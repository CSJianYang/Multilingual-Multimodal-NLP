[
    {
        "title": "Wildcard Matching",
        "question_content": "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n\t'?' Matches any single character.\n\t'*' Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the entire input string (not partial).\n&nbsp;\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation:&nbsp;'*' matches any sequence.\n\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation:&nbsp;'?' matches 'c', but the second letter is 'a', which does not match 'b'.\n\n&nbsp;\nConstraints:\n\n\t0 <= s.length, p.length <= 2000\n\ts contains only lowercase English letters.\n\tp contains only lowercase English letters, '?' or '*'.",
        "solutions": [
            {
                "id": 17810,
                "title": "linear-runtime-and-constant-space-solution",
                "content": "I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\n\\n----------\\n\\n\\nThe basic idea is to have one pointer for the string and one pointer for the pattern.  This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. \\n\\n\\n----------\\n\\nHere is Yu's elegant solution in C++\\n\\n     bool isMatch(const char *s, const char *p) {\\n            const char* star=NULL;\\n            const char* ss=s;\\n            while (*s){\\n                //advancing both pointers when (both characters match) or ('?' found in pattern)\\n                //note that *p will not advance beyond its length \\n                if ((*p=='?')||(*p==*s)){s++;p++;continue;} \\n\\n                // * found in pattern, track index of *, only advancing pattern pointer \\n                if (*p=='*'){star=p++; ss=s;continue;} \\n\\n                //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\\n                //only advancing pattern pointer\\n                if (star){ p = star+1; s=++ss;continue;} \\n\\n               //current pattern pointer is not star, last patter pointer was not *\\n               //characters do not match\\n                return false;\\n            }\\n \\n           //check for remaining characters in pattern\\n            while (*p=='*'){p++;}\\n\\n            return !*p;  \\n        }\\n\\n\\n----------\\n\\n\\nHere is my re-write in Java\\n\\n    \\ufeff\\ufeff\\ufeffboolean comparison(String str, String pattern) {\\n            int s = 0, p = 0, match = 0, starIdx = -1;            \\n            while (s < str.length()){\\n                // advancing both pointers\\n                if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\\n                    s++;\\n                    p++;\\n                }\\n                // * found, only advancing pattern pointer\\n                else if (p < pattern.length() && pattern.charAt(p) == '*'){\\n                    starIdx = p;\\n                    match = s;\\n                    p++;\\n                }\\n               // last pattern pointer was *, advancing string pointer\\n                else if (starIdx != -1){\\n                    p = starIdx + 1;\\n                    match++;\\n                    s = match;\\n                }\\n               //current pattern pointer is not star, last patter pointer was not *\\n              //characters do not match\\n                else return false;\\n            }\\n            \\n            //check for remaining characters in pattern\\n            while (p < pattern.length() && pattern.charAt(p) == '*')\\n                p++;\\n            \\n            return p == pattern.length();\\n    }",
                "solutionTags": [],
                "code": "I found this solution from http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\n\\n----------\\n\\n\\nThe basic idea is to have one pointer for the string and one pointer for the pattern.  This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step. \\n\\n\\n----------\\n\\nHere is Yu's elegant solution in C++\\n\\n     bool isMatch(const char *s, const char *p) {\\n            const char* star=NULL;\\n            const char* ss=s;\\n            while (*s){\\n                //advancing both pointers when (both characters match) or ('?' found in pattern)\\n                //note that *p will not advance beyond its length \\n                if ((*p=='?')||(*p==*s)){s++;p++;continue;} \\n\\n                // * found in pattern, track index of *, only advancing pattern pointer \\n                if (*p=='*'){star=p++; ss=s;continue;} \\n\\n                //current characters didn't match, last pattern pointer was *, current pattern pointer is not *\\n                //only advancing pattern pointer\\n                if (star){ p = star+1; s=++ss;continue;} \\n\\n               //current pattern pointer is not star, last patter pointer was not *\\n               //characters do not match\\n                return false;\\n            }\\n \\n           //check for remaining characters in pattern\\n            while (*p=='*'){p++;}\\n\\n            return !*p;  \\n        }\\n\\n\\n----------\\n\\n\\nHere is my re-write in Java\\n\\n    \\ufeff\\ufeff\\ufeffboolean comparison(String str, String pattern) {\\n            int s = 0, p = 0, match = 0, starIdx = -1;            \\n            while (s < str.length()){\\n                // advancing both pointers\\n                if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){\\n                    s++;\\n                    p++;\\n                }\\n                // * found, only advancing pattern pointer\\n                else if (p < pattern.length() && pattern.charAt(p) == '*'){\\n                    starIdx = p;\\n                    match = s;\\n                    p++;\\n                }\\n               // last pattern pointer was *, advancing string pointer\\n                else if (starIdx != -1){\\n                    p = starIdx + 1;\\n                    match++;\\n                    s = match;\\n                }\\n               //current pattern pointer is not star, last patter pointer was not *\\n              //characters do not match\\n                else return false;\\n            }\\n            \\n            //check for remaining characters in pattern\\n            while (p < pattern.length() && pattern.charAt(p) == '*')\\n                p++;\\n            \\n            return p == pattern.length();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17812,
                "title": "my-java-dp-solution-using-2d-table",
                "content": "    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n            match[s.length()][p.length()]=true;\\n            for(int i=p.length()-1;i>=0;i--){\\n                if(p.charAt(i)!='*')\\n                    break;\\n                else\\n                    match[s.length()][i]=true;\\n            }\\n            for(int i=s.length()-1;i>=0;i--){\\n                for(int j=p.length()-1;j>=0;j--){\\n                    if(s.charAt(i)==p.charAt(j)||p.charAt(j)=='?')\\n                            match[i][j]=match[i+1][j+1];\\n                    else if(p.charAt(j)=='*')\\n                            match[i][j]=match[i+1][j]||match[i][j+1];\\n                    else\\n                        match[i][j]=false;\\n                }\\n            }\\n            return match[0][0];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n            match[s.length()][p.length()]=true;\\n            for(int i=p.length()-1;i>=0;i--){\\n                if(p.charAt(i)!='*')\\n                    break;\\n                else\\n                    match[s.length()][i]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 138878,
                "title": "finite-state-machine-with-python-dictionary-13-lines-o-p-s-time",
                "content": "```python\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        transfer = {}\\n        state = 0\\n        \\n        for char in p:\\n            if char == \\'*\\':\\n                transfer[state, char] = state\\n            else:\\n                transfer[state, char] = state + 1\\n                state += 1\\n        \\n        accept = state\\n        states = {0}\\n        \\n        for char in s:\\n            states = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n        \\n        return accept in states\\n```\\n\\nAbout finite-state machine: https://en.wikipedia.org/wiki/Finite-state_machine\\n\\nThe string pattern matching can be seen as running a FSM. For example, you can use the following FSM to represent pattern `a*c?b`. \\nYou always start at state 0, and take each character of `s` as a \"token\". When a token matches the label on a link, you can transfer from one state to another via that link. `*` and `?` are special tokens that can match any token, or in other words, you can always transfer via a `*` or `?` link regardless of what token is fed from `s`. At the end, if you reach the final state, called the accepting state (state 4 in our example), that means you\\'ve got a match. \\n`*` and `?` are slightly different: `?` can match only 1 character, which means after you transfer via a `?` link, you can\\'t traverse it again, but after you transfer via a `*` link, you still have access to it, infinitely. This is why a `?` link takes you to a new state, while a `*` link takes you back to where it starts, thus this link can be traversed infinitely.\\nDue to the behavior of `*` links, you may have access to multiple states from a certain state. E.g. at state 1 below, with a token `c` you can transfer via the `c` link and arrive at 2, or transfer via the `*` link to arrive back at state 1. As a result, you can be at multiple states simultenaously (think of parallel universes). Among all the states you \"can be at\", you only need one of them being the accepting state to conclude a successful match.\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/guozhenli/image_1529467714.png)\\n\\nThe first `for` loop builds up a FSM from `p`. The states of the machine are labeled as 0, 1, 2, ... The last state reached during the FSM building is the accepting state.\\n\\nThe second `for` loop scans string `s` and run the FSM, by tracking what `states` the machine is at, and what `token` is read from `s`. The `*` and `?` tokens are always available. Because you can be at multiple states at the same time, in the second loop the `states` variable is a set of integers, rather than a single integer.\\n\\nFinally, if any of the state the FSM has reached matches the accepting state, we can conclude `s` and `p` match, otherwise they don\\'t match.\\n\\n\\n\\nThe first loop (FSM building) takes O(p) time. The second loop (string scanning) iterates over `s` once, thus O(s) iterations. Overall there are O(p+s) iterations. However, more strictly speaking in each iteration of the `for char in s` loop, you also iterate through all states you may be at (`for at in states`), which can be as many interations as the number of `*`\\'s in `p`, which is bounded by p. Thus the overall complexity in worst case is O(p+sp). If you believe the number of `*`\\'s in `p` can be bounded by a constant, then the overall complexity can be reduced to O(p+s).\\n\\nThe FSM diagram was drawn with [Finite State Machine Designer - by Evan Wallace](http://madebyevan.com/fsm/).\\n\\n**[Update 2020-02-08]**\\n\\nThanks to the very insightful comments from @ericauld , I\\'m realizing the connections between the FSM solution and DP solutions. I really like this finding so I\\'m happily writing it down with some visualization.\\n\\nQuote @ericauld\\n> it\\'s nice to think of it as a decision tree with nodes corresponding to pairs (state, location in s). That leaves the approach open to different types of solutions, and makes the problem more clear. We can traverse this decision tree in breadth-first fashion, as you do, or in depth-first fashion, as other solutions do. I think saying \"you can be in multiple states at the same time\" obscures what\\'s really going on and is confusing. Thanks for helping me think of the problem more clearly.\\n\\nTo visualize this, imagine matching string `acccb` with pattern `a*c?b` again. The FSM is set up the same as above, and your journey down the path will look like this:\\n![image](https://assets.leetcode.com/users/guozhenli/image_1581232923.png)\\nEach node in this diagram means <state in FSM, substring matched so far>. Starting at 0, where your only choice with string token \\'a\\' is to match with \\'a\\' in pattern, and arrive at state 1. At state 1, you have the next token in `s` -- \\'c\\' to work with, and your choices are to mathch it with \\'\\\\*\\' thus circle back to state 1 (the \\'c=\\\\*\\' arrow), or to match \\'c\\' of `s` with \\'c\\' of `p` and go to state 2 (the \\'c=c\\' arrow). In either case, you\\'ve matched \\'ac\\' so far. Keep doing this, when you\\'ve used all tokens in `s` you\\'re at the leaves to the right-most side, and the states you could be at are {1, 3, 4}, which is actually the final value of `states` at `return` time in my code above. Among these states, 4 is an accepting state, so we return `True`.\\n\\nNow that nodes in the same column/depth of this decision tree have the same \"substring matched so far\" value, bring them up to top, make a row for each state, and mark every valid node with a \"T\", we get:\\n|   | \\'\\' | a | ac | acc | accc | acccb |\\n|---|----|---|----|-----|------|-------|\\n| 0 | T  |   |    |     |      |       |\\n| 1 |    | T | T  | T   | T    | T     |\\n| 2 |    |   | T  | T   | T    |       |\\n| 3 |    |   |    | T   | T    | T     |\\n| 4 |    |   |    |     |      | T     |\\n\\nHere you go the DP table! Other DP solutions essentially fill this table row-by-row from top down (DFS), and the FSM solution essentially fills it column-by-column from left to right (BFS).\\n\\n**[Update 2020-07-08]**\\nA few slight changes to squeeze some performance:\\nThe line `states = ...` changed from\\n```python\\nstates = set([transfer.get((at, token)) for at in states for token in [char, \\'*\\', \\'?\\']])\\n```\\nto\\n```python\\nstates = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n```\\n\\n3 things happened here:\\n1. `set([...])` to `{...}` -- to avoid creating a list before converting it to a set; instead, construct a set directly\\n2. `for at in states` to `for at in states if at is not None` -- to avoid executing `transfer.get((None, token))`, which we know is not any useful, potentially many times. (Thanks to comment from @Xyzzy123 for pointing out this inefficiency.)\\n3. `token in [char, \\'*\\', \\'?\\']` to `for token in (char, \\'*\\', \\'?\\')` -- because [constructing a tuple is faster than cosntructing a list](https://stackoverflow.com/questions/3340539/why-is-tuple-faster-than-list-in-python)",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        transfer = {}\\n        state = 0\\n        \\n        for char in p:\\n            if char == \\'*\\':\\n                transfer[state, char] = state\\n            else:\\n                transfer[state, char] = state + 1\\n                state += 1\\n        \\n        accept = state\\n        states = {0}\\n        \\n        for char in s:\\n            states = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n        \\n        return accept in states\\n```\n```python\\nstates = set([transfer.get((at, token)) for at in states for token in [char, \\'*\\', \\'?\\']])\\n```\n```python\\nstates = {transfer.get((at, token)) for at in states if at is not None for token in (char, \\'*\\', \\'?\\')}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001130,
                "title": "c-clean-and-concise-bottom-up-dp-code-with-detailed-explanation-easy-to-understand",
                "content": "This question is similar to [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), and both question can be solved using dynamic programming.\\n\\nFirst, we need to create a 2d dp table `dp`. The size of this table is `(s.size() + 1) * (p.size() + 1)`. We introduce `+1` here to better handle the edge cases where we have an empty string or an empty pattern. `dp[i][j]` means whether the substring from index `0` to `i - 1` of the original string `s` matches with the subpattern from index `0` to `j - 1` of the original pattern `p`.\\n\\nNext, we initialize the base cases. There are three base cases:\\n1. **When both the string and the pattern are empty.**\\n\\tAlways match. `dp[0][0] = true;`\\n2. **When only the string is empty.**\\n\\tOnly if the subpattern only consists of  `*`, we have a match. \\n3. **When only the pattern is empty.**\\n\\tAlways not match.\\n\\t\\nThere are two special characters that we need to take special care in the pattern.\\n1. `?`\\n\\tThis is actually easy to deal with. Everytime when we encounter this, we can consider it matches with any character in the string. Say we are currently at `dp[i][j]`, and we have `p[j - 1] == \\'?\\'`, then we know it matches with `s[i - 1]`, no matter what `s[i - 1]` actually is.\\n2. `*`\\n\\tThis is slightly hard to deal with. A small technique while dealing this kind of question is to actually draw out the dp table, and try to fill out the table manually, when the state transfer function is not very straightforward. Everything will become much clearer after you fill out one row or two.\\n\\tWhen we encounter a `*` in the pattern, and assuming that we\\'re currently trying to figure out what `dp[i][j]` is. Then we need to consider two cases if `p[j - 1] == \\'*\\'`.\\n\\t1. **Is `dp[i - 1][j]` true?**\\n\\t\\tIf yes, it means the current subpattern `p[0...j - 1]` we have matches the substring `s[0... i - 2]`. Then will `p[0...j - 1]` match with `s[0... i - 1]`? The answer is yes, because `*` can match any sequence of characters, so it\\'s able to match one more character `s[i - 1]`.\\n\\t2. **Is `dp[i][j - 1]` true?**\\n\\t\\tIf yes, it just means the current substring `s[0...i - 1]` matches with the subpattern `p[0...j - 2]`. Therefore, if we add one more `*` into the subpattern, it will also match as `*` can match empty subsequence.\\n\\t\\t\\n\\n##### O(mn) space\\n**Note**: `m` means the size of the string, `n` means the size of the pattern.\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```\\n\\n##### O(n) space\\nWe can also use 1d table to solve this problem, but the code will be less readable.\\n**Note**: `n` means the size of the pattern.\\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<bool> dp(p.size() + 1, false);\\n        dp[0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            dp[0] = false;\\n            bool neighborLastRow = i == 1;\\n            for (int j = 1; j <= p.size(); ++j) {\\n                bool currLastRow = dp[j];\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[j] = currLastRow || dp[j - 1];\\n                } else {\\n                    dp[j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && neighborLastRow;\\n                }\\n                neighborLastRow = currLastRow;\\n            }\\n        }\\n\\n        return dp[p.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<bool> dp(p.size() + 1, false);\\n        dp[0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            dp[0] = false;\\n            bool neighborLastRow = i == 1;\\n            for (int j = 1; j <= p.size(); ++j) {\\n                bool currLastRow = dp[j];\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[j] = currLastRow || dp[j - 1];\\n                } else {\\n                    dp[j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && neighborLastRow;\\n                }\\n                neighborLastRow = currLastRow;\\n            }\\n        }\\n\\n        return dp[p.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 256025,
                "title": "python-dp-with-illustration",
                "content": "I had to look at other solutions for the top row, we set values to true until a non \"*\" character is found\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        dp = [[False for _ in range(len(p)+1)] for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1, len(p)+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n                \\n        for i in range(1, len(s)+1):\\n            for j in range(1, len(p)+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```\\n![image](https://assets.leetcode.com/users/etherealoptimist/image_1552687196.png)\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        dp = [[False for _ in range(len(p)+1)] for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1, len(p)+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n                \\n        for i in range(1, len(s)+1):\\n            for j in range(1, len(p)+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17833,
                "title": "accepted-c-dp-solution-with-a-trick",
                "content": "**Updated**: Since the OJ has relaxed the time constraint, the following DP solution is now accepted without the trick :-) \\n\\nWell, so many people has tried to solve this problem using DP. And almost all of them get TLE (if you see a **C++** DP solution that gets accepted, please let me know ^_^). Well, this post aims at providing an **accpted** DP solution which uses a **trick** to get around the largest test case, insteaed of a solution that is **fully correct**. So please do not give me down votes for that :-) \\n\\nLet's briefly summarize the idea of DP. We define the state `P[i][j]` to be whether `s[0..i)` matches `p[0..j)`. The state equations are as follows: \\n\\n 1. `P[i][j] = P[i - 1][j - 1] && (s[i - 1] == p[j - 1] || p[j - 1] == '?')`, if `p[j - 1] != '*'`;\\n 2. `P[i][j] = P[i][j - 1] || P[i - 1][j]`, if `p[j - 1] == '*'`.\\n\\nIf you feel confused with the second equation, you may refer to [this link][1]. There is an explanation in the comments.\\n\\nWe optimize the DP code to `O(m)` space by recording `P[i - 1][j - 1]` using a single variable `pre`.\\n\\nThe trick to avoid TLE is to hard-code the result for the largest test case by \\n\\n    if (n > 30000) return false;  \\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) { \\n            int m = s.length(), n = p.length();\\n            if (n > 30000) return false; // the trick\\n            vector<bool> cur(m + 1, false); \\n            cur[0] = true;\\n            for (int j = 1; j <= n; j++) {\\n                bool pre = cur[0]; // use the value before update\\n                cur[0] = cur[0] && p[j - 1] == '*'; \\n                for (int i = 1; i <= m; i++) {\\n                    bool temp = cur[i]; // record the value before update\\n                    if (p[j - 1] != '*')\\n                        cur[i] = pre && (s[i - 1] == p[j - 1] || p[j - 1] == '?');\\n                    else cur[i] = cur[i - 1] || cur[i];\\n                    pre = temp;\\n                }\\n            }\\n            return cur[m]; \\n        }\\n    };\\n\\nFor those interested in a fully correct solution, [this link][2] has a nice Greedy solution. And I have rewritten the code below to fit the new C++ interface (changed from `char*` to `string`).\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int m = s.length(), n = p.length();\\n            int i = 0, j = 0, asterisk = -1, match;\\n            while (i < m) {\\n                if (j < n && p[j] == '*') {\\n                    match = i; \\n                    asterisk = j++;\\n                }\\n                else if (j < n && (s[i] == p[j] || p[j] == '?')) {\\n                    i++; \\n                    j++;\\n                }\\n                else if (asterisk >= 0) {\\n                    i = ++match;\\n                    j = asterisk + 1;\\n                }\\n                else return false;\\n            }\\n            while (j < n && p[j] == '*') j++;\\n            return j == n;\\n        }\\n    };\\n\\n  [1]: https://leetcode.com/discuss/21634/c-dp-solution\\n  [2]: https://leetcode.com/discuss/10133/linear-runtime-and-constant-space-solution",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) { \\n            int m = s.length(), n = p.length();\\n            if (n > 30000) return false; // the trick\\n            vector<bool> cur(m + 1, false); \\n            cur[0] = true;\\n            for (int j = 1; j <= n; j++) {\\n                bool pre = cur[0]; // use the value before update\\n                cur[0] = cur[0] && p[j - 1] == '*'; \\n                for (int i = 1; i <= m; i++) {\\n                    bool temp = cur[i]; // record the value before update\\n                    if (p[j - 1] != '*')\\n                        cur[i] = pre && (s[i - 1] == p[j - 1] || p[j - 1] == '?');\\n                    else cur[i] = cur[i - 1] || cur[i];\\n                    pre = temp;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1336621,
                "title": "python-dfs-with-memoization-clean-concise",
                "content": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if j == len(p):  # Reach full pattern\\n                return i == len(s)\\n\\n            if i < len(s) and (s[i] == p[j] or p[j] == \\'?\\'):  # Match Single character\\n                return dfs(i + 1, j + 1)\\n            \\n            if p[j] == \\'*\\':\\n                return dfs(i, j + 1) or i < len(s) and dfs(i + 1, j)  # Match zero or one or more character\\n            \\n            return False\\n\\n        return dfs(0, 0)\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 2000` is the length of string `s`, `N <= 2000` is the length of string `t`.\\n- Space: `O(M * N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @lru_cache(None)\\n        def dfs(i, j):\\n            if j == len(p):  # Reach full pattern\\n                return i == len(s)\\n\\n            if i < len(s) and (s[i] == p[j] or p[j] == \\'?\\'):  # Match Single character\\n                return dfs(i + 1, j + 1)\\n            \\n            if p[j] == \\'*\\':\\n                return dfs(i, j + 1) or i < len(s) and dfs(i + 1, j)  # Match zero or one or more character\\n            \\n            return False\\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17859,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "This is similar to [regular expression matching ](https://discuss.leetcode.com/topic/54908/evolve-from-brute-force-to-dp) but more tricky.\\n1. Recursion O(2^n), * matches 0 or more chars.\\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) if(isMatch(k,j+1,s,p)) return 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\\n2. Use recursion instead of iteration when * matches non empty string, O(2^n)\\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') return isMatch(i,j+1,s,p) || (i<sn && isMatch(i+1,j,s,p));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\\n* java\\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\\n3. Memorization O(n^2), memorization turns out to be faster than dp. I think it is because dfs terminates as soon as a match is found but dp is always n^2.  \\n* c++\\n```\\n    bool isMatch(string s, string p) {\\n        vector<vector<char>> mem(s.size()+1,vector<char>(p.size(),-1));\\n        return isMatch(0,0,s,p,mem);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p,vector<vector<char>> &mem) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(mem[i][j]!=-1) return mem[i][j];\\n        if(p[j]==\\'*\\') return mem[i][j]= isMatch(i,j+1,s,p,mem) || (i<sn && isMatch(i+1,j,s,p,mem));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return mem[i][j]=isMatch(i+1,j+1,s,p,mem);\\n        return mem[i][j]=0;\\n    }\\n```\\n* java\\n```\\n\\tBoolean[][] mem;\\n    public boolean isMatch(String s, String p) {\\n        mem = new Boolean[s.length()+1][p.length()+1];\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        if(mem[i][j] != null) {\\n            return mem[i][j];\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return mem[i][j] = isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        }\\n        return mem[i][j] = false;\\n    }\\n```\\n4. dp O(n^2)\\n```\\n    bool isMatch(string s, string p) {\\n        int sn = s.size(), pn = p.size();\\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\\n        dp[sn][pn]=1;\\n        for(int i=sn;i>=0;i--)\\n            for(int j=pn-1;j>=0;j--)\\n                if(p[j]==\\'*\\') dp[i][j] = dp[i][j+1]||(i<sn && dp[i+1][j]);\\n                else dp[i][j] = i<sn && (p[j]==\\'?\\'|| s[i]==p[j]) && dp[i+1][j+1]; \\n        return dp[0][0];    \\n    }\\n```\\n5. For most recursion to dp problems, we are done. However, we can still do better in this problem. For each star, we match it incrementally with 0, 1, 2 ... chars. If a path fails, we only need to backtrack from the last star. Backtracking from earlier stars eats more chars in s and leaves a shorter string for the last star. This does not create any more choices for the last star. More formally, \\n\\n\\t*Say we use #1 and have 2 stars in p separated by characters. When we reach the 2nd star for the first time, there is a match right before it between s(0...i) and p(0......j). s(0...i) is the first/shortest substring that matches p(0...j) because we match  to chars incrementally. Matching the 2nd star starts from s[i+1]. If we backtrack the 1st star and match it with more characters then the next time when s(0...k) matche s p(0...j), k must be larger than i. At this point, matching the 2nd star starts from s[k+1]. Since k>i, so it is covered by just backtracking the 2nd star. Therefore backtracking the 1st star does not create more opportunities and we can ignore it.*\\n\\n* c++ Code is based on #1.\\n```\\n    bool isMatch(string s, string p) {\\n        bool star = 0;\\n        return isMatch(star,0,0,s,p);    \\n    }\\n    bool isMatch(bool& star, int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) {\\n                if(isMatch(star,k,j+1,s,p)) return 1;\\n                if(star) return 0;\\n            }\\n            star = 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(star,i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\\n* java\\n```\\n\\t int lastStar;\\n    public boolean isMatch(String s, String p) {\\n        lastStar = -1;\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            lastStar = j;\\n            return isMatch(i,s,j+1,p) || i<sn && j==lastStar && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\\n6. Iterative backtracking O(n^2), same as #4. [Idea is from the top solution](https://discuss.leetcode.com/topic/3040/linear-runtime-and-constant-space-solution)\\n```\\n    bool isMatch(string s, string p) {\\n        int i=0,j=0,star=-1,si=0;\\n        while(i<s.size()) {\\n            if(p[j]==\\'?\\'||s[i]==p[j]) {\\n                i++;\\n                j++;\\n            } else if (p[j]==\\'*\\') {\\n                star = j++;\\n                si = i;\\n            } else if (star >=0 ) {\\n                i = ++si;\\n                j = star+1;\\n            } else return 0;\\n        }\\n        while(j<p.size()) if(p[j++]!=\\'*\\') return 0;\\n        return 1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) if(isMatch(k,j+1,s,p)) return 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        return isMatch(0,0,s,p);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') return isMatch(i,j+1,s,p) || (i<sn && isMatch(i+1,j,s,p));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return isMatch(i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\n```\\n\\tpublic boolean isMatch(String s, String p) {\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        vector<vector<char>> mem(s.size()+1,vector<char>(p.size(),-1));\\n        return isMatch(0,0,s,p,mem);    \\n    }\\n    bool isMatch(int i, int j, string& s, string& p,vector<vector<char>> &mem) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(mem[i][j]!=-1) return mem[i][j];\\n        if(p[j]==\\'*\\') return mem[i][j]= isMatch(i,j+1,s,p,mem) || (i<sn && isMatch(i+1,j,s,p,mem));\\n        if(i<sn && (p[j]==\\'?\\'|| s[i]==p[j])) return mem[i][j]=isMatch(i+1,j+1,s,p,mem);\\n        return mem[i][j]=0;\\n    }\\n```\n```\\n\\tBoolean[][] mem;\\n    public boolean isMatch(String s, String p) {\\n        mem = new Boolean[s.length()+1][p.length()+1];\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        if(mem[i][j] != null) {\\n            return mem[i][j];\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            return mem[i][j] = isMatch(i,s,j+1,p) || i<sn && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return mem[i][j] = isMatch(i+1, s, j+1, p);\\n        }\\n        return mem[i][j] = false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        int sn = s.size(), pn = p.size();\\n        vector<vector<bool>> dp(sn+1,vector<bool>(pn+1));\\n        dp[sn][pn]=1;\\n        for(int i=sn;i>=0;i--)\\n            for(int j=pn-1;j>=0;j--)\\n                if(p[j]==\\'*\\') dp[i][j] = dp[i][j+1]||(i<sn && dp[i+1][j]);\\n                else dp[i][j] = i<sn && (p[j]==\\'?\\'|| s[i]==p[j]) && dp[i+1][j+1]; \\n        return dp[0][0];    \\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        bool star = 0;\\n        return isMatch(star,0,0,s,p);    \\n    }\\n    bool isMatch(bool& star, int i, int j, string& s, string& p) {\\n        int sn = s.size();\\n        if(j==p.size()) return i==sn;\\n        if(p[j]==\\'*\\') {\\n            for(int k=i;k<=sn;k++) {\\n                if(isMatch(star,k,j+1,s,p)) return 1;\\n                if(star) return 0;\\n            }\\n            star = 1;\\n            return 0;\\n        }\\n        if(i<sn && (p[j]==\\'?\\'||s[i]==p[j])) return isMatch(star,i+1,j+1,s,p);\\n        return 0;\\n    }\\n```\n```\\n\\t int lastStar;\\n    public boolean isMatch(String s, String p) {\\n        lastStar = -1;\\n        return isMatch(0, s, 0, p);\\n    }\\n    private boolean isMatch(int i, String s, int j, String p) {\\n        int sn = s.length(), pn = p.length();\\n        if(j==pn) {\\n            return i==sn;\\n        }\\n        char pj = p.charAt(j);\\n        if(i<sn && pj == \\'?\\') {\\n            return isMatch(i+1, s, j+1, p);\\n        } else if(pj == \\'*\\') {\\n            lastStar = j;\\n            return isMatch(i,s,j+1,p) || i<sn && j==lastStar && isMatch(i+1,s,j,p);   \\n        } else if(i<sn && pj == s.charAt(i)) {\\n            return isMatch(i+1, s, j+1, p);\\n        }\\n        return false;\\n    }\\n```\n```\\n    bool isMatch(string s, string p) {\\n        int i=0,j=0,star=-1,si=0;\\n        while(i<s.size()) {\\n            if(p[j]==\\'?\\'||s[i]==p[j]) {\\n                i++;\\n                j++;\\n            } else if (p[j]==\\'*\\') {\\n                star = j++;\\n                si = i;\\n            } else if (star >=0 ) {\\n                i = ++si;\\n                j = star+1;\\n            } else return 0;\\n        }\\n        while(j<p.size()) if(p[j++]!=\\'*\\') return 0;\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17845,
                "title": "python-dp-solution",
                "content": "    class Solution:\\n    # @return a boolean\\n    def isMatch(self, s, p):\\n        length = len(s)\\n        if len(p) - p.count('*') > length:\\n            return False\\n        dp = [True] + [False]*length\\n        for i in p:\\n            if i != '*':\\n                for n in reversed(range(length)):\\n                    dp[n+1] = dp[n] and (i == s[n] or i == '?')\\n            else:\\n                for n in range(1, length+1):\\n                    dp[n] = dp[n-1] or dp[n]\\n            dp[0] = dp[0] and i == '*'\\n        return dp[-1]\\n\\ndp[n] means the substring s[:n] if match the pattern i\\n\\ndp[0] means the empty string '' or s[:0] which only match the pattern '*'\\n\\nuse the reversed builtin because for every dp[n+1] we use the previous 'dp'\\n\\n\\n\\nadd Java O(m*n) version code\\n\\n    public boolean isMatch(String s, String p) {\\n        int count = 0;\\n        for (char c : p.toCharArray()) {\\n            if (c == '*')\\n                count++;\\n        }\\n        if (p.length() - count > s.length())\\n            return false;\\n        boolean[][] dp = new boolean[p.length() + 1][s.length() + 1];\\n        dp[0][0] = true;\\n        for (int j = 1; j <= p.length(); j++) {\\n            char pattern = p.charAt(j - 1);\\n            dp[j][0] = dp[j - 1][0] && pattern == '*';\\n            for (int i = 1; i <= s.length(); i++) {\\n                char letter = s.charAt(i - 1);\\n                if (pattern != '*') {\\n                    dp[j][i] = dp[j - 1][i - 1] && (pattern == '?' || pattern == letter);\\n                } else\\n                    dp[j][i] = dp[j][i - 1] || dp[j - 1][i];\\n            }\\n        }\\n        return dp[p.length()][s.length()];\\n    }",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @return a boolean\\n    def isMatch(self, s, p):\\n        length = len(s)\\n        if len(p) - p.count('*') > length:\\n            return False\\n        dp = [True] + [False]*length\\n        for i in p:\\n            if i != '*':\\n                for n in reversed(range(length)):\\n                    dp[n+1] = dp[n] and (i == s[n] or i == '?')\\n            else:\\n                for n in range(1, length+1):\\n                    dp[n] = dp[n-1] or dp[n]\\n            dp[0] = dp[0] and i == '*'\\n        return dp[-1]\\n\\ndp[n] means the substring s[:n] if match the pattern i\\n\\ndp[0] means the empty string '' or s[:0] which only match the pattern '*'\\n\\nuse the reversed builtin because for every dp[n+1] we use the previous 'dp'\\n\\n\\n\\nadd Java O(m*n) version code\\n\\n    public boolean isMatch(String s, String p) {\\n        int count = 0;\\n        for (char c : p.toCharArray()) {\\n            if (c == '*')\\n                count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17811,
                "title": "my-three-c-solutions-iterative-16ms-dp-180ms-modified-recursion-88ms",
                "content": "The reason that the iterative solution is much faster for this case is we only need to save (and deal with) the positions (iStar for s, jStar for p) of the last \"*\" we met. We only need to do traceback using iStar and jStar and all the previous \"*\" can be ignored since the last \"*\" will cover all the traceback cases for the previous \"*\". \\nWhat we need to do are\\n\\n - if the current p character is '*' (i.e. p[j]=='*'), then we update iStar and jStar with the cureent i and j values. iStar/jStar will be used for traceback. Also we do --i to start the depth first search with the case that '*' represents a null string.\\n - if p[j]!='*', then we check if mismatch occurs (i.e. p[j]!=s[i] and p[j]!='?'), if so we check if we met a '*' before (iStar>=0), if not, then we return false since no match can achieve. Otherwise, we traceback to the positions at which the last '*' happens and do the next possible dfs search (i.e.  i = iStar++;  j = jStar; remember to update iStar too to save the i position to try in the next traceback).\\n - The loop will quit when we reach the end of s. At last, we need to skip all the '*' in p to see if we can reach the end of p. if so, match, otherwise mismatch\\n\\n------------------------------------------------------------------------------------------------\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int  slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1;\\n    \\n            for(i=0,j=0 ; i<slen; ++i, ++j)\\n            {\\n                if(p[j]=='*')\\n                { //meet a new '*', update traceback i/j info\\n                    iStar = i;\\n                    jStar = j;\\n                    --i;\\n                }\\n                else\\n                { \\n                    if(p[j]!=s[i] && p[j]!='?')\\n                    {  // mismatch happens\\n                        if(iStar >=0)\\n                        { // met a '*' before, then do traceback\\n                            i = iStar++;\\n                            j = jStar;\\n                        }\\n                        else return false; // otherwise fail\\n                    }\\n                }\\n            }\\n            while(p[j]=='*') ++j;\\n            return j==plen;\\n        }\\n    };\\n\\nA DP solution is also given here. It has O(N^2) time complexity and O(N) space\\n\\n    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int pLen = p.size(), sLen = s.size(), i, j, k, cur, prev;\\n            if(!pLen) return sLen == 0;\\n            bool matched[2][sLen+1];\\n            fill_n(&matched[0][0], 2*(sLen+1), false);\\n            \\n            matched[0][0] = true;\\n            for(i=1; i<=pLen; ++i)\\n            {\\n                cur = i%2, prev= 1-cur;\\n                matched[cur][0]= matched[prev][0] && p[i-1]=='*';\\n                if(p[i-1]=='*') for(j=1; j<=sLen; ++j) matched[cur][j] = matched[cur][j-1] || matched[prev][j];\\n                else for(j=1; j<=sLen; ++j)            matched[cur][j] =  matched[prev][j-1] && (p[i-1]=='?' || p[i-1]==s[j-1]) ;\\n            }\\n                return matched[cur][sLen];\\n        }\\n    };\\n\\n A recursion version. A typical recursion version will give us TLE due to too many unnecessary recursive calls. As we explained, all the traceback recursive calls at the '*' we met (except the last '*') are unneccessary and should be avoided. In the below version, we use recLevel to track the recursion level (i.e the total '*' we met) and we also use curLevel to save the order of '*' we currently process. If it is not the last '*' we met (i.e  if(recLevel>curLevel+1) ), then we will return false directly ( if(recLevel>curLevel+1) return false;) to skip all unneccessary recursion call at the '*' before the last '*'.\\n\\n    class Solution {\\n    private:\\n        bool helper(const string &s, const string &p, int si, int pi, int &recLevel)\\n        {\\n            int sSize = s.size(), pSize = p.size(), i, curLevel = recLevel;\\n            bool first=true;\\n            while(si<sSize && (p[pi]==s[si] || p[pi]=='?')) {++pi; ++si;} //match as many as possible\\n            if(pi == pSize) return si == sSize; // if p reaches the end, return\\n            if(p[pi]=='*')\\n            { // if a star is met\\n                while(p[++pi]=='*'); //skip all the following stars\\n                if(pi>=pSize) return true; // if the rest of p are all star, return true\\n                for(i=si; i<sSize; ++i)\\n                {   // then do recursion\\n                    if(p[pi]!= '?' && p[pi]!=s[i]) continue;\\n                    if(first) {++recLevel; first = false;}\\n                    if(helper(s, p, i, pi, recLevel)) return true;\\n                    if(recLevel>curLevel+1) return false; // if the currently processed star is not the last one, return\\n                }\\n            }\\n            return false;\\n        }\\n    public:\\n        bool isMatch(string s, string p) {\\n            int recLevel = 0;\\n            return helper(s, p, 0, 0, recLevel);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            int  slen = s.size(), plen = p.size(), i, j, iStar=-1, jStar=-1;\\n    \\n            for(i=0,j=0 ; i<slen; ++i, ++j)\\n            {\\n                if(p[j]=='*')\\n                { //meet a new '*', update traceback i/j info\\n                    iStar = i;\\n                    jStar = j;\\n                    --i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 752350,
                "title": "recursion-brute-force-to-top-down-dp-and-bottom-up",
                "content": "We can solve this problem using recursion. The basic conditions that we need to put here is when j reaches the end of pattern length, then we need to check if the i has also reached the end or not, if not then it will return false, otherwise true.\\n\\nIf the i reaches the end of the string i.e. i=s.length(), then only when p[j]=\\' * \\'  since * can be equal to the empty sequence as well. \\n\\nWe will now check if the current charcter of pattern and string are equal or not. They would be equal if either s[i]==p[j] or p[j]=\\'?\\'. \\n\\nif the current pattern character is \\' * \\' then we have two options either to move j forward and don\\'t use it for matching or we can match and move the string index and keep the pattern index at j only. \\n\\nif the current character is not \\' * \\', then we need to check only if the first_match is true and move both the i and j index by 1.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(i==s.length())\\n            return (p[j]==\\'*\\' && helper(s,p,i,j+1));\\n        bool first_match=(i<s.length() && (p[j]==s[i] || p[j]==\\'?\\'));\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return (helper(s,p,i+1,j) || helper(s,p,i,j+1));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n```\\n\\nTop down DP solution :\\n\\nWe are solving the same subproblems many times instead we can save those problems and resuse them. We can initialize the dp array with -1 so that if it becomes postive then that means it has been solved for that i and j. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0){\\n            return (s.length()==0);\\n        }\\n        vector<vector<int>> v(s.length()+1,vector<int> (p.length()+1,-1));\\n      return  helper(s,p,0,0,v);\\n      \\n    }\\n    bool helper(string s, string p,int i,int j,vector<vector<int>> &v)\\n    {\\n        if(j==p.length())\\n            return (i==s.length());\\n        if(v[i][j]<0){\\n        if(i==s.length())\\n            v[i][j]= (p[j]==\\'*\\' && helper(s,p,i,j+1,v));\\n        else if(i<s.length() &&  (p[j]==s[i] || p[j]==\\'?\\'))\\n        {\\n           v[i][j]=  helper(s,p,i+1,j+1,v);\\n        }\\n        \\n        else if(p[j]==\\'*\\')\\n        {\\n            v[i][j]= (helper(s,p,i,j+1,v) || helper(s,p,i+1,j,v));\\n        }\\n        else\\n        v[i][j]= false;\\n        }\\n        return v[i][j];\\n    }\\n};\\n```\\n\\nBottom up solution\\n\\nWe can use bottom up approach to solve this problem. \\n\\ndp[0][0]=true or 1. it is because if the length of the pattern and matching string is 0 then, they are equal or they are a match.\\n\\nWe can fill the first row of the dp. First row of DP tells us that the matching string length is zero, then uptill which column the pattern matches the empty string. So we know that it can only happen if the pattern character at that point is \\' * \\' and if anything else comes other then a \\' * \\' then we break. \\n\\nNow, we can start filling the second row of dp, if the pattern is \\' * \\' at j-1, then either we can use it to match in that case it would be equal to dp[i-1][j] and if we use the empty string for \\' * \\' then it is equal to dp[i][j-1].\\n\\nIf the pattern at j-1 is not \\' * \\' then we need check if the characters are equal or pattern character at j-1 is \\' ? \\' then dp[i][j] =dp[i-1][j-1];\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0)\\n            return (s.length()==0);\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<=p.length();i++)\\n        {\\n            if(p[i-1]==\\'*\\')\\n                dp[0][i]=1;\\n            else\\n                break;\\n        }\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            for(int j=1;j<=p.length();j++)\\n            {\\n                if(p[j-1]==\\'*\\')\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n                }\\n                else if(p[j-1]==s[i-1] || p[j-1]==\\'?\\')\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n      \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return helper(s,p,0,0);\\n    }\\n    \\n    bool helper(string s, string p, int i, int j)\\n    {\\n        if(j==p.length())\\n            return i==s.length();\\n        if(i==s.length())\\n            return (p[j]==\\'*\\' && helper(s,p,i,j+1));\\n        bool first_match=(i<s.length() && (p[j]==s[i] || p[j]==\\'?\\'));\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return (helper(s,p,i+1,j) || helper(s,p,i,j+1));\\n        }\\n        else\\n        {\\n            return (first_match && helper(s,p,i+1,j+1));\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0){\\n            return (s.length()==0);\\n        }\\n        vector<vector<int>> v(s.length()+1,vector<int> (p.length()+1,-1));\\n      return  helper(s,p,0,0,v);\\n      \\n    }\\n    bool helper(string s, string p,int i,int j,vector<vector<int>> &v)\\n    {\\n        if(j==p.length())\\n            return (i==s.length());\\n        if(v[i][j]<0){\\n        if(i==s.length())\\n            v[i][j]= (p[j]==\\'*\\' && helper(s,p,i,j+1,v));\\n        else if(i<s.length() &&  (p[j]==s[i] || p[j]==\\'?\\'))\\n        {\\n           v[i][j]=  helper(s,p,i+1,j+1,v);\\n        }\\n        \\n        else if(p[j]==\\'*\\')\\n        {\\n            v[i][j]= (helper(s,p,i,j+1,v) || helper(s,p,i+1,j,v));\\n        }\\n        else\\n        v[i][j]= false;\\n        }\\n        return v[i][j];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        if(p.length()==0)\\n            return (s.length()==0);\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,0));\\n        dp[0][0]=1;\\n        for(int i=1;i<=p.length();i++)\\n        {\\n            if(p[i-1]==\\'*\\')\\n                dp[0][i]=1;\\n            else\\n                break;\\n        }\\n        for(int i=1;i<=s.length();i++)\\n        {\\n            for(int j=1;j<=p.length();j++)\\n            {\\n                if(p[j-1]==\\'*\\')\\n                {\\n                    dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n                }\\n                else if(p[j-1]==s[i-1] || p[j-1]==\\'?\\')\\n                {\\n                    dp[i][j]=dp[i-1][j-1];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n      \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17839,
                "title": "c-recursive-solution-16-ms",
                "content": "    class Solution {\\n        // return value:\\n        // 0: reach the end of s but unmatched\\n        // 1: unmatched without reaching the end of s\\n        // 2: matched\\n        int dfs(string& s, string& p, int si, int pi) {\\n            if (si == s.size() and pi == p.size()) return 2;\\n            if (si == s.size() and p[pi] != '*') return 0;\\n            if (pi == p.size()) return 1;\\n            if (p[pi] == '*') {\\n                if (pi+1 < p.size() and p[pi+1] == '*') \\n                    return dfs(s, p, si, pi+1); // skip duplicate '*'\\n                for(int i = 0; i <= s.size()-si; ++i) {\\n                    int ret = dfs(s, p, si+i, pi+1);\\n                    if (ret == 0 or ret == 2) return ret; \\n                }\\n            }\\n            if (p[pi] == '?' or s[si] == p[pi])\\n                return dfs(s, p, si+1, pi+1);\\n            return 1;\\n        }    \\n        \\n    public:\\n        bool isMatch(string s, string p) {\\n            return dfs(s, p, 0, 0) > 1;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\n        // return value:\\n        // 0: reach the end of s but unmatched\\n        // 1: unmatched without reaching the end of s\\n        // 2: matched\\n        int dfs(string& s, string& p, int si, int pi) {\\n            if (si == s.size() and pi == p.size()) return 2;\\n            if (si == s.size() and p[pi] != '*') return 0;\\n            if (pi == p.size()) return 1;\\n            if (p[pi] == '*') {\\n                if (pi+1 < p.size() and p[pi+1] == '*') \\n                    return dfs(s, p, si, pi+1); // skip duplicate '*'\\n                for(int i = 0; i <= s.size()-si; ++i) {\\n                    int ret = dfs(s, p, si+i, pi+1);\\n                    if (ret == 0 or ret == 2) return ret; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 17828,
                "title": "java-dp-accepted",
                "content": "    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            char[] ws = s.toCharArray();\\n            char[] wp = p.toCharArray();\\n            boolean[][] dp = new boolean[m+1][n+1];\\n            dp[0][0] = true;\\n            for (int j = 1; j <= n; j++)\\n                dp[0][j] = dp[0][j-1] && wp[j-1] == '*';\\n            for (int i = 1; i <= m; i++)\\n                dp[i][0] = false;\\n            for (int i = 1; i <= m; i++) {\\n                for (int j = 1; j <= n; j++) {\\n                \\tif (wp[j-1] == '?' || ws[i-1] == wp[j-1])\\n                \\t\\tdp[i][j] = dp[i-1][j-1];\\n                \\telse if (wp[j-1] == '*')\\n                \\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                }\\n            }\\n            return dp[m][n];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            char[] ws = s.toCharArray();\\n            char[] wp = p.toCharArray();\\n            boolean[][] dp = new boolean[m+1][n+1];\\n            dp[0][0] = true;\\n            for (int j = 1; j <= n; j++)\\n                dp[0][j] = dp[0][j-1] && wp[j-1] == '*';\\n            for (int i = 1; i <= m; i++)\\n                dp[i][0] = false;\\n            for (int i = 1; i <= m; i++) {\\n                for (int j = 1; j <= n; j++) {\\n                \\tif (wp[j-1] == '?' || ws[i-1] == wp[j-1])\\n                \\t\\tdp[i][j] = dp[i-1][j-1];\\n                \\telse if (wp[j-1] == '*')\\n                \\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1355942,
                "title": "swift-wildcard-matching-test-cases",
                "content": "```swift\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        let sArr = Array(s), pArr = Array(p)\\n        let pBools = [Bool](repeating: false, count: p.count + 1)\\n        var dp = Array(repeating: pBools, count: s.count + 1)\\n        dp[0][0] = true\\n        (0...s.count).forEach {\\n            for j in 0...p.count where j > 0 {\\n                let cp = pArr[j-1]\\n                if cp != \"*\" {\\n                    dp[$0][j] = $0 > 0 && dp[$0-1][j-1] && (cp == sArr[$0-1] || cp == \"?\")\\n                } else {\\n                    var flag = false\\n                    for k in 0...$0 where dp[k][j-1] {\\n                        flag = true\\n                    }\\n                    dp[$0][j] = flag || j == 1\\n                }\\n            }\\n        }\\n        return dp[s.count][p.count]\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.045 (0.047) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.isMatch(\"aa\",\"a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test1() {\\n        let res = s.isMatch(\"aa\",\"*\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isMatch(\"cb\",\"?a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test3() {\\n        let res = s.isMatch(\"adceb\",\"*a*b\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test4() {\\n        let res = s.isMatch(\"acdcb\",\"a*c?b\")\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        let sArr = Array(s), pArr = Array(p)\\n        let pBools = [Bool](repeating: false, count: p.count + 1)\\n        var dp = Array(repeating: pBools, count: s.count + 1)\\n        dp[0][0] = true\\n        (0...s.count).forEach {\\n            for j in 0...p.count where j > 0 {\\n                let cp = pArr[j-1]\\n                if cp != \"*\" {\\n                    dp[$0][j] = $0 > 0 && dp[$0-1][j-1] && (cp == sArr[$0-1] || cp == \"?\")\\n                } else {\\n                    var flag = false\\n                    for k in 0...$0 where dp[k][j-1] {\\n                        flag = true\\n                    }\\n                    dp[$0][j] = flag || j == 1\\n                }\\n            }\\n        }\\n        return dp[s.count][p.count]\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 5 tests, with 0 failures (0 unexpected) in 0.045 (0.047) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        let res = s.isMatch(\"aa\",\"a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test1() {\\n        let res = s.isMatch(\"aa\",\"*\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test2() {\\n        let res = s.isMatch(\"cb\",\"?a\")\\n        XCTAssertEqual(res, false)\\n    }\\n    func test3() {\\n        let res = s.isMatch(\"adceb\",\"*a*b\")\\n        XCTAssertEqual(res, true)\\n    }\\n    func test4() {\\n        let res = s.isMatch(\"acdcb\",\"a*c?b\")\\n        XCTAssertEqual(res, false)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402050,
                "title": "detailed-explaination-with-pictures-in-c-java-python-dp-top-down-tabulation",
                "content": "# Approach\\n- Here the Approach is literally same as the sum [https://leetcode.com/problems/regular-expression-matching/]() or a small improvisation of it here the \\'*\\' symbol can take any pattern that is the only difference between those two, below is the pictorical representation of the approach followed and the breifing of it is given below.\\n\\n- ![pic1.png](https://assets.leetcode.com/users/images/20f32b02-f04f-4d07-a667-a47e38e0fe02_1681159815.5575788.png)\\n\\n>- Here we can clearly see that the final DP table is completely dependent on its previous states $i.e$ given by the expression as follows -\\n`dp[i][j] = dp[i-1][j] | dp[i][j-1] | dp[i-1][j-1] ` when `p[j-1]` is\\nindicated by a \\'*\\' otherwise we go with `dp[i-1][j-1]` as the state transition. \\n\\n>- This would be the way in which we must proceed based and the prev state and the final answer would be `dp[m][n]` we always do a step down indexing for convineance purposes.\\n\\n---\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    int n=s.length();\\n        int m=p.length();\\n        bool res[m+1][n+1];\\n        memset(res,false,sizeof(res));\\n        res[0][0]=true;\\n        for(int i=1;i<=m;i++){\\n            if(p[i-1]==\\'*\\'){\\n                res[i][0]=res[i-1][0];\\n            }\\n            for(int j=1;j<=n;j++){\\n                if(p[i-1]==\\'*\\'){\\n                    res[i][j]=res[i-1][j]||res[i][j-1];\\n                }\\n                else if(p[i-1]==s[j-1]||\\'?\\'==p[i-1]){\\n                    res[i][j]=res[i-1][j-1];\\n                }\\n            }\\n        }\\n        return res[m][n];\\n    }   \\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int sIndex = 0, pIndex = 0, matchIndex = 0, starIndex = -1;\\n        \\n        while (sIndex < s.length()) {\\n            if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n                sIndex++;\\n                pIndex++;\\n            } else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n                starIndex = pIndex;\\n                matchIndex = sIndex;\\n                pIndex++;\\n            } else if (starIndex != -1) {\\n                pIndex = starIndex + 1;\\n                matchIndex++;\\n                sIndex = matchIndex;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n            pIndex++;\\n        }\\n        \\n        return pIndex == p.length();\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: #elif p_idx == p_len or p[p_idx] != s[s_idx]:\\n                if p_star == -1:\\n                    return False\\n                else:\\n                    #backtrack\\n                    p_idx = p_star + 1\\n                    s_idx = s_backtrack + 1\\n                    s_backtrack = s_idx\\n\\n        return all(p[idx] == \\'*\\' for idx in range(p_idx, p_len))\\n```\\n---\\n# Complexity\\n>- Time complexity: Here the complexity would be $O(n^2)$ as we can see that we need a 2d looping for the management of memoization using the length so $O(n^2)$.\\n\\n>- Space complexity: Here We can clearly see that we need a 2D dp so the space complexity will also be $O(n^2)$ and which can be further optimised to $O(n)$ by using space optimisation in Dp as the final states and previous states differ by one index.\\n\\n\\n---\\n\\nIF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/0ba8ee63-53aa-40f7-994a-663b1bc3c77f_1681159079.630099.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n    int n=s.length();\\n        int m=p.length();\\n        bool res[m+1][n+1];\\n        memset(res,false,sizeof(res));\\n        res[0][0]=true;\\n        for(int i=1;i<=m;i++){\\n            if(p[i-1]==\\'*\\'){\\n                res[i][0]=res[i-1][0];\\n            }\\n            for(int j=1;j<=n;j++){\\n                if(p[i-1]==\\'*\\'){\\n                    res[i][j]=res[i-1][j]||res[i][j-1];\\n                }\\n                else if(p[i-1]==s[j-1]||\\'?\\'==p[i-1]){\\n                    res[i][j]=res[i-1][j-1];\\n                }\\n            }\\n        }\\n        return res[m][n];\\n    }   \\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int sIndex = 0, pIndex = 0, matchIndex = 0, starIndex = -1;\\n        \\n        while (sIndex < s.length()) {\\n            if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n                sIndex++;\\n                pIndex++;\\n            } else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n                starIndex = pIndex;\\n                matchIndex = sIndex;\\n                pIndex++;\\n            } else if (starIndex != -1) {\\n                pIndex = starIndex + 1;\\n                matchIndex++;\\n                sIndex = matchIndex;\\n            } else {\\n                return false;\\n            }\\n        }\\n        \\n        while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n            pIndex++;\\n        }\\n        \\n        return pIndex == p.length();\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s_len, p_len, p_idx, s_idx, p_star, s_backtrack = len(s), len(p), 0, 0, -1, -1\\n        \\n        while s_idx < s_len:\\n            if p_idx < p_len and p[p_idx] in [\\'?\\', s[s_idx]]:\\n                p_idx += 1\\n                s_idx += 1\\n            elif p_idx < p_len and p[p_idx] == \\'*\\':\\n                p_star = p_idx\\n                s_backtrack = s_idx\\n                p_idx += 1\\n            else: #elif p_idx == p_len or p[p_idx] != s[s_idx]:\\n                if p_star == -1:\\n                    return False\\n                else:\\n                    #backtrack\\n                    p_idx = p_star + 1\\n                    s_idx = s_backtrack + 1\\n                    s_backtrack = s_idx\\n\\n        return all(p[idx] == \\'*\\' for idx in range(p_idx, p_len))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17950,
                "title": "fastest-non-dp-solution-with-o-1-space",
                "content": " \\n    def isWildcardMatch(self, s, p):\\n        sn, pn = len(s), len(p)\\n        si = pi = 0\\n        save_si, save_pi = None, None\\n        while si < sn:\\n            if pi < pn and (p[pi] == '?' or p[pi] == s[si]):\\n                si += 1\\n                pi += 1\\n            elif pi < pn and p[pi] == '*':\\n                # Meet \"*\", save si and pi, searching for next character\\n                save_si, save_pi = si + 1, pi\\n                pi += 1\\n            elif save_pi is not None:\\n                # Dead end, restore si and pi, carry on.\\n                si, pi = save_si, save_pi\\n            else:\\n                return False\\n        # Check trailing \"*\"\\n        return p[pi:].count(\"*\") == pn - pi",
                "solutionTags": [
                    "Python"
                ],
                "code": " \\n    def isWildcardMatch(self, s, p):\\n        sn, pn = len(s), len(p)\\n        si = pi = 0\\n        save_si, save_pi = None, None\\n        while si < sn:\\n            if pi < pn and (p[pi] == '?' or p[pi] == s[si]):\\n                si += 1\\n                pi += 1\\n            elif pi < pn and p[pi] == '*':\\n                # Meet \"*\", save si and pi, searching for next character\\n                save_si, save_pi = si + 1, pi\\n                pi += 1\\n            elif save_pi is not None:\\n                # Dead end, restore si and pi, carry on.\\n                si, pi = save_si, save_pi\\n            else:\\n                return False\\n        # Check trailing \"*\"\\n        return p[pi:].count(\"*\") == pn - pi",
                "codeTag": "Python3"
            },
            {
                "id": 17904,
                "title": "java-solution-o-n-2-dp-solution-with-some-explanations",
                "content": "I had a solution for \"Regular Expression Matching\" problem: https://leetcode.com/discuss/66032/java-solution-o-n-2-dp-with-some-explanations.\\n\\nSlight change to that solution gives an O(n^3) DP solution for this \"Wildcard Matching\" problem:\\n\\n    // O(n^3) DP solution for understanding the algorightm:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) '*' is the first character in p;\\n                    // (2) For k>=0 and k<=i, there is some dp[k][j-1] being true;\\n                    //     and '*' will match the rest sequence in s after index k;\\n                    boolean flag = false;\\n                    for(int k=i; k>=0; k--) { flag = dp[k][j-1]; if(flag) break;};\\n                    \\n                    dp[i][j] = j==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }\\n\\nBased on the same idea, I transposed the dp[][] matric and got the O(n^2) DP solution:\\n\\n    // O(n^2) DP solution with dp[][] matric transposed:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[pL+1][sL+1];\\n        dp[0][0] = true;\\n\\n        for(int i=1; i<=pL; i++) {\\n            boolean flag = false; // The flag is moved here;\\n\\n            for(int j=0; j<=sL; j++) {\\n                flag = flag || dp[i-1][j];\\n                char c = p.charAt(i-1);\\n                \\n                if(c != '*') {\\n                    dp[i][j] = j>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(j-1));\\n                }\\n                else {\\n                    // For k>=0 and k<=j, if any dp[i-1][k] is true,\\n                    // then '*' will match the rest sequence in s after index k;\\n                    dp[i][j] = i==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[pL][sL];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "I had a solution for \"Regular Expression Matching\" problem: https://leetcode.com/discuss/66032/java-solution-o-n-2-dp-with-some-explanations.\\n\\nSlight change to that solution gives an O(n^3) DP solution for this \"Wildcard Matching\" problem:\\n\\n    // O(n^3) DP solution for understanding the algorightm:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[sL+1][pL+1];\\n        dp[0][0] = true; // If s and p are \"\", isMathch() returns true;\\n        \\n        for(int i=0; i<=sL; i++) {\\n            \\n            // j starts from 1, since dp[i][0] is false when i!=0;\\n            for(int j=1; j<=pL; j++) {\\n                char c = p.charAt(j-1);\\n                \\n                if(c != '*') {\\n                    // The last character of s and p should match;\\n                    // And, dp[i-1][j-1] is true;\\n                    dp[i][j] = i>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(i-1));\\n                }\\n                else {\\n                    // Two situations:\\n                    // (1) '*' is the first character in p;\\n                    // (2) For k>=0 and k<=i, there is some dp[k][j-1] being true;\\n                    //     and '*' will match the rest sequence in s after index k;\\n                    boolean flag = false;\\n                    for(int k=i; k>=0; k--) { flag = dp[k][j-1]; if(flag) break;};\\n                    \\n                    dp[i][j] = j==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[sL][pL];\\n    }\\n\\nBased on the same idea, I transposed the dp[][] matric and got the O(n^2) DP solution:\\n\\n    // O(n^2) DP solution with dp[][] matric transposed:\\n    public boolean isMatch(String s, String p) {\\n        int sL = s.length(), pL = p.length();\\n        \\n        boolean[][] dp = new boolean[pL+1][sL+1];\\n        dp[0][0] = true;\\n\\n        for(int i=1; i<=pL; i++) {\\n            boolean flag = false; // The flag is moved here;\\n\\n            for(int j=0; j<=sL; j++) {\\n                flag = flag || dp[i-1][j];\\n                char c = p.charAt(i-1);\\n                \\n                if(c != '*') {\\n                    dp[i][j] = j>0 && dp[i-1][j-1] && (c=='?' || c==s.charAt(j-1));\\n                }\\n                else {\\n                    // For k>=0 and k<=j, if any dp[i-1][k] is true,\\n                    // then '*' will match the rest sequence in s after index k;\\n                    dp[i][j] = i==1 || flag;\\n                }\\n            }\\n        }\\n        \\n        return dp[pL][sL];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17836,
                "title": "my-java-dp-solution",
                "content": "At first I cannot pass the the long 'aaa...' test case. Then I add more check and pass it.\\n\\n    public class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') count++;\\n            }\\n            if (count==0 && m != n) return false;\\n            else if (n - count > m) return false;\\n            \\n            boolean[] match = new boolean[m+1];\\n            match[0] = true;\\n            for (int i = 0; i < m; i++) {\\n                match[i+1] = false;\\n            }\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') {\\n                    for (int j = 0; j < m; j++) {\\n                        match[j+1] = match[j] || match[j+1]; \\n                    }\\n                } else {\\n                    for (int j = m-1; j >= 0; j--) {\\n                        match[j+1] = (p.charAt(i) == '?' || p.charAt(i) == s.charAt(j)) && match[j];\\n                    }\\n                    match[0] = false;\\n                }\\n            }\\n            return match[m];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            int m = s.length(), n = p.length();\\n            int count = 0;\\n            for (int i = 0; i < n; i++) {\\n                if (p.charAt(i) == '*') count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 17957,
                "title": "c-dp-solution",
                "content": "It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa.............. (lots of a's...). However, despite this very large case my DP solution passes all other cases. The idea is:\\n\\nf(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is:\\n\\n    1). if(p[j-1]!='*') f(i, j) = f(i-1, j-1) && (s[i-1]==p[j-1] || p[j-1]=='?')\\n\\n    2). if(p[j-1]=='*') f(i, j) = f(i, j-1) || f(i-1, j)\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m = strlen(s);\\n        const int n = strlen(p);\\n        if(m>30000) return false; // to skip the large test case\\n        vector<bool> prev(n+1,false); // to save space, just O(n) space is used\\n        prev[0]=true;\\n        for(int j=1; j<=n; j++)\\n            prev[j] = prev[j-1] && p[j-1]=='*';\\n        for(int i=1; i<=m; i++) {\\n            vector<bool> cur(n+1,false);\\n            for(int j=1; j<=n; j++) {\\n                if(p[j-1]=='*') {\\n                    cur[j] = cur[j-1] || prev[j];\\n                }\\n                else {\\n                    cur[j] = prev[j-1] && (s[i-1]==p[j-1] || p[j-1]=='?');\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n\\n> Equation 1). means that if p[j-1] is not *, f(i,j) is determined\\n> by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or\\n> p[j-1]=='?'). \\n> \\n> Equation 2). means that if p[j-1] is *, f(i,j) is true if either\\n> f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not used\\n> here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is\\n> used to match s[i-1].",
                "solutionTags": [],
                "code": "It seems that only Greedy solution can pass all test cases (sorry if I omit any DP solution that passes all test cases). My DP solution also fails to pass the s=aaaaaaaaaaaaaa.............. (lots of a's...). However, despite this very large case my DP solution passes all other cases. The idea is:\\n\\nf(i,j) == whether the first i chars of s match the first j chars of p. The transition equation is:\\n\\n    1). if(p[j-1]!='*') f(i, j) = f(i-1, j-1) && (s[i-1]==p[j-1] || p[j-1]=='?')\\n\\n    2). if(p[j-1]=='*') f(i, j) = f(i, j-1) || f(i-1, j)\\n\\n    bool isMatch(const char *s, const char *p) {\\n        const int m = strlen(s);\\n        const int n = strlen(p);\\n        if(m>30000) return false; // to skip the large test case\\n        vector<bool> prev(n+1,false); // to save space, just O(n) space is used\\n        prev[0]=true;\\n        for(int j=1; j<=n; j++)\\n            prev[j] = prev[j-1] && p[j-1]=='*';\\n        for(int i=1; i<=m; i++) {\\n            vector<bool> cur(n+1,false);\\n            for(int j=1; j<=n; j++) {\\n                if(p[j-1]=='*') {\\n                    cur[j] = cur[j-1] || prev[j];\\n                }\\n                else {\\n                    cur[j] = prev[j-1] && (s[i-1]==p[j-1] || p[j-1]=='?');\\n                }\\n            }\\n            prev = cur;\\n        }\\n        return prev[n];\\n    }\\n\\n> Equation 1). means that if p[j-1] is not *, f(i,j) is determined\\n> by if s[0:i-2] matches p[0:j-2] and if (s[i-1]==p[j-1] or\\n> p[j-1]=='?'). \\n> \\n> Equation 2). means that if p[j-1] is *, f(i,j) is true if either\\n> f(i,j-1) is true: s[0:i-1] matches p[0:j-2] and * is not used\\n> here; or f(i-1,j) is true: s[0:i-2] matches p[0:j-1] and * is\\n> used to match s[i-1].",
                "codeTag": "Unknown"
            },
            {
                "id": 2242620,
                "title": "c-recursion-memoization-tabulation",
                "content": "**RECURSION (TLE)**\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string &s,string &p)\\n    {\\n        if(i<0 && j<0) return true;\\n        if(j<0 && i>=0) return false;\\n        if(i<0 && j>=0)\\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') j--;\\n                else return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(s[i]==p[j] || p[j]==\\'?\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return f(i-1,j,s,p) || f(i,j-1,s,p);\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```\\n**Memoization**\\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j, string &s,string &p,vector<vector<int>> &dp)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(i==0 && j==0) return dp[i][j]=1;\\n        if(j==0 && i>0) return dp[i][j]=0;\\n        if(i==0 && j>0)\\n        {\\n            while(j>0)\\n            {\\n                if(p[j-1]==\\'*\\') j--;\\n                else return dp[i][j]=0;\\n            }\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\') return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        \\n        if(p[j-1]==\\'*\\')\\n        {\\n            return dp[i][j] = f(i-1,j,s,p,dp) || f(i,j-1,s,p,dp) ? 1:0;\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return dp[i][j]=0;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(n,m,s,p,dp);\\n    }\\n};\\n```\\n**Tabulation**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            dp[0][i]=flag;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\\n**Space Optimized**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        // vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        \\n        vector<bool> prev(m+1);\\n        //Initially prev is for n=0\\n        prev[0]=true;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            prev[i]=flag;\\n        }\\n        vector<bool> curr(m+1);\\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            curr[0]=false;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    curr[j]=prev[j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    curr[j] = prev[j] || curr[j-1];\\n                else curr[j]=false;\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string &s,string &p)\\n    {\\n        if(i<0 && j<0) return true;\\n        if(j<0 && i>=0) return false;\\n        if(i<0 && j>=0)\\n        {\\n            while(j>=0)\\n            {\\n                if(p[j]==\\'*\\') j--;\\n                else return false;\\n            }\\n            return true;\\n        }\\n        \\n        if(s[i]==p[j] || p[j]==\\'?\\') return f(i-1,j-1,s,p);\\n        \\n        if(p[j]==\\'*\\')\\n        {\\n            return f(i-1,j,s,p) || f(i,j-1,s,p);\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return false;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        return f(n-1,m-1,s,p);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int i,int j, string &s,string &p,vector<vector<int>> &dp)\\n    {\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(i==0 && j==0) return dp[i][j]=1;\\n        if(j==0 && i>0) return dp[i][j]=0;\\n        if(i==0 && j>0)\\n        {\\n            while(j>0)\\n            {\\n                if(p[j-1]==\\'*\\') j--;\\n                else return dp[i][j]=0;\\n            }\\n            return dp[i][j]=1;\\n        }\\n        \\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\') return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        \\n        if(p[j-1]==\\'*\\')\\n        {\\n            return dp[i][j] = f(i-1,j,s,p,dp) || f(i,j-1,s,p,dp) ? 1:0;\\n            //Two cases\\n            //Consider * as len=0\\n            //Give one charcter to * and remain at *\\n            //at next step it will again be decided from both these cases\\n        }\\n        return dp[i][j]=0;\\n        \\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<int>> dp(n+1,vector<int>(m+1,-1));\\n        return f(n,m,s,p,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            dp[0][i]=flag;\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(),m=p.length();\\n        // vector<vector<bool>> dp(n+1,vector<bool>(m+1));\\n        \\n        vector<bool> prev(m+1);\\n        //Initially prev is for n=0\\n        prev[0]=true;\\n        \\n        bool flag=true;\\n        for(int i=1;i<=m;i++)\\n        {\\n            if(p[i-1]!=\\'*\\')\\n                flag=false;\\n            prev[i]=flag;\\n        }\\n        vector<bool> curr(m+1);\\n        \\n        \\n        for(int i=1;i<=n;i++)\\n        {\\n            curr[0]=false;\\n            for(int j=1;j<=m;j++)\\n            {\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                    curr[j]=prev[j-1];\\n                else if(p[j-1]==\\'*\\')\\n                    curr[j] = prev[j] || curr[j-1];\\n                else curr[j]=false;\\n            }\\n            prev=curr;\\n        }\\n        return prev[m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17939,
                "title": "python-dp-solution",
                "content": "For a 2d table, dp[i][j] would mean whether sub-pattern p[:i + 1] matches sub-string s[:j + 1].\\nMost tricky part is when the current pattern letter is `*`, suppose its index is `i`, p[:i + 1] will match sub-string s[:j + 1] if p[:i + 1] matches s[:j] *or* p[:i] matches s[:j + 1], namely current cell value is true if its top or its left is true.  Since the current row only depends on the previous row, we can use two rolling lists to do the dp instead of a matrix.\\n    \\n    def isMatch(self, s, p):\\n        l = len(s)\\n        if len(p) - p.count('*') > l:\\n            return False\\n        dp = [True]  + [False] * l\\n        for letter in p:\\n            new_dp = [dp[0] and letter == '*']\\n            if letter == '*':\\n                for j in range(l):\\n                    new_dp.append(new_dp[-1] or dp[j + 1])\\n            elif letter == '?':\\n                new_dp += dp[:l]\\n            else:\\n                new_dp += [dp[j] and s[j] == letter for j in range(l)]\\n            dp = new_dp\\n        return dp[-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "For a 2d table, dp[i][j] would mean whether sub-pattern p[:i + 1] matches sub-string s[:j + 1].\\nMost tricky part is when the current pattern letter is `*`, suppose its index is `i`, p[:i + 1] will match sub-string s[:j + 1] if p[:i + 1] matches s[:j] *or* p[:i] matches s[:j + 1], namely current cell value is true if its top or its left is true.  Since the current row only depends on the previous row, we can use two rolling lists to do the dp instead of a matrix.\\n    \\n    def isMatch(self, s, p):\\n        l = len(s)\\n        if len(p) - p.count('*') > l:\\n            return False\\n        dp = [True]  + [False] * l\\n        for letter in p:\\n            new_dp = [dp[0] and letter == '*']\\n            if letter == '*':\\n                for j in range(l):\\n                    new_dp.append(new_dp[-1] or dp[j + 1])\\n            elif letter == '?':\\n                new_dp += dp[:l]\\n            else:\\n                new_dp += [dp[j] and s[j] == letter for j in range(l)]\\n            dp = new_dp\\n        return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 2874339,
                "title": "python-faster-than-90-explained-with-comments",
                "content": "# Complexity\\n- Time complexity:\\nBetter than 90%\\n\\n- Space complexity:\\nBetter than 90%\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # Initialize the pointers for the input string and the pattern\\n        i = 0\\n        j = 0\\n    \\n        # Initialize the pointers for the last character matched and the last\\n        # \\'*\\' encountered in the pattern\\n        last_match = 0\\n        star = -1\\n    \\n        # Loop through the input string and the pattern\\n        while i < len(s):\\n            # Check if the current characters in the input string and the pattern\\n            # match, or if the pattern character is a \\'?\\'\\n            if j < len(p) and (s[i] == p[j] or p[j] == \\'?\\'):\\n                # Move the pointers for the input string and the pattern forward\\n                i += 1\\n                j += 1\\n            # Check if the current pattern character is a \\'*\\'\\n            elif j < len(p) and p[j] == \\'*\\':\\n                # Store the current positions of the pointers for the input string\\n                # and the pattern\\n                last_match = i\\n                star = j\\n                # Move the pointer for the pattern forward\\n                j += 1\\n            # If none of the above conditions are met, check if we have encountered\\n            # a \\'*\\' in the pattern previously\\n            elif star != -1:\\n                # Move the pointer for the pattern back to the last \\'*\\'\\n                j = star + 1\\n                # Move the pointer for the input string to the next character\\n                # after the last character matched\\n                i = last_match + 1\\n                # Move the pointer for the last character matched forward\\n                last_match += 1\\n            # If none of the above conditions are met, the input string and the\\n            # pattern do not match\\n            else:\\n                return False\\n    \\n        # Loop through the remaining characters in the pattern and check if they\\n        # are all \\'*\\' characters\\n        while j < len(p) and p[j] == \\'*\\':\\n            j += 1\\n    \\n        # Return True if all the characters in the pattern have been processed,\\n        # False otherwise\\n        return j == len(p)\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # Initialize the pointers for the input string and the pattern\\n        i = 0\\n        j = 0\\n    \\n        # Initialize the pointers for the last character matched and the last\\n        # \\'*\\' encountered in the pattern\\n        last_match = 0\\n        star = -1\\n    \\n        # Loop through the input string and the pattern\\n        while i < len(s):\\n            # Check if the current characters in the input string and the pattern\\n            # match, or if the pattern character is a \\'?\\'\\n            if j < len(p) and (s[i] == p[j] or p[j] == \\'?\\'):\\n                # Move the pointers for the input string and the pattern forward\\n                i += 1\\n                j += 1\\n            # Check if the current pattern character is a \\'*\\'\\n            elif j < len(p) and p[j] == \\'*\\':\\n                # Store the current positions of the pointers for the input string\\n                # and the pattern\\n                last_match = i\\n                star = j\\n                # Move the pointer for the pattern forward\\n                j += 1\\n            # If none of the above conditions are met, check if we have encountered\\n            # a \\'*\\' in the pattern previously\\n            elif star != -1:\\n                # Move the pointer for the pattern back to the last \\'*\\'\\n                j = star + 1\\n                # Move the pointer for the input string to the next character\\n                # after the last character matched\\n                i = last_match + 1\\n                # Move the pointer for the last character matched forward\\n                last_match += 1\\n            # If none of the above conditions are met, the input string and the\\n            # pattern do not match\\n            else:\\n                return False\\n    \\n        # Loop through the remaining characters in the pattern and check if they\\n        # are all \\'*\\' characters\\n        while j < len(p) and p[j] == \\'*\\':\\n            j += 1\\n    \\n        # Return True if all the characters in the pattern have been processed,\\n        # False otherwise\\n        return j == len(p)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560759,
                "title": "java-easiest-solution-with-proper-comments",
                "content": "Hi Family,\\n\\nPlease have a look into the code with proper comment\\nIf you liked the code Please Please upvote !!!\\n\\n```\\nclass Solution {\\n    Boolean dp[][];\\n    public boolean isMatch(String s, String p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        dp = new Boolean[m][n];\\n        \\n        return is_match(m-1,n-1,p,s);\\n    }\\n    \\n    private boolean is_match(int m,int n,String p,String s){\\n        \\n        //Base Case\\n        //if m and n both are 0 i.e strings are matching\\n        if (m<0 && n<0) return true;\\n        \\n        // if n has some character but m is empty\\n        if (m<0 && n>=0) return false;\\n        \\n        // if m has some character but n is empty\\n        \\n        if (n<0 && m>=0) {\\n            /*\\n                if str = \"\" && pattern = \"***\" then return true;\\n                    because we can neglect the * also\\n                else str = \"\"  && pattern = \"sd**\" return false;\\n                    because after neglecting the * pattern has some more character\\n            \\n            */\\n            for (int i=0;i<=m;i++){\\n                if (p.charAt(i) != \\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        \\n        //Memorisation\\n        if (dp[m][n] != null) return dp[m][n];\\n        \\n        //if both the character is equal || patern[m] == ?\\n        if (p.charAt(m) == s.charAt(n) || p.charAt(m) == \\'?\\'){\\n            return dp[m][n] = is_match(m-1,n-1,p,s);\\n        }\\n        \\n        // if p has \\'*\\'\\n        if (p.charAt(m) == \\'*\\'){\\n            return dp[m][n] = is_match(m-1,n,p,s) || is_match(m,n-1,p,s);\\n        }\\n        // if both the character is not equal\\n        return false;\\n            \\n    }\\n}\\n```\\n\\nThanks\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    Boolean dp[][];\\n    public boolean isMatch(String s, String p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        dp = new Boolean[m][n];\\n        \\n        return is_match(m-1,n-1,p,s);\\n    }\\n    \\n    private boolean is_match(int m,int n,String p,String s){\\n        \\n        //Base Case\\n        //if m and n both are 0 i.e strings are matching\\n        if (m<0 && n<0) return true;\\n        \\n        // if n has some character but m is empty\\n        if (m<0 && n>=0) return false;\\n        \\n        // if m has some character but n is empty\\n        \\n        if (n<0 && m>=0) {\\n            /*\\n                if str = \"\" && pattern = \"***\" then return true;\\n                    because we can neglect the * also\\n                else str = \"\"  && pattern = \"sd**\" return false;\\n                    because after neglecting the * pattern has some more character\\n            \\n            */\\n            for (int i=0;i<=m;i++){\\n                if (p.charAt(i) != \\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        \\n        //Memorisation\\n        if (dp[m][n] != null) return dp[m][n];\\n        \\n        //if both the character is equal || patern[m] == ?\\n        if (p.charAt(m) == s.charAt(n) || p.charAt(m) == \\'?\\'){\\n            return dp[m][n] = is_match(m-1,n-1,p,s);\\n        }\\n        \\n        // if p has \\'*\\'\\n        if (p.charAt(m) == \\'*\\'){\\n            return dp[m][n] = is_match(m-1,n,p,s) || is_match(m,n-1,p,s);\\n        }\\n        // if both the character is not equal\\n        return false;\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895500,
                "title": "dp-bottom-up-java-solution-with-detailed-explanation",
                "content": "```\\n\\t // Bottom Up DP\\n    public boolean isMatch(String s, String p) {\\n        // corner case\\n        if (s == null || p == null)\\n            return false;\\n\\n        int m = s.length();\\n        int n = p.length();\\n\\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n\\n        // 1. dp[0][0] = true, since empty string matches empty pattern\\n        dp[0][0] = true;\\n\\n        // 2. dp[0][i] = false\\n        // since empty pattern cannot match non-empty string\\n\\n        // 3. dp[j][0]\\n        // for any continuative \\'*\\' will match empty string\\n        // e.g s=\\'aasffdasda\\' p=\\'*\\'/\\'**\\'/\\'***\\'....\\n        for (int j = 1; j < n + 1; j++) {\\n            if (p.charAt(j - 1) == \\'*\\') {\\n                dp[j][0] = dp[j - 1][0];\\n            }\\n        }\\n\\n        // 1. if p.charAt(j) == s.charAt(i), match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n        // 2. if p.charAt(j) == \\'?\\', \\'?\\' match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n\\n        // 3. if p.charAt(j) == \\'*\\', dp[i][j]=dp[i-1][j]||dp[i][j-1]\\n        // =>>> a. \\'*\\' match empty: dp[i][j]=dp[i-1][j]\\n        // =>>> b. \\'*\\' match multiple characters: dp[i][j]=dp[i][j-1]\\n\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                char charS = s.charAt(i - 1);\\n                char charP = p.charAt(j - 1);\\n                if (charS == charP || charP == \\'?\\')\\n                    dp[j][i] = dp[j - 1][i - 1];\\n                else if (charP == \\'*\\')\\n                    dp[j][i] = dp[j - 1][i] || dp[j][i - 1];\\n\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\t // Bottom Up DP\\n    public boolean isMatch(String s, String p) {\\n        // corner case\\n        if (s == null || p == null)\\n            return false;\\n\\n        int m = s.length();\\n        int n = p.length();\\n\\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n\\n        // 1. dp[0][0] = true, since empty string matches empty pattern\\n        dp[0][0] = true;\\n\\n        // 2. dp[0][i] = false\\n        // since empty pattern cannot match non-empty string\\n\\n        // 3. dp[j][0]\\n        // for any continuative \\'*\\' will match empty string\\n        // e.g s=\\'aasffdasda\\' p=\\'*\\'/\\'**\\'/\\'***\\'....\\n        for (int j = 1; j < n + 1; j++) {\\n            if (p.charAt(j - 1) == \\'*\\') {\\n                dp[j][0] = dp[j - 1][0];\\n            }\\n        }\\n\\n        // 1. if p.charAt(j) == s.charAt(i), match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n        // 2. if p.charAt(j) == \\'?\\', \\'?\\' match single character\\n        // =>>> dp[i][j] = dp[i - 1][j - 1]\\n\\n        // 3. if p.charAt(j) == \\'*\\', dp[i][j]=dp[i-1][j]||dp[i][j-1]\\n        // =>>> a. \\'*\\' match empty: dp[i][j]=dp[i-1][j]\\n        // =>>> b. \\'*\\' match multiple characters: dp[i][j]=dp[i][j-1]\\n\\n        for (int i = 1; i < m + 1; i++) {\\n            for (int j = 1; j < n + 1; j++) {\\n                char charS = s.charAt(i - 1);\\n                char charP = p.charAt(j - 1);\\n                if (charS == charP || charP == \\'?\\')\\n                    dp[j][i] = dp[j - 1][i - 1];\\n                else if (charP == \\'*\\')\\n                    dp[j][i] = dp[j - 1][i] || dp[j][i - 1];\\n\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 477823,
                "title": "recursive-dfs-solution-with-memoization-top-down-approach",
                "content": "Algorithm:\\n- We have two pointers i,j pointing towards `S` and `P`.\\n- We create a dp[][] where dp[i][j]=1 indicates that 0..ith substring in `S` has been matched with 0..jth substring in `P`\\n- If s[i]==p[j] then we increment both check for s[i+1] and p[j+1]\\n- If given char in p is `*` then we have certainly three options\\n- either match the current `ith` char in with  `*` in j\\n- either end the matching of current `ith` char with `*` and increment both (i,j) -> (i+1,j+1).\\n- or match `*` with null characters and increment only `j`.\\n```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    public boolean isMatch(String s, String p) {\\n         \\n        dp = new Integer[s.length()+1][p.length()+1];\\n        dp[s.length()][p.length()] = 1;\\n        \\n        for(int i=p.length()-1;i>=0;--i){\\n            dp[s.length()][i] = p.charAt(i)==\\'*\\'? dp[s.length()][i+1]:0;\\n        }\\n        \\n        for(int j=0;j<s.length();++j){  dp[j][p.length()] = 0;}\\n        \\n        dfsHelper(s,p,0,0);\\n        return dp[0][0]==1;\\n        \\n    }\\n    \\n    private int dfsHelper(String s,String p,int sp,int pp){\\n        \\n        if(dp[sp][pp]!=null){\\n            return dp[sp][pp];\\n        }\\n        \\n        if(s.charAt(sp)==p.charAt(pp) || p.charAt(pp)==\\'?\\'){\\n            dp[sp][pp] = dfsHelper(s,p,sp+1,pp+1);\\n        }\\n        \\n        else if(p.charAt(pp)==\\'*\\'){\\n            \\n            int resultOne = dfsHelper(s,p,sp+1,pp); // matching seq with *\\n            int resultTwo = dfsHelper(s,p,sp,pp+1); // matching * with empty string\\n            int resultThree = dfsHelper(s,p,sp+1,pp+1); // end matching seq with * and inc both\\n            \\n            dp[sp][pp] = (resultOne + resultTwo + resultThree)>0 ? 1:0;\\n            \\n        }else{\\n            dp[sp][pp] = 0;\\n        }\\n        \\n        return dp[sp][pp]; \\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/arihant95/image_1578804311.png)\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Integer[][] dp;\\n    public boolean isMatch(String s, String p) {\\n         \\n        dp = new Integer[s.length()+1][p.length()+1];\\n        dp[s.length()][p.length()] = 1;\\n        \\n        for(int i=p.length()-1;i>=0;--i){\\n            dp[s.length()][i] = p.charAt(i)==\\'*\\'? dp[s.length()][i+1]:0;\\n        }\\n        \\n        for(int j=0;j<s.length();++j){  dp[j][p.length()] = 0;}\\n        \\n        dfsHelper(s,p,0,0);\\n        return dp[0][0]==1;\\n        \\n    }\\n    \\n    private int dfsHelper(String s,String p,int sp,int pp){\\n        \\n        if(dp[sp][pp]!=null){\\n            return dp[sp][pp];\\n        }\\n        \\n        if(s.charAt(sp)==p.charAt(pp) || p.charAt(pp)==\\'?\\'){\\n            dp[sp][pp] = dfsHelper(s,p,sp+1,pp+1);\\n        }\\n        \\n        else if(p.charAt(pp)==\\'*\\'){\\n            \\n            int resultOne = dfsHelper(s,p,sp+1,pp); // matching seq with *\\n            int resultTwo = dfsHelper(s,p,sp,pp+1); // matching * with empty string\\n            int resultThree = dfsHelper(s,p,sp+1,pp+1); // end matching seq with * and inc both\\n            \\n            dp[sp][pp] = (resultOne + resultTwo + resultThree)>0 ? 1:0;\\n            \\n        }else{\\n            dp[sp][pp] = 0;\\n        }\\n        \\n        return dp[sp][pp]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 899000,
                "title": "java-dp-memoization-video-explanation",
                "content": "```\\nclass Solution {\\n    // global dp array \\n    Boolean dp[][];\\n    \\n    boolean wm(String s , String p , int i , int j){\\n        // if we reach end of both string simultaneously return true\\n        if(s.length()==i && p.length() == j) return true;\\n        \\n        \\n        //if string s has ended we need to check that remaining characters in p are all asteriks.\\n        if(i == s.length()){\\n            for(int index = j;index<p.length();index++){\\n                if(p.charAt(index)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        //if string p has ended and s still remains , there is no way to match, think think!\\n        if(j == p.length() && i!=s.length())return false;\\n        \\n        //if sub problem already solved return it\\n        if(dp[i][j]!=null)return dp[i][j];\\n        \\n        boolean ans = false;\\n        \\n        if(p.charAt(j)==\\'?\\'){\\n            //using ? as a single character(go ahead in both s and p )\\n            if(wm(s,p,i+1,j+1)){\\n                ans = true;\\n            }\\n          \\n        }\\n        else if(p.charAt(j)==\\'*\\'){\\n            //using * as empty string (go ahead in just p)\\n            if(wm(s,p,i,j+1)){\\n                ans = true;\\n            }      \\n            //using * as multiple characters(go ahead in s but not p)\\n             if(wm(s,p,i+1,j)){\\n                ans = true;\\n            }\\n            // using * as single character(go ahead in both s and p)\\n             if(wm(s,p,i+1,j+1)){\\n                ans   = true;\\n            }\\n            \\n        }\\n        //if both i and j have characters then if they match go ahead in both else ans is false by default\\n        else if(p.charAt(j)==s.charAt(i) && wm(s,p,i+1,j+1)){\\n                ans= true;\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    public boolean isMatch(String s, String p) {\\n        dp = new Boolean[s.length()][p.length()];\\n        return wm (s , p , 0 , 0);\\n    }\\n}\\n```\\nVideo Explanation:\\nhttps://www.youtube.com/watch?v=x4TG1x0STNE",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    // global dp array \\n    Boolean dp[][];\\n    \\n    boolean wm(String s , String p , int i , int j){\\n        // if we reach end of both string simultaneously return true\\n        if(s.length()==i && p.length() == j) return true;\\n        \\n        \\n        //if string s has ended we need to check that remaining characters in p are all asteriks.\\n        if(i == s.length()){\\n            for(int index = j;index<p.length();index++){\\n                if(p.charAt(index)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        //if string p has ended and s still remains , there is no way to match, think think!\\n        if(j == p.length() && i!=s.length())return false;\\n        \\n        //if sub problem already solved return it\\n        if(dp[i][j]!=null)return dp[i][j];\\n        \\n        boolean ans = false;\\n        \\n        if(p.charAt(j)==\\'?\\'){\\n            //using ? as a single character(go ahead in both s and p )\\n            if(wm(s,p,i+1,j+1)){\\n                ans = true;\\n            }\\n          \\n        }\\n        else if(p.charAt(j)==\\'*\\'){\\n            //using * as empty string (go ahead in just p)\\n            if(wm(s,p,i,j+1)){\\n                ans = true;\\n            }      \\n            //using * as multiple characters(go ahead in s but not p)\\n             if(wm(s,p,i+1,j)){\\n                ans = true;\\n            }\\n            // using * as single character(go ahead in both s and p)\\n             if(wm(s,p,i+1,j+1)){\\n                ans   = true;\\n            }\\n            \\n        }\\n        //if both i and j have characters then if they match go ahead in both else ans is false by default\\n        else if(p.charAt(j)==s.charAt(i) && wm(s,p,i+1,j+1)){\\n                ans= true;\\n        }\\n        dp[i][j] = ans;\\n        return ans;\\n    }\\n    public boolean isMatch(String s, String p) {\\n        dp = new Boolean[s.length()][p.length()];\\n        return wm (s , p , 0 , 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054184,
                "title": "cpp-easy-solution-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    bool match(string& s, string& p, int i, int j, vector<vector<int>>& v){\\n        if(i==s.size()&&j==p.size())\\n            return true;\\n        else if(i==s.size()) \\n            return (p[j]==\\'*\\'&& match(s,p,i,j+1,v));\\n        else if(j==p.size())\\n            return false;\\n        \\n        if(v[i][j]!=-1) return v[i][j];\\n        \\n        if(p[j]==\\'*\\')\\n            return v[i][j]= (match(s,p,i,j+1,v)||match(s,p,i+1,j,v));\\n        \\n        if(p[j]==\\'?\\'||s[i]==p[j])\\n            return v[i][j] = match(s,p,i+1,j+1,v);\\n        \\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n       vector<vector<int>> v(s.size(), vector<int>(p.size(), -1));  \\n       return match(s,p,0,0,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool match(string& s, string& p, int i, int j, vector<vector<int>>& v){\\n        if(i==s.size()&&j==p.size())\\n            return true;\\n        else if(i==s.size()) \\n            return (p[j]==\\'*\\'&& match(s,p,i,j+1,v));\\n        else if(j==p.size())\\n            return false;\\n        \\n        if(v[i][j]!=-1) return v[i][j];\\n        \\n        if(p[j]==\\'*\\')\\n            return v[i][j]= (match(s,p,i,j+1,v)||match(s,p,i+1,j,v));\\n        \\n        if(p[j]==\\'?\\'||s[i]==p[j])\\n            return v[i][j] = match(s,p,i+1,j+1,v);\\n        \\n        return false;\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n       vector<vector<int>> v(s.size(), vector<int>(p.size(), -1));  \\n       return match(s,p,0,0,v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270729,
                "title": "java-13ms-dp-solution-with-explanation",
                "content": "This problem is simliar to [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/). The difference lies in how the ```*``` works. In the previous problem, ```*``` can only matches zero or more of its preceding element. In this problem, ```*``` can match any sequence (including empty sequence). \\nOf course, both the problems can be solved with DP, and the key is how we process ```*```.  In the previous problem, a* can be decoded as zero ```a```, one ```a``` or more ```a```. Similarly, in this problem, ```*``` can be decoded as empty sequence, one character or more character. \\nHere, we use a two demension array to denote whether substrings of ```s``` and ```p``` match. ```match[i][j]``` denotes whether ```s.substring(0, i)``` and ```p.substring(0, j)``` matches. If ```p.charAt(j)``` is not ```*```, we judge whether ```p.charAt(j)``` and ```s.charAt(i)``` matches. If ```p.charAt(j)``` is ```*```, then there could be three conditions:\\n1. ```match[i][j] = match[i][j - 1]```, i.e., ```*``` is decoded as empty sequence\\n2. ```match[i][j] = match[i - 1][j - 1]```, i.e., ```*``` is decoded as one character\\n3. ```match[i][j] = match[i - 1][j]```, i.e., ```*``` is decoded as more than one character\\n```\\npublic boolean isMatch(String s, String p) {\\n\\tboolean match[][] = new boolean[s.length() + 1][p.length() + 1];\\n\\tmatch[0][0] = true;\\n\\tfor (int i = 0; i < p.length(); i++) // judge whether the substring of p matchese empty sequence\\n\\t\\tif (p.charAt(i) == \\'*\\')\\n\\t\\t\\tmatch[0][i + 1] = match[0][i];\\n\\tfor (int i = 0; i < s.length(); i++)\\n\\t\\tfor (int j = 0; j < p.length(); j++) {\\n\\t\\t\\tif( p.charAt(j) == \\'*\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = (match[i][j + 1] | match[i + 1][j] | match[i][j]);\\n\\t\\t\\telse if( s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = match[i][j];\\n\\t\\t}\\n\\treturn match[s.length()][p.length()];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```*```\n```*```\n```*```\n```*```\n```a```\n```a```\n```a```\n```*```\n```s```\n```p```\n```match[i][j]```\n```s.substring(0, i)```\n```p.substring(0, j)```\n```p.charAt(j)```\n```*```\n```p.charAt(j)```\n```s.charAt(i)```\n```p.charAt(j)```\n```*```\n```match[i][j] = match[i][j - 1]```\n```*```\n```match[i][j] = match[i - 1][j - 1]```\n```*```\n```match[i][j] = match[i - 1][j]```\n```*```\n```\\npublic boolean isMatch(String s, String p) {\\n\\tboolean match[][] = new boolean[s.length() + 1][p.length() + 1];\\n\\tmatch[0][0] = true;\\n\\tfor (int i = 0; i < p.length(); i++) // judge whether the substring of p matchese empty sequence\\n\\t\\tif (p.charAt(i) == \\'*\\')\\n\\t\\t\\tmatch[0][i + 1] = match[0][i];\\n\\tfor (int i = 0; i < s.length(); i++)\\n\\t\\tfor (int j = 0; j < p.length(); j++) {\\n\\t\\t\\tif( p.charAt(j) == \\'*\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = (match[i][j + 1] | match[i + 1][j] | match[i][j]);\\n\\t\\t\\telse if( s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\' )\\n\\t\\t\\t\\tmatch[i + 1][j + 1] = match[i][j];\\n\\t\\t}\\n\\treturn match[s.length()][p.length()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2194986,
                "title": "dp-solution-4-different-solutions",
                "content": "**Recursive:** Time Limit Exceeded\\n\\n\\tTime Complexity: O(Exponential)\\n\\tSpace Complexity: O(N + M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        return f(n - 1, m - 1, p, s);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n\\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            return f(i - 1, j - 1, p, s);\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            return f (i - 1, j, p, s) || f (i, j - 1, p, s);\\n        }\\n        \\n        // No match found\\n        return false;\\n    }\\n}\\n```\\n\\n**Memoization:**\\n\\n\\tTime Complexity: O(N x M)\\n\\tSpace Complexity: O(N x M) + O(N + M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        int[][] dp = new int[n][m];\\n        for (int[] row: dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return f(n - 1, m - 1, p, s, dp);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s, int[][] dp) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        \\n        if (dp[i][j] != -1) {\\n            return dp[i][j] == 1 ? true : false;\\n        }\\n        \\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            boolean flag = f(i - 1, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            boolean flag = f (i - 1, j, p, s, dp) || f (i, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // No match found\\n        dp[i][j] = 0;\\n        return false;\\n    }\\n}\\n```\\n\\n**Tabulation:**\\n\\n\\tTime Complexity: O(N x M)\\n\\tSpace Complexity: O(N x M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n        \\n        // Base Case\\n        dp[0][0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            dp[0][j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        \\n        \\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                }\\n\\n                // No match found\\n                else dp[i][j] = false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n}\\n```\\n\\n**Space Optimised:**\\n\\n\\tTime Complexity: O(N x M)\\n\\tSpace Complexity: O(M) + O(M)\\n\\t\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[] prev = new boolean[m + 1];\\n        \\n        // Base Case\\n        prev[0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            prev[j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean[] cur = new boolean[m + 1];\\n            \\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            cur[0] = flag;\\n            \\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    cur[j] = prev[j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    cur[j] = prev[j] || cur[j - 1];\\n                }\\n\\n                // No match found\\n                else cur[j] = false;\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[m];\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        return f(n - 1, m - 1, p, s);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n\\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            return f(i - 1, j - 1, p, s);\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            return f (i - 1, j, p, s) || f (i, j - 1, p, s);\\n        }\\n        \\n        // No match found\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        int[][] dp = new int[n][m];\\n        for (int[] row: dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return f(n - 1, m - 1, p, s, dp);\\n    }\\n    \\n    private boolean f(int i, int j, String p, String s, int[][] dp) {\\n        \\n        // Base Case\\n        \\n        // if both strings get exhausted\\n        if (i < 0 && j < 0) return true;\\n        \\n        // if one get exhausted and other didn\\'t\\n        if (i < 0 && j >= 0) return false;\\n        \\n        // if p is left, it has to be all \\'*\\'\\n        if (j < 0 && i >= 0) {\\n            for (int k = 0; k <= i; k++) {\\n                if (p.charAt(k) != \\'*\\') {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        \\n        \\n        if (dp[i][j] != -1) {\\n            return dp[i][j] == 1 ? true : false;\\n        }\\n        \\n        // If match found or \\'?\\' is found \\n        if (p.charAt(i) == s.charAt(j) || p.charAt(i) == \\'?\\') {\\n            boolean flag = f(i - 1, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // if it is a \\'*\\'\\n        if (p.charAt(i) == \\'*\\') {\\n            boolean flag = f (i - 1, j, p, s, dp) || f (i, j - 1, p, s, dp);\\n            dp[i][j] = (flag == true) ? 1 : 0;\\n            \\n            return flag;\\n        }\\n        \\n        // No match found\\n        dp[i][j] = 0;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[][] dp = new boolean[n + 1][m + 1];\\n        \\n        // Base Case\\n        dp[0][0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            dp[0][j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        \\n        \\n        \\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                }\\n\\n                // No match found\\n                else dp[i][j] = false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int n = p.length();\\n        int m = s.length();\\n        \\n        boolean[] prev = new boolean[m + 1];\\n        \\n        // Base Case\\n        prev[0] = true;\\n        \\n        for (int j = 1; j <= m; j++) {\\n            prev[j] = false;\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {\\n            boolean[] cur = new boolean[m + 1];\\n            \\n            boolean flag = true;\\n            for (int k = 1; k <= i; k++) {\\n                if (p.charAt(k - 1) != \\'*\\') {\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            cur[0] = flag;\\n            \\n            for (int j = 1; j <= m; j++) {\\n                // If match found or \\'?\\' is found \\n                if (p.charAt(i - 1) == s.charAt(j - 1) || p.charAt(i - 1) == \\'?\\') {\\n                    cur[j] = prev[j - 1];\\n                }\\n\\n                // if it is a \\'*\\'\\n                else if (p.charAt(i - 1) == \\'*\\') {\\n                    cur[j] = prev[j] || cur[j - 1];\\n                }\\n\\n                // No match found\\n                else cur[j] = false;\\n            }\\n            prev = cur;\\n        }\\n        \\n        return prev[m];\\n    }\\n}\\n\\n// Please upvote if you find this helpful\\n// Feel free to ask doubt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909407,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        var regular = \"\"\\n        var last: Character = \" \"\\n        \\n        for c in p {\\n            if c == \"?\" {\\n                regular += \".\"\\n            } else if c == \"*\" && last != \"*\" {\\n                regular += \".*\"\\n            } else {\\n                regular += String(c)\\n            }\\n            last = c\\n        }\\n        return regularExpressionMatching(s, regular)\\n    }\\n\\n\\n    func regularExpressionMatching(_ s: String, _ p: String) -> Bool {\\n        var string = Array(s)\\n        var chars: [Character] = []\\n        var marks : [Bool] = []\\n        var isMark: Bool = false\\n        var list = [[-1, -1, 1]] // [start, end, is need to add next start]\\n        var max = Int.min\\n\\n\\n        func nextRange(_ list: [[Int]], _ char: Character, _ mark: Bool) -> [[Int]] {\\n            var res = Set<[Int]>()\\n            for range in list {\\n                let lower = range[0] + range[2]\\n                let upper = range[1] + 1\\n                for i in lower...upper {\\n                    if mark {\\n                        var j = i\\n                        var count = 0\\n                        while j < string.count {\\n                            if char == string[j] || char == \".\" {\\n                                j += 1\\n                                count += 1\\n                            } else {\\n                                break\\n                            }\\n                        }\\n                        j = i + (count > 0 ? count - 1 : 0) \\n                        if count > 0 {\\n                            res.insert([i, j, 0])\\n                        } else {\\n                            res.insert(range)\\n                        }\\n                    } else {\\n                        if i < string.count && (char == string[i] || char == \".\") {\\n                            res.insert([i, i, 1])\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return Array(res)\\n        }\\n\\n        for (_, c) in p.enumerated().reversed() {\\n            if c == \"*\" {\\n                isMark = true\\n            } else {\\n                chars.insert(c, at: 0)\\n                marks.insert(isMark, at: 0)\\n                isMark = false\\n            }\\n        }\\n\\n        for (index, c) in chars.enumerated() {\\n            let mark = marks[index]\\n            list = nextRange(list, c, mark)\\n        }\\n        for rang in list { max = max > rang[1] ? max : rang[1] }        \\n        return max == string.count - 1\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isMatch(_ s: String, _ p: String) -> Bool {\\n        var regular = \"\"\\n        var last: Character = \" \"\\n        \\n        for c in p {\\n            if c == \"?\" {\\n                regular += \".\"\\n            } else if c == \"*\" && last != \"*\" {\\n                regular += \".*\"\\n            } else {\\n                regular += String(c)\\n            }\\n            last = c\\n        }\\n        return regularExpressionMatching(s, regular)\\n    }\\n\\n\\n    func regularExpressionMatching(_ s: String, _ p: String) -> Bool {\\n        var string = Array(s)\\n        var chars: [Character] = []\\n        var marks : [Bool] = []\\n        var isMark: Bool = false\\n        var list = [[-1, -1, 1]] // [start, end, is need to add next start]\\n        var max = Int.min\\n\\n\\n        func nextRange(_ list: [[Int]], _ char: Character, _ mark: Bool) -> [[Int]] {\\n            var res = Set<[Int]>()\\n            for range in list {\\n                let lower = range[0] + range[2]\\n                let upper = range[1] + 1\\n                for i in lower...upper {\\n                    if mark {\\n                        var j = i\\n                        var count = 0\\n                        while j < string.count {\\n                            if char == string[j] || char == \".\" {\\n                                j += 1\\n                                count += 1\\n                            } else {\\n                                break\\n                            }\\n                        }\\n                        j = i + (count > 0 ? count - 1 : 0) \\n                        if count > 0 {\\n                            res.insert([i, j, 0])\\n                        } else {\\n                            res.insert(range)\\n                        }\\n                    } else {\\n                        if i < string.count && (char == string[i] || char == \".\") {\\n                            res.insert([i, i, 1])\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return Array(res)\\n        }\\n\\n        for (_, c) in p.enumerated().reversed() {\\n            if c == \"*\" {\\n                isMark = true\\n            } else {\\n                chars.insert(c, at: 0)\\n                marks.insert(isMark, at: 0)\\n                isMark = false\\n            }\\n        }\\n\\n        for (index, c) in chars.enumerated() {\\n            let mark = marks[index]\\n            list = nextRange(list, c, mark)\\n        }\\n        for rang in list { max = max > rang[1] ? max : rang[1] }        \\n        return max == string.count - 1\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1573893,
                "title": "c-recursive-memoized-dp-explained",
                "content": "**Logic:** Explained as comments in recursive code.\\nT.C of memoized and DP solution: O(NM). where N, M is length of string s and p.\\n\\n**1. Recursive**\\n```\\n    bool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        return fun(s,p,i,j);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1));\\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') return fun(s,p,i+1,j) || fun(s,p,i,j+1);\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            return (sameChar && fun(s,p,i+1,j+1));\\n        }\\n    }\\n```\\n\\n**2. Memoized:** (Recursion + Storage)\\n```\\n\\tbool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        int x = s.size(), y = p.size();\\n        int t[2002][2002];\\n        \\n        for(int k=0; k<x+1; k++){\\n            for(int m=0; m<y+1; m++){\\n                t[k][m] = -1;\\n            }\\n        }\\n        return fun(s,p,i,j, t);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j, int t[][2002]){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n\\t\\t//Check if result exists\\n        if(t[i][j] != -1) return t[i][j];\\n\\t\\t\\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1, t));\\n        \\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') {\\n            t[i][j] = fun(s,p,i+1,j,t) || fun(s,p,i,j+1, t);\\n            return t[i][j];\\n        }\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            t[i][j] = (sameChar && fun(s,p,i+1,j+1, t));\\n            return t[i][j];\\n        }\\n    }\\n```\\n\\n**3. DP:** \\n```\\nbool isMatch(string& s, string& p) {\\n        if(p.size()==0) return s.size() == 0;\\n        \\n        int x = s.size(), y = p.size();\\n        vector<vector<int>> t(x+1, vector<int>(y+1,0));\\n        \\n        t[0][0] = 1;\\n        \\n        for(int i=1; i<=p.size(); i++){\\n            if(p[i-1] == \\'*\\') t[0][i] = 1;\\n            else break;\\n        }\\n        \\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=1; j<=p.size(); j++){\\n                if(p[j-1] == \\'*\\')  t[i][j] = t[i-1][j] || t[i][j-1];\\n                else if(p[j-1] == \\'?\\' || p[j-1] == s[i-1]) {\\n                    t[i][j] = t[i-1][j-1];\\n                }\\n            }\\n        }\\n        return t[x][y];\\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n    bool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        return fun(s,p,i,j);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1));\\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') return fun(s,p,i+1,j) || fun(s,p,i,j+1);\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            return (sameChar && fun(s,p,i+1,j+1));\\n        }\\n    }\\n```\n```\\n\\tbool isMatch(string s, string p) {\\n        int i=0, j=0;\\n        \\n        //i is pointer on s\\n        //j is pointer on p\\n        int x = s.size(), y = p.size();\\n        int t[2002][2002];\\n        \\n        for(int k=0; k<x+1; k++){\\n            for(int m=0; m<y+1; m++){\\n                t[k][m] = -1;\\n            }\\n        }\\n        return fun(s,p,i,j, t);\\n    }\\n    \\n    bool fun(string& s, string& p, int i, int j, int t[][2002]){\\n        //1. Base case\\n        //a. String p has ended - s must have ended for a match between them.\\n        if(j==p.size()) return i == s.size();\\n        \\n\\t\\t//Check if result exists\\n        if(t[i][j] != -1) return t[i][j];\\n\\t\\t\\n        //b. String s has ended - p[j] could only be \\'*\\' or multiple \\'*\\' for a match.\\n        if(i==s.size()) return (p[j] == \\'*\\' && fun(s,p,i,j+1, t));\\n        \\n        \\n        //2. If none of them has ended and p[j] is \\'*\\', nothing can be said before comparing rest of the strings, both of them.\\n        if(p[j] == \\'*\\') {\\n            t[i][j] = fun(s,p,i+1,j,t) || fun(s,p,i,j+1, t);\\n            return t[i][j];\\n        }\\n        \\n        //3. Else, when p[j] = \\'?\\' or a character - If it is a character it must be same as s[i]\\n        else{\\n            bool sameChar = i<s.size() && (p[j] == s[i] || p[j] == \\'?\\');\\n            t[i][j] = (sameChar && fun(s,p,i+1,j+1, t));\\n            return t[i][j];\\n        }\\n    }\\n```\n```\\nbool isMatch(string& s, string& p) {\\n        if(p.size()==0) return s.size() == 0;\\n        \\n        int x = s.size(), y = p.size();\\n        vector<vector<int>> t(x+1, vector<int>(y+1,0));\\n        \\n        t[0][0] = 1;\\n        \\n        for(int i=1; i<=p.size(); i++){\\n            if(p[i-1] == \\'*\\') t[0][i] = 1;\\n            else break;\\n        }\\n        \\n        for(int i=1; i<=s.size(); i++){\\n            for(int j=1; j<=p.size(); j++){\\n                if(p[j-1] == \\'*\\')  t[i][j] = t[i-1][j] || t[i][j-1];\\n                else if(p[j-1] == \\'?\\' || p[j-1] == s[i-1]) {\\n                    t[i][j] = t[i-1][j-1];\\n                }\\n            }\\n        }\\n        return t[x][y];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17910,
                "title": "clear-c-dp-solution-similar-to-the-last-matching-problem",
                "content": "    bool isMatch(string s, string p) {\\n        int n1 = s.size(), n2 = p.size();\\n        vector<vector<bool>> res(n1 + 1, vector<bool>(n2 + 1));\\n        res[0][0] = true;\\n        for(int i=1; i<=n2; i++){\\n            if(p[i-1] == '*')\\n                res[0][i] = res[0][i-1];\\n        }\\n        for(int i=1; i<=n1; i++){\\n            for(int j=1; j<=n2; j++){\\n                if(p[j-1] != '*'){\\n                    res[i][j] = (s[i-1] == p[j-1] || p[j-1] == '?') && res[i-1][j-1]; \\n                }\\n                else{\\n                    res[i][j] = res[i-1][j] || res[i][j-1];\\n                }\\n            }\\n        }\\n        return res[n1][n2];\\n    }",
                "solutionTags": [],
                "code": "    bool isMatch(string s, string p) {\\n        int n1 = s.size(), n2 = p.size();\\n        vector<vector<bool>> res(n1 + 1, vector<bool>(n2 + 1));\\n        res[0][0] = true;\\n        for(int i=1; i<=n2; i++){\\n            if(p[i-1] == '*')\\n                res[0][i] = res[0][i-1];\\n        }\\n        for(int i=1; i<=n1; i++){\\n            for(int j=1; j<=n2; j++){\\n                if(p[j-1] != '*'){\\n                    res[i][j] = (s[i-1] == p[j-1] || p[j-1] == '?') && res[i-1][j-1]; \\n                }\\n                else{\\n                    res[i][j] = res[i-1][j] || res[i][j-1];\\n                }\\n            }\\n        }\\n        return res[n1][n2];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3416314,
                "title": "c-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool c(string &s,string &p,int i,int j,vector<vector<int>>&dp){\\n        if(i==s.size()){\\n            int t=0;\\n            for(int g=j;g<p.size();g++)if(p[g]==\\'*\\')t++;\\n            if(t==(p.size()-j))return true;\\n            else return false;\\n        }\\n        \\n        if(j>=p.size() || i>s.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        bool ans=false;\\n        if(p[j]>=\\'a\\' && p[j]<=\\'z\\'){\\n           if(s[i]!=p[j])ans=false;\\n           else ans|= c(s,p,i+1,j+1,dp);\\n        }\\n        else if(p[j]==\\'?\\')ans|= c(s,p,i+1,j+1,dp);\\n        else {\\n            for(int h=i;h<s.size();h++){\\n                    ans |= c(s,p,h+1,j+1,dp);\\n                    ans |= c(s,p,h,j+1,dp);\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size(),vector<int>(p.size(),-1));\\n        return c(s,p,0,0,dp);\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/78f09d88-c388-486a-89e7-1e3efd936b18_1681475282.875831.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool c(string &s,string &p,int i,int j,vector<vector<int>>&dp){\\n        if(i==s.size()){\\n            int t=0;\\n            for(int g=j;g<p.size();g++)if(p[g]==\\'*\\')t++;\\n            if(t==(p.size()-j))return true;\\n            else return false;\\n        }\\n        \\n        if(j>=p.size() || i>s.size())return false;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        bool ans=false;\\n        if(p[j]>=\\'a\\' && p[j]<=\\'z\\'){\\n           if(s[i]!=p[j])ans=false;\\n           else ans|= c(s,p,i+1,j+1,dp);\\n        }\\n        else if(p[j]==\\'?\\')ans|= c(s,p,i+1,j+1,dp);\\n        else {\\n            for(int h=i;h<s.size();h++){\\n                    ans |= c(s,p,h+1,j+1,dp);\\n                    ans |= c(s,p,h,j+1,dp);\\n            }\\n        }\\n        dp[i][j]=ans;\\n        return ans;\\n    \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size(),vector<int>(p.size(),-1));\\n        return c(s,p,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321724,
                "title": "different-python-solutions-with-thinking-process",
                "content": "Please see and vote for my standard DP solutions for\\n[10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/discuss/314237/Python-DP-solution-with-detailed-explanation)\\n[44. Wildcard Matching](https://leetcode.com/problems/wildcard-matching/discuss/321724/Different-Python-solutions-with-thinking-process)\\n\\nMethod 1: standard DP solution using a 2D table (1040 ms, beat 17%)\\n```\\nLet m = len(s), n = len(p), dp[i][j] = whether p[:j] matches s[:i] or not,\\nBase cases: \\ndp[0][0] = True\\ndp[i][0] = False, when i = 1, 2, ..., m\\ndp[0][j] = False if p[j-1] is \\'?\\' or a lowercase letter,  dp[0][j-1] if dp[j-1] == \\'*\\', when j = 1, 2, ..., n\\nRecursive relationship:  for i in range(1, m + 1), for j in range(1, n + 1)\\n(1) if p[j-1] is a lowercase letter, dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n(2) if p[j-1] == \\'?\\', dp[i][j] = dp[i-1][j-1]\\n(3) if p[j-1] == \\'*\\', dp[i][j] =\\n        (i) \\'*\\' match nothing,  dp[i][j-1]\\n   or (ii) \\'*\\' match at least one character dp[i-1][j]\\n```\\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j-1].isalpha() or p[j-1] == \\'?\\':\\n                dp[0][j] = False\\n            else:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j-1].isalpha():\\n                    dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n                elif p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[m][n]\\n```\\n\\nMethod 2: greedy solution with idea of DFS (56ms, beat 96.73%) [reference, tonygogogo\\'s comment](https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution)\\n```\\nprev_star stores the position of the previous \\'*\\' in p\\nneed_to_match stores the position of the char in s after a \\'*\\' matched zero or more chars\\nExample:  s = \"acdscd\", p = \"*cd\",\\nAfter finding the first \\'*\\', prev_star = 0, need_to_match = 0, \\'*\\' matches nothing.\\ns[0] != p[1], the previous match \\'\\' of \\'*\\' (the first branch of DFS) is actually wrong,\\nthen reset j = prev_star + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'a\\'.\\nWhen we come to i = 3 and j = 3, we know that the previous match \\'a\\' of \\'*\\' is wrong,\\nthen reset j = prev_match + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'ac\\',\\n...\\nWhen we have prev_star = 0 and need_to_match = 4 (i.e. \\'*\\' matches \\'acds\\'), then get the right match. \\n```\\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        i, j = 0, 0\\n        prev_star, need_to_match = -1, -1\\n        while i < m:\\n            if j < n and (p[j] == s[i] or p[j] == \\'?\\'):\\n                i, j = i + 1, j + 1\\n            elif j < n and p[j] == \\'*\\':\\n                prev_star = j\\n                need_to_match = i   # initially let * match nothing\\n                j += 1\\n            elif prev_star != -1:\\n                j = prev_star + 1\\n\\t\\t\\t\\tneed_to_match += 1  # let * match one more character\\n                i = need_to_match\\n            else:\\n                return False\\n        while j < n and p[j] == \\'*\\':\\n            j += 1\\n        return j == n\\n```",
                "solutionTags": [],
                "code": "```\\nLet m = len(s), n = len(p), dp[i][j] = whether p[:j] matches s[:i] or not,\\nBase cases: \\ndp[0][0] = True\\ndp[i][0] = False, when i = 1, 2, ..., m\\ndp[0][j] = False if p[j-1] is \\'?\\' or a lowercase letter,  dp[0][j-1] if dp[j-1] == \\'*\\', when j = 1, 2, ..., n\\nRecursive relationship:  for i in range(1, m + 1), for j in range(1, n + 1)\\n(1) if p[j-1] is a lowercase letter, dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n(2) if p[j-1] == \\'?\\', dp[i][j] = dp[i-1][j-1]\\n(3) if p[j-1] == \\'*\\', dp[i][j] =\\n        (i) \\'*\\' match nothing,  dp[i][j-1]\\n   or (ii) \\'*\\' match at least one character dp[i-1][j]\\n```\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False for _ in range(n + 1)] for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j-1].isalpha() or p[j-1] == \\'?\\':\\n                dp[0][j] = False\\n            else:\\n                dp[0][j] = dp[0][j-1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j-1].isalpha():\\n                    dp[i][j] = (p[j-1] == s[i-1]) and dp[i-1][j-1]\\n                elif p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                else:\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[m][n]\\n```\n```\\nprev_star stores the position of the previous \\'*\\' in p\\nneed_to_match stores the position of the char in s after a \\'*\\' matched zero or more chars\\nExample:  s = \"acdscd\", p = \"*cd\",\\nAfter finding the first \\'*\\', prev_star = 0, need_to_match = 0, \\'*\\' matches nothing.\\ns[0] != p[1], the previous match \\'\\' of \\'*\\' (the first branch of DFS) is actually wrong,\\nthen reset j = prev_star + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'a\\'.\\nWhen we come to i = 3 and j = 3, we know that the previous match \\'a\\' of \\'*\\' is wrong,\\nthen reset j = prev_match + 1, increment need_to_match, set i = need_to_match, i.e. \\'*\\' matches \\'ac\\',\\n...\\nWhen we have prev_star = 0 and need_to_match = 4 (i.e. \\'*\\' matches \\'acds\\'), then get the right match. \\n```\n```\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        i, j = 0, 0\\n        prev_star, need_to_match = -1, -1\\n        while i < m:\\n            if j < n and (p[j] == s[i] or p[j] == \\'?\\'):\\n                i, j = i + 1, j + 1\\n            elif j < n and p[j] == \\'*\\':\\n                prev_star = j\\n                need_to_match = i   # initially let * match nothing\\n                j += 1\\n            elif prev_star != -1:\\n                j = prev_star + 1\\n\\t\\t\\t\\tneed_to_match += 1  # let * match one more character\\n                i = need_to_match\\n            else:\\n                return False\\n        while j < n and p[j] == \\'*\\':\\n            j += 1\\n        return j == n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1557406,
                "title": "c-simple-and-clean-solution-detailed-explanation",
                "content": "**Idea:**\\nWe use two pointers: `pi` for `p`, and `si` for `s`.\\nWe also keep variables: `star` for the index of the last `*`, and `count` for the substring we are matching for the `*`.\\nThese are the cases:\\n1. The pattern has a `*`: update `count` and `star`.\\n2. The letters in both s and p are equal, or the pattern has a `?`: Match! just advance pointers.\\n3. Otherwise, we try to append this letter to a substring matching a `*`.\\n4. If there was no star - return false.\\n\\nIf we have more stars at the end of `p`, we skip them, and then if we reached the end of the pattern - return true.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int pi = 0, si = 0, star = -1, count = 0;\\n        \\n        while (si < s.size()) {\\n            \\n            if (p[pi] == \\'*\\') {\\n                count = si;\\n                star = pi++;\\n            }\\n            \\n            else if (p[pi] == s[si] || p[pi] == \\'?\\') {\\n                pi++, si++;\\n            }\\n            \\n            else if (star >= 0){\\n                pi = star+1;\\n                si = ++count;\\n                \\n            }\\n            else return false;\\n        }\\n        \\n        while (pi < p.size() && p[pi] == \\'*\\') pi++;\\n        return pi == p.size();\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int pi = 0, si = 0, star = -1, count = 0;\\n        \\n        while (si < s.size()) {\\n            \\n            if (p[pi] == \\'*\\') {\\n                count = si;\\n                star = pi++;\\n            }\\n            \\n            else if (p[pi] == s[si] || p[pi] == \\'?\\') {\\n                pi++, si++;\\n            }\\n            \\n            else if (star >= 0){\\n                pi = star+1;\\n                si = ++count;\\n                \\n            }\\n            else return false;\\n        }\\n        \\n        while (pi < p.size() && p[pi] == \\'*\\') pi++;\\n        return pi == p.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216893,
                "title": "java-solution-with-explanation-beats-100-of-submissions",
                "content": "we will keep track of last index in s from which we started comparing with pattern if we encounter a * ( first we will consider * as 0 length )\\nIf we encounter a mismatch , then we will increase the last index(which means we are now considering 1 length in * ) \\nSimilarly we will continue until we reach the end of string .\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i=0;\\n        int j=0;\\n        int starIdx=-1;\\n        int lastMatch=-1;\\n        \\n        while(i<s.length()){\\n            if(j<p.length() && (s.charAt(i)==p.charAt(j) || \\n              p.charAt(j)==\\'?\\')){\\n                i++;\\n                j++;\\n            }else if(j<p.length() && p.charAt(j)==\\'*\\'){\\n                starIdx=j;\\n                lastMatch=i;\\n                j++;\\n            }else if(starIdx!=-1){\\n            //there is a no match and there was a previous star, we will reset the j to indx after star_index\\n            //lastMatch will tell from which index we start comparing the string if we encounter * in pattern\\n                j=starIdx+1;\\n                lastMatch++; // we are saying we included more characters in * so we incremented the index \\n                i=lastMatch;\\n                \\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        while(j<p.length() && p.charAt(j)==\\'*\\') j++;\\n        \\n        if(i!=s.length() || j!=p.length()) return false;\\n        \\n        return true;\\n     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i=0;\\n        int j=0;\\n        int starIdx=-1;\\n        int lastMatch=-1;\\n        \\n        while(i<s.length()){\\n            if(j<p.length() && (s.charAt(i)==p.charAt(j) || \\n              p.charAt(j)==\\'?\\')){\\n                i++;\\n                j++;\\n            }else if(j<p.length() && p.charAt(j)==\\'*\\'){\\n                starIdx=j;\\n                lastMatch=i;\\n                j++;\\n            }else if(starIdx!=-1){\\n            //there is a no match and there was a previous star, we will reset the j to indx after star_index\\n            //lastMatch will tell from which index we start comparing the string if we encounter * in pattern\\n                j=starIdx+1;\\n                lastMatch++; // we are saying we included more characters in * so we incremented the index \\n                i=lastMatch;\\n                \\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        while(j<p.length() && p.charAt(j)==\\'*\\') j++;\\n        \\n        if(i!=s.length() || j!=p.length()) return false;\\n        \\n        return true;\\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 963049,
                "title": "0ms-runtime-3-golang-solutions-with-optimization-and-explaination-recursive-iterative-dp",
                "content": "This is a wonderful problem, and deserves serious study.\\n\\n1. Recursive solution.  It\\'s not complicated. \\n\\n```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    if len(s) > 0 && (s[0] == p[0] || p[0] == \\'?\\') {\\n        return isMatch(s[1:], p[1:])\\n    } else if p[0] == \\'*\\' {\\n        return isMatch(s, p[1:]) || (len(s) > 0 && isMatch(s[1:], p))\\n    }\\n    return false\\n}\\n```\\nUnfortunately it is judged Time Limit Exceeded.  The test cases is specially designed  for recursive algorithms.\\n\\n<img src=\"https://assets.leetcode.com/users/images/de901b4d-393d-42e1-9a8c-c0c11a7218b6_1607409296.4703355.png\" width=\"450px\" />\\n\\nLet\\'s do some optimization works.\\n \\nOptimization 1: Pruning unnecessary recursive calls.\\nThinking about this testcase `assert.False(t, isMatch(\"bbc\", \"*b*a\"))`. Every time we match `*`, if the string can\\'t match the subsequent pattern, the recursive function will call itself two times, the call tree forks.\\n\\n```\\nisMatch(\"bbc\", \"*b*a\")         \\n  |\\n  |-isMatch(\"bbc\", \"b*a\")   \\n  |   |\\n  |   |-isMatch(\"bc\", \"*a\")    \\n  |       |\\n  |       |-isMatch(\"bc\", \"a\")\\n  |       |\\n  |       |-isMatch(\"c\", \"*a\")  // First fork\\n  |           |                 \\n  |           |-isMatch(\"c\", \"a\")\\n  |           |\\n  |           |-isMatch(\"\", \"*a\") // Second fork return false. This means that any suffix substring can\\'t match the sub pattern \\n  |                               // starts with the last `*`. \"c\",\"bc\",\"bbc\", none of them can match \"*a\". \\n  |                               // **AND OF COURCE** they can\\'t match any pattern ends with \"*a\", such as \"b*a\",\"*b*a\". This\\'s the untimate match.\\n  |\\n  |-isMatch(\"bc\", \"*b*a\")  // Third fork, This fork branch is unnecessary, because the result is \\n\\t  |                    // already known after calling isMatch(\"\", \"*a\").\\n      |\\n      |-isMatch(\"bc\", \"b*a\")\\n      |   |\\n      |   |-isMatch(\"c\", \"*a\")\\n      |....  \\n```\\nNow we know that after matching the pattern starts with the last `*`, any recursive call fork is unnecessary.\\nTo avoid alll the unnecessary recursive forks we only need to add a `lastStar` variant and set the `lastStar` to `true` after matching the pattern starts with the last `*`. \\nSo, here is the optimized solution:\\n\\n\\n\\n```\\nfunc isMatch(s string, p string) bool { \\n    var lastStar bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n            matched = helper(s[1:], p[1:])\\n        } else if p[0] == \\'*\\' {\\n            matched = len(p) == 1 || helper(s, p[1:]) // cut the pattern string first\\n            if !lastStar && !matched && len(s) > 0 {\\n                matched = helper(s[1:], p) // When running to this line for the first time, the pattern string must start with the last `*`, then cut the string.\\n                lastStar = true\\n            }\\n        }\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\\n\\nOptimization 2: Two directions match.\\nAbout this testcase `s=\"abababababababa\", p=\"*b*b*b*b*e\"`, the solution do many useless work with the prefix containing many `*`, but the last char \"a\" doesn\\'t match \"e\", and it\\'s easy to get. If matching in two directions, back to front and front to back, it can save some time.\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n    var lastStar, frontToBack bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if frontToBack {\\n\\t\\t\\tif len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n\\t\\t\\t\\tmatched = helper(s[1:], p[1:])\\n\\t\\t\\t} else if p[0] == \\'*\\' {\\n\\t\\t\\t\\tmatched = len(p) == 1 || helper(s, p[1:])\\n\\t\\t\\t\\tif !lastStar && !matched && len(s) > 0 {\\n\\t\\t\\t\\t\\tmatched = helper(s[1:], p)\\n\\t\\t\\t\\t\\tlastStar = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        } else {\\n            if len(s) > 0 && (p[len(p)-1] == \\'?\\' || s[len(s)-1] == p[len(p)-1]) {\\n                matched = helper(s[:len(s)-1], p[:len(p)-1])\\n            } else if p[len(p)-1] == \\'*\\' {\\n    \\t\\t\\tfrontToBack = true\\n                matched = len(p) == 1 || helper(s, p) //Matching from front to back\\n            }\\n\\t\\t}\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\\n\\n2. Iterative solution.\\nThis solution is based on the same idea of the optimized recursive solution. When matching `*`, first we compare the follow up chars, if it doesn\\'t match, we just backtrack to the last star. \\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n\\tvar i, j, matched, lastStar int\\n    lastStar = -1\\n\\tfor i < len(s) {\\n\\t\\tif j < len(p) {\\n\\t\\t\\tif p[j] == \\'?\\' || s[i] == p[j] {\\n\\t\\t\\t\\ti, j = i+ 1, j+ 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif p[j] == \\'*\\' {\\n\\t\\t\\t    matched, lastStar = i, j\\n                j++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif lastStar < 0 {\\n\\t\\t    return false\\n        }\\n        matched++ // let s[i] matches \\'*\\'\\n        i, j = matched, lastStar+1\\n\\t}\\n\\t\\n\\tfor ; j < len(p); j++ {\\n\\t\\tif p[j] != \\'*\\' {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\\n\\nOptimization: Two directions match.\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n    var i, j, matched, lastStar, lastI, lastJ int\\n\\t//match from end to front until the last star\\n    for lastI, lastJ = len(s)-1, len(p)-1; lastI >= 0 && lastJ >= 0 &&  p[lastJ] != \\'*\\'; {\\n\\t    if p[lastJ] == \\'?\\' || s[lastI] == p[lastJ] {\\n            lastI, lastJ = lastI-1, lastJ-1\\n        } else {\\n            return false\\n        }\\n    }\\n    if lastJ < 0 {\\n        return lastI < 0\\n    }\\n    if lastI < 0 {\\n        for j=0; j<=lastJ; j++ {\\n            if p[j] != \\'*\\' {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\tlastStar = -1\\n\\t//match from front to end\\n    for i <= lastI {\\n        if j <= lastJ {\\n            if p[j] == \\'?\\' || s[i] == p[j] {\\n                i, j = i+1, j+1\\n                continue\\n            }\\n            if p[j] == \\'*\\' {\\n                matched, lastStar = i, j\\n                j++\\n                continue\\n            }\\n        }\\n        if lastStar < 0 {\\n            return false\\n        }\\n        matched++\\n        i, j = matched, lastStar+1\\n    }\\n\\n    for ; j <= lastJ; j++ {\\n        if p[j] != \\'*\\' {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```\\n\\nActually I think this solution is ugly. Bu it can get `0ms` running time.\\n<img src=\"https://assets.leetcode.com/users/images/dfb37fff-ed39-456b-95b1-be03e16e69fe_1607334056.0733168.png\" width=\"500px\" />\\n\\n3. DP solution.\\n\\n```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    dp := make([][]bool, len(p) + 1)\\n    for i := 0; i < len(dp); i++ {\\n        dp[i] = make([]bool, len(s) + 1)\\n    }\\n    dp[0][0] = true\\n    for i:=1;i<=len(p);i++ {\\n        dp[i][0] = dp[i-1][0] && p[i-1] == \\'*\\'\\n        for j := 1; j <= len(s); j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            case \\'*\\':\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]\\n            default:\\n                dp[i][j] = dp[i-1][j-1] && p[i-1] == s[j-1]\\n            }\\n        }\\n    }\\n    return dp[len(p)][len(s)]\\n}\\n```\\n\\nOptimization:\\n\\n1.About this testcase `s=\"abcdefghi\", p=\"*fghi\"`, after loop in which match `f`, the dp row is `[0,0,0,0,0,0,1,0,0,0]`, in the next loop which is to match `g`, we don\\'t need start from the beginning char `a`. We just start from `f` which is true correspondingly in dp array . So by saving the first matched position of last loop  to variant `firstMatch`, we can start from `firstMatch` directly in the next loop.  Also We don\\'t need match `gh` to pattern `f`, because all behind cells are False. So we can save the last matched position to `lastMatch`, if next pattern char isn\\'t `*`, in next loop, we can stop at `lastMatch + 1`.\\n2.About this testcase `s=\"ddddddddfdfdfd\", p=\"d*******d\"`,  the continuous `*` is exactly same as the pattern \"*\" with only one star. We can shrink the redundant `*`s to single `*` at the beginning. \\n3. By shrinking the pattern string, we can count the number of `non-*` chars. That can help to reduce loop length of matching `*`. In testcase `s=\"abcdefg\", p=\"*?*?*?`, there are 3 `non-*` chars, so in the first loop of matching `*`, we can just stop matching at char `d`, because there are 3 more `non-*` chars in the subsequent pattern.\\n4. About this testcase `s=\"ddddddddfdfdfd\", p=\"aaaaaaaaaaa\"`, we don\\'t need to run to the end to get the result from `dp[len(s)][len(p)]`.  After the first pattern `\\'a\\'` we already know the string doesn\\'t match the pattern. The subsequent runs are meaningless.\\n5. Space optimization using an arrays instead of 2-d arrays. Reduce space from len(s)\\\\*len(p)  to len(s). \\n```go\\n\\t...\\n\\tswitch p[i-1] {\\n\\tcase \\'?\\':\\n\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\tcase \\'*\\':\\n\\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1]\\n\\t...\\n```\\nIn dp solution, determining a cell in the 2-d array need three cells which respectively are the left cell, the top cell and the left top cell.\\n|a|b|c|.|\\n|-|-|-|-|\\n|**d**|*e*|f|.|\\n|.|.|.|.|\\nIn the example in the table above, Determining cell `e` depends on `a`,`b` and `d`.  \\nTo optimize the space, We can use a temporary variant `dpCur` save the  temporary result of cell `e`, because cell `e` is needed in determing cell \\'f\\'. We can  put `dpcur` into cell `e` after determing cell `f`.\\n\\n```go\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    //shrink redundant `*`.\\n    var charCount int\\n    var b bytes.Buffer\\n    for i := 0; i < len(p); i++ {\\n        if p[i] != \\'*\\' || i == 0 || p[i] != p[i-1] {\\n            b.WriteByte(p[i])\\n            if p[i] != \\'*\\' {\\n                charCount++\\n            }\\n        }\\n    }\\n    if charCount > len(s) {\\n        return false\\n    }\\n    if b.Len() < len(p) {\\n        p = b.String()\\n    }\\n\\t\\n    var dp = make([]bool, len(s)+1)\\n    dp[0] = true\\n    var firstMatch,stopMatch, lastMatch,dpCur = 1,0,0,true\\n\\t\\n    for i := 1; i <= len(p); i++ {\\n        dpCur = dp[firstMatch-1] && p[i-1] == \\'*\\'\\n        matched := dpCur\\n        if p[i-1] == \\'*\\' {\\n            stopMatch = len(s) - charCount\\n        } else {\\n            charCount--\\n\\t\\t\\tstopMatch = lastMatch + 1\\n\\t\\t\\t// Don\\'t worry about overflow if `stopMatch > len(s)`. It won\\'t happen.\\n        }\\n        for j := firstMatch; j <= stopMatch; j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dpCur, dp[j-1] = dp[j-1], dpCur\\n            case \\'*\\':\\n                dpCur, dp[j-1] = dpCur || dp[j], dpCur\\n            default:\\n                dpCur, dp[j-1] = dp[j-1] && p[i-1] == s[j-1], dpCur\\n            }\\n            if dpCur {\\n                if !matched {\\n                    firstMatch = j\\n                    matched = true\\n                }\\n                lastMatch = j\\n            }\\n        }\\n        if !matched {\\n            //we already know s[:j] doesn\\'t match p[:i]. So we don\\'t need more comparing.\\n            return false\\n        }\\n        dp[stopMatch] = dpCur\\n    }\\n    return dp[len(s)]\\n}\\n```\\n\\nI will be really surprised if someone can keep reading to here.",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    if len(s) > 0 && (s[0] == p[0] || p[0] == \\'?\\') {\\n        return isMatch(s[1:], p[1:])\\n    } else if p[0] == \\'*\\' {\\n        return isMatch(s, p[1:]) || (len(s) > 0 && isMatch(s[1:], p))\\n    }\\n    return false\\n}\\n```\n```\\nisMatch(\"bbc\", \"*b*a\")         \\n  |\\n  |-isMatch(\"bbc\", \"b*a\")   \\n  |   |\\n  |   |-isMatch(\"bc\", \"*a\")    \\n  |       |\\n  |       |-isMatch(\"bc\", \"a\")\\n  |       |\\n  |       |-isMatch(\"c\", \"*a\")  // First fork\\n  |           |                 \\n  |           |-isMatch(\"c\", \"a\")\\n  |           |\\n  |           |-isMatch(\"\", \"*a\") // Second fork return false. This means that any suffix substring can\\'t match the sub pattern \\n  |                               // starts with the last `*`. \"c\",\"bc\",\"bbc\", none of them can match \"*a\". \\n  |                               // **AND OF COURCE** they can\\'t match any pattern ends with \"*a\", such as \"b*a\",\"*b*a\". This\\'s the untimate match.\\n  |\\n  |-isMatch(\"bc\", \"*b*a\")  // Third fork, This fork branch is unnecessary, because the result is \\n\\t  |                    // already known after calling isMatch(\"\", \"*a\").\\n      |\\n      |-isMatch(\"bc\", \"b*a\")\\n      |   |\\n      |   |-isMatch(\"c\", \"*a\")\\n      |....  \\n```\n```\\nfunc isMatch(s string, p string) bool { \\n    var lastStar bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n            matched = helper(s[1:], p[1:])\\n        } else if p[0] == \\'*\\' {\\n            matched = len(p) == 1 || helper(s, p[1:]) // cut the pattern string first\\n            if !lastStar && !matched && len(s) > 0 {\\n                matched = helper(s[1:], p) // When running to this line for the first time, the pattern string must start with the last `*`, then cut the string.\\n                lastStar = true\\n            }\\n        }\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n    var lastStar, frontToBack bool\\n    var helper func(s, p string) bool\\n    helper = func(s, p string) bool {\\n        if len(p) == 0 {\\n            return len(s) == 0\\n        }\\n        var matched bool\\n        if frontToBack {\\n\\t\\t\\tif len(s) > 0 && (p[0] == \\'?\\' || s[0] == p[0]) {\\n\\t\\t\\t\\tmatched = helper(s[1:], p[1:])\\n\\t\\t\\t} else if p[0] == \\'*\\' {\\n\\t\\t\\t\\tmatched = len(p) == 1 || helper(s, p[1:])\\n\\t\\t\\t\\tif !lastStar && !matched && len(s) > 0 {\\n\\t\\t\\t\\t\\tmatched = helper(s[1:], p)\\n\\t\\t\\t\\t\\tlastStar = true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        } else {\\n            if len(s) > 0 && (p[len(p)-1] == \\'?\\' || s[len(s)-1] == p[len(p)-1]) {\\n                matched = helper(s[:len(s)-1], p[:len(p)-1])\\n            } else if p[len(p)-1] == \\'*\\' {\\n    \\t\\t\\tfrontToBack = true\\n                matched = len(p) == 1 || helper(s, p) //Matching from front to back\\n            }\\n\\t\\t}\\n        return matched\\n    }\\n    return helper(s, p)\\n}\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n\\tvar i, j, matched, lastStar int\\n    lastStar = -1\\n\\tfor i < len(s) {\\n\\t\\tif j < len(p) {\\n\\t\\t\\tif p[j] == \\'?\\' || s[i] == p[j] {\\n\\t\\t\\t\\ti, j = i+ 1, j+ 1\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif p[j] == \\'*\\' {\\n\\t\\t\\t    matched, lastStar = i, j\\n                j++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif lastStar < 0 {\\n\\t\\t    return false\\n        }\\n        matched++ // let s[i] matches \\'*\\'\\n        i, j = matched, lastStar+1\\n\\t}\\n\\t\\n\\tfor ; j < len(p); j++ {\\n\\t\\tif p[j] != \\'*\\' {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n    var i, j, matched, lastStar, lastI, lastJ int\\n\\t//match from end to front until the last star\\n    for lastI, lastJ = len(s)-1, len(p)-1; lastI >= 0 && lastJ >= 0 &&  p[lastJ] != \\'*\\'; {\\n\\t    if p[lastJ] == \\'?\\' || s[lastI] == p[lastJ] {\\n            lastI, lastJ = lastI-1, lastJ-1\\n        } else {\\n            return false\\n        }\\n    }\\n    if lastJ < 0 {\\n        return lastI < 0\\n    }\\n    if lastI < 0 {\\n        for j=0; j<=lastJ; j++ {\\n            if p[j] != \\'*\\' {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n\\tlastStar = -1\\n\\t//match from front to end\\n    for i <= lastI {\\n        if j <= lastJ {\\n            if p[j] == \\'?\\' || s[i] == p[j] {\\n                i, j = i+1, j+1\\n                continue\\n            }\\n            if p[j] == \\'*\\' {\\n                matched, lastStar = i, j\\n                j++\\n                continue\\n            }\\n        }\\n        if lastStar < 0 {\\n            return false\\n        }\\n        matched++\\n        i, j = matched, lastStar+1\\n    }\\n\\n    for ; j <= lastJ; j++ {\\n        if p[j] != \\'*\\' {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```\n```\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    dp := make([][]bool, len(p) + 1)\\n    for i := 0; i < len(dp); i++ {\\n        dp[i] = make([]bool, len(s) + 1)\\n    }\\n    dp[0][0] = true\\n    for i:=1;i<=len(p);i++ {\\n        dp[i][0] = dp[i-1][0] && p[i-1] == \\'*\\'\\n        for j := 1; j <= len(s); j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            case \\'*\\':\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]\\n            default:\\n                dp[i][j] = dp[i-1][j-1] && p[i-1] == s[j-1]\\n            }\\n        }\\n    }\\n    return dp[len(p)][len(s)]\\n}\\n```\n```go\\n\\t...\\n\\tswitch p[i-1] {\\n\\tcase \\'?\\':\\n\\t\\tdp[i][j] = dp[i-1][j-1]\\n\\tcase \\'*\\':\\n\\t\\tdp[i][j] = dp[i-1][j] || dp[i][j-1]\\n\\t...\\n```\n```go\\nfunc isMatch(s string, p string) bool {\\n    if len(p) == 0 {\\n        return len(s) == 0\\n    }\\n    //shrink redundant `*`.\\n    var charCount int\\n    var b bytes.Buffer\\n    for i := 0; i < len(p); i++ {\\n        if p[i] != \\'*\\' || i == 0 || p[i] != p[i-1] {\\n            b.WriteByte(p[i])\\n            if p[i] != \\'*\\' {\\n                charCount++\\n            }\\n        }\\n    }\\n    if charCount > len(s) {\\n        return false\\n    }\\n    if b.Len() < len(p) {\\n        p = b.String()\\n    }\\n\\t\\n    var dp = make([]bool, len(s)+1)\\n    dp[0] = true\\n    var firstMatch,stopMatch, lastMatch,dpCur = 1,0,0,true\\n\\t\\n    for i := 1; i <= len(p); i++ {\\n        dpCur = dp[firstMatch-1] && p[i-1] == \\'*\\'\\n        matched := dpCur\\n        if p[i-1] == \\'*\\' {\\n            stopMatch = len(s) - charCount\\n        } else {\\n            charCount--\\n\\t\\t\\tstopMatch = lastMatch + 1\\n\\t\\t\\t// Don\\'t worry about overflow if `stopMatch > len(s)`. It won\\'t happen.\\n        }\\n        for j := firstMatch; j <= stopMatch; j++ {\\n            switch p[i-1] {\\n            case \\'?\\':\\n                dpCur, dp[j-1] = dp[j-1], dpCur\\n            case \\'*\\':\\n                dpCur, dp[j-1] = dpCur || dp[j], dpCur\\n            default:\\n                dpCur, dp[j-1] = dp[j-1] && p[i-1] == s[j-1], dpCur\\n            }\\n            if dpCur {\\n                if !matched {\\n                    firstMatch = j\\n                    matched = true\\n                }\\n                lastMatch = j\\n            }\\n        }\\n        if !matched {\\n            //we already know s[:j] doesn\\'t match p[:i]. So we don\\'t need more comparing.\\n            return false\\n        }\\n        dp[stopMatch] = dpCur\\n    }\\n    return dp[len(s)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17887,
                "title": "128ms-o-1-space-python-solution",
                "content": "    class Solution:\\n        # @param {string} s\\n        # @param {string} p\\n        # @return {boolean}\\n        def isMatch(self, s, p):\\n            if not p:\\n                return not s\\n    \\n            m, n = len(s), len(p)\\n            i = j = 0\\n            last_x = 0\\n            last_y = -1\\n            while i < m:\\n                if j < n and (p[j] == '?' or p[j] == s[i]):\\n                    i += 1\\n                    j += 1\\n                elif j < n and p[j] == '*':\\n                    last_x = i\\n                    last_y = j\\n                    j += 1\\n                elif last_y >= 0:\\n                    i = last_x + 1\\n                    last_x += 1\\n                    j = last_y\\n                else:\\n                    return False\\n            \\n            while j < n and p[j] == '*':\\n                j += 1\\n\\n            return j == n",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 17958,
                "title": "my-java-dp-solution",
                "content": "a shorter version\\n\\npublic class Solution {\\n    \\n    public boolean isMatch(String s, String p) {\\n        if (p.replace(\"*\", \"\").length() > s.length())\\n            return false;\\n\\t\\tboolean[] d = new boolean[s.length() + 1];\\n\\t\\td[0] = true;\\n\\t\\tfor (int i = 1; i < s.length(); ++i) {\\n\\t\\t\\td[i] = false;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i <= p.length(); ++i) {\\n\\t\\t\\tchar pchar = p.charAt(i - 1);\\n\\t\\t\\tif (pchar == '*') {\\n\\t\\t\\t\\tfor (int j = 1; j <= s.length(); ++j) {\\n\\t\\t\\t\\t\\td[j] = d[j - 1] || d[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int j = s.length(); j >= 1; --j) {\\n\\t\\t\\t\\t\\td[j] = d[j - 1] && (pchar == '?' || pchar == s.charAt(j - 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\td[0] = d[0] && pchar == '*';\\n\\t\\t}\\n\\t\\treturn d[s.length()];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public boolean isMatch(String s, String p) {\\n        if (p.replace(\"*\", \"\").length() > s.length())\\n            return false;\\n\\t\\tboolean[] d = new boolean[s.length() + 1];\\n\\t\\td[0] = true;\\n\\t\\tfor (int i = 1; i < s.length(); ++i) {\\n\\t\\t\\td[i] = false;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 17961,
                "title": "c-o-n-m-solution-using-kmp",
                "content": "    class Solution {\\n    public:\\n        void GetLut(const char *p, int posp, int len, vector<int> *lut) {\\n            (*lut)[0] = -1;\\n            int pos = -1;\\n            for (int i = 1; i < len; ++i) {\\n                while (pos > -1 && p[posp+pos+1] != p[posp + i] && p[posp+pos+1] != '?' && p[posp+i] != '?')\\n                    pos = (*lut)[pos];\\n                if (p[posp+pos+1] == p[posp+i] || p[posp+pos+1] == '?' || p[posp+i] == '?') {\\n                    (*lut)[i] = ++pos;\\n                } else {\\n                    (*lut)[i] = -1;\\n                }\\n            }\\n        }\\n        int MyStrStr(const char *s, int poss, int lens, const char *p, int posp, int len) {\\n            if (lens - poss < len - posp) return -1;\\n            vector<int> lut(len);\\n            GetLut(p, posp, len, &lut);\\n            int pos = -1;\\n            for (int i = 0; i < lens - poss; ++i) {\\n                while (pos > -1 && p[posp+pos+1] != s[poss + i] && p[posp+pos+1] != '?')\\n                    pos = lut[pos];\\n                if (p[posp+pos+1] == s[poss+i] || p[posp+pos+1] == '?') {\\n                    ++pos;\\n                    if (pos == len - 1) {\\n                        return poss + i - len + 1;    \\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        bool isMatch(const char *s, const char *p) {\\n            int lens = 0;\\n            while (s[lens] != '\\\\0') ++lens;\\n            int lenp = 0;\\n            while (p[lenp] != '\\\\0') ++lenp;\\n            if (lens == 0 && lenp == 0) return true;\\n            if (lenp == 0) return false;\\n            vector<int> start;\\n            vector<int> len;\\n            int pos = 0;\\n            for (int i = 0; i < lenp; ++i) {\\n                if (p[i] != '*') {\\n                    if (i == 0 || p[i-1] == '*') {\\n                        pos = i;\\n                    }\\n                    if (i == lenp-1 || p[i+1] == '*') {\\n                        start.push_back(pos);\\n                        len.push_back(i - pos + 1);\\n                    }\\n                }\\n            }\\n            if (start.empty()) return true;\\n            if (lens == 0 && !start.empty()) return false;\\n            int poss = 0;\\n            for (int i = 0; i < start.size(); ++i) {\\n                int matchedpos = MyStrStr(s, poss, lens, p, start[i], len[i]);\\n                if (matchedpos == -1) return false;\\n                if (i ==  0 && p[0] != '*' && matchedpos > 0) return false;\\n                poss = matchedpos + len[i];\\n            }\\n            if (start.size() == 1 && p[lenp-1] != '*' && p[0] != '*') {\\n                if (lenp != lens) return false;\\n                return 0 == MyStrStr(s, 0, lens, p, 0, lenp);\\n            }\\n            if (p[lenp-1] != '*') {\\n                int matchedpos = MyStrStr(s, lens - len[len.size()-1], lens, p, start[start.size()-1], len[len.size()-1]);\\n                if (matchedpos == -1) return false;\\n            }\\n            return true;\\n        }\\n    };\\n\\nstring p can be divided into several substring by '\\\\*'. Match the first substring of p from starting point of string s, then second substring after the matchpoint of the first, and so on. If match is not found, return false. If the first element of p is not '*', the first match must be 0. If the last element of p is not '*', the last match must be at end of s. \\n\\ntime complexity is O(n + m) where n is length of s and m is length of p.\\n\\nWe are using a slightly change of KMP (for '?') to do string matching. For each substring of p, let's say we found a match in s, so the time for this search is O(matchedpos + len(substr of p)). For next substring of p, we do a KMP from the mathcedpos + len(prev substr of p)) in s. If we could match all substrings of p in s, the time will be O(len(s) + len(p)). We did some modifications at the end but it didnot change the time complexity.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void GetLut(const char *p, int posp, int len, vector<int> *lut) {\\n            (*lut)[0] = -1;\\n            int pos = -1;\\n            for (int i = 1; i < len; ++i) {\\n                while (pos > -1 && p[posp+pos+1] != p[posp + i] && p[posp+pos+1] != '?' && p[posp+i] != '?')\\n                    pos = (*lut)[pos];\\n                if (p[posp+pos+1] == p[posp+i] || p[posp+pos+1] == '?' || p[posp+i] == '?') {\\n                    (*lut)[i] = ++pos;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2472083,
                "title": "python-dfs-memo-simple-with-comments",
                "content": "Simple DFS + memoization (via ```@cache```), beats 70%\\n\\n```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n\\n        # i is index in s, j is index in p\\n        @cache\\n        def dfs(i,j):\\n            # reached both string and pattern ends - matched\\n            if i >= n and j >= m:\\n                return True\\n\\n            # reached pattern end but not string end - not matched\\n            if j >= m:\\n                return False\\n\\n            # match characters under i and j indexes (plus additional check whether we reached end of string), move both indexes forward\\n            if i < n and (s[i] == p[j] or p[j] == \"?\"):\\n                return dfs(i + 1, j + 1)\\n\\n            # for wildcard there are two options:\\n            #   1) use it and move i forward (plus additional check whether we reached end of string)\\n            #   2) do not use it and move j forward\\n            if (p[j] == \"*\"):\\n                return (i < n and dfs(i + 1, j)) or dfs(i, j + 1)\\n\\n            # no wildcard and not matched (or reached end of string before reaching end of pattern)\\n            return False\\n\\n        return dfs(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```@cache```\n```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n, m = len(s), len(p)\\n\\n        # i is index in s, j is index in p\\n        @cache\\n        def dfs(i,j):\\n            # reached both string and pattern ends - matched\\n            if i >= n and j >= m:\\n                return True\\n\\n            # reached pattern end but not string end - not matched\\n            if j >= m:\\n                return False\\n\\n            # match characters under i and j indexes (plus additional check whether we reached end of string), move both indexes forward\\n            if i < n and (s[i] == p[j] or p[j] == \"?\"):\\n                return dfs(i + 1, j + 1)\\n\\n            # for wildcard there are two options:\\n            #   1) use it and move i forward (plus additional check whether we reached end of string)\\n            #   2) do not use it and move j forward\\n            if (p[j] == \"*\"):\\n                return (i < n and dfs(i + 1, j)) or dfs(i, j + 1)\\n\\n            # no wildcard and not matched (or reached end of string before reaching end of pattern)\\n            return False\\n\\n        return dfs(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 498316,
                "title": "dp-very-intuitive-with-no-bullshit-for-interviews-more-simpler-than-most-voted",
                "content": "\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tboolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n\\t\\tdp[0][0] = true;\\n\\n\\t\\tfor (int i = 1; i <= p.length(); i++) {\\n\\t\\t  if (p.charAt(i - 1) == \\'*\\') {\\n\\t\\t\\tdp[0][i] = dp[0][i - 1];\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= s.length(); i++) {\\n\\t\\t  for (int j = 1; j <= p.length(); j++) {\\n\\t\\t\\tchar sch = s.charAt(i - 1);\\n\\t\\t\\tchar pch = p.charAt(j - 1);\\n\\n\\t\\t\\tif (sch == pch || pch == \\'?\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t} else if (pch == \\'*\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn dp[s.length()][p.length()];\\n\\t  }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tboolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n\\t\\tdp[0][0] = true;\\n\\n\\t\\tfor (int i = 1; i <= p.length(); i++) {\\n\\t\\t  if (p.charAt(i - 1) == \\'*\\') {\\n\\t\\t\\tdp[0][i] = dp[0][i - 1];\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= s.length(); i++) {\\n\\t\\t  for (int j = 1; j <= p.length(); j++) {\\n\\t\\t\\tchar sch = s.charAt(i - 1);\\n\\t\\t\\tchar pch = p.charAt(j - 1);\\n\\n\\t\\t\\tif (sch == pch || pch == \\'?\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t} else if (pch == \\'*\\') {\\n\\t\\t\\t  dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j];\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\n\\t\\treturn dp[s.length()][p.length()];\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 17977,
                "title": "i-got-memory-limit-exceeded",
                "content": "Following is my code, I don't know what I got the Memory Limit Exceeded error.\\n\\n\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tint lenS = s.length();\\n\\t\\tint lenP = p.length();\\n\\n\\t\\tboolean[][] dp = new boolean[lenS + 1][lenP + 1];\\n\\t\\tdp[0][0] = true;\\n\\t\\tfor (int i = 1; i <= lenS; i++) {\\n\\t\\t\\tfor (int j = 1; j <= lenP; j++) {\\n\\t\\t\\t\\tif (p.charAt(j - 1) == '*') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];\\n\\t\\t\\t\\t\\tif (j == lenP && dp[i][j]) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (s.charAt(i - 1) == p.charAt(j - 1)\\n\\t\\t\\t\\t\\t\\t|| p.charAt(j - 1) == '?') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[lenS][lenP];\\n\\t}",
                "solutionTags": [],
                "code": "Following is my code, I don't know what I got the Memory Limit Exceeded error.\\n\\n\\tpublic boolean isMatch(String s, String p) {\\n\\t\\tint lenS = s.length();\\n\\t\\tint lenP = p.length();\\n\\n\\t\\tboolean[][] dp = new boolean[lenS + 1][lenP + 1];\\n\\t\\tdp[0][0] = true;\\n\\t\\tfor (int i = 1; i <= lenS; i++) {\\n\\t\\t\\tfor (int j = 1; j <= lenP; j++) {\\n\\t\\t\\t\\tif (p.charAt(j - 1) == '*') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 1];\\n\\t\\t\\t\\t\\tif (j == lenP && dp[i][j]) {\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if (s.charAt(i - 1) == p.charAt(j - 1)\\n\\t\\t\\t\\t\\t\\t|| p.charAt(j - 1) == '?') {\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i - 1][j - 1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[lenS][lenP];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2276916,
                "title": "java-solution-memoization-tabulation-dp",
                "content": "Here I am both types of DP solution, Memoization and Tabulation.\\nYou will get TLE in memoization solution.\\n\\nIf you like the solution, then please UPVOTE it :)\\n\\nMemoization Solution\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        if(j == 0 && i!= 0)\\n            return false;\\n        \\n        boolean[][] dp = new boolean[i][j];\\n        return match(s,p,i-1,j-1,dp);\\n    }\\n    \\n    public boolean match(String s , String p , int i , int j , boolean[][] dp)\\n    {\\n        if(i < 0 && j < 0)\\n            return true;\\n        \\n        if(i < 0){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p.charAt(k) != \\'*\\')\\n                    return false;\\n            \\n            return true;\\n        }\\n        \\n        if(j < 0)\\n        {\\n            return false;\\n        }\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\') dp[i][j] = match(s,p,i-1,j-1,dp);\\n        else if(p.charAt(j) == \\'*\\') dp[i][j] = match(s,p,i-1,j,dp) | match(s,p,i,j-1,dp);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n```\\n\\nTabulation Solution\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        \\n        boolean[][] dp = new boolean[i+1][j+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for (int k = 1; k < j + 1; k++) {\\n            if (p.charAt(k - 1) == \\'*\\') {\\n                dp[0][k] = dp[0][k-1];\\n            }\\n        }\\n        \\n        \\n        for(int x = 1 ; x <= i ; x++)\\n        {\\n            for(int y = 1 ; y <= j ; y++){\\n                if(s.charAt(x-1) == p.charAt(y-1) || p.charAt(y-1) == \\'?\\')   \\n                    dp[x][y] = dp[x-1][y-1];\\n                else if(p.charAt(y-1) == \\'*\\')   \\n                    dp[x][y] = (dp[x-1][y] | dp[x][y-1]);\\n            }\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}\\n```\\n\\nHaven\\'t UPVOTED yet, can do it now :)",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        if(j == 0 && i!= 0)\\n            return false;\\n        \\n        boolean[][] dp = new boolean[i][j];\\n        return match(s,p,i-1,j-1,dp);\\n    }\\n    \\n    public boolean match(String s , String p , int i , int j , boolean[][] dp)\\n    {\\n        if(i < 0 && j < 0)\\n            return true;\\n        \\n        if(i < 0){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p.charAt(k) != \\'*\\')\\n                    return false;\\n            \\n            return true;\\n        }\\n        \\n        if(j < 0)\\n        {\\n            return false;\\n        }\\n        \\n        if(dp[i][j])\\n            return dp[i][j];\\n        \\n        if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\') dp[i][j] = match(s,p,i-1,j-1,dp);\\n        else if(p.charAt(j) == \\'*\\') dp[i][j] = match(s,p,i-1,j,dp) | match(s,p,i,j-1,dp);\\n        \\n        return dp[i][j];\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int i = s.length();\\n        int j = p.length();\\n        \\n        boolean[][] dp = new boolean[i+1][j+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for (int k = 1; k < j + 1; k++) {\\n            if (p.charAt(k - 1) == \\'*\\') {\\n                dp[0][k] = dp[0][k-1];\\n            }\\n        }\\n        \\n        \\n        for(int x = 1 ; x <= i ; x++)\\n        {\\n            for(int y = 1 ; y <= j ; y++){\\n                if(s.charAt(x-1) == p.charAt(y-1) || p.charAt(y-1) == \\'?\\')   \\n                    dp[x][y] = dp[x-1][y-1];\\n                else if(p.charAt(y-1) == \\'*\\')   \\n                    dp[x][y] = (dp[x-1][y] | dp[x][y-1]);\\n            }\\n        }\\n        \\n        return dp[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604847,
                "title": "py3-py-simple-solution-using-recursion-w-comments",
                "content": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n       \\n        # Init\\n        n = len(s)\\n        m = len(p)\\n       \\n        @cache # memoization\\n        def match(s_idx, p_idx) -> bool:\\n            \\n            # Wait for pattern to be exhausted\\n            if p_idx == m:\\n                return s_idx == n # string must be exhausted if it matches the pattern\\n            \\n            elif s_idx > n: # if string is exhausted before pattern is exhausted, return False\\n                return False\\n            \\n            else: # for all other scenarios\\n                \\n                # see if string matches the current pattern\\n                matched = ((s_idx < n) and (s[s_idx] == p[p_idx])) or (p[p_idx] in [\"*\", \"?\"])\\n                \\n                # if nothing matches, return false\\n                if not matched:\\n                    return False\\n                \\n                else: # in case of a match\\n                    \\n                    # check if pattern has \"*\"\\n                    if p[p_idx] == \"*\":\\n                        return (match(s_idx+1, p_idx) or # increment string index and stay at same pattern index\\n                                match(s_idx+1,p_idx+1) or # increment both string and patter index\\n                                match(s_idx, p_idx+1)) # increment pattern index and stay at the same string index\\n                    \\n                    else: # if pattern doesn\\'t have \"*\", then it either have \"?\" or same char as string\\n                        return match(s_idx+1, p_idx+1) # increment both string and pattern index\\n        \\n        return match(0,0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nfrom functools import cache\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n       \\n        # Init\\n        n = len(s)\\n        m = len(p)\\n       \\n        @cache # memoization\\n        def match(s_idx, p_idx) -> bool:\\n            \\n            # Wait for pattern to be exhausted\\n            if p_idx == m:\\n                return s_idx == n # string must be exhausted if it matches the pattern\\n            \\n            elif s_idx > n: # if string is exhausted before pattern is exhausted, return False\\n                return False\\n            \\n            else: # for all other scenarios\\n                \\n                # see if string matches the current pattern\\n                matched = ((s_idx < n) and (s[s_idx] == p[p_idx])) or (p[p_idx] in [\"*\", \"?\"])\\n                \\n                # if nothing matches, return false\\n                if not matched:\\n                    return False\\n                \\n                else: # in case of a match\\n                    \\n                    # check if pattern has \"*\"\\n                    if p[p_idx] == \"*\":\\n                        return (match(s_idx+1, p_idx) or # increment string index and stay at same pattern index\\n                                match(s_idx+1,p_idx+1) or # increment both string and patter index\\n                                match(s_idx, p_idx+1)) # increment pattern index and stay at the same string index\\n                    \\n                    else: # if pattern doesn\\'t have \"*\", then it either have \"?\" or same char as string\\n                        return match(s_idx+1, p_idx+1) # increment both string and pattern index\\n        \\n        return match(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016045,
                "title": "python-top-down-dynamic-programming",
                "content": "We track which character we are up to comparing between both strings, by using `s_idx` and `p_idx`\\n\\nThe recurrence relation is constructed from the following:\\n* If the current character of p is \"\\\\*\", we can...\\n\\t* Treat \\\\* as empty by skipping over it - `is_match(s, p, s_idx, p_idx + 1)`\\n\\t* Treat \\\\* as many characters - `is_match(s, p, s_idx + 1, p)`\\n\\t* Treat \\\\* as one character, so we increment both s_idx and p_idx by 1 - `is_match(s, p, s_idx + 1, p_idx + 1)`\\n* Otherwise, the current character is `?` or a letter, so...\\n    * For both `?` and letter, we simply advance the indexes by 1 - `is_match(s, p, s_idx + 1, p_idx + 1)`\\n\\n```\\nclass Solution:\\n    def is_match(self, s, p, s_idx, p_idx):\\n\\t    # reached end of both strings, it must have matched\\n        if s_idx >= len(s) and p_idx >= len(p):\\n            return True\\n  \\n\\t\\t# reached end of s, but there are still characters in p remaining\\n        if s_idx >= len(s) and p_idx < len(p):\\n\\t\\t    # if any character remaining in p, is not \"*\"\\n\\t\\t\\t# that means we have nothing in s to match, so return False\\n            for i in range(p_idx, len(p)):\\n                if p[i] != \"*\":\\n                    return False\\n            return True\\n        \\n\\t\\t# if we have reached end of p, but not end of s, this means\\n\\t\\t# we do not have sufficient characters in the pattern to match s\\n\\t\\t# return false\\n        if s_idx < len(s) and p_idx >= len(p):\\n            return False\\n        \\n        if (s_idx, p_idx) in self.dp:\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        s_char = s[s_idx]\\n        p_char = p[p_idx]\\n        \\n        if p_char.isalpha() and s_char != p_char:\\n            return False\\n        \\n        if p_char == \"*\":\\n            skip_star = self.is_match(s, p, s_idx, p_idx + 1)\\n            use_star = self.is_match(s, p, s_idx + 1, p_idx)\\n            not_use_star = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n            \\n            self.dp[(s_idx, p_idx)] = skip_star or use_star or not_use_star\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        self.dp[(s_idx, p_idx)] = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n        return self.dp[(s_idx, p_idx)]        \\n\\n\\n    def isMatch(self, s: str, p: str) -> bool:        \\n        self.dp = {}\\n        return self.is_match(s, p, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def is_match(self, s, p, s_idx, p_idx):\\n\\t    # reached end of both strings, it must have matched\\n        if s_idx >= len(s) and p_idx >= len(p):\\n            return True\\n  \\n\\t\\t# reached end of s, but there are still characters in p remaining\\n        if s_idx >= len(s) and p_idx < len(p):\\n\\t\\t    # if any character remaining in p, is not \"*\"\\n\\t\\t\\t# that means we have nothing in s to match, so return False\\n            for i in range(p_idx, len(p)):\\n                if p[i] != \"*\":\\n                    return False\\n            return True\\n        \\n\\t\\t# if we have reached end of p, but not end of s, this means\\n\\t\\t# we do not have sufficient characters in the pattern to match s\\n\\t\\t# return false\\n        if s_idx < len(s) and p_idx >= len(p):\\n            return False\\n        \\n        if (s_idx, p_idx) in self.dp:\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        s_char = s[s_idx]\\n        p_char = p[p_idx]\\n        \\n        if p_char.isalpha() and s_char != p_char:\\n            return False\\n        \\n        if p_char == \"*\":\\n            skip_star = self.is_match(s, p, s_idx, p_idx + 1)\\n            use_star = self.is_match(s, p, s_idx + 1, p_idx)\\n            not_use_star = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n            \\n            self.dp[(s_idx, p_idx)] = skip_star or use_star or not_use_star\\n            return self.dp[(s_idx, p_idx)]\\n        \\n        self.dp[(s_idx, p_idx)] = self.is_match(s, p, s_idx + 1, p_idx + 1)\\n        return self.dp[(s_idx, p_idx)]        \\n\\n\\n    def isMatch(self, s: str, p: str) -> bool:        \\n        self.dp = {}\\n        return self.is_match(s, p, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 155277,
                "title": "o-mn-time-o-mn-space-dp-solution-python-with-explanation",
                "content": "I probably could have combined some clauses, but it works.  The idea is that we need to go through all of the characters in the string, and the pattern and end up with true path at the end for it to return true.\\nThis means the current cell is true in the following cases:\\n1.  the current cell\\'s letters  i-1th letter from the string and j-1th letter from the string match and the dp[i-1][j-1] is true which means the previous two letter\\'s compared was true.\\n2.  if the current i-1th letter is * then we let all of the cases pass and the future cases pass so if dp[i-1][j] or dp[i][j-1] is true we mark dp[i][j] as true, this means all values ahead of this column will be marked as true\\n3.  if the current i-1th letter is ? then we just copy dp[i-1][j-1] (if the last letter matched was true)\\nThe branches are just to make sure we don\\'t have an out of range error since there\\'s a variety cases of i-1 and j-1s that can be less than 0 or that cases that we don\\'t have enough characters to get the i-1th or j-1th character, and probably can be cleaned up.\\nVisual Example:\\n```\\ns=\"adceb\"\\np=\"*a*b\"\\n     0       a       d    c         e     b\\n0  [true,  false,  false, false,  false, false]\\n*  [true,  true,   true,  true,   true,  true ]\\na  [false, true,   false, false,  false, false]\\n*  [false, true,   true,  true,   true,  true ]\\nb  [false,  false, false, false,  false, true ]\\n\\n```\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        N1 = len(p)\\n        N2 = len(s)\\n        dp = [[False for j in range(N2+1)] for i in range(N1+1)]\\n        for i in range(N1+1):\\n            for j in range(N2+1):\\n                if(i==0 and j==0):\\n                    dp[i][j]=True\\n                elif(j==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i-1][j]));\\n                elif(i==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i][j-1]));\\n                else:\\n                    dp[i][j]=((dp[i-1][j-1] and (N1>0 and N2>0 and p[i-1]==s[j-1]))or\\n                              (N1>0 and p[i-1]==\\'*\\' and (dp[i-1][j] or dp[i][j-1])) or \\n                              (N1>0 and p[i-1]==\\'?\\' and dp[i-1][j-1]))\\n        return dp[N1][N2]\\n```",
                "solutionTags": [],
                "code": "```\\ns=\"adceb\"\\np=\"*a*b\"\\n     0       a       d    c         e     b\\n0  [true,  false,  false, false,  false, false]\\n*  [true,  true,   true,  true,   true,  true ]\\na  [false, true,   false, false,  false, false]\\n*  [false, true,   true,  true,   true,  true ]\\nb  [false,  false, false, false,  false, true ]\\n\\n```\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        N1 = len(p)\\n        N2 = len(s)\\n        dp = [[False for j in range(N2+1)] for i in range(N1+1)]\\n        for i in range(N1+1):\\n            for j in range(N2+1):\\n                if(i==0 and j==0):\\n                    dp[i][j]=True\\n                elif(j==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i-1][j]));\\n                elif(i==0):\\n                    dp[i][j]= (N1>0 and i>0 and p[i-1]==\\'*\\' and (dp[i][j-1]));\\n                else:\\n                    dp[i][j]=((dp[i-1][j-1] and (N1>0 and N2>0 and p[i-1]==s[j-1]))or\\n                              (N1>0 and p[i-1]==\\'*\\' and (dp[i-1][j] or dp[i][j-1])) or \\n                              (N1>0 and p[i-1]==\\'?\\' and dp[i-1][j-1]))\\n        return dp[N1][N2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17878,
                "title": "brief-6ms-c-code",
                "content": "```\\nbool isMatch(char* s, char* p) {\\n    char *p0 = NULL, *s0 = NULL;\\n    while (*s) {\\n        if (*p == *s || *p == '?') {\\n            p++; \\n            s++;\\n        }else if (*p == '*') { // save\\n            p0 = ++p;\\n            s0 = s;\\n        }else if (p0 != NULL) { // load\\n            p = p0;\\n            s = ++s0;\\n        }else {\\n            return false;\\n        }\\n    }\\n    while (*p == '*') p++;\\n    return !*s && !*p;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isMatch(char* s, char* p) {\\n    char *p0 = NULL, *s0 = NULL;\\n    while (*s) {\\n        if (*p == *s || *p == '?') {\\n            p++; \\n            s++;\\n        }else if (*p == '*') { // save\\n            p0 = ++p;\\n            s0 = s;\\n        }else if (p0 != NULL) { // load\\n            p = p0;\\n            s = ++s0;\\n        }else {\\n            return false;\\n        }\\n    }\\n    while (*p == '*') p++;\\n    return !*s && !*p;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090375,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     bool isMatch(string s, string p) {\\n        int m = s.size();\\n        int n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector(n + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < n && p[j] == \\'*\\'; j++) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        // return f(s, p, 0, 0);    \\n    }\\n    bool f(string& s, string &p, int i, int j) {\\n        if(j == p.size())\\n        return i == s.size();\\n\\n        if(i == s.size())\\n        return p[j]==\\'*\\' && f(s, p, i, j+1);\\n\\n        if(p[j] == \\'*\\')\\n        return f(s, p, i, j+1) || f(s, p, i+1, j);\\n\\n        if(s[i] == p[j] || p[j] == \\'?\\')\\n        return f(s, p, i+1, j+1);\\n\\n        return false;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool isMatch(string s, string p) {\\n        int m = s.size();\\n        int n = p.size();\\n        vector<vector<bool>> dp(m + 1, vector(n + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < n && p[j] == \\'*\\'; j++) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= m; ++i) {\\n            for (int j = 1; j <= n; ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        // return f(s, p, 0, 0);    \\n    }\\n    bool f(string& s, string &p, int i, int j) {\\n        if(j == p.size())\\n        return i == s.size();\\n\\n        if(i == s.size())\\n        return p[j]==\\'*\\' && f(s, p, i, j+1);\\n\\n        if(p[j] == \\'*\\')\\n        return f(s, p, i, j+1) || f(s, p, i+1, j);\\n\\n        if(s[i] == p[j] || p[j] == \\'?\\')\\n        return f(s, p, i+1, j+1);\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2580002,
                "title": "c-detailed-explaination-from-recursive-to-space-optimisation",
                "content": "## Approach:\\n\\n--> In this problem, we have to match `p` with `s` so here we can use string matching method in which we use 2 variables `i and j` and check for each character if they are matching or not.\\n\\n### If characters are matching:\\n\\nNow here we also have one extra condition which will be `if p[i] is \\'?\\'` and if it\\'s true then also we will consider it as match because `?` can match with any single character.\\n\\nSo for both of these conditions we will simply decrease both `i and j`.\\n\\n```cpp\\nif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\treturn solve(i-1,j-1);\\n}\\n```\\n\\n### If p[i] is \\'*\\':\\n\\n--> now here we have 2 conditions:\\n\\n1. If we assume `\\'*\\'` as sequence of length 0 (means empty string)\\nthen we will simply decrease `i` and keep `j` as it is.\\n2. If we assume `\\'*\\'` as p[i]\\nthen we will decrease `j`.\\n\\n--> we have to do this for every character because `*` can have any length of subsequence so we will have check all possibilities:\\n\\nthis recursive tree will look like this:\\n\\n![image](https://assets.leetcode.com/users/images/c61364a5-4e1b-42ce-9435-65e3f00ccd20_1663254206.0240915.png)\\n\\n```cpp\\nif(p[i] == \\'*\\'){\\n\\treturn solve(i-1,j) || solve(i,j-1);\\n}\\n```\\n\\n### If p[i] and s[j] are not matching:\\n\\nthen we will simply return `false`\\n\\n## Base case:\\n\\n--> So in base case, there can be 2 possibilities:\\n\\n1. If we have traversed the p string means i is negative:\\n\\nthen we will check if `j is also negative` and if it is then we will return `true` because both strings got traversed and if `j is not negative` then we will return `false`.\\n\\n```cpp\\nif(i<0){\\n\\treturn j<0;\\n}\\n```\\n\\n2. If we have traversed the s string means j is negative:\\n\\nHere we can compare empty string with only one thing which is `\\'*\\'` so if p have all characters as `*` then we will return true otherwise we will return false.\\n\\n```cpp\\nif(j<0){\\n\\tfor(int k=0;k<=i;k++){\\n\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\\n\\n## Recursive Code:\\n\\n```cpp\\n bool solve(int i,int j,string s,string p){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn solve(i-1,j-1,s,p);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn solve(i-1,j,s,p) || solve(i,j-1,s,p);\\n\\t}\\n\\t// if they are not matching\\n\\treturn false;\\n}\\nbool isMatch(string s, string p) {\\n\\treturn solve(p.size()-1,s.size()-1,s,p);\\n}\\n```\\n\\n## Memoization Code:\\n\\n```cpp\\nbool solve(int i,int j,string s,string p,vector<vector<int>>&dp){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s,p,dp);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j,s,p,dp) || solve(i,j-1,s,p,dp);\\n\\t}\\n\\t// if they are not matching\\n\\treturn dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) {\\n\\tint n = p.size(),m = s.size();\\n\\tvector<vector<int>>dp(n+1,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s,p,dp);\\n}\\n```\\n\\n## Tabulation Code:\\n\\n--> So in tabulation first we will write the base condition and also we have to change one thing which will ` we will use 1 based indexing` because in recursive code we are stopping at i or j becoming negative but we can\\'t do it here so we will use 1 based indexing.\\n\\nNow let\\'s see all base cases one by one:\\n\\n1. If i is 0 and j is also 0 then we will mark it as `true`\\n```cpp\\ndp[0][0] = true\\n```\\n\\n2. if i is 0 and j is greater than 0 then we will mark it as `false`.\\n\\n```cpp\\nfor(int j=1;j<=m;j++){\\n\\tdp[0][j] = false;\\n}\\n```\\n\\n3. if j is 0 then p must have all characters as `\\'*\\'` so that it can be matched with empty string.\\n\\n```cpp\\n// starting from 1 because it\\'s 1 based indexing.\\nfor(int i=1;i<=n;i++){\\n\\tbool flag = true;\\n\\tfor(int k=1;k<=i;k++){\\n\\t\\tif(p[k-1] != \\'*\\'){\\n\\t\\t\\tflag = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tdp[i][0] = flag;\\n}\\n```\\n\\nNow after base case we will just have to run one loop from i from `1 to n` and one nested loop for j from `1 to m` and just copy paste the logic from recursion code:\\n\\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        // case 1\\n        dp[0][0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = false;\\n        }\\n        // case 3\\n        for(int i=1;i<=n;i++){\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\\n\\n## Space optimisation:\\n\\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<bool>prev(m+1,0),curr(m+1,0);\\n        // case 1\\n        prev[0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            prev[j] = false;\\n        }\\n        for(int i=1;i<=n;i++){\\n\\t        // case 3\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            curr[0] = flag;\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    curr[j] = prev[j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    curr[j] = curr[j-1] || prev[j];\\n                }else{\\n                    curr[j] = false;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```cpp\\nif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\treturn solve(i-1,j-1);\\n}\\n```\n```cpp\\nif(p[i] == \\'*\\'){\\n\\treturn solve(i-1,j) || solve(i,j-1);\\n}\\n```\n```cpp\\nif(i<0){\\n\\treturn j<0;\\n}\\n```\n```cpp\\nif(j<0){\\n\\tfor(int k=0;k<=i;k++){\\n\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n}\\n```\n```cpp\\n bool solve(int i,int j,string s,string p){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn solve(i-1,j-1,s,p);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn solve(i-1,j,s,p) || solve(i,j-1,s,p);\\n\\t}\\n\\t// if they are not matching\\n\\treturn false;\\n}\\nbool isMatch(string s, string p) {\\n\\treturn solve(p.size()-1,s.size()-1,s,p);\\n}\\n```\n```cpp\\nbool solve(int i,int j,string s,string p,vector<vector<int>>&dp){\\n\\tif(i<0){\\n\\t\\treturn j<0;\\n\\t}\\n\\tif(j<0){\\n\\t\\tfor(int k=0;k<=i;k++){\\n\\t\\t\\tif(p[k] != \\'*\\'){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tif(dp[i][j] != -1){\\n\\t\\treturn dp[i][j];\\n\\t}\\n\\tif(p[i] == s[j] || p[i] == \\'?\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j-1,s,p,dp);\\n\\t}\\n\\telse if(p[i] == \\'*\\'){\\n\\t\\treturn dp[i][j] = solve(i-1,j,s,p,dp) || solve(i,j-1,s,p,dp);\\n\\t}\\n\\t// if they are not matching\\n\\treturn dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) {\\n\\tint n = p.size(),m = s.size();\\n\\tvector<vector<int>>dp(n+1,vector<int>(m,-1));\\n\\treturn solve(n-1,m-1,s,p,dp);\\n}\\n```\n```cpp\\ndp[0][0] = true\\n```\n```cpp\\nfor(int j=1;j<=m;j++){\\n\\tdp[0][j] = false;\\n}\\n```\n```cpp\\n// starting from 1 because it\\'s 1 based indexing.\\nfor(int i=1;i<=n;i++){\\n\\tbool flag = true;\\n\\tfor(int k=1;k<=i;k++){\\n\\t\\tif(p[k-1] != \\'*\\'){\\n\\t\\t\\tflag = false;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tdp[i][0] = flag;\\n}\\n```\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        // case 1\\n        dp[0][0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            dp[0][j] = false;\\n        }\\n        // case 3\\n        for(int i=1;i<=n;i++){\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = flag;\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                }else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n```\n```cpp\\nbool isMatch(string s, string p) {\\n        int n = p.size(),m = s.size();\\n        vector<bool>prev(m+1,0),curr(m+1,0);\\n        // case 1\\n        prev[0] = true;\\n        // case 2\\n        for(int j=1;j<=m;j++){\\n            prev[j] = false;\\n        }\\n        for(int i=1;i<=n;i++){\\n\\t        // case 3\\n            bool flag = true;\\n            for(int k=1;k<=i;k++){\\n                if(p[k-1] != \\'*\\'){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            curr[0] = flag;\\n            for(int j=1;j<=m;j++){\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\'){\\n                    curr[j] = prev[j-1];\\n                }else if(p[i-1] == \\'*\\'){\\n                    curr[j] = curr[j-1] || prev[j];\\n                }else{\\n                    curr[j] = false;\\n                }\\n            }\\n            prev = curr;\\n        }\\n        return prev[m];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460303,
                "title": "c-easy-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pattern) {\\n        int m=pattern.size();\\n        int n=str.size();\\n\\n        bool dp[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                dp[i][j]=false;\\n            }\\n        }\\n        dp[0][0]=true;            //if both string and pattern are empty\\n\\n        for(int i=1;i<=m;i++){\\n           if(pattern[i-1]==\\'*\\')  //if pattern starts with \\'*\\' \\n           dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str[i-1]==pattern[j-1] || pattern[j-1]==\\'?\\') //if the character matches or it a ? so we can replace it with any character, then answer depends on dp[i-1][j-1]\\n                dp[i][j]=dp[i-1][j-1];\\n                else if(pattern[j-1]==\\'*\\') //if it is a * then either we can skip 1 character of str or pattern\\n                dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string str, string pattern) {\\n        int m=pattern.size();\\n        int n=str.size();\\n\\n        bool dp[n+1][m+1];\\n        for(int i=0;i<n+1;i++){\\n            for(int j=0;j<m+1;j++){\\n                dp[i][j]=false;\\n            }\\n        }\\n        dp[0][0]=true;            //if both string and pattern are empty\\n\\n        for(int i=1;i<=m;i++){\\n           if(pattern[i-1]==\\'*\\')  //if pattern starts with \\'*\\' \\n           dp[0][i]=dp[0][i-1];\\n        }\\n        for(int i=1;i<n+1;i++){\\n            for(int j=1;j<m+1;j++){\\n                if(str[i-1]==pattern[j-1] || pattern[j-1]==\\'?\\') //if the character matches or it a ? so we can replace it with any character, then answer depends on dp[i-1][j-1]\\n                dp[i][j]=dp[i-1][j-1];\\n                else if(pattern[j-1]==\\'*\\') //if it is a * then either we can skip 1 character of str or pattern\\n                dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1401330,
                "title": "c-dp-solution-with-comments-explaining-the-code",
                "content": "Scroll right to see the full comments\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length() , n = s.length();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][0] = 1; // Empty string matches empty string\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            if(p[i-1] == \\'*\\')\\n                dp[i][0] = dp[i-1][0]; // Any number of * matches empty string // E.g : ** and \\'\\'\\n        }\\n        // Note that we are using 0-based indexing for strings and in the dp table 0th positon indicates empty string hence we are checking for p[i-1] && s[j-1]\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            for(int j = 1 ; j <= n ; ++j)\\n            {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\') // If the ith character of p and jth character of s is same or ith character of p is \\'?\\' then exclude ith and jth characters of p and s and check whether the rest of the strings upto (i-1)th in p and (j-1)th in s are matching E.g : ab and ab or ab and a?\\n                    dp[i][j] = dp[i-1][j-1];\\n                else // if p[i-1] != s[j-1]\\n                    if(p[i-1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1]; // If ith character of p is \\'*\\' then we have two choices : 1) make it null character in which case we check whether string upto (i-1)th character in p and upto jth character in s are matched E.g : ab and ab* 2) match the jth character in s in which case we check whether the string upto ith character in p and (j-1) th character in s are matched E.g : abcd and ab*\\n                    }\\n            }\\n        }\\n        return dp[m][n]; // If both the strings were fully matched\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length() , n = s.length();\\n        vector<vector<int>> dp(m+1,vector<int>(n+1,0));\\n        dp[0][0] = 1; // Empty string matches empty string\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            if(p[i-1] == \\'*\\')\\n                dp[i][0] = dp[i-1][0]; // Any number of * matches empty string // E.g : ** and \\'\\'\\n        }\\n        // Note that we are using 0-based indexing for strings and in the dp table 0th positon indicates empty string hence we are checking for p[i-1] && s[j-1]\\n        for(int i = 1 ; i <= m ; ++i)\\n        {\\n            for(int j = 1 ; j <= n ; ++j)\\n            {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\') // If the ith character of p and jth character of s is same or ith character of p is \\'?\\' then exclude ith and jth characters of p and s and check whether the rest of the strings upto (i-1)th in p and (j-1)th in s are matching E.g : ab and ab or ab and a?\\n                    dp[i][j] = dp[i-1][j-1];\\n                else // if p[i-1] != s[j-1]\\n                    if(p[i-1] == \\'*\\')\\n                    {\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1]; // If ith character of p is \\'*\\' then we have two choices : 1) make it null character in which case we check whether string upto (i-1)th character in p and upto jth character in s are matched E.g : ab and ab* 2) match the jth character in s in which case we check whether the string upto ith character in p and (j-1) th character in s are matched E.g : abcd and ab*\\n                    }\\n            }\\n        }\\n        return dp[m][n]; // If both the strings were fully matched\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365119,
                "title": "no-dp-60-ms-faster-than-87-73-of-python3-double-pointer-question",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i = j = 0  \\n        back_j = -1  \\n        match_i = 0   \\n        m = len(s)\\n        n = len(p)\\n        while i < m:\\n            if j < n and (s[i] == p[j] or p[j] == \\'?\\'):  \\n                i += 1\\n                j += 1\\n            elif j < n and p[j] == \\'*\\':  \\n                back_j = j  \\n                match_i = i  \\n                j += 1  \\n            elif back_j != -1:  \\n                j = back_j + 1\\n                match_i += 1  \\n                i = match_i\\n            else:  \\n                return False\\n            print(p[j:])\\n        return list(p[j:]).count(\\'*\\') == len(p[j:]) \\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        i = j = 0  \\n        back_j = -1  \\n        match_i = 0   \\n        m = len(s)\\n        n = len(p)\\n        while i < m:\\n            if j < n and (s[i] == p[j] or p[j] == \\'?\\'):  \\n                i += 1\\n                j += 1\\n            elif j < n and p[j] == \\'*\\':  \\n                back_j = j  \\n                match_i = i  \\n                j += 1  \\n            elif back_j != -1:  \\n                j = back_j + 1\\n                match_i += 1  \\n                i = match_i\\n            else:  \\n                return False\\n            print(p[j:])\\n        return list(p[j:]).count(\\'*\\') == len(p[j:]) \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1228581,
                "title": "backtracking-97-faster-javascript-version-of-official-solution-es6",
                "content": "`Approach:` Backtracking\\n`Algorithm:`\\n- Initiate 3 pointers: \\n\\tpointer for pattern-index\\n\\tpointer for string-index\\n\\tpointer for temporary-index when we encounter \"*\" in pattern\\n- Initiate a variable for storing index-position of star \"*\"\\n- both string pointer and pattern pointer are moved forward by 1 step whenever:\\n\\tchars in string and pattern match OR\\n\\tchar in string matches with \"?\" in pattern\\n- Only pattern pointer is moved by a step when we encounter a \"*\"\\n- Only string pointer is moved when a char  doesn\\'t match with char in pattern\\n- The starIndex acts as a reference point during entire iteration\\n- The temp-index along with string-index are constantly updated when chars in pattern and string do not match. \\n\\n`Code:`\\n```\\nconst isMatch = function (string, pattern) {\\n  let s = 0, p = 0;\\n  let starIdx = -1, pointer = -1;\\n\\n  while (s < string.length) {\\n    if ((p < pattern.length && string[s] === pattern[p]) || pattern[p] === \"?\") {\\n      s++;\\n      p++;\\n    } \\n\\telse if (p < pattern.length && pattern[p] === \"*\") {\\n      starIdx = p;\\n      pointer = s;\\n      p++;\\n    } \\n\\telse if (starIdx === -1) return false;\\n    else {\\n      p = starIdx + 1;\\n      s = pointer + 1;\\n      pointer = s;\\n    }\\n  }\\n  for (let idx = p; idx < pattern.length; idx++) {\\n    if (pattern[idx] !== \"*\") return false;\\n  }\\n  return true;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/c629aa14-6b86-48a5-a535-ff42e006c84e_1621887091.1771438.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nconst isMatch = function (string, pattern) {\\n  let s = 0, p = 0;\\n  let starIdx = -1, pointer = -1;\\n\\n  while (s < string.length) {\\n    if ((p < pattern.length && string[s] === pattern[p]) || pattern[p] === \"?\") {\\n      s++;\\n      p++;\\n    } \\n\\telse if (p < pattern.length && pattern[p] === \"*\") {\\n      starIdx = p;\\n      pointer = s;\\n      p++;\\n    } \\n\\telse if (starIdx === -1) return false;\\n    else {\\n      p = starIdx + 1;\\n      s = pointer + 1;\\n      pointer = s;\\n    }\\n  }\\n  for (let idx = p; idx < pattern.length; idx++) {\\n    if (pattern[idx] !== \"*\") return false;\\n  }\\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799513,
                "title": "javascript-solutions",
                "content": "This is my original solution with help from [here](https://leetcode.com/problems/wildcard-matching/discuss/370736/Detailed-Intuition-From-Brute-force-to-Bottom-up-DP). It recursively goes through the two lists, and uses an object for memoization to help with performance.\\n\\n```\\nvar isMatch1 = function(s, p) {\\n    return helper(s, p, 0, 0, {})\\n};\\n\\nlet helper = function(s, p, sIndex, pIndex, memo) {\\n    if (\"S\" + sIndex + \"P\" + pIndex in memo) return memo[\"S\" + sIndex + \"P\" + pIndex]\\n    let res = false\\n    if (pIndex == p.length && sIndex == s.length) res = true\\n    else if (pIndex == p.length) res = false\\n    else if (sIndex == s.length) res = p[pIndex] == \"*\" && helper(s, p, sIndex, pIndex + 1, memo)\\n    else if (p[pIndex] == \"*\") res =  helper(s, p, sIndex, pIndex + 1, memo) || helper(s, p, sIndex + 1, pIndex, memo)\\n    else if (s[sIndex] == p[pIndex] || p[pIndex] == \"?\") res = helper(s, p, sIndex + 1, pIndex + 1, memo)\\n    else res = false\\n    memo[\"S\" + sIndex + \"P\" + pIndex] = res\\n    return res\\n}\\n\\nfunction allStars(input) {\\n    return input && input.split(\\'\\').every(char => char === \"*\");\\n}\\n```\\nThis is a javascript implmentation of [this solution](https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution). It has the key insight that you only ever need to care about the most recent asterisk, and not every asterick. Thus we only need to keep track of that asterick, and reset whenever we hit a failure state.\\n```\\nvar isMatch2 = function(s, p) {\\n    let sIndex = 0, pIndex = 0, star, ss = sIndex\\n    while(sIndex < s.length) {\\n        console.log(sIndex, pIndex, star, ss)\\n        if (p[pIndex] == \"?\" || p[pIndex] == s[sIndex]) { sIndex++; pIndex++ }\\n        else if (p[pIndex] == \"*\") { star = pIndex++; ss = sIndex }\\n        else if (star != undefined) { pIndex = star + 1; sIndex = ++ss }\\n        else return false\\n    }\\n    while(p[pIndex] == \"*\") {pIndex++}\\n    return pIndex == p.length\\n}\\n```\\n\\nThis is a javascript implementation of [this solution](https://leetcode.com/problems/wildcard-matching/discuss/256025/Python-DP-with-illustration). It uses dp to keep track of which states are valid given the string/pattern seen up until that point.\\n\\n```\\nvar isMatch3 = function(s, p) {\\n    let dp = []\\n    for (let i = 0; i < s.length + 1; i++) {\\n        let arr = new Array(p.length + 1).fill(false)\\n        dp.push(arr)\\n    }\\n    dp[0][0] = true\\n    for (let i = 1; i < p.length + 1; i++) {\\n        if(p[i - 1] != \\'*\\') break\\n        else dp[0][i] = true\\n    }\\n    for (let i = 1; i < s.length + 1; i++) {\\n        for (let j = 1; j < p.length + 1; j++) {\\n            if (p[j - 1] == s[i - 1] || p[j - 1] == \"?\") {dp[i][j] = dp[i-1][j-1]}\\n            else if (p[j - 1] == \"*\") {dp[i][j] = dp[i-1][j] || dp[i][j-1]}\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```\\n\\nHappy coding!\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isMatch1 = function(s, p) {\\n    return helper(s, p, 0, 0, {})\\n};\\n\\nlet helper = function(s, p, sIndex, pIndex, memo) {\\n    if (\"S\" + sIndex + \"P\" + pIndex in memo) return memo[\"S\" + sIndex + \"P\" + pIndex]\\n    let res = false\\n    if (pIndex == p.length && sIndex == s.length) res = true\\n    else if (pIndex == p.length) res = false\\n    else if (sIndex == s.length) res = p[pIndex] == \"*\" && helper(s, p, sIndex, pIndex + 1, memo)\\n    else if (p[pIndex] == \"*\") res =  helper(s, p, sIndex, pIndex + 1, memo) || helper(s, p, sIndex + 1, pIndex, memo)\\n    else if (s[sIndex] == p[pIndex] || p[pIndex] == \"?\") res = helper(s, p, sIndex + 1, pIndex + 1, memo)\\n    else res = false\\n    memo[\"S\" + sIndex + \"P\" + pIndex] = res\\n    return res\\n}\\n\\nfunction allStars(input) {\\n    return input && input.split(\\'\\').every(char => char === \"*\");\\n}\\n```\n```\\nvar isMatch2 = function(s, p) {\\n    let sIndex = 0, pIndex = 0, star, ss = sIndex\\n    while(sIndex < s.length) {\\n        console.log(sIndex, pIndex, star, ss)\\n        if (p[pIndex] == \"?\" || p[pIndex] == s[sIndex]) { sIndex++; pIndex++ }\\n        else if (p[pIndex] == \"*\") { star = pIndex++; ss = sIndex }\\n        else if (star != undefined) { pIndex = star + 1; sIndex = ++ss }\\n        else return false\\n    }\\n    while(p[pIndex] == \"*\") {pIndex++}\\n    return pIndex == p.length\\n}\\n```\n```\\nvar isMatch3 = function(s, p) {\\n    let dp = []\\n    for (let i = 0; i < s.length + 1; i++) {\\n        let arr = new Array(p.length + 1).fill(false)\\n        dp.push(arr)\\n    }\\n    dp[0][0] = true\\n    for (let i = 1; i < p.length + 1; i++) {\\n        if(p[i - 1] != \\'*\\') break\\n        else dp[0][i] = true\\n    }\\n    for (let i = 1; i < s.length + 1; i++) {\\n        for (let j = 1; j < p.length + 1; j++) {\\n            if (p[j - 1] == s[i - 1] || p[j - 1] == \"?\") {dp[i][j] = dp[i-1][j-1]}\\n            else if (p[j - 1] == \"*\") {dp[i][j] = dp[i-1][j] || dp[i][j-1]}\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 314824,
                "title": "java-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.length() == 0 && p.length() == 0) return true;\\n        int i = 0;\\n        int j = 0;\\n        int star = -1;\\n        int match = 0;\\n        while (i < s.length()) {\\n            if (j < p.length() && (p.charAt(j) == s.charAt(i) || p.charAt(j) == \\'?\\')) {\\n                i++;\\n                j++;\\n            }else if (j < p.length() && p.charAt(j) == \\'*\\') {\\n                star = j;\\n                match = i;\\n                j++;\\n            }else if (star != -1) {\\n                j = star + 1;\\n                match++;\\n                i = match;\\n            }else return false;\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') j++;\\n        return j == p.length();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.length() == 0 && p.length() == 0) return true;\\n        int i = 0;\\n        int j = 0;\\n        int star = -1;\\n        int match = 0;\\n        while (i < s.length()) {\\n            if (j < p.length() && (p.charAt(j) == s.charAt(i) || p.charAt(j) == \\'?\\')) {\\n                i++;\\n                j++;\\n            }else if (j < p.length() && p.charAt(j) == \\'*\\') {\\n                star = j;\\n                match = i;\\n                j++;\\n            }else if (star != -1) {\\n                j = star + 1;\\n                match++;\\n                i = match;\\n            }else return false;\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') j++;\\n        return j == p.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17844,
                "title": "java-recursive-solution",
                "content": "```\\npublic class Solution {\\n    public boolean isMatch(String s, String p) {\\n        return helper(s.toCharArray(), p.toCharArray(), 0, 0, 0, -1);\\n    }\\n    \\n    private boolean helper(char[] s, char[] p, int i, int j, int lastS, int lastP) {\\n        if(i == s.length && j == p.length) return true;\\n        if(j < p.length) {\\n            if(i == s.length)\\n                return p[j] == '*' ? helper(s, p, i, j + 1, lastS, lastP) : false;\\n            if(p[j] == '?' || s[i] == p[j])\\n                return helper(s, p, i + 1, j + 1, lastS, lastP);\\n            if(p[j] == '*')\\n                return helper(s, p, i, j + 1, i, j);\\n        }\\n        if(lastP != -1) return helper(s, p, lastS + 1, lastP, lastS + 1, lastP);\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isMatch(String s, String p) {\\n        return helper(s.toCharArray(), p.toCharArray(), 0, 0, 0, -1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 17900,
                "title": "beat-99-runtime-103-o-n-time-o-1-space",
                "content": "first approach works and run beats over 90%, second approach cannot work but wanna seek advice.\\n\\nLoop\\n\\n1. keep two pointers in S and P here i and j\\n\\n2. if S[i] == P[j] or P[j] == '?' we keep moving\\n3. if '*' exist in P then we mark the position in P as star and mark position in s as s_star\\n4. Loop over s until S[i] == P[star + 1]\\notherwise\\n  False\\n\\nnote that S = 'a' P = 'a*******' is still True\\nSo we need to loop over P to check this case  \\n\\n\\n \\nif we can compare p to the end that  means True\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        star = -1\\n        s_star = 0\\n        s_len = len(s)\\n        p_len = len(p)\\n        while i < s_len:\\n            if i < s_len and j < p_len and (s[i] == p[j] or p[j] == '?'):\\n                i += 1\\n                j += 1\\n            elif j < p_len and p[j] == '*':\\n                star = j\\n                s_star = i\\n                j += 1\\n            elif star != -1:\\n                j = star + 1\\n                s_star += 1\\n                i = s_star\\n            else:\\n                return False\\n        while j < p_len and p[j] == '*':\\n            j += 1\\n        return j == p_len\\n        \\nI have also Tried more traditional method with O(MN) space and Time but get LTE suggestions?\\n\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s_len = len(s)\\n        p_len = len(p)\\n        dp = [[False for _ in range(p_len + 1)] for _ in range(s_len + 1)]\\n        dp[0][0] = True\\n        for col in range(1, p_len + 1):\\n            dp[0][col] = dp[0][col - 1] and p[col - 1] == '*'\\n        \\n        for row in range(1, s_len + 1):\\n            for col in range(1, p_len + 1):\\n                if p[col - 1] == '*':\\n                    dp[row][col] = dp[row][col - 1] or dp[row - 1][col - 1]\\n                else:\\n                    dp[row][col] = dp[row - 1][col - 1] and (s[row - 1] == p[col - 1] or p[col - 1] == '?')\\n        return dp[-1][-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "first approach works and run beats over 90%, second approach cannot work but wanna seek advice.\\n\\nLoop\\n\\n1. keep two pointers in S and P here i and j\\n\\n2. if S[i] == P[j] or P[j] == '?' we keep moving\\n3. if '*' exist in P then we mark the position in P as star and mark position in s as s_star\\n4. Loop over s until S[i] == P[star + 1]\\notherwise\\n  False\\n\\nnote that S = 'a' P = 'a*******' is still True\\nSo we need to loop over P to check this case  \\n\\n\\n \\nif we can compare p to the end that  means True\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        i = 0\\n        j = 0\\n        star = -1\\n        s_star = 0\\n        s_len = len(s)\\n        p_len = len(p)\\n        while i < s_len:\\n            if i < s_len and j < p_len and (s[i] == p[j] or p[j] == '?'):\\n                i += 1\\n                j += 1\\n            elif j < p_len and p[j] == '*':\\n                star = j\\n                s_star = i\\n                j += 1\\n            elif star != -1:\\n                j = star + 1\\n                s_star += 1\\n                i = s_star\\n            else:\\n                return False\\n        while j < p_len and p[j] == '*':\\n            j += 1\\n        return j == p_len\\n        \\nI have also Tried more traditional method with O(MN) space and Time but get LTE suggestions?\\n\\n\\n    class Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s_len = len(s)\\n        p_len = len(p)\\n        dp = [[False for _ in range(p_len + 1)] for _ in range(s_len + 1)]\\n        dp[0][0] = True\\n        for col in range(1, p_len + 1):\\n            dp[0][col] = dp[0][col - 1] and p[col - 1] == '*'\\n        \\n        for row in range(1, s_len + 1):\\n            for col in range(1, p_len + 1):\\n                if p[col - 1] == '*':\\n                    dp[row][col] = dp[row][col - 1] or dp[row - 1][col - 1]\\n                else:\\n                    dp[row][col] = dp[row - 1][col - 1] and (s[row - 1] == p[col - 1] or p[col - 1] == '?')\\n        return dp[-1][-1]",
                "codeTag": "Java"
            },
            {
                "id": 17946,
                "title": "share-my-straight-forward-dp-java-code-o-n-2-complexity",
                "content": "    class Solution {\\n        public boolean isMatch(String s, String p) {\\n            //little trick here to avoid checking some corner cases\\n            return _isMatch(\"a\" + s, \"a\" + p);\\n        }\\n        public boolean _isMatch(String s, String p) {\\n            boolean[][] valid = new boolean[p.length()][s.length()];\\n            valid[0][0] = true;\\n            for(int i = 1; i < p.length(); ++i){  \\t\\n                valid[i][0] = p.charAt(i) == '*' && valid[i-1][0];\\n            }\\n            for(int j = 1; j < s.length(); ++j){\\n                valid[0][j] = false;\\n            }\\n            for(int i = 1; i < p.length(); ++i){\\n                for(int j = 1; j < s.length(); ++j){\\n                    if(p.charAt(i) == '*'){\\n                        valid[i][j] = valid[i-1][j] || valid[i-1][j-1] || valid[i][j-1];\\n                    }else if( p.charAt(i) == '?'){\\n                        valid[i][j] = valid[i-1][j-1];\\n                    }else{\\n                        valid[i][j] = valid[i-1][j-1] && p.charAt(i) == s.charAt(j);\\n                    }\\n                }\\n            }\\n            return valid[p.length()-1][s.length()-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isMatch(String s, String p) {\\n            //little trick here to avoid checking some corner cases\\n            return _isMatch(\"a\" + s, \"a\" + p);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 17947,
                "title": "c-solution-in-string-parameters",
                "content": "    class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if(s.compare(p)) return true;\\n            int ssize = (int) s.size();\\n            int psize = (int) p.size();\\n            int i=0,j=0,pi=0,pj=psize;\\n            while(i<ssize){\\n                if(s[i]==p[j]||p[j]=='?'){\\n                    i++;\\n                    j++;\\n                    continue;\\n                }\\n                if(p[j]=='*'){\\n                    pj = j++;\\n                    pi = i;\\n                    continue;\\n                }\\n                if(pj<psize){\\n                    j = pj + 1;\\n                    i = ++pi;\\n                    continue;\\n                }\\n                return false;\\n            }\\n           while(p[j]=='*'){\\n               j++;\\n           }\\n           return j==psize;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isMatch(string s, string p) {\\n            if(s.compare(p)) return true;\\n            int ssize = (int) s.size();\\n            int psize = (int) p.size();\\n            int i=0,j=0,pi=0,pj=psize;\\n            while(i<ssize){\\n                if(s[i]==p[j]||p[j]=='?'){\\n                    i++;\\n                    j++;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3613570,
                "title": "c-memization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &a,int &b,string &s,string &p,vector<vector<int>> &dp){\\n        if(i==a && j==b)return 1;\\n        else if(i==a){\\n            while(j<b && p[j]==\\'*\\')j++;\\n            return j==b;\\n        }\\n        else if(i != a && j == b)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        bool c = false;\\n        while(j<b && p[j]==\\'*\\'){j++;c = true;}\\n        \\n        if(c)j--;\\n        if(p[j]==\\'?\\'){\\n            dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n        }else if(p[j]==\\'*\\'){\\n            dp[i][j] = solve(i+1,j,a,b,s,p,dp)||solve(i,j+1,a,b,s,p,dp);\\n        }else{\\n            if(s[i]==p[j]){\\n                dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n            }else{\\n                dp[i][j] = 0;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    bool isMatch(string s, string p) {\\n        int a = s.length(),b= p.length();\\n        vector<vector<int>> dp(a,vector<int>(b,-1));\\n        return solve(0,0,a,b,s,p,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int j,int &a,int &b,string &s,string &p,vector<vector<int>> &dp){\\n        if(i==a && j==b)return 1;\\n        else if(i==a){\\n            while(j<b && p[j]==\\'*\\')j++;\\n            return j==b;\\n        }\\n        else if(i != a && j == b)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        bool c = false;\\n        while(j<b && p[j]==\\'*\\'){j++;c = true;}\\n        \\n        if(c)j--;\\n        if(p[j]==\\'?\\'){\\n            dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n        }else if(p[j]==\\'*\\'){\\n            dp[i][j] = solve(i+1,j,a,b,s,p,dp)||solve(i,j+1,a,b,s,p,dp);\\n        }else{\\n            if(s[i]==p[j]){\\n                dp[i][j] = solve(i+1,j+1,a,b,s,p,dp);\\n            }else{\\n                dp[i][j] = 0;\\n            }\\n        }\\n        return dp[i][j];\\n    }\\n    bool isMatch(string s, string p) {\\n        int a = s.length(),b= p.length();\\n        vector<vector<int>> dp(a,vector<int>(b,-1));\\n        return solve(0,0,a,b,s,p,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298717,
                "title": "python-bottom-up-dp-solution",
                "content": "\\n# Code\\n```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n = len(s);\\n        m = len(p);\\n        dp = [[0]*(m+1) for _ in range(0,n+1)]\\n\\n        dp[0][0] = 1\\n        for j in range(1,m+1):\\n            if(p[j-1] == \\'*\\' ): dp[0][j] = dp[0][j-1];\\n\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if(s[i-1] == p[j-1] or p[j-1] == \\'?\\' ): dp[i][j] = dp[i-1][j-1]\\n                elif( p[j-1] == \\'*\\' ):\\n                    # did we match without the chracter in s or did we match with the character before \\'*\\' in p\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n\\n        return dp[-1][-1]\\n    \\n               \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def isMatch(self, s: str, p: str) -> bool:\\n        n = len(s);\\n        m = len(p);\\n        dp = [[0]*(m+1) for _ in range(0,n+1)]\\n\\n        dp[0][0] = 1\\n        for j in range(1,m+1):\\n            if(p[j-1] == \\'*\\' ): dp[0][j] = dp[0][j-1];\\n\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if(s[i-1] == p[j-1] or p[j-1] == \\'?\\' ): dp[i][j] = dp[i-1][j-1]\\n                elif( p[j-1] == \\'*\\' ):\\n                    # did we match without the chracter in s or did we match with the character before \\'*\\' in p\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n\\n        return dp[-1][-1]\\n    \\n               \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2704132,
                "title": "memoization-to-tabulation",
                "content": "\\n# **Memoization:-**\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    int helper(int i,int j,string s,string p,vector<vector<int>>& dp){\\n         \\n         if(i==0 && j==0 )    return true;\\n         \\n         if(i==0 || j==0 )    {\\n            \\n            if(i==0 && p[j-1]==\\'*\\') return helper(i,j-1,s,p,dp);  \\n            else                    return false;\\n             \\n         }\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n  \\n        if(p[j-1]==\\'*\\' || p[j-1]==\\'?\\' ){\\n            \\n         if(p[j-1]==\\'?\\') return dp[i][j]=helper(i-1,j-1,s,p,dp);\\n         else            return dp[i][j]=(helper(i-1,j,s,p,dp) || helper(i-1,j-1,s,p,dp) || helper(i,j-1,s,p,dp));\\n            \\n        }\\n        else {\\n            if(s[i-1]==p[j-1]) return dp[i][j]=helper(i-1,j-1,s,p,dp);\\n            else               return false;    \\n        }\\n    }\\n\\t\\n    bool isMatch(string s, string p) {\\n    \\n        int n1=s.size();\\n        int n2=p.size();\\n        \\n        vector<vector<int>> dp(n1+1,vector<int> (n2+1,-1));\\n        return helper(s.size(),p.size(),s,p,dp);\\n    }\\n};\\n\\nSaldy it didn\\'t work so i need to convert it to tabulator form\\n\\n# **Tabulation:-**\\n\\nclass Solution {\\npublic:\\n        \\n    bool isMatch(string s, string p) {\\n    \\n        int n1=s.size();\\n        int n2=p.size();\\n        \\n        vector<vector<bool>> dp(n1+1,vector<bool> (n2+1,false));\\n        \\n        for(int i=0;i<=n1;++i){\\n            \\n            for(int j=0;j<=n2;++j){\\n                \\n                if(i==0 && j==0) dp[i][j]=true;\\n                else if (i==0 || j==0){\\n                    \\n\\t\\t\\t\\t\\t if(i==0 && p[j-1]==\\'*\\') dp[i][j]=dp[i][j-1];  \\n\\t\\t\\t\\t\\t else                    dp[i][j]=false;  \\n\\t\\t\\t\\t\\t \\n                }\\n               else if(p[j-1]==\\'*\\' || p[j-1]==\\'?\\' ){\\n\\t\\t\\t   \\n                 if (p[j-1]==\\'?\\') dp[i][j]=dp[i-1][j-1];\\n                 else             dp[i][j]=dp[i-1][j] + dp[i-1][j-1] + dp[i][j-1];\\n              \\n\\t\\t\\t  }\\n            else{\\n                if(s[i-1]==p[j-1]) dp[i][j]=dp[i-1][j-1];\\n                else               dp[i][j]=false;  \\n              }    \\n           }           \\n        }\\n        return dp[n1][n2];  \\n    }\\n};\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int helper(int i,int j,string s,string p,vector<vector<int>>& dp){\\n         \\n         if(i==0 && j==0 )    return true;\\n         \\n         if(i==0 || j==0 )    {\\n            \\n            if(i==0 && p[j-1]==\\'*\\') return helper(i,j-1,s,p,dp);  \\n            else                    return false;\\n             \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2686738,
                "title": "why-has-leetcode-started-blocking-recursive-approaches",
                "content": "i used a bottom up dp ,\\nwent from calculating from 0 , 0  to n - 1 , m  - 1 \\nbut the solution resulted in TLE ,  i was doubting my time complexity , but the same solution passed in GFG \\nNot sure why leetcode has started blocking recursive solutions",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1992492,
                "title": "greatly-explained-two-methods-dfs-memo-dp-in-python-very-easy-to-understand",
                "content": "**Very classical question** that could be solved using **DFS + Memo** & **DP**!\\n\\n**General View:**\\nThe challenge part is * .\\nIt could match any number of characters.\\nSo how to deal with * is **the key**!\\n\\n**Take an example:**\\nIf we match * with every possible number of characters, then the divisions in each level could be many\\n```\\n\\t\\t  (*ab, abc)\\n\\t  /     |       \\\\     \\\\\\n(ab, abc) (ab, bc) (ab, c) (ab, \\'\\')\\n```\\nIf we give match only two options, not match or match (* will stay for next level), the the divisions in each level is two.\\n```\\n\\t(*ab, abc)\\n\\t  /   \\\\\\n(ab, ab)  (*ab, b)\\t  \\n```\\nIt is obvious that **the latter one is better**! That is how we will deal with * .\\n\\n**Method 1:**\\n**DFS + Memoization**\\n\\nWhenever will come across a * , we will generate two paths, either **not match any** or **match**.\\nHowever, that is not enough, since we might have duplicate states when we have ***continuing*** * .\\n**For example:**\\n```\\n       (**, abc)\\n\\t    /   \\\\\\n\\t(*, abc)  (**, bc)\\n\\t/      \\\\     /   \\\\\\n(\\'\\', abc) (*, bc) (**, c)\\n```\\nThe state (* , bc) will be reached from different paths. Meaning that we could use **memoization**!\\nThe time will be reduced from O(2 ^ n) to O(m * n).\\n\\nWe will use index of the string as the signature of each state. Every state reached will be stored in the memo hash.\\n\\n**Time:** O(m * n), m is the length of string s, n is the length of string p\\n**Space:** O(m * n)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n        s_index, p_index = 0, 0\\n        return self.memo_dfs(s, s_index, p, p_index, memo)\\n    \\n    def memo_dfs(self, s, i, p, j, memo): \\n        \\n        if len(p) == j:\\n            return len(s) == i\\n        \\n        if len(s) == i:\\n            for index in range(j, len(p)):\\n                if p[index] != \\'*\\':\\n                    return False\\n            return True\\n        \\n        if (i, j) in memo:\\n            return memo[(i, j)]\\n\\n        if p[j] != \\'*\\':\\n            matched =  (s[i] == p[j] or p[j] == \\'?\\') and self.memo_dfs(s, i + 1, p, j + 1, memo)\\n        else:  # matched & not matched\\n            matched = self.memo_dfs(s, i + 1, p, j, memo) or self.memo_dfs(s, i, p, j + 1, memo)\\n        \\n        memo[(i, j)] = matched\\n        \\n        return matched\\n```\\n\\n**Method 2:**\\n**DP**\\n\\nThe idea is very similar, **dp[i][j]** means that by index i of s and by index j of p, whether there is a matching.\\n\\n**Time:** O(m * n), m is the length of string s, n is the length of string p\\n**Space:** O(m * n)\\n\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if s is None or p is None:\\n            return False\\n        \\n        m, n = len(s), len(p)\\n        \\n        dp = [[False] * (n + 1) for _ in range(2)]\\n        \\n        dp[0][0] = True\\n        for i in range(1, n + 1): # the case that p starts with some *\\n            dp[0][i] = dp[0][i - 1] and p[i - 1] == \\'*\\'\\n        \\n        for i in range(1, m + 1):\\n            dp[i % 2][0] = False # Note that: we might miss this!\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\': # match & no match \\n                    dp[i % 2][j] = dp[(i - 1) % 2][j] or dp[i % 2][j - 1]\\n                else:\\n                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] and (\\n                        s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\')\\n        \\n        return dp[m % 2][n]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n\\t\\t  (*ab, abc)\\n\\t  /     |       \\\\     \\\\\\n(ab, abc) (ab, bc) (ab, c) (ab, \\'\\')\\n```\n```\\n\\t(*ab, abc)\\n\\t  /   \\\\\\n(ab, ab)  (*ab, b)\\t  \\n```\n```\\n       (**, abc)\\n\\t    /   \\\\\\n\\t(*, abc)  (**, bc)\\n\\t/      \\\\     /   \\\\\\n(\\'\\', abc) (*, bc) (**, c)\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n        s_index, p_index = 0, 0\\n        return self.memo_dfs(s, s_index, p, p_index, memo)\\n    \\n    def memo_dfs(self, s, i, p, j, memo): \\n        \\n        if len(p) == j:\\n            return len(s) == i\\n        \\n        if len(s) == i:\\n            for index in range(j, len(p)):\\n                if p[index] != \\'*\\':\\n                    return False\\n            return True\\n        \\n        if (i, j) in memo:\\n            return memo[(i, j)]\\n\\n        if p[j] != \\'*\\':\\n            matched =  (s[i] == p[j] or p[j] == \\'?\\') and self.memo_dfs(s, i + 1, p, j + 1, memo)\\n        else:  # matched & not matched\\n            matched = self.memo_dfs(s, i + 1, p, j, memo) or self.memo_dfs(s, i, p, j + 1, memo)\\n        \\n        memo[(i, j)] = matched\\n        \\n        return matched\\n```\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if s is None or p is None:\\n            return False\\n        \\n        m, n = len(s), len(p)\\n        \\n        dp = [[False] * (n + 1) for _ in range(2)]\\n        \\n        dp[0][0] = True\\n        for i in range(1, n + 1): # the case that p starts with some *\\n            dp[0][i] = dp[0][i - 1] and p[i - 1] == \\'*\\'\\n        \\n        for i in range(1, m + 1):\\n            dp[i % 2][0] = False # Note that: we might miss this!\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\': # match & no match \\n                    dp[i % 2][j] = dp[(i - 1) % 2][j] or dp[i % 2][j - 1]\\n                else:\\n                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] and (\\n                        s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\')\\n        \\n        return dp[m % 2][n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434132,
                "title": "python3-top-down-bottom-up-dp-solutions",
                "content": "**Time Complexity:** O(m*n)\\n**Space Complexity:** O(m*n)\\n\\n**Some tips I use to become better at Top-down DP (feel free to give suggestions):**\\n1. When thinking in top-down DP manner, always begin with termination conditions. (What happens when i reaches the end or when j reaches the end?)\\n2. What happens when we encounter a special condition? (e.g. What happens when p[j-1] == \\'*\\'?)\\n3. In a top-down manner, since the **final** result will only be available when we hit the termination condition, when we increment i or j, it means that we can \\'omit\\' either one or both of them. For instance, when p[j] and s[i] matches or when p[j] equals to the \"match everything\" special character, we can increment both i and j (by \\'omitting\\' them and only consider characters after i and after j)\\n4. Always think recursively. Memoization can be as simple as one line (which can be achieved by the cache decorator in Python)\\n5. Practice and practice. Good luck!\\n\\n**Steps I follow when I do bottom-up DP (suggestions are welcome):**\\n1. Start with base condition (e.g. What if both strings are empty? i.e. dp[0][0] = True. What if one string is empty and another is not? Pre-populate those values)\\n2. When we say dp[i][j] = dp[i-1][j-1], it means we can \\'increment\\' i and j, similar to top-down manner. This is because we can omit calculation for current string and simply \"bridge the cap\" with the previous results. (Not sure if this makes sense)\\n\\nHope this helps. When I first started, I remember I was really bad at DP. But as I practice more I\\'m getting better every day. Never give up -- I\\'m sure you will get there soon.\\n\\n**Solution 1: Top-down DP (memoization)**\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n\\t\\t@cache\\n\\t\\tdef dp(i, j):\\n\\t\\t\\tif j >= len(p):\\n\\t\\t\\t\\treturn i == len(s)\\n\\t\\t\\t# When s reaches the end, p must be empty or contains only * (since * can also be used to represent empty string)\\n\\t\\t\\tif i >= len(s):\\n\\t\\t\\t\\treturn not p[j:] or p[j:] == \\'*\\'*len(p[j:])\\n\\t\\t\\t# Since \\'*\\' can be used to represent any sequence of characters including empty string, we can either increment i or j.\\n\\t\\t\\tif p[j] == \\'*\\':\\n\\t\\t\\t\\treturn dp(i+1, j) or dp(i, j+1)\\n\\t\\t\\tif p[j] in {s[i], \\'?\\'}:\\n\\t\\t\\t\\treturn dp(i+1, j+1)\\n\\t\\t\\treturn False\\n\\t\\treturn dp(0, 0)\\n```\\n\\n**Solution 2: Bottom up DP**\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False]*(n+1) for _ in range(m+1)]\\n        # When s and p are both empty, they must match.\\n        dp[0][0] = True\\n        \\n        for j in range(1, n+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```\\n\\nEdit: \\n**Solution 1 (no slicing)**\\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @cache\\n        def dp(i, j):\\n            if j >= len(p):\\n                return i == len(s)\\n            if i < len(s) and p[j] in {s[i], \\'?\\'}:\\n                return dp(i+1, j+1)\\n            if p[j] == \\'*\\':\\n                if i < len(s):\\n                    return dp(i+1, j) or dp(i, j+1)\\n                return dp(i, j+1)\\n        return dp(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n\\t\\t@cache\\n\\t\\tdef dp(i, j):\\n\\t\\t\\tif j >= len(p):\\n\\t\\t\\t\\treturn i == len(s)\\n\\t\\t\\t# When s reaches the end, p must be empty or contains only * (since * can also be used to represent empty string)\\n\\t\\t\\tif i >= len(s):\\n\\t\\t\\t\\treturn not p[j:] or p[j:] == \\'*\\'*len(p[j:])\\n\\t\\t\\t# Since \\'*\\' can be used to represent any sequence of characters including empty string, we can either increment i or j.\\n\\t\\t\\tif p[j] == \\'*\\':\\n\\t\\t\\t\\treturn dp(i+1, j) or dp(i, j+1)\\n\\t\\t\\tif p[j] in {s[i], \\'?\\'}:\\n\\t\\t\\t\\treturn dp(i+1, j+1)\\n\\t\\t\\treturn False\\n\\t\\treturn dp(0, 0)\\n```\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False]*(n+1) for _ in range(m+1)]\\n        # When s and p are both empty, they must match.\\n        dp[0][0] = True\\n        \\n        for j in range(1, n+1):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = True\\n        \\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if p[j-1] in {s[i-1], \\'?\\'}:\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j] or dp[i][j-1]\\n        return dp[-1][-1]\\n```\n```python\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        @cache\\n        def dp(i, j):\\n            if j >= len(p):\\n                return i == len(s)\\n            if i < len(s) and p[j] in {s[i], \\'?\\'}:\\n                return dp(i+1, j+1)\\n            if p[j] == \\'*\\':\\n                if i < len(s):\\n                    return dp(i+1, j) or dp(i, j+1)\\n                return dp(i, j+1)\\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321336,
                "title": "recursion-memorization-explanation-with-comments-in-code-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        dp[i][j]==(-1) means dp[i][j] not calculated yet\\n        dp[i][j]==  1 means answer is true\\n        dp[i][j]==  0 means answer is false\\n    */\\n    \\n    bool search(string &s,string &pattern,int i,int j,vector<vector<int>>&dp){\\n        // i correspond to index in s\\n        //and j correspond to index in pattern\\n\\n        if(i==s.size()&&j==pattern.size()){// both substrings are empty\\n            return true;\\n        }\\n        \\n        //We have reched at last character of pattern and it is *, then answer is true\\n        if(j==pattern.size()-1&&pattern[j]==\\'*\\'){\\n            return true;\\n        }\\n\\n        //Either of them is empty but not both,then pattern can\\'t be matched\\n        if(i==s.size()||j==pattern.size()){\\n            return false;\\n        }\\n        \\n        //Already calculated,then return value directly\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        /*\\n         current character in pattern is lowercase letter,\\n        then if both characters are matching then make function call with both indices incremented, otherwise if they are not matching return false\\n        \\n        if current character in pattern is \\'?\\', then make function call with both indices incremented\\n        \\n        otherwise current character is *. In that case, * can replace subsequence of any  length in original string.\\n        Therefore check for all possibilities of * \\n        \\n        */\\n        \\n        if(pattern[j]!=\\'*\\'&&pattern[j]!=\\'?\\'){\\n            if(pattern[j]!=s[i]){\\n                return false;\\n            }\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else if(pattern[j]==\\'?\\'){\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else{\\n            bool ans=false;\\n            for(int k=i;k<=s.size();k++){\\n                ans=search(s,pattern,k,j+1,dp);\\n                if(ans){\\n                    break;\\n                }\\n            }\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        string pattern;\\n        // consecutive sequence of * can be replaced with single *\\n        // Thereofre pattern will not have any consecutive *\\n        for(int i=0;i<p.size();i++){\\n            if(pattern.back()==\\'*\\'&&p[i]==\\'*\\'){\\n                continue;\\n            }\\n            pattern.push_back(p[i]);\\n        }\\n        vector<vector<int>>dp(s.size()+1,vector<int>(pattern.size()+1,-1));\\n        return search(s,pattern,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        dp[i][j]==(-1) means dp[i][j] not calculated yet\\n        dp[i][j]==  1 means answer is true\\n        dp[i][j]==  0 means answer is false\\n    */\\n    \\n    bool search(string &s,string &pattern,int i,int j,vector<vector<int>>&dp){\\n        // i correspond to index in s\\n        //and j correspond to index in pattern\\n\\n        if(i==s.size()&&j==pattern.size()){// both substrings are empty\\n            return true;\\n        }\\n        \\n        //We have reched at last character of pattern and it is *, then answer is true\\n        if(j==pattern.size()-1&&pattern[j]==\\'*\\'){\\n            return true;\\n        }\\n\\n        //Either of them is empty but not both,then pattern can\\'t be matched\\n        if(i==s.size()||j==pattern.size()){\\n            return false;\\n        }\\n        \\n        //Already calculated,then return value directly\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        \\n        /*\\n         current character in pattern is lowercase letter,\\n        then if both characters are matching then make function call with both indices incremented, otherwise if they are not matching return false\\n        \\n        if current character in pattern is \\'?\\', then make function call with both indices incremented\\n        \\n        otherwise current character is *. In that case, * can replace subsequence of any  length in original string.\\n        Therefore check for all possibilities of * \\n        \\n        */\\n        \\n        if(pattern[j]!=\\'*\\'&&pattern[j]!=\\'?\\'){\\n            if(pattern[j]!=s[i]){\\n                return false;\\n            }\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else if(pattern[j]==\\'?\\'){\\n            return dp[i][j]=search(s,pattern,i+1,j+1,dp);\\n        }else{\\n            bool ans=false;\\n            for(int k=i;k<=s.size();k++){\\n                ans=search(s,pattern,k,j+1,dp);\\n                if(ans){\\n                    break;\\n                }\\n            }\\n            return dp[i][j]=ans;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        string pattern;\\n        // consecutive sequence of * can be replaced with single *\\n        // Thereofre pattern will not have any consecutive *\\n        for(int i=0;i<p.size();i++){\\n            if(pattern.back()==\\'*\\'&&p[i]==\\'*\\'){\\n                continue;\\n            }\\n            pattern.push_back(p[i]);\\n        }\\n        vector<vector<int>>dp(s.size()+1,vector<int>(pattern.size()+1,-1));\\n        return search(s,pattern,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1165389,
                "title": "python3-with-explanation",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        sPos, pPos = 0, 0\\n        starPos, wildPos = -1, -1\\n        while (sPos < len(s)):\\n            if pPos < len(p) and p[pPos] in (\\'?\\', s[sPos]): #match one char in p\\n                pPos += 1\\n                sPos += 1\\n            elif pPos < len(p) and p[pPos] == \\'*\\': #match * begin\\n                starPos, wildPos = pPos, sPos # record the start position and the wildcard beginning position\\n                pPos += 1\\n            else:\\n                # not match, backtrack use *\\n                if (starPos < 0): return False\\n                pPos = starPos + 1 # p position reset to the next one after recorded star\\n                sPos = wildPos + 1 # s position set to next one from the wildcard pos\\n                wildPos += 1 # use the * to match one more\\n            \\n        \\n        while pPos < len(p) and p[pPos] == \\'*\\':\\n               pPos += 1 # skip the remaining * in p\\n        return pPos == len(p)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        sPos, pPos = 0, 0\\n        starPos, wildPos = -1, -1\\n        while (sPos < len(s)):\\n            if pPos < len(p) and p[pPos] in (\\'?\\', s[sPos]): #match one char in p\\n                pPos += 1\\n                sPos += 1\\n            elif pPos < len(p) and p[pPos] == \\'*\\': #match * begin\\n                starPos, wildPos = pPos, sPos # record the start position and the wildcard beginning position\\n                pPos += 1\\n            else:\\n                # not match, backtrack use *\\n                if (starPos < 0): return False\\n                pPos = starPos + 1 # p position reset to the next one after recorded star\\n                sPos = wildPos + 1 # s position set to next one from the wildcard pos\\n                wildPos += 1 # use the * to match one more\\n            \\n        \\n        while pPos < len(p) and p[pPos] == \\'*\\':\\n               pPos += 1 # skip the remaining * in p\\n        return pPos == len(p)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 957748,
                "title": "python-non-deterministic-finite-automaton-nfa",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return False if s else True\\n        \\n        delta = collections.defaultdict(int)\\n        delta[(0, \\'*\\')] = 0\\n        state = 1\\n        for c in p:\\n            if c == \\'*\\':\\n                delta[(state, \\'*\\')] = state\\n                continue\\n                \\n            delta[(state, c)] = state + 1\\n            state += 1\\n        \\n        accept_state = state\\n        cur_states = set([1])\\n        i = 0\\n        while i < len(s):\\n            next_states = set()\\n            cur_char = s[i]\\n            for cur_state in cur_states:\\n                if (cur_state, \\'*\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'*\\')])\\n                    \\n                if (cur_state, \\'?\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'?\\')])\\n                else:\\n                    next_states.add(delta[(cur_state, cur_char)])\\n            \\n            cur_states = next_states\\n            i += 1\\n        \\n        return accept_state in cur_states and i == len(s) \\n```\\n\\nIf you have taken a class on finite automata then this solution should be really simple to understand, otherwise it might feel cryptic. Hopfully this provides a different perspective than other solutions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return False if s else True\\n        \\n        delta = collections.defaultdict(int)\\n        delta[(0, \\'*\\')] = 0\\n        state = 1\\n        for c in p:\\n            if c == \\'*\\':\\n                delta[(state, \\'*\\')] = state\\n                continue\\n                \\n            delta[(state, c)] = state + 1\\n            state += 1\\n        \\n        accept_state = state\\n        cur_states = set([1])\\n        i = 0\\n        while i < len(s):\\n            next_states = set()\\n            cur_char = s[i]\\n            for cur_state in cur_states:\\n                if (cur_state, \\'*\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'*\\')])\\n                    \\n                if (cur_state, \\'?\\') in delta:\\n                    next_states.add(delta[(cur_state, \\'?\\')])\\n                else:\\n                    next_states.add(delta[(cur_state, cur_char)])\\n            \\n            cur_states = next_states\\n            i += 1\\n        \\n        return accept_state in cur_states and i == len(s) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 644094,
                "title": "java-fast-memoization-dp-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    int[][] memo; // 0 indicates haven\\'t found, -1 is not possible, 1 is possible!\\n    \\n    public boolean isMatch(String s, String p) {\\n        memo = new int[s.length() + 1][p.length() + 1];\\n        return dfs(s, p, 0, 0);\\n    }\\n    \\n    public boolean dfs(String s, String p, int p1, int p2) {\\n        \\n        // let\\'s check if \\n        if (p1 == s.length()) {\\n            \\n            // keep advancing the star characters!\\n            while (p2 < p.length() && p.charAt(p2) == \\'*\\')\\n                p2++;\\n            \\n            // did we get to the end?\\n            if (p2 == p.length()) {\\n                memo[p1][p2] = 1;\\n                return true;\\n            }\\n            \\n            memo[p1][p2] = -1;\\n            return false;\\n        // still have characters left!\\n        } else if (p2 == p.length()) {\\n            memo[p1][p2] = -1;\\n            return false;\\n        }\\n        \\n        if (memo[p1][p2] == -1)\\n            return false;\\n        \\n        if (memo[p1][p2] == 1)\\n            return true;\\n        \\n        boolean possible = false;\\n        \\n        if (p.charAt(p2) == \\'?\\')\\n            possible = dfs(s, p, p1 + 1, p2 + 1);\\n        else if (p.charAt(p2) == \\'*\\') {\\n            // useless starting * (match zero), matches more than one character character, matches this exact character\\n            possible = dfs(s, p, p1, p2 + 1) || dfs(s, p, p1 + 1, p2) || dfs(s, p, p1 + 1, p2 + 1);\\n        }     \\n        else\\n            if (s.charAt(p1) == p.charAt(p2))\\n                possible = dfs(s, p, p1 + 1, p2 + 1);\\n        \\n        memo[p1][p2] = possible ? 1 : -1;\\n        return possible;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n    \\n    int[][] memo; // 0 indicates haven\\'t found, -1 is not possible, 1 is possible!\\n    \\n    public boolean isMatch(String s, String p) {\\n        memo = new int[s.length() + 1][p.length() + 1];\\n        return dfs(s, p, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 487431,
                "title": "python-dp-top-down-similar-to-regex-matching",
                "content": "```\\ndef isMatch(self, s: str, p: str) -> bool:\\n    dp = [[False for i in range(len(p)+1)] for j in range(len(s)+1)]\\n    dp[0][0]= True\\n    for i in range(1,len(p)+1):\\n        if p[i-1]==\\'*\\':\\n            dp[0][i] = dp[0][i-1]\\n    for i in range(1, len(s)+1):\\n        for j in range(1, len(p)+1):\\n            if s[i-1]==p[j-1] or p[j-1]==\\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            elif p[j-1]==\\'*\\':\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1]\\n    \\n    return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef isMatch(self, s: str, p: str) -> bool:\\n    dp = [[False for i in range(len(p)+1)] for j in range(len(s)+1)]\\n    dp[0][0]= True\\n    for i in range(1,len(p)+1):\\n        if p[i-1]==\\'*\\':\\n            dp[0][i] = dp[0][i-1]\\n    for i in range(1, len(s)+1):\\n        for j in range(1, len(p)+1):\\n            if s[i-1]==p[j-1] or p[j-1]==\\'?\\':\\n                dp[i][j] = dp[i-1][j-1]\\n            elif p[j-1]==\\'*\\':\\n                dp[i][j] = dp[i-1][j] | dp[i][j-1]\\n    \\n    return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 443606,
                "title": "easy-java-dp",
                "content": "&nbsp; | \\'\\' | * | a | * |b\\n:-: | :-: | :-: | :-: | :-: | :-:\\n\\'\\' | T | T | F | F | F \\na | F | T | T | T | F\\nd | F | T | F | T | F\\nc | F | T | F | T | F\\ne | F | T | F | T | F\\nb | F | T | F | T | T\\n\\n``` java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if(p.charAt(i) == \\'*\\' && dp[0][i]){\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'){\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if(p.charAt(j) == \\'*\\'){\\n                    dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < p.length(); i++) {\\n            if(p.charAt(i) == \\'*\\' && dp[0][i]){\\n                dp[0][i+1] = true;\\n            }\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            for (int j = 0; j < p.length(); j++) {\\n                if(s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'){\\n                    dp[i+1][j+1] = dp[i][j];\\n                }\\n                if(p.charAt(j) == \\'*\\'){\\n                    dp[i + 1][j + 1] = dp[i][j + 1] || dp[i + 1][j];\\n                }\\n            }\\n        }\\n        return dp[s.length()][p.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428646,
                "title": "javascript-levenshtein-recursion-solution",
                "content": "#### The Idea - Levenshtein Distance Algorithm (Edit Distance)\\n1. Apply lavenshtein distance algorithm. More [here](https://leetcode.com/problems/edit-distance/discuss/428527/JavaScript-Solution).\\n2. Build a matrix where each cell represents whether the string and input are matching, up to the current position\\n3. For every cell, it\\'s trying to be the best matching possible, meaning it\\'s trying to hit a `true`, we have 3 conditions, if the patten is `*`, then we can either look up or left, if the two characters are the same or patten is `?`, then we inherit the result from previous `dp[i-1][j-1]`, other wise, it is a `false`.\\n```\\nvar isMatch = function(s, p) {\\n    let dp = Array(s.length+1).fill(null).map(()=>Array(p.length+1).fill(false));\\n    dp[0][0] = true;\\n\\n    // initialize first column (string)\\n    for (let i=1;i<=s.length;i++) {\\n        dp[i][0] = false;\\n    }\\n\\n    // initialize first row (pattern) \\n    for (let i=1;i<=p.length;i++) {\\n        dp[0][i] = dp[0][i-1] && p[i-1] == \"*\";\\n    }\\n    \\n    for (let i=1;i<=s.length;i++) {\\n        for (let j=1;j<=p.length;j++) {\\n            if (p[j-1]==\\'*\\') {\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]; // look top or left\\n            } else if (s[i-1] == p[j-1] || p[j-1]==\\'?\\') {\\n                dp[i][j] = dp[i-1][j-1]; // inherit from previous result\\n            }\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```\\n\\n#### The Idea - Recursion\\n1. If two strings are equal (`s==p`), or only `*` left in pattern, it\\'s `true`\\n2. If only one of the string is empty, it\\'s `false`\\n3. If two characters are the same (`p[0]==s[0]`) or pattern is `?`, recursivly check the rest\\n4. if see a `*`, we can remove 1 character or we can remove 0 character and move to the next pattern.\\n``` javascript\\nvar isMatchRecursion = function(s, p) {\\n    let dp = {};\\n\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};\\n        if (dp[s][p]!=null) return dp[s][p];\\n\\n        if ( s == p || (p.includes(\\'*\\') && !p.replace(/\\\\*/g, \\'\\'))) {\\n            dp[s][p] = true;\\n        } else if (s.length == 0 || p.length == 0) {\\n            dp[s][p] = false;\\n        } else if (p[0] == \\'?\\' || p[0] == s[0]) {\\n            dp[s][p] = recur(s.slice(1), p.slice(1));\\n        } else if (p[0] == \\'*\\') {\\n            dp[s][p] = recur(s.slice(1), p) || recur(s, p.slice(1));\\n        } else {\\n            dp[s][p] = false;\\n        }\\n\\n        return dp[s][p];\\n    }\\n\\n    return recur(s, p);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isMatch = function(s, p) {\\n    let dp = Array(s.length+1).fill(null).map(()=>Array(p.length+1).fill(false));\\n    dp[0][0] = true;\\n\\n    // initialize first column (string)\\n    for (let i=1;i<=s.length;i++) {\\n        dp[i][0] = false;\\n    }\\n\\n    // initialize first row (pattern) \\n    for (let i=1;i<=p.length;i++) {\\n        dp[0][i] = dp[0][i-1] && p[i-1] == \"*\";\\n    }\\n    \\n    for (let i=1;i<=s.length;i++) {\\n        for (let j=1;j<=p.length;j++) {\\n            if (p[j-1]==\\'*\\') {\\n                dp[i][j] = dp[i-1][j] || dp[i][j-1]; // look top or left\\n            } else if (s[i-1] == p[j-1] || p[j-1]==\\'?\\') {\\n                dp[i][j] = dp[i-1][j-1]; // inherit from previous result\\n            }\\n        }\\n    }\\n    return dp[s.length][p.length]\\n}\\n```\n``` javascript\\nvar isMatchRecursion = function(s, p) {\\n    let dp = {};\\n\\n    var recur = function(s, p) {\\n        if (!dp[s]) dp[s] = {};\\n        if (dp[s][p]!=null) return dp[s][p];\\n\\n        if ( s == p || (p.includes(\\'*\\') && !p.replace(/\\\\*/g, \\'\\'))) {\\n            dp[s][p] = true;\\n        } else if (s.length == 0 || p.length == 0) {\\n            dp[s][p] = false;\\n        } else if (p[0] == \\'?\\' || p[0] == s[0]) {\\n            dp[s][p] = recur(s.slice(1), p.slice(1));\\n        } else if (p[0] == \\'*\\') {\\n            dp[s][p] = recur(s.slice(1), p) || recur(s, p.slice(1));\\n        } else {\\n            dp[s][p] = false;\\n        }\\n\\n        return dp[s][p];\\n    }\\n\\n    return recur(s, p);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 396742,
                "title": "java-recursion-and-dp",
                "content": "Fristly, the recursive solution is pretty easy: \\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        return match(s, 0, p, 0);\\n    }\\n    \\n    boolean match(String s, int i, String p, int j)\\n    {\\n        if (i == s.length() && j == p.length()) return true;\\n        if (j == p.length()) return false;\\n        if (i == s.length())\\n        {\\n            // the remaining in p are *\\n            for (int k = j; k < p.length(); ++k) if (p.charAt(k) != \\'*\\') return false;\\n            return true;\\n        }\\n        \\n        if (p.charAt(j) == \\'*\\')\\n        {\\n            // the * could match 0+ chars in s\\n            return match(s, i + 1, p, j) || match(s, i, p, j + 1);\\n        }\\n        else\\n        {\\n            if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j))\\n            {\\n                return match(s, i + 1, p, j + 1);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```\\n\\nAfter that, rewrite it to DP:\\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {   \\n        // init base cases\\n        int m = s.length(), n = p.length();\\n        boolean[][] f = new boolean[m + 1][n + 1];\\n        f[m][n] = true;\\n        for (int j = n - 1; j >= 0; --j) if (p.charAt(j) == \\'*\\') f[m][j] = true; else break;\\n        \\n        // DP\\n        for (int i = m - 1; i >= 0; --i)\\n        {\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (p.charAt(j) == \\'*\\') f[i][j] = f[i][j + 1] || f[i + 1][j];\\n                else if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j)) f[i][j] = f[i + 1][j + 1];\\n            }\\n        }\\n        \\n        return f[0][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        return match(s, 0, p, 0);\\n    }\\n    \\n    boolean match(String s, int i, String p, int j)\\n    {\\n        if (i == s.length() && j == p.length()) return true;\\n        if (j == p.length()) return false;\\n        if (i == s.length())\\n        {\\n            // the remaining in p are *\\n            for (int k = j; k < p.length(); ++k) if (p.charAt(k) != \\'*\\') return false;\\n            return true;\\n        }\\n        \\n        if (p.charAt(j) == \\'*\\')\\n        {\\n            // the * could match 0+ chars in s\\n            return match(s, i + 1, p, j) || match(s, i, p, j + 1);\\n        }\\n        else\\n        {\\n            if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j))\\n            {\\n                return match(s, i + 1, p, j + 1);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {   \\n        // init base cases\\n        int m = s.length(), n = p.length();\\n        boolean[][] f = new boolean[m + 1][n + 1];\\n        f[m][n] = true;\\n        for (int j = n - 1; j >= 0; --j) if (p.charAt(j) == \\'*\\') f[m][j] = true; else break;\\n        \\n        // DP\\n        for (int i = m - 1; i >= 0; --i)\\n        {\\n            for (int j = n - 1; j >= 0; --j)\\n            {\\n                if (p.charAt(j) == \\'*\\') f[i][j] = f[i][j + 1] || f[i + 1][j];\\n                else if (p.charAt(j) == \\'?\\' || s.charAt(i) == p.charAt(j)) f[i][j] = f[i + 1][j + 1];\\n            }\\n        }\\n        \\n        return f[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348362,
                "title": "c-4ms-98-solution-w-explanation",
                "content": "This is basically an optimized DFS approach, that aims to greedily minimize the amount of characters that each ```*``` matches. The overall run-time is ```O(p*s)```, which is same as the DP approach, but it is much faster.\\n\\n**What makes this approach different from normal DFS**\\n\\nThe main difference is that we are _greedily cutting branches that would normally be explored in DFS_. In a normal DFS approach, we would try out different numbers of characters to skip in ```*```. In this approach, for any string in the form ```s1*s2*s3```, we would look for the _least number of characters to put in the first ```*``` such that we can match ```s1*s2```_. And that is the end for the first ```*```. The position for the first ```*``` is now set in stone. We proceed to look for the least number of characters in the second ```*``` such that we can match ```s1*s2*s3```, etc.\\n\\nIllustration:\\n\\nSay we have ```p = aba*ab```, s = ```abaababaab```\\n\\nWe first match ```aba```. Thus, we have remaining:\\n\\n```p = _*ab```\\n```s = _abaabaab```\\n\\nWe try to match 0 characters to ```*```. We end up with:\\n\\n```p  = _ab```\\n```s = _abaabaab```\\n\\nWe match ```ab```. This doesn\\'t work, since we need to match the whole string. This implies that we need ```*``` to take more characters.\\nEventually, we get ```ab``` to match the last two characters in ```s```, and we complete the match.\\n\\n**Why this optimization works (how do we know we will get a match if a match exists)**\\n\\nAssume we have string ```s = s1*s2*s3```, and it matches some pattern. Let\\'s say the first index of the matching position of ```s3``` is ```j```, and the last index of the _latest_ matching position of ```s2``` is ```i```. Because ```s2``` is before ```s1```, and ```*``` between them implies there are 0 or more characters between them, we can see that ```i < j```. Assume there is an earlier match of ```s2```, ending at index ```k```. It is easy to see here that ```k < i < j```, which directly implies ```k < j```. Thus, by _greedily_ looking for the minimum number of characters to fit into ```*``` to get a match, we will get a solution if there is _any_ other combinations in which we put more characters to into ```*``` that also results in a match.\\n\\nThus, for every string ```s = s1*s2*s3...*sn(*)```, we get ```s1```, minimize the number of characters for ```*s2```, and then ```*s3```, ... until the last ```*```. At this point, we  simply need to check if ```sn``` matches the end of the pattern, or we have ```*``` at the end, and we can get any match and put the rest in ```*```.\\n\\n**Potential Improvement**\\n\\nThis solution is simple, but it may actually be possible to improve the run-time to ```O(s+p)``` by applying KMP to match ```s1*s2*s3...*sn-1```.\\nOnce we are at ```*sn(*)```, we can either return true if there is any match if there is ```*``` at the end, or simply match ```sn``` to the same size segment at end of ```s``` if there is no ```*``` at the end.\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n     bool isMatch(const string &s, const string &p) {\\n        int sizeS = s.size(), sizeP = p.size(), lps = -1, lss = -1, i = 0, j = 0;\\n        while(j < sizeS) {\\n            if(i < sizeP && p[i] == \\'*\\') {\\n                lps = ++i;\\n                lss = j;\\n            }\\n            else if(i < sizeP && p[i] == s[j] || p[i] == \\'?\\') {++i; ++j;}\\n            else {\\n                if(lps == -1) return false;\\n                j = ++lss;\\n                i = lps;\\n            }\\n        }\\n        while(p[i] == \\'*\\') ++i;\\n        return i == sizeP;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```*```\n```O(p*s)```\n```*```\n```s1*s2*s3```\n```*```\n```s1*s2```\n```*```\n```*```\n```*```\n```s1*s2*s3```\n```p = aba*ab```\n```abaababaab```\n```aba```\n```p = _*ab```\n```s = _abaabaab```\n```*```\n```p  = _ab```\n```s = _abaabaab```\n```ab```\n```*```\n```ab```\n```s```\n```s = s1*s2*s3```\n```s3```\n```j```\n```s2```\n```i```\n```s2```\n```s1```\n```*```\n```i < j```\n```s2```\n```k```\n```k < i < j```\n```k < j```\n```*```\n```*```\n```s = s1*s2*s3...*sn(*)```\n```s1```\n```*s2```\n```*s3```\n```*```\n```sn```\n```*```\n```*```\n```O(s+p)```\n```s1*s2*s3...*sn-1```\n```*sn(*)```\n```*```\n```sn```\n```s```\n```*```\n```\\nclass Solution {\\npublic:\\n     bool isMatch(const string &s, const string &p) {\\n        int sizeS = s.size(), sizeP = p.size(), lps = -1, lss = -1, i = 0, j = 0;\\n        while(j < sizeS) {\\n            if(i < sizeP && p[i] == \\'*\\') {\\n                lps = ++i;\\n                lss = j;\\n            }\\n            else if(i < sizeP && p[i] == s[j] || p[i] == \\'?\\') {++i; ++j;}\\n            else {\\n                if(lps == -1) return false;\\n                j = ++lss;\\n                i = lps;\\n            }\\n        }\\n        while(p[i] == \\'*\\') ++i;\\n        return i == sizeP;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 338080,
                "title": "python-simple-dp",
                "content": "[Similar problem: 10. Regular Expression Matching with Explanation](https://leetcode.com/problems/regular-expression-matching/discuss/336345/python-simple-dp/308355)\\n```python\\n    # DP\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[False]*(len(p)+1) for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1,len(p)+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-1]\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(1,len(p)+1):\\n                dp[i][j] = (p[j-1] in [s[i-1],\\'?\\',\\'*\\'] and dp[i-1][j-1]) or (p[j-1] == \\'*\\' and (dp[i][j-1] or dp[i-1][j]))\\n  \\n        return dp[len(s)][len(p)]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\n    # DP\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[False]*(len(p)+1) for i in range(len(s)+1)]\\n        dp[0][0] = True\\n        for j in range(1,len(p)+1):\\n            if p[j-1] == \\'*\\':\\n                dp[0][j] = dp[0][j-1]\\n        \\n        for i in range(1,len(s)+1):\\n            for j in range(1,len(p)+1):\\n                dp[i][j] = (p[j-1] in [s[i-1],\\'?\\',\\'*\\'] and dp[i-1][j-1]) or (p[j-1] == \\'*\\' and (dp[i][j-1] or dp[i-1][j]))\\n  \\n        return dp[len(s)][len(p)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 335162,
                "title": "c-concise-dp",
                "content": "```cpp\\nbool isMatch(string s, string p) {\\n\\tvector<vector<int>> memo(p.size() + 1, vector<int>(s.size() + 1));\\n\\tmemo[0][0] = 1;\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tmemo[i][0] = p[i - 1] == \\'*\\' && memo[i - 1][0];\\n\\n\\tfor(int i = 1; i <= p.size(); i++) {\\n\\t\\tfor(int j = 1; j <= s.size(); j++) {\\n\\t\\t\\tif(p[i - 1] == \\'*\\')\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j] || memo[i][j - 1];\\n\\t\\t\\telse if(p[i - 1] == \\'?\\' || p[i - 1] == s[j - 1])\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo.back().back();\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nbool isMatch(string s, string p) {\\n\\tvector<vector<int>> memo(p.size() + 1, vector<int>(s.size() + 1));\\n\\tmemo[0][0] = 1;\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tmemo[i][0] = p[i - 1] == \\'*\\' && memo[i - 1][0];\\n\\n\\tfor(int i = 1; i <= p.size(); i++) {\\n\\t\\tfor(int j = 1; j <= s.size(); j++) {\\n\\t\\t\\tif(p[i - 1] == \\'*\\')\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j] || memo[i][j - 1];\\n\\t\\t\\telse if(p[i - 1] == \\'?\\' || p[i - 1] == s[j - 1])\\n\\t\\t\\t\\tmemo[i][j] = memo[i - 1][j - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn memo.back().back();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 180538,
                "title": "short-and-easy-to-understand-solution-based-on-nfa-nondeterministic-finite-automaton",
                "content": "Just save a set of current states and from every current state try to advance with one character from the pattern to a next state.\\nThe state is an integer representing the current index in the string s. The length of the string s is a finite state.\\nAfter we process the whole pattern check whether we have arrived to a finite state.\\n\\n```\\n bool isMatch(string s, string p) {\\n    unordered_set<int> states;\\n    // We start from the first characher of s.\\n    states.insert(0);\\n\\n    for (char ch : p) {\\n       unordered_set<int> nextStates;\\n       for (int state : states) {\\n          if (ch == \\'*\\') {\\n             // If we reach a Kleene star we can process from 0 character to\\n             // the whole string so we insert all the states from the current state to\\n             // the end of the string.\\n             for (int i = state; i <= s.size(); ++i) {\\n                nextStates.insert(i);\\n             }\\n          }\\n          \\n          // We cannot go anywhere from a finite state if the current char from pattern is not\\n          // a star.\\n          if (state >= s.size()) continue;\\n          \\n          // We advance 1 move if the char matches of if it is a question mark.\\n          if (s[state] == ch || ch == \\'?\\') {\\n             nextStates.insert(state + 1);\\n          }\\n       }\\n       // Proceed from the new set of states.\\n       states = nextStates;\\n    }\\n    for (int state : states)\\n       if (state == s.size()) return true;\\n\\n    // We haven\\'t reached an end state.\\n    return false;\\n }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isMatch(string s, string p) {\\n    unordered_set<int> states;\\n    // We start from the first characher of s.\\n    states.insert(0);\\n\\n    for (char ch : p) {\\n       unordered_set<int> nextStates;\\n       for (int state : states) {\\n          if (ch == \\'*\\') {\\n             // If we reach a Kleene star we can process from 0 character to\\n             // the whole string so we insert all the states from the current state to\\n             // the end of the string.\\n             for (int i = state; i <= s.size(); ++i) {\\n                nextStates.insert(i);\\n             }\\n          }\\n          \\n          // We cannot go anywhere from a finite state if the current char from pattern is not\\n          // a star.\\n          if (state >= s.size()) continue;\\n          \\n          // We advance 1 move if the char matches of if it is a question mark.\\n          if (s[state] == ch || ch == \\'?\\') {\\n             nextStates.insert(state + 1);\\n          }\\n       }\\n       // Proceed from the new set of states.\\n       states = nextStates;\\n    }\\n    for (int state : states)\\n       if (state == s.size()) return true;\\n\\n    // We haven\\'t reached an end state.\\n    return false;\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126185,
                "title": "java-dp-solution-with-o-n-space-with-detailed-explaination",
                "content": "This is a DP O(n) space solution optimized from DP O(mn) space solution\\n\\nThe optimization is based on Zero-One backpack algorithm and Complete backpack algorithm.\\nSo after the optimization, this problem looks more like a mixed backpack problem.\\n\\n```\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];   // dp[i] maps to dp[i][j], where i is the length of s, j is the length of j\\n        char[] sStr = s.toCharArray();\\n        char[] pStr = p.toCharArray();\\n        dp[0] = true;   // before we started any iteration, dp[0] is equal to dp[0][0], meaning both s and p are EMPTY\\n        for (int j=1; j<=pStr.length; j++) {\\n            char pChr = pStr[j-1];\\n            if (pChr == \\'*\\') {\\n                // same optimization as complete backpack problem\\n                // we scan from 1 to s.length, so that dp[i] = dp[i] || dp[i-1]\\n                // just thinking like every time we iterating dp[i], the dp[i][j] we referenced is actually previous iteration\\'s result. so dp[i-1] is actually dp[i-1][j] from previous step of current i-loop for string s, dp[i] is actually dp[i][j-1] from previous j-loop for string p\\n                // it\\'s relatively easy to understand that before the dp[i]\\'s value is updated, dp[i] refers to dp[i][j-1] \\n                // the hard to understand part may be why dp[i-1] equals to dp[i-1][j]. Notice dp[i-1]\\'s value was updated in previous step\\'s update (we update dp[i-1] in dp[i-2]\\'s step), so dp[i-1] is equal to dp[i-1][j]\\n                for (int i=1; i<=sStr.length; i++) {\\n                    dp[i] = dp[i] || dp[i-1];\\n                }\\n            } else {\\n                // same optimization as zero-one backpack\\n                // dp[i-1] means dp[i-1][j-1]\\n                for (int i=sStr.length; i>=1; i--) {\\n                    if (sStr[i-1] == pChr || pChr == \\'?\\') {\\n                        dp[i] = dp[i-1];\\n                    } else {\\n                        dp[i] = false;\\n                    }\\n                }\\n                // now, after we see the first non-\\'*\\' character, as dp[0] means dp[i][0] where i>=1, dp[i][0] it\\'s definite false (matching empty p with non-empty s)\\n                // we want to set that value to false\\n                dp[0] = false;\\n            }\\n        }\\n        return dp[sStr.length];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];   // dp[i] maps to dp[i][j], where i is the length of s, j is the length of j\\n        char[] sStr = s.toCharArray();\\n        char[] pStr = p.toCharArray();\\n        dp[0] = true;   // before we started any iteration, dp[0] is equal to dp[0][0], meaning both s and p are EMPTY\\n        for (int j=1; j<=pStr.length; j++) {\\n            char pChr = pStr[j-1];\\n            if (pChr == \\'*\\') {\\n                // same optimization as complete backpack problem\\n                // we scan from 1 to s.length, so that dp[i] = dp[i] || dp[i-1]\\n                // just thinking like every time we iterating dp[i], the dp[i][j] we referenced is actually previous iteration\\'s result. so dp[i-1] is actually dp[i-1][j] from previous step of current i-loop for string s, dp[i] is actually dp[i][j-1] from previous j-loop for string p\\n                // it\\'s relatively easy to understand that before the dp[i]\\'s value is updated, dp[i] refers to dp[i][j-1] \\n                // the hard to understand part may be why dp[i-1] equals to dp[i-1][j]. Notice dp[i-1]\\'s value was updated in previous step\\'s update (we update dp[i-1] in dp[i-2]\\'s step), so dp[i-1] is equal to dp[i-1][j]\\n                for (int i=1; i<=sStr.length; i++) {\\n                    dp[i] = dp[i] || dp[i-1];\\n                }\\n            } else {\\n                // same optimization as zero-one backpack\\n                // dp[i-1] means dp[i-1][j-1]\\n                for (int i=sStr.length; i>=1; i--) {\\n                    if (sStr[i-1] == pChr || pChr == \\'?\\') {\\n                        dp[i] = dp[i-1];\\n                    } else {\\n                        dp[i] = false;\\n                    }\\n                }\\n                // now, after we see the first non-\\'*\\' character, as dp[0] means dp[i][0] where i>=1, dp[i][0] it\\'s definite false (matching empty p with non-empty s)\\n                // we want to set that value to false\\n                dp[0] = false;\\n            }\\n        }\\n        return dp[sStr.length];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 17880,
                "title": "c-code-9ms-beats-100-persons",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        int pid=0, sid=0;\\n        int pidp=-1, sidp=-1;\\n        while(sid<n){\\n            if(p[pid]==s[sid] || p[pid]=='?'){\\n                pid++; sid++;\\n            }else if(p[pid]=='*'){\\n                pidp=pid++; sidp=sid;\\n            }else{\\n                if(pidp>-1){\\n                    pid=pidp+1; sid=++sidp;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        while(p[pid]=='*') pid++;\\n        return pid==m;\\n    }\\n};\\n````",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        int pid=0, sid=0;\\n        int pidp=-1, sidp=-1;\\n        while(sid<n){\\n            if(p[pid]==s[sid] || p[pid]=='?'){\\n                pid++; sid++;\\n            }else if(p[pid]=='*'){\\n                pidp=pid++; sidp=sid;\\n            }else{\\n                if(pidp>-1){\\n                    pid=pidp+1; sid=++sidp;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        while(p[pid]=='*') pid++;\\n        return pid==m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 17888,
                "title": "simple-greedy-python-with-regexes",
                "content": "For example if the pattern is `'ab*cd*e?*gh'`:\\n1. Turn that into `['ab', 'cd', 'e.', 'gh']` (turn `?` into `.` and split on `*`).\\n2. Check that the start of the string matches `'ab'` (and chop it off the string).\\n3. Check that the end of the string matches `'gh'` (and chop it off the string).\\n4. Check that `'cd'` and `'e.'` are matched somewhere in the string in that order. Just be greedy, always use the first occurrence.\\n\\n\\n    def isMatch(self, s, p):\\n        parts = p.replace('?', '.').split('*')\\n        if len(parts) == 1:\\n            return bool(re.match(parts[0] + '$', s))\\n        if not re.match(parts[0], s):\\n            return False\\n        s = s[len(parts.pop(0)):]\\n        if not re.search(parts[-1] + '$', s):\\n            return False\\n        s = s[:len(s) - len(parts.pop())]\\n        for part in parts:\\n            m = re.search(part, s)\\n            if not m:\\n                return False\\n            s = s[m.end():]\\n        return True",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "For example if the pattern is `'ab*cd*e?*gh'`:\\n1. Turn that into `['ab', 'cd', 'e.', 'gh']` (turn `?` into `.` and split on `*`).\\n2. Check that the start of the string matches `'ab'` (and chop it off the string).\\n3. Check that the end of the string matches `'gh'` (and chop it off the string).\\n4. Check that `'cd'` and `'e.'` are matched somewhere in the string in that order. Just be greedy, always use the first occurrence.\\n\\n\\n    def isMatch(self, s, p):\\n        parts = p.replace('?', '.').split('*')\\n        if len(parts) == 1:\\n            return bool(re.match(parts[0] + '$', s))\\n        if not re.match(parts[0], s):\\n            return False\\n        s = s[len(parts.pop(0)):]\\n        if not re.search(parts[-1] + '$', s):\\n            return False\\n        s = s[:len(s) - len(parts.pop())]\\n        for part in parts:\\n            m = re.search(part, s)\\n            if not m:\\n                return False\\n            s = s[m.end():]\\n        return True",
                "codeTag": "Python3"
            },
            {
                "id": 17975,
                "title": "32-ms-c-ac-code-after-34-submission-with-main-idea-explained-in-commet-o-1-in-space",
                "content": "    class Solution {\\n    public:\\n    \\tbool isMatch(const char* s, const char* p){\\n    // main idea:\\n    // before '*' appears, everything is trivial\\n    // just move forward the pointer s and p\\n    // after '*' shows up, \\n    // I separate the pattern p into some subpatterns, spaced by '*'\\n    // for those subpatterns between '*', to check if s fit the\\n    // first subpattern is equvalent to check if\\n    // that subpattern exist in s\\n    // because '*' can be any char including empty char\\n    // I then find the first substring of s\\n    // that satisfies the first subpattern, update s and go on\\n    // searching for the following subpatterns until the\\n    // last subpattern (here I used KMP algorithm which is\\n    // not quite necessary, I just wanted to have a practice to\\n    // impletment that algorithm)\\n    // At that time I know that the searched substring s\\n    // fits the searched subpattern of p and if I move forward\\n    // pointer s, the fitting still holds (because of *)\\n    // what I want is to make s and p go to '\\\\0' together at the\\n    // same time. For that purpose, I need to keep moving forward\\n    // s and check if s exactly fit the last subpattern of p\\n    // and after that, the problem is solved\\n    // I'm not very sure about the time complexity\\n    // but the KMP algorithm take nearly O(N + M) where N and M\\n    // are the length of s and p correspondingly\\n    // and the last step searching should be O(N + M) so I guess\\n    // the time complexity should be O(N + M)\\n    // the space complexity is O(1)\\n    \\t\\tconst char* lastS = nullptr;\\n    \\t\\tconst char* lastP = nullptr;\\n    \\t\\tbool star = false;\\n    \\t\\twhile(*s != '\\\\0'){\\n    \\t\\t\\tif(!star){\\n    \\t\\t\\t\\tif(*p == '?' || *p == *s){\\n    \\t\\t\\t\\t\\tp++;\\n    \\t\\t\\t\\t\\ts++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse if(*p == '*'){\\n    \\t\\t\\t\\t\\tstar = true;\\n    \\t\\t\\t\\t\\twhile(*p == '*') p++;\\n    \\t\\t\\t\\t\\tif(*p == '\\\\0') return true;\\n    \\t\\t\\t\\t\\tlastS = s;\\n    \\t\\t\\t\\t\\tlastP = p;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse return false;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tif(*p == '*'){\\n    \\t\\t\\t\\t\\twhile(*p == '*') p++;\\n    \\t\\t\\t\\t\\tif(*p == '\\\\0') return true;\\n    \\t\\t\\t\\t\\tlastS = s;\\n    \\t\\t\\t\\t\\tlastP = p;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse if(*p == '?'){\\n    \\t\\t\\t\\t\\ts++;\\n    \\t\\t\\t\\t\\tp++;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse if(*p != '\\\\0'){\\n    \\t\\t\\t\\t\\tint n = 0;\\n    \\t\\t\\t\\t\\tconst char* itr = p;\\n    \\t\\t\\t\\t\\twhile(*itr != '\\\\0' && *itr != '*' && *itr != '?'){\\n    \\t\\t\\t\\t\\t\\titr++;\\n    \\t\\t\\t\\t\\t\\tn++;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\tif(!help(s, p, n)) return false;\\n    \\t\\t\\t\\t\\ts += n;\\n    \\t\\t\\t\\t\\tp += n;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\tif(*lastP != '\\\\0'){\\n    \\t\\t\\t\\t\\t\\tlastS++;\\n    \\t\\t\\t\\t\\t\\ts = lastS;\\n    \\t\\t\\t\\t\\t\\tp = lastP;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\telse return false;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\twhile(*p == '*') p++;\\n    \\t\\treturn *p == '\\\\0';\\n    \\t}\\n    \\tbool help(const char*& s, const char*& p, int n){\\n    \\t// KMP algorithm\\n    \\t\\tvector<int> table(n, 0);\\n    \\t\\tbuildPartialSeparationTable(p, n, table);\\n    \\t\\tint idx = 0;// number of chars that match\\n    \\t\\twhile(1){\\n    \\t\\t\\tif(idx == n) return true;\\n    \\t\\t\\tif(*(s + idx) == '\\\\0') return false;\\n    \\t\\t\\tif(*(s + idx) == *(p + idx)){\\n    \\t\\t\\t\\tidx++;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tif(idx == 0) s++;\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\ts += idx - table[idx - 1];\\n    \\t\\t\\t\\t\\tidx = 0;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t}\\n    \\tvoid buildPartialSeparationTable(const char* p, int n, vector<int>& table){\\n    \\t// a help function for KMP algorithm\\n    \\t\\ttable.resize(n);\\n    \\t\\tint longgestPre = 0;\\n    \\t\\tfor(int i = 1; i < n; i++){\\n    \\t\\t\\twhile(longgestPre > 0 && p[longgestPre] != p[i]){\\n    \\t\\t\\t\\tlonggestPre = table[longgestPre - 1];\\n    \\t\\t\\t}\\n    \\t\\t\\tif(p[longgestPre] == p[i]){\\n    \\t\\t\\t\\ttable[i] = table[i - 1] + 1;\\n    \\t\\t\\t\\tlonggestPre = table[i];\\n    \\t\\t\\t}\\n    \\t\\t\\telse table[i] = 0;\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isMatch(const char* s, const char* p){\\n    // main idea:\\n    // before '*' appears, everything is trivial\\n    // just move forward the pointer s and p\\n    // after '*' shows up, \\n    // I separate the pattern p into some subpatterns, spaced by '*'\\n    // for those subpatterns between '*', to check if s fit the\\n    // first subpattern is equvalent to check if\\n    // that subpattern exist in s\\n    // because '*' can be any char including empty char\\n    // I then find the first substring of s\\n    // that satisfies the first subpattern, update s and go on\\n    // searching for the following subpatterns until the\\n    // last subpattern (here I used KMP algorithm which is\\n    // not quite necessary, I just wanted to have a practice to\\n    // impletment that algorithm)\\n    // At that time I know that the searched substring s\\n    // fits the searched subpattern of p and if I move forward\\n    // pointer s, the fitting still holds (because of *)\\n    // what I want is to make s and p go to '\\\\0' together at the\\n    // same time. For that purpose, I need to keep moving forward\\n    // s and check if s exactly fit the last subpattern of p\\n    // and after that, the problem is solved\\n    // I'm not very sure about the time complexity\\n    // but the KMP algorithm take nearly O(N + M) where N and M\\n    // are the length of s and p correspondingly\\n    // and the last step searching should be O(N + M) so I guess\\n    // the time complexity should be O(N + M)\\n    // the space complexity is O(1)\\n    \\t\\tconst char* lastS = nullptr;\\n    \\t\\tconst char* lastP = nullptr;\\n    \\t\\tbool star = false;\\n    \\t\\twhile(*s != '\\\\0'){\\n    \\t\\t\\tif(!star){\\n    \\t\\t\\t\\tif(*p == '?' || *p == *s){\\n    \\t\\t\\t\\t\\tp++;\\n    \\t\\t\\t\\t\\ts++;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3731092,
                "title": "simple-c-memoization",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s,string &p,int i,int j,vector<vector<int>> &dp){\\n\\n        if(i<0 && j<0){\\n            return 1;\\n        }\\n\\n        if(i>=0  && j<0) return 0;\\n     \\n        \\n        if(i<0 && j>=0) {\\n            while(j>=0) {\\n                if(p[j]!=\\'*\\') return 0;\\n                j--;\\n            }\\n            return 1;\\n        };\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(p[j]==s[i] || p[j]==\\'?\\'){\\n           return dp[i][j]=solve(s,p,i-1,j-1,dp);\\n\\n        }\\n\\n\\n\\n        if(p[j]==\\'*\\'){\\n            int t=solve(s,p,i-1,j,dp);\\n            \\n            int neglect=solve(s,p,i,j-1,dp);\\n            return dp[i][j]=t||neglect;\\n        }\\n        return dp[i][j]=0;\\n    }\\n    bool isMatch(string &s, string &p) {\\n     \\n        int n=s.size();\\n        int m=p.size();\\n       \\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n       \\n        return solve(s,p,n-1,m-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s,string &p,int i,int j,vector<vector<int>> &dp){\\n\\n        if(i<0 && j<0){\\n            return 1;\\n        }\\n\\n        if(i>=0  && j<0) return 0;\\n     \\n        \\n        if(i<0 && j>=0) {\\n            while(j>=0) {\\n                if(p[j]!=\\'*\\') return 0;\\n                j--;\\n            }\\n            return 1;\\n        };\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(p[j]==s[i] || p[j]==\\'?\\'){\\n           return dp[i][j]=solve(s,p,i-1,j-1,dp);\\n\\n        }\\n\\n\\n\\n        if(p[j]==\\'*\\'){\\n            int t=solve(s,p,i-1,j,dp);\\n            \\n            int neglect=solve(s,p,i,j-1,dp);\\n            return dp[i][j]=t||neglect;\\n        }\\n        return dp[i][j]=0;\\n    }\\n    bool isMatch(string &s, string &p) {\\n     \\n        int n=s.size();\\n        int m=p.size();\\n       \\n\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n       \\n        return solve(s,p,n-1,m-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490512,
                "title": "java-solution-for-wildcard-matching-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to use two pointers i and j to traverse the string s and the pattern p, respectively. We also use two variables starIndex and iIndex to keep track of the index of the last * character in p and the index of the last character in s that matched the * character, respectively. If the current character in p matches the current character in s, we move both pointers i and j to the next index. If the current character in p is a ? or a non-* character that does not match the current character in s, we return false. If the current character in p is a *, we update the starIndex and iIndex variables to the current indices of j and i, respectively, and move j to the next index. If we encounter a mismatch between p and s and there is a * character in p, we reset j to starIndex+1, i to iIndex+1, and iIndex to the next index of i. We repeat this process until we reach the end of s. Finally, we check if there are any remaining * characters in p. If so, we return false. Otherwise, we return true.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize two pointers i and j to 0 to traverse the string s and the pattern p, respectively.\\n- Initialize two variables starIndex and iIndex to -1 to keep track of the index of the last * character in p and the index of the last character in s that matched the * character, respectively.\\n- Traverse the string s from left to right for each index i from 0 to the length of s minus 1.\\n- If the current character in p matches the current character in s, move both pointers i and j to the next index.\\n- If the current character in p is a ? or a non-* character that does not match the current character in s, return false.\\n- If the current character in p is a *, update the starIndex and iIndex variables to the current indices of j and i, respectively, and move j to the next index.\\n- If we encounter a mismatch between p and s and there is a * character in p, reset j to starIndex+1, i to iIndex+1, and iIndex to the next index of i.\\n- Repeat steps 4-7 until the end of s is reached.\\n- Traverse the pattern p from the current index j to the end of the pattern.\\n- If the current character in p is a *, move j to the next index.\\n- If there are any remaining characters in p, return false. Otherwise, return true.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the input string s. The algorithm iterates through the string s once and performs constant-time operations for each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as the algorithm uses only constant extra space to store the variables i, j, starIndex, and iIndex.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        int i = 0;\\n        int j = 0;\\n        int starIndex = -1;\\n        int iIndex = -1;\\n        while (i < s.length()) \\n        {\\n            if (j < p.length() && (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)))\\n            {\\n                ++i;\\n                ++j;\\n            }\\n            else if (j < p.length() && p.charAt(j) == \\'*\\') \\n            {\\n                starIndex = j;\\n                iIndex = i;\\n                j++;\\n            }\\n            else if (starIndex != -1) \\n            {\\n                j = starIndex + 1;\\n                i = iIndex+1;\\n                iIndex++;\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') \\n        {\\n            ++j;\\n        }\\n        return j == p.length();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public boolean isMatch(String s, String p) \\n    {\\n        int i = 0;\\n        int j = 0;\\n        int starIndex = -1;\\n        int iIndex = -1;\\n        while (i < s.length()) \\n        {\\n            if (j < p.length() && (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)))\\n            {\\n                ++i;\\n                ++j;\\n            }\\n            else if (j < p.length() && p.charAt(j) == \\'*\\') \\n            {\\n                starIndex = j;\\n                iIndex = i;\\n                j++;\\n            }\\n            else if (starIndex != -1) \\n            {\\n                j = starIndex + 1;\\n                i = iIndex+1;\\n                iIndex++;\\n            }\\n            else \\n            {\\n                return false;\\n            }\\n        }\\n        while (j < p.length() && p.charAt(j) == \\'*\\') \\n        {\\n            ++j;\\n        }\\n        return j == p.length();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217667,
                "title": "wildcard-matching-c-solution",
                "content": "C# Solution:\\r\\n\\r\\n# Code\\r\\n```C#\\r\\npublic class Solution\\r\\n{\\r\\n    public bool IsMatch(string s, string p)\\r\\n    {\\r\\n        var i = 0;\\r\\n        var j = 0;\\r\\n        var star = -1;\\r\\n        var m = -1;\\r\\n\\r\\n        while (i < s.Length)\\r\\n        {\\r\\n            if (j < p.Length && (p[j] == \\'?\\' || p[j] == s[i]))\\r\\n            {\\r\\n                i++;\\r\\n                j++;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (j < p.Length && p[j] == \\'*\\')\\r\\n            {\\r\\n                star = j++;\\r\\n                m = i;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (star >= 0)\\r\\n            {\\r\\n                j = star + 1;\\r\\n                i = ++m;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        while (j < p.Length && p[j] == \\'*\\')\\r\\n        {\\r\\n            j++;\\r\\n        }\\r\\n\\r\\n        return j == p.Length;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```C#\\r\\npublic class Solution\\r\\n{\\r\\n    public bool IsMatch(string s, string p)\\r\\n    {\\r\\n        var i = 0;\\r\\n        var j = 0;\\r\\n        var star = -1;\\r\\n        var m = -1;\\r\\n\\r\\n        while (i < s.Length)\\r\\n        {\\r\\n            if (j < p.Length && (p[j] == \\'?\\' || p[j] == s[i]))\\r\\n            {\\r\\n                i++;\\r\\n                j++;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (j < p.Length && p[j] == \\'*\\')\\r\\n            {\\r\\n                star = j++;\\r\\n                m = i;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            if (star >= 0)\\r\\n            {\\r\\n                j = star + 1;\\r\\n                i = ++m;\\r\\n\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        while (j < p.Length && p[j] == \\'*\\')\\r\\n        {\\r\\n            j++;\\r\\n        }\\r\\n\\r\\n        return j == p.Length;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160732,
                "title": "wildcard-matching-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a 2D boolean array dp with m + 1 rows and n + 1 columns, where m is the length of string s and n is the length of string p.\\n2. Set dp[0][0] to True, which means an empty string matches an empty pattern.\\n3. For each column in the first row, if the corresponding character in p is \\'*\\', set the value in the same column of the first row to the value in the previous column. This is because \\'*\\' matches any sequence of characters.\\n4. For each row from 1 to m, and each column from 1 to n:\\nIf the corresponding character in p is \\'*\\', set the value in dp[i][j] to the OR of the values in dp[i][j - 1] and dp[i - 1][j]. This means \\'*\\' matches any sequence of characters, including the empty sequence.\\nIf the corresponding character in p is \\'?\\' or the same as the corresponding character in s, set the value in dp[i][j] to the value in dp[i - 1][j - 1]. This means \\'?\\' matches any single character, and a character in s matches the same character in p.\\n5. Return dp[m][n], which is the result of matching the entire input string s with the entire pattern p.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n                elif p[j - 1] == \\'?\\' or s[i - 1] == p[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n        return dp[m][n]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\\n        dp[0][0] = True\\n        for j in range(1, n + 1):\\n            if p[j - 1] == \\'*\\':\\n                dp[0][j] = dp[0][j - 1]\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n                elif p[j - 1] == \\'?\\' or s[i - 1] == p[j - 1]:\\n                    dp[i][j] = dp[i - 1][j - 1]\\n        return dp[m][n]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006399,
                "title": "most-simple-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        vector<vector<bool>> dp(s.size() + 1, vector(p.size() + 1, false));\\n        dp[0][0] = true;\\n        for (int j = 0; j < p.size() && p[j] == \\'*\\'; ++j) {\\n            dp[0][j + 1] = true;\\n        }\\n        \\n        for (int i = 1; i <= s.size(); ++i) {\\n            for (int j = 1; j <= p.size(); ++j) {\\n                if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n                } else {\\n                    dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1];\\n                }\\n            }\\n        }\\n\\n        return dp[s.size()][p.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004512,
                "title": "c-striver-solution-recursion-memoisation",
                "content": "\\n# Approach\\nThis problem can be thought of as a recursion problem which can later be converted to dynamic programming using memoisation because it involves trying out all ways.\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n*m)+O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int ind1,int ind2,string &s,string &p,vector<vector<int>> &dp){\\n        if(ind1<0 && ind2<0) return true;\\n        if(ind2<0) return false;\\n        if(ind1<0){\\n            for(int i=0;i<=ind2;i++){\\n                if(p[i]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        if(s[ind1]==p[ind2] || p[ind2]==\\'?\\') return dp[ind1][ind2]=solve(ind1-1,ind2-1,s,p,dp);\\n        else if(p[ind2]==\\'*\\'){\\n            return dp[ind1][ind2]=solve(ind1-1,ind2,s,p,dp) || solve(ind1,ind2-1,s,p,dp);\\n        }\\n        return dp[ind1][ind2]=false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,s,p,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int ind1,int ind2,string &s,string &p,vector<vector<int>> &dp){\\n        if(ind1<0 && ind2<0) return true;\\n        if(ind2<0) return false;\\n        if(ind1<0){\\n            for(int i=0;i<=ind2;i++){\\n                if(p[i]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        if(dp[ind1][ind2]!=-1) return dp[ind1][ind2];\\n        if(s[ind1]==p[ind2] || p[ind2]==\\'?\\') return dp[ind1][ind2]=solve(ind1-1,ind2-1,s,p,dp);\\n        else if(p[ind2]==\\'*\\'){\\n            return dp[ind1][ind2]=solve(ind1-1,ind2,s,p,dp) || solve(ind1,ind2-1,s,p,dp);\\n        }\\n        return dp[ind1][ind2]=false;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<int>> dp(n,vector<int>(m,-1));\\n        return solve(n-1,m-1,s,p,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769545,
                "title": "python-dp-o-m-n",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m,n=len(s),len(p)\\n        dp=[[0 for i in range(m+1)] for j in range(n+1)]\\n        dp[0][0]=1\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s[j-1]==p[i-1] or p[i-1]==\\'?\\':\\n                    dp[i][j]=dp[i-1][j-1]\\n                elif p[i-1]==\\'*\\':\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return dp[n][m]\\n```\\n\\n**Please Upvote If You Like The Solution**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m,n=len(s),len(p)\\n        dp=[[0 for i in range(m+1)] for j in range(n+1)]\\n        dp[0][0]=1\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1,n+1):\\n            for j in range(1,m+1):\\n                if s[j-1]==p[i-1] or p[i-1]==\\'?\\':\\n                    dp[i][j]=dp[i-1][j-1]\\n                elif p[i-1]==\\'*\\':\\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\\n        return dp[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489651,
                "title": "c-recursion-memoization-tabulation-spaceoptimization",
                "content": "# Method - 1 [Recursion] \\n![image](https://assets.leetcode.com/users/images/51e10645-e2f4-4b78-b2bd-7880beb409cb_1661582208.273855.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool f(int i,int j,string& p,string& s){\\n\\t\\t\\tif(i<0 && j<0) return true;\\n\\t\\t\\tif(i<0 && j>=0) return false;\\n\\t\\t\\tif(j<0 && i>=0){\\n\\t\\t\\t\\tfor(int k=i;k>=0;k--){\\n\\t\\t\\t\\t\\tif(p[k]!=\\'*\\') return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t//      Match \\n\\t\\t\\tif(p[i]==s[j] || p[i]==\\'?\\') return f(i-1,j-1,p,s);\\n\\t\\t\\tif(p[i]==\\'*\\') return f(i-1,j,p,s) || f(i,j-1,p,s);\\n\\t//      NotMatch\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\treturn f(n-1,m-1,p,s);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/49215323-5577-4559-90a2-e8d8ec335fcc_1661582342.8689756.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool f(int i,int j,string& p,string& s,vector<vector<int>>& dp){\\n\\t\\t\\tif(i<0 && j<0) return true;\\n\\t\\t\\tif(i<0 && j>=0) return false;\\n\\t\\t\\tif(j<0 && i>=0){\\n\\t\\t\\t\\tfor(int k=i;k>=0;k--){\\n\\t\\t\\t\\t\\tif(p[k]!=\\'*\\') return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif(dp[i][j]!=-1) return dp[i][j];\\n\\t//      Match \\n\\t\\t\\tif(p[i]==s[j] || p[i]==\\'?\\') return dp[i][j]=f(i-1,j-1,p,s,dp);\\n\\t\\t\\tif(p[i]==\\'*\\') return dp[i][j]=f(i-1,j,p,s,dp) || f(i,j-1,p,s,dp);\\n\\t//      NotMatch\\n\\t\\t\\treturn dp[i][j]=false;\\n\\t\\t}\\n\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(m,-1));\\n\\t\\t\\treturn f(n-1,m-1,p,s,dp);\\n\\t\\t}\\n\\t};\\n\\n# Method - 3 [Tabulation]\\n\\n![image](https://assets.leetcode.com/users/images/de78b6e7-c220-4b83-8fb3-2b9031909db2_1661593846.1921206.png)\\n\\n**T->O(mn) && S->O(mn)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<vector<bool>> dp(n+1,vector<bool>(m+1,false));\\n\\t\\t\\tdp[0][0]=true;\\n\\t\\t\\tfor(int j=1;j<=m;j++) dp[0][j]=false;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\tfor(int k=1;k<=i;k++){\\n\\t\\t\\t\\t\\tif(p[k-1]!=\\'*\\'){\\n\\t\\t\\t\\t\\t\\tflag=false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdp[i][0]=flag;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(p[i-1]==s[j-1] || p[i-1]==\\'?\\') dp[i][j]=dp[i-1][j-1];\\n\\t\\t\\t\\t\\telse if(p[i-1]==\\'*\\') dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n\\t\\t\\t\\t\\telse dp[i][j]=false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[n][m];\\n\\t\\t}\\n\\t};\\n\\t\\n# Method - 4 [SpaceOptimization]\\n\\n![image](https://assets.leetcode.com/users/images/d723d4e6-b015-489c-8bed-ef95f203be68_1661594465.8915417.png)\\n\\n**T->O(nm) && S->O(m)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isMatch(string s, string p) {\\n\\t\\t\\tint n=p.size();\\n\\t\\t\\tint m=s.size();\\n\\t\\t\\tvector<bool> prev(m+1,false),curr(m+1,false);\\n\\t\\t\\tprev[0]=true;\\n\\t\\t\\tfor(int i=1;i<=n;i++){\\n\\t\\t\\t\\tbool flag=true;\\n\\t\\t\\t\\tfor(int k=1;k<=i;k++){\\n\\t\\t\\t\\t\\tif(p[k-1]!=\\'*\\'){\\n\\t\\t\\t\\t\\t\\tflag=false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr[0]=flag;\\n\\t\\t\\t\\tfor(int j=1;j<=m;j++){\\n\\t\\t\\t\\t\\tif(p[i-1]==s[j-1] || p[i-1]==\\'?\\') curr[j]=prev[j-1];\\n\\t\\t\\t\\t\\telse if(p[i-1]==\\'*\\') curr[j]=prev[j] || curr[j-1];\\n\\t\\t\\t\\t\\telse curr[j]=false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev=curr;\\n\\t\\t\\t}\\n\\t\\t\\treturn prev[m];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool f(int i,int j,string& p,string& s){\\n\\t\\t\\tif(i<0 && j<0) return true;\\n\\t\\t\\tif(i<0 && j>=0) return false;\\n\\t\\t\\tif(j<0 && i>=0){\\n\\t\\t\\t\\tfor(int k=i;k>=0;k--){\\n\\t\\t\\t\\t\\tif(p[k]!=\\'*\\') return false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2443955,
                "title": "simple-java-solution-using-dp",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) \\n    {\\n        if(s==null || p==null)\\n            return s.equals(p);\\n        \\n        int m= s.length();\\n        int n= p.length();\\n        \\n        boolean[][] dp = new boolean[m+1][n+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for(int i=0; i< n ;i++)\\n        {\\n            if(p.charAt(i) == \\'*\\')\\n                dp[0][i+1] = dp[0][i];\\n        }\\n        \\n        for(int i=1; i<m+1; i++)\\n        {\\n            for(int j=1; j<n+1; j++)\\n            {\\n                if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                \\n                else if(p.charAt(j-1) == \\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) \\n    {\\n        if(s==null || p==null)\\n            return s.equals(p);\\n        \\n        int m= s.length();\\n        int n= p.length();\\n        \\n        boolean[][] dp = new boolean[m+1][n+1];\\n        \\n        dp[0][0] = true;\\n        \\n        for(int i=0; i< n ;i++)\\n        {\\n            if(p.charAt(i) == \\'*\\')\\n                dp[0][i+1] = dp[0][i];\\n        }\\n        \\n        for(int i=1; i<m+1; i++)\\n        {\\n            for(int j=1; j<n+1; j++)\\n            {\\n                if(s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                \\n                else if(p.charAt(j-1) == \\'*\\')\\n                    dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n            }\\n        }\\n        \\n        return dp[m][n];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950430,
                "title": "php-100-100-regex-solution",
                "content": "Used Regex, found that PHP/PCRE was faster than Python matching.\\nReplaced \"?\" with \".\", and \"*\" with \".\\\\*\".\\n```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $p\\n     * @return Boolean\\n     */\\n    function isMatch($s, $p) {\\n        return preg_match(\"/^\" . preg_replace(\"/\\\\*+/\", \".*\" ,str_replace(\"?\", \".\", $p)) . \"$/U\", $s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param String $s\\n     * @param String $p\\n     * @return Boolean\\n     */\\n    function isMatch($s, $p) {\\n        return preg_match(\"/^\" . preg_replace(\"/\\\\*+/\", \".*\" ,str_replace(\"?\", \".\", $p)) . \"$/U\", $s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731886,
                "title": "c-dp-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int m = s.length(),n=p.length();\\n        vector<vector<bool>> vec(m+1,vector<bool>(n+1,false));\\n        vec[0][0] = true;\\n        //For first row\\n        //For matching sequence like **** etc.\\n        for(int i=1;i<=n;i++)\\n        {\\n            vec[0][i] = p[i-1] == \\'*\\' && vec[0][i-1];\\n        }\\n        \\n        for(int i=1;i<=m;i++)\\n        {\\n            for(int j=1;j<=n;j++)\\n            {\\n                if(p[j-1] != \\'*\\')\\n                {\\n                    vec[i][j] = (s[i-1] == p[j-1] || p[j-1] == \\'?\\') && vec[i-1][j-1];\\n                }\\n                else\\n                {\\n                    vec[i][j] = vec[i][j-1] || vec[i-1][j];\\n                }\\n            }\\n        }\\n        return vec[m][n];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isMatch(string s, string p) \\n    {\\n        int m = s.length(),n=p.length();\\n        vector<vector<bool>> vec(m+1,vector<bool>(n+1,false));\\n        vec[0][0] = true;\\n        //For first row\\n        //For matching sequence like **** etc.\\n        for(int i=1;i<=n;i++)\\n        {\\n            vec[0][i] = p[i-1] == \\'*\\' && vec[0][i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1723986,
                "title": "getting-tle-on-memoization-do-this",
                "content": "I tried doing memoization, but got TLE so i checked the discussion section, many others were facing the same issue. So I did a small changes in my memoization which is, I passed the strings by reference instead of passing by value and voila! submission got accepted xD.\\nMy solution.\\n*Upvote if helpful*\\n```\\nclass Solution {\\npublic:\\n    bool recursive_engine(string &s, string &p,int i,int j,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        bool output;\\n        if(i==s.length()){\\n            output= ((j==p.length()) || (p[j]==\\'*\\' && recursive_engine(s,p,i,j+1,dp)));\\n            \\n        }\\n        else if(p[j]==\\'*\\'){\\n            output= recursive_engine(s,p,i+1,j,dp) || recursive_engine(s,p,i,j+1,dp);\\n        }\\n        else{\\n            if(s[i]==p[j] || p[j]==\\'?\\'){\\n                output= recursive_engine(s,p,i+1,j+1,dp);\\n            }\\n            else output= false;\\n        }\\n        dp[i][j]=output;\\n        return output;\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,-1));\\n        return recursive_engine(s,p,0,0,dp);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool recursive_engine(string &s, string &p,int i,int j,vector<vector<int>> &dp){\\n        if(dp[i][j]!=-1){\\n            return dp[i][j];\\n        }\\n        bool output;\\n        if(i==s.length()){\\n            output= ((j==p.length()) || (p[j]==\\'*\\' && recursive_engine(s,p,i,j+1,dp)));\\n            \\n        }\\n        else if(p[j]==\\'*\\'){\\n            output= recursive_engine(s,p,i+1,j,dp) || recursive_engine(s,p,i,j+1,dp);\\n        }\\n        else{\\n            if(s[i]==p[j] || p[j]==\\'?\\'){\\n                output= recursive_engine(s,p,i+1,j+1,dp);\\n            }\\n            else output= false;\\n        }\\n        dp[i][j]=output;\\n        return output;\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(s.length()+1,vector<int>(p.length()+1,-1));\\n        return recursive_engine(s,p,0,0,dp);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231816,
                "title": "two-sol-intution-from-recursion-to-dp-two-pointer-solution",
                "content": "**Intution from recursion to DP**\\nSo question is to match the two string where one contain some special character having some meaning ,\\nok let\\'s start thinking from basic if have two string to comapre what we can do:-\\n* compare first letter from both if equal then recursively compare for next letter , if not equal then simply return false.\\n* Base conditions:  \\n1. * if both string exhaust return true.    \\n1. * if one string exhaust and one is still , return false.\\n\\nNow come to our question we have two special char.\\n1. \\'?\\' replacable by any single letter\\n2. \\'*\\' replaceable by 0 or more letters.\\n\\nThus we need to consider three cases :-\\n1. when we encouter \\'*\\' in our pattern string , so we will recursively take all possibility like from empty string to the whole remaining string in our string .\\n2. when we encounter \\'? in our pattern string , simply we insert the same char which is present in our string, thus we move for the next.\\n3. same as normal check if current char are equal && recursively call for next char.\\n\\n#### **Here is sample code for it.**\\n\\n```\\n bool rec(string s, string p,int i,int j){\\n        if(s.length() == i && p.length() == j) return true;\\n        if(s.length() == i) {\\n            while(j != p.length()){\\n                if(p[j] != \\'*\\') return false;\\n                j++;\\n            }\\n            return true;\\n        }\\n        if(p.length() == j) return false;\\n        \\n        if(p[j] == \\'*\\'){ \\n            int k = i;\\n            bool ans = false;\\n            while(s.length() >= k){\\n                ans = ans  | rec(s,p,k,j+1);\\n                k++;\\n            }\\n            return ans;\\n        }\\n        else if(p[j] == \\'?\\'){\\n            return rec(s,p,i+1,j+1);\\n        }\\n        else{\\n           return s[i] == p[j] && rec(s,p,i+1,j+1);\\n        }\\n    }\\n```\\n\\nBut In this question it give TLE for the provided input , so we need to go for DP\\nIn Dp intialision part will be like if string length 0 so only if pattern contains * then true otherwise false,\\nand if pattern length 0 ,not possible so always false.\\nif encounter \\'*\\' look for one less in first || one less in seocond , \\'?\\' look for one less in both\\notherwise normally comapre and look for one less in both.\\n\\n### **Here is DP working code**\\n\\n```\\n   bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        \\n        bool dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                //initalisation\\n                if(i == 0 && j == 0) dp[i][j] = true;\\n                if(i == 0 && j > 0){\\n                    dp[i][j] = (p[j-1] == \\'*\\') && dp[i][j-1];\\n                }\\n                if(i > 0 && j == 0) dp[i][j] = false;\\n                if(i > 0 && j > 0){\\n                    if(p[j-1] == \\'*\\'){\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                    }\\n                    else if(p[j-1] == \\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n   }\\n```\\n\\nBut if we consider complexity of solution it\\'s like :-\\n1. Time Comlexity O(n*m)\\n2. space Comlexity O(n*m)\\n\\nWe can do better ? using two pointer approach.\\n[Explanation](https://leetcode.com/problems/wildcard-matching/discuss/17811/My-three-C%2B%2B-solutions-(iterative-(16ms)-and-DP-(180ms)-and-modified-recursion-(88ms)))\\n\\n```\\n  bool isMatch(string s, string p) {\\n        int  n = s.size();\\n        int  m = p.size();\\n        int k =-1,jEnc=-1;\\n        int i=0,j=0;\\n        while(i < n){\\n            if(p[j]==\\'*\\'){ \\n                k   = i;\\n                jEnc = j;\\n                i--;\\n            }\\n            else{ \\n                if(p[j] != s[i] && p[j] != \\'?\\'){\\n                    if(k >=0){\\n                        i = k;\\n                        j = jEnc;\\n                        k++;\\n                    }\\n                    else return false; \\n                }\\n            }\\n            ++i;\\n            ++j;\\n        }\\n        \\n        while(p[j]==\\'*\\') ++j;\\n        return j == m;\\n    }\\n```\\n\\ncredit to [Lejas](https://leetcode.com/LeJas/) for explaining two pointer solution in [this post.](https://leetcode.com/problems/wildcard-matching/discuss/17811/My-three-C%2B%2B-solutions-(iterative-(16ms)-and-DP-(180ms)-and-modified-recursion-(88ms)))\\n\\n",
                "solutionTags": [],
                "code": "```\\n bool rec(string s, string p,int i,int j){\\n        if(s.length() == i && p.length() == j) return true;\\n        if(s.length() == i) {\\n            while(j != p.length()){\\n                if(p[j] != \\'*\\') return false;\\n                j++;\\n            }\\n            return true;\\n        }\\n        if(p.length() == j) return false;\\n        \\n        if(p[j] == \\'*\\'){ \\n            int k = i;\\n            bool ans = false;\\n            while(s.length() >= k){\\n                ans = ans  | rec(s,p,k,j+1);\\n                k++;\\n            }\\n            return ans;\\n        }\\n        else if(p[j] == \\'?\\'){\\n            return rec(s,p,i+1,j+1);\\n        }\\n        else{\\n           return s[i] == p[j] && rec(s,p,i+1,j+1);\\n        }\\n    }\\n```\n```\\n   bool isMatch(string s, string p) {\\n        int n = s.length();\\n        int m = p.length();\\n        \\n        bool dp[n+1][m+1];\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=m;j++){\\n                //initalisation\\n                if(i == 0 && j == 0) dp[i][j] = true;\\n                if(i == 0 && j > 0){\\n                    dp[i][j] = (p[j-1] == \\'*\\') && dp[i][j-1];\\n                }\\n                if(i > 0 && j == 0) dp[i][j] = false;\\n                if(i > 0 && j > 0){\\n                    if(p[j-1] == \\'*\\'){\\n                        dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                    }\\n                    else if(p[j-1] == \\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }\\n                    else{\\n                        dp[i][j] = dp[i-1][j-1] && (s[i-1] == p[j-1]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[n][m];\\n   }\\n```\n```\\n  bool isMatch(string s, string p) {\\n        int  n = s.size();\\n        int  m = p.size();\\n        int k =-1,jEnc=-1;\\n        int i=0,j=0;\\n        while(i < n){\\n            if(p[j]==\\'*\\'){ \\n                k   = i;\\n                jEnc = j;\\n                i--;\\n            }\\n            else{ \\n                if(p[j] != s[i] && p[j] != \\'?\\'){\\n                    if(k >=0){\\n                        i = k;\\n                        j = jEnc;\\n                        k++;\\n                    }\\n                    else return false; \\n                }\\n            }\\n            ++i;\\n            ++j;\\n        }\\n        \\n        while(p[j]==\\'*\\') ++j;\\n        return j == m;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218483,
                "title": "python-solution-using-dp",
                "content": "\\tclass Solution:\\n\\t\\tdef isMatch(self, s: str, p: str) -> bool:\\n\\t\\t\\tm = len(p)                    # Length of the pattern\\n\\t\\t\\tn = len(s)                    # Length of the string\\n\\n\\t\\t\\t# Creating a 2D list of size n x m, with initial values to True\\n\\t\\t\\tdp = [[True for i in range(m+1)] for j in range(n+1)]\\n\\n\\t\\t\\t# Get the First row values of \\'dp\\'\\n\\t\\t\\ti = 0\\n\\t\\t\\tfor j in range(m+1):\\n\\t\\t\\t\\tif j == 0:\\n\\t\\t\\t\\t\\tdp[i][j] = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i][j-1]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False\\n\\n\\t\\t\\t# Initialize the First column\\'s values of \\'dp\\' to False\\n\\t\\t\\tfor j in range(1, n+1):\\n\\t\\t\\t\\tdp[j][0] = False\\n\\n\\t\\t\\t# Get all the index values of \\'dp\\'\\n\\t\\t\\tfor i in range(1, n+1):\\n\\t\\t\\t\\tfor j in range(1, m+1):\\n\\t\\t\\t\\t\\t# If (i-1)th char of \\'s\\' and (j-1)th of \\'p\\' char are same or (j-1)th char of \\'p\\' is \\'?\\'\\n\\t\\t\\t\\t\\tif s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]  # Set [i, j] index value to the previous diagonal value\\n\\n\\t\\t\\t\\t\\t# If (j-1)th char of \\'p\\' is \\'*\\'\\n\\t\\t\\t\\t\\telif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\t# If any of [i-1, j]th or [i, j-1]th index value is True\\n\\t\\t\\t\\t\\t\\tif dp[i-1][j] == True or dp[i][j-1] == True:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = True     # Set [i, j]th index value to True\\n\\t\\t\\t\\t\\t\\t# Else\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = False    # Set [i, j]th index value to False\\n\\n\\t\\t\\t\\t\\t# If [i-1]th char of \\'s\\' and [j-1]th char of \\'p\\' are not the same\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False        # Set [i, j]th index value to False\\n\\t\\t\\t\\t# End Inner For Loop\\n\\t\\t\\t# End Outer For Loop\\n\\n\\t\\t\\t# Return the [n, m]th index value of \\'dp\\' as the answer\\n\\t\\t\\treturn dp[n][m]\\n\\n\\t\\'\\'\\'\\n\\t** Manual Tracing: An example\\n\\t\\t  0 1 2 3 4          0 1 2 3\\n\\ts =   a d c e b ;   p =  * a * b ;     m = len(p) = 4;  n = len(s) = 5\\n\\ti < n+1 = 6 ;  j < m+1 = 5\\n\\t  i = 1:         j = 1: s[0] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[1][1] =   d[0][1] || d[1][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[0] == p[1] or p[1] == \\'?\\' ?=                     YES: d[1][2] =   d[i-1][j-1]=d[0][1]  = T \\\\\\n\\t\\t\\t\\t\\t j = 3; s[0] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[1][3] =   d[0][3] || d[1][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[0] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[1][3] =                        = F \\\\\\n\\n\\t  i = 2:         j = 1: s[1] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[2][1] =   d[1][1] || d[2][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[1] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[2][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[1] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[2][3] =   d[1][3] || d[2][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[1] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[2][3] =                        = F \\\\\\n\\n\\t  i = 3:         j = 1: s[2] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[3][1] =   d[2][1] || d[3][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[2] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[3][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[2] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[3][3] =   d[2][3] || d[3][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[2] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[3][3] =                        = F \\\\\\n\\n\\t  i = 4:         j = 1: s[3] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[4][1] =   d[3][1] || d[4][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[3] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[4][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[3] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[4][3] =   d[3][3] || d[4][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[3] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[4][3] =                        = F \\\\\\n\\n\\t  i = 5:         j = 1: s[4] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[5][1] =   d[4][1] || d[5][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[4] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[5][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[4] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[5][3] =   d[4][3] || d[5][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[4] == p[3] or p[3] == \\'?\\' ?=                     YES: d[5][4] =   d[i-1][j-1]=d[4][3]  = T \\\\\\n\\n\\t\\tdp: \\n\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   | 0 | 1 | 2 | 3 | 4 |\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   |\\' \\'| * | a | * | b----> Pattern\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 0 |\\' \\'| T | T | T | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 1 | a | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 2 | d | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 3 | c | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 4 | e | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 5 | b | F | T | F | T | T----> Answer\\n\\t   |---|-|-|---|---|---|---|---|\\n\\t\\t\\t |\\n\\t\\t\\t \\'--> String\\n\\t\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isMatch(self, s: str, p: str) -> bool:\\n\\t\\t\\tm = len(p)                    # Length of the pattern\\n\\t\\t\\tn = len(s)                    # Length of the string\\n\\n\\t\\t\\t# Creating a 2D list of size n x m, with initial values to True\\n\\t\\t\\tdp = [[True for i in range(m+1)] for j in range(n+1)]\\n\\n\\t\\t\\t# Get the First row values of \\'dp\\'\\n\\t\\t\\ti = 0\\n\\t\\t\\tfor j in range(m+1):\\n\\t\\t\\t\\tif j == 0:\\n\\t\\t\\t\\t\\tdp[i][j] = True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i][j-1]\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False\\n\\n\\t\\t\\t# Initialize the First column\\'s values of \\'dp\\' to False\\n\\t\\t\\tfor j in range(1, n+1):\\n\\t\\t\\t\\tdp[j][0] = False\\n\\n\\t\\t\\t# Get all the index values of \\'dp\\'\\n\\t\\t\\tfor i in range(1, n+1):\\n\\t\\t\\t\\tfor j in range(1, m+1):\\n\\t\\t\\t\\t\\t# If (i-1)th char of \\'s\\' and (j-1)th of \\'p\\' char are same or (j-1)th char of \\'p\\' is \\'?\\'\\n\\t\\t\\t\\t\\tif s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1]  # Set [i, j] index value to the previous diagonal value\\n\\n\\t\\t\\t\\t\\t# If (j-1)th char of \\'p\\' is \\'*\\'\\n\\t\\t\\t\\t\\telif p[j-1] == \\'*\\':\\n\\t\\t\\t\\t\\t\\t# If any of [i-1, j]th or [i, j-1]th index value is True\\n\\t\\t\\t\\t\\t\\tif dp[i-1][j] == True or dp[i][j-1] == True:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = True     # Set [i, j]th index value to True\\n\\t\\t\\t\\t\\t\\t# Else\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tdp[i][j] = False    # Set [i, j]th index value to False\\n\\n\\t\\t\\t\\t\\t# If [i-1]th char of \\'s\\' and [j-1]th char of \\'p\\' are not the same\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tdp[i][j] = False        # Set [i, j]th index value to False\\n\\t\\t\\t\\t# End Inner For Loop\\n\\t\\t\\t# End Outer For Loop\\n\\n\\t\\t\\t# Return the [n, m]th index value of \\'dp\\' as the answer\\n\\t\\t\\treturn dp[n][m]\\n\\n\\t\\'\\'\\'\\n\\t** Manual Tracing: An example\\n\\t\\t  0 1 2 3 4          0 1 2 3\\n\\ts =   a d c e b ;   p =  * a * b ;     m = len(p) = 4;  n = len(s) = 5\\n\\ti < n+1 = 6 ;  j < m+1 = 5\\n\\t  i = 1:         j = 1: s[0] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[1][1] =   d[0][1] || d[1][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[0] == p[1] or p[1] == \\'?\\' ?=                     YES: d[1][2] =   d[i-1][j-1]=d[0][1]  = T \\\\\\n\\t\\t\\t\\t\\t j = 3; s[0] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[1][3] =   d[0][3] || d[1][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[0] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[1][3] =                        = F \\\\\\n\\n\\t  i = 2:         j = 1: s[1] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[2][1] =   d[1][1] || d[2][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[1] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[2][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[1] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[2][3] =   d[1][3] || d[2][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[1] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[2][3] =                        = F \\\\\\n\\n\\t  i = 3:         j = 1: s[2] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[3][1] =   d[2][1] || d[3][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[2] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[3][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[2] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[3][3] =   d[2][3] || d[3][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[2] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[3][3] =                        = F \\\\\\n\\n\\t  i = 4:         j = 1: s[3] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[4][1] =   d[3][1] || d[4][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[3] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[4][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[3] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[4][3] =   d[3][3] || d[4][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[3] == p[3] or p[3] == \\'?\\' ?= NO ; p[3] == \\'*\\' ?= NO : d[4][3] =                        = F \\\\\\n\\n\\t  i = 5:         j = 1: s[4] == p[0] or p[0] == \\'?\\' ?= NO ; p[0] == \\'*\\' ?= YES: d[5][1] =   d[4][1] || d[5][0]   = T \\\\\\n\\t\\t\\t\\t\\t j = 2; s[4] == p[1] or p[1] == \\'?\\' ?= NO ; p[1] == \\'*\\' ?= NO : d[5][2] =                        = F \\\\\\n\\t\\t\\t\\t\\t j = 3; s[4] == p[2] or p[2] == \\'?\\' ?= NO ; p[2] == \\'*\\' ?= YES: d[5][3] =   d[4][3] || d[5][2]   = T \\\\\\n\\t\\t\\t\\t\\t j = 4; s[4] == p[3] or p[3] == \\'?\\' ?=                     YES: d[5][4] =   d[i-1][j-1]=d[4][3]  = T \\\\\\n\\n\\t\\tdp: \\n\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   | 0 | 1 | 2 | 3 | 4 |\\n\\t\\t\\t   |---|---|---|---|---|\\n\\t\\t\\t   |\\' \\'| * | a | * | b----> Pattern\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 0 |\\' \\'| T | T | T | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 1 | a | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 2 | d | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 3 | c | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 4 | e | F | T | F | T | F |\\n\\t   |---|---|---|---|---|---|---|\\n\\t   | 5 | b | F | T | F | T | T----> Answer\\n\\t   |---|-|-|---|---|---|---|---|\\n\\t\\t\\t |\\n\\t\\t\\t \\'--> String\\n\\t\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1210412,
                "title": "python-o-m-n-top-down-dp-solution",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False for i in range(m + 1)] for i in range(n + 1)]\\n        \\n        dp[0][0] = True\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[j - 1] == p[i - 1] or p[i - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[i - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n        return dp[n][m]\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[False for i in range(m + 1)] for i in range(n + 1)]\\n        \\n        dp[0][0] = True\\n        for i in range(1,n + 1):\\n            if(p[i - 1] == \\'*\\'):\\n                dp[i][0] = True\\n            else:\\n                break\\n        for i in range(1, n + 1):\\n            for j in range(1, m + 1):\\n                if s[j - 1] == p[i - 1] or p[i - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[i - 1] == \\'*\\':\\n                    dp[i][j] = dp[i][j - 1] or dp[i - 1][j]\\n        return dp[n][m]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206824,
                "title": "python3-dp-think-removing",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \"\"\"dynamic programming, think \"removing\"\\n\\n        dp[i][j] == T/F if char match between s[i] and p[j]\\n\\n        1) if s[i] == p[j] or p[j] == \"?\"\\n\\n        - effectively the same as *removing* both characters, and thus resulting\\n          evaluation based on previous subproblem: dp[i][j] = dp[i-1][j-1]\\n\\n        2) if p[j] == \"*\"\\n\\n        - one possibility is the empty sequence, so effectively same as\\n          *removing* the star character and thus evaluation based on previous\\n          subproblem: dp[i][j] = dp[i][j-1]\\n\\n        - another possibility is matching against one or more characters, in\\n          which case effectively same as *removing* character from s[i], and\\n          thus evaluation based on previous subproblem: dp[i][j] = dp[i-1][j]\\n\\n              * c d\\n            0 1 2 3\\n          0 T T F F\\n        a 1 F T F F\\n        b 2 F T F F\\n        c 3 F T T F\\n        d 4 F T F T <- corresponds to matching pattern\\n\\n              a * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F T T F\\n        b 2 F F T F\\n        c 3 F F T F\\n        d 4 F F T T\\n\\n              z * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F F F F\\n        b 2 F F F F\\n        c 3 F F F F\\n        d 4 F F F F\\n\\n        Notably, when initializing the table of subproblems dp, we need to\\n        correctly set the first row per defined rules above.\\n\\n        O(MN) time and space; MN corresponds to lengths of input s / p\\n        \"\"\"\\n        ls, lp = len(s), len(p)\\n        dp = [[False for _ in range(lp+1)] for __ in range(ls+1)]\\n        dp[0][0] = True\\n\\n        for j in range(1, lp+1):\\n            if p[j-1] == \"*\":\\n                dp[0][j] = dp[0][j-1]\\n\\n        for i in range(1, ls+1):\\n            for j in range(1, lp+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                if p[j-1] == \"*\":\\n                    opt1 = dp[i][j-1]\\n                    opt2 = dp[i-1][j]\\n                    dp[i][j] = opt1 or opt2\\n\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \"\"\"dynamic programming, think \"removing\"\\n\\n        dp[i][j] == T/F if char match between s[i] and p[j]\\n\\n        1) if s[i] == p[j] or p[j] == \"?\"\\n\\n        - effectively the same as *removing* both characters, and thus resulting\\n          evaluation based on previous subproblem: dp[i][j] = dp[i-1][j-1]\\n\\n        2) if p[j] == \"*\"\\n\\n        - one possibility is the empty sequence, so effectively same as\\n          *removing* the star character and thus evaluation based on previous\\n          subproblem: dp[i][j] = dp[i][j-1]\\n\\n        - another possibility is matching against one or more characters, in\\n          which case effectively same as *removing* character from s[i], and\\n          thus evaluation based on previous subproblem: dp[i][j] = dp[i-1][j]\\n\\n              * c d\\n            0 1 2 3\\n          0 T T F F\\n        a 1 F T F F\\n        b 2 F T F F\\n        c 3 F T T F\\n        d 4 F T F T <- corresponds to matching pattern\\n\\n              a * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F T T F\\n        b 2 F F T F\\n        c 3 F F T F\\n        d 4 F F T T\\n\\n              z * d\\n            0 1 2 3\\n          0 T F F F\\n        a 1 F F F F\\n        b 2 F F F F\\n        c 3 F F F F\\n        d 4 F F F F\\n\\n        Notably, when initializing the table of subproblems dp, we need to\\n        correctly set the first row per defined rules above.\\n\\n        O(MN) time and space; MN corresponds to lengths of input s / p\\n        \"\"\"\\n        ls, lp = len(s), len(p)\\n        dp = [[False for _ in range(lp+1)] for __ in range(ls+1)]\\n        dp[0][0] = True\\n\\n        for j in range(1, lp+1):\\n            if p[j-1] == \"*\":\\n                dp[0][j] = dp[0][j-1]\\n\\n        for i in range(1, ls+1):\\n            for j in range(1, lp+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                if p[j-1] == \"*\":\\n                    opt1 = dp[i][j-1]\\n                    opt2 = dp[i-1][j]\\n                    dp[i][j] = opt1 or opt2\\n\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988649,
                "title": "python-dynamic-programming-approach-o-m-n",
                "content": "**Easy to understand python3 solution**\\n```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # fisrt we make a clear pattern \\n        # i.e *****a****b***c** is same as *a*b*c*\\n        def clear_pattern(p):\\n            ans = []\\n            for i in range(len(p)):\\n                if p[i] != \\'*\\':\\n                    ans.append(p[i])\\n                else:\\n                    if ans and ans[-1] == \\'*\\':\\n                        continue\\n                    else:\\n                        ans.append(p[i])\\n            p = \\'\\'.join(ans)\\n            return p\\n        p = clear_pattern(p)\\n        \\n        # now we apply dynamic programming approach to solve the problem\\n        dp = [[False for j in range(len(p) + 1)] for i in range(len(s) + 1)]\\n        # null string is always same as null string\\n        dp[0][0] = True\\n        \\n        if p and p[0] == \\'*\\':\\n            dp[0][1] = True\\n            \\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                \\'\\'\\'\\n                if both the characters are equal or pattern has ? then we need to check\\n                for the string if it is matched till previous charcters length\\n                \\'\\'\\'\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\\n        return dp[len(s)][len(p)]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # fisrt we make a clear pattern \\n        # i.e *****a****b***c** is same as *a*b*c*\\n        def clear_pattern(p):\\n            ans = []\\n            for i in range(len(p)):\\n                if p[i] != \\'*\\':\\n                    ans.append(p[i])\\n                else:\\n                    if ans and ans[-1] == \\'*\\':\\n                        continue\\n                    else:\\n                        ans.append(p[i])\\n            p = \\'\\'.join(ans)\\n            return p\\n        p = clear_pattern(p)\\n        \\n        # now we apply dynamic programming approach to solve the problem\\n        dp = [[False for j in range(len(p) + 1)] for i in range(len(s) + 1)]\\n        # null string is always same as null string\\n        dp[0][0] = True\\n        \\n        if p and p[0] == \\'*\\':\\n            dp[0][1] = True\\n            \\n        for i in range(1, len(s) + 1):\\n            for j in range(1, len(p) + 1):\\n                \\'\\'\\'\\n                if both the characters are equal or pattern has ? then we need to check\\n                for the string if it is matched till previous charcters length\\n                \\'\\'\\'\\n                if s[i - 1] == p[j - 1] or p[j - 1] == \\'?\\':\\n                    dp[i][j] = dp[i - 1][j - 1]\\n                elif p[j - 1] == \\'*\\':\\n                    dp[i][j] = dp[i - 1][j] or dp[i][j - 1]\\n        return dp[len(s)][len(p)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824268,
                "title": "java-evolve-to-dp-solution-all-4-approaches",
                "content": "```\\n\\n/**\\n * General Idea: Credit: https://leetcode.com/problems/wildcard-matching/discuss/370736/Detailed-Intuition-From-Brute-force-to-Bottom-up-DP \\n * The idea is pretty straightforward : scan S and P while there is a match between the current character of S and the current character of P. \\n * If we reach the end of both strings while there is still a match, return True, otherwise return False. \\n * The scan is done by having a pointer in S and a pointer in P.\\n\\n\\tExample: S=\"code\"\\n\\tThe character \\'c\\' of S matches the first character of P if the first character of P is:\\n\\n\\t\\'c\\'\\n\\t\\'?\\'\\n\\t\\'*\\'\\n\\n\\tCase 1:\\n\\t\\tWhen the first character of P is a lowercase letter different from \\'c\\', return False.\\n\\tCase 2:\\n\\t\\tIf the first character of P is \\'c\\' or \\'?\\', we move both pointers one step to the right.\\n\\tCase 3:\\n\\t\\tIf the first character of P is \\'*\\', we have 2 possibilities:\\n\\n\\t\\t\\t- \\'*\\' matches 0 character : in this case we move the pointer in P one step, ie will ignore the whole pattern\\n\\t\\t\\t- \\'*\\' matches 1 or more characters : in this case we move the pointer in S one step, ie we consider pattern\\n\\tAnd we continue like this for each two positions taken by the two pointers.\\n\\n\\t- If we reach the end of P but there is still characters from S, simply return .. False !\\n\\t- If we reach the end of S and there is still characters from P, the only case when there is a match is that all the remaining characters in P are \\'*\\', \\n\\t  in this case these stars will be matched with the empty string.\\n ****/\\n\\n/*******************\\n * Approach 1: TLE: using recursion\\n * \\n * Time Complexity : \\n * \\n * Space Complexity : O(M^2+N^2)\\n **********************************/\\n\\npublic boolean isMatchApproach1(String text, String pattern) {\\n\\treturn isMatchApproach1Helper(0, 0, text, pattern);\\n}\\n\\npublic boolean isMatchApproach1Helper(int tIdx, int pIdx, String text, String pattern) {\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\treturn true;\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\t\\treturn false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\treturn pattern.charAt(pIdx) == \\'*\\' && isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern);\\n\\t}\\n\\t// Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\treturn isMatchApproach1Helper(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\treturn isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern)\\n\\t\\t\\t\\t|| isMatchApproach1Helper(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n/*******************\\n * Approach 2: Top Down Memoization + Recursion\\n * Top-down the smallest problem is (len(s), len(p)),\\n * \\n * Time Complexity : O(m * n)\\n * \\n * Space Complexity : O(m * n)\\n **********************************/\\nBoolean[][] memo;\\n\\npublic boolean isMatchApproach2(String text, String pattern) {\\n\\tmemo = new Boolean[text.length() + 1][pattern.length() + 1];\\n\\treturn dpMemo(0, 0, text, pattern);\\n}\\n\\npublic boolean dpMemo(int tIdx, int pIdx, String text, String pattern) {\\n\\tif (memo[tIdx][pIdx] != null) {\\n\\t\\treturn memo[tIdx][pIdx];\\n\\t}\\n\\tboolean match = false; // False picked up in memo @ end for else case when chars don\\'t match.\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\tmatch = true;\\n\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\n\\t\\tmatch = false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\tmatch = pattern.charAt(pIdx) == \\'*\\' && dpMemo(tIdx, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t//  Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\tmatch = dpMemo(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t} \\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\tmatch = dpMemo(tIdx, pIdx + 1, text, pattern) || dpMemo(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn memo[tIdx][pIdx] = match;\\n}\\n\\n/*******************\\n * Approach 3: Bottom Up Tabulation: https://www.youtube.com/watch?v=3ZDZ-N0EPV0\\n * Bottom-up the smallest is (0, 0)\\n * \\n * \\t\\t\\t\\t|\\tdp[i-1][j-1]  if str[i] == pattern[j] || pattern[j] == \\'?\\'\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tif pattern[j-1] == \\'*\\'\\n * dp[i][j] = \\t|\\t\\tdp[i][j-1] || dp[i-1][j]\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tFalse\\n * \\n * Time Complexity : O(m * n)\\n * Space Complexity : O(m * n)\\n **********************************/\\n\\npublic boolean isMatchApproach3(String text, String pattern) {\\n\\n\\tint m = text.length();\\n\\tint n = pattern.length();\\n\\tboolean[][] dp = new boolean[m + 1][n + 1];\\n\\n\\tfor (int tIdx = 0; tIdx <= m; tIdx++) {\\n\\t\\tfor (int pIdx = 0; pIdx <= n; pIdx++) {\\n\\n\\t\\t\\t// empty strings match\\n\\t\\t\\tif (tIdx == 0 && pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = true;\\n\\n\\t\\t\\t// fill first row, empty text can match all * pattern\\n\\t\\t\\telse if (tIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = pattern.charAt(pIdx - 1) == \\'*\\' && dp[tIdx][pIdx - 1] == true;\\n\\n\\t\\t\\t// Can\\'t have a non-empty text match an empty pattern.\\n\\t\\t\\telse if (pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = false;\\n\\n\\t\\t\\t// star either matches 0 or >=1 character\\n\\t\\t\\telse if (pattern.charAt(pIdx - 1) == \\'*\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx][pIdx - 1] || dp[tIdx - 1][pIdx];\\n\\n\\t\\t\\t//  Here cuz text & pattern match atleast a char\\n\\t\\t\\telse if (text.charAt(tIdx - 1) == pattern.charAt(pIdx - 1) || pattern.charAt(pIdx - 1) == \\'?\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx - 1][pIdx - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\n/*\\n * Approach 4: Linear: Very tricky: https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution\\n */\\npublic boolean isMatchApproach4(String text, String pattern) {\\n\\tint tIdx = 0, pIdx = 0, match = 0, starIdx = -1;\\n\\n\\twhile (tIdx < text.length()) {\\n\\t\\t// advancing both pointers\\n\\t\\tif (pIdx < pattern.length() && (pattern.charAt(pIdx) == \\'?\\' || text.charAt(tIdx) == pattern.charAt(pIdx))) {\\n\\t\\t\\ttIdx++;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// \\'*\\' found, only advancing pattern pointer\\n\\t\\telse if (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t\\tstarIdx = pIdx;\\n\\t\\t\\tmatch = tIdx;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// last pattern pointer was *, advancing string pointer\\n\\t\\telse if (starIdx != -1) {\\n\\t\\t\\tpIdx = starIdx + 1;\\n\\t\\t\\tmatch++;\\n\\t\\t\\ttIdx = match;\\n\\t\\t}\\n\\t\\t//current pattern pointer is not star, last patter pointer was not *\\n\\t\\t//characters do not match\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t//check for remaining characters in pattern\\n\\twhile (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\')\\n\\t\\tpIdx++;\\n\\n\\treturn pIdx == pattern.length();\\n}",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * General Idea: Credit: https://leetcode.com/problems/wildcard-matching/discuss/370736/Detailed-Intuition-From-Brute-force-to-Bottom-up-DP \\n * The idea is pretty straightforward : scan S and P while there is a match between the current character of S and the current character of P. \\n * If we reach the end of both strings while there is still a match, return True, otherwise return False. \\n * The scan is done by having a pointer in S and a pointer in P.\\n\\n\\tExample: S=\"code\"\\n\\tThe character \\'c\\' of S matches the first character of P if the first character of P is:\\n\\n\\t\\'c\\'\\n\\t\\'?\\'\\n\\t\\'*\\'\\n\\n\\tCase 1:\\n\\t\\tWhen the first character of P is a lowercase letter different from \\'c\\', return False.\\n\\tCase 2:\\n\\t\\tIf the first character of P is \\'c\\' or \\'?\\', we move both pointers one step to the right.\\n\\tCase 3:\\n\\t\\tIf the first character of P is \\'*\\', we have 2 possibilities:\\n\\n\\t\\t\\t- \\'*\\' matches 0 character : in this case we move the pointer in P one step, ie will ignore the whole pattern\\n\\t\\t\\t- \\'*\\' matches 1 or more characters : in this case we move the pointer in S one step, ie we consider pattern\\n\\tAnd we continue like this for each two positions taken by the two pointers.\\n\\n\\t- If we reach the end of P but there is still characters from S, simply return .. False !\\n\\t- If we reach the end of S and there is still characters from P, the only case when there is a match is that all the remaining characters in P are \\'*\\', \\n\\t  in this case these stars will be matched with the empty string.\\n ****/\\n\\n/*******************\\n * Approach 1: TLE: using recursion\\n * \\n * Time Complexity : \\n * \\n * Space Complexity : O(M^2+N^2)\\n **********************************/\\n\\npublic boolean isMatchApproach1(String text, String pattern) {\\n\\treturn isMatchApproach1Helper(0, 0, text, pattern);\\n}\\n\\npublic boolean isMatchApproach1Helper(int tIdx, int pIdx, String text, String pattern) {\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\treturn true;\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\t\\treturn false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\treturn pattern.charAt(pIdx) == \\'*\\' && isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern);\\n\\t}\\n\\t// Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\treturn isMatchApproach1Helper(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\treturn isMatchApproach1Helper(tIdx, pIdx + 1, text, pattern)\\n\\t\\t\\t\\t|| isMatchApproach1Helper(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn false;\\n}\\n\\n/*******************\\n * Approach 2: Top Down Memoization + Recursion\\n * Top-down the smallest problem is (len(s), len(p)),\\n * \\n * Time Complexity : O(m * n)\\n * \\n * Space Complexity : O(m * n)\\n **********************************/\\nBoolean[][] memo;\\n\\npublic boolean isMatchApproach2(String text, String pattern) {\\n\\tmemo = new Boolean[text.length() + 1][pattern.length() + 1];\\n\\treturn dpMemo(0, 0, text, pattern);\\n}\\n\\npublic boolean dpMemo(int tIdx, int pIdx, String text, String pattern) {\\n\\tif (memo[tIdx][pIdx] != null) {\\n\\t\\treturn memo[tIdx][pIdx];\\n\\t}\\n\\tboolean match = false; // False picked up in memo @ end for else case when chars don\\'t match.\\n\\n\\t// reached the end of both S and P\\n\\tif (tIdx == text.length() && pIdx == pattern.length()) {\\n\\t\\tmatch = true;\\n\\n\\t}\\n\\t// there are still characters in S => there is no match\\n\\telse if (pIdx == pattern.length()) {\\n\\n\\t\\tmatch = false; // Can\\'t have a non-empty s match an empty p.\\n\\t}\\n\\t// if we reached end of text and pattern is still left. \\n\\t// Try to see if p at or after this stage is only * or ** or *** etc. Only way to match an empty text.\\n\\telse if (tIdx == text.length()) {\\n\\t\\tmatch = pattern.charAt(pIdx) == \\'*\\' && dpMemo(tIdx, pIdx + 1, text, pattern);\\n\\n\\t}\\n\\t//  Here cuz text & pattern match atleast a char\\n\\telse if (text.charAt(tIdx) == pattern.charAt(pIdx) || pattern.charAt(pIdx) == \\'?\\') {\\n\\n\\t\\t// Match here if strs from next index onward also are a match. Delegate job to recursive func for latter.\\n\\t\\tmatch = dpMemo(tIdx + 1, pIdx + 1, text, pattern);\\n\\n\\t} \\n\\t// star either matches 0 or >=1 character\\n\\telse if (pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t// 1: When * matches an empty seq, it\\'s work is done. Hence, the next stage to check match for is w/o *.\\n\\t\\t// \\t  Also, there could be *s in line. So, consuming this *, could exhibit new p with next fresh *.\\n\\t\\t// 2: \\'*\\' can match seq of chars. Hence, * kept. Further rec stages could use it to match more chars/empty.\\n\\t\\tmatch = dpMemo(tIdx, pIdx + 1, text, pattern) || dpMemo(tIdx + 1, pIdx, text, pattern);\\n\\t}\\n\\n\\treturn memo[tIdx][pIdx] = match;\\n}\\n\\n/*******************\\n * Approach 3: Bottom Up Tabulation: https://www.youtube.com/watch?v=3ZDZ-N0EPV0\\n * Bottom-up the smallest is (0, 0)\\n * \\n * \\t\\t\\t\\t|\\tdp[i-1][j-1]  if str[i] == pattern[j] || pattern[j] == \\'?\\'\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tif pattern[j-1] == \\'*\\'\\n * dp[i][j] = \\t|\\t\\tdp[i][j-1] || dp[i-1][j]\\n * \\t\\t\\t\\t|\\t\\t\\t\\t\\t\\n * \\t\\t\\t\\t|\\tFalse\\n * \\n * Time Complexity : O(m * n)\\n * Space Complexity : O(m * n)\\n **********************************/\\n\\npublic boolean isMatchApproach3(String text, String pattern) {\\n\\n\\tint m = text.length();\\n\\tint n = pattern.length();\\n\\tboolean[][] dp = new boolean[m + 1][n + 1];\\n\\n\\tfor (int tIdx = 0; tIdx <= m; tIdx++) {\\n\\t\\tfor (int pIdx = 0; pIdx <= n; pIdx++) {\\n\\n\\t\\t\\t// empty strings match\\n\\t\\t\\tif (tIdx == 0 && pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = true;\\n\\n\\t\\t\\t// fill first row, empty text can match all * pattern\\n\\t\\t\\telse if (tIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = pattern.charAt(pIdx - 1) == \\'*\\' && dp[tIdx][pIdx - 1] == true;\\n\\n\\t\\t\\t// Can\\'t have a non-empty text match an empty pattern.\\n\\t\\t\\telse if (pIdx == 0)\\n\\t\\t\\t\\tdp[tIdx][pIdx] = false;\\n\\n\\t\\t\\t// star either matches 0 or >=1 character\\n\\t\\t\\telse if (pattern.charAt(pIdx - 1) == \\'*\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx][pIdx - 1] || dp[tIdx - 1][pIdx];\\n\\n\\t\\t\\t//  Here cuz text & pattern match atleast a char\\n\\t\\t\\telse if (text.charAt(tIdx - 1) == pattern.charAt(pIdx - 1) || pattern.charAt(pIdx - 1) == \\'?\\')\\n\\t\\t\\t\\tdp[tIdx][pIdx] = dp[tIdx - 1][pIdx - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[m][n];\\n}\\n\\n/*\\n * Approach 4: Linear: Very tricky: https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution\\n */\\npublic boolean isMatchApproach4(String text, String pattern) {\\n\\tint tIdx = 0, pIdx = 0, match = 0, starIdx = -1;\\n\\n\\twhile (tIdx < text.length()) {\\n\\t\\t// advancing both pointers\\n\\t\\tif (pIdx < pattern.length() && (pattern.charAt(pIdx) == \\'?\\' || text.charAt(tIdx) == pattern.charAt(pIdx))) {\\n\\t\\t\\ttIdx++;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// \\'*\\' found, only advancing pattern pointer\\n\\t\\telse if (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\') {\\n\\t\\t\\tstarIdx = pIdx;\\n\\t\\t\\tmatch = tIdx;\\n\\t\\t\\tpIdx++;\\n\\t\\t}\\n\\t\\t// last pattern pointer was *, advancing string pointer\\n\\t\\telse if (starIdx != -1) {\\n\\t\\t\\tpIdx = starIdx + 1;\\n\\t\\t\\tmatch++;\\n\\t\\t\\ttIdx = match;\\n\\t\\t}\\n\\t\\t//current pattern pointer is not star, last patter pointer was not *\\n\\t\\t//characters do not match\\n\\t\\telse\\n\\t\\t\\treturn false;\\n\\t}\\n\\n\\t//check for remaining characters in pattern\\n\\twhile (pIdx < pattern.length() && pattern.charAt(pIdx) == \\'*\\')\\n\\t\\tpIdx++;\\n\\n\\treturn pIdx == pattern.length();\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 667143,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nfrom functools import lru_cache \\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return True if s[i:] matches p[j:]\"\"\"\\n            if j == len(p): return i == len(s)\\n            if i < len(s) and (s[i] == p[j] or p[j] == \"?\"): return fn(i+1, j+1)\\n            if p[j] == \"*\": return fn(i, j+1) or i < len(s) and fn(i+1, j)\\n            return False \\n        \\n        return fn(0, 0)\\n```\\n\\nThis is similar to but easier than [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/discuss/652563/Python3-top-down-dp).",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache \\n\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return True if s[i:] matches p[j:]\"\"\"\\n            if j == len(p): return i == len(s)\\n            if i < len(s) and (s[i] == p[j] or p[j] == \"?\"): return fn(i+1, j+1)\\n            if p[j] == \"*\": return fn(i, j+1) or i < len(s) and fn(i+1, j)\\n            return False \\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617975,
                "title": "java-python-dp",
                "content": "```\\n    public boolean isMatch(String s, String p) {\\n        if (s == null || p == null) return false;\\n        int m = s.length(), n = p.length();\\n        if (n == 0) return m == 0;\\n        boolean[][] dp = new boolean[m + 1][n + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < n; i++) {\\n            if (p.charAt(i) != \\'*\\') break;\\n            dp[0][i + 1] = true;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                } else if (p.charAt(j) == \\'*\\') {\\n                    dp[i+1][j+1] = dp[i+1][j] || dp[i][j+1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\\n\\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        ls = len(s)\\n        lp = len(p)\\n        if lp == 0: return ls == 0\\n        ss = i = j = 0\\n        star = -1\\n        while i < ls:\\n            if j < lp:\\n                if s[i] == p[j] or p[j] == \"?\":\\n                    i+=1\\n                    j+=1\\n                    continue\\n                elif p[j] == \"*\":\\n                    star = j\\n                    j = star +1\\n                    ss = i\\n                    continue\\n            if star != -1:\\n                j = star +1\\n                ss +=1\\n                i = ss\\n                continue\\n            return False\\n        while j < lp and p[j] == \"*\":\\n            j +=1\\n        return j == lp\\n            \\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isMatch(String s, String p) {\\n        if (s == null || p == null) return false;\\n        int m = s.length(), n = p.length();\\n        if (n == 0) return m == 0;\\n        boolean[][] dp = new boolean[m + 1][n + 1];\\n        dp[0][0] = true;\\n        for (int i = 0; i < n; i++) {\\n            if (p.charAt(i) != \\'*\\') break;\\n            dp[0][i + 1] = true;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (p.charAt(j) == \\'?\\' || p.charAt(j) == s.charAt(i)) {\\n                    dp[i+1][j+1] = dp[i][j];\\n                } else if (p.charAt(j) == \\'*\\') {\\n                    dp[i+1][j+1] = dp[i+1][j] || dp[i][j+1];\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n    }\\n```\n```\\nclass Solution(object):\\n    def isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        ls = len(s)\\n        lp = len(p)\\n        if lp == 0: return ls == 0\\n        ss = i = j = 0\\n        star = -1\\n        while i < ls:\\n            if j < lp:\\n                if s[i] == p[j] or p[j] == \"?\":\\n                    i+=1\\n                    j+=1\\n                    continue\\n                elif p[j] == \"*\":\\n                    star = j\\n                    j = star +1\\n                    ss = i\\n                    continue\\n            if star != -1:\\n                j = star +1\\n                ss +=1\\n                i = ss\\n                continue\\n            return False\\n        while j < lp and p[j] == \"*\":\\n            j +=1\\n        return j == lp\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 534681,
                "title": "python-three-solutions-1-recursion-with-momerize-2-dp-3-finate-state-machine",
                "content": "I met a simpler version of this problem during Mircrosoft on-site interview. During the on-site, there is only one wildcard \\'?\\' and \\'?\\' means zero or one arbitrary charecter. I solved this simpler wildcard matching problem using recursion. Then I came to Leetcode to find the wildcard matching problem and I found this problem #44.\\n\\nHere I provide my three solutions\\n1. **Recursion with memorization**. Without memorization and some other pruning techniques, there will be Time Limit Exceeded. My memorization is inspired from this [post](https://leetcode.com/problems/wildcard-matching/discuss/17811/My-three-C%2B%2B-solutions-(iterative-(16ms)-and-DP-(180ms)-and-modified-recursion-(88ms))). The key is to notice the following. Let *s_sub* be a substring of *s*, and let *p_sub* be a substring of *p*. If *s_sub* and *p_sub* doesn\\'t match, then *s* and *p* doesn\\'t match.\\n2. **Dynamic programming**. My first attemp failed because I had issue defining the subproblem.  Bad definition: let dp[i][j] be {0, 1, 2, 3, 4, ...}, the longest length of substring that s[1, ..., i ] match p[1, ..., j ]. I stuggled a lot with this subproblem definition. Then I looked at the discussion and fixed the difinition. Good definition: let dp[i][j] be {0, 1}, where {0} means s[1, ..., i ] doesn\\'t match p[1, ..., j ], and {1} means s[1, ..., i ] match p[1, ..., j ]. Under this definition, I solve the problem.\\n3. **Finite state machine**. This is the most elegant solution. I like this solution the most. I am inspired from this [post](https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time). First build a finate state machine using the pattern p, then run the machine with the input string s.\\n\\n\\n```\\n\\nclass Solution:\\n    \\'\\'\\'Recursion solution -- with memorization. \\n\\t   Time beat 86%.\\n    \\'\\'\\'\\n    def __init__(self):\\n        self.memorize = []  # memorize the smaller substrings s[i:] and p[j:] that doesn\\'t match\\n\\n    def update_memorize(self, s, i, p, j):\\n        s_no_match_new = len(s) - i  # the last s_no_match charecters of s\\n        p_no_match_new = len(p) - j  # the last p_no_match charecters of p\\n        new_memorize = []\\n        keep_new = True\\n        for s_no_match_old, p_no_match_old in self.memorize:\\n            if s_no_match_old < s_no_match_new or p_no_match_old < p_no_match_new:\\n                new_memorize.append((s_no_match_old, p_no_match_old))\\n            if s_no_match_old < s_no_match_new and p_no_match_old < p_no_match_new:\\n                keep_new = False\\n        if keep_new:\\n            new_memorize.append((s_no_match_new, p_no_match_new))\\n        self.memorize = new_memorize\\n\\n    def check_memorize(self, s, i, p, j):\\n        prune = False\\n        s_sub_len = len(s) - i\\n        p_sub_len = len(p) - j\\n        for s_no_match, p_no_match in self.memorize:\\n            if s_sub_len >= s_no_match and p_sub_len >= p_no_match:\\n                prune = True  # when two smaller substrings of s[i:] and p[j:] don\\'t match, s[i:] and p[j:] is guaranteed not to match, so prune it\\n                break         # the  two smaller substrings here are the last s_no_match charecters of s and the last p_no_match charecters of p\\n        return prune\\n\\n    def isMatch_helper(self, s: str, p: str) -> bool:\\n        if len(s) == 0 and len(p) == 0:  # both match to the end\\n            return True\\n        if len(s) == 0 or len(p) == 0:   # one comes to the end but the other not\\n            return False\\n        if s[0] == p[0] or p[0] == \\'?\\':  # match\\n            return self.isMatch_helper(s[1:], p[1:])\\n        if s[0] != p[0] and p[0] == \\'*\\':\\n            i, j = 0, 0\\n            while j < len(p):            # j points to the first char that is not \\'*\\'\\n                if p[j] != \\'*\\':\\n                    break\\n                j += 1\\n            counter = 0\\n            for k in range(j+1, len(p)): # for pruning the search space for i\\n                if p[k] != \\'*\\':\\n                    counter += 1\\n            while i < len(s)-counter and j < len(p):\\n                if s[i] == p[j] or (s[i] != p[j] and p[j] == \\'?\\'):\\n                    if self.check_memorize(s, i, p, j):\\n                        return False\\n                    if self.isMatch_helper(s[i:], p[j:]):\\n                        return True\\n                    else:\\n                        self.update_memorize(s, i, p, j)\\n                i += 1\\n        return False                     # case for s[0] != p[0] and p[0] is not a wildcard:\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s = s + \\'1\\'\\n        p = p + \\'1\\'  # so that the last charecter is not \\'*\\'. Of course there are other ways to deal with it.\\n        return self.isMatch_helper(s, p)\\n\\n\\nclass Solution2:\\n    \\'\\'\\'DP solution, nice solution. First I defined the subproblem so that dp[i][j] are {0, 1, 2, 3...}, this way is somewhat hard, so failed\\n       The right way of defining the subproblem is that dp[i][j] is {True,False}.\\n\\t   Time beat 15%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        dp[0][0] = 1\\n        j = 1\\n        while j-1 < len(p):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = 1\\n            j += 1\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    if dp[i-1][j-1]:              #  precise match\\n                        dp[i][j] = 1\\n                if s[i-1] != p[j-1] and p[j-1] == \\'*\\':\\n                    if dp[i][j-1] or dp[i-1][j]:  # \\'*\\' either {skip} or {matching more charecters}\\n                        dp[i][j] = 1\\n        return dp[m][n]\\n\\n\\nclass Solution3:\\n    \\'\\'\\'Finite state machine (FSM) solution. elegant\\n       reference: https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time\\n\\t   Time beat 77%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # step 1: build a FSM: 1) state 2) transition\\n        state = 0\\n        transition = {}\\n        for char in p:\\n            if char != \\'*\\':\\n                transition[(state, char)] = state + 1\\n                state += 1\\n            else:\\n                transition[(state, char)] = state\\n        final_state = state\\n        # step 2: start running the FSM\\n        states = set([0])\\n        for char in s:\\n            new_states = set()\\n            for state in states:\\n                for token in [char, \\'*\\', \\'?\\']:\\n                    next_state = transition.get((state, token))\\n                    if next_state is not None:\\n                        new_states.add(next_state)\\n            states = new_states\\n        return final_state in states\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    \\'\\'\\'Recursion solution -- with memorization. \\n\\t   Time beat 86%.\\n    \\'\\'\\'\\n    def __init__(self):\\n        self.memorize = []  # memorize the smaller substrings s[i:] and p[j:] that doesn\\'t match\\n\\n    def update_memorize(self, s, i, p, j):\\n        s_no_match_new = len(s) - i  # the last s_no_match charecters of s\\n        p_no_match_new = len(p) - j  # the last p_no_match charecters of p\\n        new_memorize = []\\n        keep_new = True\\n        for s_no_match_old, p_no_match_old in self.memorize:\\n            if s_no_match_old < s_no_match_new or p_no_match_old < p_no_match_new:\\n                new_memorize.append((s_no_match_old, p_no_match_old))\\n            if s_no_match_old < s_no_match_new and p_no_match_old < p_no_match_new:\\n                keep_new = False\\n        if keep_new:\\n            new_memorize.append((s_no_match_new, p_no_match_new))\\n        self.memorize = new_memorize\\n\\n    def check_memorize(self, s, i, p, j):\\n        prune = False\\n        s_sub_len = len(s) - i\\n        p_sub_len = len(p) - j\\n        for s_no_match, p_no_match in self.memorize:\\n            if s_sub_len >= s_no_match and p_sub_len >= p_no_match:\\n                prune = True  # when two smaller substrings of s[i:] and p[j:] don\\'t match, s[i:] and p[j:] is guaranteed not to match, so prune it\\n                break         # the  two smaller substrings here are the last s_no_match charecters of s and the last p_no_match charecters of p\\n        return prune\\n\\n    def isMatch_helper(self, s: str, p: str) -> bool:\\n        if len(s) == 0 and len(p) == 0:  # both match to the end\\n            return True\\n        if len(s) == 0 or len(p) == 0:   # one comes to the end but the other not\\n            return False\\n        if s[0] == p[0] or p[0] == \\'?\\':  # match\\n            return self.isMatch_helper(s[1:], p[1:])\\n        if s[0] != p[0] and p[0] == \\'*\\':\\n            i, j = 0, 0\\n            while j < len(p):            # j points to the first char that is not \\'*\\'\\n                if p[j] != \\'*\\':\\n                    break\\n                j += 1\\n            counter = 0\\n            for k in range(j+1, len(p)): # for pruning the search space for i\\n                if p[k] != \\'*\\':\\n                    counter += 1\\n            while i < len(s)-counter and j < len(p):\\n                if s[i] == p[j] or (s[i] != p[j] and p[j] == \\'?\\'):\\n                    if self.check_memorize(s, i, p, j):\\n                        return False\\n                    if self.isMatch_helper(s[i:], p[j:]):\\n                        return True\\n                    else:\\n                        self.update_memorize(s, i, p, j)\\n                i += 1\\n        return False                     # case for s[0] != p[0] and p[0] is not a wildcard:\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        s = s + \\'1\\'\\n        p = p + \\'1\\'  # so that the last charecter is not \\'*\\'. Of course there are other ways to deal with it.\\n        return self.isMatch_helper(s, p)\\n\\n\\nclass Solution2:\\n    \\'\\'\\'DP solution, nice solution. First I defined the subproblem so that dp[i][j] are {0, 1, 2, 3...}, this way is somewhat hard, so failed\\n       The right way of defining the subproblem is that dp[i][j] is {True,False}.\\n\\t   Time beat 15%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        m, n = len(s), len(p)\\n        dp = [[0 for _ in range(n+1)] for _ in range(m+1)]\\n        dp[0][0] = 1\\n        j = 1\\n        while j-1 < len(p):\\n            if p[j-1] != \\'*\\':\\n                break\\n            dp[0][j] = 1\\n            j += 1\\n        for i in range(1, m+1):\\n            for j in range(1, n+1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    if dp[i-1][j-1]:              #  precise match\\n                        dp[i][j] = 1\\n                if s[i-1] != p[j-1] and p[j-1] == \\'*\\':\\n                    if dp[i][j-1] or dp[i-1][j]:  # \\'*\\' either {skip} or {matching more charecters}\\n                        dp[i][j] = 1\\n        return dp[m][n]\\n\\n\\nclass Solution3:\\n    \\'\\'\\'Finite state machine (FSM) solution. elegant\\n       reference: https://leetcode.com/problems/wildcard-matching/discuss/138878/Finite-state-machine-with-Python-and-dictionary.-13-lines-O(p%2Bs)-time\\n\\t   Time beat 77%.\\n    \\'\\'\\'\\n    def isMatch(self, s: str, p: str) -> bool:\\n        # step 1: build a FSM: 1) state 2) transition\\n        state = 0\\n        transition = {}\\n        for char in p:\\n            if char != \\'*\\':\\n                transition[(state, char)] = state + 1\\n                state += 1\\n            else:\\n                transition[(state, char)] = state\\n        final_state = state\\n        # step 2: start running the FSM\\n        states = set([0])\\n        for char in s:\\n            new_states = set()\\n            for state in states:\\n                for token in [char, \\'*\\', \\'?\\']:\\n                    next_state = transition.get((state, token))\\n                    if next_state is not None:\\n                        new_states.add(next_state)\\n            states = new_states\\n        return final_state in states\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316258,
                "title": "c-greedy-solutiuon-beats-99-51-with-o-1-space-chinese-detailed-comment",
                "content": "```\\n//Greedy Solution 20190621\\nclass Solution\\n{\\npublic:\\n\\tbool isMatch(string s,string p)\\n\\t{\\n\\t\\tint m = s.size();\\n\\t\\tint n = p.size();\\n\\t\\tint i = 0,j=0;\\n\\t\\tint matchI = -1,starJ = -1;\\n\\t\\t//\\u4F7F\\u7528\\u8D2A\\u5A6A\\u7B97\\u6CD5 *\\u5148\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4E0D\\u884C\\u518D\\u5339\\u914D1\\u4E2A\\u5B57\\u7B26\\uFF0C2\\u4E2A\\u5B57\\u7B26...\\n\\t\\twhile(i<m)\\n\\t\\t{\\n\\t\\t\\tif(j<n && p[j]==\\'*\\')\\n\\t\\t\\t{//\\u5982\\u679Cp\\u7684\\u5F53\\u524D\\u5B57\\u7B26\\u662F*,\\u5219*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\n\\t\\t\\t\\tmatchI = i;\\n\\t\\t\\t\\tstarJ = j;\\n\\t\\t\\t\\tj++;//*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0Cj\\u540E\\u79FB\\u4E0E\\u5F53\\u524Di\\u5339\\u914D\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if(j<n &&(p[j] == \\'?\\' || p[j] == s[i]))\\n\\t\\t\\t{//\\u5982\\u679C\\u5F53\\u524D\\u5B57\\u7B26\\u5339\\u914D\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(starJ >-1)\\n\\t\\t\\t{//\\u5982\\u679Cp\\u5F53\\u524D\\u5B57\\u7B26\\u65E2\\u4E0D\\u662F*\\u4E5F\\u4E0D\\u5339\\u914D\\uFF0C\\u5219i j \\u56DE\\u9000\\u5230\\u4E0A\\u4E00\\u6B21\\u5339\\u914D\\u7684\\u4F4D\\u7F6E\\u7684\\u4E0B\\u4E00\\u4F4D\\u7F6E\\n\\t\\t\\t //\\u8FD9\\u91CCmatchI\\u8981+1\\uFF0C\\u8868\\u793A\\u5982\\u679C\\u4E0B\\u6B21\\u518D\\u8FDB\\u5165\\u8BE5\\u5206\\u652F\\u65F6,*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF08\\u4F8B\\u5982\\u5F53\\u524D\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E0D\\u884C\\uFF0C\\u5219\\u540E\\u9762\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E24\\u4E2A\\u5B57\\u7B26\\uFF09\\n\\t\\t\\t\\ti = matchI+1;\\n\\t\\t\\t\\tj = starJ+1;\\n\\t\\t\\t\\tmatchI++;//*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\n\\n\\t\\t\\t}\\n\\t\\t\\telse return false;\\n\\t\\t}\\n\\t\\t//\\u904D\\u5386\\u5269\\u4F59\\u7684p\\u4E2D\\u7684*\\u5B57\\u7B26\\n\\t\\twhile(j<n && p[j] == \\'*\\') j++;\\n\\n\\t\\t//p\\u540E\\u9762\\u5269\\u4F59\\u7684\\u5B57\\u7B26\\u662F\\u5426\\u5168\\u662F*\\n\\t\\treturn j ==n;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Greedy Solution 20190621\\nclass Solution\\n{\\npublic:\\n\\tbool isMatch(string s,string p)\\n\\t{\\n\\t\\tint m = s.size();\\n\\t\\tint n = p.size();\\n\\t\\tint i = 0,j=0;\\n\\t\\tint matchI = -1,starJ = -1;\\n\\t\\t//\\u4F7F\\u7528\\u8D2A\\u5A6A\\u7B97\\u6CD5 *\\u5148\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0C\\u4E0D\\u884C\\u518D\\u5339\\u914D1\\u4E2A\\u5B57\\u7B26\\uFF0C2\\u4E2A\\u5B57\\u7B26...\\n\\t\\twhile(i<m)\\n\\t\\t{\\n\\t\\t\\tif(j<n && p[j]==\\'*\\')\\n\\t\\t\\t{//\\u5982\\u679Cp\\u7684\\u5F53\\u524D\\u5B57\\u7B26\\u662F*,\\u5219*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\n\\t\\t\\t\\tmatchI = i;\\n\\t\\t\\t\\tstarJ = j;\\n\\t\\t\\t\\tj++;//*\\u5339\\u914D0\\u4E2A\\u5B57\\u7B26\\uFF0Cj\\u540E\\u79FB\\u4E0E\\u5F53\\u524Di\\u5339\\u914D\\n\\n\\t\\t\\t}\\n\\t\\t\\telse if(j<n &&(p[j] == \\'?\\' || p[j] == s[i]))\\n\\t\\t\\t{//\\u5982\\u679C\\u5F53\\u524D\\u5B57\\u7B26\\u5339\\u914D\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\telse if(starJ >-1)\\n\\t\\t\\t{//\\u5982\\u679Cp\\u5F53\\u524D\\u5B57\\u7B26\\u65E2\\u4E0D\\u662F*\\u4E5F\\u4E0D\\u5339\\u914D\\uFF0C\\u5219i j \\u56DE\\u9000\\u5230\\u4E0A\\u4E00\\u6B21\\u5339\\u914D\\u7684\\u4F4D\\u7F6E\\u7684\\u4E0B\\u4E00\\u4F4D\\u7F6E\\n\\t\\t\\t //\\u8FD9\\u91CCmatchI\\u8981+1\\uFF0C\\u8868\\u793A\\u5982\\u679C\\u4E0B\\u6B21\\u518D\\u8FDB\\u5165\\u8BE5\\u5206\\u652F\\u65F6,*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\uFF08\\u4F8B\\u5982\\u5F53\\u524D\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\u4E0D\\u884C\\uFF0C\\u5219\\u540E\\u9762\\u5C1D\\u8BD5*\\u5339\\u914D\\u4E24\\u4E2A\\u5B57\\u7B26\\uFF09\\n\\t\\t\\t\\ti = matchI+1;\\n\\t\\t\\t\\tj = starJ+1;\\n\\t\\t\\t\\tmatchI++;//*\\u591A\\u5339\\u914D\\u4E00\\u4E2A\\u5B57\\u7B26\\n\\n\\t\\t\\t}\\n\\t\\t\\telse return false;\\n\\t\\t}\\n\\t\\t//\\u904D\\u5386\\u5269\\u4F59\\u7684p\\u4E2D\\u7684*\\u5B57\\u7B26\\n\\t\\twhile(j<n && p[j] == \\'*\\') j++;\\n\\n\\t\\t//p\\u540E\\u9762\\u5269\\u4F59\\u7684\\u5B57\\u7B26\\u662F\\u5426\\u5168\\u662F*\\n\\t\\treturn j ==n;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231702,
                "title": "java-clean-top-down-w-memo",
                "content": "`O(M*N)`\\n```\\nclass Solution {\\n    Boolean[][] memo;\\n   \\n    public boolean isMatch(String s, String p) {\\n        int M = s.length();\\n        int N = p.length();\\n        memo = new Boolean[M+1][N+1];\\n        return match(s, p, 0, 0);\\n    }\\n    \\n    private boolean match(String s, String p, int i, int j) {\\n        if (memo[i][j] != null) return memo[i][j];\\n        if (j == p.length()) {\\n            memo[i][j] = i == s.length();\\n            return memo[i][j];\\n        }\\n        \\n        char c = p.charAt(j);\\n        if (c == \\'*\\') {\\n            boolean skipStar = match(s, p, i, j+1);\\n            boolean useStar = i < s.length() && match(s, p, i+1, j);\\n            memo[i][j] = skipStar || useStar;\\n        } else if (c == \\'?\\') {\\n            memo[i][j] = i < s.length() && match(s, p, i+1, j+1);\\n        } else {\\n            memo[i][j] = i < s.length() && (s.charAt(i) == c) && match(s, p, i+1, j+1);\\n        }\\n        \\n        return memo[i][j];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Boolean[][] memo;\\n   \\n    public boolean isMatch(String s, String p) {\\n        int M = s.length();\\n        int N = p.length();\\n        memo = new Boolean[M+1][N+1];\\n        return match(s, p, 0, 0);\\n    }\\n    \\n    private boolean match(String s, String p, int i, int j) {\\n        if (memo[i][j] != null) return memo[i][j];\\n        if (j == p.length()) {\\n            memo[i][j] = i == s.length();\\n            return memo[i][j];\\n        }\\n        \\n        char c = p.charAt(j);\\n        if (c == \\'*\\') {\\n            boolean skipStar = match(s, p, i, j+1);\\n            boolean useStar = i < s.length() && match(s, p, i+1, j);\\n            memo[i][j] = skipStar || useStar;\\n        } else if (c == \\'?\\') {\\n            memo[i][j] = i < s.length() && match(s, p, i+1, j+1);\\n        } else {\\n            memo[i][j] = i < s.length() && (s.charAt(i) == c) && match(s, p, i+1, j+1);\\n        }\\n        \\n        return memo[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 209623,
                "title": "python-solutions-brute-force-bottom-up-top-down-backward-and-forward",
                "content": "##### Recurrence\\n```\\nT[i][j] = T[i-1][j-1] if s[i] == p[j] or p[j] == \\'?\\'\\nT[i][j] = T[i-1][j] || T[i][j-1] if p[j] == \\'*\\'\\nT[i][j] = False\\n```\\n##### Naive Recursive(Brute Force TLE)\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        if not p:\\n            return not s \\n        if not s:\\n            return p.count(\\'*\\') == len(p) \\n        if s[-1] == p[-1] or p[-1] == \\'?\\':\\n            return self.isMatch(s[:-1], p[:-1])\\n        if p[-1] == \\'*\\':\\n            return self.isMatch(s[:-1], p) or self.isMatch(s, p[:-1]) \\n        \\n        return False\\n```\\n\\n##### Bottom Up\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True       \\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\' and dp[0][j-1]:\\n                dp[0][j] = True\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]      \\n```\\n\\n##### Top Down\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(i, j):\\n            if (i, j) in memo: return memo[i, j]\\n            if j == len(p): return i == len(s) \\n            if i == len(s): return p[j:].count(\\'*\\') == j\\n            \\n            memo[i, j] = False\\n            if s[i] == p[j] or p[j] == \\'?\\':\\n                memo[i, j] = dfs(i+1, j+1)\\n            elif p[j] == \\'*\\':    \\n                memo[i, j] = dfs(i, j+1) or dfs(i+1, j)\\n            return memo[i, j]    \\n        return dfs(0, 0)\\n```\\n##### Another Top Down (Backwards)\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(l, r):\\n            if (l, r) in memo: return memo[l, r]\\n            if not r: return not l  \\n            if not l: return p[:r].count(\\'*\\') == r \\n            \\n            memo[l, r] = False\\n            if p[r-1] == \\'*\\':\\n                memo[l, r] = dfs(l-1, r) or dfs(l, r-1)    \\n            elif s[l-1] == p[r-1] or p[r-1] == \\'?\\':\\n                memo[l, r] = dfs(l-1, r-1)\\n            return memo[l, r] \\n        return dfs(len(s), len(p))\\n```\\n\\n##### Linear Time\\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        si, pi = 0, 0\\n        last_si, last_pi = None, None\\n\\n        while si < len(s):\\n            if pi < len(p) and (s[si] == p[pi] or p[pi] == \\'?\\'):\\n                si += 1\\n                pi += 1\\n            elif pi < len(p) and p[pi] == \\'*\\':\\n                last_si = si + 1\\n                last_pi = pi + 1\\n                pi += 1\\n            elif last_pi:\\n                pi = last_pi\\n                si = last_si\\n                last_si += 1\\n            else:\\n                return False\\n\\n        return p[pi:].count(\\'*\\') == len(p) - pi\\n```",
                "solutionTags": [],
                "code": "```\\nT[i][j] = T[i-1][j-1] if s[i] == p[j] or p[j] == \\'?\\'\\nT[i][j] = T[i-1][j] || T[i][j-1] if p[j] == \\'*\\'\\nT[i][j] = False\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        if not p:\\n            return not s \\n        if not s:\\n            return p.count(\\'*\\') == len(p) \\n        if s[-1] == p[-1] or p[-1] == \\'?\\':\\n            return self.isMatch(s[:-1], p[:-1])\\n        if p[-1] == \\'*\\':\\n            return self.isMatch(s[:-1], p) or self.isMatch(s, p[:-1]) \\n        \\n        return False\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        dp = [[False] * (n+1) for _ in range(m+1)]\\n        dp[0][0] = True       \\n        for j in range(1, n+1):\\n            if p[j-1] == \\'*\\' and dp[0][j-1]:\\n                dp[0][j] = True\\n\\n        for i in range(1, m + 1):\\n            for j in range(1, n + 1):\\n                if s[i-1] == p[j-1] or p[j-1] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j-1] == \\'*\\':\\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]      \\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(i, j):\\n            if (i, j) in memo: return memo[i, j]\\n            if j == len(p): return i == len(s) \\n            if i == len(s): return p[j:].count(\\'*\\') == j\\n            \\n            memo[i, j] = False\\n            if s[i] == p[j] or p[j] == \\'?\\':\\n                memo[i, j] = dfs(i+1, j+1)\\n            elif p[j] == \\'*\\':    \\n                memo[i, j] = dfs(i, j+1) or dfs(i+1, j)\\n            return memo[i, j]    \\n        return dfs(0, 0)\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        memo = {} \\n        def dfs(l, r):\\n            if (l, r) in memo: return memo[l, r]\\n            if not r: return not l  \\n            if not l: return p[:r].count(\\'*\\') == r \\n            \\n            memo[l, r] = False\\n            if p[r-1] == \\'*\\':\\n                memo[l, r] = dfs(l-1, r) or dfs(l, r-1)    \\n            elif s[l-1] == p[r-1] or p[r-1] == \\'?\\':\\n                memo[l, r] = dfs(l-1, r-1)\\n            return memo[l, r] \\n        return dfs(len(s), len(p))\\n```\n```\\nclass Solution:\\n    def isMatch(self, s, p):\\n        si, pi = 0, 0\\n        last_si, last_pi = None, None\\n\\n        while si < len(s):\\n            if pi < len(p) and (s[si] == p[pi] or p[pi] == \\'?\\'):\\n                si += 1\\n                pi += 1\\n            elif pi < len(p) and p[pi] == \\'*\\':\\n                last_si = si + 1\\n                last_pi = pi + 1\\n                pi += 1\\n            elif last_pi:\\n                pi = last_pi\\n                si = last_si\\n                last_si += 1\\n            else:\\n                return False\\n\\n        return p[pi:].count(\\'*\\') == len(p) - pi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198794,
                "title": "dp-ruby-and-compiled-explanation-with-example-from-leetcode-forum",
                "content": "```ruby\\n# @param {String} s\\n# @param {String} p\\n# @return {Boolean}\\ndef is_match(s, p)\\n    m, n = s.length, p.length\\n    dp = Array.new(m + 1) { Array.new(n + 1, false) }\\n    dp[0][0] = true\\n\\n    1.upto(n) do |j|\\n        dp[0][j] = dp[0][j - 1] if p[j - 1] == \\'*\\'\\n    end\\n\\n    1.upto(m) do |i|\\n        1.upto(n) do |j|\\n            dp[i][j] = dp[i - 1][j - 1] if p[j - 1] == s[i - 1] || p[j - 1] == \\'?\\'\\n            dp[i][j] = dp[i - 1][j] || dp[i][j - 1] if p[j - 1] == \\'*\\'\\n        end\\n    end\\n\\n    dp[m][n]\\nend\\n\\n# 44. Wildcard Matching\\n# https://leetcode.com/problems/wildcard-matching/\\n\\n# 1. dp[i][j]: represents a match between s[0 to i - 1] (len i) and p[0 to j - 1] (len j)\\n# 2. Base case:\\n#     - origin: dp[0][0]: they do match, so dp[0][0] = true\\n#     - first row: dp[0][j]: except for String p starts with *, otherwise all false\\n#     - first col: dp[i][0]: can\\'t match when p is empty. All false.\\n# 3. Recursion:\\n#     - Iterate through every dp[i][j]\\n#     - dp[i][j] = true:\\n#         - if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1] == true\\n#         - elif p[j - 1] == \\'*\\' && (dp[i-1][j] == true || dp[i][j-1] == true)\\n\\n# dp[i-1][j] represents the match between s[0 to i - 2] (len i - 1) and p[0 to j - 1] (len j) [1 less char in s]\\n# dp[i][j-1] represents the match between s[0 to i - 1] (len i) and p[0 to j - 2] (len j - 1) [1 less char in p]\\n\\n# Example:\\n# S: xxx\\n# P: xx*\\n#   \\'\\' x x *\\n# \\'\\' T F F F\\n#  x F T F F\\n#  x F F T T\\n#  x F F F T\\n\\n# For i=3, j=3: s[i] is x, p[i] is *\\n# dp[3][3] = dp[2][3] || dp[3][2]\\n# dp[2][3] means we use the match from s: xx and p: xx* (notice 1 less char in s)\\n# dp[3][2] means we use the match from s: xxx and p: xx (notice 1 less char in p)\\n# dp[2][3] is true hence this ends up being a match\\n\\n# Time: O(m * n)\\n# Space: O(m * n)\\n\\nrequire \\'test/unit\\'\\nextend Test::Unit::Assertions\\n\\nassert_equal(is_match(\\'aa\\', \\'a\\'), false)\\nassert_equal(is_match(\\'ab\\', \\'*\\'), true)\\nassert_equal(is_match(\\'abcd\\', \\'*\\'), true)\\nassert_equal(is_match(\\'adceb\\', \\'*a*b\\'), true)\\nassert_equal(is_match(\\'acdcb\\', \\'a*c?b\\'), false)\\nassert_equal(is_match(\\'xb\\', \\'xa*\\'), false)\\nassert_equal(is_match(\\'xa\\', \\'xa*\\'), true)\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {String} s\\n# @param {String} p\\n# @return {Boolean}\\ndef is_match(s, p)\\n    m, n = s.length, p.length\\n    dp = Array.new(m + 1) { Array.new(n + 1, false) }\\n    dp[0][0] = true\\n\\n    1.upto(n) do |j|\\n        dp[0][j] = dp[0][j - 1] if p[j - 1] == \\'*\\'\\n    end\\n\\n    1.upto(m) do |i|\\n        1.upto(n) do |j|\\n            dp[i][j] = dp[i - 1][j - 1] if p[j - 1] == s[i - 1] || p[j - 1] == \\'?\\'\\n            dp[i][j] = dp[i - 1][j] || dp[i][j - 1] if p[j - 1] == \\'*\\'\\n        end\\n    end\\n\\n    dp[m][n]\\nend\\n\\n# 44. Wildcard Matching\\n# https://leetcode.com/problems/wildcard-matching/\\n\\n# 1. dp[i][j]: represents a match between s[0 to i - 1] (len i) and p[0 to j - 1] (len j)\\n# 2. Base case:\\n#     - origin: dp[0][0]: they do match, so dp[0][0] = true\\n#     - first row: dp[0][j]: except for String p starts with *, otherwise all false\\n#     - first col: dp[i][0]: can\\'t match when p is empty. All false.\\n# 3. Recursion:\\n#     - Iterate through every dp[i][j]\\n#     - dp[i][j] = true:\\n#         - if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') && dp[i - 1][j - 1] == true\\n#         - elif p[j - 1] == \\'*\\' && (dp[i-1][j] == true || dp[i][j-1] == true)\\n\\n# dp[i-1][j] represents the match between s[0 to i - 2] (len i - 1) and p[0 to j - 1] (len j) [1 less char in s]\\n# dp[i][j-1] represents the match between s[0 to i - 1] (len i) and p[0 to j - 2] (len j - 1) [1 less char in p]\\n\\n# Example:\\n# S: xxx\\n# P: xx*\\n#   \\'\\' x x *\\n# \\'\\' T F F F\\n#  x F T F F\\n#  x F F T T\\n#  x F F F T\\n\\n# For i=3, j=3: s[i] is x, p[i] is *\\n# dp[3][3] = dp[2][3] || dp[3][2]\\n# dp[2][3] means we use the match from s: xx and p: xx* (notice 1 less char in s)\\n# dp[3][2] means we use the match from s: xxx and p: xx (notice 1 less char in p)\\n# dp[2][3] is true hence this ends up being a match\\n\\n# Time: O(m * n)\\n# Space: O(m * n)\\n\\nrequire \\'test/unit\\'\\nextend Test::Unit::Assertions\\n\\nassert_equal(is_match(\\'aa\\', \\'a\\'), false)\\nassert_equal(is_match(\\'ab\\', \\'*\\'), true)\\nassert_equal(is_match(\\'abcd\\', \\'*\\'), true)\\nassert_equal(is_match(\\'adceb\\', \\'*a*b\\'), true)\\nassert_equal(is_match(\\'acdcb\\', \\'a*c?b\\'), false)\\nassert_equal(is_match(\\'xb\\', \\'xa*\\'), false)\\nassert_equal(is_match(\\'xa\\', \\'xa*\\'), true)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 186283,
                "title": "o-mn-simple-dp-python-with-explanation",
                "content": "Almost same problem is 10 Regular Expression Matching. \\nIdea: Each entry in the dp table represents if the pattern (p) up to j matches the string (s) up to i. \\nInitialize with an extra e in front to represent the empty string. \\n\\t1. if p empty, then everything except s == \"\" doesn\\'t work so leave False\\n\\t2. if s empty, then p == \"\" so only empty string and \\'\\'s work\\nMain body:\\n\\t1. if s[i] == p[j] or the \\'?\\', then the current character is equal to the boolean in the diagonal top left. Why? its like ur peeling the outer char\\n\\t\\t\\tEx. s = \\'ab\\' p = \\'ab\\'. Then when i and j are 1 and have same char, it is only true if \\n\\t\\t\\t       s= \\'a\\' and p = \\'a\\'. Only true if previous string and pattern matched\\n 2. if p[j] == \\'\\', Then you can do OR of diagonal, left or top.\\n     - left handles when u add one more char for the * to hold\\n\\t\\t - diagonal is same as before\\n\\t\\t - top because * can be empty string and maybe it isn\\'t even counted\\n```\\ndef isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s,p = \\'e\\' + s, \\'e\\' + p    # e is for empty string\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False] * m for _ in range(n)]\\n        dp[0][0] = True\\n        \\n        # initialize the first row.\\n        for j in range(1, m):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-1] \\n                \\n        # First column is already all False \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if s[i] == p[j] or p[j] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j-1] or dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]\\n\\t\\t\\t\\t````",
                "solutionTags": [],
                "code": "```\\ndef isMatch(self, s, p):\\n        \"\"\"\\n        :type s: str\\n        :type p: str\\n        :rtype: bool\\n        \"\"\"\\n        s,p = \\'e\\' + s, \\'e\\' + p    # e is for empty string\\n        n = len(s)\\n        m = len(p)\\n        dp = [[False] * m for _ in range(n)]\\n        dp[0][0] = True\\n        \\n        # initialize the first row.\\n        for j in range(1, m):\\n            if p[j] == \\'*\\':\\n                dp[0][j] = dp[0][j-1] \\n                \\n        # First column is already all False \\n        \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if s[i] == p[j] or p[j] == \\'?\\':\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[j] == \\'*\\':\\n                    dp[i][j] = dp[i-1][j-1] or dp[i][j-1] or dp[i-1][j]\\n        return dp[-1][-1]\\n\\t\\t\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 149826,
                "title": "why-you-don-t-need-to-backtrack-to-an-earlier-asterisk-if-you-find-a-later-asterisk",
                "content": "```\\nclass Solution {\\npublic:\\n    bool matchForward(string& s, string& p, int s_i, int p_i, int& star) {\\n        while(s_i < s.size() && p_i < p.size() && (s[s_i] == p[p_i] || p[p_i] == \\'?\\'))\\n            s_i++, p_i++;\\n        if(p_i >= p.size() && s_i >= s.size())\\n            return true;\\n        if(p_i < p.size() && p[p_i] == \\'*\\') {\\n            star = p_i;\\n            while(s_i <= s.size()) {\\n                if(matchForward(s, p, s_i, p_i+1, star))\\n                    return true;\\n                if(star > p_i)\\n                    return false;\\n                s_i++;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isMatch(string s, string p) {\\n        if(p.empty()) {\\n            if(s.empty())\\n                return true;\\n            else\\n                return false;\\n        }\\n        int star = -1;\\n        return matchForward(s, p, 0, 0, star);\\n    }\\n};\\n```\\n\\nYou can solve wildcard matching iteratively or recursively. They\\'re basically the same, but how you visualize the problem MIGHT be a little different. The solution above uses recursion and backtracks to the furthest found asterisk * character.\\n\\nObjective:\\nBasically, you have two strings. You have string s, which is any possible string, and you also have string p, which based on the rules of wildcard matching, may match with string s. This is the objective of the problem, using the rules of wildcard matching, does your \"pattern string\" p match with the string s.\\n\\nHow the solution works:\\nFor this particular solution, you want to match characters in string p with the characters in string s. You iterate through both strings, starting from the first position of both strings, and match the characters one by one. When the characters match, you look at the next characters of both p and s and see if they match. The \\'?\\' in string p will match with any character in s, you can basically treat it as if characters in p and s match. If you find two characters that don\\'t match, then basically the two strings don\\'t match. So you would immediately return false. If you find that all the previous characters matched, and you have no more characters of p or s to match, then that means p matches with s.\\n\\nBut there is the special case where you may come across an asterisk, or the * character. This could stand for any number of characters in s while only standing for a single character in p (the asterisk). So how do you handle this case? Say you come across an asterisk in p. Record the current positions of s and p, in case you have to go back. To start, basically start with matching the asterisk in p to none of the characters in s, in other words, just skip the asterisk, and continue matching the characters of s and p. If you find a character of p, and it doesn\\'t match with s, then go back to those previously recorded positions, and now match one more character of s to the asterisk in p than you did before (so the recorded position of s is now one position further than it was before), and test if the remaining characters of s, and the characters in p after the asterisk match. Again, if we find that there\\'s a single character in p that doesn\\'t match with s later in the algorithm, then we go back to the position of the asterisk and match one more character in s than we did previously. We keep doing this until either all subsequent characters in p match with s (if they all match, return true), or we run out of characters in s to match with the rest of the characters in p. We may possibly match all the characters in p to s, and not have enough characters in p left to cover the rest of s, but if p has just one asterisk, this doesn\\'t happen since we will end up eventually matching all the remaining characters of s with the asterisk in p, and if there are any remaining characters in p, then we know that p cannot match with s.\\n\\n**But, here\\'s the tricky part.** What if there\\'s more than one asterisk in p? If we come to another asterisk in p, and we find that the matching fails, do we need to go all the way back to the previous asterisk and try again? How about if there are multiple asterisks? Do we need to keep trying every previous asterisk?\\n\\nWell, the trick is, you only need to worry about the latest asterisk that you encounter. If you find that p does not match with s using the latest asterisk, then there\\'s no need to check the previous ones. This is simply because the latest asterisk we found can match any number of characters in s, and we only need to worry about matching the remaining characters in p *after* the latest asterisk we have just found. There\\'s no way using a previous asterisk in p to match more characters in s is going to help, because that decreases the number of characters in s available that p can match with, it\\'s better to match more characters of p and use the last asterisk we find, because then we only need to worry about a fewer number of characters in p that we need to match with s. **If you backtrack to all previous asterisk characters of p, then you will get TLE because by backtracking to previous asterisks, the complexity tends to be more polynomial in the number of asterisk.**\\n\\nThis solution is O(nxm) where n is the size of s and m is the size of p. To understand why, we need to imagine a string s and string p that makes our algorithm run in the longest possible way. That would basically be having a single asterisk in the beginning of p, and having the pattern after the asterisk in p *almost* match with s. That could be as follows:\\n\\ns = qqqqqqqqqqq\\np = *qqqm\\n\\nThis is going to be O(nxm) because, that asterisk in the beginning of string p is going to be matched with all the characters of s, eventually. That asterisk will first stand for no characters, and we will iterate through all characters of p (matching them with characters of s) until we see the \\'m\\' character, which will cause the algorithm to come all the way back to the asterisk (because \\'m\\' cannot match with any character in string s, and it\\'s at the very end of string p). When we come back to the asterisk, the algorithm will match one of the \\'q\\' characters in s, and again try to match the remaining characters of s and p. Then we will again match all the characters in p to s until we get to the \\'m\\' character again, then have to go all the way back again to the asterisk and match two of the \\'q\\' in s with the asterisk in p. So we iterate through all the characters of p every time we match another \\'q\\' in s with the asterisk in p. So, for every character in s, we iterate through all the characters of p, and this works out to O(nxm).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool matchForward(string& s, string& p, int s_i, int p_i, int& star) {\\n        while(s_i < s.size() && p_i < p.size() && (s[s_i] == p[p_i] || p[p_i] == \\'?\\'))\\n            s_i++, p_i++;\\n        if(p_i >= p.size() && s_i >= s.size())\\n            return true;\\n        if(p_i < p.size() && p[p_i] == \\'*\\') {\\n            star = p_i;\\n            while(s_i <= s.size()) {\\n                if(matchForward(s, p, s_i, p_i+1, star))\\n                    return true;\\n                if(star > p_i)\\n                    return false;\\n                s_i++;\\n            }\\n        }\\n        return false;\\n    }\\n    bool isMatch(string s, string p) {\\n        if(p.empty()) {\\n            if(s.empty())\\n                return true;\\n            else\\n                return false;\\n        }\\n        int star = -1;\\n        return matchForward(s, p, 0, 0, star);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 145515,
                "title": "python-backtracking-beat-100",
                "content": "```\\ndef isMatch(s,p):\\n    i,j,s_star,p_star = 0,0,0,-1\\n    while i<len(s):\\n        if j<len(p) and (s[i]==p[j] or p[j]==\\'?\\'):\\n            i,j = i+1,j+1\\n        elif j<len(p) and p[j]==\\'*\\':\\n            s_star,p_star = i,j\\n            j+=1\\n        elif p_star!=-1:\\n            s_star +=1\\n            i,j = s_star,p_star+1\\n        else:\\n            return False\\n    \\n    \\n    while j<len(p) and p[j]==\\'*\\':\\n        j+=1\\n    return True if j==len(p) else False\\n\\n```\\ncredit to http://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html",
                "solutionTags": [],
                "code": "```\\ndef isMatch(s,p):\\n    i,j,s_star,p_star = 0,0,0,-1\\n    while i<len(s):\\n        if j<len(p) and (s[i]==p[j] or p[j]==\\'?\\'):\\n            i,j = i+1,j+1\\n        elif j<len(p) and p[j]==\\'*\\':\\n            s_star,p_star = i,j\\n            j+=1\\n        elif p_star!=-1:\\n            s_star +=1\\n            i,j = s_star,p_star+1\\n        else:\\n            return False\\n    \\n    \\n    while j<len(p) and p[j]==\\'*\\':\\n        j+=1\\n    return True if j==len(p) else False\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 17838,
                "title": "from-normal-dp-solution-to-an-optimised-and-then-the-best-in-c",
                "content": "    //AC - 112ms - a typical DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        sLen++, pLen++;\\n        bool **match = (bool**)malloc(sizeof(bool*)*sLen);\\n        for(int i = 0; i < sLen; i++)\\n            match[i] = (bool*)malloc(sizeof(bool)*pLen);\\n        match[sLen-1][pLen-1] = true;\\n        for(int i = pLen-2; i > -1; i--)\\n            if(p[i] != '*')\\n                break;\\n            else\\n                match[sLen-1][i] = true;\\n        for(int i = sLen-2; i > -1; i--)\\n            for(int j = pLen-2; j > -1; j--)\\n            {\\n                if(s[i]==p[j] || p[j]=='?')\\n                    match[i][j] = match[i+1][j+1];\\n                else if(p[j] == '*')\\n                    match[i][j] = match[i+1][j] || match[i][j+1];\\n                else\\n                    match[i][j] = false;\\n            }\\n        return **match; \\n    }\\n\\n\\n----------\\n\\nAn optimised DP\\n\\n\\n----------\\n\\n    //AC - 28ms - DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        int count = 0;\\n        for(int i = 0; i < pLen; i++)\\n            if(p[i] == '*') count++;\\n        if((count==0 && pLen!=sLen) || (pLen-count>sLen)) return false;\\n        bool *match = (bool*)malloc(sizeof(bool)*(sLen+1));\\n        memset(match, 0, sizeof(bool)*(sLen+1));\\n        match[0] = true;\\n        for(int i = 0; i < pLen; i++)\\n        {\\n            if(p[i] == '*')\\n            {\\n                for(int j = 1; j <= sLen; j++)\\n                    match[j] = match[j-1] || match[j];\\n            }\\n            else\\n            {\\n                for(int j = sLen; j > 0; j--)\\n                    match[j] = (p[i] == '?' || p[i] == s[j-1]) && match[j-1];\\n                match[0] = false;\\n            }\\n        }\\n        return match[sLen];\\n    }\\n\\n\\n----------\\n\\n> The BEST\\n\\n\\n----------\\n\\n    bool isMatch(char* s, char* p)\\n    {\\n        const char *pA = NULL, *sA = NULL;\\n        while(*s)\\n        {\\n            if(*p=='?' || *s==*p){p++, s++; continue;}\\n            if(*p=='*'){pA=p++, sA=s; continue;}\\n            if(pA){p=pA+1, s=++sA; continue;}\\n            return false;\\n        }\\n        while(*p=='*') p++;\\n        return !*p;\\n    }",
                "solutionTags": [],
                "code": "    //AC - 112ms - a typical DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        sLen++, pLen++;\\n        bool **match = (bool**)malloc(sizeof(bool*)*sLen);\\n        for(int i = 0; i < sLen; i++)\\n            match[i] = (bool*)malloc(sizeof(bool)*pLen);\\n        match[sLen-1][pLen-1] = true;\\n        for(int i = pLen-2; i > -1; i--)\\n            if(p[i] != '*')\\n                break;\\n            else\\n                match[sLen-1][i] = true;\\n        for(int i = sLen-2; i > -1; i--)\\n            for(int j = pLen-2; j > -1; j--)\\n            {\\n                if(s[i]==p[j] || p[j]=='?')\\n                    match[i][j] = match[i+1][j+1];\\n                else if(p[j] == '*')\\n                    match[i][j] = match[i+1][j] || match[i][j+1];\\n                else\\n                    match[i][j] = false;\\n            }\\n        return **match; \\n    }\\n\\n\\n----------\\n\\nAn optimised DP\\n\\n\\n----------\\n\\n    //AC - 28ms - DP solution;\\n    bool isMatch(char* s, char* p)\\n    {\\n        int sLen=strlen(s), pLen=strlen(p);\\n        int count = 0;\\n        for(int i = 0; i < pLen; i++)\\n            if(p[i] == '*') count++;\\n        if((count==0 && pLen!=sLen) || (pLen-count>sLen)) return false;\\n        bool *match = (bool*)malloc(sizeof(bool)*(sLen+1));\\n        memset(match, 0, sizeof(bool)*(sLen+1));\\n        match[0] = true;\\n        for(int i = 0; i < pLen; i++)\\n        {\\n            if(p[i] == '*')\\n            {\\n                for(int j = 1; j <= sLen; j++)\\n                    match[j] = match[j-1] || match[j];\\n            }\\n            else\\n            {\\n                for(int j = sLen; j > 0; j--)\\n                    match[j] = (p[i] == '?' || p[i] == s[j-1]) && match[j-1];\\n                match[0] = false;\\n            }\\n        }\\n        return match[sLen];\\n    }\\n\\n\\n----------\\n\\n> The BEST\\n\\n\\n----------\\n\\n    bool isMatch(char* s, char* p)\\n    {\\n        const char *pA = NULL, *sA = NULL;\\n        while(*s)\\n        {\\n            if(*p=='?' || *s==*p){p++, s++; continue;}\\n            if(*p=='*'){pA=p++, sA=s; continue;}\\n            if(pA){p=pA+1, s=++sA; continue;}\\n            return false;\\n        }\\n        while(*p=='*') p++;\\n        return !*p;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 17897,
                "title": "14-line-python-solution-beats-78-82",
                "content": "    def isMatch(self, s, p):\\n        i, j, star_match_pos, last_star_pos, len_s, len_p = 0, 0, 0, -1, len(s), len(p)\\n        while i < len_s:\\n            if j < len_p and p[j] in (s[i], '?'):\\n                i, j = i + 1, j + 1\\n            # when meet a '*', first assume it will match 0 character in s\\n            elif j < len_p and p[j] == '*':\\n                star_match_pos, last_star_pos = i, j\\n                j += 1\\n            # now p[j] is not ?, not *, can't match s[i], we can only use the last '*'\\n            elif last_star_pos > -1:\\n                i, star_match_pos = star_match_pos + 1, star_match_pos + 1\\n                j = last_star_pos + 1\\n            else:\\n                return False\\n        while j < len_p and p[j] == '*': j += 1\\n        return j == len_p",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def isMatch(self, s, p):\\n        i, j, star_match_pos, last_star_pos, len_s, len_p = 0, 0, 0, -1, len(s), len(p)\\n        while i < len_s:\\n            if j < len_p and p[j] in (s[i], '?'):\\n                i, j = i + 1, j + 1\\n            # when meet a '*', first assume it will match 0 character in s\\n            elif j < len_p and p[j] == '*':\\n                star_match_pos, last_star_pos = i, j\\n                j += 1\\n            # now p[j] is not ?, not *, can't match s[i], we can only use the last '*'\\n            elif last_star_pos > -1:\\n                i, star_match_pos = star_match_pos + 1, star_match_pos + 1\\n                j = last_star_pos + 1\\n            else:\\n                return False\\n        while j < len_p and p[j] == '*': j += 1\\n        return j == len_p",
                "codeTag": "Python3"
            },
            {
                "id": 17917,
                "title": "python-dp-solution-avoid-tle-o-m-n-time-o-n-space",
                "content": "    class Solution(object):\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        if n - p.count('*') > m:   #avoid TLE\\n            return False\\n        dp = [False] * (n + 1)\\n        for i in xrange(m + 1):\\n            pre, dp[0] = dp[0], i == 0\\n            for j in xrange(1, n + 1):\\n                temp = dp[j]\\n                if p[j-1] == '*':\\n                    dp[j] = pre or dp[j-1] or dp[j]\\n                else:\\n                    dp[j] = pre and (p[j-1] in [s[i-1], '?'] ) \\n                pre = temp\\n        return dp[-1]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n    def isMatch(self, s, p):\\n        m, n = len(s), len(p)\\n        if n - p.count('*') > m:   #avoid TLE\\n            return False\\n        dp = [False] * (n + 1)\\n        for i in xrange(m + 1):\\n            pre, dp[0] = dp[0], i == 0\\n            for j in xrange(1, n + 1):\\n                temp = dp[j]\\n                if p[j-1] == '*':\\n                    dp[j] = pre or dp[j-1] or dp[j]\\n                else:\\n                    dp[j] = pre and (p[j-1] in [s[i-1], '?'] ) \\n                pre = temp\\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 17916,
                "title": "java-dfa-solution-with-better-structure-and-easy-understand",
                "content": "    public boolean isMatch(String s, String p) {return matchHere(s,p,0,0);\\n    }\\n\\n    private boolean matchHere(String s, String p, int indexS, int indexP){\\n        if(indexS>=s.length()){\\n            return isPatternTailingMatch(p,indexP);\\n        }\\n        if(indexP>=p.length()){\\n            return isPatternEndWithWildCard(p);\\n        }\\n        if(s.charAt(indexS)==p.charAt(indexP)||p.charAt(indexP)=='?'){\\n            return matchHere(s,p,indexS+1,indexP+1);\\n        }\\n        else if(p.charAt(indexP)=='*'){\\n            return matchWildCard(s,p,++indexS,indexP+1);\\n        }\\n        return false;\\n    }\\n    private boolean isPatternTailingMatch(String p, int indexP){\\n        for(int index=indexP; index<p.length();index++){\\n            if(p.charAt(index)!='*'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPatternEndWithWildCard(String p){\\n        return p.endsWith(\"*\");\\n    }\\n    private boolean matchWildCard(String s, String p, int indexS, int indexP){\\n        for(int index=indexS;index<s.length();index++){\\n            if(matchHere(s,p,index,indexP)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public boolean isMatch(String s, String p) {return matchHere(s,p,0,0);\\n    }\\n\\n    private boolean matchHere(String s, String p, int indexS, int indexP){\\n        if(indexS>=s.length()){\\n            return isPatternTailingMatch(p,indexP);\\n        }\\n        if(indexP>=p.length()){\\n            return isPatternEndWithWildCard(p);\\n        }\\n        if(s.charAt(indexS)==p.charAt(indexP)||p.charAt(indexP)=='?'){\\n            return matchHere(s,p,indexS+1,indexP+1);\\n        }\\n        else if(p.charAt(indexP)=='*'){\\n            return matchWildCard(s,p,++indexS,indexP+1);\\n        }\\n        return false;\\n    }\\n    private boolean isPatternTailingMatch(String p, int indexP){\\n        for(int index=indexP; index<p.length();index++){\\n            if(p.charAt(index)!='*'){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPatternEndWithWildCard(String p){\\n        return p.endsWith(\"*\");\\n    }\\n    private boolean matchWildCard(String s, String p, int indexS, int indexP){\\n        for(int index=indexS;index<s.length();index++){\\n            if(matchHere(s,p,index,indexP)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3827509,
                "title": "0-n-space-solution-with-all-solutions",
                "content": "# **PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION**\\n\\n# Approach\\nsolvetab Function: This function uses the tabulation technique to find if the string s matches the wildcard pattern p. It initializes two vectors, prev and curr, of size p.length() + 1. These vectors are used to represent the DP table.\\n\\nBase Case Initialization: It sets prev[0] to true, representing an empty string matching an empty pattern.\\n\\nHandling the \\'\\' Characters at the Start of Pattern: It checks if the pattern starts with multiple \\'\\' characters. For each character in p from 1 to p.length(), it sets prev[j] to true if the pattern contains only \\'*\\' characters from the start.\\n\\nFilling DP Table: It iterates through each character in s and each character in p, starting from 1 to s.length() and 1 to p.length(). For each character, it checks two conditions:\\n\\nIf the characters are the same or if the pattern has a \\'?\\', it propagates the result from the previous diagonal position (prev[j-1]) to the current position (curr[j]).\\nIf the pattern has a \\'\\', it propagates the result from the previous row (prev[j]) or the previous column (curr[j-1]) to the current position (curr[j]), indicating that the \\'\\' can match either a single character in s or a sequence of characters.\\nFinal Result: After filling the DP table, the function returns the value at prev[p.length()], which indicates if the entire string s matches the entire wildcard pattern p.\\n\\nisMatch Function: This function serves as an interface to call the solvetab function. It takes the input strings s and p and calls solvetab(s, p) to find if s matches p\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n```\\n\\n# **TABULATION**\\n\\n# Approach\\nsolvetab Function: This function uses a tabulation (bottom-up) dynamic programming approach to find if s matches the wildcard pattern p. It initializes a 2D DP table dp of size (s.length() + 1) x (p.length() + 1) with all elements initialized to 0.\\n\\nBase Cases: It sets dp[0][0] to true, as an empty string matches an empty pattern. Then, it handles the case where the pattern starts with multiple \\'\\' characters. For each character in p from 1 to p.length(), it sets dp[0][j] to true if the pattern contains only \\'\\' characters from the start.\\n\\nFilling DP Table: It iterates through each character in s and each character in p, starting from 1 to s.length() and 1 to p.length(). For each character, it checks three conditions:\\n\\nIf the characters are the same or if the pattern has a \\'?\\', it propagates the result from the previous position (dp[i-1][j-1]) to the current position (dp[i][j]).\\nIf the pattern has a \\'\\', it propagates the result from the previous row (dp[i-1][j]) or the previous column (dp[i][j-1]) to the current position (dp[i][j]), indicating that the \\'\\' can match either a single character or a sequence of characters.\\nIf none of the above conditions match, it sets dp[i][j] to false, as the characters do not match.\\nFinal Result: After filling the DP table, the function returns the value at dp[s.length()][p.length()], which indicates if the entire string s matches the entire wildcard pattern p.\\n\\nisMatch Function: This function serves as an interface to call the solvetab function. It takes the input strings s and p and calls solvetab(s, p) to find if s matches p.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n\\nbool solvetab(string s, string p)\\n{\\n    vector<vector<int>>dp(s.length()+1,vector<int>(p.length()+1,0));\\n    dp[0][0]=true;\\n    for(int j=1;j<=p.length();j++)\\n    {\\n    bool flag= true;\\n        for(int k =1;k<=j;k++)\\n        {\\n            if(p[k-1]!=\\'*\\')\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        dp[0][j]=flag;\\n    }\\n    for(int i =1;i<=s.length();i++)\\n    {\\n        for(int j =1;j<=p.length();j++)\\n        {\\n            if(p[j-1]==\\'?\\' || p[j-1]==s[i-1])\\n            {\\n                dp[i][j]=dp[i-1][j-1];\\n            }\\n            else if(p[j-1]==\\'*\\')\\n            {\\n              dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n            else\\n            {\\n                  dp[i][j]=false;\\n            }\\n        }\\n    }\\n    return dp[s.length()][p.length()];\\n}\\n\\n\\n\\n\\n    bool isMatch(string s, string p)\\n    {\\n       \\n        // return solve(s,p,s.length()-1,p.length()-1,dp);\\nreturn solvetab(s,p);\\n    }\\n};\\n```\\n\\n\\n# **MEMOIZATION**\\n# Approach\\nsolve Function: This recursive function is used to check if a substring of str starting from the first character to index i matches a substring of pattern starting from the first character to index j. The function takes the string str, the pattern pattern, the indices i and j, and a memoization table dp as input.\\n\\nBase Cases: The function first checks for base cases:\\n\\nIf both i and j are less than 0, it means both str and pattern are empty, so it returns true.\\nIf i is greater than or equal to 0 but j is less than 0, it means pattern is empty, so it returns false.\\nIf j is greater than or equal to 0 but i is less than 0, it checks if the remaining characters in pattern (from index 0 to j) are all \\'*\\' characters. If yes, it returns true; otherwise, it returns false.\\nMemoization: Before proceeding with the recursive calls, the function checks if the result for the current i and j has already been computed and stored in the memoization table dp. If so, it directly returns the precomputed value to avoid redundant calculations.\\n\\nRecursive Calls: If the base cases are not satisfied, the function checks for the following conditions:\\n\\nIf the current characters in str and pattern match (either the same character or \\'?\\' in the pattern), it makes a recursive call to solve with indices i-1 and j-1 to check the remaining substrings.\\nIf the current character in pattern is \\'*\\', it makes two recursive calls to solve:\\nOne with index i-1 and the same index j to check if the \\'*\\' matches a single character in str.\\nAnother with the same index i and index j-1 to check if the \\'*\\' matches a sequence of characters in str.\\nIf none of the above conditions match, it returns false, as the characters do not match.\\nMemoization Update: After the recursive calls, the function updates the memoization table dp with the result for the current i and j and returns the result.\\n\\nisMatch Function: This function serves as an interface to call the solve function with the appropriate arguments. It initializes the memoization table dp, calls solve with s.length()-1, p.length()-1, and returns the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n\\nbool solve(string& str,string& pattern , int i , int j, vector<vector<int>>&dp)\\n{\\n    if(i<0 && j<0)\\n    {\\n        return true;\\n    }\\n    if(i>=0 && j<0)\\n    {\\n        return false;\\n    }\\n    if(j>=0 && i<0)\\n    {\\n        for(int k =0;k<=j;k++)\\n        {\\n            if(pattern[k]!=\\'*\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(pattern[j]==\\'?\\' || pattern[j]==str[i])\\n    {\\n        return dp[i][j]=solve(str,pattern, i-1,j-1,dp);\\n    }\\n    else if(pattern[j]==\\'*\\')\\n    {\\n       return dp[i][j]=solve(str,pattern, i-1,j,dp) || solve(str,pattern, i,j-1,dp);\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n}\\n    bool isMatch(string s, string p)\\n    {\\n        vector<vector<int>>dp(s.length(),vector<int>(p.length(),-1));\\n        return solve(s,p,s.length()-1,p.length()-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\nbool solvetab(string s, string p)\\n{\\n    vector<vector<int>>dp(s.length()+1,vector<int>(p.length()+1,0));\\n    dp[0][0]=true;\\n    for(int j=1;j<=p.length();j++)\\n    {\\n    bool flag= true;\\n        for(int k =1;k<=j;k++)\\n        {\\n            if(p[k-1]!=\\'*\\')\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        dp[0][j]=flag;\\n    }\\n    for(int i =1;i<=s.length();i++)\\n    {\\n        for(int j =1;j<=p.length();j++)\\n        {\\n            if(p[j-1]==\\'?\\' || p[j-1]==s[i-1])\\n            {\\n                dp[i][j]=dp[i-1][j-1];\\n            }\\n            else if(p[j-1]==\\'*\\')\\n            {\\n              dp[i][j]=dp[i-1][j] || dp[i][j-1];\\n            }\\n            else\\n            {\\n                  dp[i][j]=false;\\n            }\\n        }\\n    }\\n    return dp[s.length()][p.length()];\\n}\\n\\n\\n\\n\\n    bool isMatch(string s, string p)\\n    {\\n       \\n        // return solve(s,p,s.length()-1,p.length()-1,dp);\\nreturn solvetab(s,p);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\nbool solve(string& str,string& pattern , int i , int j, vector<vector<int>>&dp)\\n{\\n    if(i<0 && j<0)\\n    {\\n        return true;\\n    }\\n    if(i>=0 && j<0)\\n    {\\n        return false;\\n    }\\n    if(j>=0 && i<0)\\n    {\\n        for(int k =0;k<=j;k++)\\n        {\\n            if(pattern[k]!=\\'*\\')\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    if(dp[i][j]!=-1)\\n    {\\n        return dp[i][j];\\n    }\\n    if(pattern[j]==\\'?\\' || pattern[j]==str[i])\\n    {\\n        return dp[i][j]=solve(str,pattern, i-1,j-1,dp);\\n    }\\n    else if(pattern[j]==\\'*\\')\\n    {\\n       return dp[i][j]=solve(str,pattern, i-1,j,dp) || solve(str,pattern, i,j-1,dp);\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n}\\n    bool isMatch(string s, string p)\\n    {\\n        vector<vector<int>>dp(s.length(),vector<int>(p.length(),-1));\\n        return solve(s,p,s.length()-1,p.length()-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788484,
                "title": "c-dp-memoization-tabulation",
                "content": "# Memoization\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<short>> memo(n, vector<short>(m, -1));\\n        return dp(s, p, n-1, m-1, memo);\\n    }\\n\\nprivate:\\n    bool dp(string& s, string& p, int i, int j, vector<vector<short>>& memo) {\\n        if (i < 0) {\\n            while (j >= 0)\\n                if (p[j--] != \\'*\\') return false;\\n            return true;\\n        }\\n        if (j < 0) return false;\\n        if (memo[i][j] != -1) return memo[i][j];\\n\\n        if (s[i] == p[j] || p[j] == \\'?\\') return memo[i][j] = dp(s, p, i-1, j-1, memo);\\n        if (p[j] == \\'*\\') return memo[i][j] = dp(s, p, i-1, j, memo) || dp(s, p, i, j-1, memo);\\n\\n        return memo[i][j] = false;\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        dp[0][0] = true;\\n\\n        for (int j = 1; p[j-1] == \\'*\\'; j++) dp[0][j] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i-1] == p[j-1] || p[j-1] == \\'?\\') dp[i][j] = dp[i-1][j-1]; \\n                else if (p[j-1] == \\'*\\') dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j] = false;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<short>> memo(n, vector<short>(m, -1));\\n        return dp(s, p, n-1, m-1, memo);\\n    }\\n\\nprivate:\\n    bool dp(string& s, string& p, int i, int j, vector<vector<short>>& memo) {\\n        if (i < 0) {\\n            while (j >= 0)\\n                if (p[j--] != \\'*\\') return false;\\n            return true;\\n        }\\n        if (j < 0) return false;\\n        if (memo[i][j] != -1) return memo[i][j];\\n\\n        if (s[i] == p[j] || p[j] == \\'?\\') return memo[i][j] = dp(s, p, i-1, j-1, memo);\\n        if (p[j] == \\'*\\') return memo[i][j] = dp(s, p, i-1, j, memo) || dp(s, p, i, j-1, memo);\\n\\n        return memo[i][j] = false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size(); \\n        vector<vector<bool>> dp(n + 1, vector<bool>(m + 1, false));\\n        dp[0][0] = true;\\n\\n        for (int j = 1; p[j-1] == \\'*\\'; j++) dp[0][j] = true;\\n\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 1; j <= m; j++) {\\n                if (s[i-1] == p[j-1] || p[j-1] == \\'?\\') dp[i][j] = dp[i-1][j-1]; \\n                else if (p[j-1] == \\'*\\') dp[i][j] = dp[i-1][j] || dp[i][j-1];\\n                else dp[i][j] = false;\\n            }\\n        }\\n\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773695,
                "title": "c-90-fast-recursive-memoization-tabulation-space-optimised",
                "content": "# Intuition\\nWhatever conditions are given in the question, just keep calling indices according to them.\\n\\n# Approach\\nJust handle the base cases carefully here.\\n\\nIf both the strings end at the same time, *return **true***\\nif string p is finished, and s isn\\'t, *return **false***\\nif s is finshed, then check if all the remaining elements in p are \\'*\\', *return true else return **false***\\n\\nTo understaand the last point, think about the case where \\ns = \"\"\\np = \"***\"\\n\\n\\n# Complexity\\n    n = s.size()\\n    m = p.size()\\n\\n- Time complexity:\\nO(n * m)\\n\\n- Space complexity:\\nO(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, string &s, string &p){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solve(i+1, j+1, s, p);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solve(k, j+1, s, p);\\n            }\\n\\n            // OR\\n            // ans = solve(i, j+1, s, p) || solve(i+1, j, s, p);\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool solveMem(int i, int j, string &s, string &p, vector<vector<int>> &DP){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        if(DP[i][j] != -1) return DP[i][j];\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solveMem(i+1, j+1, s, p, DP);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solveMem(k, j+1, s, p, DP);\\n            }\\n            \\n            // OR we can use\\n            // ans = solveMem(i, j+1, s, p, DP) || solveMem(i+1, j, s, p, DP);\\n        }\\n\\n        return DP[i][j] = ans;\\n    }\\n\\n    bool solveTab(string &s, string &p){\\n        vector<vector<int>> DP(s.size()+1, vector<int>(p.size()+1, 0));\\n        DP[s.size()][p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                DP[s.size()][i] = DP[s.size()][i+1];\\n            }\\n            else{\\n                DP[s.size()][i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = DP[i+1][j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = DP[i][j+1] || DP[i+1][j];\\n                }\\n\\n                DP[i][j] = ans;\\n            }\\n        }\\n\\n        return DP[0][0];\\n    }\\n\\n    bool solveSO(string &s, string &p){\\n        vector<int> curr(p.size()+1, 0), next(p.size()+1, 0);\\n\\n        // Modify our DP arrays according to the base cases\\n        next[p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                next[i] = next[i+1];\\n            }\\n            else{\\n                next[i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = next[j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = curr[j+1] || next[j];\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return next[0];\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        // vector<vector<int>> DP(s.size(), vector<int>(p.size(), -1));\\n        // return solveMem(0, 0, s, p, DP);\\n\\n        return solveSO(s, p);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(int i, int j, string &s, string &p){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solve(i+1, j+1, s, p);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solve(k, j+1, s, p);\\n            }\\n\\n            // OR\\n            // ans = solve(i, j+1, s, p) || solve(i+1, j, s, p);\\n        }\\n\\n        return ans;\\n    }\\n\\n    bool solveMem(int i, int j, string &s, string &p, vector<vector<int>> &DP){\\n        if(i >= s.size() && j >= p.size()) return 1;\\n        if(j >= p.size()) return 0;\\n        if(i >= s.size()){\\n            for(int k = j; k < p.size(); k++){\\n                if(p[k] != \\'*\\') return 0;\\n            }\\n            return 1;\\n        }\\n\\n        if(DP[i][j] != -1) return DP[i][j];\\n\\n        bool ans = 0;\\n        if(p[j] == \\'?\\' || s[i] == p[j]){\\n            ans = solveMem(i+1, j+1, s, p, DP);\\n        }\\n        else if(p[j] == \\'*\\'){\\n            for(int k = i; k <= s.size(); k++){\\n                ans = ans || solveMem(k, j+1, s, p, DP);\\n            }\\n            \\n            // OR we can use\\n            // ans = solveMem(i, j+1, s, p, DP) || solveMem(i+1, j, s, p, DP);\\n        }\\n\\n        return DP[i][j] = ans;\\n    }\\n\\n    bool solveTab(string &s, string &p){\\n        vector<vector<int>> DP(s.size()+1, vector<int>(p.size()+1, 0));\\n        DP[s.size()][p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                DP[s.size()][i] = DP[s.size()][i+1];\\n            }\\n            else{\\n                DP[s.size()][i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = DP[i+1][j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = DP[i][j+1] || DP[i+1][j];\\n                }\\n\\n                DP[i][j] = ans;\\n            }\\n        }\\n\\n        return DP[0][0];\\n    }\\n\\n    bool solveSO(string &s, string &p){\\n        vector<int> curr(p.size()+1, 0), next(p.size()+1, 0);\\n\\n        // Modify our DP arrays according to the base cases\\n        next[p.size()] = 1;\\n        for(int i=p.size()-1; i>=0; i--){\\n            if(p[i] == \\'*\\'){\\n                next[i] = next[i+1];\\n            }\\n            else{\\n                next[i] = 0;\\n            }\\n        }\\n\\n        for(int i=s.size()-1; i>=0; i--){\\n            for(int j=p.size()-1; j>=0; j--){\\n                bool ans = 0;\\n                if(p[j] == \\'?\\' || s[i] == p[j]){\\n                    ans = next[j+1];\\n                }\\n                else if(p[j] == \\'*\\'){\\n                    ans = curr[j+1] || next[j];\\n                }\\n\\n                curr[j] = ans;\\n            }\\n\\n            next = curr;\\n        }\\n\\n        return next[0];\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        // vector<vector<int>> DP(s.size(), vector<int>(p.size(), -1));\\n        // return solveMem(0, 0, s, p, DP);\\n\\n        return solveSO(s, p);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555561,
                "title": "approach1-recursion-with-memoisation",
                "content": "# Intuition\\nThere are two cases we can encounter\\n- pattern[i]==string[j] or pattern[i]==\\'?\\' this is normal case and we can just move onto next index\\n- pattern[i]==\\'\\\\*\\' when it is \\'\\\\*\\' we need to further check two other cases\\n   - \\'*\\'can mean it matches with nothing\\n   - or it matches whith a sequence\\n- The two cases can be calculated recursively as \\n```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\\n- Here when it matches with nothing the index of string remains the same and pattern is reduced as it matches nothing\\n- In second case we keep the pattern index at the same position (\\'*\\')\\nand reduce the string index as we need to check if it matches further and this recursio covers all cases\\n- Ther recursion values are stored in a vector(memoisation) which improves the time complexity\\n- Further a cleanup function was created to remove multiple \\'*\\' placed together in the pattern as \\'ab\\\\***cd\\' pattern is same as \\'ab\\\\*cd\\' which reduces calculation time\\n        \\n# Approach\\n- cleanup function created which removes duplicate * and returns cleaned pattern\\n- BASE CASES\\n    - ```if(pi<0 && si<0)```: return true as both patten and word is empty\\n    - ```else if(pi<0 &&si>=0)```: returns fasle as pattern is empty but word is not\\n    - ```else if(pi<0 &&si>=0)```: if pattern is empty further checks if pattern contains \\'*\\' only or not. If not then return false\\n- ```else if (dp[pi][si]!=-1)```: checks if dp has calculated the recursion call or not\\n- ```else if(p[pi]==s[si] || p[pi]==\\'?\\')```: Case 1 where we reduce both indexes by ```helper(s,p,dp,si-1,pi-1);```\\n- ```else if(p[pi]==\\'*\\')```: checks both cases as mentioned in the intuition by ```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\\n\\n# Complexity\\n- Time complexity:\\nO(M*N) M,N is the length of string and pattern \\n\\n- Space complexity:\\nO(M*N)+O(M+N) .O(M+N) is the auxillary stack space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string cleanup(string p) {\\n        string cleaned_str = \"\";\\n        for (int i = 0; i < p.size(); i++) {\\n            if (cleaned_str.empty() || p[i] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            } else if (i >= 1 && cleaned_str[cleaned_str.size() - 1] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            }\\n        }\\n        return cleaned_str;\\n    }\\n\\n    bool helper(string &s, string &p, vector<vector<int>>&dp,int si,int pi) {\\n        if(pi<0 && si<0){\\n            return true;\\n        }\\n        else if(pi<0 &&si>=0){\\n            return false;\\n        }\\n        else if(pi>=0 && si<0){\\n            for(int k=0;k<=pi;k++){\\n                if(p[k]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        else if (dp[pi][si]!=-1) {\\n            return dp[pi][si];\\n        }\\n        else if(p[pi]==s[si] || p[pi]==\\'?\\'){\\n            return dp[pi][si]=helper(s,p,dp,si-1,pi-1);\\n        }\\n        else if(p[pi]==\\'*\\'){\\n            return dp[pi][si]= helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);\\n        }\\n\\n        return dp[pi][si]=false;\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        if (p != \"\") {\\n            p = cleanup(p);\\n        }\\n        int m=s.size();\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return helper(s, p, dp,m-1,n-1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\n```if(pi<0 && si<0)```\n```else if(pi<0 &&si>=0)```\n```else if(pi<0 &&si>=0)```\n```else if (dp[pi][si]!=-1)```\n```else if(p[pi]==s[si] || p[pi]==\\'?\\')```\n```helper(s,p,dp,si-1,pi-1);```\n```else if(p[pi]==\\'*\\')```\n```helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);```\n```\\nclass Solution {\\npublic:\\n    string cleanup(string p) {\\n        string cleaned_str = \"\";\\n        for (int i = 0; i < p.size(); i++) {\\n            if (cleaned_str.empty() || p[i] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            } else if (i >= 1 && cleaned_str[cleaned_str.size() - 1] != \\'*\\') {\\n                cleaned_str.append(1, p[i]);\\n            }\\n        }\\n        return cleaned_str;\\n    }\\n\\n    bool helper(string &s, string &p, vector<vector<int>>&dp,int si,int pi) {\\n        if(pi<0 && si<0){\\n            return true;\\n        }\\n        else if(pi<0 &&si>=0){\\n            return false;\\n        }\\n        else if(pi>=0 && si<0){\\n            for(int k=0;k<=pi;k++){\\n                if(p[k]!=\\'*\\') return false;\\n            }\\n            return true;\\n        }\\n        else if (dp[pi][si]!=-1) {\\n            return dp[pi][si];\\n        }\\n        else if(p[pi]==s[si] || p[pi]==\\'?\\'){\\n            return dp[pi][si]=helper(s,p,dp,si-1,pi-1);\\n        }\\n        else if(p[pi]==\\'*\\'){\\n            return dp[pi][si]= helper(s,p,dp,si,pi-1)|| helper(s,p,dp,si-1,pi);\\n        }\\n\\n        return dp[pi][si]=false;\\n    }\\n\\n    bool isMatch(string s, string p) {\\n        if (p != \"\") {\\n            p = cleanup(p);\\n        }\\n        int m=s.size();\\n        int n=p.size();\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return helper(s, p, dp,m-1,n-1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118356,
                "title": "c-two-approaches-recursive-memoization-tabulation",
                "content": "**Explanation**\\n\\n\\tabbacbaa\\n\\tab*?a\\n\\t* -> matches : bacb \\n\\t? -> matches : a\\n        \\n    abdejced\\n    ab*c?d\\n    * matches with empty, j, je, jed than the string is matched\\n\\n**Recursive**\\n```\\nbool helper(int i, int j, string& s, string& p){\\n        if(i <= -1 && j <= -1)return true;\\n        if(i <= -1){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j <= -1 && i != -1)return false;\\n        \\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i] == p[j] || ((s[i] != p[j]) && p[j] == \\'?\\'))return helper(i - 1, j - 1, s, p);\\n\\t\\t\\n        // For star pattern (Two Approaches for checking for star pattern)\\n        // if(p[j] == \\'*\\')return helper(i - 1, j, s, p) || helper(i, j - 1, s, p);\\n        if(p[j] == \\'*\\'){\\n            for(int m = 0 ; m <= i + 1 ; m++){\\n                bool f = helper(i - m, j - 1, s, p);\\n                if(f)return true;\\n            }\\n        }\\n        // Not Matching Case \\n        return false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        return helper(s.size() - 1, p.size() - 1, s, p);\\n    }\\n};\\n```\\n**Memoization**\\n\\n```\\nbool helper(int i, int j, string& s, string& p, vector<vector<int>>&dp){\\n        if(i == 0 && j == 0)return true;\\n        if(i == 0){\\n            for(int k = 0 ; k <= j - 1 ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j == 0 && i != 0)return false;\\n        if(dp[i][j] != -1)return dp[i][j];\\n\\t\\t\\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')return dp[i][j] = helper(i - 1, j - 1, s, p, dp);\\n        \\n        // For star pattern\\n        if(p[j - 1] == \\'*\\')return dp[i][j] = helper(i - 1, j, s, p, dp) || helper(i, j - 1, s, p, dp);\\n        \\n        // Not Matching Case \\n        return dp[i][j] = false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n        return helper(s.size(), p.size(), s, p, dp);\\n    }\\n};\\n\\n```\\n\\n**Tabulation**\\n\\n```\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size();\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n        \\n        dp[0][0] = true;\\n        for(int i = 1; i<= n ; i++)dp[i][0] = false;\\n        for(int j = 1 ; j <= m;j ++)dp[0][j] = valid(p, j);\\n        \\n        for(int i = 1 ; i <= n;i++){\\n            for(int j= 1 ; j <= m ; j++){\\n                if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')dp[i][j] = dp[i - 1 ][j - 1];\\n                else if(p[j - 1] == \\'*\\')dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];      \\n    }\\n};\\n```\\n\\n**Tabulation**\\n\\n```cpp\\nbool isMatch(string s, string p) {\\n    int n = s.size(), m = p.size();\\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1));\\n    \\n    // Base case coversion\\n    dp[0][0] = true;\\n    for (int i = 1; i <= n; i++)dp[i][0] = false;\\n\\n    bool flag = true;\\n    for (int i = 1; i <= m; i++) {\\n        if (p[i - 1] != \\'*\\') {\\n            flag = false;\\n        }\\n        dp[0][i] = flag;\\n    }\\n\\n    // Recursive relation conversion\\n    for (int i = 1 ; i <= n ; i++) {\\n        for (int j = 1 ; j <= m ; j++) {\\n            if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\'){\\n                dp[i][j] = dp[i - 1][j - 1];\\n            }else if (p[j - 1] == \\'*\\'){\\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n            }else{\\n                dp[i][j] = false;\\n            }\\n        }\\n    }\\n\\n    return dp[n][m];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nbool helper(int i, int j, string& s, string& p){\\n        if(i <= -1 && j <= -1)return true;\\n        if(i <= -1){\\n            for(int k = 0 ; k <= j ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j <= -1 && i != -1)return false;\\n        \\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i] == p[j] || ((s[i] != p[j]) && p[j] == \\'?\\'))return helper(i - 1, j - 1, s, p);\\n\\t\\t\\n        // For star pattern (Two Approaches for checking for star pattern)\\n        // if(p[j] == \\'*\\')return helper(i - 1, j, s, p) || helper(i, j - 1, s, p);\\n        if(p[j] == \\'*\\'){\\n            for(int m = 0 ; m <= i + 1 ; m++){\\n                bool f = helper(i - m, j - 1, s, p);\\n                if(f)return true;\\n            }\\n        }\\n        // Not Matching Case \\n        return false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        return helper(s.size() - 1, p.size() - 1, s, p);\\n    }\\n};\\n```\n```\\nbool helper(int i, int j, string& s, string& p, vector<vector<int>>&dp){\\n        if(i == 0 && j == 0)return true;\\n        if(i == 0){\\n            for(int k = 0 ; k <= j - 1 ; k++)\\n                if(p[k] != \\'*\\')return false;\\n            return true;\\n        }\\n        if(j == 0 && i != 0)return false;\\n        if(dp[i][j] != -1)return dp[i][j];\\n\\t\\t\\n        // Matching case \\n        // If string and pattern matches or the pattern contains a question mark\\n        if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')return dp[i][j] = helper(i - 1, j - 1, s, p, dp);\\n        \\n        // For star pattern\\n        if(p[j - 1] == \\'*\\')return dp[i][j] = helper(i - 1, j, s, p, dp) || helper(i, j - 1, s, p, dp);\\n        \\n        // Not Matching Case \\n        return dp[i][j] = false;\\n        \\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>>dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n        return helper(s.size(), p.size(), s, p, dp);\\n    }\\n};\\n\\n```\n```\\n    bool isMatch(string s, string p) {\\n        int n = s.size(), m = p.size();\\n        vector<vector<bool>> dp(n + 1, vector<bool> (m + 1, false));\\n        \\n        dp[0][0] = true;\\n        for(int i = 1; i<= n ; i++)dp[i][0] = false;\\n        for(int j = 1 ; j <= m;j ++)dp[0][j] = valid(p, j);\\n        \\n        for(int i = 1 ; i <= n;i++){\\n            for(int j= 1 ; j <= m ; j++){\\n                if(s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\')dp[i][j] = dp[i - 1 ][j - 1];\\n                else if(p[j - 1] == \\'*\\')dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        return dp[n][m];      \\n    }\\n};\\n```\n```cpp\\nbool isMatch(string s, string p) {\\n    int n = s.size(), m = p.size();\\n    vector<vector<bool>> dp(n + 1, vector<bool>(m + 1));\\n    \\n    // Base case coversion\\n    dp[0][0] = true;\\n    for (int i = 1; i <= n; i++)dp[i][0] = false;\\n\\n    bool flag = true;\\n    for (int i = 1; i <= m; i++) {\\n        if (p[i - 1] != \\'*\\') {\\n            flag = false;\\n        }\\n        dp[0][i] = flag;\\n    }\\n\\n    // Recursive relation conversion\\n    for (int i = 1 ; i <= n ; i++) {\\n        for (int j = 1 ; j <= m ; j++) {\\n            if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\'){\\n                dp[i][j] = dp[i - 1][j - 1];\\n            }else if (p[j - 1] == \\'*\\'){\\n                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\\n            }else{\\n                dp[i][j] = false;\\n            }\\n        }\\n    }\\n\\n    return dp[n][m];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3115049,
                "title": "python-solution-one-linear-using-fnmatch",
                "content": "```\\nimport fnmatch\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return fnmatch.fnmatch(s,p)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport fnmatch\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        return fnmatch.fnmatch(s,p)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107865,
                "title": "beats-100-tabulation-simple-and-easy-to-understand-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// //// TABULATION\\n    bool isMatch(string str, string p) {\\n        string s = p , t = str;\\n        int m = s.size() , n = t.size(); ///  string t is pattern string\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,0));\\n        dp[0][0] = true;\\n        for(int j=1;j<=n;j++) dp[0][j] =false;\\n        for(int i=1;i<=m;i++){\\n            bool temp = true;\\n            for(int ii=1;ii<=i;ii++){\\n                if(s[ii-1] != \\'*\\'){\\n                    temp = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = temp;\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1] == t[j-1] || s[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else if(s[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                }\\n                else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// //// TABULATION\\n    bool isMatch(string str, string p) {\\n        string s = p , t = str;\\n        int m = s.size() , n = t.size(); ///  string t is pattern string\\n        vector<vector<bool>> dp(m+1,vector<bool>(n+1,0));\\n        dp[0][0] = true;\\n        for(int j=1;j<=n;j++) dp[0][j] =false;\\n        for(int i=1;i<=m;i++){\\n            bool temp = true;\\n            for(int ii=1;ii<=i;ii++){\\n                if(s[ii-1] != \\'*\\'){\\n                    temp = false;\\n                    break;\\n                }\\n            }\\n            dp[i][0] = temp;\\n        }\\n        for(int i=1;i<=m;i++){\\n            for(int j=1;j<=n;j++){\\n                if(s[i-1] == t[j-1] || s[i-1] == \\'?\\'){\\n                    dp[i][j] = dp[i-1][j-1];\\n                }\\n                else if(s[i-1] == \\'*\\'){\\n                    dp[i][j] = dp[i-1][j] | dp[i][j-1];\\n                }\\n                else{\\n                    dp[i][j] = false;\\n                }\\n            }\\n        }\\n        return dp[m][n];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076936,
                "title": "c-easy-solution-memoization-tabulation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string s,string p,vector<vector<int>>&dp){\\n        if(i==0 && j==0) return true;\\n        if(i>0 && j==0) return false;\\n        if(i==0 && j>0){\\n            for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n            return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        if(p[j-1]==\\'*\\'){\\n            return dp[i][j]=f(i-1,j,s,p,dp) | f(i,j-1,s,p,dp);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    bool x(string p,int j){\\n        for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        for(int j=1;j<=m;j++) {\\n            dp[0][j]=x(p,j);\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                 dp[i][j]=dp[i-1][j-1];\\n            else {if(p[j-1]==\\'*\\'){\\n                dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n            }\\n            else\\n                dp[i][j]=false;}\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool f(int i,int j, string s,string p,vector<vector<int>>&dp){\\n        if(i==0 && j==0) return true;\\n        if(i>0 && j==0) return false;\\n        if(i==0 && j>0){\\n            for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n            return dp[i][j]=f(i-1,j-1,s,p,dp);\\n        if(p[j-1]==\\'*\\'){\\n            return dp[i][j]=f(i-1,j,s,p,dp) | f(i,j-1,s,p,dp);\\n        }\\n        return dp[i][j]=false;\\n    }\\n    bool x(string p,int j){\\n        for(int k=1;k<=j;k++){\\n                if(p[k-1]!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n    }\\n    bool isMatch(string s, string p) {\\n        int n=s.length();\\n        int m=p.length();\\n        vector<vector<bool>>dp(n+1,vector<bool>(m+1,false));\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++) dp[i][0]=false;\\n        for(int j=1;j<=m;j++) {\\n            dp[0][j]=x(p,j);\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1] || p[j-1]==\\'?\\')\\n                 dp[i][j]=dp[i-1][j-1];\\n            else {if(p[j-1]==\\'*\\'){\\n                dp[i][j]=dp[i-1][j] | dp[i][j-1];\\n            }\\n            else\\n                dp[i][j]=false;}\\n            }\\n        }\\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2270748,
                "title": "c-easy-simple-solution-wildcard-matching",
                "content": "class Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        bool dp[p.size() + 1][s.size() + 1];\\n        \\n        for(int i = p.size(); i >= 0; i--) {\\n            for(int j = s.size(); j >= 0; j--) {\\n                 if(i == p.size()&& j == s.size()) {\\n                     dp[i][j] = true;\\n                 }\\n                 else if(i == p.size()) {\\n                       dp[i][j] = false;\\n                 }\\n                 else if(j == s.size()) {\\n                       if(p[i] == \\'*\\') {\\n                             dp[i][j] = dp[i+1][j];\\n                       }\\n                     else {\\n                         dp[i][j] = false;\\n                     }\\n                 }\\n                 else {\\n                     if(p[i] == \\'*\\') {\\n                         dp[i][j] = dp[i+1][j] || dp[i][j+1];\\n                     }\\n                     else if(p[i] == \\'?\\') {\\n                         dp[i][j] = dp[i+1][j+1];\\n                     }\\n                     else {\\n                         if(p[i] == s[j]) dp[i][j] = dp[i+1][j+1];\\n                         else dp[i][j] = false;\\n                     }\\n                 }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        bool dp[p.size() + 1][s.size() + 1];\\n        \\n        for(int i = p.size(); i >= 0; i--) {\\n            for(int j = s.size(); j >= 0; j--) {\\n                 if(i == p.size()&& j == s.size()) {\\n                     dp[i][j] = true;\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2217760,
                "title": "working-solution-100-python",
                "content": "Here i am having a recursive solution in python. \\n\\n> Lets understand the complexity of the problem and where we are not able to pass the cases.\\n\\nIn this problem we need to  match two string char by char the problem while doing is the REGEX  <bold>* </bold> and<bold> ?</bold> which creates confusion. Genralization comes with equating the length of the char  as we encounter the <bold> * </bold> and <bol> ? </bold> following are the cases that we need to follow:\\n\\n> 1. text = \\'xyz\\'  and  pattern = \\'*\\' -> In this we can directly return true as \\'*\\' can match anylength of sequence without any issue.\\n> 2. text = \\'xyz\\' and pattern = \\'x?z\\' -> Here, also we can return true as \\'?\\' can match with length 1 char which will give true as result.\\n> 3. text = \\'xyylmnz\\' and pattern = x <bold>* </bold>m?z -> Now a little confusing part here we need to match the text as much as possible so we will match \\'yyl\\' with  \\'<bold>* </bold>\\' and then \\'n\\' with \\'?\\'  and so we will get all char matched with text.\\n\\nApart from the above cases we might encounter a case where we don\\'t have \\'*\\' and \\'?\\' in the string and that is simple case of string matching where we don\\'t need to worry about REGEX patterns.\\n\\nPYTHON CODE :\\n\\n```\\n def isMatchRecursive(self, s, p ,p1, p2):\\n \\n \\'\\'\\'   if all char in pattern is checked then return by checking \\n       whether text is equal to iterated position value \\'\\'\\'\\n        if p2 == len(p):\\n            return len(s) == p1    \\n       \\n\\t   \\'\\'\\' If * then try to match maximum char in pattern and if \\'?\\' is found\\n\\t      match it with one char else recursively call the function with increased \\n\\t\\t  position values \\'\\'\\'\\n\\t\\t  \\n        if p[p2] != \\'*\\':\\n            if p1 < len(s) and (s[p1] == p[p2] or p[p2] == \\'?\\'):\\n                return self.isMatchRecursive(s, p,p1+1,p2+1)\\n            else:\\n                return False\\n\\t\\t\\'\\'\\' This else condition is for maching \\'*\\' int the pattern like we \\n\\t\\thave 3 \\'*\\' so we need to bypass all the \\'*\\'. \\'\\'\\'\\n\\t\\t\\n        else: \\n            while p2< len(p)-1 and p[p2+1] == \\'*\\':\\n                p2 += 1\\n            p1 -= 1\\n\\n            \\'\\'\\' This loop recursively calls the function with next chars in the pattern by incrementing the poistions in the pattern and text strings\\'\\'\\'\\n            while p1< len(s):\\n                if self.isMatchRecursive(s,p,p1+1, p2+1):\\n                    return True\\n\\n                p1 += 1\\n\\n        return False\\n\\ndef isMatch(self, s, p):\\n\\n\\treturn self.isMatchRecursive(s, p, 0 , 0)\\n```",
                "solutionTags": [
                    "Python",
                    "String",
                    "Recursion"
                ],
                "code": "```\\n def isMatchRecursive(self, s, p ,p1, p2):\\n \\n \\'\\'\\'   if all char in pattern is checked then return by checking \\n       whether text is equal to iterated position value \\'\\'\\'\\n        if p2 == len(p):\\n            return len(s) == p1    \\n       \\n\\t   \\'\\'\\' If * then try to match maximum char in pattern and if \\'?\\' is found\\n\\t      match it with one char else recursively call the function with increased \\n\\t\\t  position values \\'\\'\\'\\n\\t\\t  \\n        if p[p2] != \\'*\\':\\n            if p1 < len(s) and (s[p1] == p[p2] or p[p2] == \\'?\\'):\\n                return self.isMatchRecursive(s, p,p1+1,p2+1)\\n            else:\\n                return False\\n\\t\\t\\'\\'\\' This else condition is for maching \\'*\\' int the pattern like we \\n\\t\\thave 3 \\'*\\' so we need to bypass all the \\'*\\'. \\'\\'\\'\\n\\t\\t\\n        else: \\n            while p2< len(p)-1 and p[p2+1] == \\'*\\':\\n                p2 += 1\\n            p1 -= 1\\n\\n            \\'\\'\\' This loop recursively calls the function with next chars in the pattern by incrementing the poistions in the pattern and text strings\\'\\'\\'\\n            while p1< len(s):\\n                if self.isMatchRecursive(s,p,p1+1, p2+1):\\n                    return True\\n\\n                p1 += 1\\n\\n        return False\\n\\ndef isMatch(self, s, p):\\n\\n\\treturn self.isMatchRecursive(s, p, 0 , 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2152788,
                "title": "c-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string text, string pattern) {\\n       int n = pattern.size();\\n       int m = text.size();\\n        if(m==0 && n==0)\\n        {return true;}\\n        if(n==0)\\n        {return false;}\\n        if(m==0 && pattern[0] == \\'?\\') return false;\\n        \\n       vector<vector<bool>> dp(m+1, vector<bool> (n+1, false));\\n        dp[0][0] = true;\\n       for(int i=1;i<=n;++i)\\n       {\\n           if( pattern[i-1] != \\'*\\') \\n           {\\n               break;\\n           }\\n           else \\n           {\\n               dp[0][i] = true;\\n           }\\n       }\\n       \\n       \\n\\n       for(int i=1;i<=m;++i)\\n       {\\n        for(int j=1;j<=n;++j)\\n        {\\n         \\n         if(text[i-1] == pattern[j-1])\\n         {\\n          dp[i][j] = dp[i-1][j-1];\\n         }\\n         else\\n         {\\n           if(pattern[j-1] == \\'?\\')\\n           {\\n              dp[i][j] = dp[i-1][j-1];\\n           }\\n           else if(pattern[j-1] == \\'*\\')\\n           {\\n              dp[i][j] = dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1];\\n           }\\n           else\\n           {\\n            dp[i][j] = false;\\n           }\\n         }\\n\\n        }\\n       }\\n\\n       return dp[m][n];\\n    }\\n};\\n```\\n\\n**Kindly upvote if you got the solution**.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string text, string pattern) {\\n       int n = pattern.size();\\n       int m = text.size();\\n        if(m==0 && n==0)\\n        {return true;}\\n        if(n==0)\\n        {return false;}\\n        if(m==0 && pattern[0] == \\'?\\') return false;\\n        \\n       vector<vector<bool>> dp(m+1, vector<bool> (n+1, false));\\n        dp[0][0] = true;\\n       for(int i=1;i<=n;++i)\\n       {\\n           if( pattern[i-1] != \\'*\\') \\n           {\\n               break;\\n           }\\n           else \\n           {\\n               dp[0][i] = true;\\n           }\\n       }\\n       \\n       \\n\\n       for(int i=1;i<=m;++i)\\n       {\\n        for(int j=1;j<=n;++j)\\n        {\\n         \\n         if(text[i-1] == pattern[j-1])\\n         {\\n          dp[i][j] = dp[i-1][j-1];\\n         }\\n         else\\n         {\\n           if(pattern[j-1] == \\'?\\')\\n           {\\n              dp[i][j] = dp[i-1][j-1];\\n           }\\n           else if(pattern[j-1] == \\'*\\')\\n           {\\n              dp[i][j] = dp[i][j-1] | dp[i-1][j] | dp[i-1][j-1];\\n           }\\n           else\\n           {\\n            dp[i][j] = false;\\n           }\\n         }\\n\\n        }\\n       }\\n\\n       return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2146926,
                "title": "c-easy-solution-memoiazation-tabulation",
                "content": "**Method 1: Memoiazation**\\n\\n\\n```\\n//Memoiazation\\nbool f(int i,int j,string &pattern,string &text,vector<vector<int>>&dp)\\n{\\n    // Base Cases\\n    if(i<0 && j<0) return true;\\n    if(i<0 && j>=0) return false;\\n    if(i>=0 && j<0) {\\n    for(int k=0;k<=i;k++) \\n      if(pattern[k]!=\\'*\\') return false; \\n      return true;  \\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    if(pattern[i]==text[j] || pattern[i]==\\'?\\') \\n    return dp[i][j] = f(i-1,j-1,pattern,text,dp);\\n    else if(pattern[i] ==\\'*\\') \\n    return dp[i][j]=f(i-1,j,pattern,text,dp) || f(i,j-1,pattern,text,dp);\\n    else return dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) \\n{\\n    int m = p.length();\\n    int n = s.length();\\n    vector<vector<int>>dp(m,vector<int>(n,-1));\\n    return f(m-1,n-1,p,s,dp);\\n}\\n```\\n\\n**Method: Tabulation**\\n\\n```\\n// Tabulation \\nbool isMatch(string text, string pattern) \\n{\\n    int m = pattern.length();\\n    int n = text.length();\\n    vector<vector<bool>>dp(m+1,vector<bool>(n+1,false));\\n  \\n    // Base Cases\\n    dp[0][0] = true;\\n    for(int j=1;j<=n;j++) dp[0][j] = false;\\n    \\n    for(int i=1;i<=m;i++)\\n    {\\n      bool flag = true;\\n     for(int k=1;k<=i;k++){\\n      if(pattern[k-1]!=\\'*\\'){\\n           flag = false;\\n           break;\\n      }         \\n    }\\n     return dp[i][0] = flag; \\n    }\\n    \\n    // Main Operation\\n    for(int i=1;i<=m;i++)\\n    {\\n        for(int j=1;j<=n;j++)\\n        {\\n          if(pattern[i-1]==text[j-1] || pattern[i-1]==\\'?\\') \\n          dp[i][j] = dp[i-1][j-1]; \\n            \\n          else if(pattern[i-1] ==\\'*\\') \\n          dp[i][j]= dp[i-1][j] | dp[i][j-1];\\n            \\n          else dp[i][j] = false;\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Memoiazation\\nbool f(int i,int j,string &pattern,string &text,vector<vector<int>>&dp)\\n{\\n    // Base Cases\\n    if(i<0 && j<0) return true;\\n    if(i<0 && j>=0) return false;\\n    if(i>=0 && j<0) {\\n    for(int k=0;k<=i;k++) \\n      if(pattern[k]!=\\'*\\') return false; \\n      return true;  \\n    }\\n    if(dp[i][j]!=-1) return dp[i][j];\\n    if(pattern[i]==text[j] || pattern[i]==\\'?\\') \\n    return dp[i][j] = f(i-1,j-1,pattern,text,dp);\\n    else if(pattern[i] ==\\'*\\') \\n    return dp[i][j]=f(i-1,j,pattern,text,dp) || f(i,j-1,pattern,text,dp);\\n    else return dp[i][j] = false;\\n}\\nbool isMatch(string s, string p) \\n{\\n    int m = p.length();\\n    int n = s.length();\\n    vector<vector<int>>dp(m,vector<int>(n,-1));\\n    return f(m-1,n-1,p,s,dp);\\n}\\n```\n```\\n// Tabulation \\nbool isMatch(string text, string pattern) \\n{\\n    int m = pattern.length();\\n    int n = text.length();\\n    vector<vector<bool>>dp(m+1,vector<bool>(n+1,false));\\n  \\n    // Base Cases\\n    dp[0][0] = true;\\n    for(int j=1;j<=n;j++) dp[0][j] = false;\\n    \\n    for(int i=1;i<=m;i++)\\n    {\\n      bool flag = true;\\n     for(int k=1;k<=i;k++){\\n      if(pattern[k-1]!=\\'*\\'){\\n           flag = false;\\n           break;\\n      }         \\n    }\\n     return dp[i][0] = flag; \\n    }\\n    \\n    // Main Operation\\n    for(int i=1;i<=m;i++)\\n    {\\n        for(int j=1;j<=n;j++)\\n        {\\n          if(pattern[i-1]==text[j-1] || pattern[i-1]==\\'?\\') \\n          dp[i][j] = dp[i-1][j-1]; \\n            \\n          else if(pattern[i-1] ==\\'*\\') \\n          dp[i][j]= dp[i-1][j] | dp[i][j-1];\\n            \\n          else dp[i][j] = false;\\n        }\\n    }\\n    return dp[m][n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2051554,
                "title": "java-2ms-solution-beat-99",
                "content": "\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean isMatch(String s, String p) {\\n\\t\\t\\tif (p == null || p.length() == 0) return (s == null | s.length() == 0);\\n\\n\\t\\t\\tif (p == \"*\") return true;\\n\\n\\t\\t\\tint ls = s.length(), lp = p.length();\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint star = -1, match = 0;\\n\\n\\t\\t\\twhile (i < ls){\\n\\n\\t\\t\\t\\tif(j < lp && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\')){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}else if (j < lp &&p.charAt(j) == \\'*\\'){\\n\\t\\t\\t\\t\\tstar = j;\\n\\t\\t\\t\\t\\tmatch = i;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}else if (star != -1){\\n\\t\\t\\t\\t\\ti = ++match;\\n\\t\\t\\t\\t\\tj = star+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse return false;\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (j < lp){\\n\\t\\t\\t\\tif (p.charAt(j) != \\'*\\') return false;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn j == lp;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isMatch(String s, String p) {\\n\\t\\t\\tif (p == null || p.length() == 0) return (s == null | s.length() == 0);\\n\\n\\t\\t\\tif (p == \"*\") return true;\\n\\n\\t\\t\\tint ls = s.length(), lp = p.length();\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint star = -1, match = 0;\\n\\n\\t\\t\\twhile (i < ls){\\n\\n\\t\\t\\t\\tif(j < lp && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\')){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2043900,
                "title": "java-solution-for-wildcard-matching",
                "content": "## Approach\\n\\n  We start with the first character of the pattern.\\n  If the first character of the pattern is a match, we move to the next character of the pattern and the next character of the string.\\n  If the first character of the pattern is not a match, we check if there is a star in the pattern.\\n  If there is a star in the pattern, we move to the next character of the pattern and the next character of the string.\\n  If there is no star in the pattern, we return false.\\n  If the first character of the pattern is a star, we move to the next character of the pattern.\\n  We check if the next character of the pattern is a match.\\n  If the next character of the pattern is a match, we move to the next character of the pattern and the next character of the string.\\n  If the next character of the pattern is not a match, we check if there is a star in the pattern.\\n  If there is a star in the pattern, we move to the next character of the pattern and the next character of the string.\\n  If there is no star in the pattern, we return false.\\n  If the first character of the pattern is not a match and there is no star in the pattern, we return false.\\n \\n  **`Time: O(n)`**\\n  \\n  ---\\n\\n## Solution\\n\\n```java\\n// Time: O(n)\\nclass Solution {\\n  public static boolean isMatch(String s, String p) {\\n    // Edge case\\n    if (s == null || p == null) {\\n      return false;\\n    }\\n\\n    // Initialize the variables\\n    int sIndex = 0;\\n    int pIndex = 0;\\n    int starIndex = -1;\\n    int match = 0;\\n\\n    // Loop through the pattern\\n\\n    while (sIndex < s.length()) {\\n      // If the current pattern is a match\\n      if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n        sIndex++;\\n        pIndex++;\\n      }\\n      // If the current pattern is a star\\n      else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n        starIndex = pIndex;\\n        match = sIndex;\\n        pIndex++;\\n      }\\n      // If the current pattern is not a match and there is no star\\n      else if (starIndex == -1) {\\n        return false;\\n      }\\n      // If the current pattern is not a match and there is a star\\n      else {\\n        pIndex = starIndex + 1;\\n        sIndex = match + 1;\\n        match++;\\n      }\\n    }\\n\\n    // Check if the pattern is a match\\n    while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n      pIndex++;\\n    }\\n\\n    return pIndex == p.length();\\n  }\\n\\n  public static void main(String[] args) {\\n    System.out.println(isMatch(\"aa\", \"a\"));\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n// Time: O(n)\\nclass Solution {\\n  public static boolean isMatch(String s, String p) {\\n    // Edge case\\n    if (s == null || p == null) {\\n      return false;\\n    }\\n\\n    // Initialize the variables\\n    int sIndex = 0;\\n    int pIndex = 0;\\n    int starIndex = -1;\\n    int match = 0;\\n\\n    // Loop through the pattern\\n\\n    while (sIndex < s.length()) {\\n      // If the current pattern is a match\\n      if (pIndex < p.length() && (s.charAt(sIndex) == p.charAt(pIndex) || p.charAt(pIndex) == \\'?\\')) {\\n        sIndex++;\\n        pIndex++;\\n      }\\n      // If the current pattern is a star\\n      else if (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n        starIndex = pIndex;\\n        match = sIndex;\\n        pIndex++;\\n      }\\n      // If the current pattern is not a match and there is no star\\n      else if (starIndex == -1) {\\n        return false;\\n      }\\n      // If the current pattern is not a match and there is a star\\n      else {\\n        pIndex = starIndex + 1;\\n        sIndex = match + 1;\\n        match++;\\n      }\\n    }\\n\\n    // Check if the pattern is a match\\n    while (pIndex < p.length() && p.charAt(pIndex) == \\'*\\') {\\n      pIndex++;\\n    }\\n\\n    return pIndex == p.length();\\n  }\\n\\n  public static void main(String[] args) {\\n    System.out.println(isMatch(\"aa\", \"a\"));\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961308,
                "title": "simple-java-dp-memoization",
                "content": "```\\n Boolean[][] dp;\\n    \\n    public boolean func(String s,String p,int n,int m){\\n        if(n==-1&&m==-1){\\n            return true;\\n        }\\n        if(n<0){\\n            for(int i=0;i<=m;i++){\\n                if(p.charAt(i)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(m<0){\\n            return false;\\n        }\\n        if(dp[n][m]!=null){\\n            return dp[n][m];\\n        }\\n        if(p.charAt(m)==\\'?\\'||(p.charAt(m)==s.charAt(n))){\\n            return dp[n][m]=func(s,p,n-1,m-1);\\n        }\\n        if(p.charAt(m)==\\'*\\'){\\n            return dp[n][m]=func(s,p,n-1,m)||func(s,p,n,m-1);\\n        }\\n        \\n        return dp[n][m]=false;\\n    }\\n    \\n    public boolean isMatch(String s, String p) {\\n        dp=new Boolean[s.length()][p.length()];\\n        return func(s,p,s.length()-1,p.length()-1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n Boolean[][] dp;\\n    \\n    public boolean func(String s,String p,int n,int m){\\n        if(n==-1&&m==-1){\\n            return true;\\n        }\\n        if(n<0){\\n            for(int i=0;i<=m;i++){\\n                if(p.charAt(i)!=\\'*\\'){\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n        if(m<0){\\n            return false;\\n        }\\n        if(dp[n][m]!=null){\\n            return dp[n][m];\\n        }\\n        if(p.charAt(m)==\\'?\\'||(p.charAt(m)==s.charAt(n))){\\n            return dp[n][m]=func(s,p,n-1,m-1);\\n        }\\n        if(p.charAt(m)==\\'*\\'){\\n            return dp[n][m]=func(s,p,n-1,m)||func(s,p,n,m-1);\\n        }\\n        \\n        return dp[n][m]=false;\\n    }\\n    \\n    public boolean isMatch(String s, String p) {\\n        dp=new Boolean[s.length()][p.length()];\\n        return func(s,p,s.length()-1,p.length()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945937,
                "title": "java-solution-tc-o-n-2-sc-o-n-2",
                "content": "\\t\\tpublic boolean isMatch(String s, String p) \\n\\t\\t{   \\n\\t\\t\\tint m = p.length(),n = s.length();\\n\\t\\t\\tboolean dp[][] = new boolean[m+1][n+1];\\n\\t\\t\\tdp[m][n] = true;\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\tdp[i][n] = dp[i+1][n];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p.charAt(i)==\\'?\\' || p.charAt(i)==s.charAt(j))\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i+1][j+1];\\n\\t\\t\\t\\t\\telse if(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i+1][j]||dp[i+1][j+1])||dp[i][j+1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "\\t\\tpublic boolean isMatch(String s, String p) \\n\\t\\t{   \\n\\t\\t\\tint m = p.length(),n = s.length();\\n\\t\\t\\tboolean dp[][] = new boolean[m+1][n+1];\\n\\t\\t\\tdp[m][n] = true;\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\tdp[i][n] = dp[i+1][n];\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=m-1;i>=0;i--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=n-1;j>=0;j--)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(p.charAt(i)==\\'?\\' || p.charAt(i)==s.charAt(j))\\n\\t\\t\\t\\t\\t\\tdp[i][j] = dp[i+1][j+1];\\n\\t\\t\\t\\t\\telse if(p.charAt(i)==\\'*\\')\\n\\t\\t\\t\\t\\t\\tdp[i][j] = (dp[i+1][j]||dp[i+1][j+1])||dp[i][j+1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1945845,
                "title": "c-dp-lcs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\\n        dp[0][0] = true;\\n        \\n        int st = 0;\\n        while(st < m && p[st] == \\'*\\')\\n            dp[++st][0] = true;\\n        \\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                else if(p[i-1] == \\'*\\')\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                else \\n                    dp[i][j] = false;\\n            }\\n        }\\n        \\n        \\n        // for(int i = 0; i <= m; i++) {\\n        //     for(int j = 0; j <= n; j++)\\n        //         cout << dp[i][j] << \" \";\\n        //     cout << endl;\\n        // }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int m = p.length();\\n        int n = s.length();\\n        \\n        vector<vector<bool>> dp(m+1, vector<bool>(n+1, false));\\n        dp[0][0] = true;\\n        \\n        int st = 0;\\n        while(st < m && p[st] == \\'*\\')\\n            dp[++st][0] = true;\\n        \\n        for(int i = 1; i <= m; i++) {\\n            for(int j = 1; j <= n; j++) {\\n                if(p[i-1] == s[j-1] || p[i-1] == \\'?\\')\\n                    dp[i][j] = dp[i-1][j-1];\\n                else if(p[i-1] == \\'*\\')\\n                    dp[i][j] = dp[i][j-1] || dp[i-1][j];\\n                else \\n                    dp[i][j] = false;\\n            }\\n        }\\n        \\n        \\n        // for(int i = 0; i <= m; i++) {\\n        //     for(int j = 0; j <= n; j++)\\n        //         cout << dp[i][j] << \" \";\\n        //     cout << endl;\\n        // }\\n        \\n        return dp[m][n];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1636756,
                "title": "python-short-top-down-dp",
                "content": "```\\nclass Solution:\\n    @cache\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return not s\\n        if p[0]==\"*\": \\n            return self.isMatch(s,p[1:]) or (s and self.isMatch(s[1:],p))\\n        else:\\n            return s and p[0] in (s[0],\\'?\\') and self.isMatch(s[1:],p[1:])",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def isMatch(self, s: str, p: str) -> bool:\\n        if not p: return not s\\n        if p[0]==\"*\": \\n            return self.isMatch(s,p[1:]) or (s and self.isMatch(s[1:],p))\\n        else:\\n            return s and p[0] in (s[0],\\'?\\') and self.isMatch(s[1:],p[1:])",
                "codeTag": "Java"
            },
            {
                "id": 1545924,
                "title": "c-tabulation-dp-ac-recursive-memo-tle-t-c-o-n-m",
                "content": "**Tabulation DP**\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string &s, string &p) {\\n        int is=s.size(), ip=p.size();\\n        bool dp[is+1][ip+1];\\n\\n        for(int i=0;i<=is;++i){\\n            for(int j=0;j<=ip;++j){\\n                if(i==0 and j==0){\\n                    dp[i][j] = true;\\n                }else if(i==0){\\n                    if(p[j-1]==\\'*\\') dp[i][j] = dp[i][j-1];\\n                    else dp[i][j] = false;\\n                }else if(j==0){\\n                    dp[i][j] = false;\\n                }else{\\n                    char curS = s[i-1], curP = p[j-1];\\n                    if(curS==curP){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'*\\'){\\n                        dp[i][j] = (dp[i][j-1] or dp[i-1][j-1] or dp[i-1][j]);\\n                    }else{\\n                        dp[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[is][ip];\\n    }\\n};\\n```\\n\\n**Recursive+memoization  = TLE**\\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2004][2004];\\n    bool solve(string &s, string &p, int is, int ip){\\n        if(ip==0 and is==0) return true;\\n        else if(is==0){\\n            if(p[ip-1]==\\'*\\') return dp[is][ip] = solve(s,p,is,ip-1);\\n            return false;\\n        }else if(ip==0) return false;\\n        if(dp[is][ip]!=-1) return dp[is][ip];\\n        char curS = s[is-1], curP = p[ip-1];\\n        if(curS==curP or curP==\\'?\\'){  \\n            return dp[is][ip] = solve(s,p,is-1,ip-1);\\n        }else if(curP==\\'*\\'){\\n            bool empty = solve(s,p,is,ip-1);\\n            bool ele1 = solve(s,p,is-1,ip-1);\\n            bool eleN = solve(s,p,is-1,ip);\\n            return dp[is][ip] = (empty or ele1 or eleN);\\n        }else{\\n            return dp[is][ip] = false;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        memset(dp,-1,sizeof(dp));\\n        int is=s.size(), ip=p.size();\\n        return solve(s,p,is,ip);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string &s, string &p) {\\n        int is=s.size(), ip=p.size();\\n        bool dp[is+1][ip+1];\\n\\n        for(int i=0;i<=is;++i){\\n            for(int j=0;j<=ip;++j){\\n                if(i==0 and j==0){\\n                    dp[i][j] = true;\\n                }else if(i==0){\\n                    if(p[j-1]==\\'*\\') dp[i][j] = dp[i][j-1];\\n                    else dp[i][j] = false;\\n                }else if(j==0){\\n                    dp[i][j] = false;\\n                }else{\\n                    char curS = s[i-1], curP = p[j-1];\\n                    if(curS==curP){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'?\\'){\\n                        dp[i][j] = dp[i-1][j-1];\\n                    }else if(curP==\\'*\\'){\\n                        dp[i][j] = (dp[i][j-1] or dp[i-1][j-1] or dp[i-1][j]);\\n                    }else{\\n                        dp[i][j] = false;\\n                    }\\n                }\\n            }\\n        }\\n        return dp[is][ip];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int dp[2004][2004];\\n    bool solve(string &s, string &p, int is, int ip){\\n        if(ip==0 and is==0) return true;\\n        else if(is==0){\\n            if(p[ip-1]==\\'*\\') return dp[is][ip] = solve(s,p,is,ip-1);\\n            return false;\\n        }else if(ip==0) return false;\\n        if(dp[is][ip]!=-1) return dp[is][ip];\\n        char curS = s[is-1], curP = p[ip-1];\\n        if(curS==curP or curP==\\'?\\'){  \\n            return dp[is][ip] = solve(s,p,is-1,ip-1);\\n        }else if(curP==\\'*\\'){\\n            bool empty = solve(s,p,is,ip-1);\\n            bool ele1 = solve(s,p,is-1,ip-1);\\n            bool eleN = solve(s,p,is-1,ip);\\n            return dp[is][ip] = (empty or ele1 or eleN);\\n        }else{\\n            return dp[is][ip] = false;\\n        }\\n    }\\n    \\n    bool isMatch(string s, string p) {\\n        memset(dp,-1,sizeof(dp));\\n        int is=s.size(), ip=p.size();\\n        return solve(s,p,is,ip);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1311503,
                "title": "recursion-with-memoization-c",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s, string &p, int i, int j, vector<vector<int> > &dp)\\n    {\\n        if(i==s.size() && j==p.size()) return true;\\n        if(j==p.size()) return false;\\n        \\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n        \\n        if(i==s.size())\\n        {\\n            int jj = j;\\n            while( (j<p.size()) && (p[j] == \\'*\\') ) j++;\\n            dp[i][j] = (j==p.size());\\n            return dp[i][jj] = dp[i][j];\\n        }\\n        \\n        if((s[i]==p[j]) || (p[j] == \\'?\\')) \\n            return dp[i][j] = solve(s, p, i+1, j+1, dp);\\n        if(p[j] == \\'*\\')\\n            return dp[i][j] = (solve(s, p, i, j+1, dp) || solve(s, p, i+1, j, dp) || solve(s, p, i+1, j+1, dp));\\n        \\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n         vector<vector<int>> dp(s.size()+1, vector<int>(p.size()+1, -1));\\n        return solve(s, p, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\n    bool solve(string &s, string &p, int i, int j, vector<vector<int> > &dp)\\n    {\\n        if(i==s.size() && j==p.size()) return true;\\n        if(j==p.size()) return false;\\n        \\n        if(dp[i][j]!=-1) \\n            return dp[i][j];\\n        \\n        if(i==s.size())\\n        {\\n            int jj = j;\\n            while( (j<p.size()) && (p[j] == \\'*\\') ) j++;\\n            dp[i][j] = (j==p.size());\\n            return dp[i][jj] = dp[i][j];\\n        }\\n        \\n        if((s[i]==p[j]) || (p[j] == \\'?\\')) \\n            return dp[i][j] = solve(s, p, i+1, j+1, dp);\\n        if(p[j] == \\'*\\')\\n            return dp[i][j] = (solve(s, p, i, j+1, dp) || solve(s, p, i+1, j, dp) || solve(s, p, i+1, j+1, dp));\\n        \\n        return dp[i][j] = false;\\n    }\\n    bool isMatch(string s, string p) {\\n         vector<vector<int>> dp(s.size()+1, vector<int>(p.size()+1, -1));\\n        return solve(s, p, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248251,
                "title": "c-easy-bottom-up-dp",
                "content": "```\\n bool isMatch(string s, string p) \\n    {\\n        int n = s.size();\\n        int m = p.size();\\n        \\n        bool t[n + 1][m + 1];\\n        memset(t, 0, sizeof(t));\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i <= m; i++)\\n        {\\n            if(p[i - 1] == \\'*\\')\\n                t[0][i] = t[0][i - 1];\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(p[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n               else\\n                   t[i][j] = ((s[i - 1] == p[j - 1] || p[j - 1]==\\'?\\') && t[i - 1][j - 1]);\\n            }\\n        }\\n       return (t[n][m]);\\n  }\\n```\\n\\n\\n```\\n//for loop can also be written as:\\n    for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(pattern[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n        \\n                else if(pattern[j - 1] == \\'?\\' || pattern[j - 1] == str[i - 1])\\n                        t[i][j] = t[i - 1][j - 1];\\n                else t[i][j] = 0;\\n                    \\n            }\\n        } \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n bool isMatch(string s, string p) \\n    {\\n        int n = s.size();\\n        int m = p.size();\\n        \\n        bool t[n + 1][m + 1];\\n        memset(t, 0, sizeof(t));\\n        t[0][0] = 1;\\n        \\n        for(int i = 1; i <= m; i++)\\n        {\\n            if(p[i - 1] == \\'*\\')\\n                t[0][i] = t[0][i - 1];\\n        }\\n        for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(p[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n               else\\n                   t[i][j] = ((s[i - 1] == p[j - 1] || p[j - 1]==\\'?\\') && t[i - 1][j - 1]);\\n            }\\n        }\\n       return (t[n][m]);\\n  }\\n```\n```\\n//for loop can also be written as:\\n    for(int i = 1; i <= n; i++)\\n        {\\n            for(int j = 1; j <= m; j++)\\n            {\\n                if(pattern[j - 1] == \\'*\\')\\n                    t[i][j] = t[i - 1][j] || t[i][j - 1];\\n        \\n                else if(pattern[j - 1] == \\'?\\' || pattern[j - 1] == str[i - 1])\\n                        t[i][j] = t[i - 1][j - 1];\\n                else t[i][j] = 0;\\n                    \\n            }\\n        } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1103091,
                "title": "java-share-my-3ms-solution-not-dp-easy-to-understand",
                "content": "My idea is to split pattern into multiple sub-patterns by \\'*\\'.\\nFor example:\\n```\\np        sub-patterns\\n\"\"    -> []\\n\"a\"   -> [\"a\"]\\n\"a*b\" -> [\"a\", \"b\"]\\n\"*a\"  -> [\"\", \"a\"]\\n\"a*\"  -> [\"a\", \"\"]\\n\"*a*\" -> [\"\", \"a\", \"\"]\\n\"*\"   -> [\"\", \"\"]\\n\"**\"  -> [\"\", \"\", \"\"]\\n```\\nThen search those sub-patterns in the string. String is matched when:\\n```text\\nif (sub-patterns == []) only empty string can be matched.\\nif (sub-patterns.size() == 1) string must be strictly matched.\\nif (sub-patterns.size() >= 2) {\\n    string must match the fist sub-pattern from start. &&\\n\\tstring must match the last sub-pattern at end. &&\\n\\tmiddle sub-patterns can be matched by order.\\n}\\n```\\nComplexity:\\n```\\nspace: O(p.length)\\n time: O(s.length * p.length) for worst scenario\\n```\\nShow code:\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int slen = s.length();\\n        List<String> parts = split(p.toCharArray());\\n        if (parts.isEmpty()) return slen == 0;\\n        \\n        // handle first\\n        String firstP = parts.get(0);\\n        if (!match(s, 0, firstP)) return false;\\n        if (parts.size() == 1) return slen == firstP.length();\\n        \\n        int si = firstP.length();\\n        \\n        // handle middle\\n        FOR_PARTS:\\n        for (int i = 1; i < parts.size() - 1; ++i) {\\n            String currP = parts.get(i);\\n            while (si <= slen) {\\n                if (match(s, si, currP)) {\\n                    si += currP.length();\\n                    continue FOR_PARTS;\\n                }\\n                ++si;\\n            }\\n            return false;\\n        }\\n            \\n        // handle last\\n        String lastP = parts.get(parts.size()-1);\\n        int lastSlen = slen - si;\\n        if (lastSlen < lastP.length()) return false;\\n        si = slen - lastP.length();\\n        return match(s, si, lastP);\\n    }\\n    \\n    private boolean match(String s, int si, String p) {\\n        int plen = p.length();\\n        int slen = s.length() - si;\\n        if (plen == 0) return true;\\n        if (slen < plen) return false;\\n        for (int i = 0; i < plen; ++i) {\\n            if (p.charAt(i) == \\'?\\') continue;\\n            if (s.charAt(si+i) != p.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    // [] -> p is empty\\n    // [\"s1\"] -> p has no \\'*\\'\\n    // [\"s1\", \"s2\"] -> p has one \\'*\\'\\n    // [\"\", \"s1\"] -> p has \\'*\\' ahead\\n    // [\"s1\", \"\"] -> p has \\'*\\' at end\\n    // [\"\", \"\"] -> p == \\'*\\'\\n    private List<String> split(char[] p) {\\n        List<String> parts = new ArrayList<>();\\n        if (p.length > 0) {\\n            StringBuilder sb = new StringBuilder();\\n            for (char c : p) {\\n                if (c != \\'*\\') {\\n                    sb.append(c);\\n                } else {\\n                    parts.add(sb.toString());\\n                    sb = new StringBuilder();\\n                }\\n            }\\n            parts.add(sb.toString());\\n        }\\n        return parts;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\np        sub-patterns\\n\"\"    -> []\\n\"a\"   -> [\"a\"]\\n\"a*b\" -> [\"a\", \"b\"]\\n\"*a\"  -> [\"\", \"a\"]\\n\"a*\"  -> [\"a\", \"\"]\\n\"*a*\" -> [\"\", \"a\", \"\"]\\n\"*\"   -> [\"\", \"\"]\\n\"**\"  -> [\"\", \"\", \"\"]\\n```\n```text\\nif (sub-patterns == []) only empty string can be matched.\\nif (sub-patterns.size() == 1) string must be strictly matched.\\nif (sub-patterns.size() >= 2) {\\n    string must match the fist sub-pattern from start. &&\\n\\tstring must match the last sub-pattern at end. &&\\n\\tmiddle sub-patterns can be matched by order.\\n}\\n```\n```\\nspace: O(p.length)\\n time: O(s.length * p.length) for worst scenario\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        int slen = s.length();\\n        List<String> parts = split(p.toCharArray());\\n        if (parts.isEmpty()) return slen == 0;\\n        \\n        // handle first\\n        String firstP = parts.get(0);\\n        if (!match(s, 0, firstP)) return false;\\n        if (parts.size() == 1) return slen == firstP.length();\\n        \\n        int si = firstP.length();\\n        \\n        // handle middle\\n        FOR_PARTS:\\n        for (int i = 1; i < parts.size() - 1; ++i) {\\n            String currP = parts.get(i);\\n            while (si <= slen) {\\n                if (match(s, si, currP)) {\\n                    si += currP.length();\\n                    continue FOR_PARTS;\\n                }\\n                ++si;\\n            }\\n            return false;\\n        }\\n            \\n        // handle last\\n        String lastP = parts.get(parts.size()-1);\\n        int lastSlen = slen - si;\\n        if (lastSlen < lastP.length()) return false;\\n        si = slen - lastP.length();\\n        return match(s, si, lastP);\\n    }\\n    \\n    private boolean match(String s, int si, String p) {\\n        int plen = p.length();\\n        int slen = s.length() - si;\\n        if (plen == 0) return true;\\n        if (slen < plen) return false;\\n        for (int i = 0; i < plen; ++i) {\\n            if (p.charAt(i) == \\'?\\') continue;\\n            if (s.charAt(si+i) != p.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    // [] -> p is empty\\n    // [\"s1\"] -> p has no \\'*\\'\\n    // [\"s1\", \"s2\"] -> p has one \\'*\\'\\n    // [\"\", \"s1\"] -> p has \\'*\\' ahead\\n    // [\"s1\", \"\"] -> p has \\'*\\' at end\\n    // [\"\", \"\"] -> p == \\'*\\'\\n    private List<String> split(char[] p) {\\n        List<String> parts = new ArrayList<>();\\n        if (p.length > 0) {\\n            StringBuilder sb = new StringBuilder();\\n            for (char c : p) {\\n                if (c != \\'*\\') {\\n                    sb.append(c);\\n                } else {\\n                    parts.add(sb.toString());\\n                    sb = new StringBuilder();\\n                }\\n            }\\n            parts.add(sb.toString());\\n        }\\n        return parts;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032324,
                "title": "javascript-easy-to-read-dynamic-programming-solution-with-drawing",
                "content": "For this problem, it\\'s important to remember a few things:\\n1. `?` can map to any **character** (can not be a space, must be a-z)\\n2. `*` is the most versatile, since it can be a sequence of numbers or blank (`\"\"`)\\n\\nFirst, we create a DP array (text.length + 1) by (text2.length + 1). We do plus once because we make room for the blank string (\" \").\\n\\n**Setup**\\n1. We know that blank to blank is true, because they are equal strings. \\n2. If we have a `*` in our text2, we take the previous value in our DP array. This is evident in going from blank (\" \") to \"*\".  \\n\\n**Using Subproblems to make up the entire problem**\\n1. We know if the two letters are equal to each other or text2 === \"?\", our value for dp[row][col] is the same as dp[row - 1][col - 1]. Why? Let\\'s look at `acdeb` to `*a*b`. If we were to drop the `b`s in both of these, we would have `acde` and `*a*`. These two are equivalent, so we just take the solution of `acde` and `*a*` and put it into the square for  `acdeb` to `*a*b`\\n2. If text2[index] is a `*`, we can look at the cell above or the cell to the left. Why? Look at `ac` compared to `*a*`. If we drop the c, our solution will be the same as `a` compared to `*a*`. If that\\'s true, dp[row][col] is true. Notice though if we look at `*a` compared to `ac`, it is false. That is okay because the `*` makes things more flexible, and we take the `OR` of the top or left cell.\\n\\n![image](https://assets.leetcode.com/users/images/b032ec12-edc2-4cb2-9dd6-00cf0df8e8c8_1611468211.9012723.png)\\n\\nThis is a hard problem, and I **did not get it on my first try**. I had to look at the solution and make sense of it. I am going to try to make a video to better understand it myself hopefully. If you have any questions, please let me know.\\n\\n```\\nconst isMatch = (text1, text2) => {\\n\\tlet dp = [...new Array(text1.length + 1)].map(() =>\\n\\t\\tArray(text2.length + 1).fill(false)\\n\\t);\\n\\n    // blank to blank always true\\n    dp[0][0] = true;\\n    \\n\\t// Only text2 will have `*` or `?`\\n    for (var col = 1; col <= dp[0].length; col ++) {\\n        if (text2[col - 1] === \\'*\\') {\\n            dp[0][col] = dp[0][col - 1];\\n        }\\n    }\\n\\n\\tfor (let row = 1; row < dp.length; row++) {\\n\\t\\tfor (let col = 1; col < dp[0].length; col++) {\\n\\t\\t\\tlet text1Letter = text1[row - 1],\\n\\t\\t\\t\\ttext2Letter = text2[col - 1];\\n\\n\\t\\t\\tif (text1Letter == text2Letter || text2Letter == \\'?\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row - 1][col - 1];\\n\\t\\t\\telse if (text2Letter == \\'*\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row][col - 1] || dp[row - 1][col];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[text1.length][text2.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nconst isMatch = (text1, text2) => {\\n\\tlet dp = [...new Array(text1.length + 1)].map(() =>\\n\\t\\tArray(text2.length + 1).fill(false)\\n\\t);\\n\\n    // blank to blank always true\\n    dp[0][0] = true;\\n    \\n\\t// Only text2 will have `*` or `?`\\n    for (var col = 1; col <= dp[0].length; col ++) {\\n        if (text2[col - 1] === \\'*\\') {\\n            dp[0][col] = dp[0][col - 1];\\n        }\\n    }\\n\\n\\tfor (let row = 1; row < dp.length; row++) {\\n\\t\\tfor (let col = 1; col < dp[0].length; col++) {\\n\\t\\t\\tlet text1Letter = text1[row - 1],\\n\\t\\t\\t\\ttext2Letter = text2[col - 1];\\n\\n\\t\\t\\tif (text1Letter == text2Letter || text2Letter == \\'?\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row - 1][col - 1];\\n\\t\\t\\telse if (text2Letter == \\'*\\')\\n\\t\\t\\t\\tdp[row][col] = dp[row][col - 1] || dp[row - 1][col];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[text1.length][text2.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991061,
                "title": "easy-python-dp-solution",
                "content": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[0 for i in range(len(s)+1)] for j in range(len(p)+1)] \\n        \\n        dp[0][0] = 1\\n        i=0\\n        while i<len(p) and p[i]==\"*\":\\n            dp[i+1][0]=1\\n            i+=1\\n        for i in range(1,len(p)+1):\\n            for j in range(1,len(s)+1):\\n                if p[i-1]==s[j-1] or p[i-1]==\"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[i-1]==\"*\":\\n                    dp[i][j] = dp[i-1][j]|dp[i][j-1]\\n                else:\\n                    dp[i][j] = 0\\n                    \\n        return dp[len(p)][len(s)]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def isMatch(self, s: str, p: str) -> bool:\\n        dp = [[0 for i in range(len(s)+1)] for j in range(len(p)+1)] \\n        \\n        dp[0][0] = 1\\n        i=0\\n        while i<len(p) and p[i]==\"*\":\\n            dp[i+1][0]=1\\n            i+=1\\n        for i in range(1,len(p)+1):\\n            for j in range(1,len(s)+1):\\n                if p[i-1]==s[j-1] or p[i-1]==\"?\":\\n                    dp[i][j] = dp[i-1][j-1]\\n                elif p[i-1]==\"*\":\\n                    dp[i][j] = dp[i-1][j]|dp[i][j-1]\\n                else:\\n                    dp[i][j] = 0\\n                    \\n        return dp[len(p)][len(s)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903975,
                "title": "simple-dp-solution-any-language",
                "content": "Please refer below link and then code for proper understanding. Please upvote if you find it useful.\\nhttps://www.youtube.com/watch?v=3ZDZ-N0EPV0 - tushar roy\\n```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size();\\n        int m = p.size();\\n        bool dp[n+1][m+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++)dp[i][0]=false;\\n        int flag=1;\\n        for(int j=0;j<m;j++){ \\n            if(p[j]==\\'*\\'&&flag)dp[0][j+1]=true;  // if p string starts with * like (***a?b or *aa) then we have true value for corresponding empty s string as *** in ***a?b will be considered empty.\\n            else{\\n                flag=0;\\n                dp[0][j+1]=false;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1]||p[j-1]==\\'?\\')dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size();\\n        int m = p.size();\\n        bool dp[n+1][m+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=n;i++)dp[i][0]=false;\\n        int flag=1;\\n        for(int j=0;j<m;j++){ \\n            if(p[j]==\\'*\\'&&flag)dp[0][j+1]=true;  // if p string starts with * like (***a?b or *aa) then we have true value for corresponding empty s string as *** in ***a?b will be considered empty.\\n            else{\\n                flag=0;\\n                dp[0][j+1]=false;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            for(int j=1;j<=m;j++){\\n                if(s[i-1]==p[j-1]||p[j-1]==\\'?\\')dp[i][j]=dp[i-1][j-1];\\n                else if(p[j-1]==\\'*\\')dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                else dp[i][j]=false;\\n            }\\n        }\\n        \\n        return dp[n][m];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 816048,
                "title": "java-top-down-solution",
                "content": "class Solution {\\n\\n    public boolean isMatch(String s, String p) {\\n        return isMatchTDhelper(s, p, new int[s.length()][p.length()]);\\n    }\\n\\n\\tpublic static boolean isMatchTDhelper(String s, String p, int[][] memo) {\\n\\n\\t\\tif (s.length() == 0 && p.length() == 0)\\n\\t\\t\\treturn true;\\n\\n\\t\\tif (s.length() == 0 && p.length() != 0) {\\n\\t\\t\\tfor (char ch : p.toCharArray()) {\\n\\t\\t\\t\\tif (ch != \\'*\\')\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\tif (s.length() != 0 && p.length() == 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\tif (memo[s.length() - 1][p.length() - 1] != 0)\\n\\t\\t\\treturn (memo[s.length() - 1][p.length() - 1]) == 2 ? true : false;\\n\\n\\t\\tchar ch1 = s.charAt(0);\\n\\t\\tchar ch2 = p.charAt(0);\\n\\n\\t\\tboolean ans = false;\\n\\n\\t\\tString ros1 = s.substring(1);\\n\\t\\tString ros2 = p.substring(1);\\n\\n\\t\\tif (ch2 == \\'?\\')\\n\\t\\t\\tans = isMatchTDhelper(ros1, ros2, memo);\\n\\n\\t\\telse if (ch2 == \\'*\\') {\\n\\t\\t\\tans = isMatchTDhelper(s, ros2, memo);\\n\\t\\t\\tans = ans || isMatchTDhelper(ros1, p, memo);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t\\tans = (ch1 == ch2) ? isMatchTDhelper(ros1, ros2, memo) : false;\\n\\n\\t\\tmemo[s.length() - 1][p.length() - 1] = (ans) ? 2 : 1;\\n\\t\\treturn ans;\\n\\t}\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isMatch(String s, String p) {\\n        return isMatchTDhelper(s, p, new int[s.length()][p.length()]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 726474,
                "title": "c-two-pointers-o-n-2-and-o-1-space-beats-98-95",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return isMatchHelper(s.c_str(), p.c_str());\\n    }\\nprivate:\\n    bool isMatchHelper(const char *s, const char *p) {\\n        bool star = false;\\n        const char *str;\\n        const char *ptr;\\n        for (str = s, ptr = p; *str != \\'\\\\0\\'; str++, ptr++) {\\n            switch(*ptr) {\\n                case \\'?\\' :\\n                    break; // str step for 1, ptr step for 1\\n                case \\'*\\' :\\n                    star = true;\\n                    s = str;\\n                    p = ptr;\\n                    while (*p == \\'*\\') p++; // skip continuous \\'*\\'\\n                    if (*p == \\'\\\\0\\') return true;\\n                    str = s-1;\\n                    ptr = p-1;\\n                    break;\\n                default:\\n                    if (*str != *ptr) {\\n                        if (!star) return false;\\n                        s++;\\n                        str = s - 1;\\n                        ptr = p - 1;\\n                    }\\n            }\\n        }\\n        while (*ptr == \\'*\\') ptr++;\\n        return (*ptr == \\'\\\\0\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        return isMatchHelper(s.c_str(), p.c_str());\\n    }\\nprivate:\\n    bool isMatchHelper(const char *s, const char *p) {\\n        bool star = false;\\n        const char *str;\\n        const char *ptr;\\n        for (str = s, ptr = p; *str != \\'\\\\0\\'; str++, ptr++) {\\n            switch(*ptr) {\\n                case \\'?\\' :\\n                    break; // str step for 1, ptr step for 1\\n                case \\'*\\' :\\n                    star = true;\\n                    s = str;\\n                    p = ptr;\\n                    while (*p == \\'*\\') p++; // skip continuous \\'*\\'\\n                    if (*p == \\'\\\\0\\') return true;\\n                    str = s-1;\\n                    ptr = p-1;\\n                    break;\\n                default:\\n                    if (*str != *ptr) {\\n                        if (!star) return false;\\n                        s++;\\n                        str = s - 1;\\n                        ptr = p - 1;\\n                    }\\n            }\\n        }\\n        while (*ptr == \\'*\\') ptr++;\\n        return (*ptr == \\'\\\\0\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665179,
                "title": "python-96-66",
                "content": "```\\nclass Solution:\\n    def isMatch(self, string: str, pattern: str) -> bool:\\n        \\n        s = 0\\n        p = 0\\n        match = 0\\n        starIdx = -1\\n        \\n        # while we have not gone through all characters in the string\\n        while s < len(string):\\n            \\n            # if there are characters left in the pattern and string and pattern match 1-1, increment both\\n            if p < len(pattern) and (pattern[p] == \\'?\\' or string[s] == pattern[p]):\\n                s += 1\\n                p += 1\\n            \\n            # if there are characters left in the pattern and the current pattern character is *, \\n            # save the star index, save the match index, and increment the pattern\\n            elif p < len(pattern) and pattern[p] == \\'*\\':\\n                starIdx = p\\n                match = s\\n                p += 1\\n            \\n            # if the last char was *, increment match and assign to s\\n            elif starIdx != -1:\\n                p = starIdx + 1\\n                match += 1\\n                s = match\\n            \\n            else:\\n                return False\\n        \\n        # make sure remaining chars are all *\\n        while p < len(pattern) and pattern[p] == \\'*\\':\\n            p += 1\\n\\n        return p == len(pattern)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isMatch(self, string: str, pattern: str) -> bool:\\n        \\n        s = 0\\n        p = 0\\n        match = 0\\n        starIdx = -1\\n        \\n        # while we have not gone through all characters in the string\\n        while s < len(string):\\n            \\n            # if there are characters left in the pattern and string and pattern match 1-1, increment both\\n            if p < len(pattern) and (pattern[p] == \\'?\\' or string[s] == pattern[p]):\\n                s += 1\\n                p += 1\\n            \\n            # if there are characters left in the pattern and the current pattern character is *, \\n            # save the star index, save the match index, and increment the pattern\\n            elif p < len(pattern) and pattern[p] == \\'*\\':\\n                starIdx = p\\n                match = s\\n                p += 1\\n            \\n            # if the last char was *, increment match and assign to s\\n            elif starIdx != -1:\\n                p = starIdx + 1\\n                match += 1\\n                s = match\\n            \\n            else:\\n                return False\\n        \\n        # make sure remaining chars are all *\\n        while p < len(pattern) and pattern[p] == \\'*\\':\\n            p += 1\\n\\n        return p == len(pattern)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565256,
                "title": "java-dfs-memo-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return dfs(s, p, 0, 0);\\n    }\\n    \\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 == s.length() && idx2 == p.length()) {\\n            return true;\\n        }\\n        \\n        if (!s.equals(\"\") && !(idx2 < p.length() && p.charAt(idx2) == \\'*\\') && ((idx1 == s.length() && idx2 != p.length()) || (idx1 != s.length() && idx2 == p.length()))) {\\n            return false;\\n        }\\n        \\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        boolean result = false;\\n        if (idx2 < p.length() && p.charAt(idx2) == \\'?\\') {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (idx2 < p.length() && p.charAt(idx2) == \\'*\\') {\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        } else if (idx2 < p.length() && idx1 < s.length() && p.charAt(idx2) == s.charAt(idx1)) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        }\\n        \\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```\\n\\nUpdate : Cleaned up version\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.equals(p)) return true;\\n        \\n        return dfs(s, p, 0, 0);\\n    }\\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 >= s.length() && (idx2 >= p.length() || (idx2 == p.length()-1 && p.charAt(idx2) == \\'*\\'))) {\\n            return true;\\n        }\\n        if (idx1 >= s.length() && idx2 >= p.length()) return false;\\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        char ch1 = (idx1 >= s.length())? \\' \\' : s.charAt(idx1);\\n        char ch2 = (idx2 >= p.length())? \\':\\' : p.charAt(idx2);\\n        boolean result = false;\\n        if (ch1 == ch2 || (ch2 == \\'?\\' && ch1 != \\' \\')) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (ch2 == \\'*\\') {\\n            if (idx1 >= s.length()) return dfs(s, p, idx1, idx2+1);\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        return dfs(s, p, 0, 0);\\n    }\\n    \\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 == s.length() && idx2 == p.length()) {\\n            return true;\\n        }\\n        \\n        if (!s.equals(\"\") && !(idx2 < p.length() && p.charAt(idx2) == \\'*\\') && ((idx1 == s.length() && idx2 != p.length()) || (idx1 != s.length() && idx2 == p.length()))) {\\n            return false;\\n        }\\n        \\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        boolean result = false;\\n        if (idx2 < p.length() && p.charAt(idx2) == \\'?\\') {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (idx2 < p.length() && p.charAt(idx2) == \\'*\\') {\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        } else if (idx2 < p.length() && idx1 < s.length() && p.charAt(idx2) == s.charAt(idx1)) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        }\\n        \\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        if (s.equals(p)) return true;\\n        \\n        return dfs(s, p, 0, 0);\\n    }\\n    HashMap<String, Boolean> memo = new HashMap<>();\\n    public boolean dfs(String s, String p, int idx1, int idx2) {\\n        if (idx1 >= s.length() && (idx2 >= p.length() || (idx2 == p.length()-1 && p.charAt(idx2) == \\'*\\'))) {\\n            return true;\\n        }\\n        if (idx1 >= s.length() && idx2 >= p.length()) return false;\\n        String key = \"\"+idx1+\",\"+idx2;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        \\n        char ch1 = (idx1 >= s.length())? \\' \\' : s.charAt(idx1);\\n        char ch2 = (idx2 >= p.length())? \\':\\' : p.charAt(idx2);\\n        boolean result = false;\\n        if (ch1 == ch2 || (ch2 == \\'?\\' && ch1 != \\' \\')) {\\n            result = dfs(s, p, idx1+1, idx2+1);\\n        } else if (ch2 == \\'*\\') {\\n            if (idx1 >= s.length()) return dfs(s, p, idx1, idx2+1);\\n            for (int i = idx1; i <= s.length(); i++) {\\n                if (dfs(s, p, i, idx2+1)) {\\n                    result = true;\\n                    break;\\n                }\\n            }\\n        }\\n        memo.put(key, result);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491219,
                "title": "c-o-mn-memoization-and-tabular-solution-detailed-explanation",
                "content": "**Tabular Solution**\\n```\\n// TC: O(MN), SC: O(MN)\\nbool regexMatchTabular(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, 1));\\n\\n\\t// when source string is zero, pattern is only allowed to have *\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tdp[0][i] = p[i-1] == \\'*\\' && i-2 >= 0 ? dp[0][i-2] : 0;\\n\\t// when pattern length is zero\\n\\tfor(int i = 1; i <= s.size(); i++)\\n\\t\\tdp[i][0] = 0;\\n\\n\\tfor(int i = 1; i <= s.size(); i++) {\\n\\t\\tfor(int j = 1; j <= p.size(); j++) {\\n\\t\\t\\t// if the chars are same \\n\\t\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// different chars are allowed only incase of wilcard chars\\n\\t\\t\\t\\tif(p[j-1] == \\'.\\')\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t// when *\\n\\t\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t\\t// we have two choices, either use * or don\\'t use\\n\\t\\t\\t\\t\\tint with_star = (j - 2 >= 0) ? (p[j-2] == \\'.\\' || s[i-1] == p[j-2]) && dp[i-1][j] : 0;\\n\\t\\t\\t\\t\\tint without_star = (j - 2 >= 0) ? dp[i][j-2] : 0;\\n\\t\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// when chars are diff\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[s.size()][p.size()];\\n}  \\n\\nbool isMatch(string s, string p) {\\n\\t//return regexMatchDriver(s, p);\\n\\treturn regexMatchTabular(s, p);\\n}\\n```\\n\\n**Using Memoization**\\n```\\n// TC: O(MN), SC: O(MN)\\nint regexMatch(vector<vector<int>>& dp, string& s, string& p, \\n\\t\\t\\t   int i, int j) {\\n\\tif(j < 0)\\n\\t\\treturn 0;\\n\\tif(i == 0 && j == 0)\\n\\t\\treturn dp[i][j] = 1;\\n\\t// if the length of any string has become 0\\n\\t// then it is not a match except if the char in pattern is *\\n\\tif(i == 0 && j > 0)\\n\\t\\treturn dp[i][j] = p[j-1] == \\'*\\' && regexMatch(dp, s, p, i, j-1);\\n\\t// pattern has finished but not the source\\n\\tif(i != 0 && j == 0)\\n\\t\\treturn dp[i][j] = 0;\\n\\n\\tif(dp[i][j] == -1) {\\n\\t\\t// initially mark it true\\n\\t\\tdp[i][j] = 1;\\n\\t\\t// if the chars are same\\n\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\telse {\\n\\t\\t\\t// when chars are different, then only if the pattern contains \\'.\\'\\n\\t\\t\\t// or \\'*\\' matching the string s then it is valid\\n\\t\\t\\tif(p[j-1] == \\'?\\')\\n\\t\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t// With * we can either try using it or not use it \\n\\t\\t\\t\\tint with_star = 0, without_star = 0;\\n\\t\\t\\t\\t// USE *\\n\\t\\t\\t\\t// if the pattern char match the * char of string source\\n\\t\\t\\t\\t// check for the previous char of source\\n\\t\\t\\t\\twith_star = regexMatch(dp, s, p, i-1, j);\\n\\n\\t\\t\\t\\t// DON\\'T USE * \\n\\t\\t\\t\\t// also covers the case when current pattern char is wildcard * and doesn\\'t match\\n\\t\\t\\t\\t// the char of source, try the char before \\'*\\' of pattern\\n\\t\\t\\t\\twithout_star = regexMatch(dp, s, p, i, j-1);\\n\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t}\\n\\t\\t\\t// chars don\\'t match\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[i][j];\\n}\\n\\n// driver memoization function\\nbool regexMatchDriver(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n\\tregexMatch(dp, s, p, s.size(), p.size());\\n\\treturn dp[s.size()][p.size()];\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n// TC: O(MN), SC: O(MN)\\nbool regexMatchTabular(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, 1));\\n\\n\\t// when source string is zero, pattern is only allowed to have *\\n\\tfor(int i = 1; i <= p.size(); i++)\\n\\t\\tdp[0][i] = p[i-1] == \\'*\\' && i-2 >= 0 ? dp[0][i-2] : 0;\\n\\t// when pattern length is zero\\n\\tfor(int i = 1; i <= s.size(); i++)\\n\\t\\tdp[i][0] = 0;\\n\\n\\tfor(int i = 1; i <= s.size(); i++) {\\n\\t\\tfor(int j = 1; j <= p.size(); j++) {\\n\\t\\t\\t// if the chars are same \\n\\t\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\telse {\\n\\t\\t\\t\\t// different chars are allowed only incase of wilcard chars\\n\\t\\t\\t\\tif(p[j-1] == \\'.\\')\\n\\t\\t\\t\\t\\tdp[i][j] = dp[i-1][j-1];\\n\\t\\t\\t\\t// when *\\n\\t\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t\\t// we have two choices, either use * or don\\'t use\\n\\t\\t\\t\\t\\tint with_star = (j - 2 >= 0) ? (p[j-2] == \\'.\\' || s[i-1] == p[j-2]) && dp[i-1][j] : 0;\\n\\t\\t\\t\\t\\tint without_star = (j - 2 >= 0) ? dp[i][j-2] : 0;\\n\\t\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// when chars are diff\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[s.size()][p.size()];\\n}  \\n\\nbool isMatch(string s, string p) {\\n\\t//return regexMatchDriver(s, p);\\n\\treturn regexMatchTabular(s, p);\\n}\\n```\n```\\n// TC: O(MN), SC: O(MN)\\nint regexMatch(vector<vector<int>>& dp, string& s, string& p, \\n\\t\\t\\t   int i, int j) {\\n\\tif(j < 0)\\n\\t\\treturn 0;\\n\\tif(i == 0 && j == 0)\\n\\t\\treturn dp[i][j] = 1;\\n\\t// if the length of any string has become 0\\n\\t// then it is not a match except if the char in pattern is *\\n\\tif(i == 0 && j > 0)\\n\\t\\treturn dp[i][j] = p[j-1] == \\'*\\' && regexMatch(dp, s, p, i, j-1);\\n\\t// pattern has finished but not the source\\n\\tif(i != 0 && j == 0)\\n\\t\\treturn dp[i][j] = 0;\\n\\n\\tif(dp[i][j] == -1) {\\n\\t\\t// initially mark it true\\n\\t\\tdp[i][j] = 1;\\n\\t\\t// if the chars are same\\n\\t\\tif(s[i-1] == p[j-1])\\n\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\telse {\\n\\t\\t\\t// when chars are different, then only if the pattern contains \\'.\\'\\n\\t\\t\\t// or \\'*\\' matching the string s then it is valid\\n\\t\\t\\tif(p[j-1] == \\'?\\')\\n\\t\\t\\t\\tdp[i][j] = regexMatch(dp, s, p, i-1, j-1);\\n\\t\\t\\telse if(p[j-1] == \\'*\\') {\\n\\t\\t\\t\\t// With * we can either try using it or not use it \\n\\t\\t\\t\\tint with_star = 0, without_star = 0;\\n\\t\\t\\t\\t// USE *\\n\\t\\t\\t\\t// if the pattern char match the * char of string source\\n\\t\\t\\t\\t// check for the previous char of source\\n\\t\\t\\t\\twith_star = regexMatch(dp, s, p, i-1, j);\\n\\n\\t\\t\\t\\t// DON\\'T USE * \\n\\t\\t\\t\\t// also covers the case when current pattern char is wildcard * and doesn\\'t match\\n\\t\\t\\t\\t// the char of source, try the char before \\'*\\' of pattern\\n\\t\\t\\t\\twithout_star = regexMatch(dp, s, p, i, j-1);\\n\\t\\t\\t\\tdp[i][j] = with_star || without_star;\\n\\t\\t\\t}\\n\\t\\t\\t// chars don\\'t match\\n\\t\\t\\telse \\n\\t\\t\\t\\tdp[i][j] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[i][j];\\n}\\n\\n// driver memoization function\\nbool regexMatchDriver(string& s, string& p) {\\n\\tvector<vector<int>> dp(s.size() + 1, vector<int>(p.size() + 1, -1));\\n\\tregexMatch(dp, s, p, s.size(), p.size());\\n\\treturn dp[s.size()][p.size()];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 371094,
                "title": "c-dp-solution-with-formula-attached",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        \\n        /**\\n         * dp[i][j]: Whether the substring of s ending at the index i can\\n         *           be matched by the subpattern of p ending at the index j.\\n         *\\n         *            | if s[i] == p[j] || p[j] == \\'?\\', dp[i - 1][j - 1]\\n         * dp[i][j] = | if p[j] == \\'*\\'                , dp[i - 1][j] || dp[i][j- 1]\\n         *            | otherwise                     , false\\n         */\\n        \\n        int len_s = s.length();\\n        int len_p = p.length();\\n        \\n        std::vector<std::vector<int>> \\n            dp(len_s + 1, std::vector<int>(len_p + 1, false));\\n        dp[0][0] = true;\\n        \\n        for (int i = 1 ; i <= len_p ; ++i) {\\n            if (p[i - 1] != \\'*\\') {\\n                break;\\n            }\\n            dp[0][i] = true;\\n        }\\n        \\n        for (int i = 1 ; i <= len_s ; ++i) {\\n            for (int j = 1 ; j <= len_p ; ++j) {\\n                if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[len_s][len_p];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string s, string p) {\\n        \\n        /**\\n         * dp[i][j]: Whether the substring of s ending at the index i can\\n         *           be matched by the subpattern of p ending at the index j.\\n         *\\n         *            | if s[i] == p[j] || p[j] == \\'?\\', dp[i - 1][j - 1]\\n         * dp[i][j] = | if p[j] == \\'*\\'                , dp[i - 1][j] || dp[i][j- 1]\\n         *            | otherwise                     , false\\n         */\\n        \\n        int len_s = s.length();\\n        int len_p = p.length();\\n        \\n        std::vector<std::vector<int>> \\n            dp(len_s + 1, std::vector<int>(len_p + 1, false));\\n        dp[0][0] = true;\\n        \\n        for (int i = 1 ; i <= len_p ; ++i) {\\n            if (p[i - 1] != \\'*\\') {\\n                break;\\n            }\\n            dp[0][i] = true;\\n        }\\n        \\n        for (int i = 1 ; i <= len_s ; ++i) {\\n            for (int j = 1 ; j <= len_p ; ++j) {\\n                if (s[i - 1] == p[j - 1] || p[j - 1] == \\'?\\') {\\n                    dp[i][j] = dp[i - 1][j - 1];\\n                } else if (p[j - 1] == \\'*\\') {\\n                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];\\n                }\\n            }\\n        }\\n        \\n        return dp[len_s][len_p];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347267,
                "title": "go-8ms-dp-solution",
                "content": "```\\nfunc isMatch(s string, p string) bool {\\n    // mem[i][j] means isMatch(s[:i], p[:j])\\n    mem := make([][]bool, len(s)+1)\\n    for i := range mem {\\n        mem[i] = make([]bool, len(p)+1)\\n    }\\n\\t\\n\\t// init bound, mem[n][0] is false while n > 0\\n    mem[0][0] = true\\n    for j := 1; j <= len(p); j++ {\\n        if p[j-1] == \\'*\\' {\\n            mem[0][j] = mem[0][j-1]\\n        }\\n    }\\n    \\n    for i := 1; i <= len(s); i++ {\\n        for j := 1; j <= len(p); j++ {\\n            if p[j-1] == \\'*\\' {\\n                mem[i][j] = mem[i][j-1] || mem[i-1][j]\\n            } else if p[j-1] == \\'?\\' || p[j-1] == s[i-1] {\\n                mem[i][j] = mem[i-1][j-1]\\n            }\\n        }\\n    }\\n    \\n    return mem[len(s)][len(p)]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isMatch(s string, p string) bool {\\n    // mem[i][j] means isMatch(s[:i], p[:j])\\n    mem := make([][]bool, len(s)+1)\\n    for i := range mem {\\n        mem[i] = make([]bool, len(p)+1)\\n    }\\n\\t\\n\\t// init bound, mem[n][0] is false while n > 0\\n    mem[0][0] = true\\n    for j := 1; j <= len(p); j++ {\\n        if p[j-1] == \\'*\\' {\\n            mem[0][j] = mem[0][j-1]\\n        }\\n    }\\n    \\n    for i := 1; i <= len(s); i++ {\\n        for j := 1; j <= len(p); j++ {\\n            if p[j-1] == \\'*\\' {\\n                mem[i][j] = mem[i][j-1] || mem[i-1][j]\\n            } else if p[j-1] == \\'?\\' || p[j-1] == s[i-1] {\\n                mem[i][j] = mem[i-1][j-1]\\n            }\\n        }\\n    }\\n    \\n    return mem[len(s)][len(p)]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 304264,
                "title": "c-dynamic-o-n-p-quadratic-complexity-80-beatings",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string pStr, string pPat) {\\n        \\n        int aStrLen = pStr.length();\\n        int aPatLen = pPat.length();\\n        \\n        int s = 0;\\n        int p = 0;\\n        \\n        int aGrid[aStrLen + 1][aPatLen + 1];\\n        \\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 1;\\n        \\n        if (pPat.size() > 0 && pPat[0] == \\'*\\') {\\n            for (s=0;s<pStr.size();s++) {\\n                aGrid[s + 1][0] = 1;\\n            }\\n            \\n            p = 0;\\n            while (p < pPat.size() && pPat[p] == \\'*\\') {\\n                aGrid[0][p + 1] = 1;\\n                ++p;\\n            }\\n        }\\n        \\n        for (p=1;p<=pPat.size();p++) {\\n            \\n            bool aNextStar = (p < (pPat.size()) && pPat[p] == \\'*\\');\\n            for (s=1;s<=pStr.size();s++) {\\n                if (((pPat[p-1] == pStr[s-1]) || (pPat[p-1] == \\'?\\')) && aGrid[s - 1][p - 1] == 1) {\\n                    aGrid[s][p] = 1;\\n                }\\n                \\n                if (pPat[p-1] == \\'*\\') {\\n                    if ((aGrid[s][p - 1] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                    if ((aGrid[s - 1][p] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                }\\n            }\\n        }   \\n        return aGrid[aStrLen][aPatLen] == 1;\\n    }\\n};\\n```\\n\\nThis solution was mainly arrived at by analyzing the grid of subproblems. To me, it is not intuitive why a \\'*\\' would have us search both up and left. It makes more sense after testing out some example problems. It\\'s entirely possible that a more efficient solution exists.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isMatch(string pStr, string pPat) {\\n        \\n        int aStrLen = pStr.length();\\n        int aPatLen = pPat.length();\\n        \\n        int s = 0;\\n        int p = 0;\\n        \\n        int aGrid[aStrLen + 1][aPatLen + 1];\\n        \\n        memset(aGrid, 0, sizeof(aGrid));\\n        \\n        aGrid[0][0] = 1;\\n        \\n        if (pPat.size() > 0 && pPat[0] == \\'*\\') {\\n            for (s=0;s<pStr.size();s++) {\\n                aGrid[s + 1][0] = 1;\\n            }\\n            \\n            p = 0;\\n            while (p < pPat.size() && pPat[p] == \\'*\\') {\\n                aGrid[0][p + 1] = 1;\\n                ++p;\\n            }\\n        }\\n        \\n        for (p=1;p<=pPat.size();p++) {\\n            \\n            bool aNextStar = (p < (pPat.size()) && pPat[p] == \\'*\\');\\n            for (s=1;s<=pStr.size();s++) {\\n                if (((pPat[p-1] == pStr[s-1]) || (pPat[p-1] == \\'?\\')) && aGrid[s - 1][p - 1] == 1) {\\n                    aGrid[s][p] = 1;\\n                }\\n                \\n                if (pPat[p-1] == \\'*\\') {\\n                    if ((aGrid[s][p - 1] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                    if ((aGrid[s - 1][p] == 1)) {\\n                        aGrid[s][p] = 1;\\n                    }\\n                }\\n            }\\n        }   \\n        return aGrid[aStrLen][aPatLen] == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273339,
                "title": "easy-to-read-java-dp-solution-by-adding-an-extra-character-to-string-head",
                "content": "This is a regular O(N^2) DP solution, but we do a trick by adding a character \"#\" to the head of both expressions s and p (or add any other character as long as it\\'s not in the given char set). Then, we don\\'t need to worry about edge cases where p[0] = \\'*\\' or \\'?\\', etc.\\n\\nRuntime: 9 ms, faster than 95.15% of Java online submissions for Wildcard Matching.\\n\\n```\\npublic boolean isMatch(String s, String p) {\\n\\ts = \"#\" + s;\\n\\tp = \"#\" + p;\\n\\tint sn = s.length(), pn = p.length();\\n\\tboolean[][] dp = new boolean[pn][sn];\\n\\n\\tdp[0][0] = true;\\n\\tfor (int i = 1; i < pn; i++) {\\n\\t\\tif (p.charAt(i) == \\'*\\') {\\n\\t\\t\\tfor (int j = 0; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j]) {\\n\\t\\t\\t\\t\\tfor (int k = j; k < sn; k++) {\\n\\t\\t\\t\\t\\t\\tdp[i][k] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = 1; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j-1]) {\\n\\t\\t\\t\\t\\tdp[i][j] = (p.charAt(i) == \\'?\\' || p.charAt(i) == s.charAt(j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[pn - 1][sn - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isMatch(String s, String p) {\\n\\ts = \"#\" + s;\\n\\tp = \"#\" + p;\\n\\tint sn = s.length(), pn = p.length();\\n\\tboolean[][] dp = new boolean[pn][sn];\\n\\n\\tdp[0][0] = true;\\n\\tfor (int i = 1; i < pn; i++) {\\n\\t\\tif (p.charAt(i) == \\'*\\') {\\n\\t\\t\\tfor (int j = 0; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j]) {\\n\\t\\t\\t\\t\\tfor (int k = j; k < sn; k++) {\\n\\t\\t\\t\\t\\t\\tdp[i][k] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfor (int j = 1; j < sn; j++) {\\n\\t\\t\\t\\tif (dp[i-1][j-1]) {\\n\\t\\t\\t\\t\\tdp[i][j] = (p.charAt(i) == \\'?\\' || p.charAt(i) == s.charAt(j));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[pn - 1][sn - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 199127,
                "title": "python-recursive-top-down",
                "content": "\\t\\tmemo = {}\\n        def helper(i, j):\\n            if j == len(p): return i == len(s)\\n            if i == len(s): return len(p[j:]) == p[j:].count(\"*\")\\n            \\n            if (i, j) in memo:\\n                return memo[i, j]\\n            \\n            if p[j] != \"*\":\\n                first_match = i < len(s) and p[j] in {s[i], \\'?\\'}\\n                ans = first_match and helper(i+1, j+1)\\n            \\n            else:\\n                ans = helper(i, j+1) or helper(i+1, j)\\n            \\n            memo[i, j] = ans\\n            return ans\\n        \\n        return helper(0, 0)\\n\\nUsing the idea from the 10: Regular Expression Matching. If p[j] is not *, compare the first character. If p[j] is *, either skip this pattern or skip the string character",
                "solutionTags": [],
                "code": "\\t\\tmemo = {}\\n        def helper(i, j):\\n            if j == len(p): return i == len(s)\\n            if i == len(s): return len(p[j:]) == p[j:].count(\"*\")\\n            \\n            if (i, j) in memo:\\n                return memo[i, j]\\n            \\n            if p[j] != \"*\":\\n                first_match = i < len(s) and p[j] in {s[i], \\'?\\'}\\n                ans = first_match and helper(i+1, j+1)\\n            \\n            else:\\n                ans = helper(i, j+1) or helper(i+1, j)\\n            \\n            memo[i, j] = ans\\n            return ans\\n        \\n        return helper(0, 0)\\n\\nUsing the idea from the 10: Regular Expression Matching. If p[j] is not *, compare the first character. If p[j] is *, either skip this pattern or skip the string character",
                "codeTag": "Python3"
            },
            {
                "id": 195140,
                "title": "java-dp-solutions-with-o-n-2-first-and-then-optimized-to-o-n-space-with-explanation",
                "content": "We can either match the strings by starting to compare first character of S to first character of P \\nOR\\nWe can start by comparing last character of S with last character of P and work our way backwards.\\nWe use the second approach as its easy to understand \\nLet \\ndp[i][j]  = true if substring of P ending at i-1 and S ending at j-1 matches.\\ndp[0][0] = true     Both P and S are empty.\\ndp[i][0] = dp[i-1][0] AND P[i-1]  = * , This means sequence of \\\\*\\'s will match the empty string.\\ndp[i][j] = dp[i-1][j-1]  if P[i-1] == S[j-1]  OR P[i-1] = \\'?\\'   \\ndp[i][j] = dp[i-1][j] | dp[i][j-1]   if P[i-1] = \\'\\\\*\\'\\n\\nUsing this recursive formula our program looks like.\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[p.length()+1][s.length()+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            if(p.charAt(i-1) == \\'*\\' && dp[i-1][0]){\\n                dp[i][0]=true;\\n            }\\n        }\\n        for(int i=1;i<=p.length();i++){\\n             for(int j=1;j<=s.length();j++){\\n                if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }else if(p.charAt(i-1) == \\'*\\'){\\n                    dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                }\\n             } \\n        }\\n        return dp[p.length()][s.length()];\\n    }\\n}\\n```\\n\\nWe note that value of  dp[i][j] depends on \\ndp[i-1][j]  Previous row same column \\ndp[i][j-1]  Same row previous column\\nd[i-1][j-1] Previous row , previous column.\\nBecause the current value only depends on previous values we can just use 1D array to store the values and an additional variable to store the dp[i-1][j-1] value.\\n\\n\\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            boolean prev;\\n            boolean prevPrev = true;\\n             for(int j=0;j<=s.length();j++){\\n                prev = dp[j];\\n                if(j == 0){\\n                    dp[j]&= p.charAt(i-1) == \\'*\\';\\n                }else{\\n                    if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                        dp[j]=prevPrev;\\n                    }else if(p.charAt(i-1) == \\'*\\'){\\n                        dp[j]|=dp[j-1];\\n                    }else{\\n                        dp[j]=false;\\n                    }\\n                }\\n                prevPrev = prev; \\n             } \\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] dp = new boolean[p.length()+1][s.length()+1];\\n        dp[0][0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            if(p.charAt(i-1) == \\'*\\' && dp[i-1][0]){\\n                dp[i][0]=true;\\n            }\\n        }\\n        for(int i=1;i<=p.length();i++){\\n             for(int j=1;j<=s.length();j++){\\n                if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                    dp[i][j]=dp[i-1][j-1];\\n                }else if(p.charAt(i-1) == \\'*\\'){\\n                    dp[i][j]=dp[i-1][j]||dp[i][j-1];\\n                }\\n             } \\n        }\\n        return dp[p.length()][s.length()];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[] dp = new boolean[s.length()+1];\\n        dp[0]=true;\\n        for(int i=1;i<=p.length();i++){\\n            boolean prev;\\n            boolean prevPrev = true;\\n             for(int j=0;j<=s.length();j++){\\n                prev = dp[j];\\n                if(j == 0){\\n                    dp[j]&= p.charAt(i-1) == \\'*\\';\\n                }else{\\n                    if(s.charAt(j-1) == p.charAt(i-1) || p.charAt(i-1) == \\'?\\'){\\n                        dp[j]=prevPrev;\\n                    }else if(p.charAt(i-1) == \\'*\\'){\\n                        dp[j]|=dp[j-1];\\n                    }else{\\n                        dp[j]=false;\\n                    }\\n                }\\n                prevPrev = prev; \\n             } \\n        }\\n        return dp[s.length()];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564889,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1566677,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570522,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1723420,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570407,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1568429,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1972353,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1868299,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1572611,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1571107,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1564889,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1566677,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570522,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1723420,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1570407,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1568429,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1972353,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1868299,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1572611,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1571107,
                "content": [
                    {
                        "username": "Imory2020",
                        "content": "I've figured out what the difference is, but would like to raise a question here in case others might also wonder it in the future. For reference, [Regular Expression Matching][1].\\n\\n\\n  [1]: https://oj.leetcode.com/problems/regular-expression-matching/"
                    },
                    {
                        "username": "stridemann",
                        "content": "Yes, the solution from REM problem could be a bit fixed/simplified and will do this job.\nI did REM using backtracking using recursion (and it was working there), but in this problem I got a timeouts with this approach. \nWe will also get timeouts if we use Regex way (on C#) (some cases takes 3min to process).\nI'm sure the \"DP table\" should be used in both this problems. It will simplify code many times.\n\nUPD. Dp table did it job, but slow as hell :) (no timeouts)"
                    },
                    {
                        "username": "et169tkm",
                        "content": "[@pradeepsinghjaroliya](/pradeepsinghjaroliya) Sounds like we can translate the input in this question to a regular expression, then use the previous solution to match it...."
                    },
                    {
                        "username": "practice_90",
                        "content": "[@fengli738](/fengli738) * in regular expression matches zero or more previous character. Here * can match any character any number of times"
                    },
                    {
                        "username": "pradeepsinghjaroliya",
                        "content": "[@fengli738](/fengli738) \nIn that question \na* means it can be \"\" or \"a\" or \"aa\" or \"aa.....\". (i.e. Matches zero or more of the preceding element.)\na* cant be \"ab\" it can only have zero or more preceding element in this case will be 'a';\n' * ' is not independent character consider (a*) as together.\n In this case ,it is independent.\nExample: \"aa*\"\nin this question it can be- \"aa\",\"aaa\",\"aaa....a\",\"aab\",\"aabb\",\"aaba\"\nAnd in that question it can be-\n \"a\",\"aa\",\"aaa\",\"aaaa...aa\"\n(Notice in that question it can be \"a\" but here it can't be \"aa\" is the compulsary part.)\n(Hope it help, was confused in both , sorry for my bad wording)"
                    },
                    {
                        "username": "fengli738",
                        "content": "what is the difference between this problem and https://leetcode.com/problems/regular-expression-matching/description/"
                    },
                    {
                        "username": "ArpitDhamija",
                        "content": "So, I just gave my Tech Round in a startup, applied offcampus.\\n\\nI have not done this question earlier. So just imagine my situation\\n\\nInterviewer asked me this as the 2nd ques. 1st ques was also hard but I know the solution of that.\\n\\nIn this, I somehow able to get to the recurssive solution with some of the hints given by interviewer. Its hell difficult according to me to get to the optimal solution for this question in an interview if you haven\\'t done that earlier. \\nLike I get to the recurssive solution. And time got over. As in 1 hr, 2 hard questions were asked and I have to code that also. \\n\\nThats all about this. \\n\\n"
                    },
                    {
                        "username": "HimanshuBani",
                        "content": "[@nushk_23](/nushk_23) this was asked in adobe to someone I know"
                    },
                    {
                        "username": "nushk_23",
                        "content": "which company though?"
                    },
                    {
                        "username": "iZERWAS",
                        "content": "ah tough luck man"
                    },
                    {
                        "username": "zdi561",
                        "content": "\"aa\" \"a\" is false but \"abcabczzzde\", \"*abc???de*\" is true , they are contradictory"
                    },
                    {
                        "username": "Minnikeswar18",
                        "content": "[@DarkMatter71](/DarkMatter71)  Indeed its false.. I think you are mistaken the pattern which is *abc???de*"
                    },
                    {
                        "username": "tanmaytaran",
                        "content": "\\'*\\' matches 0 or more characters but \\'?\\' matches exactly 1 character.\\nSo, for string \"aa\" and pattern \"a\", its false, which is correct. Now for string \"aa\" and any pattern like \"*\" || \"a*\" || \"*a\" || \"?*\" || \"*?\", etc. all are correct.\\n\\nNow if we look at string \"abcabczzzde\" with pattern \"abc???de\", \\n\\'abc\\' in pattern matches and leaves us with \"abczzzde\". Now 3 \\'?\\' need to match exactly 3 characters. So the next abc gets matched, hence we are now left with \"zzzde\" and in pattern \"de\". Thats why this is false."
                    },
                    {
                        "username": "DarkMatter71",
                        "content": "\"abcabczzzde\", \"abc???de\" is not true"
                    },
                    {
                        "username": "agrawalshubham1001",
                        "content": "this question having contradictory testcase.\n\"adceb\"   \"* a* b\" this is true why?\n\"a*c?b\"   \"acdcb\" then why tis is false?\n"
                    },
                    {
                        "username": "danielrrv",
                        "content": "[@Moonbeam8773](/Moonbeam8773) Doesn't make sense at all. \"The The first * must match an empty string\" There's no empty string at the beginning unless that the tester supposes it. Machines don't understand assumptions. The empty string is not there, then  it is not there. \nThe only way to pass this case in my opinion is assuming*(in software assumptions are risky) that the letters have priority over * because the * in first place makes the entire string fulfills the pattern."
                    },
                    {
                        "username": "Moonbeam8773",
                        "content": "\\* matches any character, including 0-length string. For \"\\*a\\*b\", the first \\* must match an empty string in order to have the \"a\" match up.  This leaves \"a\\*b\" to match \"adceb\". The first and last characters of the pattern and string match, so we remove them. This leaves the single \\* in the middle to match \"dce\", which it does. Therefore true.\n\n\"a\\*c?b\" start and end has to be \"a\" and \"b\" respectively. Which means we need to have \"\\*c?\" match \"cdc\". If the last \"?\" must match one character, that leaves \"\\*c\" to match \"cd\". Both last characters don't match, therefore it's false."
                    },
                    {
                        "username": "gargsaksham57",
                        "content": "could anybody explain why recursion+memoisation is giving tle"
                    },
                    {
                        "username": "raistar702614",
                        "content": "if you get a tle then most of the time this trick worls...declare the variable as unsigned int AND while passing the strings in the function pass them by reference.\\n\\nfor this qustion i tried memoization it passed 1774/1811\\n\\ni made the type as unsigned then it passed 1809/1811\\n\\ni passed the string by reference ...passed all cases with ahead of 85% in time and 15% in space "
                    },
                    {
                        "username": "thiscodeisugly",
                        "content": "I've written the Memoised version and it works.\nPlz check this - https://leetcode.com/problems/wildcard-matching/solutions/3230627/dp-memoization/?orderBy=most_votes"
                    },
                    {
                        "username": "user4523qT",
                        "content": "recursion is slow because of the nature of recursion. iterative solution is the fastest way"
                    },
                    {
                        "username": "c3lEsTIaL",
                        "content": "I can\\'t think about a greedy strategy that works here. Most solutions posted seemed like Brute Force or DP."
                    },
                    {
                        "username": "abhishek_kumar_12140040",
                        "content": "I am Trying t solve it by recursion + memorisation but on the last test case I am exceeding the memory limit. Is there any other method for this?"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "[@mahdichaben47](/mahdichaben47) pass the strings by reference"
                    },
                    {
                        "username": "mahdichaben47",
                        "content": "same problem they dont give me any test case but Memory Limit Exceeded"
                    },
                    {
                        "username": "sakshitiwari_01",
                        "content": "asked in Myanatomy in campus recruitment "
                    },
                    {
                        "username": "sevxin",
                        "content": "I submitted my code, and the result shows wrong when it applied on testcase:\"acdcb\", \"ac?b\". However, when I ran it in playground, I get the correct answer. What should I do? Could someone help me out?"
                    },
                    {
                        "username": "Okpatu",
                        "content": "C is not matched "
                    },
                    {
                        "username": "Ayush379",
                        "content": "I think that should give false, since ? means 1 character, but there are 2 needed. "
                    },
                    {
                        "username": "hzzyyy",
                        "content": "The highest voted solution is based on:\\nhttp://yucoding.blogspot.com/2013/02/leetcode-question-123-wildcard-matching.html\\n\\nIf it is not very obvious for you, I will try to explain the following two reasons why it works:\\n\\n**1. Greedy matching works, there is no need to backtrack more than once.** \\n\\nObviously, we need to use backtrack, but why Yu's solution didn't use a stack? The reason is, we only need to backtrack once to go back to the most recent '\\\\*'. Let me explain why. Given a string s and a pattern p, Consider the pattern string is divided into two substrings, p1 and p2, each of which starts with a '\\\\*'. With greedy matching, which is the case in Yu's solution, suppose p1 matches the *shortest head substring* of s, namely s1. Let's name its complement as s2, then we have s = s1 + s2 and p = p1+p2.\\n\\nThe statement is: \\n    *If p2 doesn't match s2 then p doesn't match s.* \\n\\nThe proof is the following:\\nIf s1 is the only head substring of s matching p1, then we don't have alternative matches for p1, then the only case is checked. \\nIf there is another head substring of s matching p1, namely s1' which must be longer than s1, then its complement, name s2' must be a tail substring of s2.  We know that p2 doesn't match s2, and p2 starts with '\\\\*', then we know p2 doesn't match any tail substring of s2, so p2 doesn't match s2' either.  To illustrate, consider:\\n\\n* p2 = \"*z\"\\n* s2 = \"abcd\"\\n\\np2 doesn't match s2, and p2 doesn't match any of \"bcd\", \"cd\", or \"d\". This is because in eyes of '\\\\*' \"abc\" \"bc\" \"c\" and \"\" are all the same. \\n\\n**2. C string all ends with a null char '\\\\0'.** \\nThis actually makes his problem easier to solve with C string, and if the inputs are std::string, the best way to do it is to use their c_str() to solve it. \\n\\nThe convenience is that when the pointer of pattern string p is at the end, pointing to '\\\\0', matching attempt with any char of string s (not including its end '\\\\0') will result in failure. This is equivalent to the following behavior:\\n   \\n*When characters in pattern string p are all matched but there are still characters remaining in string s, this matching attempt is a failure.*\\n\\nIf such logic is implemented in std::string, we need to use either the size of string or its end iterator."
                    }
                ]
            },
            {
                "id": 1732359,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1572947,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1572275,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1572186,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1571108,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1568869,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 1575021,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2074503,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2072054,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2068402,
                "content": [
                    {
                        "username": "aaks-ctrl",
                        "content": "Can someone help me figure this out ? \\n\\nwhile doing memoization , when declaring the dp as a global variable , I am getting TLE, but when passing that same dp by reference in the function call, it is getting passed, what could be the reason for this?"
                    },
                    {
                        "username": "BestluckJW",
                        "content": "These 2 are almost the same."
                    },
                    {
                        "username": "kranga",
                        "content": "Since the * character is different in this problem from the regular expression * (which operates on the previous character), this problem can be decomposed into a simple pattern easily. Here is the intuition for the problem:\\n\\n1. If the pattern is just * (assuming a pattern like a** b will presented), then the answer is trivially true for any input.\\n2. There are one of 4 types of patterns you can encounter. Taking the example of input pattern adceb, you can have patterns where (a) the first character is not * , (b) the last character is not * , (c) first and last is not * but we will just consider that to be pattern a and finally (d) both end points are *.\\n\\n(a) Take input pattern a * b. You can start matching adceb from the left until you encounter the first * . So then you are left with * b and dceb in the input. This becomes case (b)\\n\\n(b) Take the incput pattern * a * b  You can start matching from the right until you encounter the first * and you are left with adce with pattern * a * \\n\\n(c) Take input a * b - as shown above this becomes case (b) easily.\\n\\n(d) * ce * as pattern \\n\\nThe ? character is not optional and therefore a non * char. \\nEssentially by working off non-* characters we are left with a pattern of * on both ends. We now make a single pass through the pattern and create sequences of contiguous non-* characters. \\n\\nExample pattern * a * be? * ac * has three sub-sequences of a, be? and ac.\\nSimple scan the input from left to right to see if these subsequences can be matched. An input for the above pattern of\\ndeabexdefacde would match\\nde (a) (bex) def (ac) de and therefore would return true. \\n\\n"
                    },
                    {
                        "username": "KeerthanaJetty",
                        "content": "https://www.geeksforgeeks.org/wildcard-pattern-matching/ "
                    },
                    {
                        "username": "teddyyyy",
                        "content": "I think I saw pretty much the same code with many peoples' answers, basically DP, with 2 rows of storage.\\n\\nmany people reported timing out on the large case of s= \"a\" x 32316  , p = \"*\" + \"a\"x 32317 + \"*\"\\n\\n\\nI really can't figure out how it could be reduced further. on eclipse the input does come back in about 2 seconds"
                    },
                    {
                        "username": "mythjill",
                        "content": "I tried the following, and could not understand why\\n\\ntest case 121*  121*?, result is false\\n\\ntest case  1211 121*?, result is true\\n\\nany comment?"
                    },
                    {
                        "username": "fscyhcyh",
                        "content": "Could someone please explain why there are duplicate checks in recursion approach, so that we need memo? It took me for a while but I still don\\'t get it. Thank you"
                    },
                    {
                        "username": "satendra_04",
                        "content": " confuse ,if in second string we got * then why there is need to check further ...we can directly return true?\\n"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "so they want us to write a finite automata"
                    },
                    {
                        "username": "user4488fC",
                        "content": "Examples are not good. "
                    }
                ]
            },
            {
                "id": 2047390,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2038477,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2025544,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2009810,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 2007373,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1994279,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1966498,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1965624,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1960244,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1947451,
                "content": [
                    {
                        "username": "scarletspeedster2",
                        "content": "Pattern needs pre-processing, remove consecutive \"*\"  from pattern "
                    },
                    {
                        "username": "vansh22559",
                        "content": "Aah faced 7 wrong submissions but still got bit of dopamine when it got passed on 8th attempt.\\nProblem had many edge cases, definitely a difficult one to solve but that\\'s where the fun is."
                    },
                    {
                        "username": "user8272RT",
                        "content": "Got here after doing [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/), so this was solvable."
                    },
                    {
                        "username": "dvakar",
                        "content": "1. s =  `\"aab\"`, p =  `\"c*a*b\"`\n2. s =  `\"adceb\"`, p =  `\"*a*b\"`\n3. s =  `\"abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab\"`, p =  `\"*aabb***aa**a******aa*\"`"
                    },
                    {
                        "username": "dmigalin",
                        "content": "What is wrong with 983 testcase?\\n\\ns = \"acdcb\"\\np = \"a*c?b\"\\n\\nMy answer is True, because p contains \"*\" -  the symbol that matches any sequence.\\nExpected answer is False.\\n\\nWhats wrong?"
                    },
                    {
                        "username": "ahrix268",
                        "content": "`*` matches any sequence, it's true. but it doesn't mean you can return true as soon as you meet `*`\n\nexample -> \nafter `*` in the pattern there is a character, \"c\". so this \"c\" must match with one \"c\" from the check string.\nif \"c\" in the pattern matches the first \"c\" in the check string, we have:\n  \"a\" = \"a\"\n  `*` = \"\" (empty)\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"dcb\" -> not possible\nif \"c\" in the pattern matches the second \"c\" in the check string:\n  \"a\" = \"a\"\n  `*` = \"cd\"\n  \"c\" = \"c\"\n  -> then \"?b\" must match \"b\" -> not possible, too\n\ntherefore, expected answer is false"
                    },
                    {
                        "username": "aq41",
                        "content": "so dumbass. why the hell * should be equal to empty string"
                    },
                    {
                        "username": "Asha_nagar",
                        "content": "leetcode please provide some solid example input"
                    },
                    {
                        "username": "dpvidyasagar",
                        "content": "Hi,\\nPlease help! this code is failing in last test case, I don\\'t know why \\nclass Solution {\\nprivate:\\n    bool find(int i,int j,string s,string p,vector<vector<int>>& dp){\\n        if(i<0 || j<0){\\n            if(i<0 && j<0) return true;\\n            if(i>=0 && j<0) return false;\\n            if(i<0 && j>=0){\\n                while(j>=0){\\n                    if(p[j--]!= \\'*\\') return false;\\n                }\\n                return true;\\n            }\\n            return false;\\n        }\\n        if(dp[i][j] != -1) return dp[i][j];\\n        if(s[i] == p[j] || p[j] == \\'?\\') return dp[i][j] = find(i-1,j-1,s,p,dp);\\n        if(p[j] == \\'*\\') return dp[i][j] = find(i,j-1,s,p,dp) || find(i-1,j,s,p,dp);\\n        return dp[i][j] = false;\\n    }\\npublic:\\n    bool isMatch(string s, string p) {\\n        int n = s.size(),m = p.size();\\n        if(n == 0 && m == 0) return true;\\n        vector<vector<int>>dp(n,vector<int>(m,-1));\\n        return find(n-1,m-1,s,p,dp);\\n    }\\n};\\n"
                    },
                    {
                        "username": "simply_arko",
                        "content": "[Pic](https://drive.google.com/file/d/1VdNsh1Pi9KF7ITzvl-ImFqjDS08dcOrQ/view?usp=drive_link)\\nHuhhhh!.....What is this test case???"
                    },
                    {
                        "username": "asmithey",
                        "content": "I have no idea, but I\\'ve seen this before on other test cases. Has anyone been able to solve it recently, or is the problem just broken?"
                    },
                    {
                        "username": "pratikshaw8",
                        "content": "Same question. WTH is this?\\n"
                    },
                    {
                        "username": "khibach2004",
                        "content": "little hint for u guys this is exactly the same to regular expression matching the only different is the condition if that\\'s it\\nai ng Vi\\u1EC7t th\\xEC \\u0111\\u1ECDc kh\\xFAc n\\xE0y nha: c\\xE1i b\\xE0i n\\xE0y y chang b\\xE0i 10 leetcode n\\xF3 ch\\u1EC9 kh\\xE1c m\\u1ED7i \\u0111\\xECu ki\\u1EC7n ch\\u1ED7 if thoi c\\xF2n l\\u1EA1i y h\\u1EC7t"
                    }
                ]
            },
            {
                "id": 1903193,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1872982,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1868098,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1864599,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1863944,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1847569,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1815659,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1780717,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1769127,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            },
            {
                "id": 1741982,
                "content": [
                    {
                        "username": "bedmuthaapoorv",
                        "content": "I was scared of this question for too long, for nothing tbh"
                    },
                    {
                        "username": "prakharu040",
                        "content": "My solution is failing on 1811/1811 case can anyone help as to why is this happening\\n\\n\\nclass Solution {\\n    HashMap<String,Boolean> map;\\n    \\n    public boolean regex(int i,int j,String s,String p)\\n    {\\n        if(j<0)\\n        {\\n            return i<0;\\n        }\\n        String key = String.valueOf(i)+\"#\"+String.valueOf(j);\\n        if(map.containsKey(key))\\n            return map.get(key);\\n        boolean charEquals = false;\\n        if(i>=0 && (s.charAt(i) == p.charAt(j) || p.charAt(j) == \\'?\\'))\\n        {\\n            if(regex(i-1,j-1,s,p))\\n            {\\n                map.put(key,true);\\n                return true;\\n            }\\n                \\n        }\\n        else if(p.charAt(j) == \\'*\\')\\n        {\\n            for(int m =0;m<=i+1;m++)\\n            {\\n                if(regex(i-m,j-1,s,p))\\n                {\\n                    map.put(key,true);\\n                    return true;\\n                }\\n            }\\n        }\\n        map.put(key,false);\\n        return false;\\n            \\n    }\\n    \\n    \\n    public boolean isMatch(String s, String p) {\\n        map = new HashMap<>();\\n        return regex(s.length()-1,p.length()-1,s,p);\\n    }\\n}"
                    },
                    {
                        "username": "prnvvarshney",
                        "content": "public class Solution {\\n    public boolean isMatch(String s, String p) {\\n        boolean[][] match=new boolean[s.length()+1][p.length()+1];\\n        match[s.length()][p.length()]=true;\\n        for(int i=p.length()-1;i>=0;i--){\\n            if(p.charAt(i)!=\\'*\\')\\n                break;\\n            else\\n                match[s.length()][i]=true;\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            for(int j=p.length()-1;j>=0;j--){\\n                if(s.charAt(i)==p.charAt(j)||p.charAt(j)==\\'?\\')\\n                        match[i][j]=match[i+1][j+1];\\n                else if(p.charAt(j)==\\'*\\')\\n                        match[i][j]=match[i+1][j]||match[i][j+1];\\n                else\\n                    match[i][j]=false;\\n            }\\n        }\\n        return match[0][0];\\n    }\\n}"
                    },
                    {
                        "username": "normanlmfung",
                        "content": "I'm trying to wrap my mind around this: If the current pattern character is a star (p[0] == '*'), then there are two possible situations:\n        a. The star matches no characters, and hence the answer is isMatch(s, p[1:]).\n        b. The star matches one or more characters, and so the answer is isMatch(s[1:], p).\"\nCan someone give an example of input s and p where \"hence the answer is isMatch(s, p[1:])\"?\n\nTo understand case (a), first note that explaination \"* matches no character\" can be misleading. \n            s = \"adceb\"\n            p = \"*a*b\"\n\n            It's just saying solution is either in:\n                s = 'adceb'         <-- case (a) will evaluate to True\n                p = 'a*b'\n                    or\n                s = 'dceb'          <-- case (b) will evaluate to False\n                p = '*a*b'\n\n        To understand case (b)\n            s = \"a9absfkls\"\n            p = \"*abs*\"\n            helper(s[1:], p) True --> s[1:] = '9absfkls' ('*a': Case when the star matches one or more character)\n            helper(s, p[1:]) False --> p[1:] = 'abs*'"
                    },
                    {
                        "username": "hunnyjain711",
                        "content": "In the testcase s=\"abcabczzzde\", p=\"*abc???de*\" are they matching \"*abc\" with \"abcabc\"?\n\nedit: I guess yes, in this test case\ns=\"abefcdgiescdfimde\", p=\"ab*cd?i*de\"  leading suffix after \"*de\" are matched to0."
                    },
                    {
                        "username": "Bold_Bruiser",
                        "content": "s=\"aab\" p=\"a*a*b\"\nhow this is false??"
                    },
                    {
                        "username": "jayanth-c137",
                        "content": "` class Solution {`\\n`public:`\\n  `int tr(string& s,string& p,int i,int j,vector<vector<int>>& dp){`\\n      `  // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;`\\n   `     if(dp[i][j]!=-1)return dp[i][j];`\\n       ` if(j>=p.length() && i<s.length())return dp[i][j]=0;`\\n     `   if(j==p.length() && i==s.length()){`\\n       ` return dp[i][j]=1;`\\n       ` }`\\n    `    if(i>=s.length() && j<p.length()){`\\n         `   for(;j<p.length();j++){`\\n             `   if(p[j]!=\\'*\\')return dp[i][j]=0;`\\n         `   }`\\n       `     return dp[i][j]=1;`\\n     `   }`\\n        \\n        int ans;\\n        if(p[j]==\\'?\\'){\\n            ans = tr(s,p,i+1,j+1,dp);\\n                return dp[i][j]=ans;\\n        }\\n        else if(p[j]==\\'*\\'){\\n           int ans1 = tr(s,p,i,j+1,dp);\\n            ans = tr(s,p,i+1,j,dp);\\n                return dp[i][j]=(ans|ans1);\\n        }\\n        else {\\n            if(s[i]!=p[j]){\\n            return dp[i][j]=0;\\n            }\\n            else{\\n                ans = tr(s,p,i+1,j+1,dp);\\n            return dp[i][j]=ans;\\n            } \\n        }\\n\\n    }\\n    bool isMatch(string s, string p) {\\n        vector<vector<int>> dp(2001,vector<int>(2001,-1));\\n        if(s==\"\"){\\n            int i;\\n            for(i=0;i<p.length();i++){\\n                if(p[i]!=\\'*\\')return false;\\n            }\\n            return true;\\n        }\\n        int ans = tr(s,p,0,0,dp);\\n        if(ans==1)return true;\\n        else return false;\\n    }`\\n`};`\\n\\n\\ni\\'m getting tle for this , can someone please help\\n"
                    },
                    {
                        "username": "satyam_0405",
                        "content": "Please give 1 or 2 more testcases so that we can clearly understand the usage of  \\'*\\' in detail"
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "clumsy questiion"
                    },
                    {
                        "username": "rawan9000",
                        "content": "Any answer please , Why the expected result is false  not true incase  s = \"acdcb\" and p = `  a*c?b` , \nalthough the mentioned point that '*' Matches any sequence of characters (including the empty sequence)."
                    },
                    {
                        "username": "SleekPanther",
                        "content": "I read it like this going left to right in the pattern:\\n1) `a` from pattern matches the 1st \"a\" from the string\\n2) `*` from pattern can match \"cd\", characters 2 and 3 from the string\\n3) `c` from pattern matches \"c\", the 4th character in the string\\n4) `?` from pattern matches any SINGLE character, the last \"b\"\\n5) `b` from pattern doesn\\'t match anything as we ran out"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Preorder Traversal",
        "question_content": "<p>Given the <code>root</code> of a binary tree, return <em>the preorder traversal of its nodes&#39; values</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" style=\"width: 125px; height: 200px;\" />\n<pre>\n<strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,2,3]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 100]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Recursive solution is trivial, could you do it iteratively?</p>\n",
        "solutions": [
            {
                "id": 45266,
                "title": "accepted-iterative-solution-in-java-using-stack",
                "content": "Note that in this solution only right children are stored to stack.\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n\\t\\tList<Integer> list = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> rights = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tlist.add(node.val);\\n\\t\\t\\tif (node.right != null) {\\n\\t\\t\\t\\trights.push(node.right);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tif (node == null && !rights.isEmpty()) {\\n\\t\\t\\t\\tnode = rights.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return list;\\n    }",
                "solutionTags": [],
                "code": "Note that in this solution only right children are stored to stack.\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n\\t\\tList<Integer> list = new LinkedList<Integer>();\\n\\t\\tStack<TreeNode> rights = new Stack<TreeNode>();\\n\\t\\twhile(node != null) {\\n\\t\\t\\tlist.add(node.val);\\n\\t\\t\\tif (node.right != null) {\\n\\t\\t\\t\\trights.push(node.right);\\n\\t\\t\\t}\\n\\t\\t\\tnode = node.left;\\n\\t\\t\\tif (node == null && !rights.isEmpty()) {\\n\\t\\t\\t\\tnode = rights.pop();\\n\\t\\t\\t}\\n\\t\\t}\\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45273,
                "title": "very-simple-iterative-python-solution",
                "content": "Classical usage of stack's LIFO feature, very easy to grasp:\\n\\n    \\n    def preorderTraversal(self, root):\\n        ret = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                ret.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return ret",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "Classical usage of stack's LIFO feature, very easy to grasp:\\n\\n    \\n    def preorderTraversal(self, root):\\n        ret = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                ret.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 3025711,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        head = root\\n        stack = []\\n        res = []\\n\\n        while head or stack:\\n            if head:\\n                res.append(head.val)\\n                if head.right:\\n                    stack.append(head.right)\\n                head = head.left\\n            else:\\n                head = stack.pop()\\n\\n        return res        \\n```\\n\\n```Java []\\nclass Solution {\\n    List<Integer> preorderTraverse(TreeNode root,List<Integer> list) {\\n\\n        if(root==null)\\n            return list;\\n        list.add(root.val);\\n        preorderTraverse(root.left,list);\\n        preorderTraverse(root.right,list);\\n        return list;\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        list = preorderTraverse(root,list);\\n        return list;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        head = root\\n        stack = []\\n        res = []\\n\\n        while head or stack:\\n            if head:\\n                res.append(head.val)\\n                if head.right:\\n                    stack.append(head.right)\\n                head = head.left\\n            else:\\n                head = stack.pop()\\n\\n        return res        \\n```\n```Java []\\nclass Solution {\\n    List<Integer> preorderTraverse(TreeNode root,List<Integer> list) {\\n\\n        if(root==null)\\n            return list;\\n        list.add(root.val);\\n        preorderTraverse(root.left,list);\\n        preorderTraverse(root.right,list);\\n        return list;\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        list = preorderTraverse(root,list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45466,
                "title": "c-iterative-recursive-and-morris-traversal",
                "content": "There are three solutions to this problem.\\n\\n 1. Iterative solution using stack --- `O(n)` time and `O(n)` space;\\n 2. Recursive solution --- `O(n)` time and `O(n)` space (function call stack);\\n 3. Morris traversal --- `O(n)` time and `O(1)` space.\\n\\n**Iterative solution using stack**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                nodes.push_back(root -> val);\\n                if (root -> right) {\\n                    todo.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = todo.top();\\n                todo.pop();\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\n**Recursive solution**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        nodes.push_back(root -> val);\\n        preorder(root -> left, nodes);\\n        preorder(root -> right, nodes);\\n    }\\n};\\n```\\n\\n**Morris traversal**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            if (root) {\\n                nodes.push_back(root -> val);\\n                if (root -> right) {\\n                    todo.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = todo.top();\\n                todo.pop();\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector<int>& nodes) {\\n        if (!root) {\\n            return;\\n        }\\n        nodes.push_back(root -> val);\\n        preorder(root -> left, nodes);\\n        preorder(root -> right, nodes);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45468,
                "title": "3-different-solutions",
                "content": "Recursive method with List as returning value:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpre.addAll(preorderTraversal(root.left));\\n    \\t\\tpre.addAll(preorderTraversal(root.right));\\n    \\t\\treturn pre;\\n    \\t}\\n\\nRecursive method with Helper method to have a List as paramater, so we can modify the parameter and don't have to instantiate a new List at each recursive call:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tpreHelper(root,pre);\\n    \\t\\treturn pre;\\n    \\t}\\n    \\tpublic void preHelper(TreeNode root, List<Integer> pre) {\\n    \\t\\tif(root==null) return;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpreHelper(root.left,pre);\\n    \\t\\tpreHelper(root.right,pre);\\n    \\t}\\n\\nIterative method with Stack:\\n\\n    \\tpublic List<Integer> preorderIt(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tStack<TreeNode> tovisit = new Stack<TreeNode>();\\n    \\t\\ttovisit.push(root);\\n    \\t\\twhile(!tovisit.empty()) {\\n    \\t\\t\\tTreeNode visiting = tovisit.pop();\\n    \\t\\t\\tpre.add(visiting.val);\\n    \\t\\t\\tif(visiting.right!=null) tovisit.push(visiting.right);\\n    \\t\\t\\tif(visiting.left!=null) tovisit.push(visiting.left);\\n    \\t\\t}\\n    \\t\\treturn pre;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive method with List as returning value:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpre.addAll(preorderTraversal(root.left));\\n    \\t\\tpre.addAll(preorderTraversal(root.right));\\n    \\t\\treturn pre;\\n    \\t}\\n\\nRecursive method with Helper method to have a List as paramater, so we can modify the parameter and don't have to instantiate a new List at each recursive call:\\n\\n    \\tpublic List<Integer> preorderTraversal(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tpreHelper(root,pre);\\n    \\t\\treturn pre;\\n    \\t}\\n    \\tpublic void preHelper(TreeNode root, List<Integer> pre) {\\n    \\t\\tif(root==null) return;\\n    \\t\\tpre.add(root.val);\\n    \\t\\tpreHelper(root.left,pre);\\n    \\t\\tpreHelper(root.right,pre);\\n    \\t}\\n\\nIterative method with Stack:\\n\\n    \\tpublic List<Integer> preorderIt(TreeNode root) {\\n    \\t\\tList<Integer> pre = new LinkedList<Integer>();\\n    \\t\\tif(root==null) return pre;\\n    \\t\\tStack<TreeNode> tovisit = new Stack<TreeNode>();\\n    \\t\\ttovisit.push(root);\\n    \\t\\twhile(!tovisit.empty()) {\\n    \\t\\t\\tTreeNode visiting = tovisit.pop();\\n    \\t\\t\\tpre.add(visiting.val);\\n    \\t\\t\\tif(visiting.right!=null) tovisit.push(visiting.right);\\n    \\t\\t\\tif(visiting.left!=null) tovisit.push(visiting.left);\\n    \\t\\t}\\n    \\t\\treturn pre;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 45290,
                "title": "python-solutions-recursively-and-iteratively",
                "content": "        \\n    # recursively\\n    def preorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            res.append(root.val)\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n    \\n    # iteratively\\n    def preorderTraversal(self, root):\\n        stack, res = [root], []\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    # recursively\\n    def preorderTraversal1(self, root):\\n        res = []\\n        self.dfs(root, res)\\n        return res\\n        \\n    def dfs(self, root, res):\\n        if root:\\n            res.append(root.val)\\n            self.dfs(root.left, res)\\n            self.dfs(root.right, res)\\n    \\n    # iteratively\\n    def preorderTraversal(self, root):\\n        stack, res = [root], []\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3022021,
                "title": "c-easy-beats100-3-approach-with-explaination",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Intuition\\n3 ways to solve this problem\\n\\n# Approach\\n**1.Recursive approach**\\n  - Check if the current node is empty or Null.\\n  - Display the data part of the root (or current node)\\n  - Traverse the left subtree by recursively calling the preorder function.\\n  - Traverse the right subtree by recursively calling the preorder function.\\n  \\n**2.Iterative approach**\\n  - Create an empty stack and push the root node to it.\\n  - Do the following while the stack is not empty\\n      1. Pop the top item from the stack and display it.\\n      2. Push the right child of the popped item to the stack.\\n      3. Push the left child of the popped item to the stack.\\n# Complexity\\n   - **Time complexity**:O(N)\\n   - **Space complexity**:O(H)H=height of binary tree\\n\\n  **3.Morris traversal**\\n - Initialize current as root\\n - While current is not null:\\n     1. If current does not have a left child:\\n          (i) Print current\\'s data.\\n          (ii) Go to the right, i.e., current = current.right\\n     2. Else:\\n           (i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n           (ii)Go to this left child, i.e., current = current.left.\\n\\n# Complexity\\n- **Time complexity**:O(N)\\n- **Space complexity**:O(1)\\n\\n\\n \\n![oms.png](https://assets.leetcode.com/users/images/f5a39b74-fd4e-4f2c-bfb2-7737e7f09f35_1673225202.6658852.png)\\n\\n# Code(Recursuve approach)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root){\\n            ans.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(iterative approach)\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*>st;\\n        while (root || !st.empty()) {\\n            if (root) {\\n                ans.push_back(root -> val);\\n                if (root -> right) {\\n                    st.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = st.top();\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Code(Morris approach)\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```\\n\\nIf you really found my solution helpful **please upvote it**, as it motivates me to post such kind of codes.\\n*Let me know in comment if i can do bette*r.\\nLets connect on [LINKDIN](https://www.linkedin.com/in/mahesh-vishnoi-a4a47a193/).\\n\\n",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root){\\n            ans.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*>st;\\n        while (root || !st.empty()) {\\n            if (root) {\\n                ans.push_back(root -> val);\\n                if (root -> right) {\\n                    st.push(root -> right);\\n                }\\n                root = root -> left;\\n            } else {\\n                root = st.top();\\n                st.pop();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> nodes;\\n        while (root) {\\n            if (root -> left) {\\n                TreeNode* pre = root -> left;\\n                while (pre -> right && pre -> right != root) {\\n                    pre = pre -> right;\\n                }\\n                if (!pre -> right) {\\n                    pre -> right = root;\\n                    nodes.push_back(root -> val);\\n                    root = root -> left;\\n                } else {\\n                    pre -> right = NULL;\\n                    root = root -> right;\\n                }\\n            } else {\\n                nodes.push_back(root -> val);\\n                root = root -> right;\\n            }\\n        }\\n        return nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45493,
                "title": "accepted-code-explaination-with-algo",
                "content": " 1. Create an empty stack, Push root node to the stack.\\n 2. Do following while stack is not empty.\\n\\n 2.1. pop an item from the stack and print it.\\n \\n 2.2. push the right child of popped item to stack.\\n\\n 2.3. push the left child of popped item to stack.\\n\\n \\n\\n\\n>     class Solution {\\n>     public:\\n>         vector<int> preorderTraversal(TreeNode *root) {\\n>             stack<TreeNode*> nodeStack;\\n>             vector<int> result;\\n>             //base case\\n>             if(root==NULL)\\n>             return result;\\n>             nodeStack.push(root);\\n>             while(!nodeStack.empty())\\n>             {\\n>                 TreeNode* node= nodeStack.top();\\n>                 result.push_back(node->val);\\n>                 nodeStack.pop();\\n>                 if(node->right)\\n>                 nodeStack.push(node->right);\\n>                 if(node->left)\\n>                 nodeStack.push(node->left);\\n>             }\\n>             return result;\\n>             \\n>         }\\n>     };",
                "solutionTags": [],
                "code": "class Solution {\\n>     public:\\n>         vector<int> preorderTraversal(TreeNode *root) {\\n>             stack<TreeNode*> nodeStack;\\n>             vector<int> result;\\n>             //base case\\n>             if(root==NULL)\\n>             return result;\\n>             nodeStack.push(root);\\n>             while(!nodeStack.empty())\\n>             {\\n>                 TreeNode* node= nodeStack.top();\\n>                 result.push_back(node->val);\\n>                 nodeStack.pop();\\n>                 if(node->right)\\n>                 nodeStack.push(node->right);\\n>                 if(node->left)\\n>                 nodeStack.push(node->left);\\n>             }",
                "codeTag": "Java"
            },
            {
                "id": 45435,
                "title": "4-solutions-in-c",
                "content": "\\n    // recursive, but it's trivial...\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preTraversal(root, v);\\n        return v;\\n    }\\n    void preTraversal(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        v.push_back(root->val);\\n        preTraversal(root->left, v);\\n        preTraversal(root->right, v);\\n    }\\n    \\n    \\n    // iterate, use stack to imitate recursive\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            if(temp->right) s.push(temp->right);\\n            if(temp->left) s.push(temp->left);\\n        }\\n    }\\n    \\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                v.push_back(temp->val);\\n                if(temp->right) s.push(temp->right);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n        };\\n    }\\n    \\n    // morris traversal\\uff0c O(1) space\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    v.push_back(temp->val);\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n    // recursive, but it's trivial...\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preTraversal(root, v);\\n        return v;\\n    }\\n    void preTraversal(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        v.push_back(root->val);\\n        preTraversal(root->left, v);\\n        preTraversal(root->right, v);\\n    }\\n    \\n    \\n    // iterate, use stack to imitate recursive\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        while(!s.empty()){\\n            temp = s.top();\\n            s.pop();\\n            v.push_back(temp->val);\\n            if(temp->right) s.push(temp->right);\\n            if(temp->left) s.push(temp->left);\\n        }\\n    }\\n    \\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root;\\n        stack<TreeNode*> s;\\n        while(true){\\n            while(temp){\\n                v.push_back(temp->val);\\n                if(temp->right) s.push(temp->right);\\n                temp = temp->left;\\n            }\\n            if(s.empty()) break;\\n            temp = s.top();\\n            s.pop();\\n        };\\n    }\\n    \\n    // morris traversal\\uff0c O(1) space\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        if(!root) return v;\\n        TreeNode* temp = root, *prev;\\n        while(temp){\\n            if(!temp->left){\\n                v.push_back(temp->val);\\n                temp = temp->right;\\n            }else{\\n                prev = temp->left;\\n                while(prev->right&&(prev->right != temp))\\n                    prev = prev->right;\\n                if(!prev->right){\\n                    v.push_back(temp->val);\\n                    prev->right = temp;\\n                    temp = temp->left;\\n                }else{\\n                    prev->right = NULL;\\n                    temp = temp->right;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45417,
                "title": "preorder-traversal-java-solution-both-iteration-and-recursion",
                "content": "    // recursive\\n    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root != null){\\n                result.add(root.val);\\n                result.addAll(preorderTraversal(root.left));\\n                result.addAll(preorderTraversal(root.right));\\n            }\\n            return result;\\n        }\\n    }\\n    \\n    // iterative\\n    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root == null) return result;\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            stack.push(root);\\n            while (!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                result.add(node.val);\\n                if (node.right != null) stack.push(node.right);\\n                if (node.left != null) stack.push(node.left);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (root != null){\\n                result.add(root.val);\\n                result.addAll(preorderTraversal(root.left));\\n                result.addAll(preorderTraversal(root.right));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45259,
                "title": "easy-c-solution-using-stack",
                "content": "    class Solution {\\n    public:\\n    vector<int> preorderTraversal(TreeNode *root) {\\n        if (root==NULL) {\\n            return vector<int>();\\n        }\\n        vector<int> result;\\n        stack<TreeNode *> treeStack;\\n        treeStack.push(root);\\n        while (!treeStack.empty()) {\\n            TreeNode *temp = treeStack.top();\\n            result.push_back(temp->val);\\n            treeStack.pop();\\n            if (temp->right!=NULL) {\\n                treeStack.push(temp->right);\\n            }\\n            if (temp->left!=NULL) {\\n                treeStack.push(temp->left);\\n            }\\n        }\\n        return result;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> preorderTraversal(TreeNode *root) {\\n        if (root==NULL) {\\n            return vector<int>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3022675,
                "title": "java-solution-with-explanation",
                "content": "\\n\\n# Approach and Explanation ( Recursive )\\n<!-- Describe your approach to solving the problem. -->\\n1. A preorder traversal is a traversal order in which the root node is visited first, followed by the left subtree, and then the right subtree. `The traversal order for a node is: root, left, right.`\\n\\n2. The code first defines a List called result which will store the preorder traversal of the tree. It then calls a helper function traversal which takes in a TreeNode called root and the result List.\\n\\n3. The traversal function first checks if the root is null. If it is, it returns without doing anything. If the root is not null, it adds the root\\'s value to the result List. It then calls itself recursively on the root\\'s left child and then on the root\\'s right child.\\n\\n4. This recursive function will continue until it reaches a leaf node (a node with no children), at which point it will start returning and adding the values of the nodes it traversed on the way back up the recursive stack to the result List.\\n\\n5. At the end of the function, the result List will contain the preorder traversal of the tree.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public List<Integer> preorderTraversal(TreeNode root) {\\n       // Create a list to store the traversal result\\n\\tList<Integer> result = new ArrayList<>();\\n\\t\\n       // Call helper method to perform the traversal\\n\\ttraversal(root, result);\\n\\t\\n       // Return the result\\n\\treturn result;\\n   }\\n   \\n   // Helper method to perform the preorder traversal\\n   public void traversal(TreeNode root, List<Integer> result) {\\n       // Return if the current node is null\\n\\tif(root == null) return;\\n\\t\\n       // Add the current node\\'s value to the result list\\n\\tresult.add(root.val);\\n\\t\\n       // Recursively traverse the left and right subtrees\\n\\ttraversal(root.left, result);\\n\\ttraversal(root.right, result);\\n   }\\n}\\n```\\n# Approach and Explanation ( Iterative )\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. This code is implementing the pre-order traversal of a binary tree. In a pre-order traversal, the root node is visited first, then the left subtree, and then the right subtree.\\n\\n2. The code is using a stack to store nodes as it traverses the tree. A stack is a Last-In-First-Out (LIFO) data structure, which means that the last element added to the stack will be the first one to be removed. This property is useful for implementing a tree traversal because it allows us to process the nodes in the correct order (i.e., root node before the child nodes).\\n\\n3. The algorithm works as follows:\\n\\n- Create an empty stack and an empty list to store the traversal.\\n- Push the root node to the stack.\\n- While the stack is not empty:\\nPop the top element from the stack.\\nAdd the popped element\\'s value to the traversal list.\\nPush the right child of the popped element to the stack.\\nPush the left child of the popped element to the stack.\\n- Return the traversal list.\\n4. The reason why the right child is pushed to the stack before the left child is that we want to process the left subtree before the right subtree (since this is a pre-order traversal). Pushing the right child before the left child ensures that the left child will be processed first when it is popped from the stack.\\n```\\nclass Solution {\\n    // This method returns a list of integers representing the preorder traversal of a binary tree\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     // Create an empty ArrayList to store the preorder traversal\\n     ArrayList<Integer> result = new ArrayList<Integer>();\\n      // If the root is null, return the empty list\\n      if(root == null) \\n      return result;\\n      \\n      // Create a stack to store the nodes as we traverse the tree\\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      // Push the root node onto the stack\\n      st.push(root);\\n      \\n      // While the stack is not empty,\\n      while(!st.isEmpty()) {\\n        // Pop the top node from the stack\\n        TreeNode current = st.pop(); \\n        // Add the value of the node to the list\\n        result.add(current.val);\\n        \\n        // If the current node has a right child, push it onto the stack\\n        if(current.right != null) \\n        st.push(current.right);\\n        // If the current node has a left child, push it onto the stack\\n        if(current.left != null)\\n        st.push(current.left);\\n      }\\n      // Return the list of preorder traversal values\\n      return result;\\n    }\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   public List<Integer> preorderTraversal(TreeNode root) {\\n       // Create a list to store the traversal result\\n\\tList<Integer> result = new ArrayList<>();\\n\\t\\n       // Call helper method to perform the traversal\\n\\ttraversal(root, result);\\n\\t\\n       // Return the result\\n\\treturn result;\\n   }\\n   \\n   // Helper method to perform the preorder traversal\\n   public void traversal(TreeNode root, List<Integer> result) {\\n       // Return if the current node is null\\n\\tif(root == null) return;\\n\\t\\n       // Add the current node\\'s value to the result list\\n\\tresult.add(root.val);\\n\\t\\n       // Recursively traverse the left and right subtrees\\n\\ttraversal(root.left, result);\\n\\ttraversal(root.right, result);\\n   }\\n}\\n```\n```\\nclass Solution {\\n    // This method returns a list of integers representing the preorder traversal of a binary tree\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     // Create an empty ArrayList to store the preorder traversal\\n     ArrayList<Integer> result = new ArrayList<Integer>();\\n      // If the root is null, return the empty list\\n      if(root == null) \\n      return result;\\n      \\n      // Create a stack to store the nodes as we traverse the tree\\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      // Push the root node onto the stack\\n      st.push(root);\\n      \\n      // While the stack is not empty,\\n      while(!st.isEmpty()) {\\n        // Pop the top node from the stack\\n        TreeNode current = st.pop(); \\n        // Add the value of the node to the list\\n        result.add(current.val);\\n        \\n        // If the current node has a right child, push it onto the stack\\n        if(current.right != null) \\n        st.push(current.right);\\n        // If the current node has a left child, push it onto the stack\\n        if(current.left != null)\\n        st.push(current.left);\\n      }\\n      // Return the list of preorder traversal values\\n      return result;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022631,
                "title": "java-iterative-recursive-100-faster",
                "content": "### Upvote If it adds little value, vote means a lot for me\\uD83D\\uDE0A\\n# Code 1 ( Iterative)\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        ArrayList<Integer> arrl = new ArrayList<>();\\n        if(root == null) return arrl;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode current = stack.pop();\\n            arrl.add(current.val);\\n            if(current.right != null){\\n                stack.push(current.right);\\n            }\\n            if(current.left != null){\\n                stack.push(current.left);\\n            }\\n        }\\n        return arrl;\\n    }\\n}\\n```\\n# Iterative Approach\\n Unlike recursion, we require an additional data structure to store our `TreeNode` for iterative solutions. As a result, using `stack` is the best option.\\nAs we know for preorder traversal, we traverse from left -> right. Because the `stack` follow\\'s LIFO technique, we will push the right child of the `node` first then left.\\n\\n1. Initialize empty array `answer` and `stack`\\n2. If `root` is `null` return `answer` or else\\n3. Push `root` to `stack`\\n4. While `stack` is not empty\\n    - pop top `node` from `stack`\\n    - add its `value` to `answer`\\n    - if `node`\\'s right child is not `null`, push to `stack`\\n    - if `node`\\'s left child is not `null`, push to `stack`\\n# Code 2 ( Recursion)\\n```\\npublic class Solution {\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    ArrayList<Integer> list = new ArrayList<Integer>();\\n    traverse(root, list);\\n    return list;\\n}\\n\\npublic void traverse(TreeNode node, ArrayList<Integer> list) {\\n    if(node == null) {\\n        return;\\n    }\\n    \\n    list.add(node.val);\\n    traverse(node.left, list);\\n    traverse(node.right, list);\\n    \\n}\\n}\\n```\\n# Recursive Approach\\nA recursive approach is simple. Here is psuedo code\\n\\n1. Initialize an empty array `answer`\\n1. In recursion\\n    - Base Case: If `root` is null return `root`.\\n    - Add `root` value to `answer`.\\n    - Traverse `root.left` subtree\\n    - Traverse `root.right` subtree",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        ArrayList<Integer> arrl = new ArrayList<>();\\n        if(root == null) return arrl;\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while(!stack.isEmpty()){\\n            TreeNode current = stack.pop();\\n            arrl.add(current.val);\\n            if(current.right != null){\\n                stack.push(current.right);\\n            }\\n            if(current.left != null){\\n                stack.push(current.left);\\n            }\\n        }\\n        return arrl;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n    ArrayList<Integer> list = new ArrayList<Integer>();\\n    traverse(root, list);\\n    return list;\\n}\\n\\npublic void traverse(TreeNode node, ArrayList<Integer> list) {\\n    if(node == null) {\\n        return;\\n    }\\n    \\n    list.add(node.val);\\n    traverse(node.left, list);\\n    traverse(node.right, list);\\n    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45467,
                "title": "132ms-in-javascript",
                "content": "    var preorderTraversal = function(root) {\\n      if (!root) return [];\\n      var result = [];\\n      var stack = [root];\\n      \\n      while(stack.length) {\\n        var node = stack.pop();\\n        result.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n      }\\n      return result;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var preorderTraversal = function(root) {\\n      if (!root) return [];\\n      var result = [];\\n      var stack = [root];\\n      \\n      while(stack.length) {\\n        var node = stack.pop();\\n        result.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n      }\\n      return result;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 45267,
                "title": "3-iterative-solutions-stack-and-morris-traversal-complexity-explained",
                "content": "### 1 Stack-based:\\nStack-based: \\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            res.add(cur.val);\\n            if (cur.right != null)\\n                s.push(cur.right);\\n            if (cur.left != null)\\n                s.push(cur.left);\\n        }\\n        return res;\\n    }\\n}\\n```\\nPush right before left so that, due to the property of a stack, left is processed before right; This is the logic that echoes most throughout this problem's discussions, and is very easy to understand.\\n\\n### 2 Stack-based:\\nSlight changes. \\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            while (cur != null) {\\n                res.add(cur.val);\\n                s.push(cur.right);\\n                cur = cur.left;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nThis algorithm employs a technique I like to call \"push horizontal\" that is frequently used in the implementation of stack-based InOrder and PostOrder algorithm. Since PreOrder logic is generally easier than the other two, this approach is not as much used as that of solution 1. Note that here we push `cur.right` rather than `cur`. The `null` cases will handle themselves by the inner while loop.\\n\\n\\n### 3 Morris Traversal\\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left == null) {\\n                res.add(cur.val);\\n                cur = cur.right;\\n            } else {\\n                TreeNode prev = cur.left;\\n                while (prev.right != null && prev.right != cur)\\n                    prev = prev.right;\\n                if (prev.right == null) {\\n                    res.add(cur.val);\\n                    prev.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    prev.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nA [**good explanation**](http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/) here gives implementation of Morris Traversal InOrder algorithm. The PreOrder algorithm can be achieved by tweaking the code very slightly: rather than visit `cur` when we **restore** the tree(which is generally the second time we are at node `cur`), we visit it the first time we encounter it, which is when we have to **modify**. \\n\\nThe space **complexity** for Morris Traversal is O(1) obviously. The time complexity is actually O(N) which is a little more subtle. The outer while loop is executed O(N) iterations obviously, depending on the position of `root` in the InOrder serialization of the tree. In each such iteration, we have to find the left predecessor for `cur`, which is the costly part. Trivially you would think that gives us `O(NlgN)` per height of the tree. But if you think aggregately, you will see these:\\n* For each node, we do `find left predecessor` on it only twice.\\n* Throughout these two `find left predecessor` inner while loops, each edge of the tree get traversed at most twice.\\n\\nYou might have to draw a tree and doodle some trace to convince yourself this. Since a tree has `N-1` edges, with `N` as the number of nodes, we know that the time complexity is O(N).",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            res.add(cur.val);\\n            if (cur.right != null)\\n                s.push(cur.right);\\n            if (cur.left != null)\\n                s.push(cur.left);\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        Stack<TreeNode> s = new Stack<>();\\n        s.push(root);\\n        while (!s.isEmpty()) {\\n            TreeNode cur = s.pop();\\n            while (cur != null) {\\n                res.add(cur.val);\\n                s.push(cur.right);\\n                cur = cur.left;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null)\\n            return res;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left == null) {\\n                res.add(cur.val);\\n                cur = cur.right;\\n            } else {\\n                TreeNode prev = cur.left;\\n                while (prev.right != null && prev.right != cur)\\n                    prev = prev.right;\\n                if (prev.right == null) {\\n                    res.add(cur.val);\\n                    prev.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    prev.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022150,
                "title": "python-3-1-10-lines-3-versions-w-example-t-m-98-29",
                "content": "\\nThe iterative version, with example:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n                                            #  Ex: root = [1, 2,None, 3,4]\\n        if not root: return []              #         __1\\n        stack, ans = [root], []             #        /\\n                                            #       2\\n        while stack:                        #      / \\\\\\n            node = stack.pop()              #     3   4\\n            ans.append(node.val)            #\\n                                            #     node     node.left   node.right  stack    ans\\n            if node.right:                  #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                stack.append(node.right)    #                                       [1]     []\\n            if node. left:                  #       1          2         None       [2]     [1]\\n                stack.append(node.left )    #       2          3          4         [4,3]   [1,2]\\n                                            #       3        None        None       [4]     [1,2,3]\\n                                            #       4        None        None       [4]     [1,2,3,4]\\n        return ans  \\n```\\n[https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/577636662/](http://)\\n\\nThe recursive version:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        def dfs(node):\\n            if not node: return\\n\\n            ans.append(node.val)\\n\\n            dfs(node.left)\\n            dfs(node.right)\\n  \\n            return   \\n        \\n        ans = []\\n        \\n        dfs(root)\\n\\n        return ans\\n```\\nAnd here\\'s a one-liner:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        return [] if not root else   ([root.val]+\\n                self.preorderTraversal(root.left)+\\n                self.preorderTraversal(root.right))\\n```\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n                                            #  Ex: root = [1, 2,None, 3,4]\\n        if not root: return []              #         __1\\n        stack, ans = [root], []             #        /\\n                                            #       2\\n        while stack:                        #      / \\\\\\n            node = stack.pop()              #     3   4\\n            ans.append(node.val)            #\\n                                            #     node     node.left   node.right  stack    ans\\n            if node.right:                  #   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                stack.append(node.right)    #                                       [1]     []\\n            if node. left:                  #       1          2         None       [2]     [1]\\n                stack.append(node.left )    #       2          3          4         [4,3]   [1,2]\\n                                            #       3        None        None       [4]     [1,2,3]\\n                                            #       4        None        None       [4]     [1,2,3,4]\\n        return ans  \\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        def dfs(node):\\n            if not node: return\\n\\n            ans.append(node.val)\\n\\n            dfs(node.left)\\n            dfs(node.right)\\n  \\n            return   \\n        \\n        ans = []\\n        \\n        dfs(root)\\n\\n        return ans\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> list[int]:\\n\\n        return [] if not root else   ([root.val]+\\n                self.preorderTraversal(root.left)+\\n                self.preorderTraversal(root.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45361,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively\\n    public List<Integer> preorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            ret.add(root.val);\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.right);\\n                stack.push(node.left);\\n            }\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively\\n    public List<Integer> preorderTraversal1(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        dfs(root, ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> ret) {\\n        if (root != null) {\\n            ret.add(root.val);\\n            dfs(root.left, ret);\\n            dfs(root.right, ret);\\n        }\\n    }\\n    \\n    // iteratively\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ret = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode node = stack.pop();\\n            if (node != null) {\\n                ret.add(node.val);\\n                stack.push(node.right);\\n                stack.push(node.left);\\n            }\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45338,
                "title": "preorder-u3001inorder-u3001postorder-iterative-solution-by-c",
                "content": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "solutionTags": [],
                "code": "preorder:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.push_back(root->val);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\ninorder:\\n\\n    vector<int> inorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\troot = root->left;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\tres.push_back(root->val);\\n    \\t\\troot = root->right;\\n    \\t}\\n    \\treturn res;\\n    }\\n\\npostorder:\\n\\n    vector<int> postorderTraversal(TreeNode* root) {\\n    \\tvector<int> res;\\n    \\tstd::stack<TreeNode*> temp;\\n    \\twhile (root || !temp.empty()) {\\n    \\t\\twhile (root) {\\n    \\t\\t\\ttemp.push(root);\\n    \\t\\t\\tres.insert(res.begin(),root->val);\\n    \\t\\t\\troot = root->right;\\n    \\t\\t}\\n    \\t\\troot = temp.top();\\n    \\t\\ttemp.pop();\\n    \\t\\troot = root->left;\\n    \\t}\\n    \\treturn res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1334821,
                "title": "c-solution-100-faster-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332277,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Please see and vote for my solutions for these similar problems.\\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions)\\n[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/discuss/332277/Python-recursive-and-iterative-solutions)\\n[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/discuss/332286/Python-recursive-and-iterative-solutions)\\n\\nRecursive solution:\\n```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            pre_order.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        pre_order = []\\n        dfs(root)\\n        return pre_order\\n```\\n\\nIterative solution:\\n```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        pre_order = []\\n        stack = [root]\\n        while stack:\\n            top = stack.pop()\\n            pre_order.append(top.val)\\n            if top.right:\\n                stack.append(top.right)\\n            if top.left:\\n                stack.append(top.left)\\n        return pre_order\\n```",
                "solutionTags": [],
                "code": "```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            pre_order.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        \\n        pre_order = []\\n        dfs(root)\\n        return pre_order\\n```\n```\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        pre_order = []\\n        stack = [root]\\n        while stack:\\n            top = stack.pop()\\n            pre_order.append(top.val)\\n            if top.right:\\n                stack.append(top.right)\\n            if top.left:\\n                stack.append(top.left)\\n        return pre_order\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1508299,
                "title": "c-recursive-simple-solution-0-ms-100-faster",
                "content": "**C++ :**\\n\\n```\\nvoid preorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tres.push_back(root -> val);           \\n\\n\\t\\tif(root -> left)\\n\\t\\t\\tpreorderTraversalHelper(root -> left, res);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tpreorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> preorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tpreorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid preorderTraversalHelper(TreeNode* root, vector<int> &res) {\\n\\tif(root)\\n\\t{\\n\\t\\tres.push_back(root -> val);           \\n\\n\\t\\tif(root -> left)\\n\\t\\t\\tpreorderTraversalHelper(root -> left, res);\\n\\n\\t\\tif(root -> right)\\n\\t\\t\\tpreorderTraversalHelper(root -> right, res);\\n\\t}\\n\\n\\treturn;\\n}\\n\\n\\nvector<int> preorderTraversal(TreeNode* root) \\n{   \\n\\tvector<int> res;\\n\\tpreorderTraversalHelper(root, res) ;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238346,
                "title": "easy-c-solution-with-explaination",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED !!!**\\n\\n*Overload the comments section with doubts and praises if you have.!!!*\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n// Declairing global variable *ans* so that we don\\'t declare it again and again and affect the SC by some factors\\n    vector<int> ans;\\n    \\n\\t// Find the preorder sequence\\n    void preorder(TreeNode* root) {\\n        if(root==NULL) {\\n            return;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);        \\n    }\\n    \\n    // Recieve the preorder sequence from *preorder()* and return it\\n    vector<int> preorderTraversal(TreeNode* root) {\\n   \\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n// Declairing global variable *ans* so that we don\\'t declare it again and again and affect the SC by some factors\\n    vector<int> ans;\\n    \\n\\t// Find the preorder sequence\\n    void preorder(TreeNode* root) {\\n        if(root==NULL) {\\n            return;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);        \\n    }\\n    \\n    // Recieve the preorder sequence from *preorder()* and return it\\n    vector<int> preorderTraversal(TreeNode* root) {\\n   \\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520452,
                "title": "javascript-stack-98-runtime-step-by-step",
                "content": "For anyone (new to algo/ds) who\\'s beaten by this, here\\'s an step by step explanation:\\n\\n```\\ntree:\\n    1\\n  2   3\\n4  5 6  7\\n\\n1st iteration:\\nstack: [1]\\n\\n2nd iteration:\\ncurrent node = stack pop last element = 1\\ncurrent node:\\n   1\\n 2   3\\nstack push right of current node first then followed by left \\nstack: [3, 2]\\n\\n3rd iteration:\\ncurrent node = stack pop last element = 2\\ncurrent node:\\n   2\\n 4   5\\nstack push right current node first then followed by left \\nstack: [3, 5, 4]\\n\\n4th iteration:\\ncurrent node = stack pop last element = 4\\ncurrent node:\\n    4\\nnull null\\nstack push right current node first then followed by left \\nstack: [3, 5]\\n\\n5th iteration:\\ncurrent node = stack pop last element = 5\\ncurrent node:\\n    5\\nnull null\\nstack push right current node first then followed by left \\nstack: [3]\\n\\n6th iteration:\\ncurrent node = stack pop last element = 3\\ncurrent node:\\n  3\\n6   7\\nstack push right current node first then followed by left \\nstack: [7, 6]\\n\\n7th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     6\\nnull   null\\nstack push right current node first then followed by left \\nstack: [7]\\n\\n8th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     7\\nnull   null\\nstack push right current node first then followed by left \\nstack: []\\nstack.length === 0, false thereby terminating the for loop\\n```\\n\\n**Full code:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    let stack = [root]\\n    let arr = []\\n        \\n    while (stack.length) {\\n        let curr = stack.pop()\\n        arr.push(curr.val)\\n        \\n        if (curr.right) {\\n            stack.push(curr.right)\\n        }\\n        \\n        if (curr.left) {\\n            stack.push(curr.left)\\n        }\\n    }\\n    \\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\ntree:\\n    1\\n  2   3\\n4  5 6  7\\n\\n1st iteration:\\nstack: [1]\\n\\n2nd iteration:\\ncurrent node = stack pop last element = 1\\ncurrent node:\\n   1\\n 2   3\\nstack push right of current node first then followed by left \\nstack: [3, 2]\\n\\n3rd iteration:\\ncurrent node = stack pop last element = 2\\ncurrent node:\\n   2\\n 4   5\\nstack push right current node first then followed by left \\nstack: [3, 5, 4]\\n\\n4th iteration:\\ncurrent node = stack pop last element = 4\\ncurrent node:\\n    4\\nnull null\\nstack push right current node first then followed by left \\nstack: [3, 5]\\n\\n5th iteration:\\ncurrent node = stack pop last element = 5\\ncurrent node:\\n    5\\nnull null\\nstack push right current node first then followed by left \\nstack: [3]\\n\\n6th iteration:\\ncurrent node = stack pop last element = 3\\ncurrent node:\\n  3\\n6   7\\nstack push right current node first then followed by left \\nstack: [7, 6]\\n\\n7th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     6\\nnull   null\\nstack push right current node first then followed by left \\nstack: [7]\\n\\n8th iteration:\\ncurrent node = stack pop last element = 6\\ncurrent node:\\n     7\\nnull   null\\nstack push right current node first then followed by left \\nstack: []\\nstack.length === 0, false thereby terminating the for loop\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    if (!root) {\\n        return []\\n    }\\n    \\n    let stack = [root]\\n    let arr = []\\n        \\n    while (stack.length) {\\n        let curr = stack.pop()\\n        arr.push(curr.val)\\n        \\n        if (curr.right) {\\n            stack.push(curr.right)\\n        }\\n        \\n        if (curr.left) {\\n            stack.push(curr.left)\\n        }\\n    }\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403244,
                "title": "3-simple-python-solutions",
                "content": "##### Solution 1: Preorder traversal with stack\\n\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        stack = [root]\\n        \\n        while stack:\\n            temp = stack.pop()\\n            \\n            if temp:\\n                ans.append(temp.val)\\n                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out\\n                stack.append(temp.left)\\n                \\n        return ans\\n```\\n\\n\\n##### Solution 2: With recursion for python beginners\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        def preorder(node):\\n            if node:\\n                ans.append(node.val)\\n                preorder(node.left)\\n                preorder(node.right)\\n            \\n        preorder(root)\\n        return ans\\n```\\n\\n##### Solution 3: Short solution\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        stack = [root]\\n        \\n        while stack:\\n            temp = stack.pop()\\n            \\n            if temp:\\n                ans.append(temp.val)\\n                stack.append(temp.right) #as we are using stack which works on LIFO, we need to push right tree first so that left will be popped out\\n                stack.append(temp.left)\\n                \\n        return ans\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans = []\\n        if not root:\\n            return ans\\n        \\n        def preorder(node):\\n            if node:\\n                ans.append(node.val)\\n                preorder(node.left)\\n                preorder(node.right)\\n            \\n        preorder(root)\\n        return ans\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return []\\n        \\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321689,
                "title": "java-2-easy-approach-with-explanation-dsf-and-stack",
                "content": "```\\n1)\\n//Recursive Solution //DFS\\nclass Solution \\n{\\n    List<Integer> res= new ArrayList<>();//global ArrayList \\n\\n    public List<Integer> preorderTraversal(TreeNode root)\\n    {\\n         if(root==null)//base case for the null graph \\n             return res;\\n\\n         preorder(root);//calling the preorder in order  \\n\\n         return res;//returning gthe resultant array list \\n    }\\n\\n    public void preorder(TreeNode root)\\n    {\\n        if(root==null)//base case when we reach to the null node while recuring down hill, returning to the calling function and deleting the  activation record \\n            return;//returning to the call function or the active acttib=vation record \\n        \\n        res.add(root.val);//adding first the value, as we first see the root we are adding it to the ArrayList (Root Left Right)\\n        \\n        preorder(root.left);//recursing down hill in search of left node \\n        preorder(root.right);//after the left node is done fo the particular activation record , we are going downhill for the right node search \\n        \\n        return;//returning to the calling function or the active activation record and deleting this activation record as all the fuction are completed \\n    }\\n}//Please do Upvote, It helps a lot\\n```\\n```\\n2)\\n//Non-Recursive Solution \\nclass Solution \\n{\\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list=new ArrayList<>();//for storing the element inorder \\n        \\n        if(root == null)//base case when the tree is empty\\n            return list;\\n        \\n        Stack<TreeNode> stack= new Stack<>();\\n        \\n        stack.push(root);//pushing the root node \\n        \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp=stack.pop();//popping the top element \\n            \\n            list.add(temp.val);//adding the value to the ArrayList //Root\\n            \\n            if(temp.right != null)//first pushing the right because to access the left first and then the right //Right\\n                stack.push(temp.right);//pushing the right node \\n            \\n            if(temp.left != null)//pushing the left node if present after right because to access the left first //Left\\n                stack.push(temp.left);\\n        }//the main purpose of pushing this way is to achive Root Left Right pattern of Inorder Traversal \\n        return list;//returning the List of integer that are stored in Inorder fashion \\n    }\\n}//Please do Upvote, It helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n1)\\n//Recursive Solution //DFS\\nclass Solution \\n{\\n    List<Integer> res= new ArrayList<>();//global ArrayList \\n\\n    public List<Integer> preorderTraversal(TreeNode root)\\n    {\\n         if(root==null)//base case for the null graph \\n             return res;\\n\\n         preorder(root);//calling the preorder in order  \\n\\n         return res;//returning gthe resultant array list \\n    }\\n\\n    public void preorder(TreeNode root)\\n    {\\n        if(root==null)//base case when we reach to the null node while recuring down hill, returning to the calling function and deleting the  activation record \\n            return;//returning to the call function or the active acttib=vation record \\n        \\n        res.add(root.val);//adding first the value, as we first see the root we are adding it to the ArrayList (Root Left Right)\\n        \\n        preorder(root.left);//recursing down hill in search of left node \\n        preorder(root.right);//after the left node is done fo the particular activation record , we are going downhill for the right node search \\n        \\n        return;//returning to the calling function or the active activation record and deleting this activation record as all the fuction are completed \\n    }\\n}//Please do Upvote, It helps a lot\\n```\n```\\n2)\\n//Non-Recursive Solution \\nclass Solution \\n{\\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        List<Integer> list=new ArrayList<>();//for storing the element inorder \\n        \\n        if(root == null)//base case when the tree is empty\\n            return list;\\n        \\n        Stack<TreeNode> stack= new Stack<>();\\n        \\n        stack.push(root);//pushing the root node \\n        \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp=stack.pop();//popping the top element \\n            \\n            list.add(temp.val);//adding the value to the ArrayList //Root\\n            \\n            if(temp.right != null)//first pushing the right because to access the left first and then the right //Right\\n                stack.push(temp.right);//pushing the right node \\n            \\n            if(temp.left != null)//pushing the left node if present after right because to access the left first //Left\\n                stack.push(temp.left);\\n        }//the main purpose of pushing this way is to achive Root Left Right pattern of Inorder Traversal \\n        return list;//returning the List of integer that are stored in Inorder fashion \\n    }\\n}//Please do Upvote, It helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164175,
                "title": "python-solution",
                "content": "Recursive:\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        elif not root.left and not root.right:\\n            return [root.val]\\n        l = self.preorderTraversal(root.left)\\n        r = self.preorderTraversal(root.right)\\n        return [root.val]+l+r\\n```\\nIterative:\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.append(u.val)\\n            if u.right:\\n                stack.append(u.right)\\n            if u.left:\\n                stack.append(u.left)\\n        return res\\n```\\nAnother iterative solution:\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        trav = root\\n        stack = []\\n        res = []\\n        while trav or stack:\\n            if trav:\\n                stack.append(trav)\\n                res.append(trav.val)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                trav = u.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        elif not root.left and not root.right:\\n            return [root.val]\\n        l = self.preorderTraversal(root.left)\\n        r = self.preorderTraversal(root.right)\\n        return [root.val]+l+r\\n```\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        res = []\\n        stack = [root]\\n        while stack:\\n            u = stack.pop()\\n            res.append(u.val)\\n            if u.right:\\n                stack.append(u.right)\\n            if u.left:\\n                stack.append(u.left)\\n        return res\\n```\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        trav = root\\n        stack = []\\n        res = []\\n        while trav or stack:\\n            if trav:\\n                stack.append(trav)\\n                res.append(trav.val)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                trav = u.right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45416,
                "title": "share-my-solution-in-c",
                "content": "//// iterative solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n        \\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0;\\n    stack[length++] = root;\\n    \\n    while (length > 0) {\\n        result = (int *)realloc(result, (*returnSize+1)*sizeof(int));\\n        pop = stack[--length];\\n        result[*returnSize] = pop->val;\\n        *returnSize += 1;\\n        if (pop->right) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->right;\\n        }\\n        if (pop->left) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->left;\\n        }\\n    }\\n    free(stack);\\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n    result = (int *)malloc(sizeof(int));\\n    *result = root->val;\\n    \\n    int leftsize=0, rightsize=0, *leftarr, *rightarr;\\n    if (root->left)\\n        leftarr = preorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = preorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    if (leftsize >0 || rightsize > 0)\\n        result = (int *)realloc(result, sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i+1] = leftarr[i];\\n    if (leftsize > 0)\\n        free(leftarr);\\n    for (j=0; j<rightsize; j++)\\n        result[i+j+1] = rightarr[j];\\n    if (rightsize > 0)\\n        free(rightarr);\\n        \\n    return result;\\n}",
                "solutionTags": [],
                "code": "//// iterative solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n        \\n    *returnSize = 0;\\n    \\n    struct TreeNode **stack = (struct TreeNode **)malloc(sizeof(struct TreeNode *));\\n    struct TreeNode *pop;\\n    int length = 0;\\n    stack[length++] = root;\\n    \\n    while (length > 0) {\\n        result = (int *)realloc(result, (*returnSize+1)*sizeof(int));\\n        pop = stack[--length];\\n        result[*returnSize] = pop->val;\\n        *returnSize += 1;\\n        if (pop->right) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->right;\\n        }\\n        if (pop->left) {\\n            stack = (struct TreeNode **)realloc(stack, sizeof(struct TreeNode*)*(length+1));\\n            stack[length++] = pop->left;\\n        }\\n    }\\n    free(stack);\\n    return result;\\n}\\n\\n//// recursive solution\\n\\n    int* preorderTraversal(struct TreeNode* root, int* returnSize) {\\n    int *result = NULL;\\n    if (root == NULL)\\n        return result;\\n    result = (int *)malloc(sizeof(int));\\n    *result = root->val;\\n    \\n    int leftsize=0, rightsize=0, *leftarr, *rightarr;\\n    if (root->left)\\n        leftarr = preorderTraversal(root->left, &leftsize);\\n    if (root->right)\\n        rightarr = preorderTraversal(root->right, &rightsize);\\n    \\n    *returnSize = 1 + leftsize + rightsize;\\n    if (leftsize >0 || rightsize > 0)\\n        result = (int *)realloc(result, sizeof(int)*(*returnSize));\\n    \\n    int i, j;\\n    for (i=0; i<leftsize; i++)\\n        result[i+1] = leftarr[i];\\n    if (leftsize > 0)\\n        free(leftarr);\\n    for (j=0; j<rightsize; j++)\\n        result[i+j+1] = rightarr[j];\\n    if (rightsize > 0)\\n        free(rightarr);\\n        \\n    return result;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1941808,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            res.append(root.val)\\n            preOrder(root.left)\\n            preOrder(root.right)\\n        }\\n        \\n        preOrder(root)\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        var res: [Int] = []\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            res.append(root.val)\\n            preOrder(root.left)\\n            preOrder(root.right)\\n        }\\n        \\n        preOrder(root)\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753215,
                "title": "c-100-time-dfs-recursive-vs-iterative-solutions-explained-and-compared",
                "content": "First in the easy, convenient way of a plain DFS: we just move `left` as much as possible, update `res` at each step and only then we have met the last `left` branch on our current path we start considering going to the `right`:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    void dfs(TreeNode *root) {\\n        if (!root) return;\\n        res.push_back(root->val);\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\\n\\nThe iterative solution does not take too much effort either, it is just potentially less intuitive; let\\'s go with a DFS for this one as well, since going for a BFS would require needless extra complexity and more logic as we go (in other words: the interviewer should really hate you for that); the structure will be similar: class accumulator variable `res`, no external helper function needed for this one and nice loop inside to build the result.\\n\\nWe start checking if the tree is empty, in which case we just return our `res`, empty as well. If not, we declare a stack `s` and initialise it with a first push, `root` itself.\\n\\nNow the fun begins: we loop while our stack is not empty, we pop the last element, we add back its possible child - but not that we add `right` first, `left` second, since in a stack the values come out following a LIFO approach.\\n\\nTry to visualise it with the example tree of any other one you might wish to build; use pen and paper if not sure, but it works :)\\n\\nOnce the stack is empty, we are done: time to return `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if (!root) return res;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        TreeNode *currNode;\\n        while (s.size()) {\\n            currNode = s.top();\\n            s.pop();\\n            res.push_back(currNode->val);\\n            if (currNode->right) s.push(currNode->right);\\n            if (currNode->left) s.push(currNode->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    void dfs(TreeNode *root) {\\n        if (!root) return;\\n        res.push_back(root->val);\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        dfs(root);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if (!root) return res;\\n        stack<TreeNode*> s;\\n        s.push(root);\\n        TreeNode *currNode;\\n        while (s.size()) {\\n            currNode = s.top();\\n            s.pop();\\n            res.push_back(currNode->val);\\n            if (currNode->right) s.push(currNode->right);\\n            if (currNode->left) s.push(currNode->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514913,
                "title": "python-recursive-iterative-simple-solutions",
                "content": "### Recursive Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, preorder):\\n        if root:\\n            preorder.append(root.val)\\n            self.traversal(root.left, preorder)\\n            self.traversal(root.right, preorder)\\n            \\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        self.traversal(root, preorder)\\n        return preorder\\n```\\n\\n### Iterative Solution\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                preorder.append(root.val)\\n                stack.append(root.right)\\n                stack.append(root.left)\\n        return preorder\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def traversal(self, root, preorder):\\n        if root:\\n            preorder.append(root.val)\\n            self.traversal(root.left, preorder)\\n            self.traversal(root.right, preorder)\\n            \\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        self.traversal(root, preorder)\\n        return preorder\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        preorder = []\\n        stack = [root]\\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                preorder.append(root.val)\\n                stack.append(root.right)\\n                stack.append(root.left)\\n        return preorder\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443518,
                "title": "easy-0-ms-100-fully-explained-java-c-python-python3-recursive-iterative",
                "content": "# **Java Solution (Iterative Approach Using Stack):**\\nRuntime: 1 ms, faster than 93.68% of Java online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 41.3 MB, less than 84.60% of Java online submissions for Binary Tree Preorder Traversal.\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<>();\\n        // Return the solution answer if the tree is empty...\\n        if(root == null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()){\\n            // Pop a node from the stack...\\n            TreeNode node = bag.pop();\\n            sol.add(node.val);\\n            // Push the right child of the popped node into the stack...\\n            if(node.right != null) bag.push(node.right);\\n            // Push the left child of the popped node into the stack...\\n            if(node.left != null) bag.push(node.left);\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Recursive Approach):**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 8.5 MB, less than 42.50% of C++ online submissions for Binary Tree Preorder Traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<int> sol;\\n    void preorder(TreeNode* node){\\n        if(!node) return;\\n        sol.push_back(node->val);\\n        preorder(node->left);\\n        preorder(node->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return sol;\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution (Iterative Approach Using Stack):**\\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            if node:\\n                sol.append(node.val)\\n                # Append the right child of the popped node into the stack\\n                bag.append(node.right)\\n                # Push the left child of the popped node into the stack\\n                bag.append(node.left)\\n        return sol      # Return the solution list...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Create an array list to store the solution result...\\n        List<Integer> sol = new ArrayList<>();\\n        // Return the solution answer if the tree is empty...\\n        if(root == null) return sol;\\n        // Create an empty stack and push the root node...\\n        Stack<TreeNode> bag = new Stack<>();\\n        bag.push(root);\\n        // Loop till stack is empty...\\n        while(!bag.isEmpty()){\\n            // Pop a node from the stack...\\n            TreeNode node = bag.pop();\\n            sol.add(node.val);\\n            // Push the right child of the popped node into the stack...\\n            if(node.right != null) bag.push(node.right);\\n            // Push the left child of the popped node into the stack...\\n            if(node.left != null) bag.push(node.left);\\n        }\\n        return sol;     // Return the solution list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> sol;\\n    void preorder(TreeNode* node){\\n        if(!node) return;\\n        sol.push_back(node->val);\\n        preorder(node->left);\\n        preorder(node->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return sol;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        # Create an empty stack and push the root node...\\n        bag = [root]\\n        # Create an array list to store the solution result...\\n        sol = []\\n        # Loop till stack is empty...\\n        while bag:\\n            # Pop a node from the stack...\\n            node = bag.pop()\\n            if node:\\n                sol.append(node.val)\\n                # Append the right child of the popped node into the stack\\n                bag.append(node.right)\\n                # Push the left child of the popped node into the stack\\n                bag.append(node.left)\\n        return sol      # Return the solution list...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386004,
                "title": "easiest-traversal-without-stack-queue-100-preorder",
                "content": "## **Using This Solution We Can Make Preorder Traversal In Binary Tree Without Using Stack And Queue.**\\n\\n##### Global Declaration Of Ans Vector.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\\n\\n##### Pass By Reference Ans Vector.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        ans.push_back(root->val);\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Like & UpVote If You Get My Intuition Also Comment If You Have Any Query..**\\n\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root == NULL){\\n            return v;\\n        }\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode *root, vector<int> &ans){\\n        if(root == NULL) return;\\n        ans.push_back(root->val);\\n        helper(root->left,ans);\\n        helper(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans; helper(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376174,
                "title": "python-preorder-inorder-postorder-iterative-and-recursive-summary",
                "content": "Preorder:\\n**144. Binary Tree Preorder Traversal**\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n## Recursively\\ndef preorderTraversal1(self, root):\\n    res = []\\n    self.dfs(root, res)\\n    return res\\n    \\ndef dfs(self, root, res):\\n    if root:\\n        res.append(root.val)\\n        self.dfs(root.left, res)\\n        self.dfs(root.right, res)\\n\\t\\t\\n## Iteratively\\ndef preorderTraversal(self, root):\\n    def preorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.left     \\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return res\\n```\\nInorder\\n**94. Binary Tree Inorder Traversal**\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n\\n## Recursively\\ndef inorderTraversal(self, root):\\n\\tres = []\\n\\tself.helper(root, res)\\n\\treturn res\\n\\ndef helper(self, root, res):\\n\\tif root:\\n\\t\\tself.helper(root.left, res)\\n\\t\\tres.append(root.val)\\n\\t\\tself.helper(root.right, res)\\n\\n## Iteratively\\ndef inorderTraversal(self, root):\\n    res = []\\n    stack = []\\n    while stack or root:\\n        if root:\\n            stack.append(root)\\n            root = root.left\\n        else:\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right   \\n    return res\\n```\\nPreorder\\n**145. Binary Tree Postorder Traversal**\\n> Time Complexity O(N)\\n> Space Complexity O(1)\\n```\\n## Recursively\\ndef postorderTraversal(self, root):\\n\\tself.res = []\\n\\tself.dfs(root)\\n\\treturn self.res\\n\\ndef dfs(self, root):\\n\\tif not root:\\n\\t\\treturn \\n\\tself.dfs(root.left)\\n\\tself.dfs(root.right) \\n\\tself.res.append(root.val)\\n\\t\\n## Iteratively\\ndef postorderTraversal(self, root):\\n\\tstack, res = [], []\\n\\twhile stack or root:\\n\\t\\tif root:\\n\\t\\t\\tstack.append(root)\\n\\t\\t\\tres.append(root.val)    \\n\\t\\t\\troot = root.right \\n\\t\\telse:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\troot = node.left\\n\\treturn res[::-1]\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n## Recursively\\ndef preorderTraversal1(self, root):\\n    res = []\\n    self.dfs(root, res)\\n    return res\\n    \\ndef dfs(self, root, res):\\n    if root:\\n        res.append(root.val)\\n        self.dfs(root.left, res)\\n        self.dfs(root.right, res)\\n\\t\\t\\n## Iteratively\\ndef preorderTraversal(self, root):\\n    def preorderTraversal(self, root):\\n        stack, res = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                res.append(root.val)    \\n                root = root.left     \\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return res\\n```\n```\\n\\n## Recursively\\ndef inorderTraversal(self, root):\\n\\tres = []\\n\\tself.helper(root, res)\\n\\treturn res\\n\\ndef helper(self, root, res):\\n\\tif root:\\n\\t\\tself.helper(root.left, res)\\n\\t\\tres.append(root.val)\\n\\t\\tself.helper(root.right, res)\\n\\n## Iteratively\\ndef inorderTraversal(self, root):\\n    res = []\\n    stack = []\\n    while stack or root:\\n        if root:\\n            stack.append(root)\\n            root = root.left\\n        else:\\n            node = stack.pop()\\n            res.append(node.val)\\n            root = node.right   \\n    return res\\n```\n```\\n## Recursively\\ndef postorderTraversal(self, root):\\n\\tself.res = []\\n\\tself.dfs(root)\\n\\treturn self.res\\n\\ndef dfs(self, root):\\n\\tif not root:\\n\\t\\treturn \\n\\tself.dfs(root.left)\\n\\tself.dfs(root.right) \\n\\tself.res.append(root.val)\\n\\t\\n## Iteratively\\ndef postorderTraversal(self, root):\\n\\tstack, res = [], []\\n\\twhile stack or root:\\n\\t\\tif root:\\n\\t\\t\\tstack.append(root)\\n\\t\\t\\tres.append(root.val)    \\n\\t\\t\\troot = root.right \\n\\t\\telse:\\n\\t\\t\\tnode = stack.pop()\\n\\t\\t\\troot = node.left\\n\\treturn res[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 185866,
                "title": "javascript-simple-iterative-solution",
                "content": "```\\nvar preorderTraversal = function(root) {\\n  const result = [];\\n  const stack = [];\\n  let node = root;\\n  \\n  while (node) {\\n    node.val && result.push(node.val);  \\n    node.right && stack.push(node.right);      \\n    node = node.left || stack.pop(); \\n  }\\n  \\n  return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar preorderTraversal = function(root) {\\n  const result = [];\\n  const stack = [];\\n  let node = root;\\n  \\n  while (node) {\\n    node.val && result.push(node.val);  \\n    node.right && stack.push(node.right);      \\n    node = node.left || stack.pop(); \\n  }\\n  \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45439,
                "title": "easy-to-read-java-solutions-for-both-iterative-and-recursive-300ms",
                "content": "Recursive:\\n\\n    public class Solution {\\n        List<Integer> traversal = new ArrayList<>();\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            if(root!=null){helper(root);}\\n            return traversal;\\n        }\\n        \\n        void helper (TreeNode root){\\n            traversal.add(root.val);\\n            if(root.left!=null){helper(root.left);}\\n            if(root.right!=null){helper(root.right);}\\n            \\n        }\\n    }\\n\\nIterative: Use Stack\\n\\n    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            Stack<TreeNode> stack = new Stack<>();\\n            List<Integer> traversal = new ArrayList<>();\\n            if(root!=null){\\n                stack.push(root);\\n                while(!stack.isEmpty()){\\n                    TreeNode curr = stack.pop();\\n                    traversal.add(curr.val);\\n                    if(curr.right!=null){ stack.push(curr.right); }\\n                    if(curr.left!=null){ stack.push(curr.left);  }\\n                }\\n            }\\n            return traversal;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        List<Integer> traversal = new ArrayList<>();\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            if(root!=null){helper(root);}",
                "codeTag": "Java"
            },
            {
                "id": 880873,
                "title": "iterative-and-recursive-dfs-js-solutions",
                "content": "```\\n// Iterative DFS Solution\\nvar preorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack.pop();\\n        res.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n    }\\n    return res;\\n\\t// Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\\n\\n```\\n// Recursive DFS Solution\\nvar preorderTraversal = function(root, res = []) {\\n    if (!root) return [];\\n    res.push(root.val);\\n    if (root.left) preorderTraversal(root.left, res);\\n    if (root.right) preorderTraversal(root.right, res);\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Iterative DFS Solution\\nvar preorderTraversal = function(root) {\\n    if (!root) return [];\\n    let stack = [], res = [];\\n    stack.push(root);\\n    while (stack.length) {\\n        let node = stack.pop();\\n        res.push(node.val);\\n        if (node.right) stack.push(node.right);\\n        if (node.left) stack.push(node.left);\\n    }\\n    return res;\\n\\t// Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n};\\n```\n```\\n// Recursive DFS Solution\\nvar preorderTraversal = function(root, res = []) {\\n    if (!root) return [];\\n    res.push(root.val);\\n    if (root.left) preorderTraversal(root.left, res);\\n    if (root.right) preorderTraversal(root.right, res);\\n    return res;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2549333,
                "title": "leetcode-the-hard-way-dfs-pre-order-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/channel/@leetcodethehardway) if you are interested.\\n\\n---\\n\\nYou may also check out my recent DFS solutions on other tree problems.\\n\\n- [987. Vertical Order Traversal of a Binary Tree](https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/discuss/2527028/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/discuss/2511705/leetcode-the-hard-way-dfs-explained-line-by-line)\\n- [814. Binary Tree Pruning](https://leetcode.com/problems/binary-tree-pruning/discuss/2537510/leetcode-the-hard-way-easy-dfs-explained-line-by-line)\\n- [606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/discuss/2542523/leetcode-the-hard-way-dfs-5-cases-explained-line-by-line)\\n\\nThe steps for pre-order is \\n- do something with root value\\n- traverse left subtree \\n-  traverse right sub tree. \\n\\nFor example 1, starting the root node 1.\\n\\n - At node 1 now, add root value which is 1. answer = [1]\\n- At node 1 now, traverse left node, however, there is no left node, hence return.\\n- At node 1 now, traverse right node.\\n- At node 2 now, add root value which is 2. answer = [1, 2]\\n- At node 2 now, traverse left node.\\n- At node 3 now, add root value which is 3. answer = [1, 2, 3]\\n- At node 3 now, traverse left node, however, there is no left node, hence return.\\n- At node 3 now, traverse right node, however, there is no right node, hence return.\\n- At node 2 now, traverse right node, however, there is no right node, hence return.\\n\\n**C++**\\n\\n```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the left node\\n        preorder(node->left);\\n        // traverse the right node\\n        preorder(node->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# root -> left  -> right\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\n\\n// This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n// Here\\'s a short tutorial if you\\'re interested.\\n// https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n// then you may try the following problems \\n// 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n// 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* node) {\\n        if (node == NULL) return;\\n        // do something with node value here\\n        ans.push_back(node->val);\\n        // traverse the left node\\n        preorder(node->left);\\n        // traverse the right node\\n        preorder(node->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# This is a standard pre-order traversal problem, I\\'d suggest to learn in-order and post-order as well.\\n# Here\\'s a short tutorial if you\\'re interested.\\n# https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/binary-tree\\n# then you may try the following problems \\n# 94. Binary Tree Inorder Traversal: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n# 145. Binary Tree Postorder Traversal: https://leetcode.com/problems/binary-tree-postorder-traversal/\\n\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\t# root -> left  -> right\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588301,
                "title": "java-easy-solution-0ms-100-faster-recursion",
                "content": "**Code**\\n\\n```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tpreorder(root, list);\\n\\treturn list;\\n}\\n\\npublic void preorder(TreeNode root, List<Integer> list) {\\n\\tif(root == null) return;\\n\\n\\tlist.add(root.val);\\n\\tpreorder(root.left, list);\\n\\tpreorder(root.right, list);\\n}\\n```\\n\\nHope it helps\\nDo upvote\\nThanks",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\tList<Integer> list = new ArrayList<>();\\n\\tpreorder(root, list);\\n\\treturn list;\\n}\\n\\npublic void preorder(TreeNode root, List<Integer> list) {\\n\\tif(root == null) return;\\n\\n\\tlist.add(root.val);\\n\\tpreorder(root.left, list);\\n\\tpreorder(root.right, list);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007458,
                "title": "simple-recursive-javascript-solution",
                "content": "```\\nvar preorderTraversal = function solution(root) {\\n    if (!root) {\\n        return [];\\n    }\\n    \\n    return [root.val, ...solution(root.left), ...solution(root.right)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar preorderTraversal = function solution(root) {\\n    if (!root) {\\n        return [];\\n    }\\n    \\n    return [root.val, ...solution(root.left), ...solution(root.right)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45312,
                "title": "three-ways-of-iterative-preorder-traversing-easy-explanation",
                "content": "Three types of Iterative Preorder Traversals in java. \\n\\n1) **Using 1 Stack.** O(n) Time & O(n) Space\\n\\t* Print and push all `left` nodes into the `stack` till it hits `NULL`.\\n\\t* Then `Pop` the top element from the stack, and make the `root` point to its `right`.\\n\\t* Keep iterating till `both` the below conditions are met -\\n\\t\\t* Stack is empty `and`\\n        * Root is NULL.\\n\\t\\n\\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\t\\t\\t\\t\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\n2) **Using 2 Stacks.** O(n) Time & O(n) Space\\nWe use two stacks. Stack `s` is used to find and traverse the child nodes, and `path` stack keeps track of the path from the `root` to the current node. (This is usefull in certain problems like [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/) and [Path Sum](https://leetcode.com/problems/path-sum/) ). \\n    * Initially we push the `root` into `s`.\\n\\t* Keep iterating with below logic till `s` is `empty`.\\n\\t\\t* `root` = `s.peek()`\\n\\t\\t* If the top elements of both the stacks are not the same :\\t\\t\\n\\t\\t\\t* Print `root` and push it into `path`.\\n\\t\\t\\t* Push `root`\\'s children into `s` in reverse order. (Remember it\\'s a stack!)\\n\\t\\t* When top elements of both stacks are equal. (Which means we hit a deadend, and need to turn back)\\n\\t\\t\\t* `Pop` from `both` stacks.\\n\\t\\n\\t\\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                s.pop();\\n                path.pop();\\n            }\\n            else{\\n                out.add(root.val);\\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\\n\\n3) **Using No Stacks (Morris Traversal).** O(n) Time & O(1) Space\\nInstead of using stacks to remember our way back up the tree, we are going to modify the tree to create upwards links. The idea is based on [Threaded Binary Tree](https://en.wikipedia.org/wiki/Threaded_binary_tree). \\n\\t* Iterate till `root` is null.\\n\\t\\t* If `root` has a left child.\\n\\t\\t\\t* Find the `inorder predecessor`. (Inorder predecessor of root is the right most child of its left child)\\n\\t\\t\\t\\t* Make it point to root.\\n\\t\\t\\t\\t* `root` = `root.left`.\\n\\t\\t\\t* If its already pointing to root (which means we have traversed it already and are on our way up.)\\n\\t\\t\\t\\t* Make the `inorder predecessor` point to `null` (Reverting our structural changes)\\n\\t\\t\\t\\t* `root` = `root.right`.\\n\\t\\t* If left child is `null`\\n\\t\\t\\t* `root` = `root.right`. (We are climbing up our link.)\\n\\n\\t\\t\\t\\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root == null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre = null;\\n\\t\\twhile(root!=null){\\n\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\tif(pre.right==null){\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}                   \\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\\n\\nAlso checkout [Inorder](https://discuss.leetcode.com/topic/64682/three-ways-of-iterative-inorder-traversing-easy-explanation)  & [PostOrder](https://discuss.leetcode.com/topic/64689/three-ways-of-iterative-postorder-traversing-easy-explanation)  :))",
                "solutionTags": [],
                "code": "```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root==null)\\n\\t\\t\\treturn out;\\n\\t\\tStack<TreeNode> s = new Stack();      \\n\\t\\twhile(root!=null || !s.empty()){\\n\\t\\t\\tif(root!=null){\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\ts.push(root);\\n\\t\\t\\t\\troot = root.left;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\troot = s.pop();\\t\\t\\t\\t\\n\\t\\t\\t\\troot = root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n        if(root == null)\\n            return out; \\n        Stack<TreeNode> s = new Stack(), path = new Stack();\\n        s.push(root);\\n        while(!s.empty()){\\n            root = s.peek();\\n            if(!path.empty() && path.peek()==root){\\n                s.pop();\\n                path.pop();\\n            }\\n            else{\\n                out.add(root.val);\\n                path.push(root);\\n                if(root.right != null)\\n                    s.push(root.right);\\n                if(root.left != null)\\n                    s.push(root.left);\\n            }\\n        }\\n\\t    return out;\\n    }\\n\\t\\n```\n```\\n\\npublic List<Integer> preorderTraversal(TreeNode root) {\\n\\t\\tList<Integer> out = new ArrayList<Integer>();\\n\\t\\tif(root == null)\\n\\t\\t\\treturn out;\\n\\t\\tTreeNode pre = null;\\n\\t\\twhile(root!=null){\\n\\t\\t\\tif(root.left !=null){\\n\\t\\t\\t\\tpre = root.left;\\n\\t\\t\\t\\t\\twhile(pre.right!=null && pre.right!=root)\\n\\t\\t\\t\\t\\tpre=pre.right;\\n\\t\\t\\t\\tif(pre.right==null){\\n\\t\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\t\\tpre.right=root;\\n\\t\\t\\t\\t\\troot=root.left;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tpre.right=null;\\n\\t\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t\\t}                   \\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tout.add(root.val);\\n\\t\\t\\t\\troot=root.right;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724145,
                "title": "python-3-30ms-perfect-pythonic-recursive-one-liner-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961907,
                "title": "extremely-simple-morris-traversal-pre-in-post-order-summary",
                "content": "There are a lot of introductions about how Morris Traversal works. It is a beautiful algorithm which takes only O(1) space complexity while still maintaining O(n) time complexity. Here I summarized how Morris Traversal is implemented w.r.t. all three orders. \\n\\n**Pre-Order:**\\n```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**In-Order**: \\n\\nCompared to Pre-Order implementation, the change is just one line as maked \"***\"\\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\\n**Post-Order:**\\n\\nI saw many implementations for the Post-Order to be very complex and hard to remember. Here I provide a simple version. It is very similar to the pre-order one, except that now we are doing everything reversely. By this I mean we go along the direction of right child and link the leftmost child on the right sub tree to the root. Then we leftappend the val to the result. \\n\\nTHAT`S IT!!\\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```\\n\\nHope you like it. Cheers.",
                "solutionTags": [],
                "code": "```\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n       \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\tres.append(root.val) \\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.right = None \\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef inorderTraversal(self, root: TreeNode) -> List[int]:\\n  \\n\\tres = []\\n\\n\\twhile root:\\n\\t\\tif root.left:\\n\\t\\t\\ttemp = root.left\\n\\t\\t\\twhile temp.right and temp.right != root:\\n\\t\\t\\t\\ttemp = temp.right\\n\\t\\t\\tif not temp.right:\\n\\t\\t\\t\\ttemp.right = root\\n\\t\\t\\t\\troot = root.left\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres.append(root.val)    # ***\\n\\t\\t\\t\\ttemp.right = None\\n\\t\\t\\t\\troot = root.right\\n\\t\\telse:\\n\\t\\t\\tres.append(root.val)\\n\\t\\t\\troot = root.right\\n\\n\\treturn res\\n```\n```\\ndef postorderTraversal(self, root: TreeNode) -> List[int]:\\n\\t\\n\\tres = deque()\\n\\n\\twhile root:\\n\\t\\tif root.right:\\n\\t\\t\\ttemp = root.right\\n\\t\\t\\twhile temp.left and temp.left != root:\\n\\t\\t\\t\\ttemp = temp.left\\n\\t\\t\\tif not temp.left:\\n\\t\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\t\\ttemp.left = root\\n\\t\\t\\t\\troot = root.right\\n\\t\\t\\telse:\\n\\t\\t\\t\\ttemp.left = None\\n\\t\\t\\t\\troot = root.left\\n\\t\\telse:\\n\\t\\t\\tres.appendleft(root.val)\\n\\t\\t\\troot = root.left\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 177117,
                "title": "simple-iterative-javascript-solution",
                "content": "Of the three main types of binary tree traversals (inorder,preorder,postorder), I find preorder traversal the easiest to implement iteratively. You can just reuse the dfs algorithm, but make sure you push the children onto the stack in such a way that the left child is processed before the right child.\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    var stack = [];\\n\\t\\t\\n    // We do not push the root node onto the stack if the root node is null. This way we will avoid\\n    // going into the while loop when the root is null and just return an empty array as the result. \\n    if(root !== null){\\n        stack.push(root);\\n    }\\n    \\n    // Initialize the result to an empty array \\n    var res = [];\\n\\t\\t\\n    // Keep iterating while there is something on the stack\\n    while(stack.length > 0){\\n        var node = stack.pop();\\n\\t\\t\\t\\t\\n\\t// Do the preorder processing\\n        res.push(node.val);\\n\\t\\t\\t\\t\\n        // If there is a right child, push it onto the stack. \\n        if(node.right !== null){\\n            stack.push(node.right);\\n        }\\n\\t\\t\\t\\t\\n        // If there is a left child, push it onto the stack. \\n        if(node.left !== null){\\n            stack.push(node.left);\\n        }\\n    }\\n    \\n    return res; \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    var stack = [];\\n\\t\\t\\n    // We do not push the root node onto the stack if the root node is null. This way we will avoid\\n    // going into the while loop when the root is null and just return an empty array as the result. \\n    if(root !== null){\\n        stack.push(root);\\n    }\\n    \\n    // Initialize the result to an empty array \\n    var res = [];\\n\\t\\t\\n    // Keep iterating while there is something on the stack\\n    while(stack.length > 0){\\n        var node = stack.pop();\\n\\t\\t\\t\\t\\n\\t// Do the preorder processing\\n        res.push(node.val);\\n\\t\\t\\t\\t\\n        // If there is a right child, push it onto the stack. \\n        if(node.right !== null){\\n            stack.push(node.right);\\n        }\\n\\t\\t\\t\\t\\n        // If there is a left child, push it onto the stack. \\n        if(node.left !== null){\\n            stack.push(node.left);\\n        }\\n    }\\n    \\n    return res; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3022456,
                "title": "java-explained-in-detail-simple-fast-solution-recursive-iterative",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n# Approach\\n\\nAlgorithm for Preorder(tree)\\n   1. Visit the root.\\n   2. Traverse the left subtree\\n   3. Traverse the right subtree\\n\\nExample:\\n![image](https://assets.leetcode.com/users/images/3d49dfe8-0dd8-4537-8636-0a6f1a035377_1663136628.9607692.png)\\nSteps:\\n1. At node 1 now, add root value 1 => Integers[1]\\n2. At node 1 now, traverse the left node.\\n3. At node 2 now, add root value 2 => Integers[1, 2]\\n4. At node 2 now, traverse the left node.\\n5. At node 4 now, add root value 4 => Integers[1, 2, 4]\\n6. At node 4 now, traverse the left node. Since no left node (null), return to node 4.\\n7. At node 4 now, traverse the right node. Since no right node (null), return to node 4, then node 2.\\n8. At node 2 now, traverse the right node.\\n9. At node 5 now, add root value 5 => Integers[1, 2, 4, 5]\\n10. At node 5 now, traverse the left node. Since no left node (null), return to node 5.\\n11. At node 5 now, traverse the right node. Since no right node (null), return to node 5, then node 2, then node 1.\\n12. At node 1 now, traverse the riht node.\\n13. At node 3 now, add root value 3 => Integers[1, 2, 4, 5, 3]\\n14. At node 3 now, traverse the left node. Since no left node (null), return to node 3.\\n15. At node 3 now, traverse the right node. Since no right node (null), end traversal.\\n\\nAs shown, each node here has the traversal sequence of root -> left -> right.\\n\\n---\\n\\n# Recursive Implementation:\\n\\n## Complexity\\n- Time Complexity  : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are traversing every single node.\\nHowever, this does not take into account the resizing of the array backing the LinkedList, depending on the size of nodes in the tree.\\n\\n- Space Complexity : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are recording the value of every node into the List.\\nThe recursive call stack only takes up the maximum space of tree height, which is smaller than \\'n\\'.\\n\\n## Java - With Explanation (Recursive)\\n\\n```\\nclass Solution {\\n\\n    // Wrapper method to set up and initialize the recursive function.\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    // Recursive method.\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        // The base case, for when the root is null.\\n        if (root == null) return integerList;\\n\\n        // For preorder traversal, we first visit the root and add the value of the root to the list.\\n        integerList.add(root.val);\\n        // Then, we visit the left node.\\n        preorderTraversal(root.left, integerList);\\n        // Lastly, we visit the right node.\\n        preorderTraversal(root.right, integerList);\\n\\n        // Once done, we return the list.\\n        return integerList;\\n    }\\n}\\n```\\n\\n## Java - Clean Code (Recursive)\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        if (root == null) return integerList;\\n\\n        integerList.add(root.val);\\n        preorderTraversal(root.left, integerList);\\n        preorderTraversal(root.right, integerList);\\n\\n        return integerList;\\n    }\\n}\\n```\\n\\n---\\n\\n# Iterative Implementation:\\n\\n## Complexity\\n- Time Complexity  : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are traversing every single node.\\nHowever, this does not take into account the resizing of the array backing the LinkedList, depending on the size of nodes in the tree.\\n\\n- Space Complexity : O(n), \\nwhere \\'n\\' is the number of nodes in the tree, as we are recording the data of every node into the List.\\nThe stack only takes up the maximum space of tree height, which is smaller than \\'n\\'.\\n\\n## Java - With Explanation (Iterative)\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            // First, we record the root.\\n            integerList.add(root.val);\\n\\n            // If right node is available, push the right node into the Stack first.\\n            // We will pop it later we are done with the left nodes.\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            // Continue to traverse to the left, while recording each subtree root nodes,\\n            // and pushing the subtree right nodes into the stack.\\n            // Once reaches a leaf node, pop the right nodes and continue.\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        // Fully traversed the tree.\\n        return integerList;\\n    }\\n}\\n```\\n\\n## Java - Clean Code (Iterative)\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            integerList.add(root.val);\\n\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        return integerList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Stack",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Wrapper method to set up and initialize the recursive function.\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    // Recursive method.\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        // The base case, for when the root is null.\\n        if (root == null) return integerList;\\n\\n        // For preorder traversal, we first visit the root and add the value of the root to the list.\\n        integerList.add(root.val);\\n        // Then, we visit the left node.\\n        preorderTraversal(root.left, integerList);\\n        // Lastly, we visit the right node.\\n        preorderTraversal(root.right, integerList);\\n\\n        // Once done, we return the list.\\n        return integerList;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        integerList = preorderTraversal(root, integerList);\\n        return integerList;\\n    }\\n\\n    private List<Integer> preorderTraversal(TreeNode root, List<Integer> integerList) {\\n        if (root == null) return integerList;\\n\\n        integerList.add(root.val);\\n        preorderTraversal(root.left, integerList);\\n        preorderTraversal(root.right, integerList);\\n\\n        return integerList;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            // First, we record the root.\\n            integerList.add(root.val);\\n\\n            // If right node is available, push the right node into the Stack first.\\n            // We will pop it later we are done with the left nodes.\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            // Continue to traverse to the left, while recording each subtree root nodes,\\n            // and pushing the subtree right nodes into the stack.\\n            // Once reaches a leaf node, pop the right nodes and continue.\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        // Fully traversed the tree.\\n        return integerList;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> integerList = new LinkedList<>();\\n        Stack<TreeNode> rightNodes = new Stack<>();\\n\\n        while (root != null) {\\n            integerList.add(root.val);\\n\\n            if (root.right != null) {\\n                rightNodes.push(root.right);\\n            }\\n\\n            root = root.left;\\n            if (root == null && !rightNodes.isEmpty()) {\\n                root = rightNodes.pop();\\n            }\\n        }\\n        return integerList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827152,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        ListNode* cur_node = head;\\n        while (cur_node && cur_node->next) {\\n            ListNode* next_node = cur_node->next;\\n            if (cur_node->val == next_node->val)\\n                cur_node->next = next_node->next;\\n            else\\n                cur_node = next_node;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778147,
                "title": "c-solutiona-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        stack<TreeNode*> stack;\\n        if (root == NULL)\\n            return preorder;\\n        stack.push(root);\\n        while(!stack.empty()) {\\n            TreeNode* curr = stack.top();\\n            stack.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                stack.push(curr->right);\\n            if (curr->left != NULL)\\n                stack.push(curr->left);\\n        }\\n        return preorder;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260651,
                "title": "c-recursive-and-iterative-using-stack-with-explanation",
                "content": "Pre-order traversal is to visit the root first. Then traverse the left subtree. Finally, traverse the right subtree. \\n> Preorder: **visit > left > right**\\n\\n**Iterative Approach**\\n* We need to use a `Stack` to remember the sub-trees as we go deeper\\n* Since `stack`s are `first-in-last-out` approach, we need to:\\n\\t* **Visit**:  Add the node to the `list`\\n\\t* `Push` the `right sub-tree` first, then\\n\\t* `Push` the `left sub-tree`\\n* So, when we `pop` the stack, \\n\\t* We get the `left sub-tree` first *before* the `right sub-tree` since it\\'s pushed last\\n\\n```csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) {\\n        IList<int> preorder = new List<int>();\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        \\n        if (node != null)\\n            stack.Push(node);\\n        \\n        // visit > left > right\\n        while (stack.Count > 0) {\\n            node = stack.Pop();\\n            preorder.Add(node.val); // Visit\\n            \\n            if (node.right != null) { // Push right\\n                stack.Push(node.right);\\n            }\\n            \\n            if (node.left != null) { // Push left\\n                stack.Push(node.left);\\n            }\\n            \\n        }\\n        \\n        return preorder;\\n    }\\n}\\n```\\n\\n**Recursive Approach**\\n* Recursion is the straightforward approach and mimics the concept of `visit > left > right` for `preorder` traversals\\n* We need to pass the `list` as a parameter so we can add the values of the visited nodes to it\\n* **Alternative approach**: instead of passing `preorder` list, you can make it a `global` field. \\n* **Another approach**: final approach would be for the helper function to `return` the `preorder` list\\n\\n``` csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) { \\n        IList<int> preorder = new List<int>();\\n        PreOrder(preorder, root);\\n        \\n        return preorder;\\n    }\\n    \\n    private void PreOrder(IList<int> list, TreeNode node) {\\n        if (node == null) return;\\n        \\n        list.Add(node.val);         // Visit\\n        PreOrder(list, node.left);  // Left\\n        PreOrder(list, node.right); // Right\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) {\\n        IList<int> preorder = new List<int>();\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        \\n        if (node != null)\\n            stack.Push(node);\\n        \\n        // visit > left > right\\n        while (stack.Count > 0) {\\n            node = stack.Pop();\\n            preorder.Add(node.val); // Visit\\n            \\n            if (node.right != null) { // Push right\\n                stack.Push(node.right);\\n            }\\n            \\n            if (node.left != null) { // Push left\\n                stack.Push(node.left);\\n            }\\n            \\n        }\\n        \\n        return preorder;\\n    }\\n}\\n```\n``` csharp\\npublic class Solution {\\n    public IList<int> PreorderTraversal(TreeNode root) { \\n        IList<int> preorder = new List<int>();\\n        PreOrder(preorder, root);\\n        \\n        return preorder;\\n    }\\n    \\n    private void PreOrder(IList<int> list, TreeNode node) {\\n        if (node == null) return;\\n        \\n        list.Add(node.val);         // Visit\\n        PreOrder(list, node.left);  // Left\\n        PreOrder(list, node.right); // Right\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504591,
                "title": "an-iterative-3-in-1-template-for-pre-in-post-order-traversal",
                "content": "## Explanation\\n\\nOne only needs to write the code to the corresponding block.\\n\\nThe concept is exactly how recursion works.\\nWe:\\n\\n- only traverse while the stack is not empty.  (#0)\\n- push a left child to the stack right after a pre-order region.  (#3)\\n- push a right child to the stack right after an in-order region.  (#6)\\n- pop the stack right after a post-order region.  (#8)\\n\\nAnd there are some implementation details:\\n\\n-  If a traversal is not a in-order nor post-order traversal, it\\'s a pre-order traversal. (#1)\\n-  Use a `while (true)` with a `if` statement inside to ensure `node` is not null outside the loop.  (#2, #4)\\n-  If a node has no right child, the in-order operation and post-order operation happen simutaneously. (#5, #7)\\n-  `prev` is the last post-order traversed node. (#9)\\n\\n## Template\\n\\n```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {  // #0\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {  // #1\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;   // #2\\n                    node = node->left;\\n                    stack.push(node);  // #3\\n                }\\n            }\\n            // #4\\n            if (not node->right or prev != node->right) {  // #5\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);  // #6\\n            }\\n\\n            if (not node->right or prev == node->right) {  // #7\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();  // #8\\n                prev = node;  // #9\\n            }\\n        }\\n```\\n\\n## A slightly changed version\\n\\n```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* node = root;\\n        TreeNode* prev = nullptr;\\n\\n        while (node or not stack.empty()) {\\n            while (node) {\\n                // Pre-order region {\\n                //   do_something();\\n                // }\\n                stack.push(node);\\n                node = node->left;\\n            }\\n            node = stack.top();\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right) {\\n                    node = node->right;\\n                    continue;\\n                }\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n                node = nullptr;\\n            }\\n        }\\n```\\n\\n## Examples\\n\\n### [Problem: Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    result.push_back(node->val);  // <-------------- See here!\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n### [Problem: Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n### [Problem: Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Iterator"
                ],
                "code": "```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {  // #0\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {  // #1\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;   // #2\\n                    node = node->left;\\n                    stack.push(node);  // #3\\n                }\\n            }\\n            // #4\\n            if (not node->right or prev != node->right) {  // #5\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);  // #6\\n            }\\n\\n            if (not node->right or prev == node->right) {  // #7\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();  // #8\\n                prev = node;  // #9\\n            }\\n        }\\n```\n```C++\\n        stack<TreeNode*> stack{};\\n        TreeNode* node = root;\\n        TreeNode* prev = nullptr;\\n\\n        while (node or not stack.empty()) {\\n            while (node) {\\n                // Pre-order region {\\n                //   do_something();\\n                // }\\n                stack.push(node);\\n                node = node->left;\\n            }\\n            node = stack.top();\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right) {\\n                    node = node->right;\\n                    continue;\\n                }\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n                node = nullptr;\\n            }\\n        }\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    result.push_back(node->val);  // <-------------- See here!\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                //   do_something();\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> postorderTraversal(TreeNode* root) {\\n        vector<int> result{};\\n        stack<TreeNode*> stack{};\\n        TreeNode* prev = nullptr;\\n\\n        if (root)\\n            stack.push(root);\\n        while (not stack.empty()) {\\n            TreeNode* node = stack.top();\\n\\n            if (not prev or\\n                prev != node->left and prev != node->right) {\\n                while (true) {\\n                    // Pre-order region {\\n                    //   do_something();\\n                    // }\\n                    if (not node->left)\\n                        break;\\n                    node = node->left;\\n                    stack.push(node);\\n                }\\n            }\\n\\n            if (not node->right or prev != node->right) {\\n                // In-order region {\\n                //   do_something();\\n                // }\\n                if (node->right)\\n                    stack.push(node->right);\\n            }\\n\\n            if (not node->right or prev == node->right) {\\n                // Post-order region {\\n                result.push_back(node->val);  // <-------------- See here!\\n                // }\\n                stack.pop();\\n                prev = node;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45316,
                "title": "c-iterative-with-stack",
                "content": "    public IList<int> PreorderTraversal(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        List<int> list = new List<int>();\\n        stack.Push(root);\\n        while (stack.Count() > 0)\\n        {\\n            TreeNode current = stack.Pop();\\n            if (current != null)\\n            {\\n                list.Add(current.val);\\n                stack.Push(current.right);\\n                stack.Push(current.left);\\n            }\\n        }\\n        \\n        return list;\\n    }",
                "solutionTags": [],
                "code": "    public IList<int> PreorderTraversal(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        List<int> list = new List<int>();\\n        stack.Push(root);\\n        while (stack.Count() > 0)\\n        {\\n            TreeNode current = stack.Pop();\\n            if (current != null)\\n            {\\n                list.Add(current.val);\\n                stack.Push(current.right);\\n                stack.Push(current.left);\\n            }\\n        }\\n        \\n        return list;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45438,
                "title": "java-solution-using-stack",
                "content": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> stack = new Stack<TreeNode>();\\n      stack.push(root);\\n      \\n      while (!stack.isEmpty()) {\\n        TreeNode node = stack.pop();\\n        res.add(node.val);\\n        \\n        if (node.right != null)\\n          stack.push(node.right);\\n            \\n        if (node.left != null)\\n          stack.push(node.left);\\n      }\\n      \\n      return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> postorderTraversal(TreeNode root) {\\n      List<Integer> res = new ArrayList<Integer>();\\n      \\n      if (root == null)\\n        return res;\\n          \\n      Stack<TreeNode> stack = new Stack<TreeNode>();\\n      stack.push(root);\\n      \\n      while (!stack.isEmpty()) {\\n        TreeNode node = stack.pop();\\n        res.add(node.val);\\n        \\n        if (node.right != null)\\n          stack.push(node.right);\\n            \\n        if (node.left != null)\\n          stack.push(node.left);\\n      }\\n      \\n      return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3205841,
                "title": "144-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo traverse a binary tree in a preorder fashion, we start from the root node, visit the left subtree, then the right subtree. We will use a stack to keep track of the nodes to be visited. We first push the root node onto the stack, and then while the stack is not empty, we pop the top node and visit it. If the popped node has a right child, we push it onto the stack. If the popped node has a left child, we push it onto the stack. We continue this process until the stack is empty.\\n\\nIn this code, we first check if the root is None. If it is, we return an empty list. Otherwise, we create an empty stack and add the root node to it. We also create an empty list to store the result.\\n\\nWe then start a while loop that continues until the stack is empty. In each iteration of the loop, we pop the top node from the stack and add its value to the result list. We then check if the popped node has a right child. If it does, we push the right child onto the stack. We then check if the popped node has a left child. If it does, we push the left child onto the stack.\\n\\nAfter the loop ends, we return the result list. This will contain the values of the nodes in preorder traversal order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        result = []\\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n        stack = [root]\\n        result = []\\n        while stack:\\n            node = stack.pop()\\n            result.append(node.val)\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022776,
                "title": "0ms-explained-easy-solution-c",
                "content": "# Approach\\nIn this question we need to traverse or move through this tree in pre order traversal\\n\\nFirst the root node, then the next node (left sibling, or left node) and after all the left nodes are exhausted on the left subtree, we go back on e node and check the right node or right sibling. Again when all nodes are done on that level we go back one level and repeat the same process unless we have reached the root back again; and then we start traversing the right sub tree, but here too we first go through the left siblings first and then the right siblings.\\n\\n```\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root, vector<int>& v) {\\n        if (root==NULL) return;     // if node is null there is nothing more to check\\n        v.push_back(root->val);     // We first add the node we\\'re visiting to the output vector\\n        traverse(root->left, v);    // Now let\\'s move through the left siblings\\n        traverse(root->right, v);   // After the left siblings are done with, we check for the right siblings as we start going back\\n    }\\n\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        traverse(root, v);\\n        return v;\\n    }\\n};\\n```\\n\\n\\n*Upvote this solution, as it might have helped you :)*",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void traverse(TreeNode* root, vector<int>& v) {\\n        if (root==NULL) return;     // if node is null there is nothing more to check\\n        v.push_back(root->val);     // We first add the node we\\'re visiting to the output vector\\n        traverse(root->left, v);    // Now let\\'s move through the left siblings\\n        traverse(root->right, v);   // After the left siblings are done with, we check for the right siblings as we start going back\\n    }\\n\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        traverse(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022418,
                "title": "iterative-solution-with-stack-beats-100-solution-in-time",
                "content": "# Intuition\\nWe have to do preorder traversal where we print value for root then we go for it\\'s left sub tree and in the last we go for right sub tree of the root.\\n\\nstack is the LIFO(Last in first out data structure) so we can use this property\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1-Add root of the tree in the stack and traverse till stack becomes empty \\n2-Remove top of the stack and store it in the variable called rem now add value of rem in our List\\n3-If there exist right child of the remove node (rem) then add it to the stack and then do same with the left child of the root \\n\\n(Here we are adding right child first and left child later so that while we will remove the element, left child will be poped out first )\\n\\n# Complexity\\n- Time complexity:O(N)\\nWe are Traversing all elements of the tree ones so that time complexity will be O(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n-Here H is the height of the tree (Stack will not store all n elements at once)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        List<Integer>l = new ArrayList<>();\\n        Stack<TreeNode>st = new Stack<>();\\n        st.push(root);\\n        while(st.isEmpty()==false){\\n            TreeNode rem = st.pop();\\n            l.add(rem.val);\\n            if(rem.right!=null){\\n                st.push(rem.right);\\n            }\\n            if(rem.left!=null){\\n                st.push(rem.left);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```\\nI hope you understand the solution, have a great day ahead.\\nHar Har Mahadev\\uD83D\\uDD49\\uFE0F\\u2764\\uFE0F,\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        List<Integer>l = new ArrayList<>();\\n        Stack<TreeNode>st = new Stack<>();\\n        st.push(root);\\n        while(st.isEmpty()==false){\\n            TreeNode rem = st.pop();\\n            l.add(rem.val);\\n            if(rem.right!=null){\\n                st.push(rem.right);\\n            }\\n            if(rem.left!=null){\\n                st.push(rem.left);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021964,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//PreorderTraversal Using Recurrsion\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\\n```\\n//Preorder Traversal Using Morris Traversal\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* curr=root;\\n        while(curr){\\n            if(!curr->left){\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode* pre=curr->left;\\n                while(pre->right&&pre->right!=curr){\\n                    pre=pre->right;\\n                }\\n                if(pre->right==NULL){\\n                    pre->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else{\\n                    pre->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n//PreorderTraversal Using Recurrsion\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        ans.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return ans;\\n    }\\n};\\n```\n```\\n//Preorder Traversal Using Morris Traversal\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* curr=root;\\n        while(curr){\\n            if(!curr->left){\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else{\\n                TreeNode* pre=curr->left;\\n                while(pre->right&&pre->right!=curr){\\n                    pre=pre->right;\\n                }\\n                if(pre->right==NULL){\\n                    pre->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else{\\n                    pre->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984350,
                "title": "iterative-preorder-travesal-using-stack",
                "content": "# Intuition\\nIterative Preorder Travesal using Stack\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL){\\n            return preorder;\\n        }\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            root=st.top();\\n            st.pop();\\n            preorder.push_back(root->val);\\n\\n            if(root->right!=NULL){\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL){\\n                st.push(root->left);\\n            }\\n        }\\n        return preorder;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL){\\n            return preorder;\\n        }\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            root=st.top();\\n            st.pop();\\n            preorder.push_back(root->val);\\n\\n            if(root->right!=NULL){\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL){\\n                st.push(root->left);\\n            }\\n        }\\n        return preorder;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806507,
                "title": "striver-s-method-upvote-if-you-like",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL) return preorder;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n\\n           root=st.top();\\n           st.pop();\\n           preorder.push_back(root->val);\\n           if(root->right!=NULL){\\n               st.push(root->right);\\n           }\\n\\n           if(root->left!=NULL)\\n           {\\n               st.push(root->left);\\n           }\\n\\n        }\\n        return preorder;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> preorder;\\n        if(root==NULL) return preorder;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n\\n           root=st.top();\\n           st.pop();\\n           preorder.push_back(root->val);\\n           if(root->right!=NULL){\\n               st.push(root->right);\\n           }\\n\\n           if(root->left!=NULL)\\n           {\\n               st.push(root->left);\\n           }\\n\\n        }\\n        return preorder;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540041,
                "title": "c-inorder-preorder-postorder-all-3-solution-0ms-faster-than-100",
                "content": "You can observe there is just a minimal diffrence in all 3 ,i.e, it\\'s just the way of filling vector while calling fill function.  \\n***Inorder Traversal :*** \\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Preorder Traversal :***\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Postorder Traversal :***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\n\\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        ans.push_back(root->val);  // Inorder\\n        fill(root->right);\\n    }\\n    \\n    vector<int> inorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        ans.push_back(root->val);  // Preoder\\n        fill(root->left);\\n        fill(root->right);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void fill(TreeNode* root){\\n        if(!root)\\n            return;\\n        fill(root->left);\\n        fill(root->right);\\n        ans.push_back(root->val);  /// Postorder\\n    }\\n    \\n    vector<int> postorderTraversal(TreeNode* root) {\\n        fill(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369622,
                "title": "three-types-of-solution-recursion-iterative-morris-100-faster-c",
                "content": "## All Three types of solutions: \\n1. Recursion => TC - O(N) and SC - (N)\\n2. Iterative => TC - O(N) and SC - (N)\\n3. Morris Traversal => TC - O(N) and SC - (1)\\n\\n#### **Using recursion (4ms time) TC - O(N) and SC - O(N)**\\n```\\nclass Solution {\\npublic:\\n     vector<int> ans;\\n     vector<int> preorderTraversal(TreeNode* root) {\\n         if(root==NULL)return ans;\\n\\t\\t ans.push_back(root->val);\\n         preorderTraversal(root->left);\\n         preorderTraversal(root->right);\\n         return ans;\\n     }\\n}; \\n```\\n#### Iterative method using Stack(0ms) \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> store;\\n        while(!store.empty() || root){\\n            if(root){\\n                ans.push_back(root->val); // print root\\n                if(root->right){ \\n                    store.push(root->right);//put into stack so that after print left we can go right\\n                }\\n                root=root->left; // make root of left sub tree;\\n            }\\n            else{\\n                root=store.top();//if root is null that means left tree is not there; we pop the node\\n                store.pop();\\n            }\\n        }\\n\\t\\t return ans;\\n    }\\n};\\n```\\n\\n#### **Morris Traversal in O(1) space and O(N) time**\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        while(root){\\n            if(root->left==NULL){ // if left not there, add root to answer\\n                ans.push_back(root->val);\\n                root=root->right; // go to right (bcz left is not there)\\n            }\\n            else{  // left is there then find the predecessor of root(for tracking to root after visiting left)\\n                TreeNode* temp = root;\\n                temp=temp->left;\\n                while(temp->right && temp->right!=root){\\n                    temp = temp->right;\\n                }\\n                if(temp->right==NULL){  //link predecessor->right to root(to go to root)\\n                    temp->right=root;\\n                    ans.push_back(root->val); // push the root node (we are going in left direction so before that add root as ans);\\n                    root=root->left;// goto left direction \\n                }\\n                else{ // if predecessor is linked with root that means left subtree is already visited; goto right \\n                    temp->right=NULL;\\n                    root=root->right;\\n                }    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### **If you like the solution please upvote it. Thanks**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int> ans;\\n     vector<int> preorderTraversal(TreeNode* root) {\\n         if(root==NULL)return ans;\\n\\t\\t ans.push_back(root->val);\\n         preorderTraversal(root->left);\\n         preorderTraversal(root->right);\\n         return ans;\\n     }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        stack<TreeNode*> store;\\n        while(!store.empty() || root){\\n            if(root){\\n                ans.push_back(root->val); // print root\\n                if(root->right){ \\n                    store.push(root->right);//put into stack so that after print left we can go right\\n                }\\n                root=root->left; // make root of left sub tree;\\n            }\\n            else{\\n                root=store.top();//if root is null that means left tree is not there; we pop the node\\n                store.pop();\\n            }\\n        }\\n\\t\\t return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        while(root){\\n            if(root->left==NULL){ // if left not there, add root to answer\\n                ans.push_back(root->val);\\n                root=root->right; // go to right (bcz left is not there)\\n            }\\n            else{  // left is there then find the predecessor of root(for tracking to root after visiting left)\\n                TreeNode* temp = root;\\n                temp=temp->left;\\n                while(temp->right && temp->right!=root){\\n                    temp = temp->right;\\n                }\\n                if(temp->right==NULL){  //link predecessor->right to root(to go to root)\\n                    temp->right=root;\\n                    ans.push_back(root->val); // push the root node (we are going in left direction so before that add root as ans);\\n                    root=root->left;// goto left direction \\n                }\\n                else{ // if predecessor is linked with root that means left subtree is already visited; goto right \\n                    temp->right=NULL;\\n                    root=root->right;\\n                }    \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052899,
                "title": "c-solution",
                "content": "```\\n\\nint nodeCount(struct TreeNode* root) {\\n    if (NULL == root)\\n        return 0;\\n    \\n    return (nodeCount(root->left)+ nodeCount(root->right)) + 1;\\n}\\n\\nvoid preorder(struct TreeNode* root, int *res, int *size) {\\n    if(NULL == root)\\n        return;\\n    \\n    res[(*size)++] = root->val;\\n    preorder(root->left, res, size);\\n    preorder(root->right, res, size);\\n}\\n\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    int lev = nodeCount(root);\\n    \\n    int *result =(int*)malloc(sizeof(int)*lev+1);\\n    *returnSize = 0;\\n\\n    preorder(root, result, returnSize);\\n    \\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint nodeCount(struct TreeNode* root) {\\n    if (NULL == root)\\n        return 0;\\n    \\n    return (nodeCount(root->left)+ nodeCount(root->right)) + 1;\\n}\\n\\nvoid preorder(struct TreeNode* root, int *res, int *size) {\\n    if(NULL == root)\\n        return;\\n    \\n    res[(*size)++] = root->val;\\n    preorder(root->left, res, size);\\n    preorder(root->right, res, size);\\n}\\n\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    int lev = nodeCount(root);\\n    \\n    int *result =(int*)malloc(sizeof(int)*lev+1);\\n    *returnSize = 0;\\n\\n    preorder(root, result, returnSize);\\n    \\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45394,
                "title": "simple-iterative-and-recursive-solutions",
                "content": "\\n**Solution 1, Iterative**\\n\\n    def preorderTraversal(self, root):\\n        stack, ans =[root], []\\n        while stack:\\n            node = stack.pop(-1)\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                ans.append(node.val)\\n                node=node.left\\n        return ans\\n\\n<br><br>\\n\\n**Solution 2 , Recursive**\\n\\n    def preorderTraversal(self, root):\\n        def DFS(node):\\n            if node:\\n                ans.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        ans = []\\n        DFS(root)\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n**Solution 1, Iterative**\\n\\n    def preorderTraversal(self, root):\\n        stack, ans =[root], []\\n        while stack:\\n            node = stack.pop(-1)\\n            while node:\\n                if node.right:\\n                    stack.append(node.right)\\n                ans.append(node.val)\\n                node=node.left\\n        return ans\\n\\n<br><br>\\n\\n**Solution 2 , Recursive**\\n\\n    def preorderTraversal(self, root):\\n        def DFS(node):\\n            if node:\\n                ans.append(node.val)\\n                DFS(node.left)\\n                DFS(node.right)\\n        ans = []\\n        DFS(root)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 3022165,
                "title": "java-easy-to-understand-explanation-for-all-traversal",
                "content": "Its just a simple dfs on the tree. They ask you to do the pre-order traversal. So first we add the element to the list then traversal the left sub tree and then right sub tree.\\n\\n## Type of Traversal\\n\\nInorder    -> left , current , right\\nPre-order  -> current , left , right\\nPost order -> left , right , current\\n\\nLeft means traversal the left sub tree.\\nRight means traversal the right sub tree.\\nCurrent means we need to do the process for the current node. Here we simiply added into the list.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void dfs(TreeNode root,List<Integer> l){\\n        if(root == null)return;\\n        l.add(root.val);\\n        dfs(root.left,l);\\n        dfs(root.right,l);\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        dfs(root,l);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    void dfs(TreeNode root,List<Integer> l){\\n        if(root == null)return;\\n        l.add(root.val);\\n        dfs(root.left,l);\\n        dfs(root.right,l);\\n    }\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> l = new ArrayList<>();\\n        dfs(root,l);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021963,
                "title": "dfs-pre-order-js",
                "content": "# Approach\\nDepth first search.\\n\\nT: O(n)  S: O(n)\\n\\n\\n\\n# Code\\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  DFS(root);\\n  return arr;\\n  function DFS(node) {\\n    if (!node) return;\\n    arr.push(node.val);\\n    DFS(node.left);\\n    DFS(node.right);\\n  }\\n};\\n\\n```\\n\\n\\nor\\n\\n# Code\\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return [];\\n  arr.push(node.val);\\n  preorderTraversal(root.left, arr);\\n  preorderTraversal(root.right, arr);\\n  return arr;\\n}\\n```\\nor\\n# Code\\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return arr;\\n  return [root.val,...preorderTraversal(root.left, arr),...preorderTraversal(root.right, arr)];\\n};\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar preorderTraversal = function (root, arr = []) {\\n  DFS(root);\\n  return arr;\\n  function DFS(node) {\\n    if (!node) return;\\n    arr.push(node.val);\\n    DFS(node.left);\\n    DFS(node.right);\\n  }\\n};\\n\\n```\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return [];\\n  arr.push(node.val);\\n  preorderTraversal(root.left, arr);\\n  preorderTraversal(root.right, arr);\\n  return arr;\\n}\\n```\n```\\nvar preorderTraversal = function (root, arr = []) {\\n  if (!root) return arr;\\n  return [root.val,...preorderTraversal(root.left, arr),...preorderTraversal(root.right, arr)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008946,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity : $$O(N)$$\\n\\n- Space complexity : $$O(1)$$, if we don\\u2019t consider the size of the stack for function. Otherwise, $$O(H)$$ where H is the height of the tree. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root!=NULL)\\n        {\\n            res.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root!=NULL)\\n        {\\n            res.push_back(root->val);\\n            preorderTraversal(root->left);\\n            preorderTraversal(root->right); \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294410,
                "title": "3-approaches-in-c-recursive-iterative-morris-traversal",
                "content": "**Recursive Approach:**\\n````\\nvoid help(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL)\\n            return;\\n        ans.push_back(root->val);\\n        help(root->left, ans);\\n        help(root->right, ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        help(root, ans);\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Iterative Approach:**\\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            root = st.top();\\n            st.pop();\\n            ans.push_back(root->val);\\n            if(root->right!=NULL)\\n            {\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL)\\n            {\\n                st.push(root->left);\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n-------------------------------------------------------------------------------------------------------\\n**Morris Traversal :**\\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    ans.push_back(node->val);\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n````\\n\\n**One Request : Please do upvote if you found these solutions helpful. Thanks in advance!**",
                "solutionTags": [],
                "code": "````\\nvoid help(TreeNode* root, vector<int>& ans)\\n    {\\n        if(root == NULL)\\n            return;\\n        ans.push_back(root->val);\\n        help(root->left, ans);\\n        help(root->right, ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        help(root, ans);\\n        return ans;\\n    }\\n```\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root==NULL) return ans;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            root = st.top();\\n            st.pop();\\n            ans.push_back(root->val);\\n            if(root->right!=NULL)\\n            {\\n                st.push(root->right);\\n            }\\n            if(root->left!=NULL)\\n            {\\n                st.push(root->left);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n````\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode *node = root;\\n        while(node != NULL)\\n        {\\n            if(node->left == NULL) \\n            {\\n                ans.push_back(node->val);\\n                node = node->right;\\n            }\\n            else\\n            {\\n                TreeNode *prev = node->left;\\n                while(prev->right && prev->right != node)\\n                {\\n                    prev = prev->right;\\n                }\\n                if(prev->right == NULL)\\n                {\\n                    prev->right = node;\\n                    ans.push_back(node->val);\\n                    node = node->left;\\n                }\\n                else\\n                {\\n                    prev->right = NULL;\\n                    node = node->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248114,
                "title": "java-standard-iterative-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans;\\n      \\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      st.push(root);\\n      \\n      while(!st.isEmpty()) {\\n        TreeNode cur = st.pop(); \\n        ans.add(cur.val);\\n        \\n          if(cur.right != null) st.push(cur.right);\\n          if(cur.left != null) st.push(cur.left);\\n      }\\n      return ans;\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n     ArrayList<Integer> ans = new ArrayList<Integer>();\\n      if(root == null) return ans;\\n      \\n      Stack<TreeNode> st = new Stack<TreeNode>();\\n      st.push(root);\\n      \\n      while(!st.isEmpty()) {\\n        TreeNode cur = st.pop(); \\n        ans.add(cur.val);\\n        \\n          if(cur.right != null) st.push(cur.right);\\n          if(cur.left != null) st.push(cur.left);\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976349,
                "title": "100-percent-faster-easy-to-understand",
                "content": "class Solution {\\n    private : vector<int>res;\\n    void preorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        res.push_back(root->val);\\n        preorder(root->left,res);\\n        preorder(root->right,res);\\n        return;\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        preorder(root,res);\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    private : vector<int>res;\\n    void preorder(TreeNode *root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n            return;\\n        res.push_back(root->val);\\n        preorder(root->left,res);\\n        preorder(root->right,res);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1846236,
                "title": "simple-python-solution-recursive-and-iterative-both",
                "content": "**Iterative approach using stack:**\\n```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        if root==None:\\n            return None\\n        stack=[root]\\n        while len(stack)>0:\\n            temp=stack.pop(-1)\\n            ans.append(temp.val)\\n            if temp.right!=None:\\n                stack.append(temp.right)\\n            if temp.left!=None:\\n                stack.append(temp.left)\\n        return ans\\n```\\n\\n**Recursive approach:**\\n```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tans=[]\\n        def preorder(root):\\n            if root==None:\\n                return None\\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        if root==None:\\n            return None\\n        stack=[root]\\n        while len(stack)>0:\\n            temp=stack.pop(-1)\\n            ans.append(temp.val)\\n            if temp.right!=None:\\n                stack.append(temp.right)\\n            if temp.left!=None:\\n                stack.append(temp.left)\\n        return ans\\n```\n```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n\\t\\tans=[]\\n        def preorder(root):\\n            if root==None:\\n                return None\\n            ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1765377,
                "title": "python3-easiest-solution",
                "content": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        \\n        if root:\\n            res+= [root.val]\\n            res+= self.preorderTraversal(root.left)\\n            res+= self.preorderTraversal(root.right)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        res = []\\n        \\n        if root:\\n            res+= [root.val]\\n            res+= self.preorderTraversal(root.left)\\n            res+= self.preorderTraversal(root.right)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886830,
                "title": "python-20ms-classic-implementation",
                "content": "Runtime: 20 ms, faster than 98.55% of Python3 online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 14.1 MB, less than 99.97% of Python3 online submissions for Binary Tree Preorder Traversal.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def preorder(root):\\n            if root is None:\\n                return\\n            self.ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        self.ans=[]\\n        def preorder(root):\\n            if root is None:\\n                return\\n            self.ans.append(root.val)\\n            preorder(root.left)\\n            preorder(root.right)\\n        preorder(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180119,
                "title": "javascript",
                "content": "```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null){\\n            result.push(root.val);\\n            dfs(root.left);\\n            dfs(root.right);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    dfs(root);\\n    \\n    function dfs(root) {\\n        if(root != null){\\n            result.push(root.val);\\n            dfs(root.left);\\n            dfs(root.right);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158275,
                "title": "python-stack-dfs",
                "content": "### 144. Binary Tree Preorder Traversal\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS Stack | Recursive\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\\n\\n#### DFS Recursive\\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.res.append(root.val)\\n        self.dfs(root.left)\\n        self.dfs(root.right)     \\n```\\n\\n#### Stack\\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        res = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS Stack | Recursive\\n> Time Complexity O(n)\\n> Space Complexity O(1)\\n```\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        self.res = []\\n        self.dfs(root)\\n        return self.res\\n    \\n    def dfs(self, root):\\n        if not root:\\n            return \\n        self.res.append(root.val)\\n        self.dfs(root.left)\\n        self.dfs(root.right)     \\n```\n```python\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        res = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if node:\\n                res.append(node.val)\\n                stack.append(node.right)\\n                stack.append(node.left)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45292,
                "title": "python-one-line",
                "content": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        return [root.val]+ self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n\\n        return [root.val]+ self.preorderTraversal(root.left) + self.preorderTraversal(root.right) if root else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45366,
                "title": "accepted-iterative-simplest-solution-in-java-using-stack",
                "content": "    public class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            if(root!=null) stack.push(root);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                list.add(node.val);\\n                if(node.right!=null) stack.push(node.right);\\n                if(node.left!=null) stack.push(node.left);\\n            }\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<Integer> preorderTraversal(TreeNode root) {\\n            List<Integer> list = new LinkedList<Integer>();\\n            Stack<TreeNode> stack = new Stack<TreeNode>();\\n            if(root!=null) stack.push(root);\\n            while(!stack.isEmpty()){\\n                TreeNode node = stack.pop();\\n                list.add(node.val);\\n                if(node.right!=null) stack.push(node.right);\\n                if(node.left!=null) stack.push(node.left);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 45389,
                "title": "java-solution-preorder-morris-traversal",
                "content": "![preorder Morris traversal][1]\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n        List<Integer> list = new ArrayList();\\n        \\n        while(node != null) {\\n            if(node.left == null) {\\n                list.add(node.val);\\n                node = node.right;\\n            }\\n            else {\\n                TreeNode nextNode = node.left;\\n                \\n                TreeNode p = nextNode;\\n                while(p.right != null) p = p.right;\\n                \\n                list.add(node.val);\\n                p.right = node.right;\\n                node = nextNode;\\n            }\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg",
                "solutionTags": [],
                "code": "![preorder Morris traversal][1]\\n\\n    public List<Integer> preorderTraversal(TreeNode node) {\\n        List<Integer> list = new ArrayList();\\n        \\n        while(node != null) {\\n            if(node.left == null) {\\n                list.add(node.val);\\n                node = node.right;\\n            }\\n            else {\\n                TreeNode nextNode = node.left;\\n                \\n                TreeNode p = nextNode;\\n                while(p.right != null) p = p.right;\\n                \\n                list.add(node.val);\\n                p.right = node.right;\\n                node = nextNode;\\n            }\\n        }\\n        return list;\\n    }\\n\\n\\n  [1]: http://images.cnitblog.com/blog/300640/201306/14221458-aa5f9e92cce743ccacbc735048133058.jpg",
                "codeTag": "Unknown"
            },
            {
                "id": 45446,
                "title": "elegant-c-iterative-solution-0ms-10-lines",
                "content": "    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        stack<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto p = q.top();\\n            q.pop();\\n            if(p == NULL)\\n            {\\n                continue;\\n            }\\n            result.push_back(p->val);\\n            q.push(p->right);\\n            q.push(p->left);\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> result;\\n        stack<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            auto p = q.top();\\n            q.pop();\\n            if(p == NULL)\\n            {\\n                continue;\\n            }\\n            result.push_back(p->val);\\n            q.push(p->right);\\n            q.push(p->left);\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3024604,
                "title": "python-3-recursive-and-iterative-solutions-visual-explanation",
                "content": "Here is the visual explanation for the iterative version.\\nI\\'m waiting for your comments\\uD83D\\uDCA1\\n**Upvote** if you like this post!\\n\\n![return (1).png](https://assets.leetcode.com/users/images/c8ae62f3-3b86-4713-b7a1-5f0c37a35f4f_1673265765.4591982.png)\\n\\n\\n\\n\\n# Iterative Version\\n```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res, stack = [], [root]\\n\\n        while stack:\\n            n = stack.pop()\\n            if n:\\n                pre_list.append(n.val)\\n                stack.append(n.right)\\n                stack.append(n.left)\\n\\n        return self.res\\n```\\n\\n# Recursive Version\\n```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res = []\\n\\n        def preorder(curr):\\n            if curr:\\n                self.res.append(curr.val)\\n                preorder(curr.left)\\n                preorder(curr.right)\\n        \\n        preorder(root)\\n        return self.res\\n```\\n\\n\\n**Upvote** if you like this post!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res, stack = [], [root]\\n\\n        while stack:\\n            n = stack.pop()\\n            if n:\\n                pre_list.append(n.val)\\n                stack.append(n.right)\\n                stack.append(n.left)\\n\\n        return self.res\\n```\n```\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.res = []\\n\\n        def preorder(curr):\\n            if curr:\\n                self.res.append(curr.val)\\n                preorder(curr.left)\\n                preorder(curr.right)\\n        \\n        preorder(root)\\n        return self.res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3022592,
                "title": "c-easy-solution-using-recursion-and-moris-traversal",
                "content": "# **C++ Easy Solution Using Recursion and Moris traversal**\\n* # **Recursive Traversal**\\n```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode*&root,vector<int>&pre){\\n        if(root){\\n            pre.push_back(root->val);\\n            preorder(root->left,pre);\\n            preorder(root->right,pre);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        preorder(root,pre);\\n        return pre;\\n    }\\n};\\n```\\n# ***Time Complexity : `O(N)`***\\n# ***Space Complexity : `O(N)`***\\n* # **Moris Traversal**\\n```\\nclass Solution {\\npublic:\\n    TreeNode* rightMostFinder(TreeNode*cur,TreeNode*root){\\n        while(cur->right&&cur->right!=root){\\n            cur=cur->right;\\n        }\\n        return cur;\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        TreeNode*cur=root;\\n        vector<int>ans;\\n        while(cur){\\n            TreeNode*leftNode=cur->left;\\n            if(leftNode){\\n                TreeNode*RightMost=rightMostFinder(leftNode,cur);\\n                if(RightMost->right){\\n                    RightMost->right=nullptr;\\n                    cur=cur->right;\\n                }\\n                else{\\n                    RightMost->right=cur;\\n                    ans.push_back(cur->val);\\n                    cur=cur->left;\\n                }\\n            }\\n            else{\\n                ans.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# ***Time Complexity : `O(N)`***\\n# ***Space Complexity : `O(1)`***\\n# **Please Upvote if solution Helped You It really motivates me\\uD83D\\uDE0A**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void preorder(TreeNode*&root,vector<int>&pre){\\n        if(root){\\n            pre.push_back(root->val);\\n            preorder(root->left,pre);\\n            preorder(root->right,pre);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        preorder(root,pre);\\n        return pre;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* rightMostFinder(TreeNode*cur,TreeNode*root){\\n        while(cur->right&&cur->right!=root){\\n            cur=cur->right;\\n        }\\n        return cur;\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        TreeNode*cur=root;\\n        vector<int>ans;\\n        while(cur){\\n            TreeNode*leftNode=cur->left;\\n            if(leftNode){\\n                TreeNode*RightMost=rightMostFinder(leftNode,cur);\\n                if(RightMost->right){\\n                    RightMost->right=nullptr;\\n                    cur=cur->right;\\n                }\\n                else{\\n                    RightMost->right=cur;\\n                    ans.push_back(cur->val);\\n                    cur=cur->left;\\n                }\\n            }\\n            else{\\n                ans.push_back(cur->val);\\n                cur=cur->right;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022462,
                "title": "c-three-solutions-recursive-iterative-morris-traversal",
                "content": "# Approach 1\\nRecursive Traversal \\n# Complexity\\n- Time complexity : $$O(n)$$\\n- Space complexity: $$O(n)$$ (Function Call Stack)\\n# Code\\n```\\nclass Solution {\\n    void traverse(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)return;\\n        \\n        ans.push_back(root->val);\\n        traverse(root->left,ans);\\n        traverse(root->right,ans);\\n    }\\n    \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        traverse(root,ans);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative Traversal with Stack \\n# Complexity\\n- Time complexity : $$O(n)$$\\n- Space complexity: $$O(n)$$ (Stack space)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        \\n        if(root==NULL) return ans;\\n        st.push(root);\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode *node=st.top();\\n            st.pop();\\n            \\n            if(node->right!=NULL) st.push(node->right);\\n            if(node->left!=NULL) st.push(node->left);\\n        \\n            ans.push_back(node->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Approach 3\\nMorris Traversal \\n# Complexity\\n- Time complexity : $$O(n)$$\\n- Space complexity: $$O(1)$$ \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n{\\n        vector<int>ans;\\n        TreeNode* curr=root;\\n        \\n        while(curr!=NULL)\\n        {\\n            if(curr->left==NULL)\\n            {\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* prev=curr->left;\\n                \\n                while(prev->right!=NULL && prev->right!=curr)\\n                {\\n                    prev=prev->right;\\n                }\\n\\n                if(prev->right==NULL)\\n                {\\n                    prev->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    prev->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode* root,vector<int>& ans)\\n    {\\n        if(root==NULL)return;\\n        \\n        ans.push_back(root->val);\\n        traverse(root->left,ans);\\n        traverse(root->right,ans);\\n    }\\n    \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        vector<int> ans;\\n        traverse(root,ans);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        stack<TreeNode*>st;\\n        \\n        if(root==NULL) return ans;\\n        st.push(root);\\n        \\n        while(!st.empty())\\n        {\\n            TreeNode *node=st.top();\\n            st.pop();\\n            \\n            if(node->right!=NULL) st.push(node->right);\\n            if(node->left!=NULL) st.push(node->left);\\n        \\n            ans.push_back(node->val);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) \\n{\\n        vector<int>ans;\\n        TreeNode* curr=root;\\n        \\n        while(curr!=NULL)\\n        {\\n            if(curr->left==NULL)\\n            {\\n                ans.push_back(curr->val);\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode* prev=curr->left;\\n                \\n                while(prev->right!=NULL && prev->right!=curr)\\n                {\\n                    prev=prev->right;\\n                }\\n\\n                if(prev->right==NULL)\\n                {\\n                    prev->right=curr;\\n                    ans.push_back(curr->val);\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    prev->right=NULL;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022357,
                "title": "c-recursion-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Using Recursive Approach.\\n\\n# Approach\\n- A binary tree is a recursive object where we have three essential components\\n     - Root node: The topmost node of a binary tree.\\n\\n    - Left-subtree: A smaller binary tree connected via the left pointer of root node.\\n\\n    - Right-subtree: A smaller binary tree connected via the right pointer of root node.\\n\\n- So traversing a binary tree requires traversal of each component Processing root node, traversing the left subtreeand traversing the right subtree.\\n\\n![image.png](https://assets.leetcode.com/users/images/cad94ad3-9f35-497f-ac31-166c06c6d627_1673231417.744738.png)\\n\\n## Recursive preorder traversal of binary tree \\n- In recursive preorder traversal, we first process the root node, then process all nodes in the left subtree, and finally, we process all nodes in the right subtree Suppose we use a function precrder(root) with root as an input parameter.\\n\\n### Steps of recursive preorder implementation\\n\\n- First, store data stored in the root node i.e process(root->value) in vector\\n- Then we recursively traverse and process each node in the left subtree by calling the same function with root->left as input parameter i.e preorder(root->left).\\n- Then we recursively traverse and process each node in the right subtree by calling the same function with rout->right as input parameter ie preorder(root->right). \\n- Base case: recursion will terminate and backtrack when it reaches the bottommost end of binary tree, i.e root==NULL\\n\\n![image.png](https://assets.leetcode.com/users/images/a4ee446e-7b0d-41a2-bac8-365b4398b3db_1673231891.0546484.png)\\n![image.png](https://assets.leetcode.com/users/images/41544952-4e5f-4f7d-8861-273e3e7b0ce5_1673231902.5866964.png)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &a)\\n        {\\n            // Base Case\\n            if(root==NULL)\\n                return;\\n\\n            a.push_back(root->val);// store in vector\\n            preorder(root->left,a);// recursion for left sub tree\\n            preorder(root->right,a);// recursion for right sub tree\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       vector<int> a;\\n        preorder(root,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &a)\\n        {\\n            // Base Case\\n            if(root==NULL)\\n                return;\\n\\n            a.push_back(root->val);// store in vector\\n            preorder(root->left,a);// recursion for left sub tree\\n            preorder(root->right,a);// recursion for right sub tree\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       vector<int> a;\\n        preorder(root,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022151,
                "title": "rust-iterative-recursive-0ms",
                "content": "# Approach\\nThe recursive version descends the tree through recursive calls with their state pushed on the execution stack. The traversal prefers the left branch over the right, and the output is built before descending either branch.\\n\\nThe iterative version is very similar. It also uses a stack to preserve the state of traversal. The right branch is pushed before the left, since the left branch needs to be popped before the right. The output is updated before pushing any branches.\\n\\nThe cloning operations in the code don\\'t clone the actual tree nodes, what\\'s being cloned are the smart pointers that reference them. I don\\'t believe there\\'s any value in avoiding cloning these.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ Each node is visited in turn - no searching.\\n- Space complexity: $$O(n + log_2(n))$$ *auxiliary* memory used. The returned vector accounts for the $$n + $$ term. For the $$log_2(n)$$ term, the memory used when pushing an execution stack frame counts in the same way the memory used when pushing an iterative stack item counts. The height of the tree determines the max number of stack items that will be piled up at any time during traversal. Assuming the tree is balanced, the height will be $$log_2(n)$$.\\n\\n# Code\\n```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype NodeOpt = Option<Rc<RefCell<TreeNode>>>;\\n\\nimpl Solution {\\n    pub fn preorder_traversal(root: NodeOpt) -> Vec<i32> {\\n        Self::preorder_traversal_iter(root)\\n        //let mut result = vec![];\\n        //Self::preorder_traversal_recurs(root, &mut result);\\n        //result\\n    }\\n    fn preorder_traversal_recurs(root: NodeOpt, result: &mut Vec<i32>) {\\n        if let Some(pnode) = root {\\n            let node = pnode.borrow();\\n            result.push(node.val);\\n            Self::preorder_traversal_recurs(node.left.clone(), result);\\n            Self::preorder_traversal_recurs(node.right.clone(), result);\\n        }\\n    }\\n    fn preorder_traversal_iter(root: NodeOpt) -> Vec<i32> {\\n        let mut result = vec![];\\n        let mut stack  = vec![root];\\n        while let Some(node_opt) = stack.pop() {\\n            if let Some(pnode) = node_opt {\\n                let node = pnode.borrow();\\n                result.push(node.val);\\n                stack.push(node.right.clone());\\n                stack.push(node.left.clone());\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\ntype NodeOpt = Option<Rc<RefCell<TreeNode>>>;\\n\\nimpl Solution {\\n    pub fn preorder_traversal(root: NodeOpt) -> Vec<i32> {\\n        Self::preorder_traversal_iter(root)\\n        //let mut result = vec![];\\n        //Self::preorder_traversal_recurs(root, &mut result);\\n        //result\\n    }\\n    fn preorder_traversal_recurs(root: NodeOpt, result: &mut Vec<i32>) {\\n        if let Some(pnode) = root {\\n            let node = pnode.borrow();\\n            result.push(node.val);\\n            Self::preorder_traversal_recurs(node.left.clone(), result);\\n            Self::preorder_traversal_recurs(node.right.clone(), result);\\n        }\\n    }\\n    fn preorder_traversal_iter(root: NodeOpt) -> Vec<i32> {\\n        let mut result = vec![];\\n        let mut stack  = vec![root];\\n        while let Some(node_opt) = stack.pop() {\\n            if let Some(pnode) = node_opt {\\n                let node = pnode.borrow();\\n                result.push(node.val);\\n                stack.push(node.right.clone());\\n                stack.push(node.left.clone());\\n            }\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867567,
                "title": "beated-94-21-javascript-simple-small-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar preorderTraversal = function (root) {\\n    let arr = []\\n    const getVal = (root) => {\\n        if(!root)\\n        return         \\n        arr.push(root.val)\\n        getVal(root.left)\\n        getVal(root.right)\\n    }\\n    getVal(root)\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar preorderTraversal = function (root) {\\n    let arr = []\\n    const getVal = (root) => {\\n        if(!root)\\n        return         \\n        arr.push(root.val)\\n        getVal(root.left)\\n        getVal(root.right)\\n    }\\n    getVal(root)\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745358,
                "title": "java-iterative-and-recursive-clean-and-simple",
                "content": "# Please Upvote \\uD83D\\uDE07\\n---\\n### 1. Recursive approach:\\n``` java []\\nclass Solution {\\n    private List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return ans;\\n    }\\n\\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        ans.add(root.val);\\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\\n---\\n### 2. Iterative approach:\\n``` java []\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n\\n        while (!st.isEmpty()) {\\n            TreeNode curr = st.pop();\\n            ans.add(curr.val);\\n\\n            if (curr.right != null) {\\n                st.push(curr.right);\\n            }\\n            if (curr.left != null) {\\n                st.push(curr.left);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    private List<Integer> ans = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        traverse(root);\\n        return ans;\\n    }\\n\\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        ans.add(root.val);\\n        traverse(root.left);\\n        traverse(root.right);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```\n``` java []\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (root == null) {\\n            return ans;\\n        }\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n\\n        while (!st.isEmpty()) {\\n            TreeNode curr = st.pop();\\n            ans.add(curr.val);\\n\\n            if (curr.right != null) {\\n                st.push(curr.right);\\n            }\\n            if (curr.left != null) {\\n                st.push(curr.left);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570075,
                "title": "recursion-time-complexity-space-complexity-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodeVec;\\n        doTraversal(nodeVec,root);\\n        return nodeVec;\\n    }\\n    void doTraversal(vector<int> &nodeVec, TreeNode* temp)\\n    {\\n        if(temp==nullptr)\\n            return;\\n        nodeVec.push_back(temp->val);\\n        doTraversal(nodeVec,temp->left);\\n        doTraversal(nodeVec,temp->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971310,
                "title": "python-iterative-recursive-solution",
                "content": "## Leecode 144 - Preorder\\n### Iterative Tree Traversal\\n```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res, stack = [], [root]\\n\\n    while stack:\\n        root = stack.pop()\\n\\n        if root:\\n            res.append(root.val)\\n            stack.append(root.right)\\n            stack.append(root.left)\\n        \\n    return res\\n```\\n### Recursive Tree Traversal\\n```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res = []\\n\\n    def dfs(node: TreeNode):\\n        if node:\\n            result.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n\\n    dfs(root)\\n    return res\\n```\\n\\n# Question List\\n94\\\\. Binary Tree Inorder Traversal \\\\\\n102\\\\. Binary Tree Level Order Traversal \\\\\\n144\\\\. Binary Tree Preorder Traversal \\\\\\n145\\\\. Binary Tree Postorder Traversal",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res, stack = [], [root]\\n\\n    while stack:\\n        root = stack.pop()\\n\\n        if root:\\n            res.append(root.val)\\n            stack.append(root.right)\\n            stack.append(root.left)\\n        \\n    return res\\n```\n```python\\ndef preorderTraversal(self, root: TreeNode) -> List[int]:\\n    res = []\\n\\n    def dfs(node: TreeNode):\\n        if node:\\n            result.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n\\n    dfs(root)\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 937276,
                "title": "java-iterative-and-recursive-inorder-preorder-postorder-dfs-traversal",
                "content": "****************DFS Iterative Traversal****************\\n\\n****************\\n\\n**Inorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(stack.size() > 0 || root != null) {\\n            while(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n\\n        return list;\\n    }\\n}\\n```\\n\\n\\n****************\\n\\n**Preorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null)\\n                stack.add(root.right);\\n            if(root.left != null)\\n                stack.add(root.left);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n\\n****************\\n\\n**Postorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        Stack<TreeNode> stack = new Stack();\\n        while(!stack.isEmpty() || root != null) {\\n            if(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            } else {\\n                TreeNode temp = stack.peek().right;\\n                if(temp == null) {\\n                    temp = stack.pop();\\n                    list.add(temp.val);\\n                    while(!stack.isEmpty() && temp ==  stack.peek().right) {\\n                        temp = stack.pop();\\n                        list.add(temp.val);\\n                    }\\n                } else {\\n                    root = temp;\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\n**Postorder from Preorder - Reverse the steps of pushing left and right child into stack and reverse full list in the end.**\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.left != null)\\n                stack.add(root.left);\\n            if(root.right != null)\\n                stack.add(root.right);\\n        }\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```\\n\\n****************\\n\\n****************DFS Recrsive Traversal****************\\n\\n**Inorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        list.add(root.val);\\n        dfs(root.right, list);\\n    } \\n}\\n```\\n\\n****************\\n\\n**Preorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n```\\n\\n****************\\n\\n**Postorder**\\n\\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n        list.add(root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if (root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(stack.size() > 0 || root != null) {\\n            while(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n        }\\n\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.right != null)\\n                stack.add(root.right);\\n            if(root.left != null)\\n                stack.add(root.left);\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        Stack<TreeNode> stack = new Stack();\\n        while(!stack.isEmpty() || root != null) {\\n            if(root != null) {\\n                stack.add(root);\\n                root = root.left;\\n            } else {\\n                TreeNode temp = stack.peek().right;\\n                if(temp == null) {\\n                    temp = stack.pop();\\n                    list.add(temp.val);\\n                    while(!stack.isEmpty() && temp ==  stack.peek().right) {\\n                        temp = stack.pop();\\n                        list.add(temp.val);\\n                    }\\n                } else {\\n                    root = temp;\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        if(root == null)\\n            return list;\\n        Stack<TreeNode> stack = new Stack();\\n        stack.add(root);\\n        while(!stack.isEmpty()) {\\n            root = stack.pop();\\n            list.add(root.val);\\n            if(root.left != null)\\n                stack.add(root.left);\\n            if(root.right != null)\\n                stack.add(root.right);\\n        }\\n        Collections.reverse(list);\\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        list.add(root.val);\\n        dfs(root.right, list);\\n    } \\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        list.add(root.val);\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> postorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList();\\n        dfs(root, list);\\n        return list;\\n    }\\n    \\n    private void dfs(TreeNode root, List<Integer> list) {\\n        if(root == null)\\n            return;\\n        dfs(root.left, list);\\n        dfs(root.right, list);\\n        list.add(root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806233,
                "title": "scala-recursive",
                "content": "```\\nobject Solution {\\n    def preorderTraversal(root: TreeNode): List[Int] = {\\n        Option(root) match {\\n            case Some(node) => List(node.value) ++ preorderTraversal(node.left) ++ preorderTraversal(node.right)\\n            case _ => List()\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\nobject Solution {\\n    def preorderTraversal(root: TreeNode): List[Int] = {\\n        Option(root) match {\\n            case Some(node) => List(node.value) ++ preorderTraversal(node.left) ++ preorderTraversal(node.right)\\n            case _ => List()\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 774069,
                "title": "runtime-0-ms-faster-than-100-00-c-iterative",
                "content": "\\n    class Solution {\\n        public:\\n            vector<int> preorderTraversal(TreeNode* root) {\\n                if(root==NULL)\\n                   return {};\\n                vector<int> vec;\\n                stack<TreeNode*> s;\\n                while(true){\\n                    if(root!=NULL){\\n                       s.push(root);\\n                       vec.push_back(root->val); \\n                       root=root->left; \\n                    }\\n                    else{\\n                        if(s.empty())\\n                            break;\\n                        root=s.top();\\n                        s.pop();\\n                        root=root->right;\\n                    }\\n                }\\n                return vec;\\n            }\\n      };\\n\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public:\\n            vector<int> preorderTraversal(TreeNode* root) {\\n                if(root==NULL)\\n                   return {}",
                "codeTag": "Java"
            },
            {
                "id": 446676,
                "title": "one-line-recursive-javascript-solution",
                "content": "``` javascript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : [];\\n};\\n```\\n\\nOff course iterative solution is better.",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    return root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327891,
                "title": "c-o-n-in-place-80-beat-morris-traversal-hot-stinger-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        vector<int> aResult;\\n        \\n        //We memorize the Morris traversal of binary trees.\\n        TreeNode *aNode = root, *aPrev;\\n        while (aNode != NULL) {\\n            if (aNode->left == NULL) {\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            } else {\\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                if (aPrev->right == aNode) {\\n                    aPrev->right = NULL;\\n                    aNode = aNode->right;\\n                } else {\\n                    aResult.push_back(aNode->val);\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nThis only differs slightly from in-order traversal. We \"print\" the node the first time we visit it instead of on the pass-back-through...",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        vector<int> aResult;\\n        \\n        //We memorize the Morris traversal of binary trees.\\n        TreeNode *aNode = root, *aPrev;\\n        while (aNode != NULL) {\\n            if (aNode->left == NULL) {\\n                aResult.push_back(aNode->val);\\n                aNode = aNode->right;\\n            } else {\\n                aPrev = aNode->left;\\n                while (aPrev->right != NULL && aPrev->right != aNode) {\\n                    aPrev = aPrev->right;\\n                }\\n                if (aPrev->right == aNode) {\\n                    aPrev->right = NULL;\\n                    aNode = aNode->right;\\n                } else {\\n                    aResult.push_back(aNode->val);\\n                    aPrev->right = aNode;\\n                    aNode = aNode->left;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148119,
                "title": "java-iterative-and-recursive-solutions",
                "content": "Iterative \\n```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        \\n        while(root != null || !stack.isEmpty()) {\\n            while(root != null) {\\n                list.add(root.val);\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\\n\\nRecursive\\n```\\nclass Solution {\\n    public List<Integer> list = new ArrayList<>();\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if (root == null) {\\n            return list;\\n        }\\n\\n        list.add(root.val);\\n        if (root.left != null)\\n            preorderTraversal(root.left);\\n\\n        if (root.right != null)\\n            preorderTraversal(root.right);\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        \\n        while(root != null || !stack.isEmpty()) {\\n            while(root != null) {\\n                list.add(root.val);\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            root = root.right;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<Integer> list = new ArrayList<>();\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if (root == null) {\\n            return list;\\n        }\\n\\n        list.add(root.val);\\n        if (root.left != null)\\n            preorderTraversal(root.left);\\n\\n        if (root.right != null)\\n            preorderTraversal(root.right);\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45385,
                "title": "my-recursive-and-iterative-cpp-code",
                "content": "**Recursive:**\\n\\n    class Solution {\\n    public:\\n        \\n        vector<int> result;\\n        \\n        void dfs(TreeNode *root)\\n        {\\n            if(!root) return;\\n            \\n            result.push_back(root->val);\\n            dfs(root->left);\\n            dfs(root->right);\\n        }\\n        \\n        vector<int> preorderTraversal(TreeNode* root) \\n        {\\n            dfs(root);\\n            return result;\\n        }\\n    };\\n\\n**Iterative:**\\n\\n    class Solution {\\n    public:\\n        \\n        vector<int> preorderTraversal(TreeNode* root) \\n        {\\n            vector<int> result;\\n            \\n            if(!root) return result;\\n            \\n            stack<TreeNode*> nodes;\\n        \\n            while(root)\\n            {\\n                result.push_back(root->val);\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n            \\n            while( !nodes.empty() )\\n            {\\n                root = nodes.top();\\n                nodes.pop();\\n                \\n                root = root->right;\\n                while(root)\\n                {\\n                    result.push_back(root->val);\\n                    nodes.push(root);\\n                    root = root->left;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        \\n        vector<int> result;\\n        \\n        void dfs(TreeNode *root)\\n        {\\n            if(!root) return;\\n            \\n            result.push_back(root->val);\\n            dfs(root->left);\\n            dfs(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 45482,
                "title": "my-c-solution-recursive-and-stack-based-non-recursive",
                "content": "    For non-recursive, it is simple to use a stack, but just remember to push the right child before the left child  \\n      class Solution {\\n        public:\\n        /*\\n                //recursive solution\\n            void preorderVec(TreeNode *root, vector<int> &result)\\n            {\\n                if(root)\\n                {\\n                    result.push_back(root->val);\\n                    preorderVec(root->left, result);\\n                    preorderVec(root->right, result);\\n                }\\n            }\\n        \\n            vector<int> preorderTraversal(TreeNode *root) {\\n                vector<int> result;\\n                preorderVec(root, result);\\n                return result;\\n            }\\n        */    \\n            vector<int> preorderTraversal(TreeNode *root) {\\n                //non-recursive solution\\n                vector<int> result;\\n                stack<TreeNode *> nodeS;\\n                TreeNode *topS;\\n                if(root)\\n                {// if the tree is non-empty\\n                    nodeS.push(root); // push the root to the stack\\n        \\n                    while(!nodeS.empty())\\n                    {  \\n                        topS = nodeS.top();\\n                        nodeS.pop(); // remove the top node\\n                        // add right child first and then left child\\n                        if(topS->right)\\n                        {\\n                            nodeS.push(topS->right);\\n                        }\\n                        if(topS->left)\\n                        {\\n                            nodeS.push(topS->left);\\n                        }\\n                        \\n                        result.push_back(topS->val);\\n                    }\\n                }\\n                return result;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n        /*\\n                //recursive solution\\n            void preorderVec(TreeNode *root, vector<int> &result)\\n            {\\n                if(root)\\n                {\\n                    result.push_back(root->val);\\n                    preorderVec(root->left, result);\\n                    preorderVec(root->right, result);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3168483,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursive Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        nodes.push_back(root->val);\\n        preorder(root->left, nodes);\\n        preorder(root->right, nodes);    \\n    }       \\n};\\n```\\n\\n# Approach 2\\nIterative Solution\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> preorder;\\n        if (root == NULL)\\n            return preorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n            if (curr->left != NULL)\\n                st.push(curr->left);    \\n        }\\n        return preorder;\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> nodes;\\n        preorder(root, nodes);\\n        return nodes;\\n    }\\nprivate:\\n    void preorder(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        nodes.push_back(root->val);\\n        preorder(root->left, nodes);\\n        preorder(root->right, nodes);    \\n    }       \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector <int> preorder;\\n        if (root == NULL)\\n            return preorder;\\n        stack <TreeNode* > st;\\n        st.push(root);\\n        while (st.empty() != true) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n            preorder.push_back(curr->val);\\n            if (curr->right != NULL)\\n                st.push(curr->right);\\n            if (curr->left != NULL)\\n                st.push(curr->left);    \\n        }\\n        return preorder;\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090382,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root,vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        ans.push_back(root->val);\\n        f(root->left, ans);\\n        f(root->right, ans);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void f(TreeNode* root,vector<int> &ans)\\n    {\\n        if(root==NULL)\\n            return;\\n        ans.push_back(root->val);\\n        f(root->left, ans);\\n        f(root->right, ans);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        f(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025030,
                "title": "100-faster-java-c-solutions-0-ms-with-explanation",
                "content": "\\n# Approach\\n- In PreOrder Traversal First we Consider value of Root Node \\n- After That Consider values of left sub-tree in PreOrder\\n- Afret That Consider Values of Rigth sub-tree in PreOrder \\n\\n# Java Code\\n```\\nclass Solution {\\n    public List<Integer> Answer=new ArrayList<Integer>();\\n//Consider Global List For Answer \\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        if(root==null)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n\\n    public void Travers(TreeNode root)\\n    {\\n        Answer.add(root.val);   // first add value of rood into list of Answer\\n            \\n        if(root.left!=null)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root.left);\\n            \\n        if(root.right!=null)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root.right);\\n    }   \\n}\\n```\\n\\n#  C++ Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> Answer; //Consider Global Vector For Answer \\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        if(root==NULL)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n    void Travers(TreeNode* root)\\n    {\\n        Answer.push_back(root->val);   // first add value of rood into list of Answer\\n            \\n        if(root->left!=NULL)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root->left);\\n            \\n        if(root->right!=NULL)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root->right);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> Answer=new ArrayList<Integer>();\\n//Consider Global List For Answer \\n    public List<Integer> preorderTraversal(TreeNode root) \\n    {\\n        if(root==null)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n\\n    public void Travers(TreeNode root)\\n    {\\n        Answer.add(root.val);   // first add value of rood into list of Answer\\n            \\n        if(root.left!=null)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root.left);\\n            \\n        if(root.right!=null)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root.right);\\n    }   \\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> Answer; //Consider Global Vector For Answer \\n    vector<int> preorderTraversal(TreeNode* root) \\n    {\\n        if(root==NULL)  //if root of tree is null than tree dont have any element so return empty list of Answer\\n            return Answer;  \\n        \\n        Travers(root); //Travers Tree in  preorder(root,left sub-tree,right sub-tree)\\n\\n        return Answer;\\n    }\\n    void Travers(TreeNode* root)\\n    {\\n        Answer.push_back(root->val);   // first add value of rood into list of Answer\\n            \\n        if(root->left!=NULL)     //if root have Left sub-tree than Travers it in preorder\\n            Travers(root->left);\\n            \\n        if(root->right!=NULL)     //if root have Right sub-tree than Travers it in preorder\\n            Travers(root->right);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023226,
                "title": "beats-100-c-simple-recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do three simple steps first insert the data of root and then call left subtree and then call right subtree .This will give us  preorder traversal\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)-->Recursive stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n void preorder(TreeNode *root,vector<int>&ans){\\n     if(!root)return;\\n     ans.push_back(root->val);\\n     preorder(root->left,ans);\\n    \\n     preorder(root->right,ans);\\n    \\n }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n         preorder(root,ans);\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n void preorder(TreeNode *root,vector<int>&ans){\\n     if(!root)return;\\n     ans.push_back(root->val);\\n     preorder(root->left,ans);\\n    \\n     preorder(root->right,ans);\\n    \\n }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n         preorder(root,ans);\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023199,
                "title": "simple-c-stack-solution-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void fun(TreeNode* root){\\n       if(!root) return;\\n       stack<TreeNode*> st;\\n       st.push(root);\\n       while(!st.empty()){\\n           TreeNode* p=st.top();\\n           v.push_back(p->val);\\n           st.pop();\\n\\n            if(p->right){\\n               st.push(p->right);\\n           }\\n           if(p->left){\\n               st.push(p->left);\\n           }\\n          \\n           \\n       }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fun(root);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void fun(TreeNode* root){\\n       if(!root) return;\\n       stack<TreeNode*> st;\\n       st.push(root);\\n       while(!st.empty()){\\n           TreeNode* p=st.top();\\n           v.push_back(p->val);\\n           st.pop();\\n\\n            if(p->right){\\n               st.push(p->right);\\n           }\\n           if(p->left){\\n               st.push(p->left);\\n           }\\n          \\n           \\n       }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        fun(root);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022820,
                "title": "detailed-explanation-iterative-and-recursive-solutions-in-java-and-javascript",
                "content": "# Recursive Solution\\n## Intuition\\nIn a preorder traversal, the root node is visited first, followed by the left subtree and then the right subtree.\\n\\nThe code uses function preorderTraversal() to traverse the tree in a recursive manner. The function is called on the root node of the tree, and then it is called recursively on the left and right children of the root (if they exist).\\n\\nThe key idea behind this algorithm is that the recursive function calls simulate the process of visiting the nodes of the tree in a preorder fashion. Each time the function is called, it adds the value of the current node to the list and then calls itself on the left and right children of the current node. This continues until the function has been called on all of the nodes in the tree, at which point the list will contain the values of the nodes in the correct order.\\n\\n## Approach\\n1. Initialize an empty list list to store the preorder traversal.\\n2. If the root node is null, return the empty list.\\n3. Add the value of the root node to the list.\\n4. Call the function recursively on the left child of the root node.\\n5. Call the function recursively on the right child of the root node.\\n6. Return the list.\\n\\n## Complexity\\n- Time complexity:\\nThe time complexity of the code provided is O(n), where n is the number of nodes in the tree. This is because the algorithm visits each node once, so the time complexity is linear in the size of the input.\\n\\n- Space complexity:\\nThe space complexity is O(n) in the worst case, when the tree is highly unbalanced and the function calls form a chain. In this case, the function call stack will contain all of the nodes in the tree, and the space complexity will be linear in the size of the input. In the best case, when the tree is balanced, the space complexity is O(log n), since the height of the tree is logarithmic in the number of nodes.\\n\\n## Code\\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list = new ArrayList<Integer>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null){\\n            return list;\\n        }\\n        list.add(root.val);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n        return list;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root, list = []) {\\n    if(!root){\\n        return [];\\n    }\\n    list.push(root.val);\\n    if (root.left !== null) preorderTraversal(root.left, list);\\n    if (root.right !== null) preorderTraversal(root.right, list);\\n    return list;\\n};\\n```\\n# Iterative Approach\\n## Intuition\\nIn a preorder traversal, the root node is visited first, followed by the left subtree and then the right subtree.\\n\\nWe use a stack to keep track of the nodes that have been visited but have not yet had their subtrees explored. The algorithm works by pushing the root node onto the stack and then repeatedly popping a node from the stack, adding its value to the list, and pushing its children (if any) onto the stack.\\n\\nThe key idea behind this algorithm is that **the stack simulates the behavior of the function call stack in a recursive implementation of the preorder traversal.** Each time a node is popped from the stack, it is as if the function has returned from exploring that node\\'s subtree and is now ready to move on to the next node.\\n\\n## Approach\\n1. Initialize an empty list list to store the preorder traversal and an empty stack stack to keep track of the nodes that have been visited but have not yet had their subtrees explored.\\n2. If the root node is null, return the empty list.\\n3. Push the root node onto the stack.\\n4. While the stack is not empty:\\n    1. Pop a node from the stack and add its value to the list.\\n    2. If the node has a right child, push it onto the stack.\\n    3. If the node has a left child, push it onto the stack.\\n5. Return the list.\\n## Complexity\\n- Time complexity:\\nThe time complexity of this approach is O(n), where n is the number of nodes in the tree. This is because the algorithm visits each node once, so the time complexity is linear in the size of the input.\\n\\n- Space complexity:\\nThe space complexity is also O(n), since the stack may contain up to n nodes at any given time. This is because the stack is used to keep track of the nodes that have been visited but have not yet had their right subtrees explored, and in the worst case, the stack could contain all of the nodes in the tree.\\n\\n## Code\\n\\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root == null){\\n            return list;\\n        }\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode curr = stack.pop();\\n            list.add(curr.val);\\n            if(curr.right != null){\\n                stack.push(curr.right);\\n            }\\n            if(curr.left != null){\\n                stack.push(curr.left);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root) {\\n    if(!root) return [];\\n    let stack = [];\\n    let list = [];\\n    stack.push(root);\\n    while(stack.length){\\n        let node = stack.pop();\\n        list.push(node.val);\\n        if(node.right) stack.push(node.right);\\n        if(node.left) stack.push(node.left);\\n    }\\n    return list;\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list = new ArrayList<Integer>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null){\\n            return list;\\n        }\\n        list.add(root.val);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n        return list;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root, list = []) {\\n    if(!root){\\n        return [];\\n    }\\n    list.push(root.val);\\n    if (root.left !== null) preorderTraversal(root.left, list);\\n    if (root.right !== null) preorderTraversal(root.right, list);\\n    return list;\\n};\\n```\n```Java []\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        if(root == null){\\n            return list;\\n        }\\n        stack.push(root);\\n        \\n        while(!stack.isEmpty()){\\n            TreeNode curr = stack.pop();\\n            list.add(curr.val);\\n            if(curr.right != null){\\n                stack.push(curr.right);\\n            }\\n            if(curr.left != null){\\n                stack.push(curr.left);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\n\\nvar preorderTraversal = function(root) {\\n    if(!root) return [];\\n    let stack = [];\\n    let list = [];\\n    stack.push(root);\\n    while(stack.length){\\n        let node = stack.pop();\\n        list.push(node.val);\\n        if(node.right) stack.push(node.right);\\n        if(node.left) stack.push(node.left);\\n    }\\n    return list;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022722,
                "title": "a-classic-approach-to-preorder-tree-traversal-a-recursive-solution-beats-100-time-c",
                "content": "The PreorderTraversal function is the public interface for the algorithm, and it accepts the root node of a binary tree as an argument. It creates an empty list to store the result of the traversal, and then calls the PreorderTraversalRecursive function on the root node to perform the actual traversal.\\n\\nThe PreorderTraversalRecursive function has the following steps:\\n\\nIf the node is null, it returns immediately.\\nIt adds the value of the node (node.val) to the list.\\nIt calls itself recursively on the left child of the node (node.left).\\nIt calls itself recursively on the right child of the node (node.right).\\nThis way, the function traverses the tree in a depth-first fashion, visiting the root node first, then the left subtree, and finally the right subtree.\\n\\nWhen the traversal is complete, the PreorderTraversal function returns the list containing the values of the nodes in the order they were visited.\\n\\n# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public IList<int> PreorderTraversal(TreeNode root)\\n    {\\n        var list = new List<int>();\\n        PreorderTraversalRecursive(root, list);\\n        return list;\\n    }\\n\\n    private void PreorderTraversalRecursive(TreeNode node, List<int> list)\\n    {\\n        if (node == null) return;\\n        list.Add(node.val);\\n        PreorderTraversalRecursive(node.left, list);\\n        PreorderTraversalRecursive(node.right, list);\\n    }\\n}\\n```\\n\\nIf you found my solution helpful, please consider upvoting it to let others know!",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<int> PreorderTraversal(TreeNode root)\\n    {\\n        var list = new List<int>();\\n        PreorderTraversalRecursive(root, list);\\n        return list;\\n    }\\n\\n    private void PreorderTraversalRecursive(TreeNode node, List<int> list)\\n    {\\n        if (node == null) return;\\n        list.Add(node.val);\\n        PreorderTraversalRecursive(node.left, list);\\n        PreorderTraversalRecursive(node.right, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022068,
                "title": "java-o-n-0-ms",
                "content": "# Intuition\\n    step 1---> add the root element in list\\n    step 2--->add the left element in list\\n    step 3--->add the right element in list\\n\\n# Approach\\n    Using Recursion\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList<>();\\n        if(root!=null){\\n        //root-->left-->right====>pre-order traversal\\n        list.add(root.val);\\n        list.addAll(preorderTraversal(root.left));\\n        list.addAll(preorderTraversal(root.right));\\n        return list;\\n        }\\n    //   If the Root is NULL ,then return the list\\n        return list;\\n        \\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/27555805-c730-4eb8-9b0c-9ebda36f3080_1673225293.3940446.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list =new ArrayList<>();\\n        if(root!=null){\\n        //root-->left-->right====>pre-order traversal\\n        list.add(root.val);\\n        list.addAll(preorderTraversal(root.left));\\n        list.addAll(preorderTraversal(root.right));\\n        return list;\\n        }\\n    //   If the Root is NULL ,then return the list\\n        return list;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021971,
                "title": "most-easy-short-and-clean-code-in-java-dfs-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs the definition of PreOrder Traversal is add->left->right\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst add data of the node to list then go to left and then go to right\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n\\n    public void preTree(TreeNode root){\\n        if(root == null) return;\\n\\n        list.add(root.val);\\n        preTree(root.left);\\n        preTree(root.right);\\n    }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        preTree(root);\\n        return list;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n\\n    public void preTree(TreeNode root){\\n        if(root == null) return;\\n\\n        list.add(root.val);\\n        preTree(root.left);\\n        preTree(root.right);\\n    }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        preTree(root);\\n        return list;\\n    }\\n}\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021955,
                "title": "daily-leetcoding-challenge-january-day-9",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 9.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-preorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-tree-preorder-traversal/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2765272,
                "title": "preorder",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            a.push_back(root->val);\\n            preorder(root->left);\\n            preorder(root->right);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    void preorder(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            a.push_back(root->val);\\n            preorder(root->left);\\n            preorder(root->right);\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575711,
                "title": "preorder-with-recursion-small-code",
                "content": "\\n```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc preorderTraversal(root *tree.TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *tree.TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.Res = append(r.Res, node.Val)\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree"
                ],
                "code": "```\\ntype Res struct {\\n\\tRes []int\\n}\\n\\nfunc preorderTraversal(root *tree.TreeNode) []int {\\n\\tr := Res{}\\n\\tr.traversal(root)\\n\\treturn r.Res\\n}\\n\\nfunc (r *Res) traversal(node *tree.TreeNode) {\\n\\tif node != nil {\\n\\t\\tr.Res = append(r.Res, node.Val)\\n\\t\\tr.traversal(node.Left)\\n\\t\\tr.traversal(node.Right)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765397,
                "title": "python3-fastest-solution-recursion-one-liner",
                "content": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694797,
                "title": "c-using-recursive-approach",
                "content": "```\\nvoid helper(TreeNode* root,vector<int> &vec){\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        helper(root->left,vec);\\n        helper(root->right,vec);\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> vec;\\n        helper(root,vec);\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvoid helper(TreeNode* root,vector<int> &vec){\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        vec.push_back(root->val);\\n        helper(root->left,vec);\\n        helper(root->right,vec);\\n        }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> vec;\\n        helper(root,vec);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1688224,
                "title": "python3-explanation-with-both-recursive-and-iterative-solution",
                "content": "My template for solving the problem:\\n* Clarify requirements\\n* Propose testcases\\n* Define function signature\\n* Coding\\n* Work through testcases\\n* Time and Space Complexity\\n<hr>\\n\\n**video explanation**: \\n<hr>\\n\\n**Prior Knowledge before working on this problem**\\n* Preorder Traversal: Node, traverse the Left subtree, then traverse the right subtree\\n```\\n\\t\\t 4\\n\\t3        5\\n1      2   6\\n```\\nThe preorder traversal for the above tree is 431256\\n\\n**1. Clarify requirements**\\n* \\tIt\\'s a binary tree\\n* \\tWe need to do a preorder traversal and return their values\\n\\n**2. Propose testcases**\\n```\\n1. Empty Tree\\n2. Two nodes, the right child is nil\\n    Node(3)\\nNode(2)\\n3.  Two nodes, the left child is nil\\n    Node(3)\\n\\t\\tNode(5)\\n```\\n**3. Define function signature**\\n* input: TreeNode\\n* return: List[int]\\n\\n**4. Coding**\\nWe have two ways to solve this problem. We can approach by recursion first since that\\'s the most intuitive way.\\n\\n```\\nrecursion\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ret = []\\n        def dfs(node):\\n            if not node:\\n                return\\n            ret.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        dfs(root)\\n        return ret\\n\\nExplanation: In the dfs function, If node is not null, we store its value and visit its left side, and then its right side.\\n\\nOptimize:\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n\\nWe can also implement it iteratively.\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        stack, ret = [root], []\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            if node.right: \\n                stack.append(node.right)\\n            if node.left: \\n                stack.append(node.left)\\n        return ret\\n\\nExplanation: \\nNotice that the order is Node, Left, Right. We can use a stack to store the node\\'s right child first and then store the nodes\\' left child. If the node has a left child, we can get that by stack.pop()\\nThis runs fast than the recursive approach\\n```\\n\\n**5. Work through testcases**\\nGo through the proposed testcases and check the code line by line to make sure it runs expectedly.\\n\\n**6. Time and Space Complexity**\\nAverage Time: O(n), where n is the number of nodes\\nSpace: O(1), constant space\\n\\n**Please upvote if this is helpful to you. Your upvote will motivate me to write more content.**",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n\\t\\t 4\\n\\t3        5\\n1      2   6\\n```\n```\\n1. Empty Tree\\n2. Two nodes, the right child is nil\\n    Node(3)\\nNode(2)\\n3.  Two nodes, the left child is nil\\n    Node(3)\\n\\t\\tNode(5)\\n```\n```\\nrecursion\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        ret = []\\n        def dfs(node):\\n            if not node:\\n                return\\n            ret.append(node.val)\\n            dfs(node.left)\\n            dfs(node.right)\\n        dfs(root)\\n        return ret\\n\\nExplanation: In the dfs function, If node is not null, we store its value and visit its left side, and then its right side.\\n\\nOptimize:\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []\\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n\\n\\nWe can also implement it iteratively.\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        if not root:\\n            return []\\n\\n        stack, ret = [root], []\\n        while stack:\\n            node = stack.pop()\\n            ret.append(node.val)\\n            if node.right: \\n                stack.append(node.right)\\n            if node.left: \\n                stack.append(node.left)\\n        return ret\\n\\nExplanation: \\nNotice that the order is Node, Left, Right. We can use a stack to store the node\\'s right child first and then store the nodes\\' left child. If the node has a left child, we can get that by stack.pop()\\nThis runs fast than the recursive approach\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670795,
                "title": "javascript-solutions",
                "content": "**1. Recursive solution.**\\n\\nRuntime: 72 ms, faster than 74.34% of JavaScript online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 38.8 MB, less than 80.63% of JavaScript online submissions for Binary Tree Preorder Traversal.\\n\\n```\\nvar preorderTraversal = function(root) {\\n    let output = [];\\n    function foo (node) {\\n        if(!node) return;\\n        output.push(node.val);\\n        foo(node.left);\\n        foo(node.right);\\n    }\\n    foo(root);\\n    return output;\\n};\\n```\\n\\n**2. Iterative Solution.**\\n\\nRuntime: 72 ms, faster than 74.34% of JavaScript online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 38.9 MB, less than 69.88% of JavaScript online submissions for Binary Tree Preorder Traversal.\\n\\n```\\nvar preorderTraversal = function(node) {\\n    let stack = [];\\n    let output = [];\\n    while (stack.length || node !== null) {\\n        if (node !== null) {\\n            output.push(node.val);\\n            stack.push(node);\\n            node = node.left;\\n        } else {\\n            node = stack.pop().right;\\n        }\\n        \\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nvar preorderTraversal = function(root) {\\n    let output = [];\\n    function foo (node) {\\n        if(!node) return;\\n        output.push(node.val);\\n        foo(node.left);\\n        foo(node.right);\\n    }\\n    foo(root);\\n    return output;\\n};\\n```\n```\\nvar preorderTraversal = function(node) {\\n    let stack = [];\\n    let output = [];\\n    while (stack.length || node !== null) {\\n        if (node !== null) {\\n            output.push(node.val);\\n            stack.push(node);\\n            node = node.left;\\n        } else {\\n            node = stack.pop().right;\\n        }\\n        \\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1514657,
                "title": "java-easy-non-recursive-stack-based",
                "content": "```\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if(root==null)\\n            return res;\\n        Stack<TreeNode> st = new Stack <>();\\n        st.push(root);\\n        while(!st.isEmpty())\\n        {\\n            TreeNode top = st.pop();\\n            res.add(top.val);\\n            if(top.right!=null)\\n                st.push(top.right);\\n            if(top.left!=null)\\n                st.push(top.left);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> res = new ArrayList<>();\\n        if(root==null)\\n            return res;\\n        Stack<TreeNode> st = new Stack <>();\\n        st.push(root);\\n        while(!st.isEmpty())\\n        {\\n            TreeNode top = st.pop();\\n            res.add(top.val);\\n            if(top.right!=null)\\n                st.push(top.right);\\n            if(top.left!=null)\\n                st.push(top.left);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380065,
                "title": "c-easy-and-efficient-recursion",
                "content": "**If you liked this solution, Please Upvote. Thanks**\\n\\n```\\n\\tvoid preorder(TreeNode *root,vector<int>&vec)\\n    {\\n        if(!root) return;\\n        vec.push_back(root->val);\\n        preorder(root->left,vec);\\n        preorder(root->right,vec);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>vec;\\n        preorder(root,vec);\\n        return vec;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvoid preorder(TreeNode *root,vector<int>&vec)\\n    {\\n        if(!root) return;\\n        vec.push_back(root->val);\\n        preorder(root->left,vec);\\n        preorder(root->right,vec);\\n    }\\n    \\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>vec;\\n        preorder(root,vec);\\n        return vec;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1020137,
                "title": "recursive-faster-than-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        vec.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> vec;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        if(root==nullptr) return {};\\n        vec.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897240,
                "title": "c-solution",
                "content": "void travel(struct TreeNode *root,int *arr,int *size){\\n    if(root==NULL)\\n        return;\\n    arr[(*size)++]=root->val;\\n    travel(root->left,arr,size);\\n    travel(root->right,arr,size);\\n}\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *arr=(int *)malloc(100*sizeof(int));\\n    travel(root,arr,returnSize);\\n    return arr;\\n}",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "void travel(struct TreeNode *root,int *arr,int *size){\\n    if(root==NULL)\\n        return;\\n    arr[(*size)++]=root->val;\\n    travel(root->left,arr,size);\\n    travel(root->right,arr,size);\\n}\\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\\n    *returnSize=0;\\n    int *arr=(int *)malloc(100*sizeof(int));\\n    travel(root,arr,returnSize);\\n    return arr;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 775203,
                "title": "javascript-clean-3-liner",
                "content": "```javascript\\nvar preorderTraversal = function(root) {\\n  \\n    function traverse(node) {\\n        if(!node) return [];\\n        return [node.val, ...traverse(node.left), ...traverse(node.right)];\\n    }\\n    return traverse(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar preorderTraversal = function(root) {\\n  \\n    function traverse(node) {\\n        if(!node) return [];\\n        return [node.val, ...traverse(node.left), ...traverse(node.right)];\\n    }\\n    return traverse(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 646180,
                "title": "python-iterative-and-recursive",
                "content": "Method 1: Iterative \\n\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        result, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                result.append(root.val)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return result\\n\\n```\\n\\nMethod 2: Recursive (Trivial, not desired in the question guidelines) \\n\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:      \\n        output = []\\n        self._helper(root, output)\\n        return output\\n    \\n    def _helper(self, root, output):\\n        if root is None: return \\n        output.append(root.val)\\n        self._helper(root.left, output)\\n        self._helper(root.right, output)\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        result, stack = [], []\\n        while stack or root:\\n            if root:\\n                stack.append(root)\\n                result.append(root.val)\\n                root = root.left\\n            else:\\n                node = stack.pop()\\n                root = node.right\\n        return result\\n\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:      \\n        output = []\\n        self._helper(root, output)\\n        return output\\n    \\n    def _helper(self, root, output):\\n        if root is None: return \\n        output.append(root.val)\\n        self._helper(root.left, output)\\n        self._helper(root.right, output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406827,
                "title": "c-clean-and-easy-to-read",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Binary Tree Preorder Traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* temp=stack.top();\\n            res.push_back(temp->val);\\n            stack.pop();\\n            if(temp->right) stack.push(temp->right);\\n            if(temp->left) stack.push(temp->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> res;\\n        if(!root) return res;\\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        while(!stack.empty()){\\n            TreeNode* temp=stack.top();\\n            res.push_back(temp->val);\\n            stack.pop();\\n            if(temp->right) stack.push(temp->right);\\n            if(temp->left) stack.push(temp->left);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359086,
                "title": "javascript-iterative-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    let res = [];\\n    let stack = [];\\n    let cur = root;\\n    while(cur || stack.length) {\\n        while(cur) {\\n            res.push(cur.val);\\n            stack.push(cur);\\n            cur = cur.left;\\n        }\\n        cur = stack.pop();\\n        cur = cur.right;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar preorderTraversal = function(root) {\\n    let res = [];\\n    let stack = [];\\n    let cur = root;\\n    while(cur || stack.length) {\\n        while(cur) {\\n            res.push(cur.val);\\n            stack.push(cur);\\n            cur = cur.left;\\n        }\\n        cur = stack.pop();\\n        cur = cur.right;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326245,
                "title": "help-python-3-attributeerror-nonetype-object-has-no-attribute-right",
                "content": "Although I am checking for the stack length in the while condition, I do not understand why this error appears\\nLine 13: AttributeError: \\'NoneType\\' object has no attribute \\'right\\'\\n\\n```\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack,res = [root],[]\\n        while len(stack)>0:\\n            node = stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            res.append(node.val)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def preorderTraversal(self, root: TreeNode) -> List[int]:\\n        stack,res = [root],[]\\n        while len(stack)>0:\\n            node = stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            res.append(node.val)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274116,
                "title": "go-solution",
                "content": "```\\nfunc preorderTraversal(root *TreeNode) []int {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    var ret []int\\n    p := root\\n    stack := make([]*TreeNode, 0)\\n    stack = append(stack, p)\\n\\n    for len(stack) != 0 {\\n        visit := stack[len(stack)-1]\\n        stack = stack[:len(stack)-1]\\n        \\n        ret = append(ret, visit.Val)\\n        \\n        if visit.Right != nil {\\n            stack = append(stack, visit.Right)\\n        }\\n        if visit.Left != nil {\\n            stack = append(stack, visit.Left)\\n        }\\n    }\\n    return ret\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc preorderTraversal(root *TreeNode) []int {\\n    if root == nil {\\n        return nil\\n    }\\n\\n    var ret []int\\n    p := root\\n    stack := make([]*TreeNode, 0)\\n    stack = append(stack, p)\\n\\n    for len(stack) != 0 {\\n        visit := stack[len(stack)-1]\\n        stack = stack[:len(stack)-1]\\n        \\n        ret = append(ret, visit.Val)\\n        \\n        if visit.Right != nil {\\n            stack = append(stack, visit.Right)\\n        }\\n        if visit.Left != nil {\\n            stack = append(stack, visit.Left)\\n        }\\n    }\\n    return ret\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 257252,
                "title": "javascript-iterative-recursive-solutions",
                "content": "**RECURSIVE:**\\n```\\nvar preorderTraversal = function(root) {\\n    \\n    let result = [];\\n    \\n    function pot(node) {\\n        if(node) {\\n            result.push(node.val);\\n            if(node.left) {\\n                pot(node.left);\\n            }\\n            if(node.right) {\\n                pot(node.right);\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n    \\n    pot(root);\\n    return result;\\n};\\n```\\n\\n**ITERATIVE - USE STACK**\\n```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    let stack = [];\\n    if(root) {\\n        stack.push(root);\\n        while(stack.length > 0) {\\n            let node = stack.pop();\\n            result.push(node.val);\\n            if(node.right) {\\n                stack.push(node.right);\\n            }\\n            if(node.left) {\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar preorderTraversal = function(root) {\\n    \\n    let result = [];\\n    \\n    function pot(node) {\\n        if(node) {\\n            result.push(node.val);\\n            if(node.left) {\\n                pot(node.left);\\n            }\\n            if(node.right) {\\n                pot(node.right);\\n            }\\n        } else {\\n            return;\\n        }\\n    }\\n    \\n    pot(root);\\n    return result;\\n};\\n```\n```\\nvar preorderTraversal = function(root) {\\n    let result = [];\\n    let stack = [];\\n    if(root) {\\n        stack.push(root);\\n        while(stack.length > 0) {\\n            let node = stack.pop();\\n            result.push(node.val);\\n            if(node.right) {\\n                stack.push(node.right);\\n            }\\n            if(node.left) {\\n                stack.push(node.left);\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 45258,
                "title": "1-line-python",
                "content": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        return [] if not root else [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        return [] if not root else [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 45444,
                "title": "java-solution-both-recursion-and-iteration",
                "content": "    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // recursion method\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        res.add(root.val);\\n        if (root.left != null) \\n            for (int left : preorderTraversal(root.left)) res.add(left);\\n        if (root.right != null) \\n            for (int right : preorderTraversal(root.right)) res.add(right);\\n        return res;\\n    }\\n\\n\\n----------\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // iteration method\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) return res;\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode temp = stack.pop();\\n            if (temp != null) {\\n                res.add(temp.val);\\n                stack.push(temp.right);\\n                stack.push(temp.left);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // recursion method\\n        List<Integer> res = new ArrayList<>();\\n        if (root == null) return res;\\n        res.add(root.val);\\n        if (root.left != null) \\n            for (int left : preorderTraversal(root.left)) res.add(left);\\n        if (root.right != null) \\n            for (int right : preorderTraversal(root.right)) res.add(right);\\n        return res;\\n    }\\n\\n\\n----------\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // root --> left --> right\\n        // iteration method\\n        List<Integer> res = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        if (root == null) return res;\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeNode temp = stack.pop();\\n            if (temp != null) {\\n                res.add(temp.val);\\n                stack.push(temp.right);\\n                stack.push(temp.left);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 45484,
                "title": "what-s-the-simplest-and-cleanest-answer",
                "content": "Here's the answer I got. I was wondering if someone came up with something simpler and cleaner.\\n\\n    class Solution {\\n    public:\\n        vector<int> order;\\n        vector<int> preorderTraversal(TreeNode *root) {\\n            addNextNode(root);\\n            return order;\\n        }\\n        void addNextNode(TreeNode* node) {\\n            if (node) {\\n                order.push_back(node->val);\\n                addNextNode(node->left);\\n                addNextNode(node->right);\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> order;\\n        vector<int> preorderTraversal(TreeNode *root) {\\n            addNextNode(root);\\n            return order;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4052573,
                "title": "simplest-solution-beginner-friendly-waiting-for-you",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```PreOrder -> Printing root val and Calling left subtree then right subtree```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*Step-1 -> Declare a ```list``` outside method bcoz we are using recursion\\nStep-2 -> ```Loop until root becomes null ```\\nStep-3 -> ```Add root val to list```\\nStep-4 -> ```Recursively Call for left subtree```\\nStep-5 -> ```Recursively Call for right subtree```\\nStep-6 -> Job is done Just return ```list``` in the end*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root != null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```PreOrder -> Printing root val and Calling left subtree then right subtree```\n```list```\n```Loop until root becomes null ```\n```Add root val to list```\n```Recursively Call for left subtree```\n```Recursively Call for right subtree```\n```list```\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root != null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929505,
                "title": "3-easy-c-solutions-dfs-bfs-and-morris-traversal-beats-100",
                "content": "# Code\\n```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        ans.push_back(root->val);\\n        preorder(root->left, ans);\\n        preorder(root->right, ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)        return ans;\\n\\n        stack<TreeNode*> s;\\n        s.push(root);\\n\\n        while(!s.empty()){\\n            TreeNode *temp = s.top();\\n            s.pop();\\n            ans.push_back(temp->val);\\n\\n            if(temp->right != NULL)\\n                s.push(temp->right);\\n            if(temp->left != NULL)\\n                s.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans ;\\n        TreeNode *curr = root, *pre;\\n\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    ans.push_back(curr->val);\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{\\n                    pre->right = NULL;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive approach\\nclass Solution {\\npublic:\\n    void preorder(TreeNode* root, vector<int> &ans){\\n        //base case\\n        if(root == NULL)\\n            return;\\n\\n        ans.push_back(root->val);\\n        preorder(root->left, ans);\\n        preorder(root->right, ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root, ans);\\n        return ans;\\n    }\\n};\\n\\n// Iterative approach\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        if(root == NULL)        return ans;\\n\\n        stack<TreeNode*> s;\\n        s.push(root);\\n\\n        while(!s.empty()){\\n            TreeNode *temp = s.top();\\n            s.pop();\\n            ans.push_back(temp->val);\\n\\n            if(temp->right != NULL)\\n                s.push(temp->right);\\n            if(temp->left != NULL)\\n                s.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Morris traversal - Space O(1)\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans ;\\n        TreeNode *curr = root, *pre;\\n\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                ans.push_back(curr->val);\\n                curr = curr->right;\\n            }\\n            else{\\n                pre = curr->left;\\n                while(pre->right != NULL && pre->right != curr)\\n                    pre = pre->right;\\n                \\n                if(pre->right == NULL){\\n                    ans.push_back(curr->val);\\n                    pre->right = curr;\\n                    curr = curr->left;\\n                }\\n                else{\\n                    pre->right = NULL;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875596,
                "title": "recursive-iteration-o-n-approach-for-beginners-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode *root,vector<int>& ans) {\\n        if(!root)return ;\\n        ans.push_back(root->val);\\n        preorder(root->left,ans);\\n        preorder(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        //preorder(root,ans); to do recursively\\n        stack<TreeNode *>st;\\n        while(true){\\n            while(root){\\n                ans.push_back(root->val);\\n                if(root->right)st.push(root->right);\\n                root=root->left;\\n            }\\n            if(st.empty())break;\\n            root=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void preorder(TreeNode *root,vector<int>& ans) {\\n        if(!root)return ;\\n        ans.push_back(root->val);\\n        preorder(root->left,ans);\\n        preorder(root->right,ans);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        //preorder(root,ans); to do recursively\\n        stack<TreeNode *>st;\\n        while(true){\\n            while(root){\\n                ans.push_back(root->val);\\n                if(root->right)st.push(root->right);\\n                root=root->left;\\n            }\\n            if(st.empty())break;\\n            root=st.top();\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806147,
                "title": "crack-the-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid preorder(TreeNode* root,vector<int> &ans){\\n         if(root==NULL)return;\\n         ans.push_back(root->val);\\n         preorder(root->left,ans);\\n         preorder(root->right,ans);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n# Intuition:\\nThe goal is to perform a preorder traversal on a binary tree, which means visiting the nodes in the order: root, left, right. To achieve this, we can use a recursive approach. We start at the root node and perform the following steps:\\n\\nVisit the current node and store its value in a vector called \"ans.\"\\nRecursively traverse the left subtree.\\nRecursively traverse the right subtree.\\n# Algorithm:\\n\\nDefine a helper function called preorder that takes the current node and a reference to a vector called \"ans\" as input.\\nInside the preorder function:\\nIf the current node is NULL (base case), return from the function.\\nOtherwise, add the value of the current node to the \"ans\" vector.\\nRecursively call the preorder function for the left child of the current node.\\nRecursively call the preorder function for the right child of the current node.\\nInitialize an empty vector called \"ans\" to store the preorder traversal result.\\nCall the preorder function with the root node and the \"ans\" vector as arguments.\\nReturn the \"ans\" vector, which now contains the preorder traversal of the binary tree.\\n# Complexity Analysis:\\n\\n# Time Complexity:\\n The time complexity of the preorder traversal using recursion is O(N), where \"N\" is the number of nodes in the binary tree. This is because we visit each node exactly once during the traversal.\\n# Space Complexity:\\n The space complexity is O(H), where \"H\" is the height of the binary tree. In the worst case, the height of the binary tree can be N (when the tree is skewed), so the space complexity is O(N). This is because the maximum number of function calls stored in the call stack at any point is equal to the height of the binary tree. The space used by the \"ans\" vector is also considered, but it is not dominating compared to the space used by the call stack. Therefore, the overall space complexity is O(N).\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvoid preorder(TreeNode* root,vector<int> &ans){\\n         if(root==NULL)return;\\n         ans.push_back(root->val);\\n         preorder(root->left,ans);\\n         preorder(root->right,ans);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        preorder(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723664,
                "title": "recursive-and-iterative-approach-please-upvote-me-it-would-encourage-me-alot",
                "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        list1=[]\\n        def preorder(root,list1):\\n            if not root:\\n                return \\n            list1.append(root.val)\\n            preorder(root.left,list1)\\n            preorder(root.right,list1)\\n        preorder(root,list1)\\n        return list1\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return None\\n        stack,ans=[],[]\\n        stack.append(root)\\n        while stack:\\n            node=stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            ans.append(node.val)\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        list1=[]\\n        def preorder(root,list1):\\n            if not root:\\n                return \\n            list1.append(root.val)\\n            preorder(root.left,list1)\\n            preorder(root.right,list1)\\n        preorder(root,list1)\\n        return list1\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root:\\n            return None\\n        stack,ans=[],[]\\n        stack.append(root)\\n        while stack:\\n            node=stack.pop()\\n            if node.right:\\n                stack.append(node.right)\\n            if node.left:\\n                stack.append(node.left)\\n            ans.append(node.val)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678499,
                "title": "binary-tree-preorder-traversal-iterative-using-stack-beat-100-time-best-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse stack ---push root first---loop while stacl is not empty--pop top-- push right child --- push left child--- insert value into vector--- return vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n          O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root){    //if root is null\\n            return ans;\\n        }\\n        stack<TreeNode*>op;\\n        op.push(root);\\n        while(!op.empty()){\\n            TreeNode* top=op.top();\\n            op.pop();\\n            ans.push_back(top->val);\\n            if(top->right) op.push(top->right);\\n            if(top->left) op.push(top->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(!root){    //if root is null\\n            return ans;\\n        }\\n        stack<TreeNode*>op;\\n        op.push(root);\\n        while(!op.empty()){\\n            TreeNode* top=op.top();\\n            op.pop();\\n            ans.push_back(top->val);\\n            if(top->right) op.push(top->right);\\n            if(top->left) op.push(top->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302205,
                "title": "easiest-solution-out-there-in-5-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlsssss Up vote -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root!=null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> list = new ArrayList<>();\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root!=null){\\n            list.add(root.val);\\n            preorderTraversal(root.left);\\n            preorderTraversal(root.right);\\n        }\\n        return list;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272343,
                "title": "python3-memory-efficient-32ms",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- visit root first.\\n- now visit left sub-tree.\\n- now visit right sub-tree.\\n- return ans\\n---\\n# Note\\n- used yield because it is memory efficient.\\n---\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        def preOrder(curr=root):\\n            if curr:\\n                yield curr.val\\n                for i in preOrder(curr.left):\\n                    yield i\\n                for j in preOrder(curr.right):\\n                    yield j\\n        preorder = preOrder()\\n        ans = []\\n        for i in preorder:\\n            ans.append(i)\\n        return ans\\n```\\n# Please like and comment below. :-)",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        def preOrder(curr=root):\\n            if curr:\\n                yield curr.val\\n                for i in preOrder(curr.left):\\n                    yield i\\n                for j in preOrder(curr.right):\\n                    yield j\\n        preorder = preOrder()\\n        ans = []\\n        for i in preorder:\\n            ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264403,
                "title": "c-solution-using-recursion-run-time-0ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // NLR\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        ans.push_back(root->val);\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void solve(TreeNode* root, vector<int>& ans) { // NLR\\n        if(root == NULL) {\\n            return;\\n        }\\n\\n        ans.push_back(root->val);\\n        solve(root->left, ans);\\n        solve(root->right, ans);\\n    }\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> ans;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163085,
                "title": "simple-java-100-easy-comments-readable-beginners-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> answer = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        // Note that we add currNode\\'s right child to the stack first.\\n        while (!stack.isEmpty()) {\\n            TreeNode currNode = stack.peek();\\n            stack.pop();\\n            if (currNode != null) {\\n                answer.add(currNode.val);\\n                stack.add(currNode.right);\\n                stack.add(currNode.left);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> answer = new ArrayList<>();\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.add(root);\\n        \\n        // Note that we add currNode\\'s right child to the stack first.\\n        while (!stack.isEmpty()) {\\n            TreeNode currNode = stack.peek();\\n            stack.pop();\\n            if (currNode != null) {\\n                answer.add(currNode.val);\\n                stack.add(currNode.right);\\n                stack.add(currNode.left);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053471,
                "title": "c-short-simple-recursion",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid preorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return v;   \\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> v;\\nvoid preorder(TreeNode* root){\\n    if(root==nullptr){return;}\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        preorder(root);\\n        return v;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025551,
                "title": "100-faster-easy-java-soln-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we have taken the help of an helper function.\\nThe function first adds the value of the root node to the result list. It then recursively calls itself on the left and right subtrees, appending the results of these calls to the result list. If the root node is null, it simply returns.\\n\\n# Complexity\\n- Time complexity:\\n\\nThis implementation has a time complexity of O(n), where n is the number of nodes in the tree, because it visits each node exactly once\\n\\n- Space complexity:\\n\\nThe space complexity is also O(n), because at any given time there can be up to n function calls on the call stack.\\n\\nI hope this helps! Let me know if you have any questions.Please upvote!!!!!!!!!!!!!!!!!!!\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        helper(root,list);\\n        return list;\\n        \\n    }\\n    private static void helper(TreeNode root,List<Integer> list)\\n    {\\n        if(root==null)\\n        return;\\n        list.add(root.val);\\n        helper(root.left,list);\\n        helper(root.right,list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        helper(root,list);\\n        return list;\\n        \\n    }\\n    private static void helper(TreeNode root,List<Integer> list)\\n    {\\n        if(root==null)\\n        return;\\n        list.add(root.val);\\n        helper(root.left,list);\\n        helper(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025140,
                "title": "beats-100-easy-solution-c",
                "content": "\\n\\n\\n**- Time complexity:**\\n**O(n) \\nwhere, n = Number of Nodes**\\n\\n**- Space complexity:\\nO(h) \\nwhere, h = height of tree**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void pre(TreeNode *root, vector<int>&v){\\n        if(root == NULL){\\n            return ;\\n        }\\n        else{\\n            v.push_back(root->val);\\n            pre(root->left,v);\\n            pre(root->right,v);\\n        }\\n    }\\n\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void pre(TreeNode *root, vector<int>&v){\\n        if(root == NULL){\\n            return ;\\n        }\\n        else{\\n            v.push_back(root->val);\\n            pre(root->left,v);\\n            pre(root->right,v);\\n        }\\n    }\\n\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        pre(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023752,
                "title": "c-0ms-short-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nApply recursion for complete traversal of tree.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n    void help(TreeNode* root, vector<int>&ans){\\n        if(!root) return;\\n        ans.push_back(root->val);\\n        help(root->left,ans);\\n        help(root->right,ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        help(root,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n    void help(TreeNode* root, vector<int>&ans){\\n        if(!root) return;\\n        ans.push_back(root->val);\\n        help(root->left,ans);\\n        help(root->right,ans);\\n    }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        help(root,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3023679,
                "title": "python-beats-97-9",
                "content": "# Intuition\\nWhen it comes down to binary tries it\\'s usually about some kind of bfs or dfs. Here is an easy way to implement it.\\n\\n# Approach\\nIterate over given tree and collect all non `null` values. Using stack to iterate we end up with sorted array and we dont have to anything else.\\n\\n# Complexity\\n- Time complexity: O(n) Because we need to itaret over entire tree\\n\\n- Space complexity: O(n) Because we copy tree values 1:1 to result array.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        preordered = []\\n        nodes = [root]\\n        \\n        while nodes:\\n            node = nodes[-1]\\n            del nodes [-1]\\n            \\n            if node.right is not None:\\n                nodes.append(node.right)\\n            \\n            if node.left is not None:\\n                nodes.append(node.left)\\n            \\n            preordered.append(node.val)\\n\\n        return preordered\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return []\\n        \\n        preordered = []\\n        nodes = [root]\\n        \\n        while nodes:\\n            node = nodes[-1]\\n            del nodes [-1]\\n            \\n            if node.right is not None:\\n                nodes.append(node.right)\\n            \\n            if node.left is not None:\\n                nodes.append(node.left)\\n            \\n            preordered.append(node.val)\\n\\n        return preordered\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023648,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO[N]\\n\\n- Space complexity:\\nO[N]\\nAs Used vector\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void yo(TreeNode* root,vector<int>& A){\\n        if(root!=NULL){\\n            A.push_back(root->val);\\n            yo(root->left,A);\\n            yo(root->right,A);\\n        }\\n\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>A;\\n        yo(root,A);\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void yo(TreeNode* root,vector<int>& A){\\n        if(root!=NULL){\\n            A.push_back(root->val);\\n            yo(root->left,A);\\n            yo(root->right,A);\\n        }\\n\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>A;\\n        yo(root,A);\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023506,
                "title": "java-solution-for-pre-order-binary-tree-beats-100-solution-in-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/14399fe7-0b15-4d89-801d-47d199f34e6a_1673248747.2783885.png)\\n# Approach\\n## **Recursive**\\n**Algorithm for Preorder(tree)**\\n\\n1. Visit the root.\\n2. Traverse the left subtree\\n3. Traverse the right subtree\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void traversal(TreeNode root, List<Integer> res) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        \\n        // Add the current node\\'s value to the result list\\n        res.add(root.val);\\n        \\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left, res);\\n        traversal(root.right, res);\\n   }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Creating a list to store the traversal result\\n        //Initialization\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // To perform the traversal\\n        traversal(root, res);\\n        \\n        // Return the result\\n        return res;\\n   }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void traversal(TreeNode root, List<Integer> res) {\\n       \\n        // Return if the current node is null\\n        //base case\\n        if(root == null) return;\\n        \\n        // Add the current node\\'s value to the result list\\n        res.add(root.val);\\n        \\n        // Recursively traverse the left and right subtrees\\n        traversal(root.left, res);\\n        traversal(root.right, res);\\n   }\\n\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        // Creating a list to store the traversal result\\n        //Initialization\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // To perform the traversal\\n        traversal(root, res);\\n        \\n        // Return the result\\n        return res;\\n   }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023171,
                "title": "c-begineer-friendly-easy-understanding-2-methods-video-solution",
                "content": "# Intuition && Intution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=NQjAvtyLFM0/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Iterative \\n```\\nclass Solution {\\npublic:\\n vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>preorder;\\n        stack<TreeNode*>st;\\n\\n        if(root == NULL){return preorder; }\\n\\n        st.push(root);\\n\\n\\n        while(!st.empty()){\\n            TreeNode* top = st.top();\\n            st.pop();\\n            preorder.push_back(top->val);\\n\\n            if(top->right!= NULL){\\n                st.push(top->right);\\n            }\\n            if(top->left!= NULL){\\n                st.push(top->left);\\n            }\\n        }\\n\\n        return preorder;\\n    }\\n};\\n```\\n\\n## Recursive\\n\\n```\\n  void preorderfun(vector<int>& preorder,TreeNode* root){\\n         if(root == NULL){return;}\\n        preorder.push_back(root->val);\\n        preorderfun(preorder,root->left);\\n        preorderfun(preorder,root->right);\\n     }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n         vector<int>preorder;\\n        preorderfun(preorder,root);\\n         return preorder;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>preorder;\\n        stack<TreeNode*>st;\\n\\n        if(root == NULL){return preorder; }\\n\\n        st.push(root);\\n\\n\\n        while(!st.empty()){\\n            TreeNode* top = st.top();\\n            st.pop();\\n            preorder.push_back(top->val);\\n\\n            if(top->right!= NULL){\\n                st.push(top->right);\\n            }\\n            if(top->left!= NULL){\\n                st.push(top->left);\\n            }\\n        }\\n\\n        return preorder;\\n    }\\n};\\n```\n```\\n  void preorderfun(vector<int>& preorder,TreeNode* root){\\n         if(root == NULL){return;}\\n        preorder.push_back(root->val);\\n        preorderfun(preorder,root->left);\\n        preorderfun(preorder,root->right);\\n     }\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n         vector<int>preorder;\\n        preorderfun(preorder,root);\\n         return preorder;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022989,
                "title": "c-solution-o-n-solution-with-explanation-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we use the concept of recursion to solve this problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPreorder traversal is like **root, left, right**\\nSo, startimg from the root node, if root is not null we insert the value part of that node in the vector or array and then move to left substree, and after traversing the left subtree then we move to right subtree. \\nIf the value of any root is NULL then we simply return.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder --> root, left, right\\n    void preorder(TreeNode* root, vector<int> & v)\\n    {\\n        if (root == NULL)\\n        return;\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preorder(root, v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // preorder --> root, left, right\\n    void preorder(TreeNode* root, vector<int> & v)\\n    {\\n        if (root == NULL)\\n        return;\\n        v.push_back(root->val);\\n        preorder(root->left,v);\\n        preorder(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n        preorder(root, v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022946,
                "title": "c-simplest-stack-and-recursive-method-easiest-and-cleanest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPreorder Traversal of a binary tree, follows the order \\n```\\nTraverse:\\n1.(root)         //Current Root\\n2.(root->left)   //Current Root\\'s left\\n3.(root->right)  //Current Root\\'s right\\n```\\n# Method 1 : Using Recursion\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;    //Answer vector\\n    void pre(TreeNode * root){\\n        if(root==NULL) return ;\\n        else {\\n            ans.push_back(root->val);   //Take current root value.\\n            pre(root->left);            //Traverse root\\'s Left\\n            pre(root->right);           //Traverse root\\'s Right\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        pre(root);    //Passing root for computation of recursive fn\\n        return ans;   //Final ans\\n    }\\n    \\n};\\n```\\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Recursive Function calls\\n```\\n# Method 2 : Using Stack\\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        if(root==NULL) return pre;  //Empty Tree\\n        stack<TreeNode *> st;\\n        st.push(root);  //Push root\\n        while(!st.empty()){\\n            root=st.top();  //New root=Take the topmost node\\n            st.pop();       //Remove from stack\\n            pre.push_back(root->val);  //Push into ans vector\\n            if(root->right!=NULL) st.push(root->right);  //Goto Left \\n            if(root->left!=NULL ) st.push(root->left);   //Goto Right\\n        }\\n        return pre;\\n    }\\n};\\n```\\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Storing all nodes\\n```\\nPlease upvote if found useful \\uD83D\\uDE00\\uD83C\\uDF83\\uD83E\\uDD21",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nTraverse:\\n1.(root)         //Current Root\\n2.(root->left)   //Current Root\\'s left\\n3.(root->right)  //Current Root\\'s right\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;    //Answer vector\\n    void pre(TreeNode * root){\\n        if(root==NULL) return ;\\n        else {\\n            ans.push_back(root->val);   //Take current root value.\\n            pre(root->left);            //Traverse root\\'s Left\\n            pre(root->right);           //Traverse root\\'s Right\\n        }\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        pre(root);    //Passing root for computation of recursive fn\\n        return ans;   //Final ans\\n    }\\n    \\n};\\n```\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Recursive Function calls\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> pre;\\n        if(root==NULL) return pre;  //Empty Tree\\n        stack<TreeNode *> st;\\n        st.push(root);  //Push root\\n        while(!st.empty()){\\n            root=st.top();  //New root=Take the topmost node\\n            st.pop();       //Remove from stack\\n            pre.push_back(root->val);  //Push into ans vector\\n            if(root->right!=NULL) st.push(root->right);  //Goto Left \\n            if(root->left!=NULL ) st.push(root->left);   //Goto Right\\n        }\\n        return pre;\\n    }\\n};\\n```\n```\\nTime Complexity - O(N) //Traversing all nodes\\nSpace Complexity- O(N) //Storing all nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022895,
                "title": "python-4-solutions-recursion-stack-morris-1-morris-2-short-and-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBelow listed are 4 approaches:\\n- **Recursive:** Uses linear space. clean and Short. Potential recursion max depth issue.\\n- **Stack:** Uses linear space. Short.\\n- **Morris without recovery:** Uses constant space. Destroys the input tree.\\n- **Morris with recovery:** Uses constant space. Destroys and recovers the input tree before returning.\\n\\n---\\n\\n# Approach 1\\nRecursive solution.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            if not root: return\\n            yield root.val\\n            yield from preorder(root.left)\\n            yield from preorder(root.right)\\n                \\n        return list(preorder(root_))\\n```\\nReduced to 1 - liner:\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            yield from chain((root.val,), preorder(root.left), preorder(root.right)) if root else []\\n                \\n        return list(preorder(root_))\\n```\\n---\\n\\n# Approach 2\\nStack solution.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                yield node.val\\n                \\n                if node.right: stack.append(node.right)\\n                if node.left: stack.append(node.left)\\n                \\n        return list(preorder(root_))\\n```\\n\\n---\\n\\n# Approach 3\\nMorris Treversal without recovery.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right:\\n                    last = last.right\\n                last.right = node.right\\n\\n                yield node.val\\n                node = node.left\\n                \\n        return list(preorder(root_))\\n```\\n\\n---\\n\\n# Approach 4\\nMorris Treversal with recovery.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right and last.right != node:\\n                    last = last.right\\n                \\n                if last.right is None:\\n                    last.right = node\\n                    yield node.val\\n                    node = node.left\\n                else:\\n                    last.right = None\\n                    node = node.right\\n                \\n        return list(preorder(root_))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            if not root: return\\n            yield root.val\\n            yield from preorder(root.left)\\n            yield from preorder(root.right)\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            yield from chain((root.val,), preorder(root.left), preorder(root.right)) if root else []\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            stack = [root] if root else []\\n            \\n            while stack:\\n                node = stack.pop()\\n                yield node.val\\n                \\n                if node.right: stack.append(node.right)\\n                if node.left: stack.append(node.left)\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right:\\n                    last = last.right\\n                last.right = node.right\\n\\n                yield node.val\\n                node = node.left\\n                \\n        return list(preorder(root_))\\n```\n```\\nclass Solution:\\n    def preorderTraversal(self, root_: TreeNode | None) -> list[int]:\\n        # Morris (Destroys and recovers the tree)\\n        def preorder(root: TreeNode | None) -> Iterable:\\n            node = root\\n            while node:\\n                if node.left is None:\\n                    yield node.val\\n                    node = node.right\\n                    continue\\n\\n                last = node.left\\n                while last.right and last.right != node:\\n                    last = last.right\\n                \\n                if last.right is None:\\n                    last.right = node\\n                    yield node.val\\n                    node = node.left\\n                else:\\n                    last.right = None\\n                    node = node.right\\n                \\n        return list(preorder(root_))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022589,
                "title": "iterative-traversal-c-using-stack",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* temp=st.top();\\n            ans.push_back(temp->val);\\n            st.pop();\\n            if(temp->right!=NULL) st.push(temp->right);\\n            if(temp->left!=NULL) st.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>ans;\\n        if(root==NULL)\\n        {\\n            return ans;\\n        }\\n        stack<TreeNode*>st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* temp=st.top();\\n            ans.push_back(temp->val);\\n            st.pop();\\n            if(temp->right!=NULL) st.push(temp->right);\\n            if(temp->left!=NULL) st.push(temp->left);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022473,
                "title": "tree-easy-py",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []             \\n        stack, ans = [root],[]                                            \\n        while stack:                      \\n            node = stack.pop()             \\n            ans.append(node.val)                              \\n            if node.right:                 \\n                stack.append(node.right)   \\n            if node.left:                  \\n                stack.append(node.left )    \\n        return ans  \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        if not root: return []             \\n        stack, ans = [root],[]                                            \\n        while stack:                      \\n            node = stack.pop()             \\n            ans.append(node.val)                              \\n            if node.right:                 \\n                stack.append(node.right)   \\n            if node.left:                  \\n                stack.append(node.left )    \\n        return ans  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022311,
                "title": "0ms-c-faster-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(n)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>&v){        \\n        if(root==NULL)return ;\\n        v.push_back(root->val);\\n        solve(root->left,v);\\n        solve(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,vector<int>&v){        \\n        if(root==NULL)return ;\\n        v.push_back(root->val);\\n        solve(root->left,v);\\n        solve(root->right,v);\\n    }\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        solve(root,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022295,
                "title": "easy-java-solution-recursive-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null) {\\n            return new ArrayList<>();\\n        }\\n        if(root.left == null && root.right == null) {\\n            List<Integer> leaf = new ArrayList<>();\\n            leaf.add(root.val);\\n            return leaf;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(root.val);\\n        ans.addAll(preorderTraversal(root.left));\\n        ans.addAll(preorderTraversal(root.right));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        if(root == null) {\\n            return new ArrayList<>();\\n        }\\n        if(root.left == null && root.right == null) {\\n            List<Integer> leaf = new ArrayList<>();\\n            leaf.add(root.val);\\n            return leaf;\\n        }\\n        List<Integer> ans = new ArrayList<>();\\n        ans.add(root.val);\\n        ans.addAll(preorderTraversal(root.left));\\n        ans.addAll(preorderTraversal(root.right));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022288,
                "title": "python3-23-ms-faster-than-98-78-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.output = []\\n        def traverse(root):\\n            if(root):\\n                self.output.append(root.val)\\n                traverse(root.left)\\n                traverse(root.right)\\n        traverse(root)\\n        return self.output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        self.output = []\\n        def traverse(root):\\n            if(root):\\n                self.output.append(root.val)\\n                traverse(root.left)\\n                traverse(root.right)\\n        traverse(root)\\n        return self.output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3022253,
                "title": "java-easy-recursive-iterative-solution-approach-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- ***Preorder Traversal is :  Root -> left-subtree -> right-subtree***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- ### Recursive:\\n    1. Add the current root node to ans list\\n    2. Call preorder for the left subtree\\n    3. Call preorder for right subtree\\n    4. Base Case: If root is null just return.\\n\\n- ### Iterative:\\n    1. If the root is null return an empty list\\n    2. Create a stack which will hold nodes of the tree.\\n    3. Push the root onto the stack\\n    4. Now iterate till stack is not empty\\n    5. At every iteration do the following: \\n        a.  Pop the top node in stack and add it to ans list.\\n        b.  If we have a node to the right of the popped node, push it onto the stack;\\n        c.  If we have a left node add it to the stack too.\\n\\n\\n# Code \\n## Recursive Approach\\n```\\n// Recursive Solution\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        preorder(root, ls);\\n        return ls;\\n    }\\n    public void preorder(TreeNode root, List<Integer> ls){\\n        if(root == null) return;\\n\\n        ls.add(root.val);\\n        preorder(root.left, ls);\\n        preorder(root.right, ls);\\n         \\n    }\\n}\\n```\\n## Iterative Approach\\n``` \\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        if(root == null) return ls;\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode temp = st.pop();\\n            ls.add(temp.val);\\n            if(temp.right != null) st.push(temp.right);\\n            if(temp.left != null) st.push(temp.left);\\n        }\\n        return ls;\\n    } \\n}\\n```\\n\\n#### Please do Upvote if you find it helpful\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive Solution\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        preorder(root, ls);\\n        return ls;\\n    }\\n    public void preorder(TreeNode root, List<Integer> ls){\\n        if(root == null) return;\\n\\n        ls.add(root.val);\\n        preorder(root.left, ls);\\n        preorder(root.right, ls);\\n         \\n    }\\n}\\n```\n``` \\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> ls = new ArrayList<>();\\n        if(root == null) return ls;\\n\\n        Stack<TreeNode> st = new Stack<>();\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode temp = st.pop();\\n            ls.add(temp.val);\\n            if(temp.right != null) st.push(temp.right);\\n            if(temp.left != null) st.push(temp.left);\\n        }\\n        return ls;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022130,
                "title": "preorder-traversal-simple-approach",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        preorder(root,list);\\n        return list;\\n    }\\n    public void preorder(TreeNode root,List<Integer> list){\\n        if(root==null) return ;\\n        list.add(root.val);\\n        preorder(root.left,list);\\n        preorder(root.right,list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<Integer> preorderTraversal(TreeNode root) {\\n        List<Integer> list=new ArrayList<Integer>();\\n        preorder(root,list);\\n        return list;\\n    }\\n    public void preorder(TreeNode root,List<Integer> list){\\n        if(root==null) return ;\\n        list.add(root.val);\\n        preorder(root.left,list);\\n        preorder(root.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1748954,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748997,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748979,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749377,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1570384,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1565777,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749643,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748998,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1572820,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1568092,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748954,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748997,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748979,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749377,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1570384,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1565777,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1749643,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1748998,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1572820,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1568092,
                "content": [
                    {
                        "username": "kontsis",
                        "content": "I remember the days when I couldn\\'t solve this. Look how far we\\'ve come."
                    },
                    {
                        "username": "miss_sunshine",
                        "content": "someday I\\'ll reach there!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "[@shivamgcodes](/shivamgcodes) there is no book like this ig but you can go to cp-alogrithms website it has all the algos but not all algos are beautiful and worth doing, like morris traversal is only worth using if you are constrained with using no extra space and already know it, but can be used to learn a new perspective on using null pointers in trees and threading.\\nalmost all sufficient algorithms are most beautifully explained in cormen but it doesn\\'t fill the criteria for what you want  but  i trust this book."
                    },
                    {
                        "username": "ankurgupta1999",
                        "content": "I remember the college days when I could solve this at a blink. Look how far I\\'ve come \\uD83E\\uDD72"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@Rishabh_yaduwanshi](/Rishabh_yaduwanshi) bro can u please recommend me a book which has all the algos and DS , not necessarily in depth , because being honest , i am reading the word morris traversal for the first time ."
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "i\\'m living your days right now..... hope i might solve these problems soon...!! :  )"
                    },
                    {
                        "username": "mrunfunny",
                        "content": "I remember skipping questions that had slightest mention of tree or graph."
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "i spent a week understanding all these traversals and wasn\\'t able to grasp whole,but now even Morris traversal seems simple,keep pushing."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Yes!! Hard work pays off!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Remember : \\nPreorder Traversal : Root | Left | Right"
                    },
                    {
                        "username": "parapsychic",
                        "content": "A quick way to remember preorder, postorder and inorder is to actually look at the meaning of the word itself. It\\'s always left -> right. The only position that matters is the root. Pre = before, In = in between, post = after.\\nSo, preorder becomes: root left right\\npostorder becomes: left right root\\ninorder becomes: left root right"
                    },
                    {
                        "username": "Msey",
                        "content": "But remember, the power of the Jedi Knight is the power of the universe"
                    },
                    {
                        "username": "kenzoengineer",
                        "content": "thank you daddy leetcode for giving us this question after \"Max Points on a Line\""
                    },
                    {
                        "username": "itsyaboiimoulee",
                        "content": "[@shivamgcodes](/shivamgcodes) instead of copy pasting it, atleast should have learned the brute force approach and attempted it. it doesnt take much time.. im also a beginner"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "i did not even attempt it , just copy pasted the solution will just read the solution and then implement it myself "
                    },
                    {
                        "username": "neopraveen",
                        "content": "Just a little addition for whom tree is new :\\nPreOrder Traversal -> In preorder traversal, the root node is visited first, then left subtree and then right subtree.\\nIt\\'s required simple recursive solution. You just need to add your current node in the List (it may be a class level variable) and traverse left and right node with same recursive function. That\\'s it, no more line of code is required, the same function will take care of whole tree traversal. Maybe the solution is looking very easy, but believe me it\\'s more easier than you think.\\nPS - Please don\\'t forget to check if current node is null or not, in example you can see a node with null value.\\n\\nIf I am helpful, you know how you can motivate me :)\\nHappy coding."
                    },
                    {
                        "username": "ritteh",
                        "content": "The problem statement indicates the recurrsive version is trivial. How can it be trivial for anyone who has never done trees before? There is exactly zero guidance on how to do it. What terrible training. Fortunately there is Google and I was able to solve it."
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "I think that the problem is trivial when you\\'ve got a bit of experience under your belt. Leetcode isn\\'t really for beginners. This problem is probably one of the easiest problems on Leetcode, so relative to other problems on Leetcode, it is trivial.\\n\\nNow, with all that said, the dumb part is that the iterative solution is just as trivial as the recursive solution, for this particular problem anyways.\\n\\nFor other DFS algos such as Post Order Traversal, the iterative version is actually a lot harder than the recursive version."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Agree"
                    },
                    {
                        "username": "Mr_Fish",
                        "content": "Just out of curiosity. I am perfectly capable of coming up with BFS or DFS of traversing a tree as well as just recursion. \\n\\nWill knowing Morris Traversal help you in an interview? I mean while it has O(1) space, it actually has O(2*n) time complexity and time complexity is more significant in an interview."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "O(2 * n) is still O(n). The problem is the locality. Chasing pointers is cache-unfriendly on modern architectures, Morris traversal follows each pointer multiple times so it probably tends to be slower. But in an interview situation it depends on the interviewer. They might just want to tick boxes on a checklist (recursive: check, morris: check), they might be a show-off who tries to impress the interviewee with obscure knowlege (not good but it happens) or they might be an experienced programmer who wants to you find a reasonable solution and/or weigh the advantages/disadvantages."
                    },
                    {
                        "username": "space_invader",
                        "content": "![2023-01-09 15.32.48.jpg](https://assets.leetcode.com/users/images/2323c791-f48e-431d-a064-499d1a314186_1673260399.4520557.jpeg)"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Recursive approach is quite trivial, can you code it iteravtively!!"
                    },
                    {
                        "username": "Rishabh_yaduwanshi",
                        "content": "use morris traversal if you want to use constant space,but if you can trade in space using stack is best."
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "stack<TreeNode*> s;\\nwhile(root || !s.empty()){\\n   if(root){\\n        res.push_back(root->val);\\n        s.push(root);\\n        root=root->left;\\n      }\\n   else{\\n        TreeNode* temp=s.top();\\n        temp=temp->right;\\n        }\\n   }\\nreturn res;"
                    },
                    {
                        "username": "nishant7372",
                        "content": "        if(root!=null)\n           stack.push(root);\n        while(!stack.isEmpty()){\n           TreeNode curr = stack.pop();\n           list.add(curr.val);\n           if(curr.right!=null)\n               stack.push(curr.right);\n           if(curr.left!=null)\n               stack.push(curr.left);\n        }"
                    },
                    {
                        "username": "tjin94",
                        "content": "as the title suggests, my code fails for this:\\n\\n[3,5,1,4,2]\\n\\ntest case(testcase66) and i have no idea how they visualize this input tree \\xA0 as the example is too short.."
                    },
                    {
                        "username": "andresstawski",
                        "content": "did you declare your vector as a global variable?"
                    },
                    {
                        "username": "llufan",
                        "content": "`const preorderTraversal = (root) => root ? [root.val, ...preorderTraversal(root.left), ...preorderTraversal(root.right)] : []`"
                    }
                ]
            },
            {
                "id": 1569545,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1750815,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1749782,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1749373,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1569864,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1571310,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 2067039,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 2045738,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1950035,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1901509,
                "content": [
                    {
                        "username": "SDWillems",
                        "content": "This is my First Leetcode challenge I take.\\nSo you get a little bit of explenation what a Binary Tree is and what ways there are to traverse. Then you directly must make an question without any knowledge of how you can do this? On top of that they add that you must return a list, what makes it Way harder bc now you need to create a new list everytime and add it recursivly?? \\n\\nMy question: HOW can one learn from this? I don\\'t see how you learn from not knowing what you must do or how you can get at it. The only way I know how to do it is from looking at the answers.. There must be a lesson but I just cannot find it.."
                    },
                    {
                        "username": "VinayakNegi",
                        "content": "this platform is not for learning, this is for practicing what you already know if you think that these questions will help you learn without you having prior knowledge then it\\'ll be a hell for you here. \\nI suggest you to go and watch a few videos, practice a few questions and then implement it. \\n"
                    },
                    {
                        "username": "bean_bean005",
                        "content": "`int* preorderTraversal(struct TreeNode* root, int* returnSize){\nstruct TreeNode* p=(struct TreeNode*) malloc(sizeof(struct TreeNode));\nif(root){\n    p=root->val;\n    preorderTraversal(root->left, returnSize);\n    preorderTraversal(root->right, returnSize);\n}\nreturn p;\n}`\nWhat is wrong with this C solution"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The function should return an array of `int`, and communicate the number of elements in the array via the OUT-parameter `returnSize`. So in some way you will have to allocate enough memory for all values in the tree, write the values to the array, and return it.  \\nIn this solution the function allocates memory for a single `struct TreeNode`, stores the value of the `root` in that allocated memory, calls itself recursively for the left and right subtree and discards the result of those function calls. That doesn\\'t work at all.  \\n\\nHow about this: First count the number of nodes in the tree, then allocate enough memory for the result, then call a \"helper function\" that writes to the array and calls itself recursively."
                    },
                    {
                        "username": "ajaymaida17",
                        "content": "100% beats  c++ easy Iterative solution: \nHINT: \nuse Stack to process each node;\npush right element first and then left .\nand process stack till it becomes an empty.\n\n\n\n\n\n\n\n\n         vector<int> v;\n        stack<TreeNode*> st;\n        if(root==NULL) return v;\n        st.push(root);\n        while(!st.empty()){\n            TreeNode* temp=st.top();\n            st.pop();\n            v.push_back(temp->val);\n            if(temp->right!=NULL)st.push(temp->right);\n            if(temp->left!=NULL)st.push(temp->left);\n        }\n        return v; "
                    },
                    {
                        "username": "rjalali",
                        "content": "We deserved this after yesterday\\'s problem."
                    },
                    {
                        "username": "Petersburg",
                        "content": "Why do some answers use while root or stack: and others use while stack: ?\\n\\nUsually the latter is much simpler and I cannot understand the thought process behind \\nwhile root or stack:\\n\\nCan anyone help me here?"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "As you understood the second approach:\\nbasically here you are pushing the right then left, so when you go to the next iteration you pick the left part of the current node from stack first. And after completing that part you come to the right part of the current node.\\n\\nIn the first approach , instead of pushing the left part and poping it from the stack, we just take that left part into root as:\\n    root=root->left and continue pushing the right part.\\nSo, you need to check either stack is not empty or root exists in the first approach as the iteration condition.\\n\\n"
                    },
                    {
                        "username": "arthurjwannerjr",
                        "content": "It basically means that the loop will keep looping if the data exists.\\n\"while root\" will keep looping if the node named root exists and continues to exist.\\n\"while stack\" will keep looping as long as the stack is not empty."
                    },
                    {
                        "username": "feiger123",
                        "content": "although recursive is trivial, not sure how to pass the return value: List<Integer> if using recursive method.\\n\\nLooks like we can use global variables, any better ideas?"
                    },
                    {
                        "username": "nishant7372",
                        "content": "if you want to avoid using global variable, then create another function and pass list/vector to it."
                    },
                    {
                        "username": "ivozayas",
                        "content": "excuse me?\\n\\nInput\\nroot =\\n[1,4,3,2]\\n\\nOutput\\n[1,4,3,2]\\n\\nExpected\\n[1,4,2,3]"
                    },
                    {
                        "username": "ysosalty",
                        "content": "why is there a null at all i dont get it"
                    },
                    {
                        "username": "codearyan",
                        "content": "why this code doesn\\'t work like is there a way to code it in same function without creating a helper one \\n\\n\\nvector<int> preorderTraversal(TreeNode* root) {\\n        vector<int> v;\\n       \\n        if (root  == NULL) {\\n            return v ;\\n        }\\n        \\n       v.push_back(root->val);\\n        preorderTraversal(root->left);\\n       preorderTraversal(root->right);\\n       return v;\\n        \\n    }"
                    },
                    {
                        "username": "codearyan",
                        "content": "[@andresstawski](/andresstawski)  the vector declaration is wrong else the code works thank you so much.\\n"
                    },
                    {
                        "username": "andresstawski",
                        "content": "put vector v outside of the function\\n\\nclass Solution {\\npublic:\\n    \\nvector<int> ans;\\n\\n    vector<int> preorderTraversal(TreeNode* root) {\\n       \\n\\n        if (root == NULL) return ans;\\n        \\n        ans.push_back(root -> val);\\n    \\n        if (root->left) preorderTraversal(root->left);\\n        if (root->right) preorderTraversal(root->right);\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Each time `preorderTraversal()` gets called the function creates an empty `std::vector` and returns it at the end. But the recursive calls (`preorderTraversal(root->left);` and `preorderTraversal(root->right);`) create their own `std::vector` which gets discarded. Therefore in the end the result is a `std::vector` with a single element, the value of the `root` (or none if the `root` is `NULL`).\\n\\nCreating a helper function that takes the `std::vector` by reference allows the recursive calls to write to the exact same `std::vector`."
                    },
                    {
                        "username": "andresstawski",
                        "content": "using vector as a global variable instead of local variable helped me solve issue where I could not push the last node to the vector."
                    }
                ]
            },
            {
                "id": 1851840,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1801928,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1800542,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1772395,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1754967,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750338,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750278,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750130,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1750129,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1749798,
                "content": [
                    {
                        "username": "williamtheconqueror",
                        "content": "love how this used to be medium"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Use Self function to work on"
                    },
                    {
                        "username": "seelamadisheshu149",
                        "content": "Explanation step by step in recursive method:\\n1. create a return type list\\n2.call the preorder function\\n    In preorder function\\n       1.base condition \\n       2. data leftnode right node \\n3.return list;\\n\\npreorder data leftnode rightnode\\ninorder leftnode data rightnode\\npostorder leftnode rightnode data"
                    },
                    {
                        "username": "SumitHere",
                        "content": "This is what I\\'m doing in Swift. it\\'s not working but same logic is working in Java.\\n\\nclass Solution {\\n            var arr = [Int]()\\n    func preorderTraversal(_ root: TreeNode?) -> [Int] {\\n        if root == nil {\\n            return arr\\n        }\\n        arr.append(root!.val)\\n        if root?.left != nil {\\n            preorderTraversal(root?.left)\\n        } else if root?.right != nil {\\n            preorderTraversal(root?.right)\\n        }\\n        return arr\\n    }\\n}"
                    },
                    {
                        "username": "user3571Ej",
                        "content": "```C++\\n    vector<int> preorderTraversal(TreeNode* root) {\\n    \\n        static vector<int> v;\\n        if(!root)\\n            return {};\\n        v.push_back(root->val);\\n        preorderTraversal(root->left);\\n        preorderTraversal(root->right);\\n        return v;\\n    }\\n```\\nthis should work but for this test case it shows it has fails \\n\\ntest case => root = [1] in my computer it return 1 but in the web ide provided by leetcode it return [1,2,3,1] as output which is weird "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "`v` is a `static` local variable, it keeps its value across the function calls. Remove that keyword `static`."
                    },
                    {
                        "username": "vishwajeet_004",
                        "content": "I tried to solve this problem and in starting I was not able to solve and Today I solved it after few mins of pain"
                    },
                    {
                        "username": "juggernaut1101",
                        "content": "Any suggestions on where I can start to learn about trees from scratch?"
                    },
                    {
                        "username": "tinnamchoi",
                        "content": "mfw i misunderstood what preorder traversal was and did bfs instead of dfs"
                    },
                    {
                        "username": "bipul007",
                        "content": "This ques can be solved by creating a viod func having parameters root and a vector to store the root."
                    },
                    {
                        "username": "pr0107",
                        "content": "You know the happiness of getting this question after getting max points on line"
                    }
                ]
            },
            {
                "id": 1749687,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749635,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749616,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749588,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749478,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749392,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749384,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749292,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749286,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749237,
                "content": [
                    {
                        "username": "user4216mR",
                        "content": "Remember :\\nPreorder Traversal : Root | Left | Right.... "
                    },
                    {
                        "username": "hahahamid",
                        "content": "Do I really need to know Morris Traversal?   "
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "it\\'s fav question in interview for the BST topic , or in O(1) space complexity to traversing in tree"
                    },
                    {
                        "username": "Praveen135",
                        "content": "c++ easy pesy..\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>res;\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        \\n        if(!root)return res;\\n        res.push_back(root->val);\\n        if(root->left){\\n            preorderTraversal(root->left);\\n        }\\n        if(root->right){\\n            preorderTraversal(root->right);\\n        }\\n        return res;\\n    }\\n};"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "it\\'s Easy problem .\\nPreOrder Trversal : Root | Left | Right ."
                    },
                    {
                        "username": "shaon_here",
                        "content": "\n    vector<int> preorderTraversal(TreeNode* root) {\n\n        vector<int> res;\n        if(!root)\n            return res;\n        res.push_back(root->val);\n        if(root->left)\n            preorderTraversal(root->left);\n        if(root->right)\n            preorderTraversal(root->right);\n        return res;\n\n    }             \n\n\nCan anyone say why this code returns [1] in case of [1,null,2,3] ?"
                    },
                    {
                        "username": "VedanshNigam",
                        "content": "You need to declare the vector outside the function.\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "nice hills -> extra hard / extra easy"
                    },
                    {
                        "username": "anuAi",
                        "content": "someone pls suggest an approach to solve this problem"
                    },
                    {
                        "username": "Dorababu_pc",
                        "content": "you can use the following three approaches:\\n1. Using recursion.\\n2. Using iteration with the help of stack.\\n3. Using the Morris approach , which is similar to approach 2 but without using stack."
                    },
                    {
                        "username": "powerpro1",
                        "content": "Root- >Root.left->Root.right"
                    },
                    {
                        "username": "S_Basu",
                        "content": "***Wow!! Surprised** to see Preorder traversal of binary tree after yesterday's question - Max Points on a Line.*\nI thought another BrainF***-ing Question will come today... 😅🙏"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "looks like yesterday\\'s setter got fired"
                    }
                ]
            },
            {
                "id": 1749221,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749219,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749135,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749091,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749090,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749088,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1749059,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1748960,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1736949,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            },
            {
                "id": 1735526,
                "content": [
                    {
                        "username": "kd_5304",
                        "content": "\"Max points on a line\" was there just to break my streak T_T"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 0 ms || Beats 100% runtime and space || Easy to understand\\nhttps://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3022745/simple-java-0-ms-beats-100-runtime-and-space-easy-to-understand/"
                    },
                    {
                        "username": "verma15ayush",
                        "content": "Easy question for Daily Challenge is an opportunity to revisit the hard ones encountered lately."
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "preorder : dlr ( data left right )\\ninorder  : ldr (left data right )"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "I wonder life to be easy as this problem..."
                    },
                    {
                        "username": "amanchandna",
                        "content": "preorder = Root,Left,Right\\nFirst process `root` node, than `root.left` than `root.right`"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "3 ways to solve this problem\\n\\nApproach\\n**1.Recursive approach-----------**\\n\\nCheck if the current node is empty or Null.\\nDisplay the data part of the root (or current node)\\nTraverse the left subtree by recursively calling the preorder function.\\nTraverse the right subtree by recursively calling the preorder function.\\n**2.Iterative approach----------**\\n\\nCreate an empty stack and push the root node to it.\\nDo the following while the stack is not empty\\nPop the top item from the stack and display it.\\nPush the right child of the popped item to the stack.\\nPush the left child of the popped item to the stack.\\n**Complexity**\\nTime complexity:O(N)\\nSpace complexity:O(H)H=height of binary tree\\n**3.Morris traversal-------**\\n\\nInitialize current as root\\nWhile current is not null:\\nIf current does not have a left child:\\n(i) Print current\\'s data.\\n(ii) Go to the right, i.e., current = current.right\\nElse:\\n(i)Make current as the right child of the rightmost node in current\\'s left subtree.\\n(ii)Go to this left child, i.e., current = current.left.\\n**Complexity**\\nTime complexity:O(N)\\n\\nSpace complexity:O(1)"
                    },
                    {
                        "username": "soumita_basu",
                        "content": "This problem is easy if your knowledge of working of trees is clear.\\n\\nIn this we will create a vector of datatype integer in Class Solution of public access (outside the function) so that we don\\'t have to create another function unnecessarily and the vector can be accessed by the function.\\n\\nInside the function, create an if loop stating a condition: if root!=NULL\\nHere, if root becomes NULL, the root will not be checked further.\\n\\nFor every root!=NULL checked condition, we will push root value in the vector and call the function for left elements to the root node and then call the function for right elements to the root node.\\n\\nThis way, the tree is checked from both the sides.\\n\\nReturn the resultant vector.\\n\\nLink to the solution for better understanding:[ https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/]( https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3021999/simple-and-easy-c-code/)\\n\\nHope it helps ^_^"
                    },
                    {
                        "username": "priyankakumari6709",
                        "content": "MY C++ SOLUTION\\n\\nclass Solution {\\npublic:\\n\\nvoid helper(TreeNode* root, vector<int> &v)\\n{\\n    if(root==NULL)\\n     return;\\n     v.push_back(root->val);\\n     helper(root->left,v);\\n     helper(root->right,v);\\n}\\n    vector<int> preorderTraversal(TreeNode* root) {\\n        vector<int>v;\\n        helper(root,v);\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haldkar_shubham",
                        "content": "Python Code\\n\\n\\nhttps://siteinvokers.com/binary-tree-pre-order-traversal/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Shortest Word Distance II",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565247,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1564914,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1571487,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1894890,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            },
            {
                "id": 1867751,
                "content": [
                    {
                        "username": "daalp9999",
                        "content": "It would help a ton to understand what does it mean as `distance`\\n\\nAlso felt that it should have explaination with sample input and output"
                    },
                    {
                        "username": "hahadaxiong",
                        "content": "We can use a hash map to store the shortest distances for any pair of words."
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "The format is really weird that I can't catch the idea. Which one is input String[], which is word1, which is word2?\\n\\n[\"WordDistance\",\"shortest\",\"shortest\"]\\n[[[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"]],[\"coding\",\"practice\"],[\"makes\",\"coding\"]]"
                    },
                    {
                        "username": "drnothing",
                        "content": "Poorly written question, downvoted."
                    },
                    {
                        "username": "willm3003",
                        "content": "What is \"distance\"?"
                    },
                    {
                        "username": "willm3003",
                        "content": "It is comparing the indices"
                    }
                ]
            }
        ]
    },
    {
        "title": "Reverse String",
        "question_content": "<p>Write a function that reverses a string. The input string is given as an array of characters <code>s</code>.</p>\n\n<p>You must do this by modifying the input array <a href=\"https://en.wikipedia.org/wiki/In-place_algorithm\" target=\"_blank\">in-place</a> with <code>O(1)</code> extra memory.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n<strong>Output:</strong> [\"o\",\"l\",\"l\",\"e\",\"h\"]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n<strong>Output:</strong> [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s[i]</code> is a <a href=\"https://en.wikipedia.org/wiki/ASCII#Printable_characters\" target=\"_blank\">printable ascii character</a>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 80937,
                "title": "java-simple-and-clean-with-explanations-6-solutions",
                "content": "https://www.ratchapong.com/algorithm-practice/leetcode/reverse-string [Full solutions]\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            char temp = word[i];\\n            word[i] = word[j];\\n            word[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(word);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to character array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the string while the other pointer is pointing at the end of the string.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            byte temp = bytes[i];\\n            bytes[i] = bytes[j];\\n            bytes[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string. Each character is `1` byte.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to byte array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the byte array while the other pointer is pointing at the end of the\\n        byte array.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint.\\n    </p>\\n    <p>\\n        Note that this assume that the input string is encoded using\\n        ASCII format. This will not work with Unicode value where one character may be more than 1 byte.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            word[i] = (char) (word[i] ^ word[j]);\\n            word[j] = (char) (word[i] ^ word[j]);\\n            word[i] = (char) (word[i] ^ word[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to character array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the string while the other pointer is pointing at the end of the string.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint. The swapping is done by using <code>XOR</code> swapping\\n        algorithm.\\n    </p>\\n    <div align=\"center\" class=\"margin-bottom-10 margin-top-10\">\\n        <table class=\"table table-bordered\" style=\"width: 60%\">\\n            <thead>\\n                <tr>\\n                    <th class=\"text-center\">Operation</th>\\n                    <th class=\"text-center\">Result</th>\\n                </tr>\\n            </thead>\\n            <tbody>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = a \\\\oplus b`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`b = a \\\\oplus b`</td>\\n                    <td align=\"left\">`b = (a \\\\oplus b) \\\\oplus b = a \\\\oplus b \\\\oplus b = a`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = (a \\\\oplus b) \\\\oplus a = a \\\\oplus b \\\\oplus a = b`</td>\\n                </tr>\\n            </tbody>\\n        </table>\\n    </div>\\n    <p>\\n        Note that this assume that the input string is encoded using\\n        ASCII format. This will not work with Unicode value where one character may be more than 1 byte.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[j] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        The algorithm need to reverse the whole string. Each character is `1` byte.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        string to byte array.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Iterative Swapping Using Two Pointers\\n    </p>\\n    <p>\\n        One pointer is pointing at the start of the byte array while the other pointer is pointing at the end of the\\n        byte array.\\n        Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating\\n        rotation of a string with respect to its midpoint. The swapping is done by using <code>XOR</code> swapping\\n        algorithm.\\n    </p>\\n    <div align=\"center\" class=\"margin-bottom-10 margin-top-10\">\\n        <table class=\"table table-bordered\" style=\"width: 60%\">\\n            <thead>\\n                <tr>\\n                    <th class=\"text-center\">Operation</th>\\n                    <th class=\"text-center\">Result</th>\\n                </tr>\\n            </thead>\\n            <tbody>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = a \\\\oplus b`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`b = a \\\\oplus b`</td>\\n                    <td align=\"left\">`b = (a \\\\oplus b) \\\\oplus b = a \\\\oplus b \\\\oplus b = a`</td>\\n                </tr>\\n                <tr>\\n                    <td align=\"center\">`a = a \\\\oplus b`</td>\\n                    <td align=\"left\">`a = (a \\\\oplus b) \\\\oplus a = a \\\\oplus b \\\\oplus a = b`</td>\\n                </tr>\\n            </tbody>\\n        </table>\\n    </div>\\n    <p>\\n        Note that this assume that the input string is encoded using\\n        ASCII format. This will not work with Unicode value where one character may be more than 1 byte.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n)` (Average Case) and `O(n)` (Worst Case) where `n` is the total number character in the input string.\\n        Depending on the implementation. However, it is not possible to reverse string in less than `O(n)`.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(n)` space is used where `n` is the total number character in the input string. Space is needed to transform\\n        immutable string into character buffer in <code>StringBuilder</code>.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Using Java Library\\n    </p>\\n    <p>\\n        Java's library is probably slower that direct implementation due to extra overhead in check various edge cases\\n        such as surrogate pairs.\\n    </p>\\n</div>\\n\\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        int length = s.length();\\n        if (length <= 1) return s;\\n        String leftStr = s.substring(0, length / 2);\\n        String rightStr = s.substring(length / 2, length);\\n        return reverseString(rightStr) + reverseString(leftStr);\\n    }\\n}\\n```\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Complexity Analysis</h4>\\n    <p>\\n        <b>Time Complexity:</b>\\n        `O(n log(n))` (Average Case) and `O(n * log(n))` (Worst Case) where `n` is the total number character in the\\n        input string.\\n        The recurrence equation is `T(n) = 2 * T(n/2) + O(n)`. `O(n)` is due to the fact that concatenation function\\n        takes linear time.\\n        The recurrence equation can be solved to get `O(n * log(n))`.\\n    </p>\\n    <p>\\n        <b>Auxiliary Space:</b>\\n        `O(h)` space is used where `h` is the depth of recursion tree generated which is `log(n)`. Space is needed for\\n        activation stack during recursion calls.\\n    </p>\\n</div>\\n<div class=\"margin-bottom-20\">\\n    <h4 class=\"text-uppercase margin-bottom-10\">Algorithm</h4>\\n    <p>\\n        <b>Approach:</b>\\n        Divide and Conquer (Recursive)\\n    </p>\\n    <p>\\n        The string is split into half. Each substring will be further divided. This process continues until the string\\n        can no longer be divided (length `<= 1`). The conquering process will take they previously split strings and\\n        concatenate them in reverse order.\\n    </p>\\n</div>",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            char temp = word[i];\\n            word[i] = word[j];\\n            word[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(word);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            byte temp = bytes[i];\\n            bytes[i] = bytes[j];\\n            bytes[j] = temp;\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        char[] word = s.toCharArray();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            word[i] = (char) (word[i] ^ word[j]);\\n            word[j] = (char) (word[i] ^ word[j]);\\n            word[i] = (char) (word[i] ^ word[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        byte[] bytes = s.getBytes();\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[j] = (byte) (bytes[i] ^ bytes[j]);\\n            bytes[i] = (byte) (bytes[i] ^ bytes[j]);\\n            i++;\\n            j--;\\n        }\\n        return new String(bytes);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        int length = s.length();\\n        if (length <= 1) return s;\\n        String leftStr = s.substring(0, length / 2);\\n        String rightStr = s.substring(length / 2, length);\\n        return reverseString(rightStr) + reverseString(leftStr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901756,
                "title": "java-c-3-way-s-visual-solution",
                "content": "How\\'s going Ladies - n - Gentlemen today we are going to solve another coolest problem i.e. **Reverse String**\\n\\n```\\nThis is A way easy Problem, if you encounter this in your Technical Interview, belive me you are way more lucky <^^> \\n```\\n\\nSo, to solve this problem there are couple of ways to do that.\\n```\\nWe gonna solve this problem in 3 simple & effective way\\'s \\n```\\n**1. Two Pointer\\'s**\\n\\n**`Visuall EXPLANATION :-`**\\n\\n![image](https://assets.leetcode.com/users/images/75d33fe6-b487-4781-80de-5b6bfe447021_1648774237.6632404.gif)\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n**2. Recursive Call**\\n\\nExplanation is same as Two Pointer\\'s what only different happening is, we are solve this using our fucntion call every time. We are just doing the work to reverse only **1 time** first & last element, rest one we are not worrying about!! Because recursion will do that for us :)\\n\\n**Java**\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        solve(s, i, j);\\n    }\\n    public void solve(char[] s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        solve(s, i, j);\\n    }\\n    void solve(vector<char>& s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\n**3. Stack**\\n\\n**`Visuall EXPLANATION :-`**\\n\\n![image](https://assets.leetcode.com/users/images/6184e953-8895-4444-b1ed-5b288e955acc_1648775574.5048985.gif)\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        Stack<Character> st = new Stack<>();\\n        String str = new String(s);\\n        for(int i = 0; i < str.length(); i++){\\n            st.push(s[i]);\\n        }\\n        char ans[] = new char[s.length];\\n        int i = 0;\\n        while(st.size() > 0){\\n            s[i++] = st.pop();\\n        }\\n        for(int j = 0; j < str.length(); j++){\\n            ans[j] = str.charAt(j);\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        //create a stack\\n        stack<char> st;\\n        //loop through the string, to add all the string elements in stack\\n        for(int i=0;i<s.size();i++){\\n            //create a variable to add the values\\n            char ch = s[i];\\n            st.push(ch);\\n        }\\n        //empty the original string\\n        s.clear();\\n        //add the stack elements to the string\\n        while(!st.empty()){\\n            char ch = st.top();\\n            //reversed\\n            s.push_back(ch);\\n            st.pop();\\n        }\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nThis is A way easy Problem, if you encounter this in your Technical Interview, belive me you are way more lucky <^^> \\n```\n```\\nWe gonna solve this problem in 3 simple & effective way\\'s \\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        \\n        while(i <= j){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length - 1;\\n        solve(s, i, j);\\n    }\\n    public void solve(char[] s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int j = s.size() - 1;\\n        solve(s, i, j);\\n    }\\n    void solve(vector<char>& s, int i, int j){\\n        if(i >= j) return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        solve(s, ++i, --j);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        Stack<Character> st = new Stack<>();\\n        String str = new String(s);\\n        for(int i = 0; i < str.length(); i++){\\n            st.push(s[i]);\\n        }\\n        char ans[] = new char[s.length];\\n        int i = 0;\\n        while(st.size() > 0){\\n            s[i++] = st.pop();\\n        }\\n        for(int j = 0; j < str.length(); j++){\\n            ans[j] = str.charAt(j);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        //create a stack\\n        stack<char> st;\\n        //loop through the string, to add all the string elements in stack\\n        for(int i=0;i<s.size();i++){\\n            //create a variable to add the values\\n            char ch = s[i];\\n            st.push(ch);\\n        }\\n        //empty the original string\\n        s.clear();\\n        //add the stack elements to the string\\n        while(!st.empty()){\\n            char ch = st.top();\\n            //reversed\\n            s.push_back(ch);\\n            st.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80935,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while(i < j){\\n                swap(s[i++], s[j--]); \\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int i = 0, j = s.size() - 1;\\n            while(i < j){\\n                swap(s[i++], s[j--]); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80946,
                "title": "python2-7-3-solutions-recursive-classic-pythonic",
                "content": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        l = len(s)\\n        if l < 2:\\n            return s\\n        return self.reverseString(s[l/2:]) + self.reverseString(s[:l/2])\\n\\n\\nclass SolutionClassic(object):\\n    def reverseString(self, s):\\n        r = list(s)\\n        i, j  = 0, len(r) - 1\\n        while i < j:\\n            r[i], r[j] = r[j], r[i]\\n            i += 1\\n            j -= 1\\n\\n        return \"\".join(r)\\n\\nclass SolutionPythonic(object):\\n    def reverseString(self, s):\\n        return s[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        l = len(s)\\n        if l < 2:\\n            return s\\n        return self.reverseString(s[l/2:]) + self.reverseString(s[:l/2])\\n\\n\\nclass SolutionClassic(object):\\n    def reverseString(self, s):\\n        r = list(s)\\n        i, j  = 0, len(r) - 1\\n        while i < j:\\n            r[i], r[j] = r[j], r[i]\\n            i += 1\\n            j -= 1\\n\\n        return \"\".join(r)\\n\\nclass SolutionPythonic(object):\\n    def reverseString(self, s):\\n        return s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 670137,
                "title": "python-3-actually-easiest-solution",
                "content": "**It\\'s so simiple, a caveman could do it**\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```\\n\\n**Note:**\\n`s[:] = s[::-1]` is required **NOT** `s = s[::-1]` because you have to edit the list **inplace**. \\nUnder the hood, `s[:] =` is editing the actual memory bytes s points to, and `s = ` points the variable name `s` to other bytes in the memory.\\n\\n(easiest except .reverse())",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669571,
                "title": "python-oneliner-two-pointers-explained",
                "content": "It is very tempting in Python just to use  `reverse()` function, but I think it is not fully honest solution. \\nInstead, we go from the start and the end of the string and swap pair of elements. One thing, that we need to do is to stop at the middle of our string. We can see this as simplified version of **two points** approach, because each step we increase one of them and decrease another.\\n\\n**Complexity**: Time complexity is `O(n)` and additional space is `O(1)`.\\n\\n```\\nclass Solution:\\n    def reverseString(self, s):\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s):\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669726,
                "title": "python-js-java-go-c-sol-sharing-w-visualization",
                "content": "Several solution sharing\\n\\n---\\n\\n**Illustartion**&**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1591263228.png)\\n\\n---\\n\\n**Implementation** by mirror image:\\n\\nPython\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n\\t\\t\\n\\t\\t# reverse string by mirror image\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\\n\\n\\n---\\n\\n\\nC++\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        size_t n = s.size();\\n        \\n\\t\\t// reverse string by mirror image\\n        for( size_t i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            swap(s[i], s[n-1-i]);            \\n        }\\n        \\n        return;\\n    }\\n};\\n```\\t\\n\\t\\n</details>\\n\\n---\\n\\nGolang:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nfunc reverseString(s []byte)  {\\n    \\n    size := len(s)\\n    \\n    // reverse string by mirror image\\n    for i := 0 ; i < size/2 ; i++{\\n        s[i], s[size-1-i] = s[size-1-i], s[i]\\n    }\\n    \\n    return\\n    \\n}\\n```\\t\\n\\t\\n</details>\\n\\n\\n---\\n\\nJava:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int n = s.length;\\n        \\n\\t\\t// reverse string by mirror image\\n        for( int i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            char temp = s[i];\\n            s[i] = s[n-1-i];\\n            s[n-1-i] = temp;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nvar reverseString = function(s) {\\n    \\n    let size = s.length;\\n    \\n    // reverse string by mirror image\\n    for(let i = 0 ; i < Math.floor(size/2) ; i++ ){\\n        [ s[i], s[size-1-i] ] = [ s[size-1-i], s[i] ] ;\\n    }\\n    \\n    return;\\n};\\n```\\t\\n\\t\\n</details>\\n\\n\\n\\n\\n---\\n\\n**Implementation** by two pointers:\\n\\nPython\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n        \\n\\t\\t# one points to head position, the other points to tail position\\n        left, right = 0, len(s)-1\\n        \\n\\t\\t# reverse string by two pointers\\n        while left < right:\\n            \\n            s[left], s[right] = s[right], s[left]\\n            \\n            left,right = left+1, right-1\\n```\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        // one points to head position, the other points to tail position\\n        size_t left = 0, right = s.size()-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            swap(s[left], s[right]);            \\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nGo:\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nfunc reverseString(s []byte)  {\\n    \\n    // one points to head position, the other points to tail position\\n    left, right := 0, len(s)-1\\n    \\n    // reverse string by two pointers\\n    for left < right{\\n        \\n        s[left], s[right] = s[right], s[left]\\n\\n        left,right = left+1, right-1\\n    }\\n    \\n    return\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nJava:\\n\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        // one points to head position, the other points to tail position\\n        int left = 0, right = s.length-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            char temp = s[left];\\n            s[left] = s[right];            \\n            s[right] = temp;\\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\\t\\n\\t\\n\\t\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nvar reverseString = function(s) {\\n    \\n    // one points to head position, the other points to tail position\\n    let [left, right] = [0, s.length-1];\\n    \\n    // reverse string by two pointers\\n    while( left < right ){\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        left += 1;\\n        right -= 1;\\n    }\\n     \\n    return;\\n};\\n```\\n\\n</details>\\n\\n\\n\\n---\\n\\n**Implementation** by recursion:\\n\\nPython\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n\\n        def helper( left:int, right:int, string: List[str]):     \\n            \\n            if left >= right:\\n                # base case\\n                return\\n            \\n            # general case\\n            s[left], s[right] = s[right], s[left]\\n            \\n            helper( left+1, right-1, s)\\n        # ------------------------------------------------\\n        \\n        helper( left = 0, right = len(s)-1, string = s)\\n```\\n\\n---\\n\\nC++\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        \\n        helper(0, s.size()-1, s);\\n        \\n        return;\\n    }\\n    \\nprivate:\\n    void helper(int left, int right, vector<char>& s){\\n        \\n        if( left > right ){\\n            // base case aka stop condition\\n            return ;\\n        }\\n        \\n        // general cases\\n        swap( s[left], s[right] );\\n        helper(left+1, right-1, s);\\n        \\n        return;\\n    }\\n    \\n};\\n```\\t\\n\\t\\n</details>\\n\\n---\\n\\nGo:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\nfunc reverseString(s []byte)  {\\n\\n    \\n    var helper func( int, int)\\n    \\n    helper = func( left int, right int){\\n    \\n        if left >= right{\\n            // base case aka stop condition\\n            return\\n        }\\n        \\n        // general case\\n        // swap character \\n        s[left], s[right] = s[right], s[left]\\n        \\n        helper(left+1, right-1)\\n        return\\n    }\\n    \\n    \\n    helper(0, len(s)-1)\\n    \\n    return\\n    \\n}\\n```\\t\\n\\t\\n</details>\\n\\n---\\n\\nJavascript:\\n\\n<details>\\n\\t<summary> Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\nvar reverseString = function(s) {\\n    \\n    function helper(left, right){\\n        \\n        // base case aka stop condition\\n        if( left >= right){      \\n            return;\\n        }\\n        \\n        // general cases\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        helper(left+1, right-1);\\n        return;\\n    };\\n     \\n    helper( left=0, right=s.length-1 );\\n    return;\\n};\\n```\\t\\n\\t\\n</details>\\n\\n\\n---",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n\\t\\t\\n\\t\\t# reverse string by mirror image\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        size_t n = s.size();\\n        \\n\\t\\t// reverse string by mirror image\\n        for( size_t i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            swap(s[i], s[n-1-i]);            \\n        }\\n        \\n        return;\\n    }\\n};\\n```\n```\\nfunc reverseString(s []byte)  {\\n    \\n    size := len(s)\\n    \\n    // reverse string by mirror image\\n    for i := 0 ; i < size/2 ; i++{\\n        s[i], s[size-1-i] = s[size-1-i], s[i]\\n    }\\n    \\n    return\\n    \\n}\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int n = s.length;\\n        \\n\\t\\t// reverse string by mirror image\\n        for( int i = 0; i < n/2 ; i ++){\\n\\t\\t\\n            char temp = s[i];\\n            s[i] = s[n-1-i];\\n            s[n-1-i] = temp;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\n```\\nvar reverseString = function(s) {\\n    \\n    let size = s.length;\\n    \\n    // reverse string by mirror image\\n    for(let i = 0 ; i < Math.floor(size/2) ; i++ ){\\n        [ s[i], s[size-1-i] ] = [ s[size-1-i], s[i] ] ;\\n    }\\n    \\n    return;\\n};\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n        \\n\\t\\t# one points to head position, the other points to tail position\\n        left, right = 0, len(s)-1\\n        \\n\\t\\t# reverse string by two pointers\\n        while left < right:\\n            \\n            s[left], s[right] = s[right], s[left]\\n            \\n            left,right = left+1, right-1\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        // one points to head position, the other points to tail position\\n        size_t left = 0, right = s.size()-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            swap(s[left], s[right]);            \\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n};\\n```\n```\\nfunc reverseString(s []byte)  {\\n    \\n    // one points to head position, the other points to tail position\\n    left, right := 0, len(s)-1\\n    \\n    // reverse string by two pointers\\n    for left < right{\\n        \\n        s[left], s[right] = s[right], s[left]\\n\\n        left,right = left+1, right-1\\n    }\\n    \\n    return\\n    \\n}\\n```\n```\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        // one points to head position, the other points to tail position\\n        int left = 0, right = s.length-1;\\n        \\n        // reverse string by two pointers\\n        while( left < right ){\\n            \\n            char temp = s[left];\\n            s[left] = s[right];            \\n            s[right] = temp;\\n            \\n            left += 1;\\n            right -= 1;\\n        }\\n        \\n        return;\\n    }\\n}\\n```\n```\\nvar reverseString = function(s) {\\n    \\n    // one points to head position, the other points to tail position\\n    let [left, right] = [0, s.length-1];\\n    \\n    // reverse string by two pointers\\n    while( left < right ){\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        left += 1;\\n        right -= 1;\\n    }\\n     \\n    return;\\n};\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:            \\n\\n        def helper( left:int, right:int, string: List[str]):     \\n            \\n            if left >= right:\\n                # base case\\n                return\\n            \\n            # general case\\n            s[left], s[right] = s[right], s[left]\\n            \\n            helper( left+1, right-1, s)\\n        # ------------------------------------------------\\n        \\n        helper( left = 0, right = len(s)-1, string = s)\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        \\n        helper(0, s.size()-1, s);\\n        \\n        return;\\n    }\\n    \\nprivate:\\n    void helper(int left, int right, vector<char>& s){\\n        \\n        if( left > right ){\\n            // base case aka stop condition\\n            return ;\\n        }\\n        \\n        // general cases\\n        swap( s[left], s[right] );\\n        helper(left+1, right-1, s);\\n        \\n        return;\\n    }\\n    \\n};\\n```\n```\\n\\nfunc reverseString(s []byte)  {\\n\\n    \\n    var helper func( int, int)\\n    \\n    helper = func( left int, right int){\\n    \\n        if left >= right{\\n            // base case aka stop condition\\n            return\\n        }\\n        \\n        // general case\\n        // swap character \\n        s[left], s[right] = s[right], s[left]\\n        \\n        helper(left+1, right-1)\\n        return\\n    }\\n    \\n    \\n    helper(0, len(s)-1)\\n    \\n    return\\n    \\n}\\n```\n```\\n\\nvar reverseString = function(s) {\\n    \\n    function helper(left, right){\\n        \\n        // base case aka stop condition\\n        if( left >= right){      \\n            return;\\n        }\\n        \\n        // general cases\\n        [ s[left], s[right] ] = [ s[right], s[left] ];\\n        \\n        helper(left+1, right-1);\\n        return;\\n    };\\n     \\n    helper( left=0, right=s.length-1 );\\n    return;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901752,
                "title": "c-two-lines-wow-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use here two pointers that gives us access to characters for swapping in left and right side of the string. For swapping we use a convinient C++ method [swap](https://www.cplusplus.com/reference/algorithm/swap/). We just iterate over characters and swap them.\\n\\nTime: **O(n)**\\nSpace: **O(1)**\\n\\nRuntime: 24 ms, faster than **76.05%** of C++ online submissions for Reverse String.\\nMemory Usage: 23.3 MB, less than **41.72%** of C++ online submissions for Reverse String.\\n\\n```\\nvoid reverseString(vector<char>& s) {\\n\\tint i = 0, j = s.size() - 1;\\n\\twhile (i < j) swap(s[i++], s[j--]);\\n}\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverseString(vector<char>& s) {\\n\\tint i = 0, j = s.size() - 1;\\n\\twhile (i < j) swap(s[i++], s[j--]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794541,
                "title": "easy-to-understand-recursive-approach-c",
                "content": "In recursion, we just need to take care of 2 things i.e.\\n1. Base Condition\\n2. A relation or a formula that can divide a big problem into small subproblem of same type\\n\\nRest other things we don\\'t have to bother about, it wil be taken care by recursion.\\nSo here\\'s my recursive solution\\n```\\nclass Solution {\\npublic:\\n    void rev(vector<char>& s, int left, int right)\\n    {\\n        if(left>=right)                             // Base Condition\\n            return;\\n        swap(s[left++],s[right--]);                 // makes the problem smaller of same type            \\n        rev(s,left,right);\\n    }\\n    void reverseString(vector<char>& s) {\\n        rev(s,0,s.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rev(vector<char>& s, int left, int right)\\n    {\\n        if(left>=right)                             // Base Condition\\n            return;\\n        swap(s[left++],s[right--]);                 // makes the problem smaller of same type            \\n        rev(s,left,right);\\n    }\\n    void reverseString(vector<char>& s) {\\n        rev(s,0,s.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279927,
                "title": "es6-destructuring-assignment",
                "content": "Leverage ES6 Destructuring assignment - https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n  let i = 0, j = s.length - 1;\\n  while (i < j) {\\n    // ES6 destructuring assignment\\n    [s[i], s[j]] = [s[j], s[i]];\\n    i++;\\n    j--;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n  let i = 0, j = s.length - 1;\\n  while (i < j) {\\n    // ES6 destructuring assignment\\n    [s[i], s[j]] = [s[j], s[i]];\\n    i++;\\n    j--;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718521,
                "title": "easy-solution-with-simple-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nWe want to reverse a character array in place, meaning we cannot use any additional memory like creating a new array.\\nTo achieve this, we will use the two-pointer approach, where we place two pointers, i and j, at the two ends of the array. We\\'ll swap the characters at these pointers to reverse the array.\\n# Approach\\n1. We will use two pointers, i and j, initialized to the start and end of the array, respectively.\\n1. While i is less than j, we will perform the following steps:\\n- Swap the characters at positions i and j.\\n- Move i one step forward (towards the middle) by incrementing it.\\n- Move j one step backward (towards the middle) by decrementing it.\\n- We keep repeating the above steps until i is less than or equal to j. When i becomes equal to or greater than j, the whole array will be reversed.\\n# Complexity\\n- Time complexity:\\nThe two-pointer approach runs in linear time $$O(N)$$, where N is the length of the character array. This is because each element is swapped at most once.\\n\\n- Space complexity:\\nThe space complexity is constant $$O(1)$$ because we are not using any additional memory that grows with the input size. We are modifying the given array in place.\\n# Code\\n```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        // Iterate from the beginning (i) and end (j) of the array towards the middle.\\n        for (int i = 0, j = s.length - 1; i < s.length / 2; i++, j--) {\\n            // Use a temporary variable (temp) to store the character at index i.\\n            char temp = s[i];\\n\\n            // Replace the character at index i with the character at index j.\\n            s[i] = s[j];\\n\\n            // Replace the character at index j with the character in the temporary variable (temp).\\n            s[j] = temp;\\n        } \\n        // At this point, the character array \\'s\\' contains the reversed string.\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        # Two pointers, i pointing to the start and j pointing to the end of the list\\n        i = 0\\n        j = len(s) - 1\\n\\n        while i < j:\\n            # Swap the characters at positions i and j\\n            s[i], s[j] = s[j], s[i]\\n\\n            # Move i one step forward and j one step backward\\n            i += 1\\n            j -= 1\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        // Two pointers, i pointing to the start and j pointing to the end of the vector\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            // Swap the characters at positions i and j\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n\\n            // Move i one step forward and j one step backward\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```\\n## ***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/43b7b8c2-a65b-425a-a9fe-3b558ba3e7e2_1688491323.1367128.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Two Pointers",
                    "String"
                ],
                "code": "```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        // Iterate from the beginning (i) and end (j) of the array towards the middle.\\n        for (int i = 0, j = s.length - 1; i < s.length / 2; i++, j--) {\\n            // Use a temporary variable (temp) to store the character at index i.\\n            char temp = s[i];\\n\\n            // Replace the character at index i with the character at index j.\\n            s[i] = s[j];\\n\\n            // Replace the character at index j with the character in the temporary variable (temp).\\n            s[j] = temp;\\n        } \\n        // At this point, the character array \\'s\\' contains the reversed string.\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        # Two pointers, i pointing to the start and j pointing to the end of the list\\n        i = 0\\n        j = len(s) - 1\\n\\n        while i < j:\\n            # Swap the characters at positions i and j\\n            s[i], s[j] = s[j], s[i]\\n\\n            # Move i one step forward and j one step backward\\n            i += 1\\n            j -= 1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        // Two pointers, i pointing to the start and j pointing to the end of the vector\\n        int i = 0;\\n        int j = s.size() - 1;\\n\\n        while (i < j) {\\n            // Swap the characters at positions i and j\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n\\n            // Move i one step forward and j one step backward\\n            i++;\\n            j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232381,
                "title": "c-easy-to-understand-iterative",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)**\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        vector<char> vec;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            vec.push_back(s[i]);\\n        }\\n        s=vec;\\n    }\\n};\\n**In a similar way you may also use a stack to solve the given problem**\\n\\n**Two pointers approach(more space efficient)**\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n       int start=0,e=s.size()-1;\\n        while(start<e)\\n        {\\n            swap(s[start],s[e]);\\n            start++;\\n            e--;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        vector<char> vec;\\n        for(int i=s.size()-1;i>=0;i--)\\n        {\\n            vec.push_back(s[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 275116,
                "title": "java-simple-multiple-solutions-w-explanations",
                "content": "Interesting ways to do this problem!!!\\n\\n\\nSolution 1:  1ms\\n-Correct way of doing this. Modifying the input array in-place with O(1) extra memory.\\n```\\n    public void reverseString(char[] s) {\\n        for(int i=0; i<s.length/2; i++){    //Do it half the number of String length\\n            char tmp = s[i];\\n            s[i] = s[s.length-1-i];     //Front swap with other End side \\n            s[s.length-1-i] = tmp;      //End swap with other Front side\\n        }\\n    }\\n```\\n\\n\\nSolution 2: 400ms\\n-If you have no idea how to do this correctly and you just gota try something.\\n```\\n    public void reverseString(char[] s) {\\n        String str = \"\";                   //Allocate extra space\\n        \\n        for(int i=s.length-1; i>=0; i--)   /*Add to extra space from rear to front */\\n            str += s[i];\\n        \\n        for(int i=0; i<s.length; i++)      /*Set reversed \\'str\\' into char array \\'s\\' */\\n            s[i] = str.charAt(i);\\n    }\\n```\\n\\nSolution 3:\\n-You said you control the interview.\\n```\\n new StringBuilder(s).reverse().toString();\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public void reverseString(char[] s) {\\n        for(int i=0; i<s.length/2; i++){    //Do it half the number of String length\\n            char tmp = s[i];\\n            s[i] = s[s.length-1-i];     //Front swap with other End side \\n            s[s.length-1-i] = tmp;      //End swap with other Front side\\n        }\\n    }\\n```\n```\\n    public void reverseString(char[] s) {\\n        String str = \"\";                   //Allocate extra space\\n        \\n        for(int i=s.length-1; i>=0; i--)   /*Add to extra space from rear to front */\\n            str += s[i];\\n        \\n        for(int i=0; i<s.length; i++)      /*Set reversed \\'str\\' into char array \\'s\\' */\\n            s[i] = str.charAt(i);\\n    }\\n```\n```\\n new StringBuilder(s).reverse().toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164959,
                "title": "two-javascript-solutions-with-detailed-explanation-two-pointers-native-functions-and-bad-examples",
                "content": "Here are my two solutions for this question.\\n\\n*-- edit --*\\nSince the question mutated from \"reverse immutable string\" into \"reverse array of characters\", **\"Bad solution 1\" is now the best answer**. In programming best practices can sometimes mutate into anti-patterns, but this is the first time for me when an anti-pattern mutated into the best solution.\\n*-- end of edit --*\\n\\n**Native functions**\\nThis approach uses native javascript functions to make the code very short and easy to read.\\n\\n```\\nlet reverseString = function(s) {\\n    return s.split(\\'\\').reverse().join(\\'\\');\\n};\\n```\\n\\nWhat we did there:\\nFirst, we split a string into array of characters. Since we provide empty string as divider, the entire string is split into array elements, every character becomes a separate element. Next, we apply Array.prototype method `reverse()`, which, as the name implies, reverses the contents of an array. Then we simply join the array back into a string without any divider (using empty string `\\'\\'` as element divider).\\n\\nTime and space complexity are unknown because we\\'re using built-in language functions instead of writing our own super-efficient code. You can google on time and space complexity of these functions if you *must* know.\\n\\n**Two pointers approach**\\nWe can do this using two pointer approach to reduce the number of times we \"run\" this script against array by half:\\n\\n```\\nlet reverseString = function(s) {\\n    let arr = s.split(\\'\\'), left = 0, right = arr.length - 1;\\n    while (left < right) {\\n        let temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return arr.join(\\'\\');\\n};\\n```\\n\\nThis approach is fairly straightforward:\\nFirst, declare two pointers, left and right. Then iterate over the array, one pointer looking at the front of the array, another looking at the rear. As long as left is smaller than right, swap elements in place. When pointers meet or cross, you\\'re done.\\n\\nTime complexity: O(n)\\nSpace complexity: O(n). We create a separate array based on input string, number of elements in array matches the number of characters in the string.\\n\\n**Bad examples**\\nHere are two more solutions you should not use.\\n1. Assume strings can be manipulated directly, like an array (since you can access string elements by index). Example:\\n```\\nlet reverseString = function(s) {\\n    let left = 0, right = s.length - 1;\\n    while (left < right) {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return s;\\n};\\n```\\n**In Javascript** strings are immutable (this depends on programming language), which means string is like an array in the meaning you can access its elements by index. But it does not allow manipulating individual elements at individual indexes. If you try this in \\'normal\\' mode, it fill fail silently (it will execute but string won\\'t be modified and you\\'ll never know why). If you use strict mode via `\\'use strict\\';`, it will fail with the following error:\\n`TypeError: Cannot assign to read only property \\'0\\' of string \\'hello\\'`\\n\\nVerdict of the story: you should **always** use strict mode.\\n\\n2. Try to work around the problem of immutable strings by \\'concatenating\\' strings at each step of a loop, like this:\\n\\n```\\nvar reverseString = function(s) {\\n    let res = \"\";\\n    for(let i = s.length - 1; i >= 0; i --){\\n        res += s[i];\\n    }\\n    return res;\\n};\\n```\\n\\nCode source:\\nhttps://leetcode.com/problems/reverse-string/discuss/164660/javascript-solution\\n\\nThis approach will work and won\\'t crash (not immediately, at least). The problem of this approach is that it will use a ton of space (`O(n!)`, I believe, which is pretty **bad**) instead of `O(n)` one would expect.\\n\\n*Why this happens*: since strings are immutable, you\\'ll be creating a new string at each step of the loop, each string will be as long as previous string + 1 element. This means we\\'re effectively creating and discarding O(n) strings, each of which ranges from `O(1)` to `O(n)` in space, effectively means we\\'re **wasting** (touching, garbaging) `O(n!)` space even though it seems we only use `O(n)` space at any one moment. All those strings should be garbage-collected at some point, which will affect performance. For smaller strings and smaller programs the effect will be minimal, but for large-scale applications this could create bottlenecks at some point.\\n\\nHopefully you find this information useful :)\\n\\nP.S.: all examples will only work with strings that fit into memory. If your string doesn\\'t fit into memory (large files, multiple gigabytes each, will not fit into the memory of a small virtual machine in AWS cluster, for example), you have to create a different approach. For example: create a number of files, each containing a portion of the reversed string and save them with some index. Then process file array from the end, streaming file contents into the resulting file.\\n\\nIf you know a better approach of reversing huge files, please do let me know.",
                "solutionTags": [],
                "code": "```\\nlet reverseString = function(s) {\\n    return s.split(\\'\\').reverse().join(\\'\\');\\n};\\n```\n```\\nlet reverseString = function(s) {\\n    let arr = s.split(\\'\\'), left = 0, right = arr.length - 1;\\n    while (left < right) {\\n        let temp = arr[left];\\n        arr[left] = arr[right];\\n        arr[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return arr.join(\\'\\');\\n};\\n```\n```\\nlet reverseString = function(s) {\\n    let left = 0, right = s.length - 1;\\n    while (left < right) {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        ++left;\\n        --right;\\n    }\\n    return s;\\n};\\n```\n```\\nvar reverseString = function(s) {\\n    let res = \"\";\\n    for(let i = s.length - 1; i >= 0; i --){\\n        res += s[i];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81156,
                "title": "c-solution-sharing",
                "content": "    char* reverseString(char* s) {\\n     int l = 0;\\n     int r = strlen(s)-1;\\n     char c;\\n     \\n     while(l<r)\\n     {\\n         // swap chars\\n         c = s[l];\\n         s[l] = s[r];\\n         s[r] = c;\\n         l++;\\n         r--;\\n     }\\n     \\n     return s;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "    char* reverseString(char* s) {\\n     int l = 0;\\n     int r = strlen(s)-1;\\n     char c;\\n     \\n     while(l<r)\\n     {\\n         // swap chars\\n         c = s[l];\\n         s[l] = s[r];\\n         s[r] = c;\\n         l++;\\n         r--;\\n     }\\n     \\n     return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 80961,
                "title": "python-solution",
                "content": " Python:\\n\\n       class Solution(object):\\n            def reverseString(self, s):\\n                \"\"\"\\n                :type s: str\\n                :rtype: str\\n                \"\"\"\\n                return s[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": " Python:\\n\\n       class Solution(object):\\n            def reverseString(self, s):\\n                \"\"\"\\n                :type s: str\\n                :rtype: str\\n                \"\"\"\\n                return s[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 995210,
                "title": "java-4-line-solution",
                "content": "```\\npublic void reverseString(char[] s) {\\n        for(int i = 0, j = s.length- 1 ; i < j ; i++,j--){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void reverseString(char[] s) {\\n        for(int i = 0, j = s.length- 1 ; i < j ; i++,j--){\\n            char temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 480217,
                "title": "js-2-pointer-technique-2-liner",
                "content": "### 2 pointer technique with iteration\\n- Time complexity: **O(N)**\\n- Space complexity: **O(1)**\\n\\n```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = (s) => {\\n    for (let [a, b] = [0, s.length - 1]; a < b; a++, b--) {\\n        [s[a], s[b]] = [s[b], s[a]]\\n    }\\n};\\n```\\n### 2 pointer technique with recursion\\n- Time complexity: **O(N)**\\n- Space complexity: **O(N)**\\n```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = s => {\\n    reverse(0, s.length - 1);\\n\\n    /**\\n     * @param {character[]} s\\n     * @return {void} Do not return anything, modify s in-place instead.\\n     */\\n    function reverse(i, j) {\\n        if (i >= j) return;\\n        [s[i], s[j]] = [s[j], s[i]];\\n        reverse(i + 1, j - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = (s) => {\\n    for (let [a, b] = [0, s.length - 1]; a < b; a++, b--) {\\n        [s[a], s[b]] = [s[b], s[a]]\\n    }\\n};\\n```\n```JavaScript\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = s => {\\n    reverse(0, s.length - 1);\\n\\n    /**\\n     * @param {character[]} s\\n     * @return {void} Do not return anything, modify s in-place instead.\\n     */\\n    function reverse(i, j) {\\n        if (i >= j) return;\\n        [s[i], s[j]] = [s[j], s[i]];\\n        reverse(i + 1, j - 1);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81063,
                "title": "java-easiest-method-2-line-code-attached-another-method",
                "content": "   \\n\\n    //method 1: use StringBuilder\\n        public String reverseString(String s) {\\n            StringBuilder sb = new StringBuilder(s);\\n            return sb.reverse().toString();\\n        }\\n    \\n        //method 2: use swap method\\n        public String reverseString(String s){\\n            if(s == null || s.length() == 0)\\n                return \"\";\\n            char[] cs = s.toCharArray();\\n            int begin = 0, end = s.length() - 1;\\n            while(begin <= end){\\n                char c = cs[begin];\\n                cs[begin] = cs[end];\\n                cs[end] = c;\\n                begin++;\\n                end--;\\n            }\\n            \\n            return new String(cs);\\n        }",
                "solutionTags": [],
                "code": "   \\n\\n    //method 1: use StringBuilder\\n        public String reverseString(String s) {\\n            StringBuilder sb = new StringBuilder(s);\\n            return sb.reverse().toString();\\n        }\\n    \\n        //method 2: use swap method\\n        public String reverseString(String s){\\n            if(s == null || s.length() == 0)\\n                return \"\";\\n            char[] cs = s.toCharArray();\\n            int begin = 0, end = s.length() - 1;\\n            while(begin <= end){\\n                char c = cs[begin];\\n                cs[begin] = cs[end];\\n                cs[end] = c;\\n                begin++;\\n                end--;\\n            }\\n            \\n            return new String(cs);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1902265,
                "title": "simple-clear-easy-understanding",
                "content": "```\\nvar reverseString = function(s) {\\n    \\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left <= right) {\\n    [s[left],s[right]] = [s[right],s[left]]\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```\\n**PLEASE UPVOTE!**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    \\n  let left = 0;\\n  let right = s.length - 1;\\n\\n  while (left <= right) {\\n    [s[left],s[right]] = [s[right],s[left]]\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 81199,
                "title": "python-one-line-solution",
                "content": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            return s[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            return s[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 3194987,
                "title": "python-two-pointer-clean-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n    Loop goes until n/2 but we represent $$O(n/2)$$ to $$O(n)$$. \\nHence TC is $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        # Two Pointer\\n        l, r =0, len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l += 1\\n            r -= 1\\n```\\n\\nSimply you can use for loop like below :\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        for i in range(n // 2):\\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        # Two Pointer\\n        l, r =0, len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l += 1\\n            r -= 1\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        for i in range(n // 2):\\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2681103,
                "title": "js-es6-two-pointers-with-explanation",
                "content": "Two pointers is the use of two different pointers (usually to keep track of array or string indexes) to solve a problem with specified indexes in order to save time and space.\\n\\nTo solve this problem, we just need to steps by indices from both ends, and swap them until the indices meet in the middle.\\n\\nI hope the picture below will give you a clearer understanding :)\\n\\n![image](https://assets.leetcode.com/users/images/f8dfebd6-5f46-4ffa-8071-7b4d0c6c94ba_1665314490.753274.png)\\n\\n\\n```\\nvar reverseString = function(s) {\\n    for (let i = 0, j = s.length - 1; i < j;) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    for (let i = 0, j = s.length - 1; i < j;) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2998802,
                "title": "c-java-c-python-simple-solutions-easy-to-understand-two-pointers",
                "content": "# Frequently encountered in technical interviews\\n```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 6},\\n    {\"Microsoft\", 5},\\n    {\"Adobe\", 5},\\n    {\"Facebook\", 3},\\n    {\"tcs\", 3},\\n    {\"Apple\", 2},\\n    {\"Intel\", 2}\\n};\\n```\\n\\n# Solution\\n\\n```C++ []\\n// 1. Using Stack\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++) st.push(s[i]);\\n        s.clear();\\n        while(!st.empty()) {\\n            s.push_back(st.top());\\n            st.pop();\\n        }\\n    }\\n};\\n// 2. Recursion\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j = s.size() - 1;\\n        swapImp(s, i, j); \\n    }\\n    void swapImp(vector<char>& s,int i,int j){\\n        if(i >= j) return;\\n        s[i] ^= s[j];\\n        s[j] ^= s[i];\\n        s[i] ^= s[j];\\n        swapImp(s, ++i, --j);\\n    }\\n};\\n// 3. Two Pointers\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0, j = s.size()-1;\\n        while (i < j) \\n            swap(s[i++], s[j--]); \\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length-1;\\n        while (i<j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\\n```csharp []\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        int i = 0;\\n        int j = s.Length-1;\\n        while (i < j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        i = 0\\n        j = len(s) - 1\\n        while (i < j):\\n            temp = s[i]\\n            s[i] = s[j]\\n            s[j] = temp\\n            i += 1\\n            j -= 1\\n        return s\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C#",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nstd::vector<std::pair<std::string, int>> interview_frequency= {\\n    {\"Amazon\", 6},\\n    {\"Microsoft\", 5},\\n    {\"Adobe\", 5},\\n    {\"Facebook\", 3},\\n    {\"tcs\", 3},\\n    {\"Apple\", 2},\\n    {\"Intel\", 2}\\n};\\n```\n```C++ []\\n// 1. Using Stack\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> st;\\n        for(int i=0; i<s.size(); i++) st.push(s[i]);\\n        s.clear();\\n        while(!st.empty()) {\\n            s.push_back(st.top());\\n            st.pop();\\n        }\\n    }\\n};\\n// 2. Recursion\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j = s.size() - 1;\\n        swapImp(s, i, j); \\n    }\\n    void swapImp(vector<char>& s,int i,int j){\\n        if(i >= j) return;\\n        s[i] ^= s[j];\\n        s[j] ^= s[i];\\n        s[i] ^= s[j];\\n        swapImp(s, ++i, --j);\\n    }\\n};\\n// 3. Two Pointers\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0, j = s.size()-1;\\n        while (i < j) \\n            swap(s[i++], s[j--]); \\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i = 0;\\n        int j = s.length-1;\\n        while (i<j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\n```csharp []\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        int i = 0;\\n        int j = s.Length-1;\\n        while (i < j) {\\n            char temp = s[i];\\n            s[i++] = s[j];\\n            s[j--] = temp;\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution(object):\\n    def reverseString(self, s):\\n        i = 0\\n        j = len(s) - 1\\n        while (i < j):\\n            temp = s[i]\\n            s[i] = s[j]\\n            s[j] = temp\\n            i += 1\\n            j -= 1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81152,
                "title": "python-recursive-solution",
                "content": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            if len(s)<=1:\\n                return s\\n            n=len(s)\\n            return self.reverseString(s[n//2:])+self.reverseString(s[:n//2])",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def reverseString(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: str\\n            \"\"\"\\n            if len(s)<=1:\\n                return s\\n            n=len(s)\\n            return self.reverseString(s[n//2:])+self.reverseString(s[:n//2])",
                "codeTag": "Java"
            },
            {
                "id": 302693,
                "title": "c-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start = 0, end = s.size() - 1;    \\n        \\n        revStr(s, start, end);\\n    }\\n    \\n    void revStr(vector<char>& s, int start, int end){\\n        \\n        if(start >= end) return;\\n        int temp = s[start];\\n        s[start] = s[end];\\n        s[end] = temp;\\n        \\n        revStr(s, start+1, end-1);\\n    }\\n    \\n    \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start = 0, end = s.size() - 1;    \\n        \\n        revStr(s, start, end);\\n    }\\n    \\n    void revStr(vector<char>& s, int start, int end){\\n        \\n        if(start >= end) return;\\n        int temp = s[start];\\n        s[start] = s[end];\\n        s[end] = temp;\\n        \\n        revStr(s, start+1, end-1);\\n    }\\n    \\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81206,
                "title": "java-swapping-char-array",
                "content": "    public String reverseString(String s) {\\n            char[] c = s.toCharArray();\\n            for (int i=0,j=c.length-1;i<j;i++,j--){\\n                char temp = c[i];\\n                c[i]=c[j];\\n                c[j]=temp;\\n            }\\n            return new String(c);\\n        }",
                "solutionTags": [],
                "code": "    public String reverseString(String s) {\\n            char[] c = s.toCharArray();\\n            for (int i=0,j=c.length-1;i<j;i++,j--){\\n                char temp = c[i];\\n                c[i]=c[j];\\n                c[j]=temp;\\n            }\\n            return new String(c);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1902296,
                "title": "reverse-string-one-liner-python-solution",
                "content": "Write a function that reverses a string. The input string is given as an array of characters s.\\nYou must do this by modifying the input array in-place with O(1) extra memory.\\n\\nExample 1:\\n```\\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n```\\n\\nExample 2:\\n\\n```\\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\\n```\\nConstraints:\\n1 <= s.length <= 105\\ns[i] is a printable ascii character.\\n\\n**Python Code**\\n\\n```\\nclass Solution:\\n    def reverseString(self, s):\\n        s.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n```\n```\\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\\n```\n```\\nclass Solution:\\n    def reverseString(self, s):\\n        s.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901942,
                "title": "multiple-c-solutions-with-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re using ***Extra Space*** which doesn\\'t satisfy the condition.\\n- We iterate the array elements from last and push it to the current vector.\\n- Then we\\u2019ll erase the first n elements from the vector and will get out the reverse string.\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- Here we\\u2019re using the ***Two Pointer Approach.***\\n- We\\u2019ll use the swap function which takes O(1) time complexity.\\n- Take 2 pointers to start & end, swap them and move the pointer.\\n- **Time complexity:** O(n).\\n\\n### Solution 03\\n\\n- Here we\\u2019re using ***STL function*** reverse which takes O(n) time complexity.\\n- **Time complexity:** O(n).\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    \\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=n-1; i>=0; i--){\\n            s.push_back(s[i]);\\n        }\\n        s.erase(s.begin(), s.begin()+n);\\n        return;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int low = 0, high = n-1;\\n        \\n        while(low <= high){\\n            swap(s[low], s[high]);\\n            low++; high--;\\n        }\\n        return;\\n    }\\n};\\n\\n//Solution 03:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(), s.end());\\n        return;\\n    }\\n};\\n```\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    \\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=n-1; i>=0; i--){\\n            s.push_back(s[i]);\\n        }\\n        s.erase(s.begin(), s.begin()+n);\\n        return;\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int low = 0, high = n-1;\\n        \\n        while(low <= high){\\n            swap(s[low], s[high]);\\n            low++; high--;\\n        }\\n        return;\\n    }\\n};\\n\\n//Solution 03:\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(), s.end());\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1555808,
                "title": "java-tc-o-n-sc-o-1-simple-concise-3-diff-solutions-iterative-recursive",
                "content": "**Swap each character. Using XOR**\\n```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            s[left] = (char) (s[left] ^ s[right]);\\n            s[right] = (char) (s[left] ^ s[right]);\\n            s[left] = (char) (s[left] ^ s[right]);\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Swap each character. Using a temporay character**\\n\\n```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char c = s[left];\\n            s[left] = s[right];\\n            s[right] = c;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n---\\n**Recursive Solution**\\n```java\\n/**\\n * Recursive Solution\\n *\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(N/2) = O(N)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        reverseStringHelper(s, 0, s.length - 1);\\n    }\\n\\n    private void reverseStringHelper(char[] s, int left, int right) {\\n        if (left >= right) {\\n            return;\\n        }\\n        s[left] = (char) (s[left] ^ s[right]);\\n        s[right] = (char) (s[left] ^ s[right]);\\n        s[left] = (char) (s[left] ^ s[right]);\\n        reverseStringHelper(s, left + 1, right - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            s[left] = (char) (s[left] ^ s[right]);\\n            s[right] = (char) (s[left] ^ s[right]);\\n            s[left] = (char) (s[left] ^ s[right]);\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char c = s[left];\\n            s[left] = s[right];\\n            s[right] = c;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * Recursive Solution\\n *\\n * Time Complexity: O(N/2) = O(N)\\n *\\n * Space Complexity: O(N/2) = O(N)\\n *\\n * N = Length of input char array.\\n */\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        reverseStringHelper(s, 0, s.length - 1);\\n    }\\n\\n    private void reverseStringHelper(char[] s, int left, int right) {\\n        if (left >= right) {\\n            return;\\n        }\\n        s[left] = (char) (s[left] ^ s[right]);\\n        s[right] = (char) (s[left] ^ s[right]);\\n        s[left] = (char) (s[left] ^ s[right]);\\n        reverseStringHelper(s, left + 1, right - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524631,
                "title": "java-recursive-solution",
                "content": "```\\npublic void reverseString(char[] s) {\\n        solve(s, 0, s.length-1);  \\n    }\\n    \\n    public void solve(char[] s, int start, int end){\\n        if(start>=end)return; //base case\\n        swap(s, start, end);\\n        solve(s, ++start, --end);\\n    }\\n    \\n    public void swap(char[] s, int i, int j){\\n        char tmp = s[i];\\n        s[i] = s[j];\\n        s[j] = tmp;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic void reverseString(char[] s) {\\n        solve(s, 0, s.length-1);  \\n    }\\n    \\n    public void solve(char[] s, int start, int end){\\n        if(start>=end)return; //base case\\n        swap(s, start, end);\\n        solve(s, ++start, --end);\\n    }\\n    \\n    public void swap(char[] s, int i, int j){\\n        char tmp = s[i];\\n        s[i] = s[j];\\n        s[j] = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 797426,
                "title": "c-single-pointer-recursive-vs-iterative-solutions-explained-100-time-70-space",
                "content": "I don\\'t really think this problem was ideal to teach recursion, but I guess it is still a worthy exercise to go both ways (recursive and iterative), so let\\'s give it a look.\\n\\nWe just need one pointer `pos` to progress (although with 2 you do a bit less computation), ideally starting from the left (easier) and then computing its specular equivalent as `s.size() - 1 - pos`; our base case is that `pos` has reached half the size of the string, in which case we exit. Otherwise, we keep swapping the values of our 2 chars.\\n\\nThe recursive version:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos < s.size() / 2) {\\n            swap(s[pos], s[s.size() - 1 - pos]);\\n            reverseString(s, pos + 1);\\n        }\\n    }\\n};\\n```\\n\\nAnother alternative recursive version doing basically the same:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos >= s.size() / 2) return;\\n        swap(s[pos], s[s.size() - 1 - pos]);\\n        reverseString(s, pos + 1);\\n    }\\n};\\n```\\n\\nThe translation of the problem to an iterative approach, which for once appears shorter, if you use the trick of declaring variables as parameters:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        while (pos < s.size() / 2) swap(s[pos], s[s.size() - 1 - pos++]);\\n    }\\n};\\n```\\n\\nFinally, the real solution I would use outside of any interview context:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(begin(s), end(s));\\n    }\\n};\\n```\\n\\nBecause well tested, reliable and sturdy built-in are there to use for a reason!",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos < s.size() / 2) {\\n            swap(s[pos], s[s.size() - 1 - pos]);\\n            reverseString(s, pos + 1);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        if (pos >= s.size() / 2) return;\\n        swap(s[pos], s[s.size() - 1 - pos]);\\n        reverseString(s, pos + 1);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s, int pos = 0) {\\n        while (pos < s.size() / 2) swap(s[pos], s[s.size() - 1 - pos++]);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(begin(s), end(s));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 402685,
                "title": "javascript-es6",
                "content": "```\\nvar reverseString = function(s) {\\n    var i = 0;\\n    var j = s.length - 1;\\n    while (i < j) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n};\\n```\\nUsing destructuring assignment array matching available in ES6+ though not very effecient.",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n    var i = 0;\\n    var j = s.length - 1;\\n    while (i < j) {\\n        [s[i], s[j]] = [s[j], s[i]];\\n        i++;\\n        j--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3222200,
                "title": "js-basic-two-pointers-decision-easy-to-read-and-understand",
                "content": "![photo_5456553622704865185_y.jpg](https://assets.leetcode.com/users/images/a8e77441-ef53-4ff7-bec1-818615746890_1677166190.006001.jpeg)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    while(left <= right) {\\n        let temp = s[left]\\n        s[left] = s[right]\\n        s[right] = temp\\n        left++\\n        right--\\n    }\\n\\n    return s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0\\n    let right = s.length - 1\\n    while(left <= right) {\\n        let temp = s[left]\\n        s[left] = s[right]\\n        s[right] = temp\\n        left++\\n        right--\\n    }\\n\\n    return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2645839,
                "title": "python-faster-than-93-two-pointer",
                "content": "```\\n\"\"\"https://leetcode.com/problems/reverse-string/\"\"\"\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 207 ms, faster than 93.06% of Python3 online submissions for Reverse String.\\n    # Memory Usage: 18.4 MB, less than 82.79% of Python3 online submissions for Reverse String.\\n    \\n# EXPLANATION:-\\n    # We will use two pointers, one from start and one from end\\n    # We will swap the chars and increment the left and decrement the right\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/reverse-string/\"\"\"\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l=0\\n        r=len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n        \\n# SUBMISSION REPORT:-\\n    # Runtime: 207 ms, faster than 93.06% of Python3 online submissions for Reverse String.\\n    # Memory Usage: 18.4 MB, less than 82.79% of Python3 online submissions for Reverse String.\\n    \\n# EXPLANATION:-\\n    # We will use two pointers, one from start and one from end\\n    # We will swap the chars and increment the left and decrement the right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072607,
                "title": "javascript-two-pointer",
                "content": "var reverseString = function(s) {\\n   \\n    let pointer1 = 0;\\n    let pointer2 = s.length-1;\\n    \\n    while(pointer1<pointer2){\\n        \\n        let temp=s[pointer1];\\n        s[pointer1]=s[pointer2];\\n        s[pointer2]=temp;\\n        \\n        pointer1++;\\n        pointer2--;\\n    }\\n    \\n    return s;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "var reverseString = function(s) {\\n   \\n    let pointer1 = 0;\\n    let pointer2 = s.length-1;\\n    \\n    while(pointer1<pointer2){\\n        \\n        let temp=s[pointer1];\\n        s[pointer1]=s[pointer2];\\n        s[pointer2]=temp;\\n        \\n        pointer1++;\\n        pointer2--;\\n    }\\n    \\n    return s;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 80981,
                "title": "three-ways-to-reverse-a-string-in-javascript",
                "content": "    var reverseString = function(s) {\\n       //solution 1 \\n       var reversedStr = \"\";\\n        var high = s.length - 1;\\n        var i;\\n        for(i = high; i >= 0; i--) {\\n            reversedStr += s.charAt(i);\\n        }\\n        return reversedStr;\\n        \\n        /*solution2 with built-in function\\n        return s.split('').reverse().join('');*/\\n        \\n        /*recursion with substr and charAt, will have runtime error\\n        return (s === '') ? '' : reverseString(s.substr(1)) + s.charAt(0);*/\\n    };",
                "solutionTags": [],
                "code": "    var reverseString = function(s) {\\n       //solution 1 \\n       var reversedStr = \"\";\\n        var high = s.length - 1;\\n        var i;\\n        for(i = high; i >= 0; i--) {\\n            reversedStr += s.charAt(i);\\n        }\\n        return reversedStr;\\n        \\n        /*solution2 with built-in function\\n        return s.split('').reverse().join('');*/\\n        \\n        /*recursion with substr and charAt, will have runtime error\\n        return (s === '') ? '' : reverseString(s.substr(1)) + s.charAt(0);*/\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 2722427,
                "title": "easy-c-code-beats-98-in-time",
                "content": "## My GitHub: https://github.com/crimsonKn1ght\\n\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while (i<j) {\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n\\n*If this code helps, please upvote it, it encourages me to write more solutions*\\n",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while (i<j) {\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617193,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        sLen = len(s)\\n        for i in range(sLen//2):\\n            #swap is awesome in python\\n            s[i], s[sLen-1-i] = s[sLen-1-i], s[i]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        sLen = len(s)\\n        for i in range(sLen//2):\\n            #swap is awesome in python\\n            s[i], s[sLen-1-i] = s[sLen-1-i], s[i]",
                "codeTag": "Java"
            },
            {
                "id": 1480872,
                "title": "python-and-java-one-line-iterative-recursive-solutions",
                "content": "## PYTHON SOLUTIONS\\n##\\nOne line solution using python\\'s handy functions\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```\\n\\nIterative Approach\\n```\\nclass Solution:\\n\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\tN = len(s)\\n\\t\\tfor i in range(N // 2):\\n\\t\\t\\ts[i], s[-i-1] == s[-i-1], s[i]\\n```\\n\\nRecursive Approach\\n```\\nclass Solution:\\n    def reverse(self, l, r, s):\\n        if l >= r:\\n            return\\n        s[l], s[r] = s[r], s[l]\\n        self.reverse(l+1, r-1, s)\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        self.reverse(0, len(s)-1, s)\\n```\\n\\n## JAVA SOLUTIONS\\n##\\n\\nIterative Approach\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int N = s.length;\\n        for (int i = 0; i < N / 2; i++) {\\n            char temp = s[i];\\n            s[i] = s[N-i-1];\\n            s[N-i-1] = temp;\\n        }\\n    }\\n}\\n```\\n\\nRecursive Approach\\n```\\nclass Solution {\\n    public char[] reverse(int l, int r, char[] s) {\\n        if (l >= r) return s;\\n        char temp = s[l];\\n        s[l++] = s[r];\\n        s[r--] = temp;\\n        reverse(l, r, s);\\n        return null;\\n    }\\n\\n    public void reverseString(char[] s) {\\n        reverse(0, s.length-1, s);\\n    }\\n}\\n```\\n\\nPlease upvote for encouragement :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```\n```\\nclass Solution:\\n\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\tN = len(s)\\n\\t\\tfor i in range(N // 2):\\n\\t\\t\\ts[i], s[-i-1] == s[-i-1], s[i]\\n```\n```\\nclass Solution:\\n    def reverse(self, l, r, s):\\n        if l >= r:\\n            return\\n        s[l], s[r] = s[r], s[l]\\n        self.reverse(l+1, r-1, s)\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        self.reverse(0, len(s)-1, s)\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int N = s.length;\\n        for (int i = 0; i < N / 2; i++) {\\n            char temp = s[i];\\n            s[i] = s[N-i-1];\\n            s[N-i-1] = temp;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public char[] reverse(int l, int r, char[] s) {\\n        if (l >= r) return s;\\n        char temp = s[l];\\n        s[l++] = s[r];\\n        s[r--] = temp;\\n        reverse(l, r, s);\\n        return null;\\n    }\\n\\n    public void reverseString(char[] s) {\\n        reverse(0, s.length-1, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077649,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int i = 0, j = s.size() - 1;\\n        while(i < j){\\n            swap(s[i++], s[j--]); \\n        }\\n        \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int i = 0, j = s.size() - 1;\\n        while(i < j){\\n            swap(s[i++], s[j--]); \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902861,
                "title": "naive-approach-vs-hat-vs-array-reverse-with-benchmark-results",
                "content": "The easiest way is to use the built-in method `Reverse`:\\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        Array.Reverse(s);\\n    }\\n}\\n```\\nThe naive approach would to use one or two pointers and a `for` or a `while` loop. Please note that there is no need to introduce a temp variable for swapping values - use tuples instead. Here is an example:\\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        int len = s.Length;\\n        for (int i = 0; i < len / 2; i++)\\n        {\\n            (s[i], s[len - 1 - i]) = (s[len - 1 - i], s[i]);\\n        }\\n    }\\n}\\n```\\nReadability can be somewhat improved by using the hat operator `^`:\\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        for (int i = 1; i <= s.Length / 2; i++)\\n        {\\n            (s[i - 1], s[^i]) = (s[^i], s[i - 1]);\\n        }\\n    }\\n}\\n```\\n`^1` refers to the last element of an array, `^2` is the one before that, etc. More about the hat operator and ranges here: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/ranges\\n\\nBenchmark results on arrays of three different sizes. The built-in method is the fastest:\\n![image](https://assets.leetcode.com/users/images/5ff87d48-c4e4-40bc-b0b4-be3a3648f9a6_1648803525.3944693.png)\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        Array.Reverse(s);\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        int len = s.Length;\\n        for (int i = 0; i < len / 2; i++)\\n        {\\n            (s[i], s[len - 1 - i]) = (s[len - 1 - i], s[i]);\\n        }\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public void ReverseString(char[] s)\\n    {\\n        for (int i = 1; i <= s.Length / 2; i++)\\n        {\\n            (s[i - 1], s[^i]) = (s[^i], s[i - 1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683132,
                "title": "0ms-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0, end = s.length - 1;\\n        while(start < end) {\\n            char temp = s[start];\\n            s[start++] = s[end];\\n            s[end--] = temp;\\n        }\\n    }\\n}\\n```\\n\\n**Approach : Swapping using two pointer**\\n\\nOne pointer is pointing **at the start of the string** while the other pointer is pointing at the **end of the string**. Both pointers will keep swapping its element and travel towards each other. The algorithm basically simulating rotation of a string with respect to its midpoint.\\n\\n**Complexity** :\\nTime Complexity - O(N)\\nSpace Complexity - O(1)\\n\\nPlease UPVOTE if you understand the solution\\nThank You \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0, end = s.length - 1;\\n        while(start < end) {\\n            char temp = s[start];\\n            s[start++] = s[end];\\n            s[end--] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563138,
                "title": "python-one-line-3-simple-solutions",
                "content": "**Python :**\\n\\n**1:** Swap string elements to reverse \\n\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\tfor i in range(len(s) // 2): s[i], s[len(s) - 1 - i] = s[len(s) - 1 - i], s[i]\\n```\\n\\n**2:** Using slice\\n\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts[:] = s[::-1]\\n```\\n\\n**3:** Using built in string **reverse** method\\n\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts.reverse()\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef reverseString(self, s: List[str]) -> None:\\n\\tfor i in range(len(s) // 2): s[i], s[len(s) - 1 - i] = s[len(s) - 1 - i], s[i]\\n```\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts[:] = s[::-1]\\n```\n```\\ndef reverseString(self, s: List[str]) -> None:\\n\\ts.reverse()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 946287,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2):\\n            s[i],s[-i-1]=s[-i-1],s[i]\\n        return s\\n```\\n\\nI\\'m traversing till half of the string\\nand swapping first ith letter with last but ith letter\\n\\ns[-1] refers the last character\\ns[-2] refers the last but ith character",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2):\\n            s[i],s[-i-1]=s[-i-1],s[i]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574765,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0,j=s.size()-1;\\n        while(i<j)\\n            swap(s[i++],s[j--]);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0,j=s.size()-1;\\n        while(i<j)\\n            swap(s[i++],s[j--]);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923001,
                "title": "344-easy-python-reverse-string",
                "content": "**Using Recursion**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\\n\\n**Using Iteration**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\\n**Two Pointer**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\\n**Using Python**\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 699961,
                "title": "python-seems-easy-when-coming-from-c",
                "content": "simple swapping operation\\n```\\ndef reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        i , j = 0 , n-1\\n        \\n        while i<j:\\n            s[i] = ord(s[i])     # converting from char to int this is not necessary in cpp though\\n            s[j] = ord(s[j])\\n            \\n            s[i]^=s[j]           # swapping operation inplace\\n            s[j]^=s[i]\\n            s[i]^=s[j]\\n            \\n\\t\\t\\ts[i] = chr(s[i])     # converting back to char\\n            s[j] = chr(s[j])\\n            \\n            i+=1                   # updating pointers\\n            j-=1\\n```\\nsame code is cpp is much looks much more elegant\\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        int i=0 , j=s.size()-1;\\n        while (i<j)\\n            swap(s[i++] , s[j--]);       \\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\ndef reverseString(self, s: List[str]) -> None:\\n        n = len(s)\\n        i , j = 0 , n-1\\n        \\n        while i<j:\\n            s[i] = ord(s[i])     # converting from char to int this is not necessary in cpp though\\n            s[j] = ord(s[j])\\n            \\n            s[i]^=s[j]           # swapping operation inplace\\n            s[j]^=s[i]\\n            s[i]^=s[j]\\n            \\n\\t\\t\\ts[i] = chr(s[i])     # converting back to char\\n            s[j] = chr(s[j])\\n            \\n            i+=1                   # updating pointers\\n            j-=1\\n```\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        int i=0 , j=s.size()-1;\\n        while (i<j)\\n            swap(s[i++] , s[j--]);       \\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 305439,
                "title": "javascript-recursion",
                "content": "```\\nvar reverseString = function(s) {\\n    if (s.length == 0) {\\n        return;\\n    }\\n    var temp = s[0];\\n    s.shift();\\n    reverseString(s);\\n    s.push(temp);\\n};\\n```\\n\\nFirst Attemp",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n    if (s.length == 0) {\\n        return;\\n    }\\n    var temp = s[0];\\n    s.shift();\\n    reverseString(s);\\n    s.push(temp);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258497,
                "title": "javascript",
                "content": "```\\nvar reverseString = function(s) {\\n    for (let i=0, j=s.length-1; i<j; i++, j--) {\\n        const x = s[i]; const y = s[j];\\n        s[i] = y; s[j] = x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n    for (let i=0, j=s.length-1; i<j; i++, j--) {\\n        const x = s[i]; const y = s[j];\\n        s[i] = y; s[j] = x;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 231834,
                "title": "kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun reverseString(s: CharArray): Unit {\\n        var start = 0\\n        var end = s.lastIndex\\n        while (start < end){\\n            s[start] = s[end].also { s[end] = s[start] }\\n            start++\\n            end--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun reverseString(s: CharArray): Unit {\\n        var start = 0\\n        var end = s.lastIndex\\n        while (start < end){\\n            s[start] = s[end].also { s[end] = s[start] }\\n            start++\\n            end--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759308,
                "title": "java-recursive-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        recursiveArray(s.length - 1, s);\\n    }\\n    \\n    void recursiveArray(int index, char[] s) {\\n        if (index < s.length / 2) {\\n            return;\\n        }\\n\\n        char temp = s[index];\\n        s[index] = s[s.length - index - 1];\\n        s[s.length - index - 1] = temp;\\n\\n        recursiveArray(index - 1, s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        recursiveArray(s.length - 1, s);\\n    }\\n    \\n    void recursiveArray(int index, char[] s) {\\n        if (index < s.length / 2) {\\n            return;\\n        }\\n\\n        char temp = s[index];\\n        s[index] = s[s.length - index - 1];\\n        s[s.length - index - 1] = temp;\\n\\n        recursiveArray(index - 1, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334448,
                "title": "two-pointer-java-simple-solution",
                "content": "My simple solution, inspired from binary search\\'s some part\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        int low=0;\\n        int high=n-1;\\n\\t\\t\\n        while(low < high) {\\n            char ch = s[low];\\n            s[low] = s[high];\\n            s[high] = ch;\\n            \\n            low++;\\n            high--;\\n        }\\n        //System.out.println(Arrays.toString(s));\\n    }\\n}\\n\\n**Complexity Analysis**\\n\\n**Time Complexity:**  O(n)  where n is the total number character in the input string. The algorithm need to reverse the whole string.\\n\\n**Auxiliary Space:** O(1) or constant space is used. As you can see we are not using any extra space to reverse the elements.\\n\\nHope it help. Please **upvote** it and inspire me",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        int low=0;\\n        int high=n-1;\\n\\t\\t\\n        while(low < high) {\\n            char ch = s[low];\\n            s[low] = s[high];\\n            s[high] = ch;\\n            \\n            low++;\\n            high--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1901760,
                "title": "2-approaches-two-pointers-and-recursion",
                "content": "[Leetcode](https://leetcode.com/) [344. Reverse String](https://leetcode.com/problems/reverse-string).\\n\\n***By Frank Luo***\\n\\nHere shows **2** Approaches to slove this problem, **Two Pointers** and **Recursion**.\\n\\n\\n# Two Pointers\\n\\nThe first mind come to my mind is **Two Pointers**.\\n\\nWe need $N/2$ swaps, which $N$ is the length of string $s$. \\n\\n```java\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char ch = s[left];\\n            s[left] = s[right];\\n            s[right] = ch;\\n            left++;\\n            right--;\\n        }\\n    }\\n```\\n\\nor use **For** Loop:\\n\\n```java\\n    // Two Pointers Opt O(n) O(1)\\n    public static void reverseString_tp_opt(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int n = s.length;\\n        for (int left = 0, right = n - 1; left < right; ++left, --right) {\\n            char tmp = s[left];\\n            s[left] = s[right];\\n            s[right] = tmp;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n\\n# Recursion\\n \\nRecursion solution is also easy.\\n\\n```java\\npublic void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        reverse(s, 0, s.length - 1);\\n }\\n    \\n    public void reverse(char[] str, int begin, int end) {\\n        if (begin >= end) {\\n            return;\\n        }\\n        char ch = str[begin];\\n        str[begin] = str[end];\\n        str[end] = ch;\\n        reverse(str, begin + 1, end - 1);\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n/2)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```java\\n    public void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        int left = 0;\\n        int right = s.length - 1;\\n        while (left < right) {\\n            char ch = s[left];\\n            s[left] = s[right];\\n            s[right] = ch;\\n            left++;\\n            right--;\\n        }\\n    }\\n```\n```java\\n    // Two Pointers Opt O(n) O(1)\\n    public static void reverseString_tp_opt(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n\\n        int n = s.length;\\n        for (int left = 0, right = n - 1; left < right; ++left, --right) {\\n            char tmp = s[left];\\n            s[left] = s[right];\\n            s[right] = tmp;\\n        }\\n    }\\n```\n```java\\npublic void reverseString(char[] s) {\\n        if (s == null || s.length <= 1) {\\n            return;\\n        }\\n        \\n        reverse(s, 0, s.length - 1);\\n }\\n    \\n    public void reverse(char[] str, int begin, int end) {\\n        if (begin >= end) {\\n            return;\\n        }\\n        char ch = str[begin];\\n        str[begin] = str[end];\\n        str[end] = ch;\\n        reverse(str, begin + 1, end - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785740,
                "title": "c-simplest-recursion",
                "content": "```\\nvoid reverseString(char* s, int sSize){\\n    char* ptr = s+sSize-1;\\n    if (sSize <= 1)\\n        return;\\n    char tmp = *s;\\n    *s = *(ptr);\\n    *(ptr) = tmp;\\n    reverseString(s+1, sSize-2);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverseString(char* s, int sSize){\\n    char* ptr = s+sSize-1;\\n    if (sSize <= 1)\\n        return;\\n    char tmp = *s;\\n    *s = *(ptr);\\n    *(ptr) = tmp;\\n    reverseString(s+1, sSize-2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 262269,
                "title": "elegant-ruby-iterative-solution-two-pointers-2-lines-of-code",
                "content": "That\\'s what I call \"Ruby-way\" ;-)\\n\\n```ruby\\ndef reverse_string(s)\\n  return nil if s.empty?\\n\\n  (s.length / 2).times { |i| s[i], s[~i] = s[~i], s[i] }\\nend\\n```\\n\\nOld one:\\n```ruby\\ndef reverse_string(s)\\n    first, last = -1, s.length\\n    s[first], s[last] = s[last], s[first] until (first += 1) > (last -= 1)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef reverse_string(s)\\n  return nil if s.empty?\\n\\n  (s.length / 2).times { |i| s[i], s[~i] = s[~i], s[i] }\\nend\\n```\n```ruby\\ndef reverse_string(s)\\n    first, last = -1, s.length\\n    s[first], s[last] = s[last], s[first] until (first += 1) > (last -= 1)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 166869,
                "title": "python-solutions",
                "content": "```\\nclass Solution(object):\\n    \"\"\"Reverse String class.\"\"\"\\n    def reverse_string_by_position(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return s[::-1]\\n\\n    def reverse_string_recursive(self, s):\\n    \\t\\'\\'\\'\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \\'\\'\\'\\n        if len(s) < 1:\\n            return s\\n        return s[-1] + self.reverse_string_recursive(s[:-1])\\n\\n    def reverse_string_iteratively(self, s):\\n    \\t\"\"\"\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        length = len(s)\\n        result = list(s)\\n        for i in range(length / 2):\\n            result[length - 1], result[i] = s[length - 1], s[i]\\n            length -= 1\\n        return \\'\\'.join(result)\\n\\n    def reverse_string_using_built_in_method(self, s):\\n    \\t\"\"\"\\n        Reverse a string using built in method\\n\\n        :param s: A string\\n        :type s: str\\n        :rype: str\\n        \"\"\"\\n        return \\'\\'.join(reversed(s))\\n```\\n\\nPlease feel free to comment, give advice, etc",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \"\"\"Reverse String class.\"\"\"\\n    def reverse_string_by_position(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        return s[::-1]\\n\\n    def reverse_string_recursive(self, s):\\n    \\t\\'\\'\\'\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \\'\\'\\'\\n        if len(s) < 1:\\n            return s\\n        return s[-1] + self.reverse_string_recursive(s[:-1])\\n\\n    def reverse_string_iteratively(self, s):\\n    \\t\"\"\"\\n        Reverse a string recursively\\n\\n        :param s: A string\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        length = len(s)\\n        result = list(s)\\n        for i in range(length / 2):\\n            result[length - 1], result[i] = s[length - 1], s[i]\\n            length -= 1\\n        return \\'\\'.join(result)\\n\\n    def reverse_string_using_built_in_method(self, s):\\n    \\t\"\"\"\\n        Reverse a string using built in method\\n\\n        :param s: A string\\n        :type s: str\\n        :rype: str\\n        \"\"\"\\n        return \\'\\'.join(reversed(s))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81074,
                "title": "2ms-java-solution",
                "content": "    public class Solution {\\n        public String reverseString(String s) {\\n            if(s == null) return null;\\n            if(s.equals(\"\")) return s;\\n            char[] arrChar = s.toCharArray();\\n            for (int i = 0, j = arrChar.length-1; i <= j; i++, j--) {\\n                char temp = arrChar[i];\\n                arrChar[i] = arrChar[j];\\n                arrChar[j] = temp;\\n            }\\n            return new String(arrChar);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String reverseString(String s) {\\n            if(s == null) return null;\\n            if(s.equals(\"\")) return s;\\n            char[] arrChar = s.toCharArray();\\n            for (int i = 0, j = arrChar.length-1; i <= j; i++, j--) {\\n                char temp = arrChar[i];\\n                arrChar[i] = arrChar[j];\\n                arrChar[j] = temp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 80945,
                "title": "one-line-c-code-with-help-of-stl",
                "content": "   \\n \"Cheating\" method by calling proper iterator & constructor.\\n\\n    class Solution {\\n        public:\\n            string reverseString(string s) {\\n                return string(s.rbegin(), s.rend());\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            string reverseString(string s) {\\n                return string(s.rbegin(), s.rend());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3350770,
                "title": "what-if-the-interviewer-request-to-solve-this-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSwapping the characters in the array is a recurive operation here\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a recursive function using two pointers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        //Two Pointers were used here\\n        int startPointer = 0; \\n        int endPointer = s.length-1;\\n\\n        //Since swapping is a recursive operation we can use recursion technique\\n        solve(startPointer, endPointer, s);\\n\\n    }\\n    public void solve(int startPointer, int endPointer, char[] s){\\n        if(startPointer > endPointer) return; //Base condition\\n\\n            char temp = s[startPointer];\\n            s[startPointer] = s[endPointer];\\n            s[endPointer] = temp;\\n            \\n        solve(++startPointer, --endPointer, s);\\n    }\\n}\\n```\\n![please-upvote-and.jpeg](https://assets.leetcode.com/users/images/b08a9414-0482-430a-a0c1-5cdfde050c0f_1679992511.6273758.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        //Two Pointers were used here\\n        int startPointer = 0; \\n        int endPointer = s.length-1;\\n\\n        //Since swapping is a recursive operation we can use recursion technique\\n        solve(startPointer, endPointer, s);\\n\\n    }\\n    public void solve(int startPointer, int endPointer, char[] s){\\n        if(startPointer > endPointer) return; //Base condition\\n\\n            char temp = s[startPointer];\\n            s[startPointer] = s[endPointer];\\n            s[endPointer] = temp;\\n            \\n        solve(++startPointer, --endPointer, s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996835,
                "title": "two-pointers-easy-c-solution-3-lines",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Here, we are using two pointers for starting and ending index of the string and we swap them until we are at the middle of the string or we can say left poiner is less than right pointer.\\n# Complexity\\n- Time complexity : $$O(N) $$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            swap(s[left++],s[right--]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            swap(s[left++],s[right--]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192244,
                "title": "c-two-approach-easy-to-understand",
                "content": "#### **Approach 1: Using recursion**\\n\\nclass Solution {\\npublic:\\n\\t\\n    int idx = 0; // idx points to start of the vector and incremented at each function call.\\n    \\n    void rev(int n, vector<char>& s){\\n        if(idx == s.size()/2) return; // Recursion till half of the vector to swap.\\n        swap(s[idx++], s[n]);\\n        rev(--n, s);\\n    }\\n    \\n    void reverseString(vector<char>& s) {\\n        if(s.size() == 1) return;\\n        else rev(s.size()-1, s);  //Passing the last index as parameter to swap.\\n    }\\n};\\n\\n#### **Approach 2: Two pointers**\\n\\nclass Solution {\\npublic:\\n\\n    void reverseString(vector<char>& s) {\\n        int l = 0, r = s.size()-1;\\n        while(l < r) swap(s[l++] , s[r--]);\\n    }\\n};\\n\\nNote: For better understanding, prefer dry running yourself.\\nPLEASE UPVOTE IF HELPFUL!!",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\t\\n    int idx = 0; // idx points to start of the vector and incremented at each function call.\\n    \\n    void rev(int n, vector<char>& s){\\n        if(idx == s.size()/2) return; // Recursion till half of the vector to swap.\\n        swap(s[idx++], s[n]);\\n        rev(--n, s);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1902443,
                "title": "python-easy-solutions-one-liner",
                "content": "**Solution 1:** two pointers iterative\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        lo, hi = 0, len(s) - 1\\n        while lo < hi:\\n            s[lo], s[hi] = s[hi], s[lo]\\n            lo += 1\\n            hi -= 1\\n```\\n***\\n``` Space Complexity: O(1)```\\n***\\n\\n**Solution 2:** two pointers recursive\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        def reverse(lo,hi):\\n            if lo > hi: return\\n            s[lo], s[hi] = s[hi], s[lo]\\n            reverse(lo+1, hi-1)\\n        reverse(0, len(s)-1)\\n```\\n***\\n``` Space Complexity: O(N)```\\n***\\n\\n**Solution 3:**  One Liner\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(1,len(s) // 2 + 1): s[i-1], s[-i] = s[-i], s[i-1]\\n```\\n***\\n``` Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        lo, hi = 0, len(s) - 1\\n        while lo < hi:\\n            s[lo], s[hi] = s[hi], s[lo]\\n            lo += 1\\n            hi -= 1\\n```\n``` Space Complexity: O(1)```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        def reverse(lo,hi):\\n            if lo > hi: return\\n            s[lo], s[hi] = s[hi], s[lo]\\n            reverse(lo+1, hi-1)\\n        reverse(0, len(s)-1)\\n```\n``` Space Complexity: O(N)```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(1,len(s) // 2 + 1): s[i-1], s[-i] = s[-i], s[i-1]\\n```\n``` Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1902370,
                "title": "c-intuitive-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Upvote if it helps\\u2B06\\uFE0F*\\n```\\n\\tvoid reverseString(vector<char>& s) {\\n        int l=0,r=s.size()-1;\\n        char temp;\\n        while(l<r){\\n            temp=s[l];\\n            s[l]=s[r];\\n            s[r]=temp;\\n            l++,r--;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\tvoid reverseString(vector<char>& s) {\\n        int l=0,r=s.size()-1;\\n        char temp;\\n        while(l<r){\\n            temp=s[l];\\n            s[l]=s[r];\\n            s[r]=temp;\\n            l++,r--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1765698,
                "title": "c-efficient-algo-2-lines-easy-solutions",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size();\\n        \\n        for(int i=0;i<n/2;i++){\\n            swap(s[i],s[n-1-i]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size();\\n        \\n        for(int i=0;i<n/2;i++){\\n            swap(s[i],s[n-1-i]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673247,
                "title": "c-o-n-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        \\n        while(st<e)\\n            swap(s[st++],s[e--]);\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        \\n        while(st<e)\\n            swap(s[st++],s[e--]);\\n        \\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 497258,
                "title": "simple-rust-solutions-recursive-and-iterator",
                "content": "1. Recursive\\n```\\nimpl Solution {\\n    fn swap(s: &mut Vec<char>, beg: usize, end: usize) {\\n        if beg >= end { return; }\\n\\n        s.swap(beg, end);\\n\\n        Solution::swap(s, beg + 1, end - 1);\\n    }\\n\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            l => Solution::swap(s, 0, l - 1),\\n        };\\n    }\\n}\\n```\\n\\n2. Using iterator\\n```\\nimpl Solution {\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            size => {\\n                (0..(size / 2)).into_iter().for_each(|beg| {\\n                    let end = size - 1 - beg;\\n\\n                    s.swap(beg, end);\\n                });\\n            }\\n        };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn swap(s: &mut Vec<char>, beg: usize, end: usize) {\\n        if beg >= end { return; }\\n\\n        s.swap(beg, end);\\n\\n        Solution::swap(s, beg + 1, end - 1);\\n    }\\n\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            l => Solution::swap(s, 0, l - 1),\\n        };\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn reverse_string(s: &mut Vec<char>) {\\n        match s.len() {\\n            0 => (),\\n            size => {\\n                (0..(size / 2)).into_iter().for_each(|beg| {\\n                    let end = size - 1 - beg;\\n\\n                    s.swap(beg, end);\\n                });\\n            }\\n        };\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 458692,
                "title": "c",
                "content": "```\\npublic void ReverseString(char[] s) {\\n\\tvar n = s.Length;\\n\\n\\tfor (var i = 0; i < n / 2; i++) {\\n\\t\\tvar temp = s[i];\\n\\t\\ts[i] = s[n - i - 1];\\n\\t\\ts[n - i - 1] = temp;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void ReverseString(char[] s) {\\n\\tvar n = s.Length;\\n\\n\\tfor (var i = 0; i < n / 2; i++) {\\n\\t\\tvar temp = s[i];\\n\\t\\ts[i] = s[n - i - 1];\\n\\t\\ts[n - i - 1] = temp;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 377460,
                "title": "c-in-place-recursive",
                "content": "```\\nclass Solution {\\nprivate:\\n    void reverseHelper(vector<char>& s, int i, int j) {\\n        if (i >= j)\\n            return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        reverseHelper(s, i+1, j-1);\\n    }\\n    \\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverseHelper(s, 0, s.size() - 1);\\n    }\\n};\\n```\\nWell, this can be done in a simple loop. Since this problem appears in the chapter of Recursion, I just modify a bit in a recursive way.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void reverseHelper(vector<char>& s, int i, int j) {\\n        if (i >= j)\\n            return;\\n        char temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        reverseHelper(s, i+1, j-1);\\n    }\\n    \\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverseHelper(s, 0, s.size() - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275569,
                "title": "javascript",
                "content": "```\\nvar reverseString = function(s) {\\n\\n  for (let leftIndex = 0, rightIndex = s.length - 1; leftIndex < rightIndex; leftIndex++, rightIndex--) {\\n    let temp = s[leftIndex];\\n    s[leftIndex] = s[rightIndex];\\n    s[rightIndex] = temp;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n\\n  for (let leftIndex = 0, rightIndex = s.length - 1; leftIndex < rightIndex; leftIndex++, rightIndex--) {\\n    let temp = s[leftIndex];\\n    s[leftIndex] = s[rightIndex];\\n    s[rightIndex] = temp;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254110,
                "title": "swift-4-2-solution",
                "content": "```\\nclass Solution {\\n    func reverseString(_ s: inout [Character]) {\\n        var first = 0\\n        var last = s.count - 1\\n        \\n        while first < last {\\n            (s[first], s[last]) = (s[last], s[first])\\n            first += 1\\n            last -= 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func reverseString(_ s: inout [Character]) {\\n        var first = 0\\n        var last = s.count - 1\\n        \\n        while first < last {\\n            (s[first], s[last]) = (s[last], s[first])\\n            first += 1\\n            last -= 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81200,
                "title": "java-solution-using-stringbuilder-s-reverse-function",
                "content": "    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }",
                "solutionTags": [],
                "code": "    public String reverseString(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3975766,
                "title": "reverse-string-java-solution-super-easy-approach",
                "content": "# for detailed explaination and for your better understanding , you can watch this video :-\\nhttps://youtu.be/OKrM-UoOqkw?si=hAQwmLsxtPzD7wEz\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) \\n    {\\n        int start = 0 ;\\n        int end = s.length -1 ;\\n\\n        while(start < end)\\n        {\\n            char temp = s[start];\\n            s[start] = s[end];\\n            s[end] = temp ;\\n\\n            start++ ;\\n            end-- ;\\n        }  \\n    }\\n}\\n```\\n# If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.\\n# wish you the best  !",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) \\n    {\\n        int start = 0 ;\\n        int end = s.length -1 ;\\n\\n        while(start < end)\\n        {\\n            char temp = s[start];\\n            s[start] = s[end];\\n            s[end] = temp ;\\n\\n            start++ ;\\n            end-- ;\\n        }  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781112,
                "title": "easy-java-solution-using-two-pointer-runtime-0ms-sc-o-1",
                "content": "# Intuition\\nSwap the value between s[i] and s[j] until s.length/2\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for(int i=0, j = s.length - 1; i< s.length/2; i++, j--){\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n        }\\n    }\\n}\\n```\\n\\n# Time Complexity : O(n)\\nIn the reverseString method, the loop iterates until i reaches s.length/2, which means it only needs to iterate through half of the array. Therefore, the number of iterations is proportional to N/2, which can be simplified to N.\\n\\nInside the loop, there are constant time operations swapping two characters in the array. These operations take a constant amount of time, regardless of the size of the input.\\n\\nThus, the overall time complexity of the code is O(N).\\n\\n# Space Complexity : O(1)\\nThe space complexity is determined by the amount of additional space used by an algorithm, apart from the input itself. In this case, the code only uses a constant amount of extra space for the tmp variable to temporarily store a character during the swap operation. The space used for this variable does not depend on the size of the input array s.\\n\\nTherefore, regardless of the size of the input array, the code always requires the same amount of additional space, leading to a constant space complexity of O(1).\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for(int i=0, j = s.length - 1; i< s.length/2; i++, j--){\\n            char tmp = s[i];\\n            s[i] = s[j];\\n            s[j] = tmp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537373,
                "title": "java-simple-solution-with-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, I tried to solve this problem using a **\\'for\\'** loop, which made the code **shorter** but a little **difficult to understand**. \\n\\nIt is important for a solution to take only constant space, which is **O(1)**. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIn this approach, I am declaring two variables, **\\'left\\'** and **\\'right\\'**, to keep track of the starting and ending indices. These indices change every time at the end of the **\\'while\\'** loop.\\n\\n# Complexity\\n- **Time complexity:**\\n\\nThe **time complexity** of this function is **O(n)**, where n is the length of the input string s. The function iterates over the string in a while loop, swapping characters from the **left and right** ends until the left pointer surpasses the right pointer. \\n\\nSince each iteration swaps two characters, the number of iterations required to reverse the string is approximately **n/2**, which gives us **a linear time complexity**.\\n\\n\\n- **Space complexity:**\\n\\nThe **space complexity** of this function is **O(1)**, constant space. The function does not use any additional data structures that grow with the input size. \\n\\nInstead, it performs the character swaps in-place, modifying the input string directly. Therefore, the space required remains **constant** regardless of the size of the input string.\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int right = s.length-1;\\n        int left = 0;\\n\\n        while(left < right){\\n            char c = s[right];\\n            s[right] = s[left];\\n            s[left] = c;\\n\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```\\n\\n# **Do you like it? Upvote then..!**\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int right = s.length-1;\\n        int left = 0;\\n\\n        while(left < right){\\n            char c = s[right];\\n            s[right] = s[left];\\n            s[left] = c;\\n\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488277,
                "title": "344-reverse-string-solution",
                "content": "````\\ncode\\n\\n---\\n\\n- ````# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```javascript []\\n```\\nconsole.log(\\'Hello world!\\')\\n```\\n```\\n```python []\\nprint(\\'Hello world!\\')\\n```\\n```ruby []\\nputs \\'Hello world!\\'\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def reverseString(self, s: List[str]) -> None:\\n    l = 0\\n    r = len(s) - 1\\n\\n    while l < r:\\n      s[l], s[r] = s[r], s[l]\\n      l += 1\\n      r -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "````\\ncode\\n\\n---\\n\\n- ```\n```javascript []\\n```\n```\\n```\n```python []\\nprint(\\'Hello world!\\')\\n```\n```ruby []\\nputs \\'Hello world!\\'\\n```\n```\\nclass Solution:\\n  def reverseString(self, s: List[str]) -> None:\\n    l = 0\\n    r = len(s) - 1\\n\\n    while l < r:\\n      s[l], s[r] = s[r], s[l]\\n      l += 1\\n      r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438368,
                "title": "86-beats-two-pointer-approach-c",
                "content": "![Screenshot (625).png](https://assets.leetcode.com/users/images/952ae49a-eaec-4b94-850d-002a60a8d33a_1682002782.8422697.png)\\n\\n# Approach\\nhere i don\\'t use swap function so if we don\\'t use swap function then we use this temp variable technique \\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size(),temp;\\n        int start=0, end=n-1;\\n        while(start<=end){\\n           temp=s[start];\\n           s[start]=s[end];\\n           s[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/7c692f2b-8726-4f65-8612-fd4231521ac0_1682002801.8522642.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n=s.size(),temp;\\n        int start=0, end=n-1;\\n        while(start<=end){\\n           temp=s[start];\\n           s[start]=s[end];\\n           s[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246263,
                "title": "344-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis problem can be easily solved by swapping the characters from both ends of the given string until they meet at the center.\\n\\nHere\\'s the step-by-step explanation of the algorithm:\\n\\n1. Initialize two pointers: left pointing to the first character of the string and right pointing to the last character of the string.\\n2. While left < right, swap the characters at indices left and right and increment left and decrement right.\\n3. Return the modified string.\\n\\nThe time complexity of this algorithm is O(n) and the space complexity is O(1), where n is the length of the input string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # Initialize the left and right pointers\\n        left, right = 0, len(s) - 1\\n        \\n        # Loop until the pointers meet at the center\\n        while left < right:\\n            # Swap the characters at the left and right indices\\n            s[left], s[right] = s[right], s[left]\\n            \\n            # Increment left and decrement right\\n            left += 1\\n            right -= 1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # Initialize the left and right pointers\\n        left, right = 0, len(s) - 1\\n        \\n        # Loop until the pointers meet at the center\\n        while left < right:\\n            # Swap the characters at the left and right indices\\n            s[left], s[right] = s[right], s[left]\\n            \\n            # Increment left and decrement right\\n            left += 1\\n            right -= 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792737,
                "title": "python-easy-two-pointer-o-n-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        i,j=0,len(s)-1\\n        while i<=j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\\n\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        i,j=0,len(s)-1\\n        while i<=j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775622,
                "title": "java-runtime-1ms-faster-than-99-94-memory-usage-less-than-97-54",
                "content": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l = 0, r = s.length - 1;\\n        while (l < r) {\\n            char temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8a913d77-ae73-4853-b438-00b02512dea0_1667528314.4989285.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l = 0, r = s.length - 1;\\n        while (l < r) {\\n            char temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403620,
                "title": "python-4-method-beginner-friendly-easyto-understand-very-simple",
                "content": "If you find it helpful please upvote.\\nupvote is on left hand side just below (<Back) Button.\\nThankyou\\n\\nUSING RECURSION\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\\nUsing iteration\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\\nUsing Two Pointer\\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\\nusing python slicing\\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i=0\\n        j=len(s)-1\\n        def rev(s,i,j):\\n            if i>=j:\\n                return\\n            s[i],s[j]=s[j],s[i]\\n            rev(s,i+1,j-1)\\n        rev(s,i,j)\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n       \\n        size = len(s)\\n        for i in range(size//2):\\n            s[i], s[-i-1] = s[-i-1], s[i]\\n```\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        i,j=0,len(s)-1\\n        while i<j:\\n            s[i],s[j]=s[j],s[i]\\n            i+=1\\n            j-=1\\n```\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:]=s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901987,
                "title": "3-line-code-two-pointer-approach-easiest-way",
                "content": "```\\n//please upvote if u like my solution :)\\nvoid reverseString(vector<char>& s) {\\n        for(int i=0,j=s.size()-1;i<j;i++,j--){\\n            swap(s[i],s[j]);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n//please upvote if u like my solution :)\\nvoid reverseString(vector<char>& s) {\\n        for(int i=0,j=s.size()-1;i<j;i++,j--){\\n            swap(s[i],s[j]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1901845,
                "title": "bad-complicated-recursion",
                "content": "For jokes. This is terrible code.\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        helper(s, 0);\\n    }\\n    char helper(vector<char>& s, int i){\\n        if(i == s.size()) \\n            return s[0];\\n        char res = i == 0 ? 0 : s[s.size() - i]; // determine and store the value for prev index\\n        s[i] = helper(s, i + 1); // get the character for the current index\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        helper(s, 0);\\n    }\\n    char helper(vector<char>& s, int i){\\n        if(i == s.size()) \\n            return s[0];\\n        char res = i == 0 ? 0 : s[s.size() - i]; // determine and store the value for prev index\\n        s[i] = helper(s, i + 1); // get the character for the current index\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704410,
                "title": "3-solutions-one-liner-iterative-recursive-c-easy-to-understand",
                "content": "**One liner:**\\n\\n    void reverseString(vector<char>& s) { \\n          reverse(s.begin(), s.end());\\n    }\\n\\t\\n**Iterative:**\\n   \\n  ```\\n void reverseString(vector<char>& s) {   \\n        int low = 0;\\n        int high = s.size()-1;\\n        while(low <= high) {\\n            swap(s[low++], s[high--]);\\n        }\\n    }\\n```\\n\\n**Recurive:**\\n\\n    void rec(vector<char>& s, int low, int high)\\n    {\\n        if(low >= high)                  // Base Condition\\n            return;\\n        swap(s[low++], s[high--]);       // makes the problem smaller of same type            \\n        rec(s, low, high);\\n    }\\n    void reverseString(vector<char>& s) {\\n        rec(s, 0, s.size()-1);\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Recursion"
                ],
                "code": "```\\n void reverseString(vector<char>& s) {   \\n        int low = 0;\\n        int high = s.size()-1;\\n        while(low <= high) {\\n            swap(s[low++], s[high--]);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699563,
                "title": "python-iterative-and-recursive-solution",
                "content": "\\t# Iterative Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(s)//2\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\ts[i], s[-(i+1)] = s[-(i+1)], s[i]\\n\\n\\t# Recursive Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef revStr(st, s, e):\\n\\t\\t\\t\\tif s >= e:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tst[s], st[e] = st[e], st[s]\\n\\t\\t\\t\\trevStr(st, s+1, e-1)\\n\\n\\t\\t\\trevStr(s, 0, len(s)-1)\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\t# Iterative Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tn = len(s)//2\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\ts[i], s[-(i+1)] = s[-(i+1)], s[i]\\n\\n\\t# Recursive Approach\\n\\tclass Solution:\\n\\t\\tdef reverseString(self, s: List[str]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify s in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdef revStr(st, s, e):\\n\\t\\t\\t\\tif s >= e:\\n\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\tst[s], st[e] = st[e], st[s]\\n\\t\\t\\t\\trevStr(st, s+1, e-1)\\n\\n\\t\\t\\trevStr(s, 0, len(s)-1)\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1394982,
                "title": "simplest-java-solution-beats-100-online-java-submissions",
                "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int max=s.length-1;\\n    \\n        int halfindex=s.length/2;\\n        for(int i=0;i<halfindex;i++){\\n            char c=s[i];\\n            s[i]=s[max-i];\\n            s[max-i]=c;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void reverseString(char[] s) {\\n        int max=s.length-1;\\n    \\n        int halfindex=s.length/2;\\n        for(int i=0;i<halfindex;i++){\\n            char c=s[i];\\n            s[i]=s[max-i];\\n            s[max-i]=c;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1357993,
                "title": "simple-c-recursive-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        _reverseString(s, 0, s.size() - 1);\\n    }\\n    void _reverseString(vector<char>& s, int start, int end){\\n        // Base Case\\n        if(start > end) return;\\n        swap(s[start++], s[end--]);\\n        // Recurrence relation\\n        _reverseString(s, start, end);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        _reverseString(s, 0, s.size() - 1);\\n    }\\n    void _reverseString(vector<char>& s, int start, int end){\\n        // Base Case\\n        if(start > end) return;\\n        swap(s[start++], s[end--]);\\n        // Recurrence relation\\n        _reverseString(s, start, end);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669557,
                "title": "c-iterative-and-recursive-simple-and-short",
                "content": "**Iterative**\\n```\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        for(int i = 0; i < n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n```\\n**Recursive**\\n```\\nvoid reverse(vector<char>& str,int i)\\n    {\\n        if(i == str.size()/2) \\n            return;\\n        swap(str[i] , str[str.size() - 1 - i]);\\n        reverse(str,i + 1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        reverse(s , 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        for(int i = 0; i < n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n```\n```\\nvoid reverse(vector<char>& str,int i)\\n    {\\n        if(i == str.size()/2) \\n            return;\\n        swap(str[i] , str[str.size() - 1 - i]);\\n        reverse(str,i + 1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        reverse(s , 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374535,
                "title": "easy-c-2-line-solution-beats-92-100",
                "content": "Runtime: 44 ms, faster than 92.12% of C++ online submissions for Reverse String.\\nMemory Usage: 15.2 MB, less than 96.34% of C++ online submissions for Reverse String.\\n\\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        for(int start=0, end = s.size()-1; start < end; start++, end--)\\n            swap(s[start], s[end]);\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "Runtime: 44 ms, faster than 92.12% of C++ online submissions for Reverse String.\\nMemory Usage: 15.2 MB, less than 96.34% of C++ online submissions for Reverse String.\\n\\n```\\nvoid reverseString(vector<char>& s) {\\n        \\n        for(int start=0, end = s.size()-1; start < end; start++, end--)\\n            swap(s[start], s[end]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 272264,
                "title": "fastest-c-solution",
                "content": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var length = s.Length;\\n        for(int i = 0; i < length/2; i++){\\n            var temp = s[i];\\n            s[i] = s[length - i - 1];\\n            s[length - i - 1] = temp;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var length = s.Length;\\n        for(int i = 0; i < length/2; i++){\\n            var temp = s[i];\\n            s[i] = s[length - i - 1];\\n            s[length - i - 1] = temp;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151308,
                "title": "javascript-es6",
                "content": "new submission.\\n\\n```\\nvar reverseString = function(s) {\\n  if (s.length < 2) return s;\\n  let start = 0,end = s.length - 1;\\n  while (end > start) {\\n    [s[start], s[end]] = [s[end], s[start]]; // es6 swap trick\\n    end--;\\n    start++;\\n  }\\n};\\n```\\n\\n/////Note: Question desc has  changed from what it was back in 2018 //////\\n```\\nreturn s.reverse();\\n```\\njs\\n```\\nvar reverseString = function(s) {\\n    let result = \\'\\'\\n    for(let i= s.length -1; i >= 0; i--){\\n        result += s[i];\\n    }\\n    return result.split(\\'\\');\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar reverseString = function(s) {\\n  if (s.length < 2) return s;\\n  let start = 0,end = s.length - 1;\\n  while (end > start) {\\n    [s[start], s[end]] = [s[end], s[start]]; // es6 swap trick\\n    end--;\\n    start++;\\n  }\\n};\\n```\n```\\nreturn s.reverse();\\n```\n```\\nvar reverseString = function(s) {\\n    let result = \\'\\'\\n    for(let i= s.length -1; i >= 0; i--){\\n        result += s[i];\\n    }\\n    return result.split(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80982,
                "title": "c-solution-char-array",
                "content": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n\\n        while(left < right)\\n        {\\n            var temp = s[left];\\n            s[left] = s[right];\\n            s[right] = temp;\\n            \\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n\\n        while(left < right)\\n        {\\n            var temp = s[left];\\n            s[left] = s[right];\\n            s[right] = temp;\\n            \\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 80994,
                "title": "share-my-simple-c-solution-no-swap",
                "content": "    class Solution {\\n    public:\\n        string reverseString(string s) {\\n            string ret;\\n            for(int i = s.size()-1; i >= 0; --i)\\n                ret += s[i];\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string reverseString(string s) {\\n            string ret;\\n            for(int i = s.size()-1; i >= 0; --i)\\n                ret += s[i];\\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 81195,
                "title": "share-my-c-solution-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int start = 0;\\n            int end = s.length() - 1;\\n            char ch = 0;\\n            \\n            for (; start < end; start++, end--)\\n            {\\n                ch = s[start];\\n                s[start] = s[end];\\n                s[end] = ch;\\n            }\\n            \\n            return s;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string reverseString(string s) {\\n            int start = 0;\\n            int end = s.length() - 1;\\n            char ch = 0;\\n            \\n            for (; start < end; start++, end--)\\n            {\\n                ch = s[start];\\n                s[start] = s[end];\\n                s[end] = ch;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3649560,
                "title": "cpp-easy-2-lines-solution-using-swap-function",
                "content": "# Intuition\\nfirst thought was to use two pointers, one at start and one at end.\\n\\n# Approach\\n- Put a pointer st at start.\\n- pointer e at end of char array.\\n- put while loop till st<e.\\n- and swap s[st] with s[e].\\n- st++ and e--.\\n\\n# Complexity\\n- Time complexity:\\n                  O(n)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        while(st<e)\\n        {\\n           swap(s[st++],s[e--]);\\n        }\\n    }\\n};\\n```\\n# Please upvote if you liked my explanation",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int st=0;\\n        int e=s.size()-1;\\n        while(st<e)\\n        {\\n           swap(s[st++],s[e--]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431886,
                "title": "easy-js-solution-no-inbuilt-methods",
                "content": "\\n# Approach\\nThis is a standard two-pointer algorithm. We would start off with two variables, $$left$$ and $$right$$. Run a for loop until $$left < right$$ and swap the characters at left and right by using $$[arr[left] , arr[right]] = [arr[right], arr[left]]$$. Return the answer\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$Constant$$\\n\\n# Code\\n```\\n\\nvar reverseString = function(s) {\\n   let left = 0, right=s.length-1;\\n\\n   while(left < right ) {\\n       [s[left] , s[right]] = [s[right] , s[left]];\\n       left++;\\n       right--\\n   } \\n\\n   return s\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar reverseString = function(s) {\\n   let left = 0, right=s.length-1;\\n\\n   while(left < right ) {\\n       [s[left] , s[right]] = [s[right] , s[left]];\\n       left++;\\n       right--\\n   } \\n\\n   return s\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3423152,
                "title": "easy-c-code-using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<char>&s){\\n        if(i>=s.size()/2) return;\\n        swap(s[i],s[s.size()-i-1]);\\n        f(i+1,s);\\n    }\\n    void reverseString(vector<char>& s) {\\n        f(0,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(int i,vector<char>&s){\\n        if(i>=s.size()/2) return;\\n        swap(s[i],s[s.size()-i-1]);\\n        f(i+1,s);\\n    }\\n    void reverseString(vector<char>& s) {\\n        f(0,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342891,
                "title": "two-pointers",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvoid reverseString(char* s, int sSize){\\n    char* left = s;\\n    char* right = s + sSize - 1;\\n\\n    while (left < right) {\\n        char temp = *right;\\n        *right-- = *left;\\n        *left++ = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nvoid reverseString(char* s, int sSize){\\n    char* left = s;\\n    char* right = s + sSize - 1;\\n\\n    while (left < right) {\\n        char temp = *right;\\n        *right-- = *left;\\n        *left++ = temp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3002634,
                "title": "very-simple-c-solution-two-pointers-o-n-time-o-1-memory",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var l = 0;\\n        var r = s.Length-1;\\n        while (l < r)\\n        {\\n            var temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Two Pointers"
                ],
                "code": "```\\npublic class Solution {\\n    public void ReverseString(char[] s) {\\n        var l = 0;\\n        var r = s.Length-1;\\n        while (l < r)\\n        {\\n            var temp = s[l];\\n            s[l] = s[r];\\n            s[r] = temp;\\n            l++;\\n            r--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739302,
                "title": "using-stack-recursion-and-two-pointers-easy-and-fast",
                "content": "\\n\\n```Approach 1:```\\n\\n**Using Two Pointers**\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            char temp = s[right];\\n            s[right--] = s[left];\\n            s[left++] = temp;\\n        }\\n        \\n    }\\n};\\n```\\n\\n```Approach 2:```\\n\\n**Using recursion**\\n \\n code:\\n ```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<char>& s, int left, int right){\\n        if(left >= right) return;\\n        char temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        solve(s, ++left, --right);\\n    }\\n\\n    void reverseString(vector<char>& s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        solve(s, left, right);\\n    }\\n    \\n};\\n```\\n\\n```Approach 3:```\\n\\n**Using stack**\\n\\ncode:\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        stack<char> tempStack;\\n        int i=0;\\n        while(i<s.size()){\\n            tempStack.push(s[i++]);\\n        }\\n        \\n        s.clear();\\n        while(!tempStack.empty()){\\n            s.push_back(tempStack.top());\\n            tempStack.pop();\\n        }\\n    }\\n};\\n```\\n\\nHope it will help you \\uD83D\\uDE4C .\\nThank you!",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Stack",
                    "Recursion"
                ],
                "code": "```Approach 1:```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int left = 0, right = s.size()-1;\\n        while(left<right)\\n        {\\n            char temp = s[right];\\n            s[right--] = s[left];\\n            s[left++] = temp;\\n        }\\n        \\n    }\\n};\\n```\n```Approach 2:```\n```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<char>& s, int left, int right){\\n        if(left >= right) return;\\n        char temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        solve(s, ++left, --right);\\n    }\\n\\n    void reverseString(vector<char>& s) {\\n        int left = 0;\\n        int right = s.size() - 1;\\n        solve(s, left, right);\\n    }\\n    \\n};\\n```\n```Approach 3:```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        \\n        stack<char> tempStack;\\n        int i=0;\\n        while(i<s.size()){\\n            tempStack.push(s[i++]);\\n        }\\n        \\n        s.clear();\\n        while(!tempStack.empty()){\\n            s.push_back(tempStack.top());\\n            tempStack.pop();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685812,
                "title": "two-pointers-approach-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Start off with two-pointers (start and end).\\n2. Create a loop with breaking conditions i.e left must be less than right.\\n3. Swap the values with each other in each iteration.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0;\\n    let right = s.length - 1 ;\\n\\n    while(left < right){\\n        const temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n\\n        left += 1;\\n        right -= 1;\\n    }\\n\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0;\\n    let right = s.length - 1 ;\\n\\n    while(left < right){\\n        const temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n\\n        left += 1;\\n        right -= 1;\\n    }\\n\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2617831,
                "title": "c-2-pointer-approch-swaping-elemnts-on-the-pointer",
                "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s)\\n    {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(j>=i)\\n        {\\n           swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s)\\n    {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(j>=i)\\n        {\\n           swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2534280,
                "title": "java-3-line-code-faster-than-99-easy-to-understand",
                "content": "\\tclass Solution {\\n    public void reverseString(char[] s) {\\n        int startIndex = 0;\\n        int endIndex = s.length - 1;\\n        char temp;\\n        while (startIndex < endIndex) {\\n            temp = s[startIndex];\\n            s[startIndex] = s[endIndex];\\n            s[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\nIf you like solution, than UpVote ^ me :)",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public void reverseString(char[] s) {\\n        int startIndex = 0;\\n        int endIndex = s.length - 1;\\n        char temp;\\n        while (startIndex < endIndex) {\\n            temp = s[startIndex];\\n            s[startIndex] = s[endIndex];\\n            s[endIndex] = temp;\\n            startIndex++;\\n            endIndex--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2397227,
                "title": "simple-1ms-java-solution",
                "content": "```\\npublic void reverseString(char[] s) \\n    {\\n        int i=0;\\n        int j= s.length-1;\\n        char t;\\n\\n        \\n        while(i <= j)\\n        {\\n            t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic void reverseString(char[] s) \\n    {\\n        int i=0;\\n        int j= s.length-1;\\n        char t;\\n\\n        \\n        while(i <= j)\\n        {\\n            t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n            i++;\\n            j--;\\n        }\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381464,
                "title": "simple-c-solution",
                "content": "```\\nvoid swap(char* a, char* b){\\n    char temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid reverseString(char* s, int sSize){\\n    int starting = 0, ending = sSize - 1;\\n    while (starting < ending){\\n        swap(&s[starting++], &s[ending--]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid swap(char* a, char* b){\\n    char temp = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nvoid reverseString(char* s, int sSize){\\n    int starting = 0, ending = sSize - 1;\\n    while (starting < ending){\\n        swap(&s[starting++], &s[ending--]);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2378221,
                "title": "c-solution-2-approaches-function-and-swapping",
                "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n\\t\\n\\t\\t// 1. by using inbuilt function\\n        reverse(s.begin(), s.end());\\n\\t\\t\\n\\t\\t// 2. by swappping\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while(i < j){\\n            int temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n\\t\\n\\t\\t// 1. by using inbuilt function\\n        reverse(s.begin(), s.end());\\n\\t\\t\\n\\t\\t// 2. by swappping\\n        int i = 0;\\n        int j = s.size() - 1;\\n        while(i < j){\\n            int temp = s[i];\\n            s[i] = s[j];\\n            s[j] = temp;\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1952125,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid sol(vector<char>& s,int low,int high)\\n\\t\\t{\\n\\t\\tif(low>=high)return;\\n\\t\\tsol(s,low+1,high-1);\\n\\t\\tswap(s[low],s[high]);\\n\\t\\t}\\n\\t\\tvoid reverseString(vector<char>& s) {\\n\\t\\tint n=s.size()-1;\\n\\t\\tsol(s,0,n);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid sol(vector<char>& s,int low,int high)\\n\\t\\t{\\n\\t\\tif(low>=high)return;\\n\\t\\tsol(s,low+1,high-1);\\n\\t\\tswap(s[low],s[high]);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1901962,
                "title": "javascript-python-visual-explanation",
                "content": "**Please dont downvote guys if cannot support,We are putting lot of effort in it \\uD83D\\uDE42**\\n```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\n    Write a function that reverses a string. The input string is given as an array of characters s.\\n\\n    You must do this by modifying the input array in-place with O(1) extra memory.\\n\\n\\nQuestion Explanation:\\n    basically, we need to reverse the string with constant space\\n\\n\\nExplanation:\\n    lets declare a variable called left and right.\\n    left = 0\\n    right = len(nums) - 1\\n    we will keep on looping until left is less than right.\\n\\n\\nBig O:\\n    n--> number of elements in the array\\n    Time Complexity: O(n) \\n    Space Complexity: O(1)\\n```\\n\\n![image](https://assets.leetcode.com/users/images/eb2044db-0a9b-4534-93c9-92029ca851dc_1648779427.3667967.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/d23bd408-512f-41ea-b0ca-535aad304f1b_1648779528.4045486.gif)\\n\\n\\n`Python`\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left=0\\n        right=len(s)-1\\n        while left < right:\\n            left_val=s[left]\\n            right_val=s[right]\\n            s[left],s[right]=right_val,left_val\\n            left+=1\\n            right-=1\\n        return s\\n```\\n\\n`Javascript`\\n\\n```\\nconst reverseString = (s) => {\\nlet left = 0;\\n  let right = s.length - 1;\\n  while (left < right) {\\n    const first = s[left];\\n    const last = s[right];\\n    [s[left], s[right]] = [last, first];\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.`\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\n    Write a function that reverses a string. The input string is given as an array of characters s.\\n\\n    You must do this by modifying the input array in-place with O(1) extra memory.\\n\\n\\nQuestion Explanation:\\n    basically, we need to reverse the string with constant space\\n\\n\\nExplanation:\\n    lets declare a variable called left and right.\\n    left = 0\\n    right = len(nums) - 1\\n    we will keep on looping until left is less than right.\\n\\n\\nBig O:\\n    n--> number of elements in the array\\n    Time Complexity: O(n) \\n    Space Complexity: O(1)\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left=0\\n        right=len(s)-1\\n        while left < right:\\n            left_val=s[left]\\n            right_val=s[right]\\n            s[left],s[right]=right_val,left_val\\n            left+=1\\n            right-=1\\n        return s\\n```\n```\\nconst reverseString = (s) => {\\nlet left = 0;\\n  let right = s.length - 1;\\n  while (left < right) {\\n    const first = s[left];\\n    const last = s[right];\\n    [s[left], s[right]] = [last, first];\\n    left++;\\n    right--;\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764369,
                "title": "python-3-200ms-two-pointers-approach-2-solutions",
                "content": "***1 - Two Pointers (Start & End) :-***\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        st,e=0,len(s)-1\\n        while st<=e:\\n            s[st],s[e]=s[e],s[st]\\n            st+=1\\n            e-=1\\n```\\n\\n***2 - Same but One-Liner :-***\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        st,e=0,len(s)-1\\n        while st<=e:\\n            s[st],s[e]=s[e],s[st]\\n            st+=1\\n            e-=1\\n```\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s)//2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1618141,
                "title": "using-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        rev(s, 0, s.size()-1);\\n    }\\n    void rev(vector<char>& s, int b, int e){  \\n        if(b>e) return;\\n        \\n        else{ \\n            swap(s[b],s[e]);\\n            return rev(s,b+1,e-1);\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        rev(s, 0, s.size()-1);\\n    }\\n    void rev(vector<char>& s, int b, int e){  \\n        if(b>e) return;\\n        \\n        else{ \\n            swap(s[b],s[e]);\\n            return rev(s,b+1,e-1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615010,
                "title": "c-simple-code-full-explantion-with-comments-dry-run-constant-space-i-e-o-1-pass-94-43",
                "content": "Code with full explanation and for dry run see below -\\n```\\nclass Solution {\\npublic:\\n    //Runtime: 16 ms, faster than 94.43% of C++ online submissions for Reverse String.\\n    //Memory Usage: 23.2 MB, less than 76.23% of C++ online submissions for Reverse String.\\n    \\n\\t// Explanation-\\n    /* Basic question, but good one to do it in O(1) space\\n       Simply, we use two pointer approach for solving this,\\n       we declare two variables as low and high,\\n       and intilize low as 0 (i.e pointing first index)&\\n           high as size of string - 1 (basically, last index of string)\\n           \\n           Now, while low is less than high,(it is condition, it will clear in dry run\\n           we simply swap the characters present at low and high index,\\n           and move low as one step forward and for high we reduce it one step;\\n           \\n           see below dry run\\n    */\\n    void reverseString(vector<char>& s) {\\n        int n = s.size(); // give the size of array\\n        \\n        int low = 0; // low at first index\\n        int high = n - 1; // high at last index\\n        \\n        while(low < high) // while condition is satisfied\\n        {\\n            // simply swapping characters\\n\\t\\t\\t// other than that simply we can write also { swap(s[low], s[high]) }\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            \\n            low++; // moving low one step forwad\\n            high--; // reducing high by one step \\n        }\\n    }\\n    \\n    // we are done now\\n};\\n```\\n\\n**NOW, DRY RUN ON FIRST EXAMPLE**\\n\\n```\\nInput string , s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nn = 5\\n\\nlow = 0,\\nhigh =  5 - 1 = 4 (n - 1)\\n\\n//looping starts\\nwhile (low < high)\\n{\\n      when\\n\\t  low = 0, \\n\\t  high = 4\\n\\t  swap(arr[0],arr[4])\\n\\t  so, string s becomes - s = [\"o\",\"e\",\"l\",\"l\",\"h\"]\\n\\t  \\n\\t  low++   --> low becomes 1\\n\\t  high--   --> high becomes 3\\n\\t  \\n\\t  condition satisfiesd low < high (i.e 1 < 3)\\n\\t   when\\n\\t  low = 1, \\n\\t  high = 3\\n\\t  swap(arr[1],arr[3])\\n\\t  so, string s becomes - s = [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t   low++   --> low becomes 2\\n\\t   high--   --> high becomes 2\\n\\t  \\n\\t  condition not satisfied as \\n\\t  here, low becomes equal to high (2 == 2)\\n\\t  it is no more less than high\\n\\t  \\n\\t  so return final string\\n\\t  and becomes, s=  [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t  // if u like this please give me a upvote\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Runtime: 16 ms, faster than 94.43% of C++ online submissions for Reverse String.\\n    //Memory Usage: 23.2 MB, less than 76.23% of C++ online submissions for Reverse String.\\n    \\n\\t// Explanation-\\n    /* Basic question, but good one to do it in O(1) space\\n       Simply, we use two pointer approach for solving this,\\n       we declare two variables as low and high,\\n       and intilize low as 0 (i.e pointing first index)&\\n           high as size of string - 1 (basically, last index of string)\\n           \\n           Now, while low is less than high,(it is condition, it will clear in dry run\\n           we simply swap the characters present at low and high index,\\n           and move low as one step forward and for high we reduce it one step;\\n           \\n           see below dry run\\n    */\\n    void reverseString(vector<char>& s) {\\n        int n = s.size(); // give the size of array\\n        \\n        int low = 0; // low at first index\\n        int high = n - 1; // high at last index\\n        \\n        while(low < high) // while condition is satisfied\\n        {\\n            // simply swapping characters\\n\\t\\t\\t// other than that simply we can write also { swap(s[low], s[high]) }\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            \\n            low++; // moving low one step forwad\\n            high--; // reducing high by one step \\n        }\\n    }\\n    \\n    // we are done now\\n};\\n```\n```\\nInput string , s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\\nn = 5\\n\\nlow = 0,\\nhigh =  5 - 1 = 4 (n - 1)\\n\\n//looping starts\\nwhile (low < high)\\n{\\n      when\\n\\t  low = 0, \\n\\t  high = 4\\n\\t  swap(arr[0],arr[4])\\n\\t  so, string s becomes - s = [\"o\",\"e\",\"l\",\"l\",\"h\"]\\n\\t  \\n\\t  low++   --> low becomes 1\\n\\t  high--   --> high becomes 3\\n\\t  \\n\\t  condition satisfiesd low < high (i.e 1 < 3)\\n\\t   when\\n\\t  low = 1, \\n\\t  high = 3\\n\\t  swap(arr[1],arr[3])\\n\\t  so, string s becomes - s = [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t   low++   --> low becomes 2\\n\\t   high--   --> high becomes 2\\n\\t  \\n\\t  condition not satisfied as \\n\\t  here, low becomes equal to high (2 == 2)\\n\\t  it is no more less than high\\n\\t  \\n\\t  so return final string\\n\\t  and becomes, s=  [\"o\",\"l\",\"l\",\"e\",\"h\"]\\n\\t  \\n\\t  // if u like this please give me a upvote\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529891,
                "title": "solution-to-get-rejected-from-interview",
                "content": "\\n\\nclass Solution:\\n    \\n    def reverseString(self, s: List[str]) -> None:\\n        \\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \\n        \"\"\"\\n        \\n        s.reverse()\\n",
                "solutionTags": [],
                "code": "\\n\\nclass Solution:\\n    \\n    def reverseString(self, s: List[str]) -> None:\\n        \\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \\n        \"\"\"\\n        \\n        s.reverse()\\n",
                "codeTag": "Java"
            },
            {
                "id": 1137346,
                "title": "recursive-iterative-and-stl-solution",
                "content": "**Recursive 1**\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<char>& s, int start, int end)\\n    {\\n        if(start>=end)\\n            return ;\\n        char temp=s[end];\\n        s[end]=s[start];\\n        s[start]=temp;\\n        solve(s,start+1,end-1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        solve(s,0,s.size()-1);\\n        return ;\\n    }\\n};\\n```\\n**Recursive 2**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        if(s.size()==0)\\n            return;\\n        char temp=s[0];\\n        s.erase(s.begin()+0);\\n        reverseString(s);\\n        s.push_back(temp);\\n    }\\n};\\n```\\n**Iterative solution**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        char temp;\\n        int n=s.size();\\n        if(n==1)\\n            return ;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            temp=s[i];\\n            s[i]=s[n-i-1];\\n            s[n-1-i]=temp;\\n        }\\n    }\\n};\\n```\\n**Stl Solution**\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<char>& s, int start, int end)\\n    {\\n        if(start>=end)\\n            return ;\\n        char temp=s[end];\\n        s[end]=s[start];\\n        s[start]=temp;\\n        solve(s,start+1,end-1);\\n    }\\n    void reverseString(vector<char>& s) {\\n        solve(s,0,s.size()-1);\\n        return ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        if(s.size()==0)\\n            return;\\n        char temp=s[0];\\n        s.erase(s.begin()+0);\\n        reverseString(s);\\n        s.push_back(temp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        char temp;\\n        int n=s.size();\\n        if(n==1)\\n            return ;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            temp=s[i];\\n            s[i]=s[n-i-1];\\n            s[n-1-i]=temp;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084750,
                "title": "python-3-basic-2-pointer-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left,right = 0,len(s)-1\\n        while left < right:\\n            s[left],s[right] = s[right],s[left]\\n            left += 1\\n            right -= 1\\n```\\nRun two pointers from both the ends and assign one to the other, and vice versa.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        left,right = 0,len(s)-1\\n        while left < right:\\n            s[left],s[right] = s[right],s[left]\\n            left += 1\\n            right -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016564,
                "title": "100-faster-100-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-1-i]);\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-1-i]);\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883529,
                "title": "c-simple-and-short-solution-beats-97",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i;\\n        int j = s.size()-1;\\n        for(i = 0 ;i <j ;i++)\\n        {\\n            swap(s[i],s[j]);\\n            j--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i;\\n        int j = s.size()-1;\\n        for(i = 0 ;i <j ;i++)\\n        {\\n            swap(s[i],s[j]);\\n            j--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812518,
                "title": "ruby-without-using-reverse",
                "content": "```\\ndef reverse_string(s)\\n    (s.size/2).times { |i| s[i], s[-(i+1)] = s[-(i+1)], s[i] }\\n    s\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef reverse_string(s)\\n    (s.size/2).times { |i| s[i], s[-(i+1)] = s[-(i+1)], s[i] }\\n    s\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 670913,
                "title": "javascript-2-liner-with-explanation-faster-97-less-than-88-mem",
                "content": "Ok I wasn\\'t going to post my solution because the problem was so easy, but i see all these others using two pointers, running the full length of the string/array, of using temp vars, etc.\\n\\nSo here it is, only extra space is the iteration variable i, and the runtime is n/2.  For odd size strings, the letter in the middle doesn\\'t need to be copied.\\n```\\nvar reverseString = function(s) {\\n    for (let i=0; i<s.length/2; i++)\\n        [s[i], s[s.length-1-i]] = [s[s.length-1-i], s[i]]\\n};\\n```\\nBtw, I could have made it more efficient by setting the stopping condition in the beginning of my for loop, so i would not have recalculated it every time and by calculating s.length-1-i once per loop, rather than twice.\\n```\\n  for (let i=0, j=s.length/2, lenMin1=s.length-1; i<j; i++,lenMin1--)\\n    [s[i], s[lenMin1]] = [s[lenMin1], s[i]]\\n```\\nRemember the first statement, runs at the beginning of the loop, the second runs at each iteration, and the last also.  Normally s.length is a simple lookup, but since i do /2, it\\'s an operation each time so better just done once, same with lenMin1.\\n\\nCheers!\\n\\nP.S. As one of the comments mentioned, today this runs a bit slower than when ran earlier.  Also it\\'s pretty random (assuming it\\'s the current server load).  So I just re-ran it, and it\\'s 70% faster, then on next run 94%.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    for (let i=0; i<s.length/2; i++)\\n        [s[i], s[s.length-1-i]] = [s[s.length-1-i], s[i]]\\n};\\n```\n```\\n  for (let i=0, j=s.length/2, lenMin1=s.length-1; i<j; i++,lenMin1--)\\n    [s[i], s[lenMin1]] = [s[lenMin1], s[i]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 670430,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while(i<j){\\n            char c=s[i];\\n            s[i]=s[j];\\n            s[j]=c;\\n            i++;\\n            j--;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0, j=s.size()-1;\\n        while(i<j){\\n            char c=s[i];\\n            s[i]=s[j];\\n            s[j]=c;\\n            i++;\\n            j--;\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575577,
                "title": "python-inplace-oneliner",
                "content": "Obvious goal was to save memory so I may not use classic pythonic ways like \"[::-1]\", \"reverse\" and so on. Here is my memory-greedy approach:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s) // 2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        for i in range(len(s) // 2): s[i], s[-i-1] = s[-i-1], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573784,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        for i in range(len(s) // 2):\\n            s[i] , s[~i] = s[~i], s[i]\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        for i in range(len(s) // 2):\\n            s[i] , s[~i] = s[~i], s[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400259,
                "title": "python-recursive-solution",
                "content": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        \"\"\"\\n        :type s: List[str]\\n        :rtype: None Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        end = len(s) - 1\\n        \\n        def recursiveReverse(s, index):\\n            \\n            if index < len(s)/2:\\n                s[index], s[end-index] = s[end-index],s[index]\\n                index =  index + 1\\n                recursiveReverse(s,index)\\n            else:\\n                return\\n        \\n        recursiveReverse(s,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def reverseString(self, s):\\n        \"\"\"\\n        :type s: List[str]\\n        :rtype: None Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        end = len(s) - 1\\n        \\n        def recursiveReverse(s, index):\\n            \\n            if index < len(s)/2:\\n                s[index], s[end-index] = s[end-index],s[index]\\n                index =  index + 1\\n                recursiveReverse(s,index)\\n            else:\\n                return\\n        \\n        recursiveReverse(s,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301526,
                "title": "simple-java-solution-beats-100",
                "content": "Thought I could explain both iterative and the recursive solution here. The iterative solution is straight-forward since we want to run to the mid of the array swapping the start and the end of the array. Here is the code for that.\\n\\n```\\nprivate void iterative(char[] s) {\\n\\tint i = 0;\\n\\tint j = s.length-1;\\n\\twhile(i < j) {\\n\\t\\tchar temp = s[i];\\n\\t\\ts[i] = s[j];\\n\\t\\ts[j] = temp;\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}        \\n}\\n```\\n\\nThe recursive solution may be slightly tricky if we don\\'t the follow the similar path as above. The idea is is to traverse to the mid of the array by incrementing the start and decreasing the end and swapping all the way.\\n\\t\\n\\t\\n\\t\\n    \\n    private void recursive(char[] arr, int s, int e) {\\n        if (s >= e) {\\n            return;\\n        }\\n        recursive(arr,s+1, e-1);\\n        char temp = arr[e];\\n        arr[e] = arr[s];\\n        arr[s] = temp;\\n    }",
                "solutionTags": [],
                "code": "```\\nprivate void iterative(char[] s) {\\n\\tint i = 0;\\n\\tint j = s.length-1;\\n\\twhile(i < j) {\\n\\t\\tchar temp = s[i];\\n\\t\\ts[i] = s[j];\\n\\t\\ts[j] = temp;\\n\\t\\ti++;\\n\\t\\tj--;\\n\\t}        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 284962,
                "title": "javascript-99",
                "content": "```\\nvar reverseString = function(s) {\\n    if(s.length==1) return s;\\n    let p1 = Math.floor(s.length/2)-1;\\n    let p2 = s.length % 2 == 0 ? Math.floor(s.length/2) : Math.floor(s.length/2)+1;\\n    while(p1>=0){\\n        [s[p1], s[p2]] = [s[p2], s[p1]];\\n        p1--;\\n        p2++;\\n    }\\n    return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar reverseString = function(s) {\\n    if(s.length==1) return s;\\n    let p1 = Math.floor(s.length/2)-1;\\n    let p2 = s.length % 2 == 0 ? Math.floor(s.length/2) : Math.floor(s.length/2)+1;\\n    while(p1>=0){\\n        [s[p1], s[p2]] = [s[p2], s[p1]];\\n        p1--;\\n        p2++;\\n    }\\n    return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260796,
                "title": "go-using-recursion",
                "content": "This question was posed in the context of recursion, so I solved for it without a loop. Its performance was not great.\\n\\n```\\nfunc reverseString(s []byte)  {\\n\\tif len(s) <= 1 {\\n\\t\\treturn\\n\\t}\\n\\n\\ts[0], s[len(s)-1] = s[len(s)-1], s[0]\\n\\treverseString(s[1:len(s)-1])    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc reverseString(s []byte)  {\\n\\tif len(s) <= 1 {\\n\\t\\treturn\\n\\t}\\n\\n\\ts[0], s[len(s)-1] = s[len(s)-1], s[0]\\n\\treverseString(s[1:len(s)-1])    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 80963,
                "title": "java-using-xor",
                "content": "```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        if(s == null) return \"\";\\n        \\n        char[] rev = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i < j) {\\n            rev[i] ^= rev[j];\\n            rev[j] ^= rev[i];\\n            rev[i++] ^= rev[j--];\\n        }\\n        \\n        return String.valueOf(rev);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public String reverseString(String s) {\\n        if(s == null) return \"\";\\n        \\n        char[] rev = s.toCharArray();\\n        int i = 0, j = s.length() - 1;\\n        while(i < j) {\\n            rev[i] ^= rev[j];\\n            rev[j] ^= rev[i];\\n            rev[i++] ^= rev[j--];\\n        }\\n        \\n        return String.valueOf(rev);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 81208,
                "title": "python-one-line-solution",
                "content": "\\n\\n\\n    return s[::-1]\\n\\n    return ''.join(reversed(list(s)))",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\n\\n\\n    return s[::-1]\\n\\n    return ''.join(reversed(list(s)))",
                "codeTag": "Unknown"
            },
            {
                "id": 3933321,
                "title": "3-lines-c-code",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=0; i<n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n= s.size();\\n        for(int i=0; i<n/2; i++){\\n            swap(s[i],s[n-i-1]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850987,
                "title": "python3-two-word-answer-not-a-single-line-beats-99-89",
                "content": "# Intuition\\njust make a copy of its own list\\n# Approach\\nReversing a list in place\\n\\n# Complexity\\n- Time complexity:\\nO[1]\\n\\n- Space complexity:\\nO[1]\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s[:] = s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644079,
                "title": "344-reverse-string-100-easy-java-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        StringBuffer sb = new StringBuffer();\\n        sb.append(s);\\n        sb.reverse();\\n\\n        for (int i = 0; i < s.length; i++) {\\n            s[i] = sb.charAt(i);\\n        }\\n  }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        StringBuffer sb = new StringBuffer();\\n        sb.append(s);\\n        sb.reverse();\\n\\n        for (int i = 0; i < s.length; i++) {\\n            s[i] = sb.charAt(i);\\n        }\\n  }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3473499,
                "title": "simple-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int size = s.length;\\n        for(int i = 0, j = size - 1; i < size/2; i++){\\n            swap(s, i, j--);\\n        }\\n    }\\n\\n    public void swap(char[] s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int size = s.length;\\n        for(int i = 0, j = size - 1; i < size/2; i++){\\n            swap(s, i, j--);\\n        }\\n    }\\n\\n    public void swap(char[] s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422735,
                "title": "java-easy-solution-using-recursion",
                "content": "\\n\\n# Approach\\n```\\nUsing Recursion\\n```\\nHope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        reverse(s,0,s.length-1);    \\n    }\\n\\n    static char[] reverse(char[] s, int start, int end){\\n        //when the character array is reversed (i.e. start and end pointers cross the mid) \\n        if(start>end){\\n            return s;\\n        }\\n\\n        //swapping character at start with character at end \\n        char temp= s[start];\\n        s[start]= s[end];\\n        s[end]= temp;\\n        \\n        //recalling the function with start+1 and end-1 as start and end value\\n        reverse( s, start+1, end-1);\\n        return s;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nUsing Recursion\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        reverse(s,0,s.length-1);    \\n    }\\n\\n    static char[] reverse(char[] s, int start, int end){\\n        //when the character array is reversed (i.e. start and end pointers cross the mid) \\n        if(start>end){\\n            return s;\\n        }\\n\\n        //swapping character at start with character at end \\n        char temp= s[start];\\n        s[start]= s[end];\\n        s[end]= temp;\\n        \\n        //recalling the function with start+1 and end-1 as start and end value\\n        reverse( s, start+1, end-1);\\n        return s;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401429,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public void reverseString(char[] s) \\n    {\\n         char temp;\\n         for(int i=0,j=s.length-1;i<s.length/2;i++,j--)\\n         {\\n            temp=s[i];\\n            s[i]=s[j];\\n            s[j]=temp;\\n         }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void reverseString(char[] s) \\n    {\\n         char temp;\\n         for(int i=0,j=s.length-1;i<s.length/2;i++,j--)\\n         {\\n            temp=s[i];\\n            s[i]=s[j];\\n            s[j]=temp;\\n         }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396858,
                "title": "two-pointer-beginner-friendly-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep \\'i\\' at first and \\'j\\' at last then swap them , as long as i<j or i==j(when the string will be of odd size, it will aslo be needed for the middle element).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n};\\n```\\n# Please Upvote if you find it helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272407,
                "title": "java-solution-runtime-1-ms",
                "content": "\\n\\n# Approach\\n- Stores the reverse of the array s in array s1.(1st for loop)\\n- Stores the reversed array s1 in array s.(2nd for loop)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(2n) = O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l=s.length;\\n        char letter;\\n        int c=0;\\n        char [] s1=new char[l];\\n        for(int i=l-1;i>=0;i--)\\n        {\\n            letter=s[i];\\n            s1[c]=s[i];\\n            c++;\\n        }\\n        for (int i=0;i<l;i++)\\n            s[i]=s1[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int l=s.length;\\n        char letter;\\n        int c=0;\\n        char [] s1=new char[l];\\n        for(int i=l-1;i>=0;i--)\\n        {\\n            letter=s[i];\\n            s1[c]=s[i];\\n            c++;\\n        }\\n        for (int i=0;i<l;i++)\\n            s[i]=s1[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251934,
                "title": "java-easy-simple-solution",
                "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int l = s.length;\\n        char ch = \\' \\';\\n\\n        for (int i = 0; i < l / 2; i++) {\\n            ch = s[i];\\n        \\n            s[i] = s[l - (i+1)];\\n            s[l - (i+1)] = ch;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        \\n        int l = s.length;\\n        char ch = \\' \\';\\n\\n        for (int i = 0; i < l / 2; i++) {\\n            ch = s[i];\\n        \\n            s[i] = s[l - (i+1)];\\n            s[l - (i+1)] = ch;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208173,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # s[:]= s[::-1]\\n        start, end = 0, len(s)-1\\n        while(start<end):\\n            s[start], s[end] = s[end], s[start]\\n            start +=1\\n            end -=1\\n  \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        # s[:]= s[::-1]\\n        start, end = 0, len(s)-1\\n        while(start<end):\\n            s[start], s[end] = s[end], s[start]\\n            start +=1\\n            end -=1\\n  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126634,
                "title": "java-three-approach-recursive-solution-iterative-solution",
                "content": "\\n# Solution 1\\n```\\nclass Solution {        \\n    void swap(char[]arr, int a, int b){\\n        char temp=arr[a];\\n        arr[a]=arr[b];\\n        arr[b]=temp;\\n    }\\n    public void reverseString(char[] s) {\\n        int f=0;\\n        int l=s.length-1;\\n        while(l>f){\\n            swap(s, f, l);\\n            f++;\\n            l--;\\n        }\\n    }\\n}\\n```\\n\\n# Solution 2(Recursive solution)\\n```\\n\\nclass Solution {            \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        if(high-low+1<=1) return;\\n        swap(s, low, high);\\n        foo(s, low+1, high-1);\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```\\n\\n# Solution 3\\n\\n```\\nclass Solution {         \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        while(high>low){\\n            swap(s, low, high);\\n            high--;\\n            low++;\\n        }\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {        \\n    void swap(char[]arr, int a, int b){\\n        char temp=arr[a];\\n        arr[a]=arr[b];\\n        arr[b]=temp;\\n    }\\n    public void reverseString(char[] s) {\\n        int f=0;\\n        int l=s.length-1;\\n        while(l>f){\\n            swap(s, f, l);\\n            f++;\\n            l--;\\n        }\\n    }\\n}\\n```\n```\\n\\nclass Solution {            \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        if(high-low+1<=1) return;\\n        swap(s, low, high);\\n        foo(s, low+1, high-1);\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```\n```\\nclass Solution {         \\n    static char[] swap(char[] s, int a,int b ){\\n        char temp=s[a];\\n        s[a]=s[b];\\n        s[b]=temp;\\n        return s;\\n    }\\n    void foo(char[] s, int low, int high){\\n        while(high>low){\\n            swap(s, low, high);\\n            high--;\\n            low++;\\n        }\\n    }\\n    public void reverseString(char[] s) {\\n        foo(s, 0, s.length-1);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122269,
                "title": "2-approaches-using-1-pointer-and-2-pointers",
                "content": "# Approach 1 (Using 1 pointer)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a for loop to iterate through the string. It then swaps the first and last characters, then second and second-to-last, etc. until it reaches the middle of the string.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n    for(int i=0; i<n/2;i++){\\n        char temp = s[n-i-1];\\n    s[n-i-1]=s[i];\\n    s[i]=temp;\\n    }\\n    }\\n}\\n```\\n\\n# Approach 2 (Two-pointers)\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a while loop to swap the first and last characters of the string. It then increments i and decrements j, so that the next time through the loop, it will swap the second and second-to-last characters. This continues until i is greater than or equal to j.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i=0;\\n        int j=s.length-1;\\n        while(i<j){\\n            char temp = s[i];\\n            s[i]= s[j];\\n            s[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n    for(int i=0; i<n/2;i++){\\n        char temp = s[n-i-1];\\n    s[n-i-1]=s[i];\\n    s[i]=temp;\\n    }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int i=0;\\n        int j=s.length-1;\\n        while(i<j){\\n            char temp = s[i];\\n            s[i]= s[j];\\n            s[j]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102401,
                "title": "java-1sm",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low = 0, high = s.length-1;\\n        while(low<=high){\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low = 0, high = s.length-1;\\n        while(low<=high){\\n            char temp = s[low];\\n            s[low] = s[high];\\n            s[high] = temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099243,
                "title": "c-4-approaches-recursion-two-pointers-stack-and-vector-1-line-solution-easy",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code - 1 - Using RECURSION\\n```\\nclass Solution {\\npublic:\\n    void reverse (string &str, int start, int end)\\n    {\\n        // base case - condition to stop recursion - when the string is completely swapped\\n        if (start > end)\\n        {\\n            return ; \\n        }\\n        \\n        // ek case solve krdo baaki recursion lagado \\n        swap(str[start], str[end]) ;\\n        start ++; \\n        end --;\\n\\n        // recursive call\\n        reverse(str, start , end) ;\\n    }\\n    void reverseString(vector<char>& s) {\\n        string str ;\\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            str += s[i] ;\\n        }\\n\\n        reverse (str, 0, str.length() - 1 ); \\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            s[i] = str[i] ; \\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$ - n is the length of the string \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ - no additional space used swapping done in the same input string \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - 2\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int size=s.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;     \\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(n)$$ - n is the length of the string \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ - additional space used in creating stack and a temporary string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code - 3 \\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> temp ; \\n        for (int i = 0  ; i < s.size() ; i++)\\n        {\\n            temp.push(s[i]);\\n        }\\n        vector<char> str ; \\n        for (int i = 0 ; i< s.size() ; i++)\\n        {\\n            str.push_back(temp.top());\\n            temp.pop();\\n        }\\n        s = str ; \\n    }\\n};\\n```\\n---\\n# Code - 4\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse (s.begin() , s.end()); \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023 (1).png](https://assets.leetcode.com/users/images/e3bac8f4-dfdf-4da5-87b7-ff156d028603_1674674117.7121313.png)\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverse (string &str, int start, int end)\\n    {\\n        // base case - condition to stop recursion - when the string is completely swapped\\n        if (start > end)\\n        {\\n            return ; \\n        }\\n        \\n        // ek case solve krdo baaki recursion lagado \\n        swap(str[start], str[end]) ;\\n        start ++; \\n        end --;\\n\\n        // recursive call\\n        reverse(str, start , end) ;\\n    }\\n    void reverseString(vector<char>& s) {\\n        string str ;\\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            str += s[i] ;\\n        }\\n\\n        reverse (str, 0, str.length() - 1 ); \\n        for (int i = 0 ; i < s.size() ; i++)\\n        {\\n            s[i] = str[i] ; \\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int size=s.size();\\n        int start=0;\\n        int end=size-1;\\n        while(start<=end){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;     \\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        stack<char> temp ; \\n        for (int i = 0  ; i < s.size() ; i++)\\n        {\\n            temp.push(s[i]);\\n        }\\n        vector<char> str ; \\n        for (int i = 0 ; i< s.size() ; i++)\\n        {\\n            str.push_back(temp.top());\\n            temp.pop();\\n        }\\n        s = str ; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse (s.begin() , s.end()); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068220,
                "title": "java-0ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low=0;\\n        int high=s.length-1;\\n        \\n        while (low<high){\\n            Character temp=s[low];\\n            s[low]=s[high];\\n            s[high]=temp;\\n            low++;high--;\\n            \\n        }\\n            \\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int low=0;\\n        int high=s.length-1;\\n        \\n        while (low<high){\\n            Character temp=s[low];\\n            s[low]=s[high];\\n            s[high]=temp;\\n            low++;high--;\\n            \\n        }\\n            \\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046564,
                "title": "c-solution-easiest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo Pointer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake one pointer from the start another from the end swap them and itrate forward and backward respectively until Both the pointers meet.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int n=s.size()-1;\\n        while(i<n){\\n            swap(s[i],s[n]);\\n            i++;\\n            n--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i=0;\\n        int n=s.size()-1;\\n        while(i<n){\\n            swap(s[i],s[n]);\\n            i++;\\n            n--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027083,
                "title": "python3-two-pointers-approach-and-using-string-function",
                "content": "# Code1 Using Two Pointers\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        l,r=0,len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n```\\n# Code2 Using Function\\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        l,r=0,len(s)-1\\n        while l<r:\\n            s[l],s[r]=s[r],s[l]\\n            l+=1\\n            r-=1\\n```\n```\\n\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3017968,
                "title": "c-solution-easy-and-simple-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        reverse(s.begin(),s.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2888083,
                "title": "c-easy-solution-simple-swapping",
                "content": "# Intuition\\nEasy to understand and two pointer approach.\\n\\n# Approach\\nA simple approach to run a loop which runs for n/2 times and for each iteration their is a swapping take place between the ith index  element and the element at (n-i-1)th index element.\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-i-1]);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        for(int i=0;i<s.size()/2;i++){\\n            swap(s[i],s[s.size()-i-1]);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826849,
                "title": "easy-java-two-pointers-xor-reverse-solution",
                "content": "# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0;\\n        int end = s.length - 1;\\n\\n        while(start < end) {\\n            s[start] ^= s[end];\\n            s[end] ^= s[start];\\n            s[start++] ^= s[end--];\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0;\\n        int end = s.length - 1;\\n\\n        while(start < end) {\\n            s[start] ^= s[end];\\n            s[end] ^= s[start];\\n            s[start++] ^= s[end--];\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799603,
                "title": "easy-clear-and-classic-solution-javascript",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0, right = s.length -1;\\n\\n    while( left <= right ) {\\n        let temp = s[right];\\n        s[right] = s[left]\\n        s[left] = temp\\n        left++;\\n        right--;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    let left = 0, right = s.length -1;\\n\\n    while( left <= right ) {\\n        let temp = s[right];\\n        s[right] = s[left]\\n        s[left] = temp\\n        left++;\\n        right--;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2781972,
                "title": "java-2-liner-solution",
                "content": "\\n```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for (int i = 0, j = s.length - 1; i < j; ++i, --j) {\\n            char t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        for (int i = 0, j = s.length - 1; i < j; ++i, --j) {\\n            char t = s[i];\\n            s[i] = s[j];\\n            s[j] = t;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736090,
                "title": "easy-c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start=0,end=s.size()-1;\\n        while(start<end){\\n            char temp=s[start];\\n            s[start++]=s[end];\\n            s[end--]=temp;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int start=0,end=s.size()-1;\\n        while(start<end){\\n            char temp=s[start];\\n            s[start++]=s[end];\\n            s[end--]=temp;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565421,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565227,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576342,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565778,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576863,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575420,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1568172,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1570092,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576630,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575562,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565421,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565227,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576342,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1565778,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576863,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575420,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1568172,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1570092,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1576630,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575562,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/reverse-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion, In-Place, $$\\mathcal{O}(N)$$ Space\n\n  \n**Approach 2:** Two Pointers, Iteration, $$\\mathcal{O}(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "hukun01",
                        "content": "There are basically two ways to solve this problem. \\n\\nOne is to use a StringBuilder, another is to reverse the underlying char array. \\n\\nFor C/C++ programmers, they may want to modify the input string if it's not constant, so to achieve O(1) space.\\n\\nHowever, for Java programmers, I don't see any improvement beyond O(n) time and space. This is no different from reversing an integer array...What's the point here?"
                    },
                    {
                        "username": "Matt17283940",
                        "content": "Two pointers is O(1) space complexity, no new data structure created"
                    },
                    {
                        "username": "likeshkrishnakaranammuralidhar",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "[@ravitejaDev](/ravitejaDev) thanks a lot!"
                    },
                    {
                        "username": "ravitejaDev",
                        "content": "[@OMOH_PA](/OMOH_PA) within function it will be changing, but s given is from outside the function. As mentioned in the question, u need to do in-place instead of overwriting s within the function. which doesn't make any change to outside list. \nu can use s[:] = s[::-1] instead of just s = s[::-1]"
                    },
                    {
                        "username": "OMOH_PA",
                        "content": "could any1 explain plz why \"s = s[::-1]\" not working...\nI mean if I print result of \ns = s[::-1] i'm gettting proper answer, but it does not work for the solution\n\n\ns =\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput\n[\"h\",\"e\",\"l\",\"l\",\"o\"]\nExpected\n[\"o\",\"l\",\"l\",\"e\",\"h\"]\nStdout\n['o', 'l', 'l', 'e', 'h']\n"
                    },
                    {
                        "username": "hankerkuo",
                        "content": "When I try to run the code with default Testcase, this error appeared, wondering what\\'s the problem here.\\nTestcase and code are default settings (python). ![image](https://assets.leetcode.com/users/hankerkuo/image_1583373557.png)\\n"
                    },
                    {
                        "username": "Hemant069",
                        "content": "\\n s.reverse()"
                    },
                    {
                        "username": "troysleet",
                        "content": "[@ajaiverma](/ajaiverma) That\\'s helpful to know, thanks!"
                    },
                    {
                        "username": "ajaiverma",
                        "content": "[@sozani](/sozani) most of the time, using built in functions are not allowed in interview, you have to create you own algorithm to solve the problem."
                    },
                    {
                        "username": "sozani",
                        "content": "Why don't the most of people  use this approach although I used it?Is it wrong or more space complexity"
                    },
                    {
                        "username": "fuxinwei",
                        "content": "I test with Python solution `s = s[::-1]` but it always got wrong. Does someone know the reason?"
                    },
                    {
                        "username": "Supreeth_HR",
                        "content": "[@Sanchit33](/Sanchit33) works for list as well"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "[@Sanchit33](/Sanchit33) It works in Local environment"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "[@Sanchit33](/Sanchit33) try this s[:] = s[::-1]"
                    },
                    {
                        "username": "Sanchit33",
                        "content": "This method only works for string"
                    },
                    {
                        "username": "ronilpatil",
                        "content": "Actually python create another reference in `s = s[ : : -1]` case, you want to modify in-place na ! Simply `s = s[ : : -1]` it will re-bind the name but `s[:]` will replace whatever previously inside the list. "
                    },
                    {
                        "username": "saugat263",
                        "content": "[@shivam1100](/shivam1100) hey shivam, can you explain how does python compiles and runs over here, i\\'m kinda confused"
                    },
                    {
                        "username": "shivam1100",
                        "content": "s[:] = s[::-1]"
                    },
                    {
                        "username": "bubbafat",
                        "content": "Even iterating over the array without updates times out."
                    },
                    {
                        "username": "hazemati",
                        "content": "So, just want to give some feedback on the C version of this. Usualliy when htis is asked, the size is not passed in, but it should be assumed that the string is null-terminated (thus the size can be gotten by using strlen."
                    },
                    {
                        "username": "Yodawgz0",
                        "content": "\\n###Runtime: 192 ms, faster than 98.57% of Python3 online submissions for Reverse String.\\n###Memory Usage: 19.1 MB, less than 6.54% of Python3 online submissions for Reverse String.\\nBut it is a memory hogger , as we are doubling the space requirement\\n\\n\\'\\'\\'\\n\\n    def reverseString(self, s: List[str]) -> None:\\n        s.extend(s[::-1])\\n        del s[:int(len(s)/2)]\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "navyaswarup2004",
                        "content": "Where is the print statement?\\n"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "not needed"
                    }
                ]
            },
            {
                "id": 1575430,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1575429,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1573170,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1573147,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1569090,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 2041985,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1576222,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1576135,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1576120,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1575431,
                "content": [
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    },
                    {
                        "username": "SathvikSunny",
                        "content": "\\'\\'\\'\\ndef reverseString(self, s: List[str]) -> None:\\n        s.reverse()\\n\\'\\'\\'"
                    },
                    {
                        "username": "poojaagrwl13",
                        "content": "\\n\\t\\t\\tfor i in range(len(s)-1):\\n\\t\\t\\t\\tn = s.pop()\\n\\t\\t\\t\\ts.insert(i, n)"
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [Simple C++ solution](/topic/43298/simple-c-solution)\\n\\nWhen I run this code, I met with a strange error with on test case, which is\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\"\\n\\nI believe it's leet-code's problem?"
                    },
                    {
                        "username": "Mayur_2912",
                        "content": "In case of python we can simply use reverse() method.\\neg. \\n    s.reverse()"
                    },
                    {
                        "username": "abdrhxyii",
                        "content": "I tried my solution for this in my vs code it worked as expected but when I did the same in the leet code it gave an error, Why ? "
                    },
                    {
                        "username": "IamGirishReddy",
                        "content": "please give the code "
                    },
                    {
                        "username": "silent-killer",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        print(s.reverse())"
                    },
                    {
                        "username": "chellaprabu21",
                        "content": "func test(_ s: inout [Character]){\\n     s = s.reversed()\\n}"
                    },
                    {
                        "username": "AbdessamadJadid",
                        "content": "i solved the problem by using the Array.Reverse function."
                    },
                    {
                        "username": "faang_engineer",
                        "content": "Not able to understand problem statement"
                    }
                ]
            },
            {
                "id": 1575180,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1574836,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1574461,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1573860,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1573531,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1573184,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1572546,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1572302,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1571614,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1571615,
                "content": [
                    {
                        "username": "baloo-the-bear",
                        "content": "A number of solutions possible for this. Question:\\n- is s.reverse() in Python not good enough answer for interview i.e. needs to be implemented?\\n- I tried \\n\\'\\'\\'\\ns = s[::-1] \\n\\'\\'\\'\\n\\nin python3 - and it does work reverse currectly. \\n>>> s\\n[\\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\']\\n>>> s = s[::-1]\\n>>> s\\n[\\'o\\', \\'l\\', \\'l\\', \\'e\\', \\'h\\']\\n>>> \\n\\nHowever leetcode gives that as an inorrect answer. Thoughts?\\n"
                    },
                    {
                        "username": "pushkarsaxena96",
                        "content": "s[:] = s[::-1] modifies the original string in place by reversing its content, while s = s[::-1] creates a new string object that contains the reversed elements of the original string."
                    },
                    {
                        "username": "enixzyrex",
                        "content": "Apparently this would create another reference of s\\ns = s[::-1]\\nwhereas this would modify it in place\\ns[:] = s[::-1]"
                    },
                    {
                        "username": "egek4",
                        "content": "reverse a string is misleading, i was expecting to use a StringBuilder etc."
                    },
                    {
                        "username": "mark30331",
                        "content": "...\\nwords= \"leetcodeisacommunityforcoders\"\\nprint(words[::-1])\\n\\n..."
                    },
                    {
                        "username": "gsethi2409",
                        "content": "[https://youtu.be/ynZoxE-k5-4](https://youtu.be/ynZoxE-k5-4)"
                    },
                    {
                        "username": "varunpne",
                        "content": "![image](https://assets.leetcode.com/users/varunpne/image_1584728434.png)\\n![image](https://assets.leetcode.com/users/varunpne/image_1584728468.png)\\n\\n\\nSo this happened !!!!"
                    },
                    {
                        "username": "jumshoos",
                        "content": "why this wont accept ?\\n\\n\\'\\'\\'\\ns = s[::-1]\\n\\'\\'\\'"
                    },
                    {
                        "username": "ASWINNATH123",
                        "content": " s[:] = s[::-1]"
                    },
                    {
                        "username": "jguan1",
                        "content": "The requirement is to do this in place, but so many approaches here have \"return\" statement. I wonder if the test cases might not be correctly designed. Any ideas?"
                    },
                    {
                        "username": "daralis",
                        "content": "\\n\\tpublic String reverseString(String s){\\n\\t\\treturn new StringBuffer(s).reverse().toString();\\n\\t}"
                    },
                    {
                        "username": "mlavergn",
                        "content": "There's no reason this string should fail:\\n\\n\"Snug & raw was I ere I saw war & guns.\"\\n\\nwhen returned as:\\n\\n\".snug & raw was I ere I saw war & gunS\"\\n\\nbut the evaluator for Golang escapes the result as:\\n\\n\".snug \\\\u0026 raw was I ere I saw war \\\\u0026 gunS\"\\n\\nI tried all the escaping mechanisms to get this to pass, but none helped. Looks like a Leetcode bug."
                    },
                    {
                        "username": "chenpku",
                        "content": "Re: [C++ two pointer.](/topic/57750/c-two-pointer)\\n\\nI got the following errors with myself's code. and I re-run your code and also got similar errors, which I think it's leet-code's problem?\\n\\nInput:\\n\"Marge\\nlet's \\\\\"went.\\\\\" I await news telegram.\"\\nOutput:\\n\".margelet swen tiawa I \\\\\".tnew\\\\\" s'tel ,egraM\"\\nExpected:\\n\".margelet swen tiawa I \".tnew\" s'tel ,egraM\""
                    }
                ]
            },
            {
                "id": 1571616,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1571617,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1570491,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1573868,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1573866,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 1572133,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2068834,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2062752,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2051796,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2049910,
                "content": [
                    {
                        "username": "weiliango",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "I read several answers, and I find most of us use swap to solve this problem. I have to say that string transfer to array and then swap is not a bad idea. However, if we can use stack to solve this problem, it may become much more easy.\\nFor stack, first you push string into stack, and then when you pop it, the first item you pop up is the last item you pushed in, which is the last item of the string. So after we pop up all the items, it is the reverse version of string.\\nI tried many times but I can't make an accept version and share the code to all of us. So I just post my idea and hope to discuss with you guys."
                    },
                    {
                        "username": "tahiraslammm",
                        "content": "\\ts.reverse()"
                    },
                    {
                        "username": "frostcs",
                        "content": "https://youtu.be/LdUnkfn1MII"
                    },
                    {
                        "username": "davidseek",
                        "content": "Hey friends,\\n\\nfor everyone having problem with this challenge,\\nI wrote a detailed explanation on how to tackle it in Swift:\\n\\nhttps://medium.com/@davidseek/leetcode-344-reverse-string-e66eb7aadf4d"
                    },
                    {
                        "username": "bao328",
                        "content": "return s[::-1]"
                    },
                    {
                        "username": "ramyadmz",
                        "content": "I saw it could be solved by in-place sorting. \\nSpecifically in Golang I saw  sort.SliceStable returns correct result but sort.Slice doesn\\'t. Wondering what is the reason?\\n\\n `func reverseString(s []byte)  {\\n    sort.SliceStable(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n\\n `func reverseString(s []byte)  {\\n    sort.Slice(s,func(i,j int)bool{\\n        return j<i\\n    })\\n}`\\n"
                    },
                    {
                        "username": "StrongerProgrammer7",
                        "content": "Why this code(1) faster than other(2). ATTENTION !THIS IS SPOILER IF YOU DIDN\\'T DECIDED  , DON\\'T WATCH!\\ncode 1\\n  `let i = 0;\\n    let j= s.length-1;\\nvar temp =\"\";\\n    while(i<j)\\n    {\\n        temp = s[i];\\n        s[i] = s[j];\\n        s[j] = temp;\\n        i++;\\n        j--;\\n    }    `\\ncode 2\\n `if(s.length===1)\\n        return;\\n    let left = 0;\\n    let right = s.length-1;\\n    while(left <right)\\n    {\\n        let temp = s[left];\\n        s[left] = s[right];\\n        s[right] = temp;\\n        left++;\\n        right--;\\n    } `"
                    },
                    {
                        "username": "user1283Yf",
                        "content": "Why are my Stdout and Ouput results different? \\n[image](https://drive.google.com/file/d/1gyXByRoWT3axef7_4yFnx-p8AkKpQ8GA/view?usp=sharing)"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "Easiest Question of my life.\\nI can\\'t believe leetcode actually has this level of easy questions. I thought leetcode easy questions were supposed to be hard too..."
                    }
                ]
            },
            {
                "id": 2049754,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 2049490,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 2022019,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1957394,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1948552,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1935915,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1934812,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1922181,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1896485,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1895520,
                "content": [
                    {
                        "username": "IamGirishReddy",
                        "content": " why am I getting output the same as input I tried with console.log I\\'m getting correct answer in my chrome console editor, please highlight my mistake Thank you in advance  `/**\\n * @param {character[]} s\\n * @return {void} Do not return anything, modify s in-place instead.\\n */\\nvar reverseString = function(s) {\\n    var temp = s;\\n    s=[];\\n    for(let i=temp.length-1;i>=0;i--){\\n        s.push(temp[i]);\\n       \\n    } \\n}; `"
                    },
                    {
                        "username": "user7408ET",
                        "content": "why i See\\no\\nl\\nl\\nl\\no\\n\\n=(((so sad"
                    },
                    {
                        "username": "juansymontano",
                        "content": "\"s.reverse()\"\\n\\ninterviewer: \"implement your own function, how about recursion\"\\n\\n*sweats*\\n\\nThis problem is a litmus test of whether or not a programmer will be replaced by chatgpt. This is not a test of our syntax."
                    },
                    {
                        "username": "charlie_599",
                        "content": "can someone tell me more optimised solution to this \\n\\n\\n`your inline code...your inline code...`\\nclass Solution {\\n    void swap(int i, int j,char[]s){\\n        char temp= s[i];\\n        s[i]=s[j];\\n        s[j]=temp; \\n    }\\n    public void reverseString(char[] s) {\\n        \\n        for(int i=0; i<(s.length)/2; i++){\\n            swap(i,s.length-1-i,s);\\n        }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "critango",
                        "content": "In Ruby, you can get the same output just joining the array into a string, then reversing the string, and splitting it back to an array. However the solution is not accepted. Does that violate the in-place rule or something? It seems more efficient to split.reverse.join... could someone elaborate?"
                    },
                    {
                        "username": "RajeshKumarThankaraj",
                        "content": "return s.reverse()\\n\\nIs this not the right solution in JavaScript? why people are doing it differently?"
                    },
                    {
                        "username": "ivozayas",
                        "content": "I tried my code on VS and it works, but here it throws the following error: \"Runtime Error\\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc\" "
                    },
                    {
                        "username": "xenojohn",
                        "content": "Doesn\\'t this problem become impossible for languages that have immutable strings?"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) Oh, my bad, I missed reading the question while replying to you. My solution was the same when I solved it lol \\n```\\n        n=(len(s)//2)\\n        for i in range(n):\\n            (s[i],s[-i-1])=(s[-1-i], s[i])\\n\\n        return s\\n\\n```"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) Please look up string immutability. The problem says to to it in-place but you cannot modify the elements of a string in Python.\\n\\nHowever, the input is a list, in this case you can and you don\\'t need to use fancy list comprehensions if you want to learn something:\\n\\n```\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l = len(s)\\n\\n        for i in range(l // 2):\\n            s[i], s[l - i - 1] = s[l - i - 1], s[i]\\n        \\n        return s\\n```"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "[@xenojohn](/xenojohn) well then you\\'re stating the obvious. i\\'m addressing the part where you said the problem is impossible just \\'cause they\\'re immutable. if you want to change the order, convert it into a list and proceed, otherwise string manipulation is the way string questions are solved"
                    },
                    {
                        "username": "xenojohn",
                        "content": "[@gdrag0n](/gdrag0n) i know that there are lots of solutions to this. but s[::-1] creates a new string. Strings in Python are immutable, therefore you cannot modify them directly, but rather reassign values to them"
                    },
                    {
                        "username": "gdrag0n",
                        "content": "Don\\'t need to change element positions, just manipulate the string. In py, for eg, using s[::-1] reverses the string"
                    },
                    {
                        "username": "ziadabdalla105",
                        "content": " \\nWhy is this not working here? it works on vscode\\n\\n`\\nvar reverseString = function(s) {\\n    let lastLetter = s.indexOf(s[s.length - 1])\\n\\n    let firstLetter = s.indexOf(s[0])\\n\\n    let arr = []\\n\\n    for(let i = lastLetter; i >= firstLetter; i--){\\n\\n    arr.push(s[i])\\n\\n    }\\n\\n    return arr\\n};\\n`"
                    },
                    {
                        "username": "yeedaKing",
                        "content": " `class Solution(object):\\n\\n    def reverseString(self, s):\\n        if len(s) == 1: return s\\n        else:\\n            return self.reverseString(s[1:]) + [s[0]]`\\n\\nwhy won\\'t this work for the case [\"h\",\"e\",\"l\",\"l\",\"o\"]?  I checked the input on Python IDLE, and it works fine.  What is wrong?"
                    },
                    {
                        "username": "chanputhi9899",
                        "content": "I also got the same error with this code"
                    }
                ]
            },
            {
                "id": 1862312,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1856884,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1847072,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836960,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1798962,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1786932,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1770922,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1765338,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1764680,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1763718,
                "content": [
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "Hi, I was wondering if I could actually use a different solution than the built-in functions so I tried to code a small alghorithm using something like a binary search and I came up to the one you can find below in the comments. Don\\'t actually know if its the best sol you can come up with, but  it was worh a try for a junior like me :)"
                    },
                    {
                        "username": "Stefano-Buzzoni",
                        "content": "`\n    \n class Solution:\n        \n        def reverseString(self, s: List[str]) -> None:\n            \n            left = 0\n            right = len(s) - 1\n\n            while left <= right:\n\n                s[left], s[right] = s[right], s[left]\n                left += 1\n                right -= 1\n`"
                    },
                    {
                        "username": "Msey",
                        "content": "s[i] ^= s[s.Length - 1 - i];\\ns[s.Length - 1 - i] ^= s[i];\\ns[i] ^= s[s.Length - 1 - i];\\n\\nThe end"
                    },
                    {
                        "username": "adityadixit7054",
                        "content": "We can use recursion here."
                    },
                    {
                        "username": "alikhanarman786",
                        "content": "java solution: \\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int start = 0 , end = s.length-1;\\n        char temp;\\n        while(start<=end){\\n            if(s[start] != s[end]){\\n                temp = s[start];\\n                s[start] = s[end];\\n                s[end] = temp;\\n            }\\n            start++;\\n            end--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int n = s.length;\\n        char b[] = new char[n];\\n        int j=n-1;\\n        for(int i=0;i<n;i++){\\n            b[i]=s[i];\\n        }\\n        for(int i=0;i<n;i++){\\n          //  b[i]=s[i];\\n          \\n            s[i]=b[j];\\n            j--;\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Gauravkr007",
                        "content": "Easiest and effective way to do it\\n\\nclass Solution {\\n    public void reverseString(char[] s) {\\n        int j =1;\\n       for(int i=0;i<s.length/2;i++){\\n           char temp = s[s.length-j];\\n           s[s.length-j] = s[i];\\n           s[i] = temp;\\n           j++;\\n       }\\n    }\\n}"
                    },
                    {
                        "username": "kk_205",
                        "content": "I   didn\\'t  get , when question says that input is given  in the array  form then why it  takes argument as a string only ??\\n I am beginner can anybody explain it?"
                    },
                    {
                        "username": "kk_205",
                        "content": "\"You must do this by modifying the input array in-place with O(1) extra memory.\"    what does it mean \" in place\" ??? plzz"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3071840/4-line-easy-solution-o-n-complexity/"
                    },
                    {
                        "username": "31703it",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n         int beg=0,end=s.size()-1,temp;\\n    while(beg<end)\\n    {\\n        temp=s[beg];\\n        s[beg]=s[end];\\n        s[end]=temp;\\n        beg++;\\n        end--;\\n    }\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760161,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1759002,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1753705,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1750046,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1749277,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1748502,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1740392,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1734151,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1734015,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1731977,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/reverse-string/solutions/3057671/js-linear-time-constant-space-explanation/\\n\\nLinear time with space efficient solution using two pointer and swapping values untill we reach middle of an array\\n"
                    },
                    {
                        "username": "ankit_k84",
                        "content": "any simple solution without swap?"
                    },
                    {
                        "username": "hongbinhe-leetcode",
                        "content": " `\nclass Solution\n{\npublic:\n  void reverseString(vector<char> &s)\n  {\n    for (int i = 0, j = s.size() - 1; i < s.size() / 2; i++, j--)\n    {\n      swap(s[i], s[j]);\n    }\n  }\n}; // time complexity: O(n), space complexity: O(1)\n`"
                    },
                    {
                        "username": "STALKER__404",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        int b = 0, k = s.length- 1 ;\\n        char temp;\\n            \\n        while(b<=k){\\n            temp = s[b];\\n            s[b] = s[k];\\n            s[k] = temp;\\n            ++b;\\n            --k;\\n        }\\n\\n        System.out.println(Arrays.toString(s));\\n\\n    }\\n}"
                    },
                    {
                        "username": "INTROVERTcoder",
                        "content": "i just wrote the simple for loop condition from int i=s.size()-1 to 0  and cout<<s[i];\\nbut than also it is showing wrong result and showing the similar string as input ..?\\nplss help whats wrong is doing i am "
                    },
                    {
                        "username": "danvac",
                        "content": "why i can\\'t use erase()?"
                    },
                    {
                        "username": "adsy",
                        "content": "I strongly believe that there are many incorrect test cases for this problem.\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "class Solution(object):\\n    def reverseString(self, s):\\n        return s.reverse()"
                    },
                    {
                        "username": "305057174a",
                        "content": "why this is rejected?i can run this code on my PyCharm\\n\\nfrom typing import List\\nclass Solution:\\n    def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        b=reversed(s)\\n        return list(b)"
                    },
                    {
                        "username": "Ahmed777Khalil",
                        "content": "    public void ReverseString(char[] s) {\\n        Array.Reverse(s);\\n    }"
                    }
                ]
            },
            {
                "id": 1729931,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1728178,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1725537,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1724436,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1722368,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1719522,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1714318,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1710659,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1709776,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1696468,
                "content": [
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/344_reverse_string.cpp"
                    },
                    {
                        "username": "Teja767",
                        "content": "we can update the given list using the python inbuild reverse funtion\\nlist.reverse()"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This is my first Question on leetCode\\nI understood how the input is taken it is very different from other platforms\\nI love the interface and overall experience"
                    },
                    {
                        "username": "sarvagya_jha",
                        "content": "int start=0;\\nint e=s.size()-1;\\nwhile(start<=e){\\n     swap(s[start++],s[e--]);\\n}"
                    },
                    {
                        "username": "mohamed_aichaoui",
                        "content": "easy one"
                    },
                    {
                        "username": "Sanjaykumar702",
                        "content": "class Solution {\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int n = s.size();\\n        int start = 0;\\n        int end = n-1;\\n        int mid= start + (end-start)/2;\\n        for (int i=0; i<=mid; i++){\\n            swap(s[start], s[end]);\\n            start++;\\n            end--;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "alphacz",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] result= new char[s.length];\\n        int j=0;\\n        for(int i=s.length;i<s.length;i--)\\n        {\\n            s[i]=result[j];\\n            j++;\\n        }\\n          return  result;\\n      \\n    }\\n}  \\n\\nLine 10: error: incompatible types: unexpected return value\\n       return  result; \\ncan anybody explain whats wrong with my solution\\n\\n"
                    },
                    {
                        "username": "MehulJ0806",
                        "content": "Do a in-place changes in array s itself.\\n"
                    },
                    {
                        "username": "karimomaya",
                        "content": "Simplest Javascript Solution\\n\\n\\n `\\nvar reverseString = function(s) {\\n    let start = 0;\\n    let end = s.length-1;\\n    \\n    \\n    while(start<end) {\\n        let temp = s[start];\\n        s[start++] = s[end];\\n        s[end--] = temp;\\n    }\\n};\\n`"
                    },
                    {
                        "username": "chetanpatil04102001",
                        "content": "class Solution {\\nprivate:\\n   void solve(vector<char>& s, int i,int n){\\n       if(i>=n/2) return ;\\n       swap(s[i],s[n-i-1]);\\n       solve(s,i+1,n);\\n   }\\n\\npublic:\\n    void reverseString(vector<char>& s) {\\n        int i = 0;\\n        int  n = s.size();\\n        solve(s,i,n);\\n        \\n    }\\n};"
                    },
                    {
                        "username": "saurabh_kumar10",
                        "content": "first make two pointer first pointer stand at 0th index and 2nd pointer stand at the last index, so you just have to swap these pointers till they do not cross each other.\\n\\nComplexity\\nTime complexity:\\no(N)\\n\\nSpace complexity:\\no (1)\\n\\ncode:\\nvoid reverseString(vector<char>& s) {\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<j){\\n            swap(s[i++],s[j--]);\\n        }\\n    }"
                    }
                ]
            },
            {
                "id": 1695343,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1686999,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1685417,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1679540,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1673323,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1673315,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1667248,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1664982,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1655758,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            },
            {
                "id": 1642440,
                "content": [
                    {
                        "username": "KoalaKeys",
                        "content": "This needs to be changed for python. In python strings are immutable so you cannot \"modify\" a string in-place."
                    },
                    {
                        "username": "suraj_achievers",
                        "content": "1st starting point =0(let) and end point lenth-1(let integer type).\\nand start a  loop till staring point is lessthen endpoint,\\nthen swap string increement and decrement\\n"
                    },
                    {
                        "username": "oppoa5sraj",
                        "content": "how can we implement this question using stack ? \\nAny reccommendation"
                    },
                    {
                        "username": "rishipurwar1",
                        "content": "Here is my solution for this problem but it\\'s not passing the test cases. Anyone please help me?\\n\\n```\\nvar reverseString = function(s) {\\n    if (s.length <= 1) return s;\\n    return reverseString(s.splice(1)) + s[0];\\n};\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java\\n ```\\nclass Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "uz-java",
                        "content": "Java   \\n`class Solution {\\n    public void reverseString(char[] s) {\\n            for (int i = 0; i < s.length/2; i++) {\\n            char a=s[i];\\n            s[i]=s[s.length-i-1];\\n            s[s.length-i-1]=a;\\n        }\\n    }\\n} `"
                    },
                    {
                        "username": "saksham4554",
                        "content": "simple and slick answer for this problem is (if u are using python only other language just get lost)\n `class Solution:\n    def reverseString(self, s: List[str]) -> None:\n        \"\"\"\n        Do not return anything, modify s in-place instead.\n        \"\"\"\n        s.reverse()\n        \n`"
                    },
                    {
                        "username": "Odegaa",
                        "content": "class Solution {\\n    public void reverseString(char[] s) {\\n        char[] chars = new char[s.length];\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s) {\\n            stack.push(c);\\n        }\\n        for (char i = 0; i < s.length; i++) {\\n            chars[i] = stack.pop();\\n        }\\n        System.out.println(Arrays.toString(chars));\\n    }\\n}\\n\\n\\nWHYYY???? Java?????"
                    },
                    {
                        "username": "Shivam_Singh_786",
                        "content": "def reverseString(self, s: List[str]) -> None:\\n        \"\"\"\\n        Do not return anything, modify s in-place instead.\\n        \"\"\"\\n        l, r = 0,len(s) - 1\\n        while l < r:\\n            s[l], s[r] = s[r], s[l]\\n            l, r =l + 1, r -1"
                    },
                    {
                        "username": "wkwanyuen",
                        "content": "def test(s):\\n    reversed = \"\"\\n    for i in range(len(s)-1,-1,-1):\\n        reversed += s[i]\\n    return reversed\\n\\ni want to know why my solution not working in leetcode but work fine in ide"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sequence Reconstruction",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1564673,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1565990,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1566597,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1575723,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1570132,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1576378,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1572136,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1571708,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1571707,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1571863,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1564673,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1565990,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1566597,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1575723,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1570132,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1576378,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1572136,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1571708,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1571707,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            },
            {
                "id": 1571863,
                "content": [
                    {
                        "username": "yya119",
                        "content": "For the test case [1] [], why the answer is false? Since there is only one element, there is only one permutation and an empty seqs is consistent with this permutation. Some tricky test cases are really boring. "
                    },
                    {
                        "username": "codeninja16",
                        "content": "I dont know why but algorithm was fairly simple but the passing test cases was so frustating.\\nUnnecessary boundary checks and invalid items in sequence array which is not at all necessary.\\nMain time consuming part here was creating the graph correctly.\\n\\nCases like : \\n[1], [[],[]]\\nor [1,2,3], [[1,2], [2,3], [100000000]]\\nor [1], []\\n\\nSome of which I am not even sure what should be the corrext answer ans and are so unnecessary.\\nSpent 30 min testing and fixing corner cases.\\n\\n"
                    },
                    {
                        "username": "joe_yt",
                        "content": "test cases are just to frustrate you"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "If there is no solution article, how are we supposed to learn?\\n\\nIn fact the problem description is woefully inadequate. Does org contain all the numbers from 1 to n exactly once each where n is the length of the array? Does the order of the numbers in org matter? Are the members of seq in the order in which they appear in org? Can seq members contain jumbled up members of org? \\n\\nThe description is not adequate for the solving of the problem. This is very poor."
                    },
                    {
                        "username": "d00mer",
                        "content": "There are many insights you need to solve this question, the trickiest (imo) is having to make the connection between unique topological orderings and Hamiltonian Paths (that\\'s a pretty obscure fact tbh).\\n\\nThis should def not be a medium difficulty..\\n"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/5746d022-2f27-41ff-9578-884bd75b12cc_1644697467.0737545.png)\\n\\n![image](https://assets.leetcode.com/users/images/46b5896d-ca6b-40e0-8899-182a71e0b1de_1644697470.8120832.png)\\n"
                    },
                    {
                        "username": "fei26",
                        "content": "The expected answer of following test case is false\\n[1]\\n[[1,1]] \\n\\nwhy following case expecting \"AssertionError\" ? \\n[2]\\n[[2,2]] \\n\\nMy assumption is seqs should not contains duplicates. [[1,1]] and [[2,2]] would be invalid input."
                    },
                    {
                        "username": "leaper",
                        "content": "Suggest to add the test case below:\\n\\n[1,2,3]\\n[[1,2],[2,1],[1,3],[2,3]]\\n\\nI've checked some solutions which pass OJ but failed with this test case, which I believe is valid.\\n\\nThanks"
                    },
                    {
                        "username": "blake-st",
                        "content": "[1]\\n[[1,1]]\\nIf I understand correctly, we can reconstruct the only sequence [1] with sequence [1,1]. But the test cases indicates this is false. Any idea?"
                    },
                    {
                        "username": "Erick111",
                        "content": "This is a really very good problem, in the sense that it helps me practise BFS topological sort for a DAG. I rarely did BFS topological sort before. When I need to do a topotogical sort, I am always leaning to DFS as it's easier to to implement. This problem is really a good practice for me.\nHowever, if you look at the \"similar problem\" of this problem: course arrangement II. You won't see a test case with course number 10000000, or an empty pre-requisite pair. And there is a reason for this: we coders can focus on the logical (algorithmetic) aspect of this problem, rather than those weird test cases. \nOK, you may then talk to me like this: those weird test cases can occur in real world, in production mode. Yes, I know. But let's consider another scenario for the purpose of this discussion: in many other LC problems, we have a M*N matrix input represented as a 2-D array in JAVA, or a 2-D vector in C++. In those problems, do you really consider the scenario where the length of the first row is not equal to the length of the second row? We all know this is possible both in JAVA (where a 2-D array is an 1-D reference array consisting of many 1-D data array, and those 1-D data arrays can have whatever lengths they want) and C++ (where of course, different vectors can have different lengths), and I bet in real world, if you leave the customers to input whatever they want, they may challenge your code with those uneven-row-length 2-D matrix. However, when you work on LC problems, you don't consider that. Why? Because LC is more about logical! Sure, there are some test cases that we need to consider even for a logical exercise purpose, but I don't think we should go too far in that direction."
                    }
                ]
            }
        ]
    },
    {
        "title": "Output Contest Matches",
        "question_content": null,
        "solutions": [],
        "discussions": []
    },
    {
        "title": "Set Mismatch",
        "question_content": "<p>You have a set of integers <code>s</code>, which originally contains all the numbers from <code>1</code> to <code>n</code>. Unfortunately, due to some error, one of the numbers in <code>s</code> got duplicated to another number in the set, which results in <strong>repetition of one</strong> number and <strong>loss of another</strong> number.</p>\n\n<p>You are given an integer array <code>nums</code> representing the data status of this set after the error.</p>\n\n<p>Find the number that occurs twice and the number that is missing and return <em>them in the form of an array</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,2,4]\n<strong>Output:</strong> [2,3]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [1,1]\n<strong>Output:</strong> [1,2]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 105558,
                "title": "oneliner-python",
                "content": "Just comparing sums...\\n\\n    def findErrorNums(self, nums):\\n        return [sum(nums) - sum(set(nums)), sum(range(1, len(nums)+1)) - sum(set(nums))]",
                "solutionTags": [],
                "code": "Just comparing sums...\\n\\n    def findErrorNums(self, nums):\\n        return [sum(nums) - sum(set(nums)), sum(range(1, len(nums)+1)) - sum(set(nums))]",
                "codeTag": "Python3"
            },
            {
                "id": 105507,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\npublic static int[] findErrorNums(int[] nums) {\\n    int[] res = new int[2];\\n    for (int i : nums) {\\n        if (nums[Math.abs(i) - 1] < 0) res[0] = Math.abs(i);\\n\\telse nums[Math.abs(i) - 1] *= -1;\\n    }\\n    for (int i=0;i<nums.length;i++) {\\n        if (nums[i] > 0) res[1] = i+1;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] findErrorNums(int[] nums) {\\n    int[] res = new int[2];\\n    for (int i : nums) {\\n        if (nums[Math.abs(i) - 1] < 0) res[0] = Math.abs(i);\\n\\telse nums[Math.abs(i) - 1] *= -1;\\n    }\\n    for (int i=0;i<nums.length;i++) {\\n        if (nums[i] > 0) res[1] = i+1;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089475,
                "title": "python-o-n-time-o-1-space-math-solution-explained",
                "content": "We are given that we have numbers from `1` to `n` and some number `x` is here twice and another number `y` is missing. Let us calculate sum of all numbers and sum of squares of all numbes and given this information we can get our answer, using math! For this we need to use couple of facts:\\n\\n1. `1 + 2 + ... + n = n*(n+1)//2`. But even if you do not know this formula you can get it in `O(n)` time and `O(1)` space.\\n2. `1^2 + 2^2 + ... + n^2 = n*(n+1)*(2*n+1)//6`. Again if you do not know this formula, you can get it in `O(n)` time and `O(1)` space.\\n\\nNow, let us consider number `A = -sum(nums) + n*(n+1)//2`. It is equal to `y - x`, because each element not equal to `x` and `y` will be canceled out. In similar way if we define `B = -sum(i*i for i in nums) + n*(n+1)*(2*n+1)//6`, it will be equal to `y*y - x*x`. So, we have system of equations now:\\n\\n`A = y - x`\\n`B = y*y - x*x`.\\n\\nDividing one by another we have `B/A = y + x`, so `x = (B/A - A)/2` and `y = (B/A + A)/2`, which we just return.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is only `O(1)`.\\n\\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        A = -sum(nums) + n*(n+1)//2\\n        B = -sum(i*i for i in nums) + n*(n+1)*(2*n+1)//6\\n        return [(B-A*A)//2//A, (B+A*A)//2//A]\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        A = -sum(nums) + n*(n+1)//2\\n        B = -sum(i*i for i in nums) + n*(n+1)*(2*n+1)//6\\n        return [(B-A*A)//2//A, (B+A*A)//2//A]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105513,
                "title": "xor-one-pass",
                "content": "The idea is based on: \\n```(1 ^ 2 ^ 3 ^ .. ^ n) ^ (1 ^ 2 ^ 3 ^ .. ^ n) = 0```\\nSuppose we change 'a' to 'b', then all but 'a' and 'b' are XORed exactly 2 times. The result is then\\n```0 ^ a ^ b ^ b ^ b = a ^ b```\\nLet ```c = a ^ b```, if we can find 'b' which appears 2 times in the original array, 'a' can be easily calculated by ```a = c ^ b```.\\n\\n```\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        int[] count = new int[n];\\n        int[] ans = {0,0};\\n        for(int i = 0; i < n; i++) {\\n            ans[1] ^= (i+1) ^ nums[i];\\n            if (++count[nums[i]-1] == 2)\\n                ans[0] = nums[i];\\n        }\\n        ans[1] ^= ans[0];\\n        return ans;\\n    }\\n```\\nO(0) space:\\n```\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[2];\\n        for(int i = 0; i < nums.length; i++) {\\n            int val = Math.abs(nums[i]);\\n            ans[1] ^= (i+1) ^ val;\\n            if (nums[val-1] < 0) ans[0] = val;\\n            else nums[val-1] = -nums[val-1];\\n        }\\n        ans[1] ^= ans[0];\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```(1 ^ 2 ^ 3 ^ .. ^ n) ^ (1 ^ 2 ^ 3 ^ .. ^ n) = 0```\n```0 ^ a ^ b ^ b ^ b = a ^ b```\n```c = a ^ b```\n```a = c ^ b```\n```\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        int[] count = new int[n];\\n        int[] ans = {0,0};\\n        for(int i = 0; i < n; i++) {\\n            ans[1] ^= (i+1) ^ nums[i];\\n            if (++count[nums[i]-1] == 2)\\n                ans[0] = nums[i];\\n        }\\n        ans[1] ^= ans[0];\\n        return ans;\\n    }\\n```\n```\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[2];\\n        for(int i = 0; i < nums.length; i++) {\\n            int val = Math.abs(nums[i]);\\n            ans[1] ^= (i+1) ^ val;\\n            if (nums[val-1] < 0) ans[0] = val;\\n            else nums[val-1] = -nums[val-1];\\n        }\\n        ans[1] ^= ans[0];\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105515,
                "title": "c-6-lines-solution-with-explanation",
                "content": "The idea is using array indexing, that is putting  each ```nums[i]``` into the position with index ```nums[i] - 1```. Then, the array becomes [1,2,3,4,5...,n]. So we can find the duplicate number  when ```nums[i] != i+1```. \\n```\\nvector<int> findErrorNums(vector<int>& nums) {\\n        for(int i = 0; i<nums.size(); i++){\\n            while(nums[i] != nums[nums[i] - 1])swap(nums[i], nums[nums[i] - 1]);\\n        }\\n        for(int i = 0; i<nums.size() ; i++){\\n            if(nums[i] != i + 1)return {nums[i], i + 1};\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```nums[i]```\n```nums[i] - 1```\n```nums[i] != i+1```\n```\\nvector<int> findErrorNums(vector<int>& nums) {\\n        for(int i = 0; i<nums.size(); i++){\\n            while(nums[i] != nums[nums[i] - 1])swap(nums[i], nums[nums[i] - 1]);\\n        }\\n        for(int i = 0; i<nums.size() ; i++){\\n            if(nums[i] != i + 1)return {nums[i], i + 1};\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733774,
                "title": "python-3-3-lines-sets-t-m-97-44",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: list[int]) -> list[int]:\\n        \\n        n, a, b = len(nums), sum(nums), sum(set(nums))\\n\\t\\t\\n        s = n*(n+1)//2\\n        \\n        return [a-b, s-b]\\n```\\n\\n[https://leetcode.com/submissions/detail/828220488/](http://)",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: list[int]) -> list[int]:\\n        \\n        n, a, b = len(nums), sum(nums), sum(set(nums))\\n\\t\\t\\n        s = n*(n+1)//2\\n        \\n        return [a-b, s-b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387231,
                "title": "python-98-80-super-easy-math",
                "content": "```\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        s = n*(n+1)//2\\n        miss = s - sum(set(nums))\\n        duplicate = sum(nums) + miss - s\\n        return [duplicate, miss]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        n = len(nums)\\n        s = n*(n+1)//2\\n        miss = s - sum(set(nums))\\n        duplicate = sum(nums) + miss - s\\n        return [duplicate, miss]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 113999,
                "title": "c-true-o-1-space-o-n-time-no-input-modifying-with-clear-explanation",
                "content": "Since all those O(1) space solutions are modying the input array, here is an idea that doesn't do that:\\n\\nTake for example ```[1 2 3 2 5 6]```, and all numbers ```[1 2 3 4 5 6]```.\\nIn binary: ```[001 010 011 010 101 110]```, ```[001 010 011 100 101 110]```.\\n\\nNow, if we XOR the 2 arrays, we will get the XOR of our duplicate and missing number, because our duplicate number would appear 3 times (2 times in input array and 1 time in all number array), and the missing number 1 time (1 time in all number array). In our case, missing ^ duplicate = ```110```.\\n\\nNow, we know the missing and duplicate number are different in the first and second most significant bits (**11**0). So let's take the last one: 1**1**0 -> get last **1** -> 0**1**0.\\n\\nThen, we go through the arrays once again and split them in 2 categories, if they have that bit set or not:\\n```(x & 010) != 0```: ```[010 011 010 110], [010 011 110]``` -> XOR all of them and we get ```010```.\\n```(x & 010) == 0```: ```[001 101]```, ```[001 100 101]``` -> XOR all of them and we get ```100```.\\n\\n```010``` and ```100``` (2 and 4) are our duplicate and missing numbers, but we don't know which is which. Just go one more time through the array to see which one we can find, in our case: ```010```. So 2 is the duplicate, and 4 the missing one.\\n\\nThe downside is, of course, that we do 3 passes, but it is still, O(n) time.\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int p = 0, acc1 = 0, acc2 = 0;\\n        // Get the xor of missing and duplicate numbers\\n        for (unsigned i = 0; i < nums.size(); ++i)\\n            p ^= (i + 1) ^ nums[i];\\n\\n        p &= -p; // We'll use only the last significant set bit\\n\\n        // Split the numbers in 2 categories and xor them\\n        for (unsigned i = 0; i < nums.size(); ++i)\\n        {\\n            ((nums[i] & p) == 0) ? acc1 ^= nums[i] : acc2 ^= nums[i];\\n            (((i + 1) & p) == 0) ? acc1 ^= i + 1 : acc2 ^= i + 1;\\n        }\\n\\n        // Determine which is the duplicate number\\n        for (auto n : nums)\\n            if (n == acc1)\\n                return {acc1, acc2};\\n        return {acc2, acc1};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```[1 2 3 2 5 6]```\n```[1 2 3 4 5 6]```\n```[001 010 011 010 101 110]```\n```[001 010 011 100 101 110]```\n```110```\n```(x & 010) != 0```\n```[010 011 010 110], [010 011 110]```\n```010```\n```(x & 010) == 0```\n```[001 101]```\n```[001 100 101]```\n```100```\n```010```\n```100```\n```010```\n```C++\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int p = 0, acc1 = 0, acc2 = 0;\\n        // Get the xor of missing and duplicate numbers\\n        for (unsigned i = 0; i < nums.size(); ++i)\\n            p ^= (i + 1) ^ nums[i];\\n\\n        p &= -p; // We'll use only the last significant set bit\\n\\n        // Split the numbers in 2 categories and xor them\\n        for (unsigned i = 0; i < nums.size(); ++i)\\n        {\\n            ((nums[i] & p) == 0) ? acc1 ^= nums[i] : acc2 ^= nums[i];\\n            (((i + 1) & p) == 0) ? acc1 ^= i + 1 : acc2 ^= i + 1;\\n        }\\n\\n        // Determine which is the duplicate number\\n        for (auto n : nums)\\n            if (n == acc1)\\n                return {acc1, acc2};\\n        return {acc2, acc1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 105552,
                "title": "python-straightforward-with-explanation",
                "content": "Count each element.  We know the original elements must have been ```1, 2, ..., len(A)```.\\nOnce we have the counts, it is easy to scan through and see which element must have occurred twice, and which one never occurred.  \\n\\nIn our implementation, we could also use ```collections.Counter(A)```.\\n\\n```\\ndef findErrorNums(self, A):\\n    N = len(A)\\n    count = [0] * (N+1)\\n    for x in A:\\n      count[x] += 1\\n    for x in xrange(1, len(A)+1):\\n        if count[x] == 2:\\n            twice = x\\n        if count[x] == 0:\\n            never = x\\n    return twice, never\\n```\\n\\n<hr>\\n\\nBonus solution: Say ```(x, y)``` is the desired answer.  We know ```sum(A) - x + y = sum([1, 2, ..., N])```, and ```sum(x*x for x in A) - x*x + y*y = sum([1*1, 2*2, ..., N*N])```.  So we know ```x-y``` and ```x*x-y*y```.  Dividing the latter by ```x-y```, we know ```x+y```.  Hence, we know ```x``` and ```y```.\\n\\n```\\ndef findErrorNums(self, A):\\n    N = len(A)\\n    alpha = sum(A) - N*(N+1)/2\\n    beta = (sum(x*x for x in A) - N*(N+1)*(2*N+1)/6) / alpha\\n    return (alpha + beta) / 2, (beta - alpha) / 2\\n```",
                "solutionTags": [],
                "code": "```1, 2, ..., len(A)```\n```collections.Counter(A)```\n```\\ndef findErrorNums(self, A):\\n    N = len(A)\\n    count = [0] * (N+1)\\n    for x in A:\\n      count[x] += 1\\n    for x in xrange(1, len(A)+1):\\n        if count[x] == 2:\\n            twice = x\\n        if count[x] == 0:\\n            never = x\\n    return twice, never\\n```\n```(x, y)```\n```sum(A) - x + y = sum([1, 2, ..., N])```\n```sum(x*x for x in A) - x*x + y*y = sum([1*1, 2*2, ..., N*N])```\n```x-y```\n```x*x-y*y```\n```x-y```\n```x+y```\n```x```\n```y```\n```\\ndef findErrorNums(self, A):\\n    N = len(A)\\n    alpha = sum(A) - N*(N+1)/2\\n    beta = (sum(x*x for x in A) - N*(N+1)*(2*N+1)/6) / alpha\\n    return (alpha + beta) / 2, (beta - alpha) / 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 105528,
                "title": "simple-java-o-n-solution-hashset",
                "content": "Idea is to compute the sum mathematically first, and subtracting the elements from it. \\nFind the duplicate element, and add that to sum. \\n\\n    public int[] findErrorNums(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        int duplicate = 0, n = nums.length;\\n        long sum = (n * (n+1)) / 2;\\n        for(int i : nums) {\\n            if(set.contains(i)) duplicate = i;\\n            sum -= i;\\n            set.add(i);\\n        }\\n        return new int[] {duplicate, (int)sum + duplicate};\\n    }",
                "solutionTags": [],
                "code": "Idea is to compute the sum mathematically first, and subtracting the elements from it. \\nFind the duplicate element, and add that to sum. \\n\\n    public int[] findErrorNums(int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        int duplicate = 0, n = nums.length;\\n        long sum = (n * (n+1)) / 2;\\n        for(int i : nums) {\\n            if(set.contains(i)) duplicate = i;\\n            sum -= i;\\n            set.add(i);\\n        }\\n        return new int[] {duplicate, (int)sum + duplicate};\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2734799,
                "title": "c-set-mismatch-simple-easy-unique-solution-explained",
                "content": "The simple idea is that \\n1. We store the sum of all the elements in nums, say **initialSum**.\\n2. Put all the elements of nums in set to remove the duplicate element and store the sum of elements of set, say **sum**.\\n3. Difference of initialSum and sum will give us the **duplicate element**.\\n4. Calculate the sum of natural numbers from 1 to n using the formula n * (n + 1) / 2.\\n5. Difference of **sum of natural numbers** and **sum of elements of the set** will give us the **missing number**.\\n\\nTime to code.\\n```\\nvector<int> findErrorNums(vector<int>& nums) {\\n    //sum of elements on nums\\n    int initialSum = accumulate(nums.begin(), nums.end(), 0);\\n\\n    //put the element of nums into set to remove the duplicate number\\n    set<int> s;\\n    for(auto &i: nums){\\n        s.insert(i);\\n    }\\n\\n    //sum of elements of the set\\n    int sum = accumulate(s.begin(), s.end(), 0);\\n\\n    //difference of initialSum and sum will give us the repeated number\\n    int repeatedNum = initialSum - sum;\\n\\n    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number\\n\\tint n = nums.size();\\n    int missingNum = n * (n+1)/2 - sum;\\n\\n    return {repeatedNum, missingNum};\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> findErrorNums(vector<int>& nums) {\\n    //sum of elements on nums\\n    int initialSum = accumulate(nums.begin(), nums.end(), 0);\\n\\n    //put the element of nums into set to remove the duplicate number\\n    set<int> s;\\n    for(auto &i: nums){\\n        s.insert(i);\\n    }\\n\\n    //sum of elements of the set\\n    int sum = accumulate(s.begin(), s.end(), 0);\\n\\n    //difference of initialSum and sum will give us the repeated number\\n    int repeatedNum = initialSum - sum;\\n\\n    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number\\n\\tint n = nums.size();\\n    int missingNum = n * (n+1)/2 - sum;\\n\\n    return {repeatedNum, missingNum};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089560,
                "title": "js-python-java-c-updated-easy-o-1-space-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n(*Note: I\\'ve added another solution that has a better **space complexity** at **O(1)** extra space vs. the original solution below at **O(N)** extra space, but it does so at the cost of an extra iteration through **nums**, though the **time complexity** remains **O(N)**. Skip down to the **Alternate Idea** section for the breakdown.*)\\n\\nFor this problem, we can take advantage of some math, because one thing we know about a sequence of numbers from **1** to **N** is that their **sum** should equal the **N**th **triangular number** (**N * (N + 1) / 2**).\\n\\nSince the only difference between the ideal array ranging from **1** to **N** and our input array **nums** is the duplicated number, that means that the difference between the **sum** of **nums** and the **N**th triangular number is the same as the difference between our duplicated number (**dupe**) and the missing number.\\n\\nWe can easily find the duplicated number by utilizing a boolean array (**seen**) to keep track of which numbers have already been seen. While iterating through nums, whenever we come across a number for the second time, that number must be our **dupe**. We can also use this iteration to find the difference in the sums.\\n\\nThen we can just **return** the **dupe** and the **sum** difference applied to the **dupe** to identify the missing number.\\n\\n---\\n\\n#### ***Altnerate Idea:***\\n\\nIn order to solve this problem with **O(1)** extra space, we can use **nums** directly to keep track of which numbers have been seen so far. To do so, we need to be able to modify the elements of **nums** in such a way as to be easily able to obtain the original value again.\\n\\nOne of the easiest ways to do this is with the use of the **mod** operator (**%**). Since the largest value **nums[i]** is **10^4**, we can use that number as our base. By adding **10^4** to the value of an element, it can now tell us two things: the original value of the element (**num % 10^4**) and whether or not the number equal to the index has been seen (**num > 10^4**).\\n\\nSince the values in nums are **1-indexed** and nums itself is **0-indexed**, however, we\\'ll have to shift the mod function to **(nums - 1) % 10^4**.\\n\\nIf we iterate through **nums** and apply this addition, then at the end, we\\'ll know that the value that was seen twice will be **> 20000** and the number that was never seen is **< 10001**.\\n\\nSo we just have to iterate through **nums** a second time, check for these values, add them to our answer (**ans**), and then **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nJavascript doesn\\'t have a boolean array, so we can use the typed **Uint8Array()** as the closest stand-in. Python likewise doesn\\'t have a boolean array, so we\\'ll have to use a normal list.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 41.2MB** (beats 99% / 96%).\\n```javascript\\nvar findErrorNums = function(nums) {\\n    let N = nums.length, dupe, sum = N * (N + 1) / 2,\\n        seen = new Uint8Array(N+1)\\n    for (let i = 0; i < N; i++) {\\n        let num = nums[i]\\n        sum -= num\\n        if (seen[num]) dupe = num\\n        seen[num]++\\n    }\\n    return [dupe, sum + dupe]\\n};\\n```\\n\\n---\\n\\n#### ***Javascript Code w/ O(1) Extra Space:***\\n\\nThe best result for the code below is **80ms / 41.6MB** (beats 98% / 85%).\\n```javascript\\nvar findErrorNums = function(nums) {\\n    let N = nums.length, ans = [,]\\n    for (let i = 0; i < N; i++)\\n        nums[(nums[i] - 1) % 10000] += 10000\\n    for (let i = 0; i < N; i++)\\n        if (nums[i] > 20000) ans[0] = i + 1\\n        else if (nums[i] < 10001) ans[1] = i + 1\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **180ms / 15.4MB** (beats 94% / 94%).\\n```python\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        N, dupe = len(nums), 0\\n        seen, sumN = [0] * (N+1), N * (N+1) // 2\\n        for num in nums:\\n            sumN -= num\\n            if seen[num]: dupe = num\\n            seen[num] += 1\\n        return [dupe, sumN + dupe]\\n```\\n\\n---\\n\\n#### ***Python Code w/ O(1) Extra Space:***\\n\\nThe best result for the code below is **192ms / 15.1MB** (beats 75% / 100%).\\n```python\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        ans = [0,0]\\n        for num in nums:\\n            nums[(num - 1) % 10000] += 10000\\n        for i in range(len(nums)):\\n            if nums[i] > 20000: ans[0] = i + 1\\n            elif nums[i] < 10001: ans[1] = i + 1\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **1ms / 39.8MB** (beats 100% / 99%).\\n```java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int N = nums.length, sum = N * (N + 1) / 2;\\n        int[] ans = new int[2];\\n        boolean[] seen = new boolean[N+1];\\n        for (int num : nums) {\\n            sum -= num;\\n            if (seen[num]) ans[0] = num;\\n            seen[num] = true;\\n        }\\n        ans[1] = sum + ans[0];\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***Java Code w/ O(1) Extra Space:***\\n\\nThe best result for the code below is **2ms / 39.9MB** (beats 86% / 98%).\\n```java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int N = nums.length;\\n        int[] ans = new int[2];\\n        for (int num : nums)\\n            nums[(num - 1) % 10000] += 10000;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] > 20000) ans[0] = i + 1;\\n            else if (nums[i] < 10001) ans[1] = i + 1;\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **20ms / 21.4MB** (beats 99% / 90%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int N = nums.size(), sum = N * (N + 1) / 2;\\n        vector<int> ans(2);\\n        vector<bool> seen(N+1);\\n        for (int num : nums) {\\n            sum -= num;\\n            if (seen[num]) ans[0] = num;\\n            seen[num] = true;\\n        }\\n        ans[1] = sum + ans[0];\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***C++ Code w/ O(1) Extra Space:***\\n\\nThe best result for the code below is **20ms / 21.3MB** (beats 99% / 97%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int> ans(2);\\n        for (int num : nums)\\n            nums[(num - 1) % 10000] += 10000;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] > 20000) ans[0] = i + 1;\\n            else if (nums[i] < 10001) ans[1] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findErrorNums = function(nums) {\\n    let N = nums.length, dupe, sum = N * (N + 1) / 2,\\n        seen = new Uint8Array(N+1)\\n    for (let i = 0; i < N; i++) {\\n        let num = nums[i]\\n        sum -= num\\n        if (seen[num]) dupe = num\\n        seen[num]++\\n    }\\n    return [dupe, sum + dupe]\\n};\\n```\n```javascript\\nvar findErrorNums = function(nums) {\\n    let N = nums.length, ans = [,]\\n    for (let i = 0; i < N; i++)\\n        nums[(nums[i] - 1) % 10000] += 10000\\n    for (let i = 0; i < N; i++)\\n        if (nums[i] > 20000) ans[0] = i + 1\\n        else if (nums[i] < 10001) ans[1] = i + 1\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        N, dupe = len(nums), 0\\n        seen, sumN = [0] * (N+1), N * (N+1) // 2\\n        for num in nums:\\n            sumN -= num\\n            if seen[num]: dupe = num\\n            seen[num] += 1\\n        return [dupe, sumN + dupe]\\n```\n```python\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        ans = [0,0]\\n        for num in nums:\\n            nums[(num - 1) % 10000] += 10000\\n        for i in range(len(nums)):\\n            if nums[i] > 20000: ans[0] = i + 1\\n            elif nums[i] < 10001: ans[1] = i + 1\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int N = nums.length, sum = N * (N + 1) / 2;\\n        int[] ans = new int[2];\\n        boolean[] seen = new boolean[N+1];\\n        for (int num : nums) {\\n            sum -= num;\\n            if (seen[num]) ans[0] = num;\\n            seen[num] = true;\\n        }\\n        ans[1] = sum + ans[0];\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int N = nums.length;\\n        int[] ans = new int[2];\\n        for (int num : nums)\\n            nums[(num - 1) % 10000] += 10000;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] > 20000) ans[0] = i + 1;\\n            else if (nums[i] < 10001) ans[1] = i + 1;\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int N = nums.size(), sum = N * (N + 1) / 2;\\n        vector<int> ans(2);\\n        vector<bool> seen(N+1);\\n        for (int num : nums) {\\n            sum -= num;\\n            if (seen[num]) ans[0] = num;\\n            seen[num] = true;\\n        }\\n        ans[1] = sum + ans[0];\\n        return ans;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int> ans(2);\\n        for (int num : nums)\\n            nums[(num - 1) % 10000] += 10000;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] > 20000) ans[0] = i + 1;\\n            else if (nums[i] < 10001) ans[1] = i + 1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 179810,
                "title": "java-solution-beats-100-with-o-1-space",
                "content": "We calculate the sum of all numbers and the sum of squares. From it we subtract the actual sum.\\nIf \\'a\\' is repeated character and \\'b\\' is missing.\\nWe get sum = a-b and square_sum = a^2 - b^2.\\nusing these equations we find a and b.\\n```\\npublic int[] findErrorNums(int[] nums) {\\n        int sum = 0;\\n        int sqsum = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            sum+=nums[i]-(i+1);\\n            sqsum+=nums[i]*nums[i]-(i+1)*(i+1);\\n        }\\n        int n = nums.length;\\n        int diff = sum;\\n        sum = sqsum/sum;\\n        int a[] = new int[2];\\n        a[0] = (sum+diff)/2;\\n        a[1] = (sum-a[0]);\\n        return a;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findErrorNums(int[] nums) {\\n        int sum = 0;\\n        int sqsum = 0;\\n        for(int i = 0;i<nums.length;i++){\\n            sum+=nums[i]-(i+1);\\n            sqsum+=nums[i]*nums[i]-(i+1)*(i+1);\\n        }\\n        int n = nums.length;\\n        int diff = sum;\\n        sum = sqsum/sum;\\n        int a[] = new int[2];\\n        a[0] = (sum+diff)/2;\\n        a[1] = (sum-a[0]);\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733971,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDeclare a Counter before the for loop, so that you don\\'t need to use the count() function inside of the for loop, that would have the raised the complexity of the function form $$O(n)$$ to $$O(n^2)$$. Now initilaize an array with [0,0] so that you can reuse the index to store the values, 0th index for the dual number, 1st position for the non-existing number in nums. Inside of the for loop, now check if the number exists twice or once, using the counter that we declared before and then intialize the values accordingly.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        c=Counter(nums)\\n        l=[0,0]\\n        for i in range(1,len(nums)+1):\\n            if c[i]==2:\\n                l[0]=i\\n            if c[i]==0:\\n                l[1]=i\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        c=Counter(nums)\\n        l=[0,0]\\n        for i in range(1,len(nums)+1):\\n            if c[i]==2:\\n                l[0]=i\\n            if c[i]==0:\\n                l[1]=i\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090188,
                "title": "python-2-approaches",
                "content": "**Approach 1: Using map**\\n```python\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        seen = defaultdict(int)\\n        for x in nums:\\n            seen[x] += 1\\n        miss = dup = 0\\n        for i in range(1, n + 1):\\n            if i not in seen:\\n                miss = i\\n            elif seen[i] == 2:\\n                dup = i\\n        return [dup, miss]\\n```\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Approach 2: Constant space**\\nIdea: \\n- Traverse `nums` array, mark the number `x` seen by marking their index `nums[x-1]` to negative number, if meet negative number while traversing -> duplicate.\\n- Traverse `x` in range `1..n`, if `nums[x-1] > 0` -> missing.\\n```python\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        dup = miss = 0\\n        for x in nums:\\n            if nums[abs(x)-1] < 0:\\n                dup = abs(x)\\n            else:\\n                nums[abs(x)-1] *= -1\\n        for x in range(1, n+1):\\n            if nums[x-1] > 0:\\n                miss = x\\n                break\\n        return [dup, miss]\\n```\\nTime: `O(N)`\\nSpace: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        seen = defaultdict(int)\\n        for x in nums:\\n            seen[x] += 1\\n        miss = dup = 0\\n        for i in range(1, n + 1):\\n            if i not in seen:\\n                miss = i\\n            elif seen[i] == 2:\\n                dup = i\\n        return [dup, miss]\\n```\n```python\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        n = len(nums)\\n        dup = miss = 0\\n        for x in nums:\\n            if nums[abs(x)-1] < 0:\\n                dup = abs(x)\\n            else:\\n                nums[abs(x)-1] *= -1\\n        for x in range(1, n+1):\\n            if nums[x-1] > 0:\\n                miss = x\\n                break\\n        return [dup, miss]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733930,
                "title": "java-easy-soln-o-1-space-and-0-n-space",
                "content": "\\n1. O(n) Space soln ->\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        \\n        int dup = 0, miss = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        // find duplicate using set\\n        for(int i = 0; i < nums.length; ++i){\\n            if(set.contains(nums[i]))   dup = nums[i];\\n            set.add(nums[i]);\\n        }\\n        \\n        // find missing\\n        for(int i = 1; i <= nums.length; ++i){\\n            if(set.contains(i) == false){\\n                miss = i;\\n                break;\\n            }\\n        }\\n        \\n        return new int[]{dup, miss};\\n    }\\n}\\n```\\n\\n\\n2. O(1) space sol -> \\n\\n```\\nclass Solution {\\n    \\n    public void swap(int i, int j, int[] nums){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public int[] findErrorNums(int[] nums) {\\n        \\n        int n = nums.length;\\n        int i = 0;\\n        \\n        while(i < n){\\n            \\n            int idx = nums[i] - 1;\\n            \\n            if(nums[i] != nums[idx]){\\n                swap(i, idx, nums);\\n            }\\n            else{\\n                ++i;   \\n            }\\n        }\\n        \\n        for(i = 0; i < n; ++i){\\n            if(nums[i] != i + 1){\\n                return new int[]{nums[i], i + 1};\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        \\n        int dup = 0, miss = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        // find duplicate using set\\n        for(int i = 0; i < nums.length; ++i){\\n            if(set.contains(nums[i]))   dup = nums[i];\\n            set.add(nums[i]);\\n        }\\n        \\n        // find missing\\n        for(int i = 1; i <= nums.length; ++i){\\n            if(set.contains(i) == false){\\n                miss = i;\\n                break;\\n            }\\n        }\\n        \\n        return new int[]{dup, miss};\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public void swap(int i, int j, int[] nums){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public int[] findErrorNums(int[] nums) {\\n        \\n        int n = nums.length;\\n        int i = 0;\\n        \\n        while(i < n){\\n            \\n            int idx = nums[i] - 1;\\n            \\n            if(nums[i] != nums[idx]){\\n                swap(i, idx, nums);\\n            }\\n            else{\\n                ++i;   \\n            }\\n        }\\n        \\n        for(i = 0; i < n; ++i){\\n            if(nums[i] != i + 1){\\n                return new int[]{nums[i], i + 1};\\n            }\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090616,
                "title": "c-fastest-linear-solution-3-versions-compared-and-explained-100-time-90-space",
                "content": "Funny problem and one that really teaches you to squeeze all the info/hints you can get in the description.\\n\\nRuling out a lame and very expensive sorting approach - no fun at all, I decided to start with a linear solution that just checked each single element in the `1 - n` range.\\n\\nTo do so, we create first of all a few support variables:\\n* `len` will store the length of the input vector;\\n* `seen` is an array of `len + 1` booleans;\\n* `res` is a vector of 2 elements (since LC really seems to love vectors instead of pairs or tuples) where we will store our result.\\n\\nWe will then first of all set all the the cells from `1` to `len` (included) in `seen` to `false`.\\n\\nSuccessively, we will parse `nums` to either mark the cell matching value in `seen` if it is was not explored or assigning it as the first value in `res` if encountered before. Yes, I did it a bit hack-ish, just to have more fun.\\n\\nThe last step will have us check for the sole value in the `1 - len` range which was not marked in `seen` as the number that was not in the series and thus to be stored as the second one in `res`.\\n\\nOnce encounteres, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size();\\n        bool seen[len + 1];\\n        vector<int> res(2);\\n        // preparing seen\\n        for (int i = 1; i <= len; i++) seen[i] = false;\\n        // parsing nums and finding the first part of res\\n        for (int i: nums) seen[i] = (!seen[i] || bool(1 + (res[0] = i)));\\n        // parsing seen and finding the second part of res\\n        for (int i = 1; i <= len; i++) if (!seen[i]) return res[1] = i, res;\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image](https://assets.leetcode.com/users/images/2d5c8c13-e7e1-411d-ac41-968a509be4c6_1614731862.2765493.png)\\n\\n\\nVariant solution in which we use the second loop also to increase a new accumulator variable `tot` that will end up having the sum of all the elements in `nums`.\\n\\nOnce we have that, we can just remember that the Gaussian formula for sum of all the numbers in the `1 - len` range, which is `len * (len + 1) / 2`: that would have been the correct sum if not replacement of a number was ever done, so we can conclude that `len * (len + 1) / 2 == tot + res[0] - res[1]` (with `res[0]` as the repeated number which has been added and `res[1]` as the number which originally should have been there).\\n\\nReversing the formula we have that `res[1] == len * (len + 1) / 2 - tot + res[0]`.\\n\\nThe more efficient code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), tot = 0;\\n        bool seen[len + 1];\\n        vector<int> res(2);\\n        // preparing seen\\n        for (int i = 1; i <= len; i++) seen[i] = false;\\n        // parsing nums and finding the first part of res and to compute tot\\n        for (int i: nums) {\\n            tot += i;\\n            seen[i] = (!seen[i] || bool(1 + (res[0] = i)));\\n        }\\n        // computing the second part of res\\n        res[1] = len * (len + 1) / 2 - tot + res[0];\\n        return res;\\n    }\\n};\\n```\\n\\nBut do we really need extra memory? Well, probably no, if we notice that all the numbers which we will be given are positive, so we can use an old trick and flag the visited ones setting them to be negative.\\n\\nTo do so, we first of all declare a few variables: `len`, `tot` and `res`, same as above.\\n\\nWe will then parse each element `n` of `nums` and:\\n* be sure that `n` is positive, coverting it to its absolute value;\\n* increase `tot` by `n`, same as in the previous solution;\\n* deal with the edge case of `n == len`, setting `n` to `0` to handle overflow and cover also the first element;\\n* check if `nums[n]` is negative (ie: pointing to an already visited node):\\n\\t* if so, we set `res[0]` to `n` (or to `len`, if its original value was still `0`);\\n\\t* if not, we mark it as visited turning it to its negative value.\\n\\nOnce done, we can derive `res[1]` with the same magic used above and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), tot = 0;\\n        vector<int> res(2);\\n        // parsing nums\\n        for (int n: nums) {\\n            // normalising n\\n            n = abs(n);\\n            // increasing tot\\n            tot += n;\\n            // preventing overflow\\n            if (n == len) n = 0;\\n            // finding the duplicate or marking numbers as visited\\n            if (nums[n] < 0) res[0] = n ? n : len;\\n            else nums[n] *= -1;\\n        }\\n        // computing the missing element\\n        res[1] = (len + 1) * len / 2 - tot + res[0];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size();\\n        bool seen[len + 1];\\n        vector<int> res(2);\\n        // preparing seen\\n        for (int i = 1; i <= len; i++) seen[i] = false;\\n        // parsing nums and finding the first part of res\\n        for (int i: nums) seen[i] = (!seen[i] || bool(1 + (res[0] = i)));\\n        // parsing seen and finding the second part of res\\n        for (int i = 1; i <= len; i++) if (!seen[i]) return res[1] = i, res;\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), tot = 0;\\n        bool seen[len + 1];\\n        vector<int> res(2);\\n        // preparing seen\\n        for (int i = 1; i <= len; i++) seen[i] = false;\\n        // parsing nums and finding the first part of res and to compute tot\\n        for (int i: nums) {\\n            tot += i;\\n            seen[i] = (!seen[i] || bool(1 + (res[0] = i)));\\n        }\\n        // computing the second part of res\\n        res[1] = len * (len + 1) / 2 - tot + res[0];\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), tot = 0;\\n        vector<int> res(2);\\n        // parsing nums\\n        for (int n: nums) {\\n            // normalising n\\n            n = abs(n);\\n            // increasing tot\\n            tot += n;\\n            // preventing overflow\\n            if (n == len) n = 0;\\n            // finding the duplicate or marking numbers as visited\\n            if (nums[n] < 0) res[0] = n ? n : len;\\n            else nums[n] *= -1;\\n        }\\n        // computing the missing element\\n        res[1] = (len + 1) * len / 2 - tot + res[0];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090400,
                "title": "set-mismatch-java-100-rt-simple-and-explained-math",
                "content": "Question link: https://leetcode.com/explore/challenge/card/march-leetcoding-challenge-2021/588/week-1-march-1st-march-7th/3658/\\n\\nIdea behind this solution is based on formula for sum of first N natural numbers  = ```N * (N+1) / 2``` .\\n\\nAssume input arr is ```[1,2,3,1,5]```.\\n\\nTo find duplicate I\\'m using a visited boolean array of fixed size `10^4`. \\nIt\\'s guaranteed that we only have one duplicate and numbers range from `1` to `10^4`. \\nSimultaneously find out the sum of input natural numbers.\\n\\nIn the example we consider, \\n`sum = 1+2+3+1+5 = 12`, duplicate number is `1`,  and sum of natural numbers till 5 is `(5 * (5+1)) / 2 = 15`\\n\\nnow we add the difference of sum of first N natural numbers and input arr sum to duplicate to get the value missed in the sequence.\\n\\ni.e, `1 + (15 - 12) = 1 + 3 = 4` is the missed number in the sequence.\\n\\nBelow is the code:\\n```\\npublic int[] findErrorNums(int[] nums) {\\n\\tboolean[] visited = new boolean[10001];\\n\\tint duplicate = 0, sum = 0, n = nums.length;\\n\\tfor (int i: nums) {\\n\\t\\tif (visited[i]) {\\n\\t\\t\\tduplicate = i;\\n\\t\\t}\\n\\t\\tvisited[i] = true;\\n\\t\\tsum += i;\\n\\t}\\n\\tint nsum =  (n * (n+1)) / 2;\\n\\treturn new int[] {duplicate, duplicate + nsum - sum};\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```N * (N+1) / 2```\n```[1,2,3,1,5]```\n```\\npublic int[] findErrorNums(int[] nums) {\\n\\tboolean[] visited = new boolean[10001];\\n\\tint duplicate = 0, sum = 0, n = nums.length;\\n\\tfor (int i: nums) {\\n\\t\\tif (visited[i]) {\\n\\t\\t\\tduplicate = i;\\n\\t\\t}\\n\\t\\tvisited[i] = true;\\n\\t\\tsum += i;\\n\\t}\\n\\tint nsum =  (n * (n+1)) / 2;\\n\\treturn new int[] {duplicate, duplicate + nsum - sum};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441132,
                "title": "commented-faster-simple-easy-to-understand-javascript",
                "content": "**Please do upvote, it motivates me to write better posts\\uD83D\\uDE03**\\n\\n```\\n\\nvar findErrorNums = function(nums) {\\n    let len = nums.length;\\n//     Formula to calculate sum of Airthmetic series\\n    let sum = (len*(len+1))/2;\\n//     Now, just doing the other calculations required\\n    let s = 0, act = 0;\\n    let obj = {};\\n    for(let i of nums){\\n        if(obj[i]){\\n            act = i;\\n        }\\n        else{\\n            obj[i] = true;\\n            s+=i;\\n        }\\n    }\\n    return [act, sum - s];\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar findErrorNums = function(nums) {\\n    let len = nums.length;\\n//     Formula to calculate sum of Airthmetic series\\n    let sum = (len*(len+1))/2;\\n//     Now, just doing the other calculations required\\n    let s = 0, act = 0;\\n    let obj = {};\\n    for(let i of nums){\\n        if(obj[i]){\\n            act = i;\\n        }\\n        else{\\n            obj[i] = true;\\n            s+=i;\\n        }\\n    }\\n    return [act, sum - s];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735569,
                "title": "python-rust-c-fastest-0-ms-using-sums-trick-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a smart math trick with three sums. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. \\n\\n| Language | Runtime | Memory |\\n|---|---|---|\\n| [**Python**](https://leetcode.com/submissions/detail/828548647/) | **178 ms (99.89%)** | **15.8 MB  (60.69%)** |\\n| [**Rust**](https://leetcode.com/submissions/detail/828544033/) | **0 ms (100.00%)** | **2.1 MB (80.00%)** |\\n| [**C++**](https://leetcode.com/submissions/detail/828547936/) | **13 ms (100.00%)** | **22.4 MB  (37.46%)** |\\n\\n**Python.**\\n```python\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        \\n        # [1] sum of all numbers from 1 to n\\n        s = len(nums)*(len(nums)+1) // 2\\n        \\n        # [2] sum of all numbers in \\'nums\\'\\n        a = sum(nums)\\n        \\n        # [3] sum of unique numbers in \\'nums\\'\\n        u = sum(set(nums))\\n        \\n        # [4] the duplicate and missing numbers are\\n        return [a-u,s-u]\\n```\\n\\n**Rust.**\\n```rust\\nimpl Solution \\n{\\n    pub fn find_error_nums(nums: Vec<i32>) -> Vec<i32> \\n    {\\n        // [1] sum of all numbers from 1 to n\\n        let s = (nums.len()*(nums.len()+1) / 2) as i32;\\n        \\n        // [2] sum of \\'all nums\\' and \\'unique nums\\'\\n        let (mut a, mut u) = (0i32, 0i32);\\n        let mut fl = vec![1;10001];\\n        nums.into_iter()\\n            .for_each(|n| { a += n; u += n*fl[n as usize]; fl[n as usize] = 0; });\\n        \\n        // [3] the duplicate and missing numbers are\\n        vec![a-u,s-u]\\n    }\\n}\\n```\\n\\n**C++.**\\n```cpp\\nclass Solution \\n{\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        // [1] sum of all numbers from 1 to n\\n        int s = nums.size()*(nums.size()+1) / 2;\\n        \\n        // [2] sum of \\'all nums\\' and \\'unique nums\\'\\n        int a = 0, u = 0;\\n        vector<int> fl(nums.size()+1, 1);\\n        for (auto n : nums)\\n        {\\n            a += n; \\n            u += n*(fl[n]--);\\n        }\\n        \\n        // [3] the duplicate and missing numbers are\\n        return {a-u, s-u};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```python\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        \\n        # [1] sum of all numbers from 1 to n\\n        s = len(nums)*(len(nums)+1) // 2\\n        \\n        # [2] sum of all numbers in \\'nums\\'\\n        a = sum(nums)\\n        \\n        # [3] sum of unique numbers in \\'nums\\'\\n        u = sum(set(nums))\\n        \\n        # [4] the duplicate and missing numbers are\\n        return [a-u,s-u]\\n```\n```rust\\nimpl Solution \\n{\\n    pub fn find_error_nums(nums: Vec<i32>) -> Vec<i32> \\n    {\\n        // [1] sum of all numbers from 1 to n\\n        let s = (nums.len()*(nums.len()+1) / 2) as i32;\\n        \\n        // [2] sum of \\'all nums\\' and \\'unique nums\\'\\n        let (mut a, mut u) = (0i32, 0i32);\\n        let mut fl = vec![1;10001];\\n        nums.into_iter()\\n            .for_each(|n| { a += n; u += n*fl[n as usize]; fl[n as usize] = 0; });\\n        \\n        // [3] the duplicate and missing numbers are\\n        vec![a-u,s-u]\\n    }\\n}\\n```\n```cpp\\nclass Solution \\n{\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        // [1] sum of all numbers from 1 to n\\n        int s = nums.size()*(nums.size()+1) / 2;\\n        \\n        // [2] sum of \\'all nums\\' and \\'unique nums\\'\\n        int a = 0, u = 0;\\n        vector<int> fl(nums.size()+1, 1);\\n        for (auto n : nums)\\n        {\\n            a += n; \\n            u += n*(fl[n]--);\\n        }\\n        \\n        // [3] the duplicate and missing numbers are\\n        return {a-u, s-u};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089542,
                "title": "java-o-1-space-using-xor-explained-beats-100",
                "content": "Useful XOR properties:\\na ^ a = 0\\na ^ b = b ^ a\\na ^ 0 = 0 ^ a = 0\\na ^ (b ^ c) = (a ^ b) ^ c  = any other order of applying XOR among a, b and c\\n\\nSuppose the array contained each number from 1 to n and we took a bitwise XOR with all the numbers from 1 to n, the result would be 0 since pairs would get cancelled out.\\n```\\n(1 ^ 2 ^ 3 .... ^ n) ^ (1 ^ 2 ^ 3 .... ^ n) = (1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3) .... (n ^ n) = 0 ^ 0 ^ 0 ... ^ 0 = 0\\n```\\nNow, say one number ```a``` is duplicated and another number ```b``` is removed, the result would be ```a ^ b``` since one ```a``` and one ```b``` would be left without a pair.\\n```(1 ^ 2 ^ 3 ... a ^ a``` **(```a``` is duplicated)**``` .... (b-1) ^ (b+1)``` **(```b``` is missing)** ```... ^ n) ^ (1 ^ 2 ^ 3 .... ^ n) = (1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3) .... (a ^ a ^ a)``` **(3 ```a```\\'s while pairing)**``` .... ^ b``` **(only 1 ```b```)** ```.... (n ^ n) = 0 ^ 0 ^ 0 ... ^ (0 ^ a) ... ^ b ... ^ 0 = a ^ b```\\n\\nSince, ```a``` and ```b``` are different, ```a ^ b``` is non-zero hence it must have a 1 bit somewhere in its binary form. This 1 bit implies that ```a``` and ```b``` differ at this bit position. In other words, ```a``` has a bit 0 at that position and ```b``` has a bit 1 OR ```a``` has a bit 1 at that position and ```b``` has a bit 0.\\n\\nIf we were to take a XOR of only those numbers which have at a bit 1 at the same place where ```a ^ b``` also has a bit 1 (this applies to both the array and the sequence of 1 to n), then we\\'d get either ```a``` or ```b``` as the result.\\nReason is that we have segregated all the numbers into 2 piles (ones that have a bit 1 and the ones that don\\'t) where all the pairs still get cancelled out barring ```a``` and ```b``` but this time, ```a``` and ```b``` don\\'t get mixed up -- they belong to different piles.\\n\\nOnce we have one number be it ```a``` or ```b```, we can take XOR with the original ```a ^ b``` value to get the other number.\\n\\nWe can calculate rightmost 1 bit (although any 1 bit would work) by doing ```n & (~(n - 1))```. Here is how it works:\\n```\\nn              b b ... b b 1 0 0 0 0\\nn-1            b b ... b b 0 1 1 1 1\\n~(n-1)         b\\'b\\'... b\\'b\\'1 0 0 0 0\\nn & (~(n-1))   0 0 ... 0 0 1 0 0 0 0\\n```\\n\\n```\\n// 1 ms. 100%\\npublic int[] findErrorNums(int[] nums) {\\n    int xor = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        xor ^= nums[i] ^ (i + 1);\\n    }\\n    int diffBit = xor & (~(xor - 1)), a = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        if((diffBit & nums[i]) != 0) {\\n            a ^= nums[i];\\n        }\\n        if((diffBit & (i + 1)) != 0) {\\n            a ^= (i + 1);\\n        }\\n    }\\n    for(int num: nums) {\\n        if(num == a) {\\n            return new int[] {a, xor ^ a};\\n        }\\n    }\\n    return new int[] {xor ^ a, a};\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n(1 ^ 2 ^ 3 .... ^ n) ^ (1 ^ 2 ^ 3 .... ^ n) = (1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3) .... (n ^ n) = 0 ^ 0 ^ 0 ... ^ 0 = 0\\n```\n```a```\n```b```\n```a ^ b```\n```a```\n```b```\n```(1 ^ 2 ^ 3 ... a ^ a```\n```a```\n``` .... (b-1) ^ (b+1)```\n```b```\n```... ^ n) ^ (1 ^ 2 ^ 3 .... ^ n) = (1 ^ 1) ^ (2 ^ 2) ^ (3 ^ 3) .... (a ^ a ^ a)```\n```a```\n``` .... ^ b```\n```b```\n```.... (n ^ n) = 0 ^ 0 ^ 0 ... ^ (0 ^ a) ... ^ b ... ^ 0 = a ^ b```\n```a```\n```b```\n```a ^ b```\n```a```\n```b```\n```a```\n```b```\n```a```\n```b```\n```a ^ b```\n```a```\n```b```\n```a```\n```b```\n```a```\n```b```\n```a```\n```b```\n```a ^ b```\n```n & (~(n - 1))```\n```\\nn              b b ... b b 1 0 0 0 0\\nn-1            b b ... b b 0 1 1 1 1\\n~(n-1)         b\\'b\\'... b\\'b\\'1 0 0 0 0\\nn & (~(n-1))   0 0 ... 0 0 1 0 0 0 0\\n```\n```\\n// 1 ms. 100%\\npublic int[] findErrorNums(int[] nums) {\\n    int xor = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        xor ^= nums[i] ^ (i + 1);\\n    }\\n    int diffBit = xor & (~(xor - 1)), a = 0;\\n    for(int i = 0; i < nums.length; i++) {\\n        if((diffBit & nums[i]) != 0) {\\n            a ^= nums[i];\\n        }\\n        if((diffBit & (i + 1)) != 0) {\\n            a ^= (i + 1);\\n        }\\n    }\\n    for(int num: nums) {\\n        if(num == a) {\\n            return new int[] {a, xor ^ a};\\n        }\\n    }\\n    return new int[] {xor ^ a, a};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105520,
                "title": "java-solution-array-swap",
                "content": "Because numbers are from ```1``` to ```n```, after we put number ```i``` to index ```i - 1``` there's only 1 ```mis-matching``` which is the answer. Time complexity O(n). Space complexity O(1).\\n\\n```\\npublic class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] result = new int[2];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] - 1 != i && nums[nums[i] - 1] != nums[i]) {\\n                swap(nums, i, nums[i] - 1);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - 1 != i) {\\n                result[0] = nums[i];\\n                result[1] = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```1```\n```n```\n```i```\n```i - 1```\n```mis-matching```\n```\\npublic class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] result = new int[2];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[i] - 1 != i && nums[nums[i] - 1] != nums[i]) {\\n                swap(nums, i, nums[i] - 1);\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - 1 != i) {\\n                result[0] = nums[i];\\n                result[1] = i + 1;\\n                break;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735781,
                "title": "c-6-or-so-different-approaches",
                "content": "This is one of this simple problems that lends itself to being solved in many different ways. Please let me know if you have more ideas and _up-vote the post if you learned something new_, I certainly did when writing it up.\\n\\n# Approach 0: brute force\\n\\nNah, I am not doing brute force for this problem, but one could just do nested loops to count how often each number between $$1$$ and $$n$$ is present in the input. This leads to $$O(n^2)$$ time complexity and is left as an exercise to the reader. Peace! :)\\n\\n# Approach 1: frequency count\\n\\nWe could consider using an ```std::unordered_map``` or ```std::map```, but since we expect almost all elements to be present a ```std::vector``` is the best choice. By using an ```vector<char>``` instead of a ```vector<int>``` we can safe some memory, as the highest frequency we are expecting is 2.\\n\\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        const int n = size(nums);\\n        // The frequency is at most 2, hence a |char| is big enough, actually 2 bits would be enough.\\n        vector<char> freq(n + 1);\\n        for (int num : nums) ++freq[num];\\n        int dup = -1;\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (freq[i] == 2) {\\n                dup = i;\\n            } else if (freq[i] == 0) {\\n                miss = i;\\n            }\\n        }\\n        return {dup, miss};\\n    }\\n```\\n\\nIf we want to could add an _early exit_ in the second loop, i.e. stop when have found the duplicate and the missing number:\\n\\n```cpp\\n        int dup = -1;\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (freq[i] == 2) {\\n                dup = i;\\n                if (miss != -1) break;\\n            } else if (freq[i] == 0) {\\n                miss = i;\\n                if (dup != -1) break;\\n            }\\n        }\\n        return {dup, miss};\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ by the size of the input vector then the\\n  * Time complexity is $$O(n)$$ because we need to scan all the input and we need to scan the frequency vector, which are both of size $$n$$ and the\\n  * Space complexity is $$O(n)$$ for the frequency vector.\\n\\n\\n# Approach 2: seen bit\\n\\nInstead of frequency counting we just keep track if we have seen a number before, this is enough to identify the duplicate and the missing number. If we want we could replace ```vector<bool> seen(n + 1)``` with a fixed size ```bitset<10240> seen;```.\\n\\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        const int n = size(nums);\\n        vector<bool> seen(n + 1);\\n        int dup = -1;\\n        for (int num : nums) {\\n            if (seen[num]) dup = num;\\n            seen[num] = true;\\n        }\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!seen[i]) {\\n                miss = i;\\n                break;\\n            }\\n        }\\n        return {dup, miss};\\n    }\\n```\\n\\n**Complexity Analysis**\\nThe constant factors for the space complexity are lower for this approach, but otherwise the complexity analysis is the same as for approach 1.\\n\\n\\n# Approach 3: seen bit in-place\\n\\nIf we are willing to at least temporarily modify the input vector we can \"borrow\" the bits we need to keep track from the input vector, as the range of numbers is limited. For the first variant we are using bit 17 because the input range is limited to 10000.\\n\\n```cpp\\n    static vector<int> findErrorNums(vector<int>& nums) {\\n        const int n = size(nums);\\n        const int mask = 0xFFFF;\\n        const int seen = 1 << 17;\\n        int dup = -1;\\n        for (int num_and_seen : nums) {\\n            const int num = num_and_seen & mask;\\n            if (nums[num - 1] & seen) dup = num;\\n            nums[num - 1] |= seen;\\n        }\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!(nums[i - 1] & seen)) {\\n                miss = i;\\n                break;\\n            }\\n        }\\n        // Optional: reset |nums| again.\\n        for (int& num_and_seen : nums) num_and_seen &= mask;\\n        return {dup, miss};\\n    }\\n```\\n\\nA very common variant of this idea is the use the highest bit of an integer, i.e. the sign bit, which leads to an implementation like the following (details may vary):\\n\\n```cpp\\n    static vector<int> findErrorNums(vector<int>& nums) {\\n        const int n = size(nums);\\n        int dup = -1;\\n        for (int num_and_sign : nums) {\\n            const int num = abs(num_and_sign);\\n            if (nums[num - 1] < 0) {\\n                dup = num;\\n            } else {\\n                nums[num - 1] *= -1;\\n            }\\n        }\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (nums[i - 1] > 0) {\\n                miss = i;\\n                break;\\n            }\\n        }\\n        // Optional: reset |nums| again.\\n        for (int& num : nums) num = abs(num);\\n        return {dup, miss};\\n    }\\n```\\n\\n**Complexity Analysis**\\nThe difference to approach 1 and 2 is that we a \"borrowing\" bits from the input vector, so we could argue that the space complexity is $$O(1)$$.\\n \\n# Approach 4: sort and scan\\n\\nIf we would know that the input is already sorted we could just do a linear scan. However we don\\'t know for sure, and hence we sort the input before scanning it for the duplicate and the missing number. Note that this approach needs a bit of extra care if the first or the last number is missing. Doing an _early exit_ would still be possible though with a bit of extra state. NB this approach is modifying the input permanently, and if that\\'s not an option we would need to make a copy of the input first.\\n\\n```cpp\\n    static vector<int> findErrorNums(vector<int>& nums) {\\n        const int n = size(nums);\\n        // If we don\\'t want to modify the input permanently we would need to make a copy here.\\n        sort(begin(nums), end(nums));\\n        int dup = -1;\\n        int miss = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (nums[i - 1] == nums[i]) {\\n                dup = nums[i];\\n            } else if (nums[i - 1] + 1 < nums[i]) {\\n                miss = nums[i - 1] + 1;\\n            }\\n        }\\n        return {dup, nums.back() != n ? n : miss};\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ by the size of the input vector then the\\n  * Time complexity is $$O(n \\\\log n)$$ for sorting the input, the rest is $$O(n)$$, and the\\n  * Space complexity is $$O(1)$$.\\n\\n# Approach 5: math\\n\\nMy first instinct was that doing something based on the total sum of the first $$n$$ natural numbers, i.e. $$\\\\frac{n (n + 1)}{2}, but unless I am mistaken this would only give us a clue about the missing number, and we would still need another approach to find the duplicate or vs. Nevertheless if we are willing to compute the unique numbers in ```nums``` this could look like this:\\n\\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        const int sum = reduce(begin(nums), end(nums));\\n        const unordered_set<int> unique_nums(begin(nums), end(nums));\\n        const int unique_sum = reduce(begin(unique_nums), end(unique_nums));\\n        const int gauss = size(nums) * (size(nums) + 1) / 2;\\n        return {sum - unique_sum, gauss - unique_sum};\\n    }\\n```\\n\\nNote that we could use ```std::accumulate``` instead of ```std::reduce``` and that we need to extra space for the ```unordered_map```.\\n\\n**However**, I saw this post from @kanna17vce, which is using a different approach and is very clever and I learned something new today. :)\\n\\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        long diff = 0;\\n        long square_diff = 0;\\n        for (int i = 0; i < size(nums); ++i) {\\n            diff += i + 1 - nums[i];\\n            square_diff += (i + 1) * (i + 1) - nums[i] * nums[i];\\n        }\\n        long s = square_diff / diff;\\n        const int dup = (s - diff) / 2;\\n        const int miss = (s + diff) / 2;\\n        return {dup, miss};\\n    }\\n```\\n\\nBtw. @pankaj_777 posted [a variant of the this idea](https://leetcode.com/problems/set-mismatch/discuss/2733783/DAILY-LEETCODE-SOLUTION-oror-EASY-C%2B%2B-SOLUTION) which is maybe a bit easier to understand, but is a bit less robust against overflows.\\n\\n## Why and how does this approach work?\\n\\nLet\\'s assume $$m$$ is the missing number and $$d$$ is the duplicate.\\n\\nWe can observe that sum of all natural numbers from $$1$$ to $$n$$ minus the sum of all the elements in the array, will be $$m - d$$ as the missing number $$m$$ will be in the sum of all numbers and we have the duplicate twice in ```nums```, formally:\\n\\n$$\\\\sum_{i=1}^{n} i - \\\\sum_{i=0}^{n-1} nums[i] = \\\\sum_{i=0}^{n-1} (i + 1) - nums[i] = m - d = diff$$\\n\\nWe can make a similar observation for the sum of the squares, formally:\\n\\n$$\\\\sum_{i=1}^{n} i^2 - \\\\sum_{i=0}^{n-1} nums[i]^2 = \\\\sum_{i=0}^{n-1} (i + 1)^2 - nums[i]^2 = m^2 - d^2 = square\\\\_sum$$\\n\\nNow let $$s = square\\\\_sum / diff = \\\\frac{(m + d)(m - d)}{m - d} = m + d$$ with that $$m = \\\\frac{s + diff}{2} = \\\\frac{m + d + m - d}{2}$$ and $$d = \\\\frac{s - diff}{2} = \\\\frac{m + d - m + d}{2}$$. Maybe not the best formal proof, but it was good enough to convince myself that this approach works.\\n\\n**Complexity Analysis**\\nLet $$n$$ by the size of the input vector then the\\n  * Time complexity is $$O(n)$$ and the\\n  * Space complexity is $$O(1)$$.\\n\\n# Approach 6: using XOR\\n\\nThis is based on [a underrated solution](https://leetcode.com/problems/set-mismatch/discuss/1089545/C%2B%2B-%3A-Xor-solution-in-detail) by @morning_coder.\\n\\nTODO(heder): Outline how and why this works. It\\'s based on the same idea as finding a missing number in $$1$$ to $$n$$ and then we ```xor_value``` will not be zero we take one bit that\\'s set in there (w/o loss of generality we take the right most set bit) and look for numbers that have this bit set and take the xor value of those again. With that we are almost there we only need to decide now of this number is the duplicate or the missing number.\\n\\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        int xor_value = 0;\\n        for (int num : nums) xor_value ^= num;\\n        for (int i = 1; i <= size(nums); ++i) xor_value ^= i;\\n        const int rightmost_bit = xor_value & ~(xor_value - 1);\\n        int repeated_num = 0;\\n        for (int num : nums)\\n            if (num & rightmost_bit) repeated_num ^= num;\\n        for (int i = 1; i <= size(nums); ++i)\\n            if (i & rightmost_bit) repeated_num ^= i;\\n        if (find(begin(nums), end(nums), repeated_num) == end(nums)) {\\n            return {xor_value ^ repeated_num, repeated_num};\\n        } else {\\n            return {repeated_num, xor_value ^ repeated_num};\\n        }\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ by the size of the input vector then the\\n  * Time complexity is $$O(n)$$ and the\\n  * Space complexity is $$O(1)$$.\\n\\n# Approach 7: ${your idea goes here}\\n\\nPlease let me know if you have more ideas, I\\'d be more than happy to include it in this post.\\n\\n# Appendix\\n\\n  * Q: What\\'s the deal with ```static```?\\n  * A: We are not using any any member variables for the ```Solution``` class, hence we don\\'t need the implicit ```this``` pointer.\\n\\n  * Q: Why ```const```?\\n  * A: Just to make it explicit that the code isn\\'t modifying a variable. This has enabled the compiler in the past to point out stupid mistakes I made.\\n\\n  * Q: What\\'s the deal with ```static int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();```?\\n  * A: I always add this snippet at file scope for faster IO.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```std::unordered_map```\n```std::map```\n```std::vector```\n```vector<char>```\n```vector<int>```\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        const int n = size(nums);\\n        // The frequency is at most 2, hence a |char| is big enough, actually 2 bits would be enough.\\n        vector<char> freq(n + 1);\\n        for (int num : nums) ++freq[num];\\n        int dup = -1;\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (freq[i] == 2) {\\n                dup = i;\\n            } else if (freq[i] == 0) {\\n                miss = i;\\n            }\\n        }\\n        return {dup, miss};\\n    }\\n```\n```cpp\\n        int dup = -1;\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (freq[i] == 2) {\\n                dup = i;\\n                if (miss != -1) break;\\n            } else if (freq[i] == 0) {\\n                miss = i;\\n                if (dup != -1) break;\\n            }\\n        }\\n        return {dup, miss};\\n```\n```vector<bool> seen(n + 1)```\n```bitset<10240> seen;```\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        const int n = size(nums);\\n        vector<bool> seen(n + 1);\\n        int dup = -1;\\n        for (int num : nums) {\\n            if (seen[num]) dup = num;\\n            seen[num] = true;\\n        }\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!seen[i]) {\\n                miss = i;\\n                break;\\n            }\\n        }\\n        return {dup, miss};\\n    }\\n```\n```cpp\\n    static vector<int> findErrorNums(vector<int>& nums) {\\n        const int n = size(nums);\\n        const int mask = 0xFFFF;\\n        const int seen = 1 << 17;\\n        int dup = -1;\\n        for (int num_and_seen : nums) {\\n            const int num = num_and_seen & mask;\\n            if (nums[num - 1] & seen) dup = num;\\n            nums[num - 1] |= seen;\\n        }\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (!(nums[i - 1] & seen)) {\\n                miss = i;\\n                break;\\n            }\\n        }\\n        // Optional: reset |nums| again.\\n        for (int& num_and_seen : nums) num_and_seen &= mask;\\n        return {dup, miss};\\n    }\\n```\n```cpp\\n    static vector<int> findErrorNums(vector<int>& nums) {\\n        const int n = size(nums);\\n        int dup = -1;\\n        for (int num_and_sign : nums) {\\n            const int num = abs(num_and_sign);\\n            if (nums[num - 1] < 0) {\\n                dup = num;\\n            } else {\\n                nums[num - 1] *= -1;\\n            }\\n        }\\n        int miss = -1;\\n        for (int i = 1; i <= n; ++i) {\\n            if (nums[i - 1] > 0) {\\n                miss = i;\\n                break;\\n            }\\n        }\\n        // Optional: reset |nums| again.\\n        for (int& num : nums) num = abs(num);\\n        return {dup, miss};\\n    }\\n```\n```cpp\\n    static vector<int> findErrorNums(vector<int>& nums) {\\n        const int n = size(nums);\\n        // If we don\\'t want to modify the input permanently we would need to make a copy here.\\n        sort(begin(nums), end(nums));\\n        int dup = -1;\\n        int miss = 1;\\n        for (int i = 1; i < n; ++i) {\\n            if (nums[i - 1] == nums[i]) {\\n                dup = nums[i];\\n            } else if (nums[i - 1] + 1 < nums[i]) {\\n                miss = nums[i - 1] + 1;\\n            }\\n        }\\n        return {dup, nums.back() != n ? n : miss};\\n    }\\n```\n```nums```\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        const int sum = reduce(begin(nums), end(nums));\\n        const unordered_set<int> unique_nums(begin(nums), end(nums));\\n        const int unique_sum = reduce(begin(unique_nums), end(unique_nums));\\n        const int gauss = size(nums) * (size(nums) + 1) / 2;\\n        return {sum - unique_sum, gauss - unique_sum};\\n    }\\n```\n```std::accumulate```\n```std::reduce```\n```unordered_map```\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        long diff = 0;\\n        long square_diff = 0;\\n        for (int i = 0; i < size(nums); ++i) {\\n            diff += i + 1 - nums[i];\\n            square_diff += (i + 1) * (i + 1) - nums[i] * nums[i];\\n        }\\n        long s = square_diff / diff;\\n        const int dup = (s - diff) / 2;\\n        const int miss = (s + diff) / 2;\\n        return {dup, miss};\\n    }\\n```\n```nums```\n```xor_value```\n```cpp\\n    static vector<int> findErrorNums(const vector<int>& nums) {\\n        int xor_value = 0;\\n        for (int num : nums) xor_value ^= num;\\n        for (int i = 1; i <= size(nums); ++i) xor_value ^= i;\\n        const int rightmost_bit = xor_value & ~(xor_value - 1);\\n        int repeated_num = 0;\\n        for (int num : nums)\\n            if (num & rightmost_bit) repeated_num ^= num;\\n        for (int i = 1; i <= size(nums); ++i)\\n            if (i & rightmost_bit) repeated_num ^= i;\\n        if (find(begin(nums), end(nums), repeated_num) == end(nums)) {\\n            return {xor_value ^ repeated_num, repeated_num};\\n        } else {\\n            return {repeated_num, xor_value ^ repeated_num};\\n        }\\n    }\\n```\n```static```\n```Solution```\n```this```\n```const```\n```static int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();```",
                "codeTag": "C++"
            },
            {
                "id": 2734130,
                "title": "c-indexing-technique",
                "content": "```\\n//Youtube explanation : https://www.youtube.com/watch?v=j89Yzq3IwVY\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int dup     = -1;\\n        int missing = -1;\\n        \\n        for(int i = 0; i<n; i++) {\\n            int num = abs(nums[i]);\\n            \\n            if(nums[num-1] < 0)\\n                dup = num;\\n            else\\n                nums[num-1] *= (-1);\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(nums[i] > 0) {\\n                missing = i+1;\\n                break;\\n            }\\n        }\\n        \\n        return {dup, missing};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//Youtube explanation : https://www.youtube.com/watch?v=j89Yzq3IwVY\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int dup     = -1;\\n        int missing = -1;\\n        \\n        for(int i = 0; i<n; i++) {\\n            int num = abs(nums[i]);\\n            \\n            if(nums[num-1] < 0)\\n                dup = num;\\n            else\\n                nums[num-1] *= (-1);\\n        }\\n        \\n        for(int i = 0; i<n; i++) {\\n            if(nums[i] > 0) {\\n                missing = i+1;\\n                break;\\n            }\\n        }\\n        \\n        return {dup, missing};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734006,
                "title": "java-easy-solution-98-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i = 0;\\n        int[] ans = new int[2];\\n        while( i < nums.length ) {\\n            int correct = nums[i] - 1;\\n            if( nums[i] != nums[correct] ){\\n                swap(nums, i, correct);\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k] != k + 1){\\n            ans[1] = k + 1;\\n                ans[0] = nums[k];\\n             //   break;\\n            }\\n        }\\n         return ans;\\n    }\\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i = 0;\\n        int[] ans = new int[2];\\n        while( i < nums.length ) {\\n            int correct = nums[i] - 1;\\n            if( nums[i] != nums[correct] ){\\n                swap(nums, i, correct);\\n            }\\n            else {\\n                i++;\\n            }\\n        }\\n        for(int k = 0; k < nums.length; k++){\\n            if(nums[k] != k + 1){\\n            ans[1] = k + 1;\\n                ans[0] = nums[k];\\n             //   break;\\n            }\\n        }\\n         return ans;\\n    }\\n    public void swap(int[] nums, int first, int second){\\n        int temp = nums[first];\\n        nums[first] = nums[second];\\n        nums[second] = temp;\\n    }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034589,
                "title": "java-6-methods-from-bruteforce-to-optimal",
                "content": "```\\n//Method 1(Bruteforce Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       Arrays.sort(arr);\\n       int n=arr.length;\\n\\t   int[] res=new int[2]; \\n        \\n       for(int i=0;i<n;i++)\\n         if(arr[i]==arr[i+1])\\n         {\\n           res[0]=arr[i]; //repeating\\n           break;\\n         }\\n        \\n       for(int i=1;i<=n;i++)\\n         if(binarySearch(arr,i)==false)\\n         {\\n            res[1]=i; //missing\\n            break;\\n         }\\n               \\n        return res;\\n    }\\n    \\n    public static boolean binarySearch(int[] arr,int key)\\n    {\\n        int low=0,high=arr.length-1;\\n        while(low<=high)\\n        {\\n           int mid=(low+high)/2; \\n           if(arr[mid]==key)\\n             return true;\\n           else if(key>arr[mid])\\n             low=mid+1;\\n           else if(key<arr[mid])\\n              high=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n```\\n//Method 2 (Improved Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       int n=arr.length;\\n       int[]count=new int[n+1];\\n\\t   int[] res=new int[2];\\n\\t   \\n       for(int i=0;i<n;i++)\\n           count[arr[i]]++;\\n       \\n       for(int i=1;i<(n+1);i++)\\n       {\\n           if(count[i]==2)\\n             res[0]=i; //repeating\\n           else if(count[i]==0)\\n             res[1]=i; //missing\\n           \\n           if(res[0]!=0 && res[1]!=0)\\n             break;\\n       }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n```\\n//Method 3 (Better Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       int n=arr.length;\\n\\t   int[] res=new int[2];\\n       HashMap<Integer,Integer>hm=new HashMap<>();\\n\\t   \\n       for(int i=0;i<n;i++)\\n         if(hm.containsKey(arr[i]))\\n           hm.put(arr[i],hm.get(arr[i])+1);\\n         else\\n           hm.put(arr[i],1);\\n       \\n       for(int i=0;i<n;i++)\\n         if(hm.get(arr[i])==2)\\n         {\\n            res[0]=arr[i]; //repeating\\n            break;\\n         }\\n       \\n       for(int i=1;i<=n;i++)\\n         if(hm.containsKey(i)==false)\\n         {\\n            res[1]=i; //Missing\\n            break;\\n         }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n```\\n//Method 4 (Even Better Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       int n=arr.length;\\n\\t   int[] res=new int[2];\\n       HashMap<Integer,Integer>hm=new HashMap<>();\\n\\t   \\n       for(int i=1;i<=n;i++)\\n          hm.put(i,0);\\n       \\n       for(int i=0;i<n;i++)\\n         hm.put(arr[i],hm.get(arr[i])+1);\\n       \\n\\n       for(int key:hm.keySet())\\n         if(hm.get(key)==2)\\n           res[0]=key; //repeating\\n         else if(hm.get(key)==0)\\n           res[1]=key; //missing\\n        \\n        return res;\\n    }\\n}\\n\\n```\\n\\n```\\n//Method 5 (Best Approach)\\n(Cycle Sort)\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n         int n=arr.length,i=0;\\n\\t\\t int[] res=new int[2];\\n          while(i<n)\\n          {\\n             int correctIndex=arr[i]-1;\\n             if(arr[correctIndex]==arr[i])\\n\\t              i++;\\n\\t         else //if arr[i] is not at its correct index\\n             {\\n               int temp=arr[correctIndex];\\n               arr[correctIndex]=arr[i];\\n               arr[i]=temp;\\n             }      \\n           }  \\n        \\n           for (i=0; i<n; i++) \\n             if(arr[i]!=i+1)\\n             {\\n               res[0]=arr[i]; //repeating\\n               res[1]=i+1; //missing\\n               break;\\n             }\\n\\t\\t\\t \\n        return res;\\n    }\\n}\\n```\\n\\n```\\n//Method 6 (Optimal Approach) (For Best Explanation : https://youtu.be/MvklwzVz654 )\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n          int n=arr.length,x=0,y=0,xXory=0,rmsbm;\\n          int[] res=new int[2];\\n          \\n          for(int i=1;i<=n;i++)\\n             xXory=xXory^i;\\n             \\n          for(int val:arr)\\n             xXory=xXory^val;\\n             \\n          rmsbm=rMSBM(xXory);\\n          \\n          for(int val:arr)\\n            if((val & rmsbm)==0)\\n               x=x^val;\\n            else\\n               y=y^val;\\n          \\n          for(int i=1;i<=n;i++)\\n            if((i & rmsbm)==0)\\n               x=x^i;\\n            else\\n               y=y^i;\\n          \\n          for(int i=0;i<n;i++)\\n            if(arr[i]==x)\\n            {\\n                res[0]=x; //Repeating\\n                res[1]=y; //Missing\\n                break;\\n                \\n            }\\n            else if(arr[i]==y)\\n            {\\n                res[0]=y; //Repeating\\n                res[1]=x; //Missing\\n                break;\\n            }\\n       \\n        return res;\\n    }\\n    \\n    public static int rMSBM(int n)\\n   {\\n       int rsbm= n & twosCompliment(n);\\n       return rsbm;\\n   }\\n\\t\\t\\n   public static int twosCompliment(int n)\\n   {\\n       return -n;//(~n+1);\\n   }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\n//Method 1(Bruteforce Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       Arrays.sort(arr);\\n       int n=arr.length;\\n\\t   int[] res=new int[2]; \\n        \\n       for(int i=0;i<n;i++)\\n         if(arr[i]==arr[i+1])\\n         {\\n           res[0]=arr[i]; //repeating\\n           break;\\n         }\\n        \\n       for(int i=1;i<=n;i++)\\n         if(binarySearch(arr,i)==false)\\n         {\\n            res[1]=i; //missing\\n            break;\\n         }\\n               \\n        return res;\\n    }\\n    \\n    public static boolean binarySearch(int[] arr,int key)\\n    {\\n        int low=0,high=arr.length-1;\\n        while(low<=high)\\n        {\\n           int mid=(low+high)/2; \\n           if(arr[mid]==key)\\n             return true;\\n           else if(key>arr[mid])\\n             low=mid+1;\\n           else if(key<arr[mid])\\n              high=mid-1;\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n//Method 2 (Improved Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       int n=arr.length;\\n       int[]count=new int[n+1];\\n\\t   int[] res=new int[2];\\n\\t   \\n       for(int i=0;i<n;i++)\\n           count[arr[i]]++;\\n       \\n       for(int i=1;i<(n+1);i++)\\n       {\\n           if(count[i]==2)\\n             res[0]=i; //repeating\\n           else if(count[i]==0)\\n             res[1]=i; //missing\\n           \\n           if(res[0]!=0 && res[1]!=0)\\n             break;\\n       }\\n\\n        return res;\\n    }\\n}\\n```\n```\\n//Method 3 (Better Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       int n=arr.length;\\n\\t   int[] res=new int[2];\\n       HashMap<Integer,Integer>hm=new HashMap<>();\\n\\t   \\n       for(int i=0;i<n;i++)\\n         if(hm.containsKey(arr[i]))\\n           hm.put(arr[i],hm.get(arr[i])+1);\\n         else\\n           hm.put(arr[i],1);\\n       \\n       for(int i=0;i<n;i++)\\n         if(hm.get(arr[i])==2)\\n         {\\n            res[0]=arr[i]; //repeating\\n            break;\\n         }\\n       \\n       for(int i=1;i<=n;i++)\\n         if(hm.containsKey(i)==false)\\n         {\\n            res[1]=i; //Missing\\n            break;\\n         }\\n\\n        return res;\\n    }\\n}\\n```\n```\\n//Method 4 (Even Better Approach)\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n       int n=arr.length;\\n\\t   int[] res=new int[2];\\n       HashMap<Integer,Integer>hm=new HashMap<>();\\n\\t   \\n       for(int i=1;i<=n;i++)\\n          hm.put(i,0);\\n       \\n       for(int i=0;i<n;i++)\\n         hm.put(arr[i],hm.get(arr[i])+1);\\n       \\n\\n       for(int key:hm.keySet())\\n         if(hm.get(key)==2)\\n           res[0]=key; //repeating\\n         else if(hm.get(key)==0)\\n           res[1]=key; //missing\\n        \\n        return res;\\n    }\\n}\\n\\n```\n```\\n//Method 5 (Best Approach)\\n(Cycle Sort)\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n         int n=arr.length,i=0;\\n\\t\\t int[] res=new int[2];\\n          while(i<n)\\n          {\\n             int correctIndex=arr[i]-1;\\n             if(arr[correctIndex]==arr[i])\\n\\t              i++;\\n\\t         else //if arr[i] is not at its correct index\\n             {\\n               int temp=arr[correctIndex];\\n               arr[correctIndex]=arr[i];\\n               arr[i]=temp;\\n             }      \\n           }  \\n        \\n           for (i=0; i<n; i++) \\n             if(arr[i]!=i+1)\\n             {\\n               res[0]=arr[i]; //repeating\\n               res[1]=i+1; //missing\\n               break;\\n             }\\n\\t\\t\\t \\n        return res;\\n    }\\n}\\n```\n```\\n//Method 6 (Optimal Approach) (For Best Explanation : https://youtu.be/MvklwzVz654 )\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) \\n    {\\n          int n=arr.length,x=0,y=0,xXory=0,rmsbm;\\n          int[] res=new int[2];\\n          \\n          for(int i=1;i<=n;i++)\\n             xXory=xXory^i;\\n             \\n          for(int val:arr)\\n             xXory=xXory^val;\\n             \\n          rmsbm=rMSBM(xXory);\\n          \\n          for(int val:arr)\\n            if((val & rmsbm)==0)\\n               x=x^val;\\n            else\\n               y=y^val;\\n          \\n          for(int i=1;i<=n;i++)\\n            if((i & rmsbm)==0)\\n               x=x^i;\\n            else\\n               y=y^i;\\n          \\n          for(int i=0;i<n;i++)\\n            if(arr[i]==x)\\n            {\\n                res[0]=x; //Repeating\\n                res[1]=y; //Missing\\n                break;\\n                \\n            }\\n            else if(arr[i]==y)\\n            {\\n                res[0]=y; //Repeating\\n                res[1]=x; //Missing\\n                break;\\n            }\\n       \\n        return res;\\n    }\\n    \\n    public static int rMSBM(int n)\\n   {\\n       int rsbm= n & twosCompliment(n);\\n       return rsbm;\\n   }\\n\\t\\t\\n   public static int twosCompliment(int n)\\n   {\\n       return -n;//(~n+1);\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089717,
                "title": "c-faster-than-99-89-o-1-space-tricky-explained-super-simple",
                "content": "So:\\nWe go through all the numbers in the array, and \"return\" each number to the place that \"belongs\" to it according to its index.\\nOther than that, we multiply each number that was \"inserted\" by ```-1```, so that we know we have already \"handled\" it.\\nDid we try to \"insert\" a number into a place where there is a negative number? Apparently this number appears twice !!! (After all, we twice tried to access the same place!)\\nAnd how do you find the missing number? Simply, then go through the whole array again, and when we find a number that is not negative, it means that we did not try to access this place, and this index - is the number we are looking for.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int len = nums.size(), dup, mis;\\n        for ( int index = 0; index < len; ++index )\\n        {\\n            if ( nums[abs(nums[index]) - 1] < 0 )\\n                dup = abs(nums[index]);\\n            else nums[abs(nums[index]) - 1] *= -1;\\n        }\\n        \\n        for ( int index = 0; index < len; ++index )\\n        {\\n            if ( nums[index] > 0 )\\n            {\\n                mis = index + 1;\\n                break;\\n            }\\n        }\\n        return {dup, mis};\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```-1```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734450,
                "title": "java-easy-solution-using-frequency-array-beats-90-solution-easy-to-understand",
                "content": "**Solution Using Frequency aaray**\\n\\n**Please  Upvote if you Like**\\n\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int freq[] = new int[nums.length+1];\\n        for (int i:nums) freq[i]++;\\n        int dup = 0, miss = 0;\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i]==2) dup = i;\\n            if (freq[i]==0) miss = i; \\n            if (dup!=0 && miss!=0) break;\\n        }\\n        return new int[]{dup,miss};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int freq[] = new int[nums.length+1];\\n        for (int i:nums) freq[i]++;\\n        int dup = 0, miss = 0;\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i]==2) dup = i;\\n            if (freq[i]==0) miss = i; \\n            if (dup!=0 && miss!=0) break;\\n        }\\n        return new int[]{dup,miss};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1617786,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {    \\n    unordered_map<int,int> mp;\\n    vector<int> ans;\\n    for(int i=0;i<nums.size();i++){\\n        mp[nums[i]]++;\\n    }\\n    for(auto &it : mp){\\n      if(it.second == 2)\\n          ans.push_back(it.first);\\n    }\\n    for(int i=1;i<=nums.size();i++){\\n      if(mp[i]==0)\\n          ans.push_back(i);\\n    }   \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {    \\n    unordered_map<int,int> mp;\\n    vector<int> ans;\\n    for(int i=0;i<nums.size();i++){\\n        mp[nums[i]]++;\\n    }\\n    for(auto &it : mp){\\n      if(it.second == 2)\\n          ans.push_back(it.first);\\n    }\\n    for(int i=1;i<=nums.size();i++){\\n      if(mp[i]==0)\\n          ans.push_back(i);\\n    }   \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351092,
                "title": "python-faster-than-90",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        true_sum = n*(n+1)//2\\n        actual_sum = sum(nums)\\n        set_sum = sum(set(nums))\\n        return [actual_sum - set_sum, true_sum - set_sum]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        true_sum = n*(n+1)//2\\n        actual_sum = sum(nums)\\n        set_sum = sum(set(nums))\\n        return [actual_sum - set_sum, true_sum - set_sum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090752,
                "title": "python-using-sum-of-triangular-numbers-o-n-o-1",
                "content": "Using the [sum of triangular numbers](https://en.wikipedia.org/wiki/Triangular_number).\\n\\nsample input : `[1,2,2,4]`\\n`n` \\u2013 number of elements in `nums`\\n`a` \\u2013 the sum of the correct sequence `1+2+3+4`\\n`b` \\u2013 the sum of `nums` (sequence w/ duplicate) `1+2+2+4`\\n`c` \\u2013 the sum of `set(nums)` (sequence w/o duplicate)  `1+2+4`\\n\\nduplicate = `b-c` \\u2013 `(1+2+2+4) - (1+2+4) = 2`\\nmissing = `a-c` \\u2013 `(1+2+3+4) - (1+2+4) = 3`\\n\\n\\n```\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        b = sum(nums)\\n        c = sum(set(nums))\\n        a = (n * (n+1)) // 2\\n        missing = a - c\\n        duplicate = b - c\\n        return [duplicate, missing]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        b = sum(nums)\\n        c = sum(set(nums))\\n        a = (n * (n+1)) // 2\\n        missing = a - c\\n        duplicate = b - c\\n        return [duplicate, missing]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2538868,
                "title": "python-solution-simple-logic-math-based",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        toRemove = sum(nums) - sum(set(nums))\\n        actualMissing = sum(range(1, len(nums)+1)) - sum(set(nums))\\n        return [toRemove, actualMissing]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        toRemove = sum(nums) - sum(set(nums))\\n        actualMissing = sum(range(1, len(nums)+1)) - sum(set(nums))\\n        return [toRemove, actualMissing]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089571,
                "title": "c-super-short-bitwise-solution-explained",
                "content": "we can use the xor operation to figure out the duplicaed number and the missing number\\n\\nby xor-ing all the numbers of the list together with all the numbers of the list as a set (removing the duplicate) we get the duplicated number\\nthis is because we end up xoring all elements twice which will turn into zero (i ^ i = 0) and one extra time with the duplicated number so we will get 0 ^ duplicated = duplicated\\n\\nby xor-ing all the numbers of the list once together with the numbers from 1 to n we get the missing number\\nthis is because we end up xoring all of the numbers from 1 to n twice but only once will we xor the missing number\\nso we will get 0 ^ missing = missing\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        int XOR = 0, duplicatedNum = 0, missingNum = nums.size();\\n        \\n        for (int num : set<int>(nums.begin(), nums.end()))\\n            XOR ^= num;\\n        \\n        for (size_t i = 0; i < nums.size(); i++)\\n            duplicatedNum ^= nums[i]; \\n            \\n        for (size_t i = 1; i < nums.size(); i++)\\n            missingNum ^= i;\\n        \\n        return {duplicatedNum ^ XOR, missingNum ^ XOR};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        int XOR = 0, duplicatedNum = 0, missingNum = nums.size();\\n        \\n        for (int num : set<int>(nums.begin(), nums.end()))\\n            XOR ^= num;\\n        \\n        for (size_t i = 0; i < nums.size(); i++)\\n            duplicatedNum ^= nums[i]; \\n            \\n        for (size_t i = 1; i < nums.size(); i++)\\n            missingNum ^= i;\\n        \\n        return {duplicatedNum ^ XOR, missingNum ^ XOR};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689145,
                "title": "c-solution",
                "content": "```\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\tsort(begin(nums), end(nums));\\n\\tint dupl = -1;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tif (nums[i] == nums[i + 1]) {\\n\\t\\t\\tdupl = nums[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint sum = (nums.size() + 1) * nums.size() / 2;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tsum -= nums[i];\\n\\t}\\n\\treturn { dupl, sum + dupl };\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\tsort(begin(nums), end(nums));\\n\\tint dupl = -1;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tif (nums[i] == nums[i + 1]) {\\n\\t\\t\\tdupl = nums[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint sum = (nums.size() + 1) * nums.size() / 2;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tsum -= nums[i];\\n\\t}\\n\\treturn { dupl, sum + dupl };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 129569,
                "title": "python-solution-beat-99",
                "content": "1. Create a continuous array (contain 1~n)\\n2. Create a set of nums to get rid of the duplicate value\\n3. Then we can get the missing value by using ( sum of continuous array - sum of set(nums) )\\n4. We can get the duplicate value by using ( sum of nums - sum of set(nums) )\\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sall = sum(list(range(1, len(nums)+1)))\\n        sset = sum(set(nums))\\n        snum = sum(nums)\\n\\n        miss    = sall - sset\\n        repeat  = snum - sset\\n\\n        return [repeat, miss]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        sall = sum(list(range(1, len(nums)+1)))\\n        sset = sum(set(nums))\\n        snum = sum(nums)\\n\\n        miss    = sall - sset\\n        repeat  = snum - sset\\n\\n        return [repeat, miss]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747590,
                "title": "frequency-array-easy-self-explanatory-solution-beats-100",
                "content": "\\n\\n### Intuition\\nThe problem aims to find the duplicate and missing numbers in an array of integers. The intuition behind the solution is to use an array to count the occurrences of each number in the given array. By iterating through the array and tracking the count, we can identify the duplicate and missing numbers.\\n\\n### Approach\\n1. We start by creating an array `x` of length `nums.length+1` to store the count of each number. The additional index allows us to represent numbers from 1 to n (inclusive).\\n2. We iterate through the `nums` array and increment the count at index `i` in array `x` using the enhanced for loop: `for(int i:nums) x[i]++;`.\\n3. We initialize variables `dup` and `miss` to keep track of the duplicate and missing numbers, respectively.\\n4. We iterate through array `x` from index 1 to the end. If the count at index `i` is equal to 2, it means `i` is the duplicate number. If the count at index `i` is 0, it means `i` is the missing number. We assign the respective values to `dup` and `miss`.\\n5. Finally, we return an array containing `dup` and `miss` as the result: `return new int[]{dup, miss};`.\\n\\n### Complexity\\n- Time complexity: The time complexity is O(n), where n is the length of the `nums` array. We iterate through the `nums` array once to count the occurrences, and then iterate through the `x` array once to find the duplicate and missing numbers. Both iterations take linear time.\\n- Space complexity: The space complexity is O(n), where n is the length of the `nums` array. We use an additional array `x` to store the counts of numbers, which requires space proportional to the size of the `nums` array.\\n\\n### Code\\n```java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int x[] = new int[nums.length + 1];\\n        \\n        // Count the occurrences of each number\\n        for (int i : nums) {\\n            x[i]++;\\n        }\\n        \\n        int dup = 0, miss = 0;\\n        \\n        // Find the duplicate and missing numbers\\n        for (int i = 1; i < x.length; i++) {\\n            if (x[i] == 2) {\\n                dup = i;\\n            }\\n            if (x[i] == 0) {\\n                miss = i;\\n            }\\n        }\\n        \\n        // Return the result as an array\\n        return new int[]{dup, miss};\\n    }\\n}\\n```\\n\\n![upvotekaro1.jpeg](https://assets.leetcode.com/users/images/21e92f3f-86c8-477a-b4cb-be60ca1b270f_1689032592.3149803.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int x[] = new int[nums.length + 1];\\n        \\n        // Count the occurrences of each number\\n        for (int i : nums) {\\n            x[i]++;\\n        }\\n        \\n        int dup = 0, miss = 0;\\n        \\n        // Find the duplicate and missing numbers\\n        for (int i = 1; i < x.length; i++) {\\n            if (x[i] == 2) {\\n                dup = i;\\n            }\\n            if (x[i] == 0) {\\n                miss = i;\\n            }\\n        }\\n        \\n        // Return the result as an array\\n        return new int[]{dup, miss};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743032,
                "title": "js-99-100-with-explanation",
                "content": "To solve this problem, we will create a new array of the same length as the one we get, filling it with zeros. Also, to get the missing number, we will create a variable with the sum of all numbers from 1 to the length of the array **sum = N * (N + 1) / 2** (since all the numbers we have are from one, and in order). To search for a duplicate, we will also create a variable.\\n\\nNow, passing through the array, we kind of sort it, so that our number from the nums array would be in the new array at the appropriate index (**\"- 1\"** - correction for the index). If this index already has a number from our array, then we got a duplicate, and write it to a variable, otherwise we put the number in place and subtract it from the sum.\\n\\nAt the end, we will get **a sorted array**, with one 0 (there should be a missing number). We could not create a sum and find the missing number by index (since 0 will stand in place of the missing one), however, it seems to me that this is redundant, so we will return the values with dup and the remaining sum.\\n\\n**I hope the picture will help to understand in more detail)**\\n![image](https://assets.leetcode.com/users/images/1b314f3b-4e24-4d22-9265-ddeb58db7a69_1666708944.902053.png)\\n\\n```\\nvar findErrorNums = function(nums) {\\n    let sum = (nums.length * (nums.length + 1)) / 2;\\n    let dup = 0;\\n    let arr = Array(nums.length).fill(0);\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (arr[nums[i] - 1] === nums[i]) dup = nums[i];\\n        else {\\n            arr[nums[i] - 1] = nums[i];\\n            sum -= nums[i];\\n        }\\n    }\\n\\n    return [dup, sum];\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar findErrorNums = function(nums) {\\n    let sum = (nums.length * (nums.length + 1)) / 2;\\n    let dup = 0;\\n    let arr = Array(nums.length).fill(0);\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (arr[nums[i] - 1] === nums[i]) dup = nums[i];\\n        else {\\n            arr[nums[i] - 1] = nums[i];\\n            sum -= nums[i];\\n        }\\n    }\\n\\n    return [dup, sum];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733900,
                "title": "c-map-easy-understanding",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> findErrorNums(vector<int> &nums)\\n        {\\n\\n            int n = nums.size();\\n            vector<int> arr(n + 1, 0);\\n            vector<int> vec;\\n\\n            for (auto i: nums)\\n            {\\n                arr[i]++;\\n                if (arr[i] > 1)\\n                    vec.push_back(i);\\n            }\\n\\n            for (int i = 1; i < n + 1; i++)\\n            {\\n                if (arr[i] == 0)\\n                {\\n                    vec.push_back(i);\\n                    break;\\n                }\\n            }\\n            return vec;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> findErrorNums(vector<int> &nums)\\n        {\\n\\n            int n = nums.size();\\n            vector<int> arr(n + 1, 0);\\n            vector<int> vec;\\n\\n            for (auto i: nums)\\n            {\\n                arr[i]++;\\n                if (arr[i] > 1)\\n                    vec.push_back(i);\\n            }\\n\\n            for (int i = 1; i < n + 1; i++)\\n            {\\n                if (arr[i] == 0)\\n                {\\n                    vec.push_back(i);\\n                    break;\\n                }\\n            }\\n            return vec;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283386,
                "title": "java-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n\\n    public int[] findErrorNums(int[] nums) {\\n        int res[] = new int[2];\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = Math.abs(nums[i]) - 1;\\n            if (nums[index] < 0) res[0] = index + 1;\\n            if (nums[index] > 0) nums[index] = -nums[index];\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) res[1] = i + 1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] findErrorNums(int[] nums) {\\n        int res[] = new int[2];\\n        for (int i = 0; i < nums.length; i++) {\\n            int index = Math.abs(nums[i]) - 1;\\n            if (nums[index] < 0) res[0] = index + 1;\\n            if (nums[index] > 0) nums[index] = -nums[index];\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) res[1] = i + 1;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089568,
                "title": "c-simple-bit-manipulation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // Create distinct vector\\n        set<int> distinct1{nums.begin(), nums.end()};\\n        vector<int> distinct{distinct1.begin(), distinct1.end()};\\n        \\n        int missing = distinct.size(), duplicate = 0, n = nums.size();\\n        \\n        // Find missing number\\n        for (int i = 0; i < n-1; i++)\\n            missing ^= i ^ distinct[i];\\n        missing ^= n;\\n        \\n        // Find duplicate number\\n        for (int i = 0; i < n-1; i++) {\\n            duplicate ^= nums[i] ^ distinct[i];\\n        }\\n        duplicate ^= nums[n-1];\\n        \\n        return {duplicate, missing};\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        // Create distinct vector\\n        set<int> distinct1{nums.begin(), nums.end()};\\n        vector<int> distinct{distinct1.begin(), distinct1.end()};\\n        \\n        int missing = distinct.size(), duplicate = 0, n = nums.size();\\n        \\n        // Find missing number\\n        for (int i = 0; i < n-1; i++)\\n            missing ^= i ^ distinct[i];\\n        missing ^= n;\\n        \\n        // Find duplicate number\\n        for (int i = 0; i < n-1; i++) {\\n            duplicate ^= nums[i] ^ distinct[i];\\n        }\\n        duplicate ^= nums[n-1];\\n        \\n        return {duplicate, missing};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089519,
                "title": "python-faster-than-99-50-o-n-time-3-lines-explain-math-super-simple",
                "content": "Short, no?\\nInteresting to know how I got to this?\\nSo:\\n```s``` Saves the sum of the existing numbers, without duplicates\\nThe missing number, is basically an invoice series sum from 1 to n, minus ```s```\\nThe dup. number, is the sum of nums (the sum of all the numbers we got) minus ```s``` (sum of the existing numbers, without duplicates).\\n\\n\\n\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        l, s = len(nums), sum(set(nums))\\n        l = l * ( 1 + l ) // 2\\n        return [sum(nums) - s, l - s]\\n```\\n\\nUnderstand? Vote\\nDo not understand? Feel free to ask :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```s```\n```s```\n```s```\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        l, s = len(nums), sum(set(nums))\\n        l = l * ( 1 + l ) // 2\\n        return [sum(nums) - s, l - s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439805,
                "title": "java-o-n-solution-using-frequency-table",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n+1];\\n        for(int i: nums) arr[i]++;\\n        int[] ans = new int[2];\\n        for(int i = 1; i <= arr.length - 1; i++) {\\n            if(arr[i] == 2) ans[0] = i;\\n            if(arr[i] == 0) ans[1] = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n+1];\\n        for(int i: nums) arr[i]++;\\n        int[] ans = new int[2];\\n        for(int i = 1; i <= arr.length - 1; i++) {\\n            if(arr[i] == 2) ans[0] = i;\\n            if(arr[i] == 0) ans[1] = i;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734972,
                "title": "easy-c-solution",
                "content": "ALGORITHM\\n//Using map to store frequency of numbers in given vector\\n//checking which number has frequency 2 \\n//checking which number is missing i.e which number does not present in map\\n\\n \\n```\\n ``vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int>v;\\n        int t=0;//will store missing number\\n        int p=0;//will store repeated number \\n\\t\\t\\n         unordered_map<int,int>m;\\n        //storing frequency of each number in map\\n         for(int i=0;i<nums.size();++i)\\n          {\\n              m[nums[i]]++; \\n          }\\n        //If frequency of any number is 2 -> store it in p\\n          for(auto it:m)\\n          {\\n              if(it.second==2)\\n              {\\n                  p=it.first;\\n              }\\n             \\n          }\\n        //check for missing number \\n        //search for key , if key is not present store missing number in t \\n           for(int i=1;i<=nums.size();++i)\\n           {\\n               auto x=m.find(i);\\n               if(x==m.end())\\n               {\\n                   t=i;\\n               }\\n           }\\n   \\n        v.push_back(p);\\n        v.push_back(t);\\n   \\n       \\n        return v;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n ``vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int>v;\\n        int t=0;//will store missing number\\n        int p=0;//will store repeated number \\n\\t\\t\\n         unordered_map<int,int>m;\\n        //storing frequency of each number in map\\n         for(int i=0;i<nums.size();++i)\\n          {\\n              m[nums[i]]++; \\n          }\\n        //If frequency of any number is 2 -> store it in p\\n          for(auto it:m)\\n          {\\n              if(it.second==2)\\n              {\\n                  p=it.first;\\n              }\\n             \\n          }\\n        //check for missing number \\n        //search for key , if key is not present store missing number in t \\n           for(int i=1;i<=nums.size();++i)\\n           {\\n               auto x=m.find(i);\\n               if(x==m.end())\\n               {\\n                   t=i;\\n               }\\n           }\\n   \\n        v.push_back(p);\\n        v.push_back(t);\\n   \\n       \\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734580,
                "title": "c-unordered-map-math-easy-explained-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int origSum=(nums.size()*(nums.size()+1))/2; // sum of n natural numbers till size of nums=n*(n+1)/2\\n        int sum=0;// sum of our given array\\n        int x=0; // our repeated number \\n\\t\\t// Let y be our deleted number\\n        unordered_map<int,int> a;\\n        for(int e:nums){\\n           a[e]++;\\n           sum+=e;\\n           if(a[e]==2){\\n               x=e;\\n           }\\n        }\\n        return {x,origSum-sum+x}; // since (sum+y-x=origSum) therefore y=origSum-sum+x.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int origSum=(nums.size()*(nums.size()+1))/2; // sum of n natural numbers till size of nums=n*(n+1)/2\\n        int sum=0;// sum of our given array\\n        int x=0; // our repeated number \\n\\t\\t// Let y be our deleted number\\n        unordered_map<int,int> a;\\n        for(int e:nums){\\n           a[e]++;\\n           sum+=e;\\n           if(a[e]==2){\\n               x=e;\\n           }\\n        }\\n        return {x,origSum-sum+x}; // since (sum+y-x=origSum) therefore y=origSum-sum+x.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203187,
                "title": "simple-python3-solution-using-basic-maths-and-coding-knowledge",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        repeated_no = sum(nums)-sum(set(nums))\\n        missing_no = repeated_no + int(n*(n+1)/2) - sum(nums)\\n        return [repeated_no,missing_no]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        repeated_no = sum(nums)-sum(set(nums))\\n        missing_no = repeated_no + int(n*(n+1)/2) - sum(nums)\\n        return [repeated_no,missing_no]\\n",
                "codeTag": "Java"
            },
            {
                "id": 1089775,
                "title": "python-math-solution-easier-than-dbabichev-s-no-formulas-o-n-o-1",
                "content": "# Explanation:\\n**If you really good at math, you may try to skip straight to code, I hope it is understandable**\\nThere is no tricky math, everything is simple:\\n1. We can get `expectedSum` (is no _error_ would be done), by `sum(range(1, len(nums)))` (or using formula, but we agreed on **no formulas**)\\n2. We can get the `realSum` of all elements in our `nums`, that will be equal the sum we expected (`expectedSum`) but minus `missing` number and plus `duplicate`. It all from Problem\\'s statement.\\n3. Now we can find `duplicate - missing` just by `duplicate - missing == realSum - expectedSum`. Calculated, remembered.\\n\\n4. Now we have to do the same with product of sequence. We use [reduce](https://docs.python.org/3/library/functools.html#functools.reduce), it basically take every element, do something, pass it to do the same thing with next element. `reduce(mul, nums)` just give the prod of every element.\\n5. Now we got expected `expectedProd`, and `realProd`. Because `duplicate / missing == realProd / expectedProd` we get `duplicate / missing`.\\n6. Now we just do some math, extracting `duplicate` from last formula we get `duplicate == prodQuot * missing`, now we replace `duplicate` with `prodQuot * missing` in 3 (`duplicate - missing == realSum - expectedSum`) and get:\\n`sumDiff == prodQuot * missing - missing`\\nhere we get the `missing` by divinding both paths by `prodQuot - 1`:\\n`missing = round(sumDiff / (prodDivision - 1))`\\nNow we found `missing` else is not hard, we can get duplicate just by `duplicate = sumDiff + missing`\\n\\n## Python code:\\n```\\nclass Solution:\\n  def findErrorNums(self, nums: List[int]) -> List[int]:\\n    expectedSum = sum(range(1, len(nums) + 1))\\n    realSum = sum(nums)\\n    sumDiff = realSum - expectedSum\\n    \\n    expectedProd = reduce(mul, range(1, len(nums) + 1))\\n    realProd = reduce(mul, nums)\\n    prodDivision = realProd / expectedProd\\n    \\n\\t# Math:\\n    # sumDiff == duplicate - missing\\n    # prodDivision == duplicate / missing\\n    # duplicate == prodQuot * missing\\n    # sumDiff == prodQuot * missing - missing\\n    # sumDiff == missing * (prodQuot - 1)\\n    # sumDiff / (prodQuot - 1) == missing\\n    missing = round(sumDiff / (prodDivision - 1))\\n    duplicate = sumDiff + missing\\n    \\n    return (duplicate, missing)\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n  def findErrorNums(self, nums: List[int]) -> List[int]:\\n    expectedSum = sum(range(1, len(nums) + 1))\\n    realSum = sum(nums)\\n    sumDiff = realSum - expectedSum\\n    \\n    expectedProd = reduce(mul, range(1, len(nums) + 1))\\n    realProd = reduce(mul, nums)\\n    prodDivision = realProd / expectedProd\\n    \\n\\t# Math:\\n    # sumDiff == duplicate - missing\\n    # prodDivision == duplicate / missing\\n    # duplicate == prodQuot * missing\\n    # sumDiff == prodQuot * missing - missing\\n    # sumDiff == missing * (prodQuot - 1)\\n    # sumDiff / (prodQuot - 1) == missing\\n    missing = round(sumDiff / (prodDivision - 1))\\n    duplicate = sumDiff + missing\\n    \\n    return (duplicate, missing)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026921,
                "title": "645-set-mismatch-typescript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst element of array is 0 that we will ignore and missing number should be 0\\nDupulicated number should be 2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array that starts with 0 to n\\nAdd all of the numbers to the array as indecies\\n\\nSo arr.indexOf(2) is the duplicated number and arr.lastIndexOf(0) is the missing number\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nfunction findErrorNums(nums: number[]): number[] {\\n    const arr: number[] = new Array(nums.length+1).fill(0);\\n    for(let i = 0; i < nums.length; i++) {\\n        arr[nums[i]]++;\\n    }\\n\\n    return [arr.indexOf(2), arr.lastIndexOf(0)];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction findErrorNums(nums: number[]): number[] {\\n    const arr: number[] = new Array(nums.length+1).fill(0);\\n    for(let i = 0; i < nums.length; i++) {\\n        arr[nums[i]]++;\\n    }\\n\\n    return [arr.indexOf(2), arr.lastIndexOf(0)];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736246,
                "title": "python-one-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        return [sum(nums)-sum(set(nums)), list(set([x for x in range(1, len(nums)+1)])-set(nums))[0]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        return [sum(nums)-sum(set(nums)), list(set([x for x in range(1, len(nums)+1)])-set(nums))[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735316,
                "title": "c-linq",
                "content": "**Please upvote if my solution was helpful ;)**\\n```\\npublic class Solution {\\n    public int[] FindErrorNums(int[] nums) {\\n        \\n        int first = nums.GroupBy(x => x).Where(g => g.Count() == 2).Select(x => x.Key).First();\\n        int second = Enumerable.Range(1, nums.Length).Except(nums).First();\\n\\n        return new int[] { first, second }; \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] FindErrorNums(int[] nums) {\\n        \\n        int first = nums.GroupBy(x => x).Where(g => g.Count() == 2).Select(x => x.Key).First();\\n        int second = Enumerable.Range(1, nums.Length).Except(nums).First();\\n\\n        return new int[] { first, second }; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734589,
                "title": "c-bitwise-xor-easy-solution",
                "content": "```\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\n\\tint n = nums.size();\\n\\n\\t// Sorting Array.\\n\\tsort(nums.begin(), nums.end());\\n\\n\\t// Creating output vector.\\n\\tvector<int> res(2);\\n\\n\\t// Storing XOR of unique numbers in array.\\n\\tint xorOfArray = nums[0];\\n\\n\\t// Storing XOR of integers from 1 to N.\\n\\tint xorUptoN = n;\\n\\n\\t// If XOR of any two numbers in the array is zero i.e. they are same.\\n\\t// Else we would store them this would remove duplicate element in our XOR.\\n\\tfor (int i = 1; i < n; i++) {\\n\\t\\tif ((nums[i - 1] ^ nums[i]) == 0) res[0] = nums[i];\\n\\t\\telse xorOfArray ^= nums[i];\\n\\t\\txorUptoN ^= i;\\n\\t}\\n\\n\\t// We could see that the difference in both of these XORs would be the element missing.\\n\\tres[1] = xorUptoN ^ xorOfArray;\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\n\\tint n = nums.size();\\n\\n\\t// Sorting Array.\\n\\tsort(nums.begin(), nums.end());\\n\\n\\t// Creating output vector.\\n\\tvector<int> res(2);\\n\\n\\t// Storing XOR of unique numbers in array.\\n\\tint xorOfArray = nums[0];\\n\\n\\t// Storing XOR of integers from 1 to N.\\n\\tint xorUptoN = n;\\n\\n\\t// If XOR of any two numbers in the array is zero i.e. they are same.\\n\\t// Else we would store them this would remove duplicate element in our XOR.\\n\\tfor (int i = 1; i < n; i++) {\\n\\t\\tif ((nums[i - 1] ^ nums[i]) == 0) res[0] = nums[i];\\n\\t\\telse xorOfArray ^= nums[i];\\n\\t\\txorUptoN ^= i;\\n\\t}\\n\\n\\t// We could see that the difference in both of these XORs would be the element missing.\\n\\tres[1] = xorUptoN ^ xorOfArray;\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734535,
                "title": "python3-beginner-friendly-solution-set-sum-o-n",
                "content": "```\\ndef findErrorNums(self, nums: List[int]) -> List[int]:\\n        length=len(nums) \\n        sum_nums = length*(length+1)//2 #Sum of first n positive integers = n(n + 1)/2 \\n        repetition = sum(nums) - sum(set(nums))\\n        loss = sum_nums - sum(set(nums))\\n        return [repetition,loss]\\n        #Time : O(n) --> using sum() func\\n        #Space : O(1) \\n        \\n        \\'\\'\\'\\n        Example: [1,2,2,4]\\n        length = 4\\n        sum_nums = 10\\n        repetiton =  9 - 7 = 2  #sum([1,2,2,4]) - sum({1,2,4}) = 2\\n        loss      = 10 - 7 = 3  #sum([1,2,3,4]) - sum({1,2,4}) = 3\\n        \\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\ndef findErrorNums(self, nums: List[int]) -> List[int]:\\n        length=len(nums) \\n        sum_nums = length*(length+1)//2 #Sum of first n positive integers = n(n + 1)/2 \\n        repetition = sum(nums) - sum(set(nums))\\n        loss = sum_nums - sum(set(nums))\\n        return [repetition,loss]\\n        #Time : O(n) --> using sum() func\\n        #Space : O(1) \\n        \\n        \\'\\'\\'\\n        Example: [1,2,2,4]\\n        length = 4\\n        sum_nums = 10\\n        repetiton =  9 - 7 = 2  #sum([1,2,2,4]) - sum({1,2,4}) = 2\\n        loss      = 10 - 7 = 3  #sum([1,2,3,4]) - sum({1,2,4}) = 3\\n        \\'\\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2733783,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "[](http://)![image](https://assets.leetcode.com/users/images/0333a49c-a9d0-4264-81b0-42627890c2e0_1666485852.1995609.png)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums){\\n        long sum=0;\\n        long sumofsquare=0;\\n        long n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            sumofsquare+=(nums[i]*nums[i]);\\n        }\\n        long nsum=n*(n+1)/2; //sum of first n natural numbers\\n        long sumdiff=nsum-sum;\\n        long nsquaresum=n*(n+1)*(2*n+1)/6; //sum of squares of first n natural numbers\\n        long squaresumdiff=nsquaresum-sumofsquare;\\n        long temp=squaresumdiff/sumdiff;\\n        int missingnum=(temp+sumdiff)/2;\\n        int repeatingnum=missingnum-sumdiff;\\n        vector<int> ans;\\n        ans.push_back(repeatingnum);\\n        ans.push_back(missingnum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums){\\n        long sum=0;\\n        long sumofsquare=0;\\n        long n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            sumofsquare+=(nums[i]*nums[i]);\\n        }\\n        long nsum=n*(n+1)/2; //sum of first n natural numbers\\n        long sumdiff=nsum-sum;\\n        long nsquaresum=n*(n+1)*(2*n+1)/6; //sum of squares of first n natural numbers\\n        long squaresumdiff=nsquaresum-sumofsquare;\\n        long temp=squaresumdiff/sumdiff;\\n        int missingnum=(temp+sumdiff)/2;\\n        int repeatingnum=missingnum-sumdiff;\\n        vector<int> ans;\\n        ans.push_back(repeatingnum);\\n        ans.push_back(missingnum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733756,
                "title": "daily-leetcoding-challenge-october-day-23",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 23.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/set-mismatch/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 7 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Better Brute Force\n\n  \n**Approach 3:** Using Sorting\n\n  \n**Approach 4:** Using Map\n\n  \n**Approach 5:** Using Extra Array\n\n  \n**Approach 6:** Using Constant Space\n\n  \n**Approach 7:** Using XOR\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/set-mismatch/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2008344,
                "title": "c-easy-approach-full-explanation",
                "content": "# Approach\\u2714\\n\\n**1. Create a vector to store the ans\\n2. Create a map to store the elements and their frequencies.\\n3. Using for loop put all the values into map.\\n4. Next for loop will push the  value of element whose frequency is 2 into vector. (number which occurs twice)\\n5. Last for loop will push the missing value to the vector.\\n6. At the end return the vector containing both the values.** \\n\\n\\n\\n```\\n=> IF THE SOLUTION WAS USEFUL, DO NOT FORGET TO UPVOTE!! \\u2714\\n\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> map;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            map[nums[i]]++;\\n        }\\n        \\n        for(auto & i :map)\\n        {\\n            if(i.second==2)\\n                ans.push_back(i.first);\\n        }\\n        \\n        for(int i=1;i<=nums.size();i++)\\n         {\\n             if(map[i]==0)\\n             {\\n                 ans.push_back(i);\\n             }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n=> IF THE SOLUTION WAS USEFUL, THEN DO NOT FORGET TO UPVOTE!! \\u2714",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> map;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            map[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1089732,
                "title": "python-o-1-space-o-n-time-tricky-super-simple",
                "content": "```\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        l, dup, mis = len(nums), 0, 0\\n        for num in nums:\\n            if nums[abs(num) - 1] < 0 :\\n                dup = abs(num)\\n            else: nums[abs(num) - 1] *= -1\\n        \\n        for index in range(l):\\n            if nums[index] > 0:\\n                mis = index + 1\\n                break\\n                \\n        return [dup, mis]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findErrorNums(self, nums):\\n        l, dup, mis = len(nums), 0, 0\\n        for num in nums:\\n            if nums[abs(num) - 1] < 0 :\\n                dup = abs(num)\\n            else: nums[abs(num) - 1] *= -1\\n        \\n        for index in range(l):\\n            if nums[index] > 0:\\n                mis = index + 1\\n                break\\n                \\n        return [dup, mis]",
                "codeTag": "Java"
            },
            {
                "id": 499448,
                "title": "java-simple-solution-using-hashset",
                "content": "```\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {  \\n        \\n        HashSet<Integer> h = new HashSet<>();\\n        int dup=0;\\n        for(int n : nums){\\n            if(h.contains(n))\\n                dup=n;\\n            h.add(n);\\n        }\\n               \\n        for(int i=1;i<=nums.length;i++){\\n            if(!h.contains(i))\\n                return new int[]{dup,i};\\n        }\\n        \\n        return new int[]{};\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {  \\n        \\n        HashSet<Integer> h = new HashSet<>();\\n        int dup=0;\\n        for(int n : nums){\\n            if(h.contains(n))\\n                dup=n;\\n            h.add(n);\\n        }\\n               \\n        for(int i=1;i<=nums.length;i++){\\n            if(!h.contains(i))\\n                return new int[]{dup,i};\\n        }\\n        \\n        return new int[]{};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434298,
                "title": "super-java-collection-brute-force-hashmap-count-hashset-math-bitwise-clever-sorting",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/set-mismatch/) <span class=\"gray\">EPI 11.10</span>\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n\\n\\n## Problem\\n\\n> The set `S` originally contains numbers from `1` to `n`. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.\\n\\n> Given an array `nums` representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing. Return them in the form of an array.\\n\\n**Note:** \\n\\n- The given array size will in the range `[2, 10000]`.\\n- The given array\\'s numbers **won\\'t have any order**.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,2,4]\\nOutput: [2,3]\\n```\\n\\n\\n## Analysis\\n\\n### Brute-Force\\n\\nFor each value from `1` to `n`, count its occurrence in `nums`.\\n\\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n  int dup = -1, miss = -1;\\n\\n  for (int i = 1; i <= n; ++i) { // for 1...n\\n    int count = 0;\\n    for (int val : nums) {\\n      if (val == i) {\\n        count += 1;\\n      }\\n    }\\n    if (count == 2) dup = i;\\n    if (count == 0) miss = i;\\n    // if both are set, then break\\n    if (dup > 0 && miss > 0) break;\\n  }\\n\\n  return new int[] { dup, miss };\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Map + Count\\n\\n**Note:** Break the loop when `dup` and `miss` are all set.\\n\\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n  Map<Integer, Integer> map = new HashMap<>();\\n  // first pass - count\\n  for (int val : nums) {\\n    map.put(val, map.getOrDefault(val, 0) + 1);\\n  }\\n  // second pass\\n  int dup = -1, miss = -1;\\n  for (int i = 1; i <= n; ++i) {\\n    if (map.containsKey(i) == false) miss = i;\\n    else if (map.get(i) == 2) dup = i;\\n    // if both are set, then break\\n    if (dup > 0  && miss > 0) break;\\n  }\\n  return new int[] { dup, miss };\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(N)`\\n\\n\\n### Set + Math\\n\\nSee the example for how this method works.\\n\\n```java\\n// actual:   1 + 2 + 4 = 7 (use a hash set to remove extra duplicates)\\n// expected: 1 + 2 + 3 + 4 = 10\\n```\\n\\nSo `expected` - `actual` = `miss`. And `dup` can be detected in the array iteration.\\n\\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n  Set<Integer> set = new HashSet<>();\\n\\n  int actualSum = 0;\\n  int dup = 0;\\n  for (int val : nums) {\\n    if (!set.contains(val)) {\\n      actualSum += val;\\n    } else {\\n      dup = val;\\n    }\\n    set.add(val);\\n  }\\n  \\n  // math\\n  int expectedSum = (1 + n) * n / 2;\\n  int miss = expectedSum - actualSum;\\n  \\n  return new int[] { dup, miss };\\n}\\n```\\n\\n\\n\\n\\n\\n### Bit Manipulation (XOR)\\n\\n**No Extra Space!**\\n\\nThe idea is very clear. I should use an example to explain it.\\n\\n```java\\n// 1  2  3  4  5 (expected)\\n// 1  2  2  4  5 (actual)\\n```\\n\\n**Note:** XOR: `x ^ x = 0`, `x ^ y ^ x = y`, `x ^ y ^ x ^ x ^ y = x` (remember this usage!)\\n\\n**First Pass:** By doing XOR for each number above, `xor` would finally equals `2^3`, which is `miss^dup`; however, we don\\'t know which is which!\\n\\n**Second Pass:**\\n\\n- Then we use `xor & ~(xor - 1)` to get the rightmost one-bit of `xor`. For example, if `xor` in binary is `00011010`, the result is `00000010`. We call it `oneBit`.\\n- Again, for each number above, if a number has that bit on, we put it to a `set` group; otherwise, throw it to `unset` group.\\n\\n```java\\n// 1  2  3  4  5\\n// 1  2  2  4  5\\n//\\n//    set: 1  1  2  2  2\\n//  unset: 3  4  4  5  5\\n//\\n// notice that I don\\'t actually examine their binary form, just for demonstration\\n```\\n\\n- By doing XOR for `set` and `unset` groups, we would have `setXor = 2` and `unsetXor = 3`; however, we don\\'t know which is which! T_T\\n\\n**Third Pass:** Decide which is which :)\\n\\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n\\n  // first pass\\n  int xor = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    xor ^= (i ^ nums[i - 1]);\\n  }\\n  \\n  // second pass\\n  int oneBit = xor & ~(xor - 1);\\n  int setXor = 0, unsetXor = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    // for i\\n    if ((i & oneBit) > 0) {\\n      setXor ^= i;\\n    } else {\\n      unsetXor ^= i;\\n    }\\n    // for nums[i - 1]\\n    if ((nums[i - 1] & oneBit) > 0) {\\n      setXor ^= nums[i - 1];\\n    } else {\\n      unsetXor ^= nums[i - 1];\\n    }\\n  }\\n\\n  // third pass\\n  int dup = setXor;\\n  int miss = unsetXor;\\n  for (int val : nums) {\\n    if (miss == val) { // miss should be the duplicate\\n      dup = unsetXor;\\n      miss = setXor; // exchange\\n      break;\\n    }\\n  }\\n\\n  return new int[] { dup, miss };\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Sorting\\n\\n**Not Recommended!**\\n\\nCheck for corner cases: `[1, 1]`, `[2, 2]`, `[1, 2, 2]`, `[2, 2, 3]`. We can reduce the corner case logic of `miss` to checking the first element and last element in the array.\\n- If the first element after sorting is not `1`, then `1` is the missing element.\\n- If the last element after sorting is not `n`, then `n` is the missing element.\\n\\n\\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  int n = nums.length;\\n  Arrays.sort(nums);\\n  int dup = -1, missing = -1;\\n  if (n == 2) {\\n    return (nums[0] == 1) ? new int[] { 1, 2 } : new int[] { 2, 1 };\\n  }\\n  for (int i = 0; i < n - 1; ++i) {\\n    int curr = nums[i], next = nums[i + 1];\\n    if (curr == next) dup = curr;\\n    else if (curr + 1 < next) missing = curr + 1;\\n  }\\n  // checking corner cases\\n  if (nums[0] != 1) missing = 1;\\n  if (nums[n - 1] != n) missing = n;\\n  return new int[] { dup, missing };\\n}\\n```\\n\\n**Time:** `O(NlogN)`\\n**Space:** `O(1)`",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```java\\nInput: nums = [1,2,2,4]\\nOutput: [2,3]\\n```\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n  int dup = -1, miss = -1;\\n\\n  for (int i = 1; i <= n; ++i) { // for 1...n\\n    int count = 0;\\n    for (int val : nums) {\\n      if (val == i) {\\n        count += 1;\\n      }\\n    }\\n    if (count == 2) dup = i;\\n    if (count == 0) miss = i;\\n    // if both are set, then break\\n    if (dup > 0 && miss > 0) break;\\n  }\\n\\n  return new int[] { dup, miss };\\n}\\n```\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n  Map<Integer, Integer> map = new HashMap<>();\\n  // first pass - count\\n  for (int val : nums) {\\n    map.put(val, map.getOrDefault(val, 0) + 1);\\n  }\\n  // second pass\\n  int dup = -1, miss = -1;\\n  for (int i = 1; i <= n; ++i) {\\n    if (map.containsKey(i) == false) miss = i;\\n    else if (map.get(i) == 2) dup = i;\\n    // if both are set, then break\\n    if (dup > 0  && miss > 0) break;\\n  }\\n  return new int[] { dup, miss };\\n}\\n```\n```java\\n// actual:   1 + 2 + 4 = 7 (use a hash set to remove extra duplicates)\\n// expected: 1 + 2 + 3 + 4 = 10\\n```\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n  Set<Integer> set = new HashSet<>();\\n\\n  int actualSum = 0;\\n  int dup = 0;\\n  for (int val : nums) {\\n    if (!set.contains(val)) {\\n      actualSum += val;\\n    } else {\\n      dup = val;\\n    }\\n    set.add(val);\\n  }\\n  \\n  // math\\n  int expectedSum = (1 + n) * n / 2;\\n  int miss = expectedSum - actualSum;\\n  \\n  return new int[] { dup, miss };\\n}\\n```\n```java\\n// 1  2  3  4  5 (expected)\\n// 1  2  2  4  5 (actual)\\n```\n```java\\n// 1  2  3  4  5\\n// 1  2  2  4  5\\n//\\n//    set: 1  1  2  2  2\\n//  unset: 3  4  4  5  5\\n//\\n// notice that I don\\'t actually examine their binary form, just for demonstration\\n```\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  // assume nums is non-empty\\n  int n = nums.length;\\n\\n  // first pass\\n  int xor = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    xor ^= (i ^ nums[i - 1]);\\n  }\\n  \\n  // second pass\\n  int oneBit = xor & ~(xor - 1);\\n  int setXor = 0, unsetXor = 0;\\n  for (int i = 1; i <= n; ++i) {\\n    // for i\\n    if ((i & oneBit) > 0) {\\n      setXor ^= i;\\n    } else {\\n      unsetXor ^= i;\\n    }\\n    // for nums[i - 1]\\n    if ((nums[i - 1] & oneBit) > 0) {\\n      setXor ^= nums[i - 1];\\n    } else {\\n      unsetXor ^= nums[i - 1];\\n    }\\n  }\\n\\n  // third pass\\n  int dup = setXor;\\n  int miss = unsetXor;\\n  for (int val : nums) {\\n    if (miss == val) { // miss should be the duplicate\\n      dup = unsetXor;\\n      miss = setXor; // exchange\\n      break;\\n    }\\n  }\\n\\n  return new int[] { dup, miss };\\n}\\n```\n```java\\npublic int[] findErrorNums(int[] nums) {\\n  int n = nums.length;\\n  Arrays.sort(nums);\\n  int dup = -1, missing = -1;\\n  if (n == 2) {\\n    return (nums[0] == 1) ? new int[] { 1, 2 } : new int[] { 2, 1 };\\n  }\\n  for (int i = 0; i < n - 1; ++i) {\\n    int curr = nums[i], next = nums[i + 1];\\n    if (curr == next) dup = curr;\\n    else if (curr + 1 < next) missing = curr + 1;\\n  }\\n  // checking corner cases\\n  if (nums[0] != 1) missing = 1;\\n  if (nums[n - 1] != n) missing = n;\\n  return new int[] { dup, missing };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105505,
                "title": "very-simple-using-array-and-bit",
                "content": "Using Array Indexing:\\n```\\npublic int[] findErrorNums(int[] nums) {\\n      int[] arr = new int[nums.length+1];\\n      int a=0,b=arr.length;       \\n      for(int i: nums) arr[i]++;\\n        \\n      for(int j=1;j<arr.length;j++){\\n          if(arr[j]==2) a=j;\\n          if(arr[j]==0) b=j;            \\n      }\\n      return new int[]{a,b};\\n}\\n```\\nUsing Bit:\\n```\\npublic int[] findErrorNums(int[] nums) {\\n    BitSet bs = new BitSet(nums.length+1);\\n    int a=0;\\n    for(int i:nums){\\n          if(bs.get(i)) a=i;\\n          bs.set(i);            \\n    }\\n    return new int[]{a,bs.nextClearBit(1)};\\n}",
                "solutionTags": [],
                "code": "```\\npublic int[] findErrorNums(int[] nums) {\\n      int[] arr = new int[nums.length+1];\\n      int a=0,b=arr.length;       \\n      for(int i: nums) arr[i]++;\\n        \\n      for(int j=1;j<arr.length;j++){\\n          if(arr[j]==2) a=j;\\n          if(arr[j]==0) b=j;            \\n      }\\n      return new int[]{a,b};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616799,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>a(n);\\n        vector<int>res(2);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[nums[i]-1]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==2)\\n            {\\n                res[0]=i+1;\\n            }\\n            if(a[i]==0)\\n            {\\n                res[1]=i+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>a(n);\\n        vector<int>res(2);\\n        for(int i=0;i<n;i++)\\n        {\\n            a[nums[i]-1]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==2)\\n            {\\n                res[0]=i+1;\\n            }\\n            if(a[i]==0)\\n            {\\n                res[1]=i+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477636,
                "title": "easy-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n\\n        HashSet<Integer> set= new HashSet<>();\\n        int sum=0;\\n        for(int num: nums){\\n            if(set.contains(num)){\\n                res[0]=num;\\n            }else {\\n                \\n                set.add(num);\\n                 sum+=num;\\n            \\n        }\\n       \\n        }\\n        // we got the number which was repeated twice\\n\\n        int n=nums.length;\\n        res[1]=(n*(n+1)/2)-(sum);\\n\\n\\n\\nreturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n\\n        HashSet<Integer> set= new HashSet<>();\\n        int sum=0;\\n        for(int num: nums){\\n            if(set.contains(num)){\\n                res[0]=num;\\n            }else {\\n                \\n                set.add(num);\\n                 sum+=num;\\n            \\n        }\\n       \\n        }\\n        // we got the number which was repeated twice\\n\\n        int n=nums.length;\\n        res[1]=(n*(n+1)/2)-(sum);\\n\\n\\n\\nreturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465991,
                "title": "hashmap-easy-one-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        map<int,int>m;\\n       \\n        vector<int>ans;\\n        for(int i=1;i<=nums.size();i++)  // storing all elements till array size with zero freq\\n        m[i]=0;\\n\\n        for(auto i:nums) // assign the freq acc to the given arr\\n        m[i]++;\\n\\n        int i=0;\\n       for(auto j:m){         // if there is a duplication then push the element to ans array \\n               if(j.second>1)\\n               ans.push_back(j.first);\\n       }\\n      for(auto j:m){      // if the freq is zero that means element is missing so,add it to the ans array\\n           if(j.second==0)\\n           ans.push_back(j.first);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        map<int,int>m;\\n       \\n        vector<int>ans;\\n        for(int i=1;i<=nums.size();i++)  // storing all elements till array size with zero freq\\n        m[i]=0;\\n\\n        for(auto i:nums) // assign the freq acc to the given arr\\n        m[i]++;\\n\\n        int i=0;\\n       for(auto j:m){         // if there is a duplication then push the element to ans array \\n               if(j.second>1)\\n               ans.push_back(j.first);\\n       }\\n      for(auto j:m){      // if the freq is zero that means element is missing so,add it to the ans array\\n           if(j.second==0)\\n           ans.push_back(j.first);\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812805,
                "title": "oneliner",
                "content": "```\\ndef findErrorNums(self, nums):\\n    return [sum(nums) - sum(set(nums)), sum(range(1, len(nums)+1)) - sum(set(nums))]\\n```",
                "solutionTags": [],
                "code": "```\\ndef findErrorNums(self, nums):\\n    return [sum(nums) - sum(set(nums)), sum(range(1, len(nums)+1)) - sum(set(nums))]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2739495,
                "title": "math-solution-easy-to-read",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        Set<Integer> dedupe = new HashSet<>();\\n        int duplicate = 0, sum = 0;\\n        for(int num : nums) {\\n            if(dedupe.contains(num)) {\\n                duplicate = num;\\n            }\\n            dedupe.add(num);\\n            sum+=num;\\n        }\\n        int expectedSum = ((nums.length)*(nums.length + 1))/2;\\n        int missing = duplicate - sum + expectedSum;\\n        return new int[]{duplicate, missing};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        Set<Integer> dedupe = new HashSet<>();\\n        int duplicate = 0, sum = 0;\\n        for(int num : nums) {\\n            if(dedupe.contains(num)) {\\n                duplicate = num;\\n            }\\n            dedupe.add(num);\\n            sum+=num;\\n        }\\n        int expectedSum = ((nums.length)*(nums.length + 1))/2;\\n        int missing = duplicate - sum + expectedSum;\\n        return new int[]{duplicate, missing};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736673,
                "title": "7ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int N = nums.length, sum = N * (N + 1) / 2;\\n        int[] result = new int[2];\\n        boolean[] seen = new boolean[N+1];\\n        for (int num : nums) {\\n            sum -= num;\\n            if (seen[num]) result[0] = num;\\n            seen[num] = true;\\n        }\\n        result[1] = sum + result[0];\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int N = nums.length, sum = N * (N + 1) / 2;\\n        int[] result = new int[2];\\n        boolean[] seen = new boolean[N+1];\\n        for (int num : nums) {\\n            sum -= num;\\n            if (seen[num]) result[0] = num;\\n            seen[num] = true;\\n        }\\n        result[1] = sum + result[0];\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736260,
                "title": "python-inplace-solution-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        #Inplace sort\\n        while i < len(nums) : \\n            if nums[i]-1 <= len(nums) and nums[i]-1 != i and nums[nums[i]-1] != nums[i] : \\n                temp = nums[nums[i]-1]\\n\\t\\t\\t\\tnums[nums[i]-1] = nums[i]\\n                nums[i]  = temp\\n                i -= 1\\n            i+=1\\n        \\n        #check for index matches with number-1 if not return\\n        for i in range(len(nums)) :\\n            if nums[i] != i+1 :\\n                return [nums[i],i+1]",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        i = 0\\n        #Inplace sort\\n        while i < len(nums) : \\n            if nums[i]-1 <= len(nums) and nums[i]-1 != i and nums[nums[i]-1] != nums[i] : \\n                temp = nums[nums[i]-1]\\n\\t\\t\\t\\tnums[nums[i]-1] = nums[i]\\n                nums[i]  = temp\\n                i -= 1\\n            i+=1\\n        \\n        #check for index matches with number-1 if not return\\n        for i in range(len(nums)) :\\n            if nums[i] != i+1 :\\n                return [nums[i],i+1]",
                "codeTag": "Java"
            },
            {
                "id": 2735730,
                "title": "easy-java-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] arr = new int[2];\\n        int check[]=new int[nums.length+1];\\n        for(int i :nums)check[i]++;\\n        \\n\\n       for(int i=1;i<check.length;i++){\\n           if(check[i]==2)arr[0]=i;\\n           if(check[i]==0)arr[1]=i;\\n       }\\n\\n    \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] arr = new int[2];\\n        int check[]=new int[nums.length+1];\\n        for(int i :nums)check[i]++;\\n        \\n\\n       for(int i=1;i<check.length;i++){\\n           if(check[i]==2)arr[0]=i;\\n           if(check[i]==0)arr[1]=i;\\n       }\\n\\n    \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734925,
                "title": "c-easy-solution-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0, sqSum = 0, arrSum = 0, arrSqSum = 0;\\n        for(int i = 0; i < n; i++){\\n            sum += (i+1);\\n            arrSum += nums[i];\\n            sqSum += (i+1)*(i+1);\\n            arrSqSum += nums[i]*nums[i];\\n        }\\n        \\n        // X --> Missing umber, Y --> repeating number\\n        int s1 = sum - arrSum;   // s1 = X-Y;\\n        int s2 = sqSum - arrSqSum;   // s2 = X^2 - Y^2;\\n        int s3 = s2/s1;   // s3 = X + Y;\\n        //solving Equation s1 ans s3;\\n        int X = (s1 + s3)/2;\\n        int Y = (s3 - s1)/2;\\n        \\n        vector<int> ans;\\n        ans.push_back(Y);\\n        ans.push_back(X);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        long long sum = 0, sqSum = 0, arrSum = 0, arrSqSum = 0;\\n        for(int i = 0; i < n; i++){\\n            sum += (i+1);\\n            arrSum += nums[i];\\n            sqSum += (i+1)*(i+1);\\n            arrSqSum += nums[i]*nums[i];\\n        }\\n        \\n        // X --> Missing umber, Y --> repeating number\\n        int s1 = sum - arrSum;   // s1 = X-Y;\\n        int s2 = sqSum - arrSqSum;   // s2 = X^2 - Y^2;\\n        int s3 = s2/s1;   // s3 = X + Y;\\n        //solving Equation s1 ans s3;\\n        int X = (s1 + s3)/2;\\n        int Y = (s3 - s1)/2;\\n        \\n        vector<int> ans;\\n        ans.push_back(Y);\\n        ans.push_back(X);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734500,
                "title": "java-easy-understanding-o-n-solution",
                "content": "```\\n public int[] findErrorNums(int[] nums) {\\n\\t\\tSet<Integer> s=new HashSet<>();\\n\\t\\tint []arr=new int[2];\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(s.contains(nums[i])) arr[0]=nums[i];\\n\\t\\t\\ts.add(nums[i]);\\n\\t\\t}\\n\\t\\tfor(int i=0;i<nums.length;i++) if(!s.contains(i+1)) arr[1]=i+1;\\n\\t\\treturn arr;\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\n public int[] findErrorNums(int[] nums) {\\n\\t\\tSet<Integer> s=new HashSet<>();\\n\\t\\tint []arr=new int[2];\\n\\t\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\t\\tif(s.contains(nums[i])) arr[0]=nums[i];\\n\\t\\t\\ts.add(nums[i]);\\n\\t\\t}\\n\\t\\tfor(int i=0;i<nums.length;i++) if(!s.contains(i+1)) arr[1]=i+1;\\n\\t\\treturn arr;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2734401,
                "title": "java-easy-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int rep = 0, ans=0;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        for(int i=1;i<=nums.length;++i){\\n            if(map.containsKey(i)){\\n                if(map.get(i)==2){\\n                    rep=i;\\n                }\\n            }\\n            else{\\n                ans=i;\\n            }\\n        }\\n        return new int[]{rep,ans};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int rep = 0, ans=0;\\n        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();\\n        for(int i:nums){\\n            map.put(i,map.getOrDefault(i,0)+1);\\n        }\\n        for(int i=1;i<=nums.length;++i){\\n            if(map.containsKey(i)){\\n                if(map.get(i)==2){\\n                    rep=i;\\n                }\\n            }\\n            else{\\n                ans=i;\\n            }\\n        }\\n        return new int[]{rep,ans};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733898,
                "title": "c-easy-solution",
                "content": "```class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n    unordered_set<int> s;\\n        vector<int> ans;\\n       int sum=0;\\n        for(auto &x:nums){\\n            if(s.find(x)!=s.end()){\\n                ans.push_back(x);\\n            }else{\\n                s.insert(x);\\n                sum+=x;\\n            }\\n        }\\n        int n=nums.size();\\n        int t=(n*(n+1))/2;\\n        ans.push_back(t-sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n    unordered_set<int> s;\\n        vector<int> ans;\\n       int sum=0;\\n        for(auto &x:nums){\\n            if(s.find(x)!=s.end()){\\n                ans.push_back(x);\\n            }else{\\n                s.insert(x);\\n                sum+=x;\\n            }\\n        }\\n        int n=nums.size();\\n        int t=(n*(n+1))/2;\\n        ans.push_back(t-sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696064,
                "title": "1-hour-spent-to-solve-java-solution",
                "content": "# class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        Arrays.sort(nums);\\n        int b[]=new int[nums.length+1];\\n        int x=0;\\n        int y=0;\\n        int c=1;\\n         for(int i=0;i<nums.length;i++)\\n        {\\n         b[nums[i]]=b[nums[i]]+1;\\n         }\\n        for(int i=1;i<b.length;i++)\\n        {\\n           if(b[i]==0)\\n           {\\n               y=i;\\n           }\\n            if(b[i]==2)\\n            {\\n                x=i;\\n            }\\n        }\\n        return new int[]{x,y};\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        Arrays.sort(nums);\\n        int b[]=new int[nums.length+1];\\n        int x=0;\\n        int y=0;\\n        int c=1;\\n         for(int i=0;i<nums.length;i++)\\n        {\\n         b[nums[i]]=b[nums[i]]+1;\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2459957,
                "title": "c-o-n-time-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int> res = {0, 0};\\n        unordered_map<int, int> count;\\n        long sum = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(count.find(nums[i]) == count.end()){\\n                count[nums[i]] = 1;\\n                sum += nums[i];\\n            }\\n            else{\\n                count[nums[i]]++;\\n                res[0] = nums[i];\\n            }\\n        }\\n        \\n        res[1] = nums.size()*(nums.size()+1)/2 - sum;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int> res = {0, 0};\\n        unordered_map<int, int> count;\\n        long sum = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(count.find(nums[i]) == count.end()){\\n                count[nums[i]] = 1;\\n                sum += nums[i];\\n            }\\n            else{\\n                count[nums[i]]++;\\n                res[0] = nums[i];\\n            }\\n        }\\n        \\n        res[1] = nums.size()*(nums.size()+1)/2 - sum;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421383,
                "title": "faster-than-99-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) {\\n         int i=0;\\n        while (i<arr.length){\\n            int correct = arr[i] -1 ;\\n            if( arr[i] != arr[correct]) {\\n                swap(arr,i,correct);\\n            } else {\\n                i++;\\n            }\\n        }\\n        //search for 1st missing number\\n        for(int index =0; index<arr.length; index++){\\n            if(arr[index] != index + 1){\\n                return new int[] {arr[index], index+1};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first]=arr[second];\\n        arr[second]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] arr) {\\n         int i=0;\\n        while (i<arr.length){\\n            int correct = arr[i] -1 ;\\n            if( arr[i] != arr[correct]) {\\n                swap(arr,i,correct);\\n            } else {\\n                i++;\\n            }\\n        }\\n        //search for 1st missing number\\n        for(int index =0; index<arr.length; index++){\\n            if(arr[index] != index + 1){\\n                return new int[] {arr[index], index+1};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n\\n    }\\n    static void swap(int[] arr, int first, int second){\\n        int temp = arr[first];\\n        arr[first]=arr[second];\\n        arr[second]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347625,
                "title": "four-solutions-c-sorting-bit-manipulation-easy-understandable",
                "content": "Time: O(n*Log n)  Space: O(n)\\n--> Sorting\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int res1,res2=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                res1=nums[i];\\n                nums[i]=0;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            res2^=nums[i]^(i+1);\\n        }\\n        return {res1,res2};\\n    }\\n};\\n```\\nTime: O(n)  Space: O(n)\\n--> Map\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        int res1,res2;\\n        map<int,int> m;\\n        for(int x: nums){\\n            m[x]++;\\n            if(m[x]==2){res1=x;break;}\\n        }\\n        res2=res1;\\n        for(int i=0;i<n;i++){\\n            res2^=nums[i]^(i+1);\\n        }\\n        return {res1,res2};\\n    }\\n};\\n```\\nTime: O(n)  Space: O(1)\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        int res1,res2=0;\\n        for(int x:nums){\\n            if(nums[abs(x)-1]<0)\\n                res1=abs(x);\\n            else\\n                nums[abs(x)-1]*=-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0)\\n                res2=i+1;\\n        }\\n        return {res1,res2};\\n    }\\n};\\n```\\nTime: O(n)  Space: O(1)\\n--> Bit Manipulation\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=0,t1=0,t2=0;\\n        for(int i=0;i<n;i++){\\n            x^=nums[i]^(i+1);\\n        }\\n        int rsb= x & ~(x-1);\\n        for(int i:nums){\\n            if((i&rsb))\\n                t1^=i;\\n            else\\n                t2^=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if((i&rsb))\\n                t1^=i;\\n            else\\n                t2^=i;\\n        }\\n        for(int i:nums){\\n            if(i==t1)\\n                return {t1,t2};\\n        }\\n        return {t2,t1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int res1,res2=0;\\n        for(int i=0;i<n-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                res1=nums[i];\\n                nums[i]=0;\\n                break;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            res2^=nums[i]^(i+1);\\n        }\\n        return {res1,res2};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        int res1,res2;\\n        map<int,int> m;\\n        for(int x: nums){\\n            m[x]++;\\n            if(m[x]==2){res1=x;break;}\\n        }\\n        res2=res1;\\n        for(int i=0;i<n;i++){\\n            res2^=nums[i]^(i+1);\\n        }\\n        return {res1,res2};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        int res1,res2=0;\\n        for(int x:nums){\\n            if(nums[abs(x)-1]<0)\\n                res1=abs(x);\\n            else\\n                nums[abs(x)-1]*=-1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0)\\n                res2=i+1;\\n        }\\n        return {res1,res2};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        int x=0,t1=0,t2=0;\\n        for(int i=0;i<n;i++){\\n            x^=nums[i]^(i+1);\\n        }\\n        int rsb= x & ~(x-1);\\n        for(int i:nums){\\n            if((i&rsb))\\n                t1^=i;\\n            else\\n                t2^=i;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if((i&rsb))\\n                t1^=i;\\n            else\\n                t2^=i;\\n        }\\n        for(int i:nums){\\n            if(i==t1)\\n                return {t1,t2};\\n        }\\n        return {t2,t1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380038,
                "title": "javascript-solution-easy-understand",
                "content": "Runtime: 76 ms, faster than 98.51% of JavaScript online submissions for Set Mismatch.\\nMemory Usage: 46.7 MB, less than 21.19% of JavaScript online submissions for Set Mismatch.\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findErrorNums = function(nums) {\\n    // Ex: [1,2,2,4]\\n    const n = nums.length\\n    const except = n * (n + 1) / 2  // 1 + 2 + 3 + 4\\n    \\n    const set = new Set(nums) // {1, 2, 4}\\n    let setSum = 0\\n    set.forEach(val => setSum+=val) // 1 + 2 + 4 \\n    \\n    const numSum = nums.reduce((curr,acc) => curr + acc) // 1 + 2 + 2 + 4\\n    \\n    // numSum - setSum = [1 + 2 + 2 + 4] - [1 + 2 + 4] = 2\\n    // except - setSum = [1 + 2 + 3 + 4] - [1 + 2 + 4] = 3\\n    \\n    return [numSum - setSum, except - setSum]\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findErrorNums = function(nums) {\\n    // Ex: [1,2,2,4]\\n    const n = nums.length\\n    const except = n * (n + 1) / 2  // 1 + 2 + 3 + 4\\n    \\n    const set = new Set(nums) // {1, 2, 4}\\n    let setSum = 0\\n    set.forEach(val => setSum+=val) // 1 + 2 + 4 \\n    \\n    const numSum = nums.reduce((curr,acc) => curr + acc) // 1 + 2 + 2 + 4\\n    \\n    // numSum - setSum = [1 + 2 + 2 + 4] - [1 + 2 + 4] = 2\\n    // except - setSum = [1 + 2 + 3 + 4] - [1 + 2 + 4] = 3\\n    \\n    return [numSum - setSum, except - setSum]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1344582,
                "title": "c-solution-o-n",
                "content": "Runtime: 24 ms, faster than 90.64% of C++ online submissions for Set Mismatch.\\nMemory Usage: 21.3 MB, less than 97.63% of C++ online submissions for Set Mismatch.\\n\\nProblem is similar to [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/).\\n\\n```\\nMark the element of nums[i] index in array to negative. When the duplicate value comes nums[nums[i]] will\\nbe a negative value and we can find it. Also mis value = Sum(1:n) - Sum(nums) + duplicate value\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int t_sum = (n * (n+1))/2;\\n        int a_sum = 0;\\n        int dup;\\n        int mis;\\n        \\n        //check if nums[nums[i]] is negative, if then nums[i] is the duplicate value\\n        // in each step also mark nums[nums[i]] as negative value\\n        for(int i=0;i<n;i++)\\n        {\\n            a_sum+=abs(nums[i]);\\n            if(nums[abs(nums[i])-1]<0)dup = abs(nums[i]);\\n            nums[abs(nums[i])-1] = -1 * nums[abs(nums[i])-1];\\n        }\\n        \\n        mis = t_sum - a_sum + dup;\\n        return {dup,mis};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nMark the element of nums[i] index in array to negative. When the duplicate value comes nums[nums[i]] will\\nbe a negative value and we can find it. Also mis value = Sum(1:n) - Sum(nums) + duplicate value\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int t_sum = (n * (n+1))/2;\\n        int a_sum = 0;\\n        int dup;\\n        int mis;\\n        \\n        //check if nums[nums[i]] is negative, if then nums[i] is the duplicate value\\n        // in each step also mark nums[nums[i]] as negative value\\n        for(int i=0;i<n;i++)\\n        {\\n            a_sum+=abs(nums[i]);\\n            if(nums[abs(nums[i])-1]<0)dup = abs(nums[i]);\\n            nums[abs(nums[i])-1] = -1 * nums[abs(nums[i])-1];\\n        }\\n        \\n        mis = t_sum - a_sum + dup;\\n        return {dup,mis};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1105427,
                "title": "python-3",
                "content": "class Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        temp = sum(set(nums))\\n        replaced= sum(nums) - temp\\n        missed = sum(range(len(nums)+1)) - temp\\n        return [replaced, missed]",
                "solutionTags": [],
                "code": "class Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        temp = sum(set(nums))\\n        replaced= sum(nums) - temp\\n        missed = sum(range(len(nums)+1)) - temp\\n        return [replaced, missed]",
                "codeTag": "Java"
            },
            {
                "id": 920549,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        set_sum = sum(set(nums))\\n        return [sum(nums) - set_sum, sum(range(1, len(nums) + 1)) - set_sum]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        set_sum = sum(set(nums))\\n        return [sum(nums) - set_sum, sum(range(1, len(nums) + 1)) - set_sum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501667,
                "title": "python-go-o-n-sol-by-summation-formula-90-w-comment",
                "content": "Python O(n) sol. by summation formula.\\n\\n---\\n\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        \\n        # get the size of input array, nums\\n\\t\\t\\n        n = len(nums)\\n        \\n        # perfect_sum \\n        # = n * ( n+1 ) // 2\\n        # = sum of unique element + missing element\\n\\t\\t\\n        perfect_sum = n * (n+1) // 2\\n\\n        # compute the missing element from summation formula\\n\\t\\t\\n        missing_element = perfect_sum - sum( set(nums) )\\n\\n        # perfect sum + repeated element = sum of nums + missing element\\n        # compute the repeated element \\n\\t\\t\\n        repeated_element = sum(nums) + missing_element - perfect_sum\\n\\n        return [ repeated_element, missing_element]\\n```\\n\\n---\\n\\n**Implementation** in Go:\\n\\nNote: hashset is not natively support in Golang, so we use map(i.e., dictionary) as alternative plan.\\n\\n```\\nfunc findErrorNums(nums []int) []int {\\n    \\n    n := len(nums)\\n    \\n    missing, repeated := 0, 0\\n    \\n    // perfect sum = 1 + 2 + 3 + ... + n = n * (n + 1) / 2\\n    perfect_sum := n * (n + 1) / 2\\n    \\n    // key: number\\n    // value: true for first occurrence\\n    num_dict := make( map[int]bool)\\n    \\n    // sum for distinct numbers in input array\\n    distinct_sum := 0\\n    \\n    for _, number := range nums{\\n        \\n        if _, exist := num_dict[ number ]; !exist{\\n\\t\\t\\n            // first time occurrence, update boolean flag and distinct sum\\n            num_dict[ number ] = true\\n            distinct_sum += number\\n            \\n        } else {\\n\\t\\t\\n            // second time occurrence, catch the repeated number\\n            repeated = number\\n            \\n        }\\n    }\\n    \\n    // missing number + distinct sum = perfect sum\\n    missing = perfect_sum - distinct_sum\\n    \\n    return []int{repeated, missing}\\n    \\n}\\n```\\n\\n---\\n\\nReference:\\n[1] [Wiki: sum of first k natural numbers](https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_\\u22EF)\\n\\n[2] [Python official docs about built-in function: sum()](https://docs.python.org/3.8/library/functions.html?highlight=sum#sum)\\n\\n[3] [Python official docs about built-in data structure: set()](https://docs.python.org/3.8/library/stdtypes.html#set)\\n\\n[4] [Golang official docs about map(i.e., hash table)](https://blog.golang.org/maps)",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        \\n        # get the size of input array, nums\\n\\t\\t\\n        n = len(nums)\\n        \\n        # perfect_sum \\n        # = n * ( n+1 ) // 2\\n        # = sum of unique element + missing element\\n\\t\\t\\n        perfect_sum = n * (n+1) // 2\\n\\n        # compute the missing element from summation formula\\n\\t\\t\\n        missing_element = perfect_sum - sum( set(nums) )\\n\\n        # perfect sum + repeated element = sum of nums + missing element\\n        # compute the repeated element \\n\\t\\t\\n        repeated_element = sum(nums) + missing_element - perfect_sum\\n\\n        return [ repeated_element, missing_element]\\n```\n```\\nfunc findErrorNums(nums []int) []int {\\n    \\n    n := len(nums)\\n    \\n    missing, repeated := 0, 0\\n    \\n    // perfect sum = 1 + 2 + 3 + ... + n = n * (n + 1) / 2\\n    perfect_sum := n * (n + 1) / 2\\n    \\n    // key: number\\n    // value: true for first occurrence\\n    num_dict := make( map[int]bool)\\n    \\n    // sum for distinct numbers in input array\\n    distinct_sum := 0\\n    \\n    for _, number := range nums{\\n        \\n        if _, exist := num_dict[ number ]; !exist{\\n\\t\\t\\n            // first time occurrence, update boolean flag and distinct sum\\n            num_dict[ number ] = true\\n            distinct_sum += number\\n            \\n        } else {\\n\\t\\t\\n            // second time occurrence, catch the repeated number\\n            repeated = number\\n            \\n        }\\n    }\\n    \\n    // missing number + distinct sum = perfect sum\\n    missing = perfect_sum - distinct_sum\\n    \\n    return []int{repeated, missing}\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443497,
                "title": "645-set-mismatch-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Limit State**\\n| O(T): O(n) | O(S): O(n) | Rt: 216ms | \\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, mapp = 0, 0, [0] * len(nums)\\n        for i in nums: mapp[i-1] += 1\\n        for i, v in enumerate(mapp): \\n            if v == 0: mis = i + 1\\n            elif v > 1: du = i + 1\\n        return [du, mis]\\n```\\nAlternative: immediate return. | Rt: 212ms |\\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, mapp = 0, 0, [0] * len(nums)\\n        for i in nums: mapp[i-1] += 1\\n        for i, v in enumerate(mapp): \\n            if v == 0: mis = i + 1\\n            elif v > 1: du = i + 1\\n            if du and mis: return [du, mis]\\n```\\nTriple: trific concise version. | Rt: 204ms | O(T): O(n) |\\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        mapp = [None] * len(nums)\\n        for i in nums: mapp[i-1] = not mapp[i-1]\\n        return (mapp.index(False) + 1, mapp.index(None) + 1)\\n```\\nReferrence: idea from https://leetcode.com/problems/set-mismatch/discuss/105552/Python-Straightforward-with-Explanation/108147\\nComment: wonderful use of None, False and True. None will be taken as False in \"not\" operation, merely 3 states without change the time complexity.\\n\\n\\n**II). Counter**\\n| O(T): O(n) | O(S): O(n) | Rt: 220ms | \\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, ct = 0, 0, collections.Counter(nums)\\n        for i in range(1, len(nums) + 1):\\n            if ct[i] == 0: mis = i\\n            elif ct[i] > 1: du = i\\n        return [du, mis]\\n```\\n\\n\\n**III). Get Missed One First**\\n| O(T): O(n) | O(S): O(n) | Rt: 200ms | \\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        l = len(nums)\\n        suma = (1 + l) * l // 2\\n        mis = (set(range(1, l + 1)) - set(nums)).pop()\\n        return [sum(nums) + mis - suma, mis]\\n```\\nComment: Once you can get one of the two, you can calculate the other using math in constant time. \\n\\n\\n**IV). In-Place Marking**\\n| O(T): O(n) | O(S): O(1) | Rt: 216ms | \\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, l = 0, 0, len(nums)\\n        for i in nums: nums[i % l - 1] += l\\n        for i, v in enumerate(nums): \\n            if v <= l: mis = i + 1\\n            elif v > 2 * l: du = i + 1\\n            if du and mis: return [du, mis]\\n```\\nComment: same as the limited state solution, no extra space required. Learn the trick how to mark index info without using extra space by negating value or add by length. Both tricks won\\'t cost you the original value, you can find them back throught abs or mod. Why we don\\'t utilize negating here? because negating method can only distinguish two states while we need 3 states here (correct, duplicated, missed). The add by length can distinguish 3 state here by value check. \\nAlternative: using negating trick with middle check. | Rt: 236ms |\\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du = 0\\n        for i in nums:\\n            if nums[abs(i) - 1] < 0: du = abs(i)\\n            nums[abs(i) - 1] = - abs(nums[abs(i) - 1])\\n        for i, v in enumerate(nums): \\n            if v > 0: return [du, i + 1] \\n```\\nReferrence: idea from https://leetcode.com/problems/set-mismatch/discuss/105507/Java-O(n)-Time-O(1)-Space\\n\\n\\n**V). Get Duplicated One First**\\n| O(T): O(n) | O(S): O(n) | Rt: 196ms | \\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        setsum = sum(set(nums))\\n        du = sum(nums) - setsum\\n        suma = (1 + len(nums)) * len(nums) // 2\\n        return [du, suma - setsum]\\n```\\n\\nOthers: Swap solution. I really don\\'t suggest this solution because it is not efficient and too heavy to solve a problem like this easy. Also, you easily get lost in the swaping process. Anyway -- https://leetcode.com/problems/set-mismatch/discuss/105515/C%2B%2B-6-lines-solution-with-explanation\\n\\n",
                "solutionTags": [],
                "code": "```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, mapp = 0, 0, [0] * len(nums)\\n        for i in nums: mapp[i-1] += 1\\n        for i, v in enumerate(mapp): \\n            if v == 0: mis = i + 1\\n            elif v > 1: du = i + 1\\n        return [du, mis]\\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, mapp = 0, 0, [0] * len(nums)\\n        for i in nums: mapp[i-1] += 1\\n        for i, v in enumerate(mapp): \\n            if v == 0: mis = i + 1\\n            elif v > 1: du = i + 1\\n            if du and mis: return [du, mis]\\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        mapp = [None] * len(nums)\\n        for i in nums: mapp[i-1] = not mapp[i-1]\\n        return (mapp.index(False) + 1, mapp.index(None) + 1)\\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, ct = 0, 0, collections.Counter(nums)\\n        for i in range(1, len(nums) + 1):\\n            if ct[i] == 0: mis = i\\n            elif ct[i] > 1: du = i\\n        return [du, mis]\\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        l = len(nums)\\n        suma = (1 + l) * l // 2\\n        mis = (set(range(1, l + 1)) - set(nums)).pop()\\n        return [sum(nums) + mis - suma, mis]\\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du, mis, l = 0, 0, len(nums)\\n        for i in nums: nums[i % l - 1] += l\\n        for i, v in enumerate(nums): \\n            if v <= l: mis = i + 1\\n            elif v > 2 * l: du = i + 1\\n            if du and mis: return [du, mis]\\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        du = 0\\n        for i in nums:\\n            if nums[abs(i) - 1] < 0: du = abs(i)\\n            nums[abs(i) - 1] = - abs(nums[abs(i) - 1])\\n        for i, v in enumerate(nums): \\n            if v > 0: return [du, i + 1] \\n```\n```python\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        setsum = sum(set(nums))\\n        du = sum(nums) - setsum\\n        suma = (1 + len(nums)) * len(nums) // 2\\n        return [du, suma - setsum]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 345631,
                "title": "multiple-python-solution",
                "content": "# Solution 1\\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        x = sum(nums) - sum(set(nums))\\n        y = sum(range(len(nums)+1))-(sum(nums)-x)\\n        return [x,y]\\n```\\n    \\n\\n# Solution 2\\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n\\t   count = [0] * (len(nums)+1)\\n        for x in nums:\\n            count[x] += 1\\n            \\n        twice = z = 0\\n        for x in range(1, len(nums)+1):\\n            if count[x] == 2:\\n                twice = x\\n            if count[x] == 0:\\n                z = x\\n        return [twice, z]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        x = sum(nums) - sum(set(nums))\\n        y = sum(range(len(nums)+1))-(sum(nums)-x)\\n        return [x,y]\\n```\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n\\t   count = [0] * (len(nums)+1)\\n        for x in nums:\\n            count[x] += 1\\n            \\n        twice = z = 0\\n        for x in range(1, len(nums)+1):\\n            if count[x] == 2:\\n                twice = x\\n            if count[x] == 0:\\n                z = x\\n        return [twice, z]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149414,
                "title": "logical-thinking-with-clear-java-code",
                "content": "**Logical Thinking**\\nIf we sort the nums[], and loop through it, we can find the duplicate and assign to `result[0]`. Then we loop through the expected numbers set, i.e., i belongs to `[1, nums.length]`, and find the missed when `nums[ni] != i && nums[ni + 1] != i`, and assign to `result[1]`.\\n\\n**Clear Java Code**\\n```\\npublic int[] findErrorNums(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] result = new int[2];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                result[0] = nums[i];\\n                break;\\n            }\\n        }\\n        int ni = 0;\\n        for (int i = 1; i <= nums.length; i++) {\\n            if (ni + 1 < nums.length && nums[ni] != i && nums[ni + 1] != i) {\\n                result[1] = i;\\n                return result;\\n            }\\n            ni++;\\n        }\\n        result[1] = nums.length;\\n        return result;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\npublic int[] findErrorNums(int[] nums) {\\n        Arrays.sort(nums);\\n        int[] result = new int[2];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == nums[i - 1]) {\\n                result[0] = nums[i];\\n                break;\\n            }\\n        }\\n        int ni = 0;\\n        for (int i = 1; i <= nums.length; i++) {\\n            if (ni + 1 < nums.length && nums[ni] != i && nums[ni + 1] != i) {\\n                result[1] = i;\\n                return result;\\n            }\\n            ni++;\\n        }\\n        result[1] = nums.length;\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 143871,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) \\n    {\\n        Set<Integer> vals = new HashSet<>();\\n        \\n        int sumOneToN = (nums.length * (nums.length + 1))/2;\\n        int duplicate = 0;\\n        int arrSum = 0;\\n        for(int i : nums)\\n        {\\n            if(!vals.add(i))\\n            {\\n                duplicate = i;\\n            }\\n            arrSum += i;\\n        }\\n        \\n        return new int[]{duplicate,(sumOneToN-(arrSum-duplicate))};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findErrorNums(int[] nums) \\n    {\\n        Set<Integer> vals = new HashSet<>();\\n        \\n        int sumOneToN = (nums.length * (nums.length + 1))/2;\\n        int duplicate = 0;\\n        int arrSum = 0;\\n        for(int i : nums)\\n        {\\n            if(!vals.add(i))\\n            {\\n                duplicate = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 105543,
                "title": "javascript-o-n-time-and-o-1-space-using-swaps",
                "content": "```\\nconst findErrorNums = (nums) => {\\n    let i = 0\\n    while (i < nums.length) {\\n        if (nums[i] !== i + 1 && nums[nums[i] - 1] !== nums[i]) {\\n            const temp = nums[i]\\n            nums[i] = nums[nums[i] - 1]\\n            nums[temp - 1] = temp\\n        } else {\\n            i++\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) {\\n            return [nums[i], i + 1]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findErrorNums = (nums) => {\\n    let i = 0\\n    while (i < nums.length) {\\n        if (nums[i] !== i + 1 && nums[nums[i] - 1] !== nums[i]) {\\n            const temp = nums[i]\\n            nums[i] = nums[nums[i] - 1]\\n            nums[temp - 1] = temp\\n        } else {\\n            i++\\n        }\\n    }\\n    for (i = 0; i < nums.length; i++) {\\n        if (nums[i] !== i + 1) {\\n            return [nums[i], i + 1]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 105578,
                "title": "java-two-methods-using-sign-and-swap",
                "content": "Method 1 is to put each element k to the k-1th position unless the k-1th is already occupied by k. In that case we know k is a duplicate. In a second pass, we look for the ith position where its value is not i+1, we know i+1 is the missing value.\\n```\\n    private void swap(int[] nums, int i, int j) {\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n    }\\n\\n    public int[] findErrorNums(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[nums[i]-1] != nums[i]) {\\n                swap(nums, i, nums[i]-1);\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i+1) return new int[]{nums[i], i+1};\\n        }\\n        return null;\\n    }\\n```\\n\\nMethod 2: when we encounter a value k, we set the k-1th element negative. If k-1th is already negative we know k is the duplicate. In the second pass we look for ith position where it's value is positive so we know i+1 is the missing one.\\n```\\n    public int[] findErrorNums(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[nums[i]-1] != nums[i]) {\\n                swap(nums, i, nums[i]-1);\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i+1) return new int[]{nums[i], i+1};\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private void swap(int[] nums, int i, int j) {\\n        int tmp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = tmp;\\n    }\\n\\n    public int[] findErrorNums(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[nums[i]-1] != nums[i]) {\\n                swap(nums, i, nums[i]-1);\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i+1) return new int[]{nums[i], i+1};\\n        }\\n        return null;\\n    }\\n```\n```\\n    public int[] findErrorNums(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            while (nums[nums[i]-1] != nums[i]) {\\n                swap(nums, i, nums[i]-1);\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != i+1) return new int[]{nums[i], i+1};\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941672,
                "title": "clever-o-1-space-solution",
                "content": "Since we are given number from 1 to n, We can use numbers as indexes of the list to make a solution. \\nWe will go through the list and take each element and use it as  index to change the value at that index to negative by multiplying it by -1.\\nIf a number is duplicate, then when we go through the list, while using that number as index, the value will be already negative, that means this is the duplicate and we add it to the ans. \\nAfter this whole process, only number at two indexes will still be positve. \\nOne is the index/number which is duplicate, other is the one missing. \\nWe go through the list and if we see a positive number and the index != duplicate number then it must be the missing number. We add it to the ans. \\n\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1] < 0:\\n                ans.append(abs(nums[i]))\\n            nums[abs(nums[i])-1] *= -1\\n        \\n        for i in range(len(nums)):\\n            if nums[i] > 0 and i + 1 != ans[0]:\\n                ans.append(i+1)\\n                break\\n                \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            if nums[abs(nums[i])-1] < 0:\\n                ans.append(abs(nums[i]))\\n            nums[abs(nums[i])-1] *= -1\\n        \\n        for i in range(len(nums)):\\n            if nums[i] > 0 and i + 1 != ans[0]:\\n                ans.append(i+1)\\n                break\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789383,
                "title": "2-c-solutions-with-and-without-hash-map",
                "content": "\\n\\n# Code\\n```\\n// Solution 1 (With hash map)\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; i++)\\n            mp[nums[i]]++;\\n        int actSum = (n*(n+1)) / 2, sum = 0;\\n        for(auto x : mp){\\n            if(x.second > 1)\\n                ans = x.first;\\n            sum += x.first;\\n        }\\n        return {ans, actSum - sum};\\n    }\\n};\\n\\n// Solution 2 (without hash map)\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\tsort(begin(nums), end(nums));\\n\\tint dupl = -1;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tif (nums[i] == nums[i + 1]) {\\n\\t\\t\\tdupl = nums[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint sum = (nums.size() + 1) * nums.size() / 2;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tsum -= nums[i];\\n\\t}\\n\\treturn { dupl, sum + dupl };\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n// Solution 1 (With hash map)\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < n; i++)\\n            mp[nums[i]]++;\\n        int actSum = (n*(n+1)) / 2, sum = 0;\\n        for(auto x : mp){\\n            if(x.second > 1)\\n                ans = x.first;\\n            sum += x.first;\\n        }\\n        return {ans, actSum - sum};\\n    }\\n};\\n\\n// Solution 2 (without hash map)\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\tsort(begin(nums), end(nums));\\n\\tint dupl = -1;\\n\\tfor (int i = 0; i < nums.size() - 1; i++) {\\n\\t\\tif (nums[i] == nums[i + 1]) {\\n\\t\\t\\tdupl = nums[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\tint sum = (nums.size() + 1) * nums.size() / 2;\\n\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\tsum -= nums[i];\\n\\t}\\n\\treturn { dupl, sum + dupl };\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490625,
                "title": "most-intuitive-and-simplest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDont ever follow the commented method this is the worst thing that you\\'ll probably tell the interveiwer Remember \"Never Ever Tamper The Data That is Given To You...\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed A basic Mathematical Approach that we learnt in 10th Std\\nJust finding couple of Equations and then by substitution and elimination finding the required missing and repeating elements..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& A) {\\n        // vector<int>v;\\n        \\n        // int n=nums.size();\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     int index=abs(nums[i]);\\n        //     if(nums[index-1]<0)\\n        //     {\\n        //         v.push_back(index);       //repeating element/duplicate element\\n        //     }\\n        //     else\\n        //     nums[index-1] *=-1;\\n\\n        // }\\n       \\n\\n        // for(int i=0;i<nums.size();i++)\\n        // {\\n        //     if(nums[i]>0)\\n        //     {\\n                \\n        //         v.push_back(i+1);    //missing element\\n        //         break;\\n        //     }\\n        // }\\n        \\n\\n        // return v;\\n            long long int len = A.size();\\n\\n    long long int S = (len * (len+1) ) /2;\\n    long long int P = (len * (len +1) *(2*len +1) )/6;\\n    long long int missingNumber=0, repeating=0;\\n     \\n    for(int i=0;i<A.size(); i++){\\n       S -= (long long int)A[i];\\n       P -= (long long int)A[i]*(long long int)A[i];\\n    }\\n     \\n    missingNumber = (S + P/S)/2;\\n\\n    repeating = missingNumber - S;\\n\\n    vector <int> ans;\\n\\n    ans.push_back(repeating);\\n    ans.push_back(missingNumber);\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& A) {\\n        // vector<int>v;\\n        \\n        // int n=nums.size();\\n        // for(int i=0;i<n;i++)\\n        // {\\n        //     int index=abs(nums[i]);\\n        //     if(nums[index-1]<0)\\n        //     {\\n        //         v.push_back(index);       //repeating element/duplicate element\\n        //     }\\n        //     else\\n        //     nums[index-1] *=-1;\\n\\n        // }\\n       \\n\\n        // for(int i=0;i<nums.size();i++)\\n        // {\\n        //     if(nums[i]>0)\\n        //     {\\n                \\n        //         v.push_back(i+1);    //missing element\\n        //         break;\\n        //     }\\n        // }\\n        \\n\\n        // return v;\\n            long long int len = A.size();\\n\\n    long long int S = (len * (len+1) ) /2;\\n    long long int P = (len * (len +1) *(2*len +1) )/6;\\n    long long int missingNumber=0, repeating=0;\\n     \\n    for(int i=0;i<A.size(); i++){\\n       S -= (long long int)A[i];\\n       P -= (long long int)A[i]*(long long int)A[i];\\n    }\\n     \\n    missingNumber = (S + P/S)/2;\\n\\n    repeating = missingNumber - S;\\n\\n    vector <int> ans;\\n\\n    ans.push_back(repeating);\\n    ans.push_back(missingNumber);\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365346,
                "title": "best-method-and-very-easy-to-understand-guranteed-beats-100-basic-approach",
                "content": "\\n# Approach\\n  Sort the array.\\n 1. Fist we will be finding the repeating element fromt the array .\\n 2. While finding the repeating element, keep the variable sum and \\n    take sum of all the elements present in the array and subtract the\\n    element which is appering twice in the array.\\n 3. Acc. to Q , we first need to push back the element of the array \\n    that is appearing twice , so push back the element occuring twice\\n    in the array.\\n4. Then after the for loop , take a variable temp and store the sum of first n numbers , here n is the size of the array\\n5. Then subtract temp from sum and push back it in the vector.\\n6. By this , you pushed back element occuring twice first and then you found the missing element and stored in array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n       vector<int> ans;\\n       int n = nums.size();\\n       sort(nums.begin() , nums.end());\\n       long int sum = 0;\\n       for(int i = 0 ; i < n-1 ; i++)\\n       {  \\n           sum+=nums[i];  \\n            if(nums[i] == nums[i+1])\\n            {\\n                sum-=nums[i];\\n                     ans.push_back(nums[i]);    \\n            }   \\n       }\\n       sum+=nums[n-1];\\n       long int temp = n*(n+1)/2;\\n       ans.push_back(temp-sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n       vector<int> ans;\\n       int n = nums.size();\\n       sort(nums.begin() , nums.end());\\n       long int sum = 0;\\n       for(int i = 0 ; i < n-1 ; i++)\\n       {  \\n           sum+=nums[i];  \\n            if(nums[i] == nums[i+1])\\n            {\\n                sum-=nums[i];\\n                     ans.push_back(nums[i]);    \\n            }   \\n       }\\n       sum+=nums[n-1];\\n       long int temp = n*(n+1)/2;\\n       ans.push_back(temp-sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363774,
                "title": "c-solution-96-59-time-56-63-space-used-auxiliary-vector",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums);\\n};\\n/***************************************************************/\\nvector<int> Solution::findErrorNums(vector<int>& nums) {\\n    int i, size = nums.size(), dupl=0, miss=0;\\n    vector<unsigned char> v(size, 0);\\n    vector<int> ans;\\n    for (i = 0; i < size; ++i) {\\n        ++v[nums[i]-1];\\n    }\\n    for(i = 0; i < size; ++i) {\\n        if (v[i] == 0) {\\n            miss = i+1;\\n        }\\n        if (v[i] > 1) {\\n            dupl = i+1;\\n        }\\n    }\\n    ans.push_back(dupl);\\n    ans.push_back(miss);\\n    return ans;\\n}\\n/***************************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums);\\n};\\n/***************************************************************/\\nvector<int> Solution::findErrorNums(vector<int>& nums) {\\n    int i, size = nums.size(), dupl=0, miss=0;\\n    vector<unsigned char> v(size, 0);\\n    vector<int> ans;\\n    for (i = 0; i < size; ++i) {\\n        ++v[nums[i]-1];\\n    }\\n    for(i = 0; i < size; ++i) {\\n        if (v[i] == 0) {\\n            miss = i+1;\\n        }\\n        if (v[i] > 1) {\\n            dupl = i+1;\\n        }\\n    }\\n    ans.push_back(dupl);\\n    ans.push_back(miss);\\n    return ans;\\n}\\n/***************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312777,
                "title": "645-space-92-41-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize the length of the given array nums as n.\\n\\n2. Compute the XOR of all the numbers in the range 1 to n, and also of all the numbers in the given array nums. Store the result in a variable called xor_sum.\\n\\n3. Find the rightmost set bit of xor_sum. To do this, perform a bitwise AND operation of xor_sum with its two\\'s complement. The result will have only the rightmost set bit of xor_sum as 1, and all other bits as 0. Store this value in a variable called rightmost_set_bit.\\n\\n4. Partition the numbers in the range 1 to n into two groups based on the rightmost set bit. Iterate through the range 1 to n, and XOR each number with xor_group1 if its rightmost set bit is 1, or with xor_group2 if its rightmost set bit is 0. Do the same for each number in the given array nums.\\n\\n5. The two numbers that we are looking for are in different groups. Iterate through the given array nums, and check if any number is equal to xor_group1 or xor_group2. The number that is found in the array is the duplicate number, and the number that is missing is the one that was not found in the range 1 to n.\\n\\n6. Return the result as a list containing the duplicate number and the missing number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Example:\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        xor_sum = 0\\n        for i in range(1, n+1):\\n            xor_sum ^= i\\n            xor_sum ^= nums[i-1]\\n        rightmost_set_bit = xor_sum & ~(xor_sum-1)\\n        xor_group1 = xor_group2 = 0\\n        for i in range(1, n+1):\\n            if i & rightmost_set_bit:\\n                xor_group1 ^= i\\n            else:\\n                xor_group2 ^= i\\n            if nums[i-1] & rightmost_set_bit:\\n                xor_group1 ^= nums[i-1]\\n            else:\\n                xor_group2 ^= nums[i-1]\\n        for num in nums:\\n            if num == xor_group1:\\n                return [num, xor_group2]\\n            elif num == xor_group2:\\n                return [num, xor_group1]\\n\\n```\\n2. Example with comments:\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        # initialize variables\\n        n = len(nums)\\n        seen = set()\\n        missing = -1\\n        duplicate = -1\\n        \\n        # loop through nums array\\n        for num in nums:\\n            # check if the number is already seen\\n            if num in seen:\\n                # if yes, then it is the duplicate number\\n                duplicate = num\\n            else:\\n                # if not, add it to the seen set\\n                seen.add(num)\\n        \\n        # loop through numbers 1 to n and find the missing number\\n        for i in range(1, n+1):\\n            if i not in seen:\\n                missing = i\\n                break\\n        \\n        # return the result as a list\\n        return [duplicate, missing]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        xor_sum = 0\\n        for i in range(1, n+1):\\n            xor_sum ^= i\\n            xor_sum ^= nums[i-1]\\n        rightmost_set_bit = xor_sum & ~(xor_sum-1)\\n        xor_group1 = xor_group2 = 0\\n        for i in range(1, n+1):\\n            if i & rightmost_set_bit:\\n                xor_group1 ^= i\\n            else:\\n                xor_group2 ^= i\\n            if nums[i-1] & rightmost_set_bit:\\n                xor_group1 ^= nums[i-1]\\n            else:\\n                xor_group2 ^= nums[i-1]\\n        for num in nums:\\n            if num == xor_group1:\\n                return [num, xor_group2]\\n            elif num == xor_group2:\\n                return [num, xor_group1]\\n\\n```\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        # initialize variables\\n        n = len(nums)\\n        seen = set()\\n        missing = -1\\n        duplicate = -1\\n        \\n        # loop through nums array\\n        for num in nums:\\n            # check if the number is already seen\\n            if num in seen:\\n                # if yes, then it is the duplicate number\\n                duplicate = num\\n            else:\\n                # if not, add it to the seen set\\n                seen.add(num)\\n        \\n        # loop through numbers 1 to n and find the missing number\\n        for i in range(1, n+1):\\n            if i not in seen:\\n                missing = i\\n                break\\n        \\n        # return the result as a list\\n        return [duplicate, missing]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987508,
                "title": "easy-cyclic-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            int correct=nums[i]-1;\\n            if(nums[i]!=nums[correct])\\n            {\\n                int temp=nums[correct];\\n                nums[correct]=nums[i];\\n                nums[i]=temp;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=j+1)\\n            {\\n                return new int[]{nums[j],j+1};\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i=0;\\n        while(i<nums.length)\\n        {\\n            int correct=nums[i]-1;\\n            if(nums[i]!=nums[correct])\\n            {\\n                int temp=nums[correct];\\n                nums[correct]=nums[i];\\n                nums[i]=temp;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        for(int j=0;j<nums.length;j++)\\n        {\\n            if(nums[j]!=j+1)\\n            {\\n                return new int[]{nums[j],j+1};\\n            }\\n        }\\n        return new int[]{-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739240,
                "title": "python-easy-solution-99-time-complexity",
                "content": "```\\nimport statistics\\nfrom statistics import mode\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=set(range(1,len(nums)+1))\\n        l.append(mode(nums))\\n        l.append((list(s-set(nums)))[0])\\n        return l\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport statistics\\nfrom statistics import mode\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        l=[]\\n        s=set(range(1,len(nums)+1))\\n        l.append(mode(nums))\\n        l.append((list(s-set(nums)))[0])\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736892,
                "title": "java-single-pass-o-n-constant-space-o-1",
                "content": "```\\npublic int[] findErrorNums(int[] nums) {\\n\\tint n = nums.length;\\n\\tint realSum = 0, duplicate = -1, targetSum = n * (n + 1) / 2;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint num = Math.abs(nums[i]);\\n\\t\\tint index = num % n;\\n\\t\\trealSum += num;\\n\\t\\tif (nums[index] < 0) {\\n\\t\\t\\tduplicate = num;\\n\\t\\t} else {\\n\\t\\t\\tnums[index] = -nums[index];\\n\\t\\t}\\n\\t}\\n\\treturn new int[] {duplicate, targetSum - (realSum - duplicate)};\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findErrorNums(int[] nums) {\\n\\tint n = nums.length;\\n\\tint realSum = 0, duplicate = -1, targetSum = n * (n + 1) / 2;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint num = Math.abs(nums[i]);\\n\\t\\tint index = num % n;\\n\\t\\trealSum += num;\\n\\t\\tif (nums[index] < 0) {\\n\\t\\t\\tduplicate = num;\\n\\t\\t} else {\\n\\t\\t\\tnums[index] = -nums[index];\\n\\t\\t}\\n\\t}\\n\\treturn new int[] {duplicate, targetSum - (realSum - duplicate)};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2736834,
                "title": "java-5-approaches",
                "content": "# Please Upvote :D\\n---\\n##### 1. Brute force approach:\\n```  java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        int dup = 0, miss = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (nums[j] == i) count++;\\n            }\\n\\n            if (count == 2) dup = i;\\n            if (count == 0) miss = i;\\n        }\\n\\n        return new int[] {dup, miss};\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n---\\n##### 2. Using frequency array:\\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n\\n        int[] freq = new int[n];\\n        for (int i : nums) {\\n            freq[i - 1]++;\\n        }\\n\\n        int dup = 0, miss = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (freq[i] == 2) dup = i + 1;\\n            if (freq[i] == 0) miss = i + 1;\\n        }\\n\\n        return new int[] {dup, miss};\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 3. Using HashSet:\\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        Set<Integer> set = new HashSet<>();\\n        int dup = 0, miss = 0;\\n\\n        for (int i : nums) {\\n            if (set.contains(i)) {\\n                dup = i;\\n            }\\n            set.add(i);\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (!set.contains(i)) {\\n                miss = i;\\n            }\\n        }\\n\\n        return new int[] {dup, miss};\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\\n---\\n##### 4. Negative marking approach:\\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[2];\\n\\n        for (int i : nums) {\\n            int idx = Math.abs(i) - 1;\\n            if (nums[idx] < 0) {\\n                ans[0] = idx + 1;\\n            } else {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                ans[1] = i + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\\n---\\n##### 5. Cyclic sort:\\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i = 0;\\n        while (i < nums.length) {\\n            int correctIdx = nums[i] - 1;\\n            if (nums[i] != nums[correctIdx]) {\\n                swap(nums, i, correctIdx);\\n            }\\n            else i++;\\n        }\\n\\n        for (i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                return new int[] {nums[i], i + 1};\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n\\n    void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n// TC: O(n) + O(n) ~ O(n)\\n// SC: O(1)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```  java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        int dup = 0, miss = 0;\\n\\n        for (int i = 1; i <= n; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (nums[j] == i) count++;\\n            }\\n\\n            if (count == 2) dup = i;\\n            if (count == 0) miss = i;\\n        }\\n\\n        return new int[] {dup, miss};\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n\\n        int[] freq = new int[n];\\n        for (int i : nums) {\\n            freq[i - 1]++;\\n        }\\n\\n        int dup = 0, miss = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (freq[i] == 2) dup = i + 1;\\n            if (freq[i] == 0) miss = i + 1;\\n        }\\n\\n        return new int[] {dup, miss};\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n        Set<Integer> set = new HashSet<>();\\n        int dup = 0, miss = 0;\\n\\n        for (int i : nums) {\\n            if (set.contains(i)) {\\n                dup = i;\\n            }\\n            set.add(i);\\n        }\\n\\n        for (int i = 1; i <= n; i++) {\\n            if (!set.contains(i)) {\\n                miss = i;\\n            }\\n        }\\n\\n        return new int[] {dup, miss};\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[2];\\n\\n        for (int i : nums) {\\n            int idx = Math.abs(i) - 1;\\n            if (nums[idx] < 0) {\\n                ans[0] = idx + 1;\\n            } else {\\n                nums[idx] = -nums[idx];\\n            }\\n        }\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] > 0) {\\n                ans[1] = i + 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```\n``` java []\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i = 0;\\n        while (i < nums.length) {\\n            int correctIdx = nums[i] - 1;\\n            if (nums[i] != nums[correctIdx]) {\\n                swap(nums, i, correctIdx);\\n            }\\n            else i++;\\n        }\\n\\n        for (i = 0; i < nums.length; i++) {\\n            if (nums[i] != i + 1) {\\n                return new int[] {nums[i], i + 1};\\n            }\\n        }\\n\\n        return new int[0];\\n    }\\n\\n    void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n// TC: O(n) + O(n) ~ O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736576,
                "title": "c-easy-approch",
                "content": "```\\nclass Solution { //my own approch TC->O(nlogn) i feel like it is a easy and optimized approch\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=1,j=1,point;\\n        int sum=nums[0],actual_sum = n*(n+1)/2;\\n        for(;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(nums[i]==nums[i-1])\\n                point=i;\\n        }\\n        // cout<<sum<<\",\"<<actual_sum<<endl;\\n        int diff = sum - nums[point];\\n        // cout<<diff<<endl;\\n        int want = actual_sum - diff;\\n        // cout<<want;\\n        return {nums[point],want};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution { //my own approch TC->O(nlogn) i feel like it is a easy and optimized approch\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int i=1,j=1,point;\\n        int sum=nums[0],actual_sum = n*(n+1)/2;\\n        for(;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(nums[i]==nums[i-1])\\n                point=i;\\n        }\\n        // cout<<sum<<\",\"<<actual_sum<<endl;\\n        int diff = sum - nums[point];\\n        // cout<<diff<<endl;\\n        int want = actual_sum - diff;\\n        // cout<<want;\\n        return {nums[point],want};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2736530,
                "title": "c-o-n-in-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& vec) {\\n        int i = 0;\\n        while(i < vec.size()) {\\n            int cind = vec[i] - 1;\\n            if(vec[i] != vec[cind]) {\\n                swap(vec[i], vec[cind]);\\n            }\\n            else i++;\\n        }\\n        for(int i=0;i<vec.size();i++) {\\n            if(vec[i] != i + 1) {\\n                return {vec[i], i + 1};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& vec) {\\n        int i = 0;\\n        while(i < vec.size()) {\\n            int cind = vec[i] - 1;\\n            if(vec[i] != vec[cind]) {\\n                swap(vec[i], vec[cind]);\\n            }\\n            else i++;\\n        }\\n        for(int i=0;i<vec.size();i++) {\\n            if(vec[i] != i + 1) {\\n                return {vec[i], i + 1};\\n            }\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736526,
                "title": "very-easy-easiest-of-all-beginner-friendly-using-dictionary-hashmap-in-python",
                "content": "\\tclass Solution:\\n\\t\\tdef findErrorNums(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tlookup = Counter(nums) # created dictionary of elements of nums\\n\\t\\t\\tans = []\\n\\t\\t\\tn = len(nums)+1\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif lookup[i]==2:    #adding the repeated number into return list\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif i not in lookup: #adding the number which is being replaced into return list\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#Do upvote if helpfull \\n\\t\\t\\t#thanks",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef findErrorNums(self, nums: List[int]) -> List[int]:\\n\\t\\t\\tlookup = Counter(nums) # created dictionary of elements of nums\\n\\t\\t\\tans = []\\n\\t\\t\\tn = len(nums)+1\\n\\t\\t\\tfor i in nums:\\n\\t\\t\\t\\tif lookup[i]==2:    #adding the repeated number into return list\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif i not in lookup: #adding the number which is being replaced into return list\\n\\t\\t\\t\\t\\tans.append(i)\\n\\t\\t\\t\\t\\treturn ans\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#Do upvote if helpfull \\n\\t\\t\\t#thanks",
                "codeTag": "Java"
            },
            {
                "id": 2736345,
                "title": "96-faster-o-n-time-o-1-space-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a very simple problem, after analysing one or two test cases, you will understand how to obtain the elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck the sum of the array and the square of the sum of the array, and then use simple `11th grade math`. As an answer, I used `b and e` as two elements.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        long long n = (long long)nums.size();\\n        long long sum = (n*(n+1))/2;\\n        long long calSum = 0;\\n        for(auto it:nums)\\n            calSum+=it;\\n        long long subbe = sum - calSum;\\n        long long sumsq = (n*(n+1)*(2*n+1))/6;\\n        long long calSumSq = 0;\\n        for(auto it:nums)\\n            calSumSq+=(long long)(it*it);\\n        long long b2e2 = sumsq - calSumSq;\\n        long long addbe = b2e2/subbe;\\n        long long b = (addbe+subbe)/2;\\n        long long e = (addbe-subbe)/2;\\n        return {(int)e, (int)b};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        long long n = (long long)nums.size();\\n        long long sum = (n*(n+1))/2;\\n        long long calSum = 0;\\n        for(auto it:nums)\\n            calSum+=it;\\n        long long subbe = sum - calSum;\\n        long long sumsq = (n*(n+1)*(2*n+1))/6;\\n        long long calSumSq = 0;\\n        for(auto it:nums)\\n            calSumSq+=(long long)(it*it);\\n        long long b2e2 = sumsq - calSumSq;\\n        long long addbe = b2e2/subbe;\\n        long long b = (addbe+subbe)/2;\\n        long long e = (addbe-subbe)/2;\\n        return {(int)e, (int)b};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736188,
                "title": "simple-yet-unique-java-solution-in-o-n-time-and-o-1-space",
                "content": "## Concept used: Cyclic Sort\\n**Cyclic Sort** Algorithm:-\\n- What we intend to do in this sorting algorithm is that, we sort the array in one pass that is in TC - O(N). As question states that the array strictly has **all** numbers between 1 and `n` , we will compare element at current index with index value. \\n- Now, if the `value_at_current_index  - 1 == index`, then position of that value is correct an we will move forward to check for next index.\\n- But, if `value_at_current_index  - 1 != index`, then we will swap the `value_at_current_index` with the number which is present in the correct position of `value_at_current_index`.\\nBut while swapping, on thing to keep in mind is that, if the repeated number occurs, i.e. if number at swapping position in the array is at the correct index, then we will just increment the pointer, count number of times this case occured and continue.\\n- We will stop the loop when either all numbers are checked or number of no swaps becomes == n; \\n\\t- Counting number of no swaps, just optimizes the algorithm a bit.\\n\\n> Note: (we subtract 1 from numbers because of the zero based indexing of array but numbers ATQ start from 1)\\n\\n## Complexity analysis\\n- Time Complexity - **O(N**) as we iterate through the array only once; i.e. at worst case we swap numbers `n` times only and the condition `no of no swaps < n` negates lot of repeatitons.\\n- Space complexity - **O(1)** as we never use any extra space in form of array/list to store some values\\n\\n## Here\\'s the solution.\\n\\n``` java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[2];\\n        int swapCount = 0;\\n        for (int i = 0; i < nums.length && swapCount < nums.length; ) {\\n            if (nums[i] - 1 == i) {\\n                i++;\\n                continue;\\n            }\\n            else {\\n                int swapPos = nums[i] - 1;\\n                if (nums[swapPos] - 1 == swapPos) {\\n                    i++;\\n                    swapCount++;\\n                    continue;\\n                } else {\\n                    int temp = nums[swapPos];\\n                    nums[swapPos] = nums[i];\\n                    nums[i] = temp;\\n                }\\n            }\\n        }\\n        int ind = 1;\\n        for (int i : nums) {\\n            if (i != ind) {\\n                ans[0] = i;\\n                ans[1] = ind;\\n            }\\n            ind++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/35ac1175-a44e-4645-b4f7-ea70745ed73c_1666535714.4448588.png)\\n\\n## Upvote\\u2B06 if you liked the solution. Thankyou!\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "``` java\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[2];\\n        int swapCount = 0;\\n        for (int i = 0; i < nums.length && swapCount < nums.length; ) {\\n            if (nums[i] - 1 == i) {\\n                i++;\\n                continue;\\n            }\\n            else {\\n                int swapPos = nums[i] - 1;\\n                if (nums[swapPos] - 1 == swapPos) {\\n                    i++;\\n                    swapCount++;\\n                    continue;\\n                } else {\\n                    int temp = nums[swapPos];\\n                    nums[swapPos] = nums[i];\\n                    nums[i] = temp;\\n                }\\n            }\\n        }\\n        int ind = 1;\\n        for (int i : nums) {\\n            if (i != ind) {\\n                ans[0] = i;\\n                ans[1] = ind;\\n            }\\n            ind++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735652,
                "title": "one-loop-no-xtra-space-beats-96-on-both-time-space-daily-challenge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\nfunc findErrorNums(nums []int) []int {\\n    var sum, dup int\\n    n:= len(nums)\\n\\n    // compute the sum and find the duplicate\\n    // note that the elements of nums are +ve\\n    foundDuplicate := false\\n    for _, x := range nums {\\n        x1 := abs(x)\\n        sum += x1\\n        if !foundDuplicate {\\n            if nums[x1-1] < 0 {\\n                dup = x1\\n                foundDuplicate = true\\n            } else {\\n                nums[x1-1] = -nums[x1-1]\\n            }\\n        }\\n    }\\n\\n    // assemble dup and missing\\n    sumExpected, sumUniq := n*(n+1)/2, sum - dup\\n    return []int{dup, sumExpected - sumUniq}\\n}\\n\\n// Runtime 24 ms Beats 96.30%\\n// Memory 6.5 MB Beats 96.30%\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc abs(a int) int {\\n    if a < 0 {\\n        return -a\\n    }\\n    return a\\n}\\nfunc findErrorNums(nums []int) []int {\\n    var sum, dup int\\n    n:= len(nums)\\n\\n    // compute the sum and find the duplicate\\n    // note that the elements of nums are +ve\\n    foundDuplicate := false\\n    for _, x := range nums {\\n        x1 := abs(x)\\n        sum += x1\\n        if !foundDuplicate {\\n            if nums[x1-1] < 0 {\\n                dup = x1\\n                foundDuplicate = true\\n            } else {\\n                nums[x1-1] = -nums[x1-1]\\n            }\\n        }\\n    }\\n\\n    // assemble dup and missing\\n    sumExpected, sumUniq := n*(n+1)/2, sum - dup\\n    return []int{dup, sumExpected - sumUniq}\\n}\\n\\n// Runtime 24 ms Beats 96.30%\\n// Memory 6.5 MB Beats 96.30%\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735464,
                "title": "java-o-n-time-with-one-cycle",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n// create an array in which the value of the cell with index n is equal to the number of repetitions n in the nums array\\n        var numsOfRepeat = new int[nums.length+1]; \\n        var result = new int[2];\\n        int missNum = 0; \\n        \\n        for (int i = 0; i < nums.length; i++){\\n            missNum = missNum + (i+1);  // sum all numbers from 1 to n            \\n            numsOfRepeat[nums[i]]+=1; // increase the number of repetitions n\\n            if (numsOfRepeat[nums[i]] == 2){  // check if n is a duplicate\\n                result[0] = nums[i]; \\n            } else {\\n                missNum-=nums[i]; // subtract from the sum from 1 to n each non-repeating element\\n            }\\n        }\\n        \\n        result[1] = missNum;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n// create an array in which the value of the cell with index n is equal to the number of repetitions n in the nums array\\n        var numsOfRepeat = new int[nums.length+1]; \\n        var result = new int[2];\\n        int missNum = 0; \\n        \\n        for (int i = 0; i < nums.length; i++){\\n            missNum = missNum + (i+1);  // sum all numbers from 1 to n            \\n            numsOfRepeat[nums[i]]+=1; // increase the number of repetitions n\\n            if (numsOfRepeat[nums[i]] == 2){  // check if n is a duplicate\\n                result[0] = nums[i]; \\n            } else {\\n                missNum-=nums[i]; // subtract from the sum from 1 to n each non-repeating element\\n            }\\n        }\\n        \\n        result[1] = missNum;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735362,
                "title": "set-mismatch",
                "content": "```\\n\\npublic class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] freq = new int[nums.length + 1];\\n        for (int i : nums) {\\n            freq[i]++;\\n        }\\n        int x = 0, y = 0;\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i] == 2) x = i;\\n            if (freq[i] == 0) y = i;\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\npublic class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] freq = new int[nums.length + 1];\\n        for (int i : nums) {\\n            freq[i]++;\\n        }\\n        int x = 0, y = 0;\\n        for (int i = 1; i < freq.length; i++) {\\n            if (freq[i] == 2) x = i;\\n            if (freq[i] == 0) y = i;\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735215,
                "title": "c-basic-hashmap-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstore frequency of array elements, then since the numbers can be from 1 to n therefore iterate from 1 to n and check if map does not contain that number then that will be your missing number and the one with the count 2 will be the duplicate number.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(N)$ N is the size of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(N)$ N the the size of the array\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        map<int, int> m;\\n        for(auto it: nums)\\n            m[it]++;\\n        int missingNumber = -1, duplicateNumber = -1;\\n        for(int i = 1; i <= nums.size(); i++){\\n            if(m[i] == 0)\\n                missingNumber = i;\\n            if(m[i] == 2)\\n                duplicateNumber = i;\\n        }\\n        vector<int> ans{duplicateNumber, missingNumber};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        map<int, int> m;\\n        for(auto it: nums)\\n            m[it]++;\\n        int missingNumber = -1, duplicateNumber = -1;\\n        for(int i = 1; i <= nums.size(); i++){\\n            if(m[i] == 0)\\n                missingNumber = i;\\n            if(m[i] == 2)\\n                duplicateNumber = i;\\n        }\\n        vector<int> ans{duplicateNumber, missingNumber};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735140,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n      vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size(),sum=0;\\n        unordered_set<int> s;\\n        int repeated_number=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(nums[i])!=s.end())\\n            {\\n                repeated_number=nums[i];\\n            }\\n            else \\n            {\\n                s.insert(nums[i]);\\n                sum+=nums[i];\\n            }\\n        }\\n        int k = n*(n+1)/2;\\n        return {repeated_number,k-sum};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size(),sum=0;\\n        unordered_set<int> s;\\n        int repeated_number=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s.find(nums[i])!=s.end())\\n            {\\n                repeated_number=nums[i];\\n            }\\n            else \\n            {\\n                s.insert(nums[i]);\\n                sum+=nums[i];\\n            }\\n        }\\n        int k = n*(n+1)/2;\\n        return {repeated_number,k-sum};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735113,
                "title": "simple-math-java-solution-very-easy-understandable",
                "content": "\\n**Hey guys don\\'t loose hope if you were not able to solve it  , it doesn\\'t matter , all that matters is your determination because of which you are here , trying to get the solution..of the problem and get that solved .\\nKeep up this spirit !  lets see the approach :-**\\n\\'\\'\\'\\nclass Solution {\\n\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//result array to store ans.\\n        int[] ans = new int[2];\\n        Set<Integer> s = new HashSet<>();\\n\\t\\t//calculate errorsum and actual sum of n natural numbers\\n        int actualsum = (n*(n+1))/2;\\n        int errorsum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            errorsum+=nums[i];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(s.contains(nums[i])){\\n\\t\\t\\t//if errorsum is less than actualsum. than just increment the repeating element with the difference of actualsum-errorsum\\n                if(errorsum<actualsum){\\n                   ans[0]=nums[i];\\n                   ans[1]=ans[0]+actualsum-errorsum;\\n                   break;\\n                }\\n                else{\\n                    ans[0]=nums[i];\\n\\t\\t\\t\\t\\t//if errorsum is greater than actualsum. than just decrement the repeating element with the difference of errorsum-actualsum\\n                    ans[1]=ans[0]-(errorsum-actualsum);\\n                    break;\\n                }\\n                \\n            }\\n            s.add(nums[i]);\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\'\\'\\'\\n**Please Upvote if you like it**",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\n    public int[] findErrorNums(int[] nums) {\\n        int n = nums.length;\\n\\t\\t//result array to store ans.\\n        int[] ans = new int[2];\\n        Set<Integer> s = new HashSet<>();\\n\\t\\t//calculate errorsum and actual sum of n natural numbers\\n        int actualsum = (n*(n+1))/2;\\n        int errorsum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            errorsum+=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2734969,
                "title": "java-19-features-python-c-2-lines-100-0ms-o-n-faster-simple",
                "content": "# UPVOTE PLEASE\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        var st = new HashSet<Integer>();\\n        int dup = Arrays.stream(nums).boxed().filter(i -> !st.add(i)).toList().get(0), n = nums.length, s = (n * (n + 1)) / 2, ts = Arrays.stream(nums).sum();\\n        return new int[]{dup, s - (ts - dup)};\\n    }\\n}\\n\\n\\n\\n\\npython :\\n\\nclass Solution:\\n    def findErrorNums(self, nums: list[int]) -> list[int]:\\n        n, a, b = len(nums), sum(nums), sum(set(nums))\\n        s = n*(n+1)//2\\n        return [a-b, s-b]\\n\\n\\n\\nC++:\\n\\nvector<int> findErrorNums(vector<int>& nums) {\\n    //sum of elements on nums\\n    int initialSum = accumulate(nums.begin(), nums.end(), 0);\\n\\n    //put the element of nums into set to remove the duplicate number\\n    set<int> s;\\n    for(auto &i: nums){\\n        s.insert(i);\\n    }\\n\\n    //sum of elements of the set\\n    int sum = accumulate(s.begin(), s.end(), 0);\\n\\n    //difference of initialSum and sum will give us the repeated number\\n    int repeatedNum = initialSum - sum;\\n\\n    //sum of all the natural numbers from 1 to n\\n    int n = nums.size() + 1;\\n\\n    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number\\n    int missingNum = n * (n-1)/2 - sum;\\n\\n    return {repeatedNum, missingNum};\\n}\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        var st = new HashSet<Integer>();\\n        int dup = Arrays.stream(nums).boxed().filter(i -> !st.add(i)).toList().get(0), n = nums.length, s = (n * (n + 1)) / 2, ts = Arrays.stream(nums).sum();\\n        return new int[]{dup, s - (ts - dup)};\\n    }\\n}\\n\\n\\n\\n\\npython :\\n\\nclass Solution:\\n    def findErrorNums(self, nums: list[int]) -> list[int]:\\n        n, a, b = len(nums), sum(nums), sum(set(nums))\\n        s = n*(n+1)//2\\n        return [a-b, s-b]\\n\\n\\n\\nC++:\\n\\nvector<int> findErrorNums(vector<int>& nums) {\\n    //sum of elements on nums\\n    int initialSum = accumulate(nums.begin(), nums.end(), 0);\\n\\n    //put the element of nums into set to remove the duplicate number\\n    set<int> s;\\n    for(auto &i: nums){\\n        s.insert(i);\\n    }\\n\\n    //sum of elements of the set\\n    int sum = accumulate(s.begin(), s.end(), 0);\\n\\n    //difference of initialSum and sum will give us the repeated number\\n    int repeatedNum = initialSum - sum;\\n\\n    //sum of all the natural numbers from 1 to n\\n    int n = nums.size() + 1;\\n\\n    //subtracting the sum of elements in set i.e. sum from the sum of the natural numbers will give us the missing number\\n    int missingNum = n * (n-1)/2 - sum;\\n\\n    return {repeatedNum, missingNum};\\n}\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734941,
                "title": "645-set-mismatch-daily-leetcoding-challenge-october-day-23",
                "content": "**APPROACH**\\n\\nFor solving any problem, clarify what is it that we need?\\nIf we read this problem, we can understand that we need two numbers, one that is repeated and the other that should take its place. \\nWe can find the repeated number by using a HashSet. A hashset stores all elements in it only once. We can iterate over our given array and keep adding the elements to a set, we will also put a check to see if the number that we currently want to add is already in the set or not. If the number is already in the set, we have found the repeated number and we can break out of the loop, since there is only one repeated number. \\n\\nNow to find the number which should have been there in the array, we can use simple mathematics. We see that the numbers in the array are in the range of 1 to n where n=length of array and from the question we know : \" You have a set of integers s, which originally contains all the numbers from 1 to n. \" \\n\\nSo the actually sum of the array should have been \\n**Actual_Sum= n(n+1)/2**, from Arithmetic Progression Series\\n\\nbut the sum is not so due to the repeated element,\\n\\nSo since we have found our duplicate element, the real element should be\\n**Real_Element= Actual_Sum-Sum_CurrentArray+DuplicateElement**\\n\\nHence, \\nFind the sum of elements of the given array and subtract this sum from the actual sum calculated from the formula and add the duplicate number to it. \\n\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n=nums.length;\\n        // to store the answer to be returned\\n        int[] ans=new int[2];\\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        //storing the sum of the elements in the given array\\n        long sum_current=0;\\n        for(int x:nums)\\n            sum_current+=x;\\n        \\n        //finding the duplicate element\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                ans[0]=nums[i]; //stores the duplicate element\\n                break;\\n            }\\n            set.add(nums[i]);\\n        }\\n        \\n        // sum of elements from 1 to n\\n        long sum_actual=(n*(n+1))/2;\\n        int realElement= (int)(sum_actual-sum_current+ans[0]);\\n        ans[1]=realElement;\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**TIME COMPLEXITY:** O(N)\\n**SPACE COMPLEXITY:** O(N)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int n=nums.length;\\n        // to store the answer to be returned\\n        int[] ans=new int[2];\\n        \\n        HashSet<Integer> set=new HashSet<>();\\n        \\n        //storing the sum of the elements in the given array\\n        long sum_current=0;\\n        for(int x:nums)\\n            sum_current+=x;\\n        \\n        //finding the duplicate element\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(set.contains(nums[i]))\\n            {\\n                ans[0]=nums[i]; //stores the duplicate element\\n                break;\\n            }\\n            set.add(nums[i]);\\n        }\\n        \\n        // sum of elements from 1 to n\\n        long sum_actual=(n*(n+1))/2;\\n        int realElement= (int)(sum_actual-sum_current+ans[0]);\\n        ans[1]=realElement;\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734741,
                "title": "c-o-n-time-o-1-space-xor",
                "content": "to check for repeated element `Y` we simply modify array as we visit number i we modify the element at ith index so if we visit again we will know.\\nfor missing element `y` we calculate `(1 ^ 2 ^ 3 ^  . . .  ^ x ^ y^  . . .  ^n)` ^ `(nums[0] ^ nums[1] ^ . . .  ^ y ^ y ^  . . .  ^ nums[n])` that wiil be equal to `x ^ y`.\\n```C++\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\tint X = 0, Y;\\n\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\tint a = abs(nums[i]);\\n\\t\\tX ^= (i+1) ^ a;\\n\\t\\tif(nums[a-1] < 0) Y = a;\\n\\t\\telse nums[a-1] = -nums[a-1]; \\n\\t}\\n\\treturn {Y, X^Y};\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nvector<int> findErrorNums(vector<int>& nums) {\\n\\tint X = 0, Y;\\n\\tfor(int i = 0; i < nums.size(); i++){\\n\\t\\tint a = abs(nums[i]);\\n\\t\\tX ^= (i+1) ^ a;\\n\\t\\tif(nums[a-1] < 0) Y = a;\\n\\t\\telse nums[a-1] = -nums[a-1]; \\n\\t}\\n\\treturn {Y, X^Y};\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734708,
                "title": "over-simplified-o-n-time-o-1-space-solution-no-hash-set",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i,n=nums.length,res[]=new int[2],abs;\\n        for(i=0;i<n;i++){\\n            abs=Math.abs(nums[i]);\\n            if(nums[abs-1]<0) res[0]=abs;\\n            else nums[abs-1]*=-1;\\n        }\\n        for(i=0;i<n;i++) if(nums[i]>0) res[1]=i+1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i,n=nums.length,res[]=new int[2],abs;\\n        for(i=0;i<n;i++){\\n            abs=Math.abs(nums[i]);\\n            if(nums[abs-1]<0) res[0]=abs;\\n            else nums[abs-1]*=-1;\\n        }\\n        for(i=0;i<n;i++) if(nums[i]>0) res[1]=i+1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734684,
                "title": "python-97-8-runtime-with-explanation",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        # Actual list -> [1,2,3,4], Duplicated from Actual list but with errors -> [1,2,2,4].\\n\\t\\t# 2 is the error and you can see 3 is supposed to be there\\n                \\n        # sum of Duplicated list with errors [1+2+2+4] is 10, sum set which will only add unique numbers [1+2+4] -> \\n\\t\\t# To find the error which was 2, you can just find the difference between both sums.\\n\\t\\t\\n        duplicate = sum(nums)-sum(set(nums))\\n\\t\\t\\n\\t\\tn = len(nums)\\n\\n        # Since you have len of the list with errors, you can find the sum of the original list with no errors \\n\\t\\t# With the formula of sum of first n natural numbers, N*(N+1)/2.\\n\\t\\t# To find the missing 3 -> Error (2) + Sum of Actual List - Sum of List with Errors\\n        missing = duplicate + ((n*(n+1))//2) - sum(nums)\\n        return duplicate, missing\\n\\n                \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        # Actual list -> [1,2,3,4], Duplicated from Actual list but with errors -> [1,2,2,4].\\n\\t\\t# 2 is the error and you can see 3 is supposed to be there\\n                \\n        # sum of Duplicated list with errors [1+2+2+4] is 10, sum set which will only add unique numbers [1+2+4] -> \\n\\t\\t# To find the error which was 2, you can just find the difference between both sums.\\n\\t\\t\\n        duplicate = sum(nums)-sum(set(nums))\\n\\t\\t\\n\\t\\tn = len(nums)\\n\\n        # Since you have len of the list with errors, you can find the sum of the original list with no errors \\n\\t\\t# With the formula of sum of first n natural numbers, N*(N+1)/2.\\n\\t\\t# To find the missing 3 -> Error (2) + Sum of Actual List - Sum of List with Errors\\n        missing = duplicate + ((n*(n+1))//2) - sum(nums)\\n        return duplicate, missing\\n\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 2734560,
                "title": "c-o-n-boolean-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool>v(n+1,false);\\n        int ans=-1;\\n\\t\\t//mark the numbers as visited. if already visited that is the one repeating\\n        for(auto x:nums){\\n            if(v[x])\\n                ans=x;\\n            else\\n                v[x]=true;\\n        }\\n\\t\\t//The number that is not visited is considered to be the one that is missing\\n        for(int i=1;i<=n;i++){\\n            if(!v[i]){\\n                return {ans,i};\\n            }\\n        }\\n        return {ans,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<bool>v(n+1,false);\\n        int ans=-1;\\n\\t\\t//mark the numbers as visited. if already visited that is the one repeating\\n        for(auto x:nums){\\n            if(v[x])\\n                ans=x;\\n            else\\n                v[x]=true;\\n        }\\n\\t\\t//The number that is not visited is considered to be the one that is missing\\n        for(int i=1;i<=n;i++){\\n            if(!v[i]){\\n                return {ans,i};\\n            }\\n        }\\n        return {ans,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734536,
                "title": "simple-index-manipulation-space-o-1",
                "content": "\\n\\n# Approach\\nIndex manipulation\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res= new int[2];\\n        \\n        //firat pass \\n        //we set the number at index(abs(nums[i])-1) as negative\\n        for(int i=0;i< nums.length;i++){\\n            if(nums[Math.abs(nums[i])-1] < 0)//if negative already exist then it is the repeated number\\n                res[0]= Math.abs(nums[i]);\\n            else\\n                nums[Math.abs(nums[i]) -1] *= -1;\\n        }\\n\\n        //second pass\\n        //if any number remains unchanged(greater than zero) then it is the missing number\\n        for(int i=0;i< nums.length;i++){\\n            if(nums[i] > 0)\\n                res[1]= i+1;\\n        }\\n        return res;\\n    }\\n}\\n\\n//O(N) space solution\\n// int[] arr= new int[nums.length];\\n\\n//         for(int i: nums){\\n//             arr[i-1]++;\\n//         }\\n\\n//         for(int i=0; i< arr.length;i++){\\n//             if(arr[i]==2)\\n//                 res[0]= i+1;\\n//             else if(arr[i]==0)\\n//                 res[1]= i+1;\\n//         }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res= new int[2];\\n        \\n        //firat pass \\n        //we set the number at index(abs(nums[i])-1) as negative\\n        for(int i=0;i< nums.length;i++){\\n            if(nums[Math.abs(nums[i])-1] < 0)//if negative already exist then it is the repeated number\\n                res[0]= Math.abs(nums[i]);\\n            else\\n                nums[Math.abs(nums[i]) -1] *= -1;\\n        }\\n\\n        //second pass\\n        //if any number remains unchanged(greater than zero) then it is the missing number\\n        for(int i=0;i< nums.length;i++){\\n            if(nums[i] > 0)\\n                res[1]= i+1;\\n        }\\n        return res;\\n    }\\n}\\n\\n//O(N) space solution\\n// int[] arr= new int[nums.length];\\n\\n//         for(int i: nums){\\n//             arr[i-1]++;\\n//         }\\n\\n//         for(int i=0; i< arr.length;i++){\\n//             if(arr[i]==2)\\n//                 res[0]= i+1;\\n//             else if(arr[i]==0)\\n//                 res[1]= i+1;\\n//         }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734316,
                "title": "linear-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size()-1;++i){\\n            if(nums[i]==nums[i+1]) ans.push_back(nums[i]);\\n                else sum+=nums[i];\\n        }\\n        int n=nums.size();\\n        sum+=nums[n-1];\\n       int finalsum= (n*(n+1))/2;\\n        ans.push_back(finalsum-sum);\\n        return ans;\\n    }\\n};\\n```\\nUpvote my answer if it helped you",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>ans;\\n        int sum=0;\\n        for(int i=0;i<nums.size()-1;++i){\\n            if(nums[i]==nums[i+1]) ans.push_back(nums[i]);\\n                else sum+=nums[i];\\n        }\\n        int n=nums.size();\\n        sum+=nums[n-1];\\n       int finalsum= (n*(n+1))/2;\\n        ans.push_back(finalsum-sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734102,
                "title": "python-s-2-simple-and-easy-way-to-solve-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**1. Brute Force Approach:**\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        counts = Counter(nums)\\n        op = [0,0]\\n        for i in range(1, len(nums)+1):\\n            if counts[i]==2:\\n                op[0]=i\\n            if counts[i]==0:\\n                op[1]=i\\n        return op\\n```\\n\\n**2. Optimal Soluton:**\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        total_sum = sum(nums)\\n        set_sum = sum(set(nums))\\n        total_n_sum = length*(length+1)//2\\n        \\n        return [total_sum - set_sum, total_n_sum - set_sum]\\n```\\n**If you\\'re interested in learning Python, check out my blog. https://www.python-techs.com/**\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        counts = Counter(nums)\\n        op = [0,0]\\n        for i in range(1, len(nums)+1):\\n            if counts[i]==2:\\n                op[0]=i\\n            if counts[i]==0:\\n                op[1]=i\\n        return op\\n```\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        total_sum = sum(nums)\\n        set_sum = sum(set(nums))\\n        total_n_sum = length*(length+1)//2\\n        \\n        return [total_sum - set_sum, total_n_sum - set_sum]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734049,
                "title": "o-1-space-easy-to-understand",
                "content": "# Intuition\\nAs this problems says about repetition, we should use mapping.\\n\\n# Approach\\nAs array contains elements from 1 to n only, we don\\'t need extra spaced map. Instead we can use given array as map.\\n\\nFor example, \\nn = 8\\nelements = [3,1,4,5,3,8,6,7]\\n\\nIf we have to mark 3 as visited we will make element at position (3-1) = 2 as visited.\\n\\nSo we will get modified array as\\n[3,1,-4,5,3,8,6,7]\\n\\nFinally after all operations array will be\\n\\n[-3,1,-4,-5-,3,-8,-6,-7]\\n\\nWhile processing array, 3 is encountered twice. While processing duplicated 3, element at 2nd position is already marked. So this gives duplicated element.\\n\\nWe are getting 2nd element is unmakred this gives the element which is missing. That is 2 here. \\n\\nSo ans is [3,2].\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int z = abs(nums[i]) - 1;\\n            if(nums[z]<0)\\n                ans.push_back(z+1);\\n            else\\n                nums[z] *= -1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                ans.push_back(i+1);break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            int z = abs(nums[i]) - 1;\\n            if(nums[z]<0)\\n                ans.push_back(z+1);\\n            else\\n                nums[z] *= -1;\\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>0){\\n                ans.push_back(i+1);break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734021,
                "title": "easy-java-solution-100-faster-1-ms-runtime",
                "content": "# Looking for Contribution in Hacktoberfest\\n## You are welcomed to contribute in my Repos:-\\n# GITHUB LINK --> [Yaduttam95](https://github.com/Yaduttam95)\\n# All PRs are getting accepted...\\n\\n# Please upvote if Helpful\\n\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) { \\n       int x [] = new int[nums.length+1]; \\n       for(int i : nums) x[i]++;  \\n        int a = 0 ; int b = 0 ; \\n       for (int i =1 ;i <x.length; i ++) { \\n           if (x[i]==2)a=i; \\n           if(x[i]==0) b=i;\\n       }\\n     return new int [] {a,b};\\n    }\\n}\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a44dbe0-7232-440d-99cc-d17f06ddf9ec_1666495619.2304356.png)\\n\\n# 1 UPVOTE = 1 SMILE AND 1 MOTIVATION TO POST REGULARLY",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) { \\n       int x [] = new int[nums.length+1]; \\n       for(int i : nums) x[i]++;  \\n        int a = 0 ; int b = 0 ; \\n       for (int i =1 ;i <x.length; i ++) { \\n           if (x[i]==2)a=i; \\n           if(x[i]==0) b=i;\\n       }\\n     return new int [] {a,b};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734003,
                "title": "c-faster-than-38-37",
                "content": "> Runtime: 302 ms, faster than 38.37% of C# online submissions for Set Mismatch.\\nMemory Usage: 47 MB, less than 60.47% of C# online submissions for Set Mismatch.\\n```\\npublic class Solution {\\n    public int[] FindErrorNums(int[] nums) {\\n        int n = nums.Length;\\n        int[] arr = new int[n + 1];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[nums[i]]++;  //store the values in a 1-index based array\\n        }\\n        \\n        int missing = -1, duplicate = -1; //initial dummy values\\n        \\n        for(int i = 1; i <= n; i++)\\n        {\\n            if(arr[i] == 0)\\n                missing = i; //store the 1-index of the result\\n            if(arr[i] == 2)\\n                duplicate = i;  //store the 1-index of the result\\n        }\\n        \\n        return new int[] { duplicate, missing };\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] FindErrorNums(int[] nums) {\\n        int n = nums.Length;\\n        int[] arr = new int[n + 1];\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            arr[nums[i]]++;  //store the values in a 1-index based array\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2734002,
                "title": "c-constant-space-faster-easy-to-understand",
                "content": "* ***Marking Element As Negative***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int repeat = 0;\\n        \\n        int missing = 0;\\n        \\n        // find repeating number\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[abs(arr[i]) - 1] < 0)\\n            {\\n                repeat = abs(arr[i]);\\n            }\\n            else\\n            {\\n                arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1];\\n            }\\n        }\\n        \\n        // find missing number\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] > 0)\\n            {\\n                missing = i + 1;\\n            }\\n        }\\n        \\n        return {repeat, missing};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        int repeat = 0;\\n        \\n        int missing = 0;\\n        \\n        // find repeating number\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[abs(arr[i]) - 1] < 0)\\n            {\\n                repeat = abs(arr[i]);\\n            }\\n            else\\n            {\\n                arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1];\\n            }\\n        }\\n        \\n        // find missing number\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(arr[i] > 0)\\n            {\\n                missing = i + 1;\\n            }\\n        }\\n        \\n        return {repeat, missing};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733859,
                "title": "simple-java-solution-uising-set",
                "content": "```\\n// if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public int[] findErrorNums(int[] nums) \\n    {\\n        HashSet<Integer> tree=new HashSet();\\n        for(int i=1;i<=nums.length;i++) tree.add(i);\\n        int key=0;\\n        int val=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(tree.contains(nums[i])) tree.remove(nums[i]);\\n            else key=nums[i];\\n        }\\n        for(int i : tree) val=i;\\n        return new int[]{key,val};\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public int[] findErrorNums(int[] nums) \\n    {\\n        HashSet<Integer> tree=new HashSet();\\n        for(int i=1;i<=nums.length;i++) tree.add(i);\\n        int key=0;\\n        int val=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(tree.contains(nums[i])) tree.remove(nums[i]);\\n            else key=nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2733769,
                "title": "javascript-o-n-time-o-1-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findErrorNums = function (nums) {\\n  let i = 0;\\n  while (i < nums.length) {\\n    const idx = nums[i] - 1;\\n    if (nums[idx] !== nums[i]) {\\n      [nums[idx], nums[i]] = [nums[i], nums[idx]];\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    const expected = i + 1;\\n    if (expected === nums[i]) continue;\\n\\n    return [nums[i], expected];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findErrorNums = function (nums) {\\n  let i = 0;\\n  while (i < nums.length) {\\n    const idx = nums[i] - 1;\\n    if (nums[idx] !== nums[i]) {\\n      [nums[idx], nums[i]] = [nums[i], nums[idx]];\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    const expected = i + 1;\\n    if (expected === nums[i]) continue;\\n\\n    return [nums[i], expected];\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2644625,
                "title": "python-using-ap-simplest-approach",
                "content": "\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef findErrorNums(self, nums: List[int]) -> List[int]:\\n\\t\\t\\t\\t\\tn=len(nums)  \\n\\t\\t\\t\\t\\tSn=(n*(n+1))//2\\n\\t\\t\\t\\t\\tmissed_element=Sn-sum(set(nums))\\n\\t\\t\\t\\t\\tduplicate=sum(nums)+missed_element-Sn\\n\\t\\t\\t\\t\\treturn  (duplicate,missed_element)",
                "solutionTags": [],
                "code": "\\t\\t\\tclass Solution:\\n\\t\\t\\t\\tdef findErrorNums(self, nums: List[int]) -> List[int]:\\n\\t\\t\\t\\t\\tn=len(nums)  \\n\\t\\t\\t\\t\\tSn=(n*(n+1))//2\\n\\t\\t\\t\\t\\tmissed_element=Sn-sum(set(nums))\\n\\t\\t\\t\\t\\tduplicate=sum(nums)+missed_element-Sn\\n\\t\\t\\t\\t\\treturn  (duplicate,missed_element)",
                "codeTag": "Java"
            },
            {
                "id": 2554670,
                "title": "easy-clear-solution",
                "content": "```\\n vector<int> findErrorNums(vector<int>& nums) {\\n        \\n        unordered_map<int,int>m;\\n        \\n        vector<int>results;\\n        \\n        int temp=0;\\n        \\n        for(auto x : nums){\\n            \\n            if(m.find(x)!=m.end()){\\n                \\n                temp=x;\\n            }\\n            \\n            m[x]++;\\n        }\\n        \\n        results.push_back(temp);\\n        \\n        for(int i=1;i<=nums.size();i++){\\n            \\n            if(m.find(i)==m.end()){\\n                \\n                results.push_back(i);\\n                \\n                break;\\n            }\\n        }\\n        \\n        return results;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<int> findErrorNums(vector<int>& nums) {\\n        \\n        unordered_map<int,int>m;\\n        \\n        vector<int>results;\\n        \\n        int temp=0;\\n        \\n        for(auto x : nums){\\n            \\n            if(m.find(x)!=m.end()){\\n                \\n                temp=x;\\n            }\\n            \\n            m[x]++;\\n        }\\n        \\n        results.push_back(temp);\\n        \\n        for(int i=1;i<=nums.size();i++){\\n            \\n            if(m.find(i)==m.end()){\\n                \\n                results.push_back(i);\\n                \\n                break;\\n            }\\n        }\\n        \\n        return results;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2537846,
                "title": "js-2-best-solution-hashmap-and-sorting-100",
                "content": "# Hashmap\\n```\\nvar findErrorNums = function(nums) {\\n    const hashmap = new Map();\\n    const output = [];\\n    let maxValue = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (hashmap.has(num)) output.push(num);\\n        hashmap.set(num, i);\\n        maxValue = Math.max(maxValue, num);\\n    }\\n\\n    for (let i = 1; i <= maxValue + 1; i++) {\\n        if (!hashmap.has(i)) {\\n            output.push(i);\\n            break;\\n        }\\n    } \\n\\n    return output;\\n};\\n```\\n# Sorting \\n```\\nvar findErrorNums = function(nums) {\\n    nums = nums.sort((a,b) => a - b);\\n    let cacheValue = 0;\\n    const output = [0,0];\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (num === cacheValue) output[0] = num;\\n        if (num === cacheValue + 2) output[1] = num - 1;\\n        cacheValue = num;\\n        \\n        if (output[0] && output[1]) break;\\n    }\\n    \\n    if (!output[1]) output[1] = nums[nums.length - 1] + 1;\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar findErrorNums = function(nums) {\\n    const hashmap = new Map();\\n    const output = [];\\n    let maxValue = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (hashmap.has(num)) output.push(num);\\n        hashmap.set(num, i);\\n        maxValue = Math.max(maxValue, num);\\n    }\\n\\n    for (let i = 1; i <= maxValue + 1; i++) {\\n        if (!hashmap.has(i)) {\\n            output.push(i);\\n            break;\\n        }\\n    } \\n\\n    return output;\\n};\\n```\n```\\nvar findErrorNums = function(nums) {\\n    nums = nums.sort((a,b) => a - b);\\n    let cacheValue = 0;\\n    const output = [0,0];\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (num === cacheValue) output[0] = num;\\n        if (num === cacheValue + 2) output[1] = num - 1;\\n        cacheValue = num;\\n        \\n        if (output[0] && output[1]) break;\\n    }\\n    \\n    if (!output[1]) output[1] = nums[nums.length - 1] + 1;\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454442,
                "title": "o-n-with-cyclic-sort",
                "content": "```\\nfunc findErrorNums(nums []int) []int {\\n    i := 0\\n    \\n    for i < len(nums) {\\n        desiredPosition := nums[i]-1\\n        \\n        if nums[i]-1 != i && nums[i] != nums[desiredPosition] {\\n            nums[i], nums[desiredPosition] = nums[desiredPosition], nums[i]\\n        } else {\\n            i++\\n        }\\n    }\\n\\n    var res []int\\n    \\n    for j := 0; j < len(nums); j++ {\\n        if nums[j] != j+1 {\\n            res = append(res, nums[j])\\n            res = append(res, j+1)\\n            break\\n        }\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nfunc findErrorNums(nums []int) []int {\\n    i := 0\\n    \\n    for i < len(nums) {\\n        desiredPosition := nums[i]-1\\n        \\n        if nums[i]-1 != i && nums[i] != nums[desiredPosition] {\\n            nums[i], nums[desiredPosition] = nums[desiredPosition], nums[i]\\n        } else {\\n            i++\\n        }\\n    }\\n\\n    var res []int\\n    \\n    for j := 0; j < len(nums); j++ {\\n        if nums[j] != j+1 {\\n            res = append(res, nums[j])\\n            res = append(res, j+1)\\n            break\\n        }\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2453113,
                "title": "very-easy-straight-forward-solution",
                "content": "Step-1: Declare a HashSet, a variable duplicate and a variable missing. Traverse the array, if the HashSet contains the element then update the duplicate variable with the number that is already present in the set. Else, keep on adding elements to the HashSet;\\n\\nStep-2: Compute the total sum of \\'n\\' number by the formula: sum of \\'n\\' numbers = n*(n+1)/2\\n\\nStep-3: Compute the sum of elements present in set.\\n\\nStep-4: Update the missing number variable as total sum of \\'n\\' numbers - sum of the numbers present in the set.\\n\\nStep-5: Return the result as new array consisting of duplicate, missing numbers.\\n\\n```\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        int duplicate=0;\\n        for(int i: nums){\\n            \\n            if(set.contains(i)){\\n                duplicate=i;\\n            }else {\\n                set.add(i);\\n            }\\n        }\\n        \\n        int setSum =0;\\n        for(int i: set){\\n            setSum+=i;\\n        }\\n        \\n        int totalSum = (nums.length*(nums.length+1))/2;\\n        \\n        int missing = totalSum - setSum;\\n        System.out.println(totalSum + \" \"+ duplicate + \" \"+setSum);\\n        \\n        return new int[]{duplicate, missing};\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        \\n        HashSet<Integer> set = new HashSet<>();\\n        int duplicate=0;\\n        for(int i: nums){\\n            \\n            if(set.contains(i)){\\n                duplicate=i;\\n            }else {\\n                set.add(i);\\n            }\\n        }\\n        \\n        int setSum =0;\\n        for(int i: set){\\n            setSum+=i;\\n        }\\n        \\n        int totalSum = (nums.length*(nums.length+1))/2;\\n        \\n        int missing = totalSum - setSum;\\n        System.out.println(totalSum + \" \"+ duplicate + \" \"+setSum);\\n        \\n        return new int[]{duplicate, missing};\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401902,
                "title": "o-n-time-and-o-1-auxiliary-space",
                "content": "Use elements as Index and mark the visited places\\n**O(n) Time and O(1) Auxiliary Space**\\nApproach: \\nTraverse the array. While traversing, use the absolute value of every element as an index and make the value at this index as negative to mark it visited. If something is already marked negative then this is the repeating element. To find missing, traverse the array again and look for a positive value\\n```\\nimport math\\nclass Solution:\\n    def findErrorNums(self, arr: List[int]) -> List[int]:\\n        size=len(arr)\\n        ans=[]\\n        for i in range(size):\\n            print(arr[abs(arr[i])-1],i,arr[i],abs(arr[i]))\\n            if arr[abs(arr[i])-1] > 0:\\n                arr[abs(arr[i])-1] = -arr[abs(arr[i])-1]\\n            else:\\n                ans.append(abs(arr[i]))\\n        for i in range(size):\\n            if arr[i]>0:\\n                ans.append(i + 1)\\n        return ans\\n```\\n\\nuppvote if liked.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def findErrorNums(self, arr: List[int]) -> List[int]:\\n        size=len(arr)\\n        ans=[]\\n        for i in range(size):\\n            print(arr[abs(arr[i])-1],i,arr[i],abs(arr[i]))\\n            if arr[abs(arr[i])-1] > 0:\\n                arr[abs(arr[i])-1] = -arr[abs(arr[i])-1]\\n            else:\\n                ans.append(abs(arr[i]))\\n        for i in range(size):\\n            if arr[i]>0:\\n                ans.append(i + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384700,
                "title": "c-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        unordered_map<int,int> m;\\n        int p,q;\\n        for(auto &x:nums)\\n        {\\n            m[x]++;\\n            if(m[x]==2)\\n            {\\n                p=x;\\n                break;\\n            }\\n        }\\n        int n=nums.size();\\n        q=(n*(n+1))/2-accumulate(nums.begin(),nums.end(),0)+p;\\n        return {p,q};\\n        \\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) \\n    {\\n        unordered_map<int,int> m;\\n        int p,q;\\n        for(auto &x:nums)\\n        {\\n            m[x]++;\\n            if(m[x]==2)\\n            {\\n                p=x;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2264154,
                "title": "python3-cyclicsort-o-n-o-1-runtime-236ms-79-68-memory-15-3mb-93-57",
                "content": "```\\nclass Solution:\\n#     O(n) || O(1)\\n# Runtime: 236ms 79.68% || Memory: 15.3mb 93.57%\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        \\n        def cyclicSort(array):\\n            i = 0\\n            while i < len(array):\\n                check = array[i] - 1\\n\\n                if array[i] != array[check]:\\n                    array[i], array[check] = array[check], array[i]\\n                else:\\n                    i += 1\\n                    \\n        cyclicSort(nums)\\n\\n        result = []\\n\\n        for i in range(len(nums)):\\n            if i + 1 != nums[i]:\\n                result += [nums[i], i + 1]\\n\\n        return result\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n#     O(n) || O(1)\\n# Runtime: 236ms 79.68% || Memory: 15.3mb 93.57%\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        if not nums:\\n            return nums\\n        \\n        def cyclicSort(array):\\n            i = 0\\n            while i < len(array):\\n                check = array[i] - 1\\n\\n                if array[i] != array[check]:\\n                    array[i], array[check] = array[check], array[i]\\n                else:\\n                    i += 1\\n                    \\n        cyclicSort(nums)\\n\\n        result = []\\n\\n        for i in range(len(nums)):\\n            if i + 1 != nums[i]:\\n                result += [nums[i], i + 1]\\n\\n        return result\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224528,
                "title": "is-this-test-case-wrong",
                "content": "this is my code that return the updated part of array that was previously repleated but my approch returns ***[1,2]*** for the test case ***[2,2]*** , but it is showing it as an error because it is expecting ***[2,1]*** , I just dont understand as all the inputs are in sorted form.\\n\\nCan anybody confirm this or I am just dumb.\\n```\\nvar findErrorNums = function(nums) {\\n  let lastDigit = nums[0]\\n  for(let i=1;i<nums.length;i++){\\n      if(lastDigit===nums[i]){\\n        nums[i]=i+1;\\n        return [i,nums[i]]\\n      }\\n      lastDigit=nums[i]\\n  }  \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/29cd00da-8fed-4adb-bdd7-f985f2ff64b0_1656706833.9328203.png)\\n",
                "solutionTags": [],
                "code": "```\\nvar findErrorNums = function(nums) {\\n  let lastDigit = nums[0]\\n  for(let i=1;i<nums.length;i++){\\n      if(lastDigit===nums[i]){\\n        nums[i]=i+1;\\n        return [i,nums[i]]\\n      }\\n      lastDigit=nums[i]\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2205594,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findErrorNums = function(nums) {\\n    let n = nums.length\\n    const map = {}\\n    let dup, missing\\n    for (let num of nums) {\\n        if (!(num in map)) map[num] = 1\\n        else dup = num\\n    }\\n    \\n    for (let i = 1; i <= n; i++) {\\n        if (!(i in map)) missing = i\\n    }\\n    \\n    return [dup, missing]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar findErrorNums = function(nums) {\\n    let n = nums.length\\n    const map = {}\\n    let dup, missing\\n    for (let num of nums) {\\n        if (!(num in map)) map[num] = 1\\n        else dup = num\\n    }\\n    \\n    for (let i = 1; i <= n; i++) {\\n        if (!(i in map)) missing = i\\n    }\\n    \\n    return [dup, missing]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192078,
                "title": "java-2ms-beats-98-5-simple-easy",
                "content": "![image](https://assets.leetcode.com/users/images/78c33f15-04ba-4ca8-b368-d4198df5dce8_1656089980.862297.png)\\n\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i=0;\\n        //Cyclic Sort\\n        while(i<nums.length)\\n        {\\n            int correct=nums[i]-1;\\n            if(nums[correct]!=nums[i])\\n            {\\n                int temp=nums[correct];\\n                nums[correct]=nums[i];\\n                nums[i]=temp;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        //Return the repeating(nums[i]) and the missing number (index+1)\\n        for (i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                return new int[] {nums[i],i+1};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n    }\\n}\\n```\\n***Pls upvote the solution if you find it helpful.***",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int i=0;\\n        //Cyclic Sort\\n        while(i<nums.length)\\n        {\\n            int correct=nums[i]-1;\\n            if(nums[correct]!=nums[i])\\n            {\\n                int temp=nums[correct];\\n                nums[correct]=nums[i];\\n                nums[i]=temp;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        //Return the repeating(nums[i]) and the missing number (index+1)\\n        for (i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]!=i+1)\\n            {\\n                return new int[] {nums[i],i+1};\\n            }\\n        }\\n        return new int[] {-1,-1};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137993,
                "title": "c-o-n-time-o-1-space-simple-maths",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        double sum=0,p_sum=0;\\n        double missing, duplicate;\\n        for(int i=1;i<=nums.size();i++){\\n           sum+=i;\\n           p_sum+=(i*i);\\n            \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            sum-=nums[i];\\n            p_sum-=(nums[i]*nums[i]);\\n        }\\n        missing=(sum+(p_sum/sum))/2;\\n        duplicate=missing-sum;\\n        int m=(int) missing;\\n        int p=(int)duplicate;\\n        \\n        return {p,m};\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        double sum=0,p_sum=0;\\n        double missing, duplicate;\\n        for(int i=1;i<=nums.size();i++){\\n           sum+=i;\\n           p_sum+=(i*i);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1966708,
                "title": "c",
                "content": "```\\n    public int[] FindErrorNums(int[] nums) {\\n        \\n        int[] temp = Enumerable.Range(1, Math.Max(nums[nums.Length - 1], nums.Length)).ToArray();\\n\\n        int missed = temp.Except(nums).First();\\n        int duplicated = nums.GroupBy(x => x).Where(x => x.Count() > 1).First().Key;\\n\\n        return new int[] { duplicated, missed };\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    public int[] FindErrorNums(int[] nums) {\\n        \\n        int[] temp = Enumerable.Range(1, Math.Max(nums[nums.Length - 1], nums.Length)).ToArray();\\n\\n        int missed = temp.Except(nums).First();\\n        int duplicated = nums.GroupBy(x => x).Where(x => x.Count() > 1).First().Key;\\n\\n        return new int[] { duplicated, missed };\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1937231,
                "title": "python-clean-and-simple",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        missing, normal, duplicate = set(range(1,len(nums)+1)), set(), set()\\n        \\n        for num in nums:\\n            if num in missing:\\n                missing.remove(num)\\n                normal.add(num)\\n            elif num in normal:\\n                normal.remove(num)\\n                duplicate.add(num)\\n        \\n        return [duplicate.pop(), missing.pop()]\\n```\\n\\n**Solution -  using only the space from the array**:\\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        duplicate, missing = None, None\\n        \\n        for num in nums:\\n            visited = nums[abs(num)-1] < 0\\n            if not visited: nums[abs(num)-1] *= -1\\n            else: duplicate = abs(num)\\n        \\n        for i,num in enumerate(nums):\\n            visited = nums[i] < 0\\n            if not visited: missing = i+1; break\\n        \\n        return [duplicate, missing]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        missing, normal, duplicate = set(range(1,len(nums)+1)), set(), set()\\n        \\n        for num in nums:\\n            if num in missing:\\n                missing.remove(num)\\n                normal.add(num)\\n            elif num in normal:\\n                normal.remove(num)\\n                duplicate.add(num)\\n        \\n        return [duplicate.pop(), missing.pop()]\\n```\n```\\nclass Solution:\\n    def findErrorNums(self, nums):\\n        duplicate, missing = None, None\\n        \\n        for num in nums:\\n            visited = nums[abs(num)-1] < 0\\n            if not visited: nums[abs(num)-1] *= -1\\n            else: duplicate = abs(num)\\n        \\n        for i,num in enumerate(nums):\\n            visited = nums[i] < 0\\n            if not visited: missing = i+1; break\\n        \\n        return [duplicate, missing]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910188,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int> ans;\\n        int repeating;\\n        int numssum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                repeating= nums[i];\\n                ans.push_back(nums[i]);\\n                break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            numssum+=nums[i];\\n        }\\n        numssum = numssum-repeating;\\n        int n= nums.size();\\n        int sum= (n*(n+1)/2);\\n        ans.push_back(abs(sum-numssum));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int> ans;\\n        int repeating;\\n        int numssum=0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size()-1;i++){\\n            if(nums[i]==nums[i+1]){\\n                repeating= nums[i];\\n                ans.push_back(nums[i]);\\n                break;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            numssum+=nums[i];\\n        }\\n        numssum = numssum-repeating;\\n        int n= nums.size();\\n        int sum= (n*(n+1)/2);\\n        ans.push_back(abs(sum-numssum));\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841325,
                "title": "c-3-methods",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        //method 1\\n        sort(nums.begin(),nums.end());\\n        vector<int>vec;\\n        int sum=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                vec.push_back(nums[i]);        \\n            }  \\n            sum=sum+nums[i];\\n        }\\n  \\n        int n=nums.size();\\n        int total=n*(n+1)/2;\\n        int missing_no=total+vec[0]-sum-nums[0];\\n        vec.push_back(missing_no);\\n        return vec;\\n    }\\n        //method 2\\n    //    vector<int> vec;\\n    //     unordered_map<int,int> mp;\\n    //     for(auto i:nums)\\n    //     {\\n    //         mp[i]++;\\n    //     }\\n    //     for(auto i:mp)\\n    //     {\\n    //         if(i.second==2)\\n    //         {\\n    //             vec.push_back(i.first);\\n    //         }\\n    //     }\\n    //     for(int i=1;i<=nums.size();i++)\\n    //     {\\n    //         if(mp[i]==0)\\n    //         {\\n    //             vec.push_back(i);\\n    //         }\\n    //     }\\n    //     return vec;\\n    // }\\n};   \\n    //logic 3: if(nums[i]^nums[i-1]==0) // means found the equal then follow the procedure of method 1.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        //method 1\\n        sort(nums.begin(),nums.end());\\n        vector<int>vec;\\n        int sum=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]==nums[i-1])\\n            {\\n                vec.push_back(nums[i]);        \\n            }  \\n            sum=sum+nums[i];\\n        }\\n  \\n        int n=nums.size();\\n        int total=n*(n+1)/2;\\n        int missing_no=total+vec[0]-sum-nums[0];\\n        vec.push_back(missing_no);\\n        return vec;\\n    }\\n        //method 2\\n    //    vector<int> vec;\\n    //     unordered_map<int,int> mp;\\n    //     for(auto i:nums)\\n    //     {\\n    //         mp[i]++;\\n    //     }\\n    //     for(auto i:mp)\\n    //     {\\n    //         if(i.second==2)\\n    //         {\\n    //             vec.push_back(i.first);\\n    //         }\\n    //     }\\n    //     for(int i=1;i<=nums.size();i++)\\n    //     {\\n    //         if(mp[i]==0)\\n    //         {\\n    //             vec.push_back(i);\\n    //         }\\n    //     }\\n    //     return vec;\\n    // }\\n};   \\n    //logic 3: if(nums[i]^nums[i-1]==0) // means found the equal then follow the procedure of method 1.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833352,
                "title": "set-mismatch-solution-java",
                "content": "class Solution {\\n  public int[] findErrorNums(int[] nums) {\\n    int duplicate = 0;\\n\\n    for (final int num : nums) {\\n      if (nums[Math.abs(num) - 1] < 0)\\n        duplicate = Math.abs(num);\\n      else\\n        nums[Math.abs(num) - 1] *= -1;\\n    }\\n\\n    for (int i = 0; i < nums.length; ++i)\\n      if (nums[i] > 0)\\n        return new int[] {duplicate, i + 1};\\n\\n    throw new IllegalArgumentException();\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Bit Manipulation",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public int[] findErrorNums(int[] nums) {\\n    int duplicate = 0;\\n\\n    for (final int num : nums) {\\n      if (nums[Math.abs(num) - 1] < 0)\\n        duplicate = Math.abs(num);\\n      else\\n        nums[Math.abs(num) - 1] *= -1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1800161,
                "title": "similar-to-single-number-1-very-easy-solution",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n     map<int,int>m;\\n        int n=nums.size();\\n     for(int i=0;i<n;i++)\\n     {\\n         m[nums[i]]++;\\n     }\\n        int a;\\n     for(auto x:m)\\n     {\\n         if(x.second==2)\\n         {\\n             a=x.first;\\n             break;\\n         }\\n     }\\n        vector<int>ans;\\n        for(int i=1;i<=n;i++)\\n        {\\n            ans.push_back(i);\\n        }\\n        int xor1=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            xor1=nums[i]^xor1;\\n        }\\n        \\n        int xor2=0;\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            xor2=ans[i]^xor2;\\n        }\\n        int b=a^xor1^xor2;\\n        vector<int>har;\\n        har.push_back(a);\\n        har.push_back(b);\\n        return har;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1739196,
                "title": "beginner-friendly-java-solution",
                "content": "**Time Complexity : O(n*logn)**\\n```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        Arrays.sort(nums);\\n        int res[] = new int[2];\\n        int n = 0, i = 0;\\n        for(i=0; i<nums.length-1; i++){\\n            if(nums[i] != nums[i+1]){\\n                n ^= nums[i] ^ (i+1);\\n            }else{\\n                res[0] = nums[i];\\n                n ^= (i+1);\\n            }\\n        }\\n        res[1] = n ^ nums[i] ^ (i+1);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        Arrays.sort(nums);\\n        int res[] = new int[2];\\n        int n = 0, i = 0;\\n        for(i=0; i<nums.length-1; i++){\\n            if(nums[i] != nums[i+1]){\\n                n ^= nums[i] ^ (i+1);\\n            }else{\\n                res[0] = nums[i];\\n                n ^= (i+1);\\n            }\\n        }\\n        res[1] = n ^ nums[i] ^ (i+1);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540084,
                "title": "java-fastest-2ms",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        \\n        int n=nums.length;\\n        int a[]=new int[n+1];\\n        int b[]=new int[2];\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            a[nums[i]]=a[nums[i]]+1;\\n        }\\n        for(i=1;i<a.length;i++){\\n            if(a[i]==2)\\n                b[0]=i;\\n            \\n            if(a[i]==0)\\n                b[1]=i;\\n            \\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        \\n        int n=nums.length;\\n        int a[]=new int[n+1];\\n        int b[]=new int[2];\\n        int i=0;\\n        for(i=0;i<nums.length;i++){\\n            a[nums[i]]=a[nums[i]]+1;\\n        }\\n        for(i=1;i<a.length;i++){\\n            if(a[i]==2)\\n                b[0]=i;\\n            \\n            if(a[i]==0)\\n                b[1]=i;\\n            \\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508353,
                "title": "python-with-counter",
                "content": "![image](https://assets.leetcode.com/users/images/a00e92cf-36cd-41ed-b165-f79a4d88fb64_1633606124.8847945.png)\\n```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        c = collections.Counter(nums)\\n        for i in range(1, len(nums)+1):\\n            j = c.get(i)\\n            if j==2:\\n                mul = i \\n            if i not in c:\\n                mis = i\\n        else:\\n            return [mul, mis]\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        c = collections.Counter(nums)\\n        for i in range(1, len(nums)+1):\\n            j = c.get(i)\\n            if j==2:\\n                mul = i \\n            if i not in c:\\n                mis = i\\n        else:\\n            return [mul, mis]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316837,
                "title": "xor-solution-one-pass",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[]{0, 0};\\n        int[] freq = new int[nums.length];\\n        int xor = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i] - 1]++;\\n            xor ^= (nums[i] ^ (i + 1));\\n            if (freq[nums[i] - 1] > 1) ans[0] = nums[i];\\n        }\\n        ans[1] = xor ^ ans[0];\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] ans = new int[]{0, 0};\\n        int[] freq = new int[nums.length];\\n        int xor = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i] - 1]++;\\n            xor ^= (nums[i] ^ (i + 1));\\n            if (freq[nums[i] - 1] > 1) ans[0] = nums[i];\\n        }\\n        ans[1] = xor ^ ans[0];\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262184,
                "title": "java-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] array = new int[nums.length+1];\\n        for(int i = 0; i < nums.length; i++){\\n            array[nums[i]]++;\\n        }\\n        int repeatedNumber = 0;\\n        int missingNumber = 0;\\n        int index = 0;\\n        for(int count : array){\\n            if(count == 0)\\n                missingNumber = index;\\n            if(count == 2)\\n                repeatedNumber = index;\\n            index++;\\n        }\\n        return new int[]{repeatedNumber, missingNumber};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] array = new int[nums.length+1];\\n        for(int i = 0; i < nums.length; i++){\\n            array[nums[i]]++;\\n        }\\n        int repeatedNumber = 0;\\n        int missingNumber = 0;\\n        int index = 0;\\n        for(int count : array){\\n            if(count == 0)\\n                missingNumber = index;\\n            if(count == 2)\\n                repeatedNumber = index;\\n            index++;\\n        }\\n        return new int[]{repeatedNumber, missingNumber};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136162,
                "title": "mathematical-approach-for-solving-without-using-loops-98-faster-and-understandable",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        sumoftotal = n*(n+1)/2\\n        res = []\\n        numsset = set(nums)\\n        res.append(sum(nums) - sum(list(numsset)))\\n        res.append(int(sumoftotal - sum(list(numsset))))\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        sumoftotal = n*(n+1)/2\\n        res = []\\n        numsset = set(nums)\\n        res.append(sum(nums) - sum(list(numsset)))\\n        res.append(int(sumoftotal - sum(list(numsset))))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1130838,
                "title": "python-3-xor-solution",
                "content": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        dx = {}\\n        for i in nums:\\n            if i not in dx:\\n                dx[i] = 1\\n            else:\\n                duplicate = i\\n                break\\n        print(dx)\\n        xor = len(nums)\\n        for i in range(0,len(nums)):\\n            xor = xor^i^nums[i]\\n        xor = xor^duplicate\\n        return [duplicate,xor]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findErrorNums(self, nums: List[int]) -> List[int]:\\n        dx = {}\\n        for i in nums:\\n            if i not in dx:\\n                dx[i] = 1\\n            else:\\n                duplicate = i\\n                break\\n        print(dx)\\n        xor = len(nums)\\n        for i in range(0,len(nums)):\\n            xor = xor^i^nums[i]\\n        xor = xor^duplicate\\n        return [duplicate,xor]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099858,
                "title": "set-mismatch-c-o-n-multiple-solutions-easy-explained",
                "content": "### Solution-1\\nWe can solve the problem using a hashset. \\n* We iterate for the first time and insert elements into the hashset. If during the first iteration, we encounter an element which is already added, that would be 1st element of our `ans` vector. \\n* We iterate for a second time from `1` to `nums.size()` and check if each element is present in the hashset(since it is given that the original `nums` contained elements from `1` to `nums.size()`). If an element is not found, we assign it as 2nd element of and return the `ans` vector.\\n```\\nvector<int> findErrorNums(vector<int>& nums) {\\n        vector<int>ans(2);\\n        unordered_set<int>s;\\n        for(auto& num:nums){\\n            if(s.find(num) != s.end())\\n                ans[0] = num;\\n            s.insert(num);\\n        }\\n        \\n        for(int i = 1; i <= nums.size(); i++)\\n            if(s.find(i) == s.end()){\\n                ans[1] = i;\\n                return ans;\\n            }\\n        return ans;\\n    }\\n```\\n**Time Complexity** : **`O(N)`**(beats 60%), for iterating over the `nums` vector.\\n**Space Complexity** : **`O(N)`**, for maintaining the hashset.\\n\\n----------------\\n\\n### Solution-2 (optimized from sol-1)\\nWe can speedup the execution time significantly if we use a *vector* instead of *unordered_set* as a hashset. This will eliminate the constant factor in each *unordered_set\\'s* insert and find operation.\\n\\n```\\nvector<int> findErrorNums(vector<int>& nums) {        \\n        vector<int>ans(2), hashSet(nums.size() + 1);\\n        for(auto& num:nums)\\n            hashSet[num]++;        \\n        \\n        for(int i = 1; i <= nums.size(); i++)\\n            if(hashSet[i] == 2) ans[0] = i;\\n            else if(!hashSet[i]) ans[1] = i;\\n        \\n        return ans;\\n    }\\n```\\n**Time Complexity** : **`O(N)`** (beats 97%), for iterating over the `nums` vector.\\n**Space Complexity** : **`O(N)`**, for maintaining the vector(hashset).\\n\\n------------------\\n\\n### Solution-3(Space optimized)\\nWe can use the `nums` vector itself to find the duplicated and missing element. In the below solution, the first loop is used to make all the elements negative. The only element that will be positive at end would be at the index equal to missing `element\\'s value - 1`.\\n\\n```\\nvector<int> findErrorNums(vector<int>& nums) {\\n    vector<int>ans(2);\\n    for(auto& num:nums)\\n        if(nums[abs(num) - 1] < 0) ans[0] = abs(num);\\n        else nums[abs(num) - 1] = -nums[abs(num) - 1];\\n\\tfor(int i = 0; i < nums.size(); i++)\\n       if(nums[i] > 0) ans[1] = i + 1;\\n    return ans;\\n}\\n```\\n**Time Complexity** : **`O(N)`** (beats 98%), for iterating over the `nums` vector.\\n**Space Complexity** : **`O(1)`**, no extra space is used.",
                "solutionTags": [],
                "code": "```\\nvector<int> findErrorNums(vector<int>& nums) {\\n        vector<int>ans(2);\\n        unordered_set<int>s;\\n        for(auto& num:nums){\\n            if(s.find(num) != s.end())\\n                ans[0] = num;\\n            s.insert(num);\\n        }\\n        \\n        for(int i = 1; i <= nums.size(); i++)\\n            if(s.find(i) == s.end()){\\n                ans[1] = i;\\n                return ans;\\n            }\\n        return ans;\\n    }\\n```\n```\\nvector<int> findErrorNums(vector<int>& nums) {        \\n        vector<int>ans(2), hashSet(nums.size() + 1);\\n        for(auto& num:nums)\\n            hashSet[num]++;        \\n        \\n        for(int i = 1; i <= nums.size(); i++)\\n            if(hashSet[i] == 2) ans[0] = i;\\n            else if(!hashSet[i]) ans[1] = i;\\n        \\n        return ans;\\n    }\\n```\n```\\nvector<int> findErrorNums(vector<int>& nums) {\\n    vector<int>ans(2);\\n    for(auto& num:nums)\\n        if(nums[abs(num) - 1] < 0) ans[0] = abs(num);\\n        else nums[abs(num) - 1] = -nums[abs(num) - 1];\\n\\tfor(int i = 0; i < nums.size(); i++)\\n       if(nums[i] > 0) ans[1] = i + 1;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094783,
                "title": "java-single-iteration-o-1-space-and-time-beats-100",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        /** Assume m is missing and d is duplicate element\\n         diff= m-d;\\n         quareDiff= m^2-d^2;\\n         sum=m+d= squareDiff/diff\\n         =>sum    = (m+d)(m-d)/(m-d);\\n         now m=(sum+diff)2;\\n         and d= (sum-diff)2;\\n        **/\\n        int diff=0;\\n        int sqaureDiff=0;\\n        for(int i=0;i<nums.length;i++){\\n            /** \\n            The order doesnot matter. keep adding the 1 to n and simultaneously subracting  corresponding array element.\\n            Use i+1 to get 1 to n  since i is the index number which is zero based.\\n            **/\\n            diff+=(i+1)-nums[i];\\n            /** squareDiff is also calculated in the same way as diff is calculated. **/\\n            sqaureDiff+= (i+1)*(i+1)-nums[i]*nums[i];\\n        } \\n       int sum=sqaureDiff/diff;\\n      return new int[]{(sum-diff)/2,(sum+diff)/2};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        /** Assume m is missing and d is duplicate element\\n         diff= m-d;\\n         quareDiff= m^2-d^2;\\n         sum=m+d= squareDiff/diff\\n         =>sum    = (m+d)(m-d)/(m-d);\\n         now m=(sum+diff)2;\\n         and d= (sum-diff)2;\\n        **/\\n        int diff=0;\\n        int sqaureDiff=0;\\n        for(int i=0;i<nums.length;i++){\\n            /** \\n            The order doesnot matter. keep adding the 1 to n and simultaneously subracting  corresponding array element.\\n            Use i+1 to get 1 to n  since i is the index number which is zero based.\\n            **/\\n            diff+=(i+1)-nums[i];\\n            /** squareDiff is also calculated in the same way as diff is calculated. **/\\n            sqaureDiff+= (i+1)*(i+1)-nums[i]*nums[i];\\n        } \\n       int sum=sqaureDiff/diff;\\n      return new int[]{(sum-diff)/2,(sum+diff)/2};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091022,
                "title": "c-simple-solution-o-n-time-o-n-space",
                "content": "Simple solution using extra vector to replace map to record frequency\\n```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int> res(2); //Result\\n        vector<int> m(nums.size(), 0); //Record frequency\\n        for(int i = 0; i < nums.size(); i++){\\n            m[nums[i]-1]++;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(m[i] == 2){ //If frequency is 2 (repeated)\\n                res[0] = i+1; //Put into result\\n            }else if(!m[i]){ //If frequency is 0 (the missing one)\\n                res[1] = i+1; //Put into result\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        vector<int> res(2); //Result\\n        vector<int> m(nums.size(), 0); //Record frequency\\n        for(int i = 0; i < nums.size(); i++){\\n            m[nums[i]-1]++;\\n        }\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            if(m[i] == 2){ //If frequency is 2 (repeated)\\n                res[0] = i+1; //Put into result\\n            }else if(!m[i]){ //If frequency is 0 (the missing one)\\n                res[1] = i+1; //Put into result\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089768,
                "title": "simple-java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] result = new int[2];\\n        int[] arr = new int[nums.length];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            arr[nums[i] - 1]++;\\n        }\\n        \\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] > 1) result[0] = i + 1;\\n            else if (arr[i] == 0) result[1] = i + 1;\\n        }\\n        \\n        \\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] result = new int[2];\\n        int[] arr = new int[nums.length];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            arr[nums[i] - 1]++;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1655829,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1656409,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1572328,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1571794,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 2057001,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1571844,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1576250,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 2062209,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 2009467,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1930495,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1655829,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1656409,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1572328,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1571794,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 2057001,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1571844,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1576250,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 2062209,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 2009467,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1930495,
                "content": [
                    {
                        "username": "FadiZaarouri",
                        "content": "I always find a solution and upon submitting the code it goes wrong because the question is UNCLEAR!!!!! as usual they don\\'t bother give you details.\\n\\nLeetCode, why have you not mentioned that the ordering could go both ways?! \\n\\nAlso, instead of the silly second example you could have given the following case\\nnums = [3,2,2]\\noutput = [2,1]\\n\\nThis is becoming unprofessional and kind of a hide and seek game."
                    },
                    {
                        "username": "Ishankoradia",
                        "content": "I think the fact they have mentioned that its a set datatype. Sets are not ordered so our algorithm should not be based on ordered list"
                    },
                    {
                        "username": "ayhanavci",
                        "content": "[@dalton_a](/dalton_a) It says \"contains all the numbers from 1 to n\" and then proceeds to give examples that are exactly increasing from 1 to n. Anyone would understand it is increasing and sequential. This is not a real life project in which we can ask questions to the customer to clarify his request. All we have is a short description. The burden of clarity is 100% on the question."
                    },
                    {
                        "username": "dalton_a",
                        "content": "Nowhere in the problem does it say the list is sorted. Your algorithm should work for any valid input. It\\'s a bit unclear that all test cases are sorted, but that doesn\\'t mean that your algorithm can assume a sorted list."
                    },
                    {
                        "username": "lokeeokee",
                        "content": "Same thing happened to me! Very unclear, wasted a few minutes only for it to be revealed that my method wouldn\\'t work for the actual problem which was hidden behind the submit button. "
                    },
                    {
                        "username": "hosua",
                        "content": "If ordering matters for the solution, it should be stated.\\n\\nMade this problem a headache for no reason."
                    },
                    {
                        "username": "its_iterator",
                        "content": "yes"
                    },
                    {
                        "username": "ug267",
                        "content": "I just wondering why the answer for **Test Case nums= [2,2]**  is [2,1]\\n\\nmy answer is [1,2] which is apparently wrong!\\n\\nbecause the range is **1 - n** : and the input is [2,2] the orginal array could have been either [1,2] or [2,1].\\n"
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "[@smajhi6289](/smajhi6289) Invalid input. \nThe input array should contain numbers from 1 to n (take n for size of array).\nIf the array's size is 2, maximum a[i] should be 2 and for a[i] to be 3, size must be >=3."
                    },
                    {
                        "username": "abhaykushwaha07",
                        "content": "[@smajhi6289](/smajhi6289) invalid input\\n"
                    },
                    {
                        "username": "introvert9112k",
                        "content": "[@naushad_ali](/naushad_ali)  missing is 1, you written missing as 2, correct it."
                    },
                    {
                        "username": "AnuragAdarsh",
                        "content": "Return [duplicate, missing]. Here duplicate is 2 and missing is 1, so [2,1]."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "[@smajhi6289](/smajhi6289) It\\'s not a valid input. Input should contain values from 1 to n and only one number will be duplicate and only one will be missing."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "You have to return the [duplicateNumber, missingNumber]:\nIn case of [2,2], duplicate is 2 and missing is 1 so answer is [2,1]"
                    },
                    {
                        "username": "smajhi6289",
                        "content": "what will be the answer for [3,3] ?"
                    },
                    {
                        "username": "Harrywithcode",
                        "content": "Please, give more details of this question"
                    },
                    {
                        "username": "20r01a66h7",
                        "content": "For those who didn\\'t understand the question clearly:\\nIn this question we have to find the element in the array which is repeated twice and the number which has to be come in the place of repeated number.\\nExample:\\n1)   [1,2,3,4,9,6,7,8,9]\\n      output: [9,5]\\n2)   [4,8,1,5,2,7,4,6]\\n      output: [4,3]\\nNote : The input array may be sorted or unsorted"
                    },
                    {
                        "username": "xiaowu4",
                        "content": "if we can not modify the array. In general, we can't modify the array. So is there any idea with O(n) time and O(1) space?"
                    },
                    {
                        "username": "Vaidehi2718",
                        "content": "[@Chouhan_Gourav](/Chouhan_Gourav)  we can also use cyclic sort here ig"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "use solution involving xor operation"
                    },
                    {
                        "username": "satyendra706",
                        "content": "if u guys face any  problem then ask me\\n\\n\\n"
                    },
                    {
                        "username": "vikku9039",
                        "content": "https://leetcode.com/problems/set-mismatch/description/comments/1576250"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "[@pratham2712](/pratham2712) The problem is that you found the duplicate number, but missing number could be anywhere in the array.\nQuestion says that a number 's' got duplicated but never said the duplicated number and missing number is adjacent.\nYou have to find the duplicate number and the missing number as well.\n\nBy the way good work with logic."
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\nwhat is wrong with my logic in this code ??"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "Since you know that your set should contain all the numbers from `1` to `n`, you could rearrange it so that `nums[0] = 1, nums[1] = 2, ..., nums[n-1] = n`. How? Check if your current position contains the right element; if it doesn\\'t, swap this element with what\\'s at its spot. Otherwise, move to the next till you\\'ve checked all.\\n\\n**Example:**\\n> **8** 7 3 5 3 6 1 [4]\\n> **4** 7 3 [5] 3 6 1 8\\n> **5** 7 3 4 [3] 6 1 8\\n> **3** 7 [3] 4 5 6 1 8\\n> [3] **1** 3 4 5 6 7 8\\n> 1 **3** [3] 4 5 6 7 8\\n> 1 3 **[3]** 4 5 6 7 8\\n> 1 3 3 **[4]** 5 6 7 8\\n> 1 3 3 4 **[5]** 6 7 8\\n> 1 3 3 4 5 **[6]** 7 8\\n> 1 3 3 4 5 6 **[7]** 8\\n> 1 3 3 4 5 6 7 **[8]**\\n>\\n> **Explanation:** Each bolded value represents the current element being checked, whereas each value between brackets is where that element should be found.\\n"
                    },
                    {
                        "username": "Edissssssson",
                        "content": "class Solution {\\n    public int[] findErrorNums(int[] nums) {\\n        int[] res=new int[2];\\n         for(int i=0; i<nums.length-1;i++){\\n             int sum1=(nums[0]+nums[i])*(i+1)/2;  //\\u5B9E\\u9645\\u7684\\n             int sum2=(1+(i+1))*(i+1)/2;            //\\u7406\\u8BBA\\u8FDE\\u7EED\\u4E0D\\u91CD\\u590D\\u65F6\\n             if(sum1>sum2){\\n                    res[0]=nums[i]-1;\\n                    res[1]=nums[i]; \\n                    break;\\n             }\\n             else if(sum1<sum2){\\n                 res[0]=nums[i-1];\\n                 res[1]=nums[i]+1;\\n                 break;\\n             }\\n         }\\n        return res;     \\n        }\\n}\\n\\n\\nanyone who can help me and why this answer is wrong for case 2?"
                    },
                    {
                        "username": "abirchatterjee552",
                        "content": "If the approach is cyclic sort then it is an easy question..\\nBut with Bitwise manipulation it is a medium one."
                    }
                ]
            },
            {
                "id": 1845754,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1845703,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1773171,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1656532,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1656494,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1656181,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1655901,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1655814,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1655396,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            },
            {
                "id": 1649783,
                "content": [
                    {
                        "username": "CoffeeCode247",
                        "content": "Why do they say `s`, just say \"One of the numbers in `NUMS`\" ... ugh...."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Math riddle"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "oreoexpo505",
                        "content": "Why is the answer to this test case\\n\\n`[2,4,3,2]`\\n\\nEqual to `[2,1]` and not `[2,5]` ? "
                    },
                    {
                        "username": "yarjuny234",
                        "content": "First sort the array,[2,2,3,4] so repeating value is 2 and missing is 1 ,so answer is [2,1] "
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "Because, as the problem states, nums \"contains all the numbers from 1 to n\". That means it starts at 1."
                    },
                    {
                        "username": "its_iterator",
                        "content": "If anybody having any doubt then ask me"
                    },
                    {
                        "username": "CharlieCoxAustin",
                        "content": "The wording of this question is so inaccurate that it is totally incorrect. The answer is something wildly different than what the question asks for. Please remove this question until the prompt is written properly."
                    },
                    {
                        "username": "__raja_",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_set<int> s;\\n        vector<int> v;\\n        int sum = 0;\\n        \\n        for(auto it : nums){\\n            if(s.find(it) != s.end()){\\n                v.push_back(it);\\n            }\\n            else{\\n                s.insert(it);\\n                sum += it;\\n            }\\n        }\\n        int t  = n*(n+1)/2;\\n        v.push_back(t-sum);\\n        return v;\\n    }\\n}; "
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "Shivgup_2000",
                        "content": "Most basic approach to solve it is, just sort and find the frequency of repeated and not present ones in array."
                    },
                    {
                        "username": "naushad_ali",
                        "content": "But not the optimal one"
                    },
                    {
                        "username": "rahul_xt",
                        "content": "this questions prompts you to think of the possible edge cases"
                    },
                    {
                        "username": "pratham2712",
                        "content": "class Solution {\\npublic:\\n    vector<int> findErrorNums(vector<int>& nums) {\\n\\n         vector<int> store;\\n        sort(nums.begin(),nums.end());\\n        \\n\\n        for(int i=1;i<=nums.size();i++){\\n            if( i ^ nums[i-1]!=0){\\n                store.push_back(i);\\n            store.push_back(nums[i-1]);\\n            break;\\n            }\\n            \\n        }\\n        sort(store.begin(),store.end());\\n        return store;\\n    }\\n};\\n\\n\\ncan anyone explain me that what is mistake in this code or in logic ????"
                    },
                    {
                        "username": "codeunderwater",
                        "content": "Please don\\'t put code in the discussion section. Go to the solutions instead."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Don\\'t sort the result, the duplicate can be larger or lesser than the missed number. ([duplicate, missing])"
                    }
                ]
            }
        ]
    },
    {
        "title": "Prefix and Suffix Search",
        "question_content": "<p>Design a special dictionary that searches the words in it by a prefix and a suffix.</p>\n\n<p>Implement the <code>WordFilter</code> class:</p>\n\n<ul>\n\t<li><code>WordFilter(string[] words)</code> Initializes the object with the <code>words</code> in the dictionary.</li>\n\t<li><code>f(string pref, string suff)</code> Returns <em>the index of the word in the dictionary,</em> which has the prefix <code>pref</code> and the suffix <code>suff</code>. If there is more than one valid index, return <strong>the largest</strong> of them. If there is no such word in the dictionary, return <code>-1</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;WordFilter&quot;, &quot;f&quot;]\n[[[&quot;apple&quot;]], [&quot;a&quot;, &quot;e&quot;]]\n<strong>Output</strong>\n[null, 0]\n<strong>Explanation</strong>\nWordFilter wordFilter = new WordFilter([&quot;apple&quot;]);\nwordFilter.f(&quot;a&quot;, &quot;e&quot;); // return 0, because the word at index 0 has prefix = &quot;a&quot; and suffix = &quot;e&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 7</code></li>\n\t<li><code>1 &lt;= pref.length, suff.length &lt;= 7</code></li>\n\t<li><code>words[i]</code>, <code>pref</code> and <code>suff</code> consist of lowercase English letters only.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to the function <code>f</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 144432,
                "title": "java-beat-95-just-small-modifications-in-implementing-trie",
                "content": "Take \"apple\" as an example, we will insert add \"apple{apple\", \"pple{apple\", \"ple{apple\", \"le{apple\", \"e{apple\", \"{apple\" into the Trie Tree. \\nIf the query is: prefix = \"app\", suffix = \"le\", we can find it by querying our trie for \\n\"le { app\".\\nWe use \\'{\\' because in ASCii Table, \\'{\\' is next to \\'z\\', so we just need to create new TrieNode[27] instead of 26. Also, compared with tradition Trie, we add the attribute weight in class TrieNode.\\n```\\nclass TrieNode {\\n    TrieNode[] children;\\n    int weight;\\n    public TrieNode() {\\n        children = new TrieNode[27]; // \\'a\\' - \\'z\\' and \\'{\\'. \\'z\\' and \\'{\\' are neighbours in ASCII table\\n        weight = 0;\\n    }\\n}\\n\\npublic class WordFilter {\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for (int weight = 0; weight < words.length; weight++) {\\n            String word = words[weight] + \"{\";\\n            for (int i = 0; i < word.length(); i++) {\\n                TrieNode cur = root;\\n                cur.weight = weight;\\n    // add \"apple{apple\", \"pple{apple\", \"ple{apple\", \"le{apple\", \"e{apple\", \"{apple\" into the Trie Tree\\n                for (int j = i; j < 2 * word.length() - 1; j++) {\\n                    int k = word.charAt(j % word.length()) - \\'a\\';\\n                    if (cur.children[k] == null)\\n                        cur.children[k] = new TrieNode();\\n                    cur = cur.children[k];\\n                    cur.weight = weight;\\n                }\\n            }\\n        }\\n    }\\n    public int f(String prefix, String suffix) {\\n        TrieNode cur = root;\\n        for (char c: (suffix + \\'{\\' + prefix).toCharArray()) {\\n            if (cur.children[c - \\'a\\'] == null) {\\n                return -1;\\n            }\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        return cur.weight;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\n    TrieNode[] children;\\n    int weight;\\n    public TrieNode() {\\n        children = new TrieNode[27]; // \\'a\\' - \\'z\\' and \\'{\\'. \\'z\\' and \\'{\\' are neighbours in ASCII table\\n        weight = 0;\\n    }\\n}\\n\\npublic class WordFilter {\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for (int weight = 0; weight < words.length; weight++) {\\n            String word = words[weight] + \"{\";\\n            for (int i = 0; i < word.length(); i++) {\\n                TrieNode cur = root;\\n                cur.weight = weight;\\n    // add \"apple{apple\", \"pple{apple\", \"ple{apple\", \"le{apple\", \"e{apple\", \"{apple\" into the Trie Tree\\n                for (int j = i; j < 2 * word.length() - 1; j++) {\\n                    int k = word.charAt(j % word.length()) - \\'a\\';\\n                    if (cur.children[k] == null)\\n                        cur.children[k] = new TrieNode();\\n                    cur = cur.children[k];\\n                    cur.weight = weight;\\n                }\\n            }\\n        }\\n    }\\n    public int f(String prefix, String suffix) {\\n        TrieNode cur = root;\\n        for (char c: (suffix + \\'{\\' + prefix).toCharArray()) {\\n            if (cur.children[c - \\'a\\'] == null) {\\n                return -1;\\n            }\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        return cur.weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110044,
                "title": "three-ways-to-solve-this-problem-in-java",
                "content": "Before solving this problem, we need to know which operation is called the most.\\n\\nIf ```f()``` is more frequently than ```WordFilter()```, use method 1. \\nIf **space complexity** is concerned, use method 2. \\nIf the input string array changes frequently, i.e., ```WordFilter()``` is more frequently than ```f()```, use method 3.\\n\\n**< Method 1 >**\\nWordFilter: Time = O(NL^2) \\nf: Time = O(1)\\nSpace = O(NL^2)\\nNote: N is the size of input array and L is the max length of input strings. \\n```\\nclass WordFilter {\\n    HashMap<String, Integer> map = new HashMap<>();\\n\\n    public WordFilter(String[] words) {\\n        for(int w = 0; w < words.length; w++){\\n            for(int i = 0; i <= 10 && i <= words[w].length(); i++){\\n                for(int j = 0; j <= 10 && j <= words[w].length(); j++){\\n                    map.put(words[w].substring(0, i) + \"#\" + words[w].substring(words[w].length()-j), w);\\n                }\\n            }\\n        }\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        return (map.containsKey(prefix + \"#\" + suffix))? map.get(prefix + \"#\" + suffix) : -1;\\n    }\\n}\\n\\n```\\n\\n**< Method 2 >**\\nWordFilter: Time = O(NL)\\nf: Time = O(N)\\nSpace = O(NL)\\n```\\nclass WordFilter {\\n    HashMap<String, List<Integer>> mapPrefix = new HashMap<>();\\n    HashMap<String, List<Integer>> mapSuffix = new HashMap<>();\\n    \\n    public WordFilter(String[] words) {\\n        \\n        for(int w = 0; w < words.length; w++){\\n            for(int i = 0; i <= 10 && i <= words[w].length(); i++){\\n                String s = words[w].substring(0, i);\\n                if(!mapPrefix.containsKey(s)) mapPrefix.put(s, new ArrayList<>());\\n                mapPrefix.get(s).add(w);\\n            }\\n            for(int i = 0; i <= 10 && i <= words[w].length(); i++){\\n                String s = words[w].substring(words[w].length() - i);\\n                if(!mapSuffix.containsKey(s)) mapSuffix.put(s, new ArrayList<>());\\n                mapSuffix.get(s).add(w);\\n            }\\n        }\\n\\n    public int f(String prefix, String suffix) {\\n        \\n        if(!mapPrefix.containsKey(prefix) || !mapSuffix.containsKey(suffix)) return -1;\\n        List<Integer> p = mapPrefix.get(prefix);\\n        List<Integer> s = mapSuffix.get(suffix);\\n        int i = p.size()-1, j = s.size()-1;\\n        while(i >= 0 && j >= 0){\\n            if(p.get(i) < s.get(j)) j--;\\n            else if(p.get(i) > s.get(j)) i--;\\n            else return p.get(i);\\n        }\\n        return -1;\\n```\\n\\n**< Method 3 >** \\nWordFilter: Time = O(1)\\nf: Time = O(NL)\\nSpace = O(1)\\n\\n```\\nclass WordFilter {\\n    String[] input;\\n    public WordFilter(String[] words) {\\n        input = words;\\n    }\\n    public int f(String prefix, String suffix) {\\n        for(int i = input.length-1; i >= 0; i--){\\n            if(input[i].startsWith(prefix) && input[i].endsWith(suffix)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n\\nNote: The format of input data:\\n**First line**: ```[\"WordFilter\", \"f\", ..., \"f\"]```, depends on how many time ```f()``` is called.\\n**Second line**: First item is the input string array, following by the pairs of ```[prefix, suffix]```.\\nex:\\n```\\n[\"WordFilter\",\"f\", \"f\"]\\n[[[\"apple\"]],[\"a\",\"e\"], [\"ap\",\"ple\"]]\\n```",
                "solutionTags": [],
                "code": "```f()```\n```WordFilter()```\n```WordFilter()```\n```f()```\n```\\nclass WordFilter {\\n    HashMap<String, Integer> map = new HashMap<>();\\n\\n    public WordFilter(String[] words) {\\n        for(int w = 0; w < words.length; w++){\\n            for(int i = 0; i <= 10 && i <= words[w].length(); i++){\\n                for(int j = 0; j <= 10 && j <= words[w].length(); j++){\\n                    map.put(words[w].substring(0, i) + \"#\" + words[w].substring(words[w].length()-j), w);\\n                }\\n            }\\n        }\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        return (map.containsKey(prefix + \"#\" + suffix))? map.get(prefix + \"#\" + suffix) : -1;\\n    }\\n}\\n\\n```\n```\\nclass WordFilter {\\n    HashMap<String, List<Integer>> mapPrefix = new HashMap<>();\\n    HashMap<String, List<Integer>> mapSuffix = new HashMap<>();\\n    \\n    public WordFilter(String[] words) {\\n        \\n        for(int w = 0; w < words.length; w++){\\n            for(int i = 0; i <= 10 && i <= words[w].length(); i++){\\n                String s = words[w].substring(0, i);\\n                if(!mapPrefix.containsKey(s)) mapPrefix.put(s, new ArrayList<>());\\n                mapPrefix.get(s).add(w);\\n            }\\n            for(int i = 0; i <= 10 && i <= words[w].length(); i++){\\n                String s = words[w].substring(words[w].length() - i);\\n                if(!mapSuffix.containsKey(s)) mapSuffix.put(s, new ArrayList<>());\\n                mapSuffix.get(s).add(w);\\n            }\\n        }\\n\\n    public int f(String prefix, String suffix) {\\n        \\n        if(!mapPrefix.containsKey(prefix) || !mapSuffix.containsKey(suffix)) return -1;\\n        List<Integer> p = mapPrefix.get(prefix);\\n        List<Integer> s = mapSuffix.get(suffix);\\n        int i = p.size()-1, j = s.size()-1;\\n        while(i >= 0 && j >= 0){\\n            if(p.get(i) < s.get(j)) j--;\\n            else if(p.get(i) > s.get(j)) i--;\\n            else return p.get(i);\\n        }\\n        return -1;\\n```\n```\\nclass WordFilter {\\n    String[] input;\\n    public WordFilter(String[] words) {\\n        input = words;\\n    }\\n    public int f(String prefix, String suffix) {\\n        for(int i = input.length-1; i >= 0; i--){\\n            if(input[i].startsWith(prefix) && input[i].endsWith(suffix)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```[\"WordFilter\", \"f\", ..., \"f\"]```\n```f()```\n```[prefix, suffix]```\n```\\n[\"WordFilter\",\"f\", \"f\"]\\n[[[\"apple\"]],[\"a\",\"e\"], [\"ap\",\"ple\"]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185249,
                "title": "c-no-trie-a-hashmap-soln",
                "content": "```\\nclass WordFilter {\\n   private:\\n    unordered_map<string, int> hashMap;\\n\\n   public:\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            int wordSize = word.size();\\n            for (int j = 1; j <= wordSize; j++) {\\n                string p = word.substr(0, j);\\n                for (int k = 0; k < wordSize; k++) {\\n                    string s = word.substr(k, wordSize);\\n                    hashMap[p + \"|\" + s] = i + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    int f(string prefix, string suffix) {\\n        string s = prefix + \"|\" + suffix;\\n        return hashMap[s] - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\n   private:\\n    unordered_map<string, int> hashMap;\\n\\n   public:\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for (int i = 0; i < n; i++) {\\n            string word = words[i];\\n            int wordSize = word.size();\\n            for (int j = 1; j <= wordSize; j++) {\\n                string p = word.substr(0, j);\\n                for (int k = 0; k < wordSize; k++) {\\n                    string s = word.substr(k, wordSize);\\n                    hashMap[p + \"|\" + s] = i + 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    int f(string prefix, string suffix) {\\n        string s = prefix + \"|\" + suffix;\\n        return hashMap[s] - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110053,
                "title": "python-few-ways-to-do-it-with-explanations-u0001f389",
                "content": "#### Method 1\\n\\nStore all the words corresponding to its prefixes and suffixes. For example, for two words `bat` and `bar`, the `prefixes` and `suffixes` dictionary will look as such:\\n\\n```\\n# prefixes\\n{\\n  \\'\\': {\\'bat\\', \\'bar\\'},\\n  \\'b\\': {\\'bat\\', \\'bar\\'},\\n  \\'ba\\': {\\'bat\\', \\'bar\\'},\\n  \\'bar\\': {\\'bar\\'},\\n  \\'bat\\': {\\'bat\\'},\\n}\\n\\n# suffixes\\n{\\n  \\'t\\': {\\'bat\\'},\\n  \\'at\\': {\\'bat\\'},\\n  \\'bat\\': {\\'bat\\'},\\n  \\'r\\': {\\'bar\\'},\\n  \\'ar\\': {\\'bar\\'},\\n  \\'bar\\': {\\'bar\\'},\\n}\\n```\\n\\n`f(\\'b\\', \\'at\\')` => set intersection of `{\\'bat\\', \\'bar\\'}` and `{\\'bat\\'}` => `\\'bat\\'`.\\n\\nYou can use a Trie to make it more space efficient as well.\\n\\n```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        from collections import defaultdict\\n        self.prefixes = defaultdict(set)\\n        self.suffixes = defaultdict(set)\\n        self.weights = {}\\n        for index, word in enumerate(words):\\n            prefix, suffix = \\'\\', \\'\\'\\n            for char in [\\'\\'] + list(word):\\n                prefix += char\\n                self.prefixes[prefix].add(word)\\n            for char in [\\'\\'] + list(word[::-1]):\\n                suffix += char\\n                self.suffixes[suffix[::-1]].add(word)\\n            self.weights[word] = index\\n\\n    def f(self, prefix, suffix):\\n        weight = -1\\n        for word in self.prefixes[prefix] & self.suffixes[suffix]:\\n            if self.weights[word] > weight:\\n                weight = self.weights[word]\\n        return weight\\n```\\n\\n#### Method 2\\n\\nDirectly save the prefix and suffix combinations for a word, where the value is the weight. For a word such as `\\'bat\\'`, store all the prefix + suffix combinations in a dictionary, delimited by a non-alphabet character such as `\\'.\\'`. The delimiter is important so as to distinguish between prefix/suffix pairs that would have been concatenated to give the same result if without - `ab` + `c` and `a` + `bc` would both give `abc` if there wasn\\'t a delimiter present.\\n\\n```\\n{\\n  \\'.\\': 0,\\n  \\'.t\\': 0,\\n  \\'.at\\': 0,\\n  \\'.bat\\': 0,\\n  \\'b.\\': 0,\\n  \\'b.t\\': 0,\\n  \\'b.at\\': 0,\\n  \\'b.bat\\': 0,\\n  \\'ba.\\': 0,\\n  \\'ba.t\\': 0,\\n  \\'ba.at\\': 0,\\n  \\'ba.bat\\': 0,\\n  \\'bat.\\': 0,\\n  \\'bat.t\\': 0,\\n  \\'bat.at\\': 0,\\n  \\'bat.bat\\': 0,\\n}\\n```\\n\\nLater occurrences of the prefix + suffix combi will have its weight overwritten, so we can simply look up the dictionary and return the answer.\\n\\n```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        self.inputs = {}\\n        for index, word in enumerate(words):\\n            prefix = \\'\\'\\n            for char in [\\'\\'] + list(word):\\n                prefix += char\\n                suffix = \\'\\'\\n                for char in [\\'\\'] + list(word[::-1]):\\n                    suffix += char\\n                    self.inputs[prefix + \\'.\\' + suffix[::-1]] = index\\n\\n    def f(self, prefix, suffix):\\n        return self.inputs.get(prefix + \\'.\\' + suffix, -1)\\n```\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**",
                "solutionTags": [],
                "code": "```\\n# prefixes\\n{\\n  \\'\\': {\\'bat\\', \\'bar\\'},\\n  \\'b\\': {\\'bat\\', \\'bar\\'},\\n  \\'ba\\': {\\'bat\\', \\'bar\\'},\\n  \\'bar\\': {\\'bar\\'},\\n  \\'bat\\': {\\'bat\\'},\\n}\\n\\n# suffixes\\n{\\n  \\'t\\': {\\'bat\\'},\\n  \\'at\\': {\\'bat\\'},\\n  \\'bat\\': {\\'bat\\'},\\n  \\'r\\': {\\'bar\\'},\\n  \\'ar\\': {\\'bar\\'},\\n  \\'bar\\': {\\'bar\\'},\\n}\\n```\n```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        from collections import defaultdict\\n        self.prefixes = defaultdict(set)\\n        self.suffixes = defaultdict(set)\\n        self.weights = {}\\n        for index, word in enumerate(words):\\n            prefix, suffix = \\'\\', \\'\\'\\n            for char in [\\'\\'] + list(word):\\n                prefix += char\\n                self.prefixes[prefix].add(word)\\n            for char in [\\'\\'] + list(word[::-1]):\\n                suffix += char\\n                self.suffixes[suffix[::-1]].add(word)\\n            self.weights[word] = index\\n\\n    def f(self, prefix, suffix):\\n        weight = -1\\n        for word in self.prefixes[prefix] & self.suffixes[suffix]:\\n            if self.weights[word] > weight:\\n                weight = self.weights[word]\\n        return weight\\n```\n```\\n{\\n  \\'.\\': 0,\\n  \\'.t\\': 0,\\n  \\'.at\\': 0,\\n  \\'.bat\\': 0,\\n  \\'b.\\': 0,\\n  \\'b.t\\': 0,\\n  \\'b.at\\': 0,\\n  \\'b.bat\\': 0,\\n  \\'ba.\\': 0,\\n  \\'ba.t\\': 0,\\n  \\'ba.at\\': 0,\\n  \\'ba.bat\\': 0,\\n  \\'bat.\\': 0,\\n  \\'bat.t\\': 0,\\n  \\'bat.at\\': 0,\\n  \\'bat.bat\\': 0,\\n}\\n```\n```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        self.inputs = {}\\n        for index, word in enumerate(words):\\n            prefix = \\'\\'\\n            for char in [\\'\\'] + list(word):\\n                prefix += char\\n                suffix = \\'\\'\\n                for char in [\\'\\'] + list(word[::-1]):\\n                    suffix += char\\n                    self.inputs[prefix + \\'.\\' + suffix[::-1]] = index\\n\\n    def f(self, prefix, suffix):\\n        return self.inputs.get(prefix + \\'.\\' + suffix, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165519,
                "title": "c-use-hashmap-simple-solution-with-comments-dlc-june-day-18",
                "content": "**Please upvote if it helps \\uD83D\\uDE0A\\u2764\\uFE0F**\\n\\n**Time Complexity : O(NxW^2)**\\n**Space Complexity : O(NxW^2)**\\n*N: Number of word in words \\nW: Size of a word*\\n\\n**Code:**\\n```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> mp; //stores preffix and suffix sequence in it\\n    \\n    WordFilter(vector<string>& words) \\n    {\\n        int n = words.size();\\n        \\n        for(int i=0; i<n; i++) //cover each word in words\\n        {\\n            string word = words[i]; \\n            int wordsize = word.size();\\n            \\n            //storing all possible sequence of prefix and suffix of a word in the hashmap\\n            for(int j=1; j<=wordsize; j++) //for preffix \\n            {\\n                string pre = word.substr(0,j);\\n                \\n                for(int k=0; k<wordsize; k++) //for suffix\\n                {\\n                    string suff = word.substr(k, wordsize);\\n                    mp[pre + \"|\" + suff] = i+1; //set index i+1 for all possible sequence of a word\\n                    //we set i+1 to handle i=0 because by-default map initialized with 0 \\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) \\n    {\\n        string s = prefix + \"|\" + suffix;\\n        return mp[s]-1; //if sequence found in hashmap we return its index\\n    }\\n};\\n```\\n**For Better Understanding:**\\n***Example-1:***\\n![image](https://assets.leetcode.com/users/images/02d78a83-ff78-4370-be72-297c45a20971_1655546394.924349.jpeg)\\n\\n**Please upvote if it helps \\uD83D\\uDE0A\\u2764\\uFE0F**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> mp; //stores preffix and suffix sequence in it\\n    \\n    WordFilter(vector<string>& words) \\n    {\\n        int n = words.size();\\n        \\n        for(int i=0; i<n; i++) //cover each word in words\\n        {\\n            string word = words[i]; \\n            int wordsize = word.size();\\n            \\n            //storing all possible sequence of prefix and suffix of a word in the hashmap\\n            for(int j=1; j<=wordsize; j++) //for preffix \\n            {\\n                string pre = word.substr(0,j);\\n                \\n                for(int k=0; k<wordsize; k++) //for suffix\\n                {\\n                    string suff = word.substr(k, wordsize);\\n                    mp[pre + \"|\" + suff] = i+1; //set index i+1 for all possible sequence of a word\\n                    //we set i+1 to handle i=0 because by-default map initialized with 0 \\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) \\n    {\\n        string s = prefix + \"|\" + suffix;\\n        return mp[s]-1; //if sequence found in hashmap we return its index\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185171,
                "title": "python-two-solutions-trie-and-bruteforce-explained",
                "content": "#### Solution 1\\n Let `n` be number of words, `L` be maximum length of word. One of the cool ways to solve this problem is the following: imagine, we have word `apple`, then what we need to find is substring `suffix + # + prefix` in string `apple#apple`. Now, quick way to find substring is for example create Trie with all suffixes of `apple#apple`, which include `#`.\\n \\n #### Complexity\\n It is `O(nL^2)` time and space for `init`: for each word we need `O(L^2)` processing time. For `f` we need `O(L)` time and `O(1)` space, because we just traverse through tree. So, final complexity is `O(nL^2 + QL)`, where `Q` is number of queries.\\n \\n\\n#### Code\\n```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.index = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word, index): #None\\n        root = self.root\\n        root.index = index\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n            root.index = index\\n        \\n    def startsWith(self, word):\\n        root = self.root\\n        for symbol in word:\\n            if symbol not in root.children:\\n                return -1\\n            root = root.children[symbol]\\n        return root.index  \\n\\n\\nclass WordFilter:\\n    def __init__(self, words):\\n        self.trie = Trie()\\n        self.words = {}\\n        \\n        for index, word in enumerate(words):\\n            long = word + \"#\" + word\\n            for i in range(len(word)):\\n                self.trie.insert(long[i:], index)\\n                \\n    def f(self, prefix, suffix):\\n        return self.trie.startsWith(suffix + \"#\" + prefix)\\n```\\n\\n#### Solution 2\\nFinally, there is again solution with `O(nL^3)` time complexity, but without Tries at all: we just generate for each word all `O(L^2)` possible prefix/suffix pairs and put them into dictionary. It is working the best in practice, even though complexity is higher. This is because `L` is quite small and trie is quite heavy data structure with all connections, whereas here we keep only strings.\\n\\n#### Complexity\\nTime is `O(nL^3 + QL)`, space is `O(nL^3)`.\\n\\n#### Code\\n```python\\nclass WordFilter:\\n    def __init__(self, words):\\n        self.d = {}\\n        for i, word in enumerate(words):\\n            for p, s in product(range(len(word) + 1), repeat=2):\\n                self.d[word[:p], word[s:]] = i\\n\\n    def f(self, prefix, suffix):\\n        return self.d.get((prefix, suffix), -1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.index = 0\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n\\n    def insert(self, word, index): #None\\n        root = self.root\\n        root.index = index\\n        for symbol in word:\\n            root = root.children.setdefault(symbol, TrieNode())\\n            root.index = index\\n        \\n    def startsWith(self, word):\\n        root = self.root\\n        for symbol in word:\\n            if symbol not in root.children:\\n                return -1\\n            root = root.children[symbol]\\n        return root.index  \\n\\n\\nclass WordFilter:\\n    def __init__(self, words):\\n        self.trie = Trie()\\n        self.words = {}\\n        \\n        for index, word in enumerate(words):\\n            long = word + \"#\" + word\\n            for i in range(len(word)):\\n                self.trie.insert(long[i:], index)\\n                \\n    def f(self, prefix, suffix):\\n        return self.trie.startsWith(suffix + \"#\" + prefix)\\n```\n```python\\nclass WordFilter:\\n    def __init__(self, words):\\n        self.d = {}\\n        for i, word in enumerate(words):\\n            for p, s in product(range(len(word) + 1), repeat=2):\\n                self.d[word[:p], word[s:]] = i\\n\\n    def f(self, prefix, suffix):\\n        return self.d.get((prefix, suffix), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483341,
                "title": "short-python",
                "content": "Build a master string `W` and let Python\\'s string searching do all the work. For example for `words = [\"banana\", \"apple\"]` I build `W = \"apple=apple banana=banana\"`. Then for example for prefix `\"ap\"` and suffix `\"le\"` I make Python find the string `\"le=ap\"` in `W`. And then I make it count the number of `\"=\"` starting at that position, which gives me weight+1, so I just subtract 1.\\n```\\nclass WordFilter:\\n    def __init__(self, words):\\n        W = \\' \\'.join(w + \\'=\\' + w for w in words[::-1])\\n        self.f = lambda p, s: W.count(\\'=\\', W.find(s + \\'=\\' + p)) - 1\\n```\\nIn Python 3 it gets accepted, in Python 2 it\\'s too slow.",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n    def __init__(self, words):\\n        W = \\' \\'.join(w + \\'=\\' + w for w in words[::-1])\\n        self.f = lambda p, s: W.count(\\'=\\', W.find(s + \\'=\\' + p)) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110045,
                "title": "c-solution-using-two-trie-time-memory-efficient",
                "content": "This is easy to understand.\\n\\n```\\nstruct Trie {\\n    vector<int> words; // index of words\\n    vector<Trie *> children;\\n    Trie() {\\n        children = vector<Trie *>(26, nullptr);\\n    }\\n    // Thanks to @huahualeetcode for adding this in case of memory leak\\n    ~Trie() {\\n        for (int i = 0; i < 26; i++) {\\n            if (children[i]) {\\n                delete children[i];\\n            }\\n        }\\n    }\\n    \\n    void add(const string &word, size_t begin, int index) {\\n        words.push_back(index);\\n        if (begin < word.length()) {\\n            if (!children[word[begin] - 'a']) {\\n                children[word[begin] - 'a'] = new Trie();\\n            }\\n            children[word[begin] - 'a']->add(word, begin + 1, index);\\n        }\\n    }\\n    \\n    vector<int> find(const string &prefix, size_t begin) {\\n        if (begin == prefix.length()) {\\n            return words;\\n        } else {\\n            if (!children[prefix[begin] - 'a']) {\\n                return {};\\n            } else {\\n                return children[prefix[begin] - 'a']->find(prefix, begin + 1);\\n            }\\n        }\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    WordFilter(vector<string> words) {\\n        forwardTrie = new Trie();\\n        backwardTrie = new Trie();\\n        for (int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            forwardTrie->add(word, 0, i);\\n            reverse(word.begin(), word.end());\\n            backwardTrie->add(word, 0, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        auto forwardMatch = forwardTrie->find(prefix, 0);\\n        reverse(suffix.begin(), suffix.end());\\n        auto backwardMatch = backwardTrie->find(suffix, 0);\\n        // search from the back\\n        auto fIter = forwardMatch.rbegin(), bIter = backwardMatch.rbegin();\\n        while (fIter != forwardMatch.rend() && bIter != backwardMatch.rend()) {\\n            if (*fIter == *bIter) {\\n                return *fIter;\\n            } else if (*fIter > *bIter) {\\n                fIter ++;\\n            } else {\\n                bIter ++;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\nprivate:\\n    Trie *forwardTrie, *backwardTrie;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Trie {\\n    vector<int> words; // index of words\\n    vector<Trie *> children;\\n    Trie() {\\n        children = vector<Trie *>(26, nullptr);\\n    }\\n    // Thanks to @huahualeetcode for adding this in case of memory leak\\n    ~Trie() {\\n        for (int i = 0; i < 26; i++) {\\n            if (children[i]) {\\n                delete children[i];\\n            }\\n        }\\n    }\\n    \\n    void add(const string &word, size_t begin, int index) {\\n        words.push_back(index);\\n        if (begin < word.length()) {\\n            if (!children[word[begin] - 'a']) {\\n                children[word[begin] - 'a'] = new Trie();\\n            }\\n            children[word[begin] - 'a']->add(word, begin + 1, index);\\n        }\\n    }\\n    \\n    vector<int> find(const string &prefix, size_t begin) {\\n        if (begin == prefix.length()) {\\n            return words;\\n        } else {\\n            if (!children[prefix[begin] - 'a']) {\\n                return {};\\n            } else {\\n                return children[prefix[begin] - 'a']->find(prefix, begin + 1);\\n            }\\n        }\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    WordFilter(vector<string> words) {\\n        forwardTrie = new Trie();\\n        backwardTrie = new Trie();\\n        for (int i = 0; i < words.size(); i++) {\\n            string word = words[i];\\n            forwardTrie->add(word, 0, i);\\n            reverse(word.begin(), word.end());\\n            backwardTrie->add(word, 0, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        auto forwardMatch = forwardTrie->find(prefix, 0);\\n        reverse(suffix.begin(), suffix.end());\\n        auto backwardMatch = backwardTrie->find(suffix, 0);\\n        // search from the back\\n        auto fIter = forwardMatch.rbegin(), bIter = backwardMatch.rbegin();\\n        while (fIter != forwardMatch.rend() && bIter != backwardMatch.rend()) {\\n            if (*fIter == *bIter) {\\n                return *fIter;\\n            } else if (*fIter > *bIter) {\\n                fIter ++;\\n            } else {\\n                bIter ++;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\nprivate:\\n    Trie *forwardTrie, *backwardTrie;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320712,
                "title": "different-python-solutions-with-thinking-process",
                "content": "Please see and vote for my solutions for\\n[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/320224/Simple-Python-solution)\\n[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/409075/standard-python-prefix-tree-solution)\\n[1032. Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/320837/Standard-Python-Trie-Solution)\\n[211. Add and Search Word - Data structure design](https://leetcode.com/problems/add-and-search-word-data-structure-design/discuss/319361/Simple-Python-solution)\\n[676. Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/320197/Simple-Python-solution)\\n[677. Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/320237/Simple-Python-solution)\\n[745. Prefix and Suffix Search](https://leetcode.com/problems/prefix-and-suffix-search/discuss/320712/Different-Python-solutions-with-thinking-process)\\n[425. Word Squares](https://leetcode.com/problems/word-squares/discuss/320916/Easily-implemented-Python-solution%3A-Backtrack-%2B-Trie)\\n[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/discuss/322444/Python-solutions%3A-top-down-DP-Trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/319071/Standard-Python-solution-with-Trie-%2B-Backtrack)\\n[336. Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/316960/Different-Python-solutions%3A-brute-force-dictionary-Trie)\\n\\nMethod 1: create two Tries, one for prefix search, another one for suffix search, then find the maximal common weight\\nImplementation 1: (588 ms, Beat 40%)\\nevery TrieNode saves all weights with current prefix\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.weights = []\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, i):\\n        node = self.root\\n        node.weights.append(i)\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n            node.weights.append(i)\\n    \\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return []\\n            node = node.children[char]\\n        return node.weights\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.prefix, self.suffix = Trie(), Trie()\\n        i, n = 0, len(words)\\n        while i < n:\\n            w = words[i]\\n            self.prefix.insert(w, i)\\n            self.suffix.insert(w[::-1], i)\\n            i += 1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        pre = self.prefix.search(prefix)\\n        suf = self.suffix.search(suffix[::-1])\\n        i, j = len(pre) - 1, len(suf) - 1\\n        while i >= 0 and j >= 0:\\n            if pre[i] == suf[j]:\\n                return pre[i]\\n            elif pre[i] < suf[j]:\\n                j -= 1\\n            else:\\n                i -= 1\\n        return -1\\n```\\nImplementation 2: (1944 ms, Beat 6%)\\nevery TrieNode saves the maximal weight of same words, -1 mean isEnd==False\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.weight = -1\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, i):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.weight = i\\n    \\n    def all_weights(self, prefix):\\n        def dfs(node):\\n            if node.weight != -1:\\n                wgts.add(node.weight)\\n            for char in node.children:\\n                dfs(node.children[char])\\n                \\n        wgts = set()\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return wgts\\n            node = node.children[char]\\n        dfs(node)\\n        return wgts\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.prefix, self.suffix = Trie(), Trie()\\n        i, n = 0, len(words)\\n        while i < n:\\n            self.prefix.insert(words[i], i)\\n            self.suffix.insert(words[i][::-1], i)\\n            i += 1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        pre = self.prefix.all_weights(prefix)\\n        suf = self.suffix.all_weights(suffix[::-1])\\n        l_pre, l_suf = len(pre), len(suf)\\n        max_wgt = -1\\n        if l_pre < l_suf:\\n            for wgt in pre:\\n                if wgt in suf:\\n                    max_wgt = max(max_wgt, wgt)\\n        else:\\n            for wgt in suf:\\n                if wgt in pre:\\n                    max_wgt = max(max_wgt, wgt)\\n        return max_wgt\\n```\\n\\nMethod 2: create a Trie to search suffix + \\'#\\' + prefix (820 ms, Beat 22%)\\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.weight = -1\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, i):\\n\\t    # node.weight can be overwritten when a larger one is inserted\\n        node = self.root\\n        node.weight = i\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n            node.weight = i\\n    \\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return -1\\n            node = node.children[char]\\n        return node.weight\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        i, n = 0, len(words)\\n        while i < n:\\n            l = len(words[i])\\n            for j in range(l + 1):\\n                self.trie.insert(words[i][j:l] + \\'#\\' + words[i], i)\\n            i += 1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.trie.search(suffix + \\'#\\' + prefix)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.weights = []\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, i):\\n        node = self.root\\n        node.weights.append(i)\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n            node.weights.append(i)\\n    \\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return []\\n            node = node.children[char]\\n        return node.weights\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.prefix, self.suffix = Trie(), Trie()\\n        i, n = 0, len(words)\\n        while i < n:\\n            w = words[i]\\n            self.prefix.insert(w, i)\\n            self.suffix.insert(w[::-1], i)\\n            i += 1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        pre = self.prefix.search(prefix)\\n        suf = self.suffix.search(suffix[::-1])\\n        i, j = len(pre) - 1, len(suf) - 1\\n        while i >= 0 and j >= 0:\\n            if pre[i] == suf[j]:\\n                return pre[i]\\n            elif pre[i] < suf[j]:\\n                j -= 1\\n            else:\\n                i -= 1\\n        return -1\\n```\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.weight = -1\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, i):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n        node.weight = i\\n    \\n    def all_weights(self, prefix):\\n        def dfs(node):\\n            if node.weight != -1:\\n                wgts.add(node.weight)\\n            for char in node.children:\\n                dfs(node.children[char])\\n                \\n        wgts = set()\\n        node = self.root\\n        for char in prefix:\\n            if char not in node.children:\\n                return wgts\\n            node = node.children[char]\\n        dfs(node)\\n        return wgts\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.prefix, self.suffix = Trie(), Trie()\\n        i, n = 0, len(words)\\n        while i < n:\\n            self.prefix.insert(words[i], i)\\n            self.suffix.insert(words[i][::-1], i)\\n            i += 1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        pre = self.prefix.all_weights(prefix)\\n        suf = self.suffix.all_weights(suffix[::-1])\\n        l_pre, l_suf = len(pre), len(suf)\\n        max_wgt = -1\\n        if l_pre < l_suf:\\n            for wgt in pre:\\n                if wgt in suf:\\n                    max_wgt = max(max_wgt, wgt)\\n        else:\\n            for wgt in suf:\\n                if wgt in pre:\\n                    max_wgt = max(max_wgt, wgt)\\n        return max_wgt\\n```\n```\\nclass TrieNode():\\n    def __init__(self):\\n        self.children = {}\\n        self.weight = -1\\n\\nclass Trie():\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word, i):\\n\\t    # node.weight can be overwritten when a larger one is inserted\\n        node = self.root\\n        node.weight = i\\n        for char in word:\\n            if char not in node.children:\\n                node.children[char] = TrieNode()\\n            node = node.children[char]\\n            node.weight = i\\n    \\n    def search(self, word):\\n        node = self.root\\n        for char in word:\\n            if char not in node.children:\\n                return -1\\n            node = node.children[char]\\n        return node.weight\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.trie = Trie()\\n        i, n = 0, len(words)\\n        while i < n:\\n            l = len(words[i])\\n            for j in range(l + 1):\\n                self.trie.insert(words[i][j:l] + \\'#\\' + words[i], i)\\n            i += 1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.trie.search(suffix + \\'#\\' + prefix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185649,
                "title": "prefix-and-suffix-search-js-python-java-c-double-trie-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n***Update 6/18/2022***: _This solution has been updated to account for duplicate words._\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhenever we have to deal with searching for data using a prefix or a suffix, this naturally points to a **trie** solution. A trie is a type of data structure that uses a branching tree format where the nodes represent segments of data (usually characters) to make searching by prefix faster and easier.\\n\\nThe difficulty in this case is that we\\'re searching by both prefix and suffix, so we can create two trie structures, one for prefixes and one for suffixes (**pTrie, sTrie**). Then we can iterate through **words** and **insert()** each word into the two tries.\\n\\n(_Update: we should iterate backwards through **words** and use a **set** to prevent duplicate word entries, as only the largest index is needed._)\\n\\nTo do so, we\\'ll iterate through the characters of the word, forwards for **pTrie** and backwards for **sTrie**, and move from node to node as the word moves from character to character. At each node, we\\'ll update the **vals** array with the current **index**. The **vals** array represents the indices of all the words that run through the current node. Since we\\'re iterating through **words** in **index** order, each node\\'s **vals** array will be sorted in **index** order, as well.\\n\\nFor our find method, **f()**, we\\'ll be doing the same in reverse. We\\'ll navigate separately through **pTrie** with **pre** and **sTrie** with **suf** to find the **vals** arrays containing the indices of each word that matches those prefixes and suffixes. If at any point a particular trie does not have the next character, we can **return -1**.\\n\\nOnce we\\'ve successfully obtained the two **vals** arrays (**pVals, sVals**), we can cross-reference their contents, starting at the end, and look for the largest index that occurs in both. If we find one, we can **return** it, otherwise we can **return -1**.\\n\\n(_Update: Since we iterated through **words** backwards on insertion, we should start at the beginning of the **vals** arrays, rather than the end, to obtain the largest common index._)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **476ms / 68.1MB** (beats 100% / 80%).\\n```javascript\\nclass WordFilter {\\n    constructor(words) {\\n        this.pTrie = new Array(27)\\n        this.sTrie = new Array(27)\\n        let wordSet = new Set()\\n        for (let index = words.length - 1; ~index; index--) {\\n            let word = words[index], wlen = word.length\\n            if (wordSet.has(word))\\n                continue;\\n            wordSet.add(word)\\n            this.insert(word, index, this.pTrie, 0, wlen, 1)\\n            this.insert(word, index, this.sTrie, wlen-1, -1, -1)\\n        }\\n    }\\n    \\n    insert(word, index, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) trie[c] = new Array(27)\\n            trie = trie[c]\\n            if (!trie[26]) trie[26] = []\\n            trie[26].push(index)\\n        }\\n    }\\n    \\n    retrieve(word, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) return []\\n            trie = trie[c]\\n        }\\n        return trie[26]\\n    }\\n    \\n    f(pre, suf) {\\n        let pVals = this.retrieve(pre, this.pTrie, 0, pre.length, 1),\\n            sVals = this.retrieve(suf, this.sTrie, suf.length-1, -1, -1),\\n            svix = 0, pvix = 0\\n        while (svix < sVals.length && pvix < pVals.length) {\\n            let sVal = sVals[svix], pVal = pVals[pvix]\\n            if (sVal === pVal) return sVal\\n            sVal > pVal ? svix++ : pvix++\\n        }\\n        return -1\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **895ms / 25.8MB** (beats 96% / 96%).\\n```python\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.pTrie = [None] * 27\\n        self.sTrie = [None] * 27\\n        self.wordSet = set()\\n        for index in range(len(words)-1, -1, -1):\\n            word = words[index]\\n            if word not in self.wordSet:\\n                self.wordSet.add(word)\\n                self.insert(word, index, self.pTrie)\\n                self.insert(word[::-1], index, self.sTrie)\\n            \\n    def insert(self, word: str, index: int, trie: dict):\\n        for c in word:\\n            cval = ord(c) - 97\\n            if not trie[cval]: trie[cval] = [None] * 27\\n            trie = trie[cval]\\n            if not trie[26]: trie[26] = []\\n            trie[26].append(index)\\n            \\n    def retrieve(self, word: str, trie: dict) -> list:\\n        for c in word:\\n            cval = ord(c) - 97\\n            trie = trie[cval]\\n            if not trie: return []\\n        return trie[26]\\n\\n    def f(self, pre: str, suf: str) -> int:\\n        pVals = self.retrieve(pre, self.pTrie)\\n        sVals = self.retrieve(suf[::-1], self.sTrie)\\n        svix, pvix = 0, 0\\n        while svix < len(sVals) and pvix < len(pVals):\\n            sVal, pVal = sVals[svix], pVals[pvix]\\n            if sVal == pVal: return sVal\\n            if sVal > pVal: svix += 1\\n            else: pvix += 1\\n        return -1\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **182ms / 51.6MB** (beats 99% / 100%).\\n```java\\nclass TrieNode {\\n    public TrieNode[] children = new TrieNode[26];\\n    public List<Integer> vals = new ArrayList<>();\\n}\\n\\nclass WordFilter {\\n    private TrieNode pTrie = new TrieNode();\\n    private TrieNode sTrie = new TrieNode();\\n    \\n    public WordFilter(String[] words) {\\n        Set<String> wordSet = new HashSet<>();\\n        for (int index = words.length - 1; index > -1; index--) {\\n            if (wordSet.contains(words[index]))\\n                continue;\\n            wordSet.add(words[index]);\\n            char[] word = words[index].toCharArray();\\n            int wlen = word.length;\\n            insert(word, index, pTrie, 0, wlen, 1);\\n            insert(word, index, sTrie, wlen-1, -1, -1);\\n        }\\n    }\\n            \\n    private void insert(char[] word, int index, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            int c = word[i] - \\'a\\';\\n            if (trie.children[c] == null)\\n                trie.children[c] = new TrieNode();\\n            trie = trie.children[c];\\n            trie.vals.add(index);\\n        }\\n    }\\n    \\n    private List<Integer> retrieve(char[] word, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            trie = trie.children[word[i]-\\'a\\'];\\n            if (trie == null) return new ArrayList<>();\\n        }\\n        return trie.vals;\\n    }\\n    \\n    public int f(String pre, String suf) {\\n        List<Integer> pVals = retrieve(pre.toCharArray(), pTrie, 0, pre.length(), 1);\\n        List<Integer> sVals = retrieve(suf.toCharArray(), sTrie, suf.length()-1, -1, -1);\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals.size() && pvix < pVals.size()) {\\n            int sVal = sVals.get(svix), pVal = pVals.get(pvix);\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **366ms / 100.8MB** (beats 97% / 98%).\\n```c++\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    vector<int> vals;\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode *pTrie, *sTrie;\\n    \\npublic:\\n    WordFilter(vector<string>& words) {\\n        pTrie = new TrieNode();\\n        sTrie = new TrieNode();\\n        unordered_set<string> wordSet;\\n        int n = words.size();\\n        for (int index = n - 1; ~index; index--) {\\n            string word = words[index];\\n            if (wordSet.find(word) != wordSet.end())\\n                continue;\\n            wordSet.insert(word);\\n            insert(word, index, pTrie);\\n            reverse(word.begin(), word.end());\\n            insert(word, index, sTrie);\\n        }\\n    }\\n    \\n    void insert(string word, int index, TrieNode* trie) {\\n        for (auto c : word) {\\n            if (!trie->children[c])\\n                trie->children[c] = new TrieNode();\\n            trie = trie->children[c];\\n            trie->vals.push_back(index);\\n        }\\n    }\\n    \\n    vector<int>* retrieve(string str, TrieNode* trie) {\\n        for (auto c : str) {\\n            trie = trie->children[c];\\n            if (!trie) return nullptr;\\n        }\\n        return &trie->vals;\\n    }\\n    \\n    int f(string pre, string suf) {\\n        vector<int>* pVals = retrieve(pre, pTrie);\\n        reverse(suf.begin(), suf.end());\\n        vector<int>* sVals = retrieve(suf, sTrie);\\n        if (pVals == nullptr or sVals == nullptr)\\n            return -1;\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals->size() && pvix < pVals->size()) {\\n            int sVal = (*sVals)[svix], pVal = (*pVals)[pvix];\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nclass WordFilter {\\n    constructor(words) {\\n        this.pTrie = new Array(27)\\n        this.sTrie = new Array(27)\\n        let wordSet = new Set()\\n        for (let index = words.length - 1; ~index; index--) {\\n            let word = words[index], wlen = word.length\\n            if (wordSet.has(word))\\n                continue;\\n            wordSet.add(word)\\n            this.insert(word, index, this.pTrie, 0, wlen, 1)\\n            this.insert(word, index, this.sTrie, wlen-1, -1, -1)\\n        }\\n    }\\n    \\n    insert(word, index, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) trie[c] = new Array(27)\\n            trie = trie[c]\\n            if (!trie[26]) trie[26] = []\\n            trie[26].push(index)\\n        }\\n    }\\n    \\n    retrieve(word, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) return []\\n            trie = trie[c]\\n        }\\n        return trie[26]\\n    }\\n    \\n    f(pre, suf) {\\n        let pVals = this.retrieve(pre, this.pTrie, 0, pre.length, 1),\\n            sVals = this.retrieve(suf, this.sTrie, suf.length-1, -1, -1),\\n            svix = 0, pvix = 0\\n        while (svix < sVals.length && pvix < pVals.length) {\\n            let sVal = sVals[svix], pVal = pVals[pvix]\\n            if (sVal === pVal) return sVal\\n            sVal > pVal ? svix++ : pvix++\\n        }\\n        return -1\\n    }\\n};\\n```\n```python\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.pTrie = [None] * 27\\n        self.sTrie = [None] * 27\\n        self.wordSet = set()\\n        for index in range(len(words)-1, -1, -1):\\n            word = words[index]\\n            if word not in self.wordSet:\\n                self.wordSet.add(word)\\n                self.insert(word, index, self.pTrie)\\n                self.insert(word[::-1], index, self.sTrie)\\n            \\n    def insert(self, word: str, index: int, trie: dict):\\n        for c in word:\\n            cval = ord(c) - 97\\n            if not trie[cval]: trie[cval] = [None] * 27\\n            trie = trie[cval]\\n            if not trie[26]: trie[26] = []\\n            trie[26].append(index)\\n            \\n    def retrieve(self, word: str, trie: dict) -> list:\\n        for c in word:\\n            cval = ord(c) - 97\\n            trie = trie[cval]\\n            if not trie: return []\\n        return trie[26]\\n\\n    def f(self, pre: str, suf: str) -> int:\\n        pVals = self.retrieve(pre, self.pTrie)\\n        sVals = self.retrieve(suf[::-1], self.sTrie)\\n        svix, pvix = 0, 0\\n        while svix < len(sVals) and pvix < len(pVals):\\n            sVal, pVal = sVals[svix], pVals[pvix]\\n            if sVal == pVal: return sVal\\n            if sVal > pVal: svix += 1\\n            else: pvix += 1\\n        return -1\\n```\n```java\\nclass TrieNode {\\n    public TrieNode[] children = new TrieNode[26];\\n    public List<Integer> vals = new ArrayList<>();\\n}\\n\\nclass WordFilter {\\n    private TrieNode pTrie = new TrieNode();\\n    private TrieNode sTrie = new TrieNode();\\n    \\n    public WordFilter(String[] words) {\\n        Set<String> wordSet = new HashSet<>();\\n        for (int index = words.length - 1; index > -1; index--) {\\n            if (wordSet.contains(words[index]))\\n                continue;\\n            wordSet.add(words[index]);\\n            char[] word = words[index].toCharArray();\\n            int wlen = word.length;\\n            insert(word, index, pTrie, 0, wlen, 1);\\n            insert(word, index, sTrie, wlen-1, -1, -1);\\n        }\\n    }\\n            \\n    private void insert(char[] word, int index, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            int c = word[i] - \\'a\\';\\n            if (trie.children[c] == null)\\n                trie.children[c] = new TrieNode();\\n            trie = trie.children[c];\\n            trie.vals.add(index);\\n        }\\n    }\\n    \\n    private List<Integer> retrieve(char[] word, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            trie = trie.children[word[i]-\\'a\\'];\\n            if (trie == null) return new ArrayList<>();\\n        }\\n        return trie.vals;\\n    }\\n    \\n    public int f(String pre, String suf) {\\n        List<Integer> pVals = retrieve(pre.toCharArray(), pTrie, 0, pre.length(), 1);\\n        List<Integer> sVals = retrieve(suf.toCharArray(), sTrie, suf.length()-1, -1, -1);\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals.size() && pvix < pVals.size()) {\\n            int sVal = sVals.get(svix), pVal = pVals.get(pvix);\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    vector<int> vals;\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode *pTrie, *sTrie;\\n    \\npublic:\\n    WordFilter(vector<string>& words) {\\n        pTrie = new TrieNode();\\n        sTrie = new TrieNode();\\n        unordered_set<string> wordSet;\\n        int n = words.size();\\n        for (int index = n - 1; ~index; index--) {\\n            string word = words[index];\\n            if (wordSet.find(word) != wordSet.end())\\n                continue;\\n            wordSet.insert(word);\\n            insert(word, index, pTrie);\\n            reverse(word.begin(), word.end());\\n            insert(word, index, sTrie);\\n        }\\n    }\\n    \\n    void insert(string word, int index, TrieNode* trie) {\\n        for (auto c : word) {\\n            if (!trie->children[c])\\n                trie->children[c] = new TrieNode();\\n            trie = trie->children[c];\\n            trie->vals.push_back(index);\\n        }\\n    }\\n    \\n    vector<int>* retrieve(string str, TrieNode* trie) {\\n        for (auto c : str) {\\n            trie = trie->children[c];\\n            if (!trie) return nullptr;\\n        }\\n        return &trie->vals;\\n    }\\n    \\n    int f(string pre, string suf) {\\n        vector<int>* pVals = retrieve(pre, pTrie);\\n        reverse(suf.begin(), suf.end());\\n        vector<int>* sVals = retrieve(suf, sTrie);\\n        if (pVals == nullptr or sVals == nullptr)\\n            return -1;\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals->size() && pvix < pVals->size()) {\\n            int sVal = (*sVals)[svix], pVal = (*pVals)[pvix];\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164210,
                "title": "python-easy-trie-solution",
                "content": "The Data structure more suitable in such cases is a [Trie](https://en.wikipedia.org/wiki/Trie).  Please read and understand  Trie before you move onto the solution.\\n\\nIn this approach, I will be storing all the following combinations of a word in the trie.\\n>eg: word =  **\\'leet\\'**\\n**>leet#leet\\n>eet#leet\\n>et#leet\\n>t#leet\\n>#leet**\\n>\\nAll the above combinations will be added to the **Trie**.\\n\\n<img src=\\'https://assets.leetcode.com/users/images/292c1ce5-185b-428e-ae2e-701e739a12c0_1655519535.6480691.jpeg\\' height=\"500\"/>\\n\\nNow let\\'s say you want to lookup\\n> prefix=\\'**le**\\', suffix=\\'**et**\\'\\n\\nYou would search for \\'**et#le**\\' ie `suffix + \\'#\\' + prefix` in the **Trie**. So this would match with the **\\'et#leet\\'** path.\\n\\nTaking above thoughts into consideration, below is my implementation:\\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie={}\\n        self.weight_marker=\\'$\\'\\n        w=self.weight_marker\\n        for idx, word in enumerate(words):\\n            word=word + \\'#\\'\\n            length=len(word)\\n            word+=word\\n            \\n            for i in range(length):\\n                curr=self.trie\\n                curr[w]=idx \\n                for c in word[i:]:\\n                    if c not in curr:\\n                        curr[c]={}\\n                    curr=curr[c]                    \\n                    curr[w]=idx  # update the weight of substring                        \\n            \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        curr=self.trie\\n        for c in suffix + \\'#\\' + prefix:\\n            if c not in curr:\\n                return -1\\n            curr=curr[c]\\n        \\n        return curr[self.weight_marker] \\n```\\n\\nIf `N` is the number of words, `L` is the  max length of the word and `M` is the length of the query `suffix + \\'#\\' + prefix`.\\n\\n**Time** :\\n`Constructor` - `O(N * L^2)` (Compute all the combinations of all the words), `Search` - `O(M)`\\n**Space** - `O(N * L^2)`(Store all the combinations of all the words)\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie={}\\n        self.weight_marker=\\'$\\'\\n        w=self.weight_marker\\n        for idx, word in enumerate(words):\\n            word=word + \\'#\\'\\n            length=len(word)\\n            word+=word\\n            \\n            for i in range(length):\\n                curr=self.trie\\n                curr[w]=idx \\n                for c in word[i:]:\\n                    if c not in curr:\\n                        curr[c]={}\\n                    curr=curr[c]                    \\n                    curr[w]=idx  # update the weight of substring                        \\n            \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        curr=self.trie\\n        for c in suffix + \\'#\\' + prefix:\\n            if c not in curr:\\n                return -1\\n            curr=curr[c]\\n        \\n        return curr[self.weight_marker] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164117,
                "title": "visual-explanation-double-trie-java",
                "content": "### Logic:\\nThe logic behind my approach is quite straightforward! Simply construct two tries: `rootP` and `rootS` each representing the root nodes of a **prefix trie** and a **suffix trie**.\\n\\nBuilding these two tries doesn\\'t take too much effort. First, let\\'s discuss how our `TrieNode` class will work.\\n```text\\nTrieNode:\\n\\tMap<Character, TrieNode> children:          stores all letters following the current letter (TrieNodes) \\n\\tSet<String> words:                          stores all words that share the current prefix / suffix\\n```\\n\\nThe `words` set is particularly important. Basically, in our prefix trie, at each TrieNode we will store all words associated with the current prefix in the words set. We will do the same for the suffix trie. This is what it would look like for the words `[\"apple\", \"agile\"]` with prefix \"a\" and suffix \"ple\":\\n\\n![image](https://assets.leetcode.com/users/images/248c300f-0c44-405d-9360-d9e6b8583a90_1655515181.765634.png)\\n\\nAs you can see, all we really need to do is collect the words associated with the ends of the prefix and suffix and find the common word with the largest index. To keep track of indexes, we\\'ll simply use a map `indexes` that will store the largest index for each word.\\n\\nAwesome, now we have everything we need to start coding!\\n___\\n### Code:\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thanks for reading!\\n```java\\nclass TrieNode {\\n    public Map<Character, TrieNode> children;\\n    public Set<String> words;\\n    public TrieNode() {\\n        children = new HashMap<>();\\n        words = new HashSet<>();\\n    }\\n}\\n```\\n```java\\nclass WordFilter {\\n    private TrieNode rootP, rootS; \\n    private Map<String, Integer> indexes; \\n    \\n    public WordFilter(String[] words) {\\n        rootP = new TrieNode();\\n        rootS = new TrieNode();\\n        indexes = new HashMap<>();\\n        for (int i=0; i<words.length; i++) {\\n            insert(words[i]);\\n            indexes.put(words[i], i);\\n        }\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode ptrP = rootP, ptrS = rootS;\\n        for (int i=0; i<word.length(); i++) {\\n            // insert as prefixes\\n            char c = word.charAt(i);\\n            if (!ptrP.children.containsKey(c))\\n                ptrP.children.put(c, new TrieNode());\\n            ptrP = ptrP.children.get(c);\\n            ptrP.words.add(word);\\n            \\n            // insert as suffixes\\n            c = word.charAt(word.length()-1-i);\\n            if (!ptrS.children.containsKey(c))\\n                ptrS.children.put(c, new TrieNode());\\n            ptrS = ptrS.children.get(c);\\n            ptrS.words.add(word);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        TrieNode ptrP = rootP, ptrS = rootS;\\n        \\n        // get all words with prefix\\n        for (int i=0; i<prefix.length(); i++) {\\n            char c = prefix.charAt(i);\\n            if (!ptrP.children.containsKey(c)) return -1;\\n            ptrP = ptrP.children.get(c);            \\n        }\\n        Set<String> prefixes = ptrP.words;\\n        \\n        // get all words with suffix\\n        for (int i=0; i<suffix.length(); i++) {\\n            char c = suffix.charAt(suffix.length()-1-i);\\n            if (!ptrS.children.containsKey(c)) return -1;\\n            ptrS = ptrS.children.get(c);            \\n        }\\n        Set<String> suffixes = ptrS.words;\\n        \\n        int index = -1;\\n        for (String word: prefixes) \\n            if (suffixes.contains(word))\\n                 index = Math.max(index, indexes.get(word));\\n        \\n        return index;\\n    }\\n}\\n```\\n**Time complexity:**\\n> WordFilter: `O(L + W)`, where `L` is the length of the words array and `W` is the length of each word\\n> insert: `O(W),`\\n> f: `O(L)`, at worst case, we have to find the largest index of `L` words.\\n\\n**Space complexity:** `O(L * W^2)`",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```text\\nTrieNode:\\n\\tMap<Character, TrieNode> children:          stores all letters following the current letter (TrieNodes) \\n\\tSet<String> words:                          stores all words that share the current prefix / suffix\\n```\n```java\\nclass TrieNode {\\n    public Map<Character, TrieNode> children;\\n    public Set<String> words;\\n    public TrieNode() {\\n        children = new HashMap<>();\\n        words = new HashSet<>();\\n    }\\n}\\n```\n```java\\nclass WordFilter {\\n    private TrieNode rootP, rootS; \\n    private Map<String, Integer> indexes; \\n    \\n    public WordFilter(String[] words) {\\n        rootP = new TrieNode();\\n        rootS = new TrieNode();\\n        indexes = new HashMap<>();\\n        for (int i=0; i<words.length; i++) {\\n            insert(words[i]);\\n            indexes.put(words[i], i);\\n        }\\n    }\\n    \\n    private void insert(String word) {\\n        TrieNode ptrP = rootP, ptrS = rootS;\\n        for (int i=0; i<word.length(); i++) {\\n            // insert as prefixes\\n            char c = word.charAt(i);\\n            if (!ptrP.children.containsKey(c))\\n                ptrP.children.put(c, new TrieNode());\\n            ptrP = ptrP.children.get(c);\\n            ptrP.words.add(word);\\n            \\n            // insert as suffixes\\n            c = word.charAt(word.length()-1-i);\\n            if (!ptrS.children.containsKey(c))\\n                ptrS.children.put(c, new TrieNode());\\n            ptrS = ptrS.children.get(c);\\n            ptrS.words.add(word);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        TrieNode ptrP = rootP, ptrS = rootS;\\n        \\n        // get all words with prefix\\n        for (int i=0; i<prefix.length(); i++) {\\n            char c = prefix.charAt(i);\\n            if (!ptrP.children.containsKey(c)) return -1;\\n            ptrP = ptrP.children.get(c);            \\n        }\\n        Set<String> prefixes = ptrP.words;\\n        \\n        // get all words with suffix\\n        for (int i=0; i<suffix.length(); i++) {\\n            char c = suffix.charAt(suffix.length()-1-i);\\n            if (!ptrS.children.containsKey(c)) return -1;\\n            ptrS = ptrS.children.get(c);            \\n        }\\n        Set<String> suffixes = ptrS.words;\\n        \\n        int index = -1;\\n        for (String word: prefixes) \\n            if (suffixes.contains(word))\\n                 index = Math.max(index, indexes.get(word));\\n        \\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160419,
                "title": "c-trie-solution-easy-to-understand",
                "content": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> next;\\n    vector<int> idx_list;\\n    TrieNode(){\\n        next = vector<TrieNode*> (26, NULL);\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    void insert(string word, int idx){\\n        root->idx_list.push_back(idx); // Deal with empty string case\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(!cur->next[word[i] - \\'a\\'])\\n                cur->next[word[i] - \\'a\\'] = new TrieNode();\\n            cur = cur->next[word[i] - \\'a\\'];\\n            cur->idx_list.push_back(idx);\\n        }\\n    }\\n    vector<int> find(string word){\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            cur = cur->next[word[i] - \\'a\\'];\\n            if(!cur) return {};\\n        }\\n        return cur->idx_list;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie* forward;\\n    Trie* backward;\\n    WordFilter(vector<string> words) {\\n        forward = new Trie();\\n        backward = new Trie();\\n        for(int i = 0; i < words.size(); i++){\\n            forward->insert(words[i], i);\\n            string rword = words[i];\\n            reverse(rword.begin(), rword.end());\\n            backward->insert(rword, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        vector<int> pre = forward->find(prefix);\\n        reverse(suffix.begin(), suffix.end());\\n        vector<int> post = backward->find(suffix);\\n        int i = pre.size() - 1;\\n        int j = post.size() - 1;\\n        while(i >= 0 && j >= 0){\\n            if(pre[i] == post[j]) return pre[i];\\n            else if(pre[i] > post[j]) i--;\\n            else j--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> next;\\n    vector<int> idx_list;\\n    TrieNode(){\\n        next = vector<TrieNode*> (26, NULL);\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    void insert(string word, int idx){\\n        root->idx_list.push_back(idx); // Deal with empty string case\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            if(!cur->next[word[i] - \\'a\\'])\\n                cur->next[word[i] - \\'a\\'] = new TrieNode();\\n            cur = cur->next[word[i] - \\'a\\'];\\n            cur->idx_list.push_back(idx);\\n        }\\n    }\\n    vector<int> find(string word){\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            cur = cur->next[word[i] - \\'a\\'];\\n            if(!cur) return {};\\n        }\\n        return cur->idx_list;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie* forward;\\n    Trie* backward;\\n    WordFilter(vector<string> words) {\\n        forward = new Trie();\\n        backward = new Trie();\\n        for(int i = 0; i < words.size(); i++){\\n            forward->insert(words[i], i);\\n            string rword = words[i];\\n            reverse(rword.begin(), rword.end());\\n            backward->insert(rword, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        vector<int> pre = forward->find(prefix);\\n        reverse(suffix.begin(), suffix.end());\\n        vector<int> post = backward->find(suffix);\\n        int i = pre.size() - 1;\\n        int j = post.size() - 1;\\n        while(i >= 0 && j >= 0){\\n            if(pre[i] == post[j]) return pre[i];\\n            else if(pre[i] > post[j]) i--;\\n            else j--;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110068,
                "title": "accepted-java-code-using-trie",
                "content": "```\\nclass WordFilter {\\n    class TrieNode{\\n        String word;\\n        TrieNode[] children;\\n        TrieNode(){\\n            word=null;\\n            children= new TrieNode[26];\\n        }\\n    }\\n    \\n   Map<String,Integer> map;\\n    TrieNode root;\\n    int ans=-1;\\n    public WordFilter(String[] words) {\\n        map= new HashMap<>();\\n        root= new TrieNode();\\n        for(int i=0;i<words.length;i++){ map.put(words[i],i);\\n                             add(words[i],root);          \\n                                       }\\n        \\n    }\\n    \\n    public void add(String word,TrieNode node){\\n        char[] wordc= word.toCharArray();\\n        for(int i=0;i<word.length();i++){\\n            int c=wordc[i]-'a';\\n            if(node.children[c]==null) node.children[c]=new TrieNode();\\n            node=node.children[c];\\n        }\\n        node.word=word;\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        TrieNode node=find(root,prefix);\\n        if(node==null) return -1;\\n        ans=-1;\\n        findf(node,suffix,suffix.length());\\n        return ans;\\n    }\\n    \\n    public TrieNode find(TrieNode node, String prefix){\\n        for(int i=0;i<prefix.length();i++){\\n            int c=prefix.charAt(i)-'a';\\n            if(node.children[c]==null) return null;\\n            node=node.children[c];\\n        }\\n        return node;\\n    }\\n    \\n    public void findf(TrieNode node,String suffix,int len){\\n        if(node.word!=null){\\n            int start= node.word.length()-len;\\n            if(start>=0 && node.word.substring(start).equals(suffix)){\\n                if(map.get(node.word)>ans) ans=map.get(node.word);\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.children[i]!=null) findf(node.children[i],suffix,len);\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    class TrieNode{\\n        String word;\\n        TrieNode[] children;\\n        TrieNode(){\\n            word=null;\\n            children= new TrieNode[26];\\n        }\\n    }\\n    \\n   Map<String,Integer> map;\\n    TrieNode root;\\n    int ans=-1;\\n    public WordFilter(String[] words) {\\n        map= new HashMap<>();\\n        root= new TrieNode();\\n        for(int i=0;i<words.length;i++){ map.put(words[i],i);\\n                             add(words[i],root);          \\n                                       }\\n        \\n    }\\n    \\n    public void add(String word,TrieNode node){\\n        char[] wordc= word.toCharArray();\\n        for(int i=0;i<word.length();i++){\\n            int c=wordc[i]-'a';\\n            if(node.children[c]==null) node.children[c]=new TrieNode();\\n            node=node.children[c];\\n        }\\n        node.word=word;\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        TrieNode node=find(root,prefix);\\n        if(node==null) return -1;\\n        ans=-1;\\n        findf(node,suffix,suffix.length());\\n        return ans;\\n    }\\n    \\n    public TrieNode find(TrieNode node, String prefix){\\n        for(int i=0;i<prefix.length();i++){\\n            int c=prefix.charAt(i)-'a';\\n            if(node.children[c]==null) return null;\\n            node=node.children[c];\\n        }\\n        return node;\\n    }\\n    \\n    public void findf(TrieNode node,String suffix,int len){\\n        if(node.word!=null){\\n            int start= node.word.length()-len;\\n            if(start>=0 && node.word.substring(start).equals(suffix)){\\n                if(map.get(node.word)>ans) ans=map.get(node.word);\\n            }\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.children[i]!=null) findf(node.children[i],suffix,len);\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185480,
                "title": "js-python-java-c-double-trie-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n***Update 6/18/2022***: _This solution has been updated to account for duplicate words._\\n\\n---\\n\\n#### ***Idea:***\\n\\nWhenever we have to deal with searching for data using a prefix or a suffix, this naturally points to a **trie** solution. A trie is a type of data structure that uses a branching tree format where the nodes represent segments of data (usually characters) to make searching by prefix faster and easier.\\n\\nThe difficulty in this case is that we\\'re searching by both prefix and suffix, so we can create two trie structures, one for prefixes and one for suffixes (**pTrie, sTrie**). Then we can iterate through **words** and **insert()** each word into the two tries.\\n\\n(_Update: we should iterate backwards through **words** and use a **set** to prevent duplicate word entries, as only the largest index is needed._)\\n\\nTo do so, we\\'ll iterate through the characters of the word, forwards for **pTrie** and backwards for **sTrie**, and move from node to node as the word moves from character to character. At each node, we\\'ll update the **vals** array with the current **index**. The **vals** array represents the indices of all the words that run through the current node. Since we\\'re iterating through **words** in **index** order, each node\\'s **vals** array will be sorted in **index** order, as well.\\n\\nFor our find method, **f()**, we\\'ll be doing the same in reverse. We\\'ll navigate separately through **pTrie** with **pre** and **sTrie** with **suf** to find the **vals** arrays containing the indices of each word that matches those prefixes and suffixes. If at any point a particular trie does not have the next character, we can **return -1**.\\n\\nOnce we\\'ve successfully obtained the two **vals** arrays (**pVals, sVals**), we can cross-reference their contents, starting at the end, and look for the largest index that occurs in both. If we find one, we can **return** it, otherwise we can **return -1**.\\n\\n(_Update: Since we iterated through **words** backwards on insertion, we should start at the beginning of the **vals** arrays, rather than the end, to obtain the largest common index._)\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **476ms / 68.1MB** (beats 100% / 80%).\\n```javascript\\nclass WordFilter {\\n    constructor(words) {\\n        this.pTrie = new Array(27)\\n        this.sTrie = new Array(27)\\n        let wordSet = new Set()\\n        for (let index = words.length - 1; ~index; index--) {\\n            let word = words[index], wlen = word.length\\n            if (wordSet.has(word))\\n                continue;\\n            wordSet.add(word)\\n            this.insert(word, index, this.pTrie, 0, wlen, 1)\\n            this.insert(word, index, this.sTrie, wlen-1, -1, -1)\\n        }\\n    }\\n    \\n    insert(word, index, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) trie[c] = new Array(27)\\n            trie = trie[c]\\n            if (!trie[26]) trie[26] = []\\n            trie[26].push(index)\\n        }\\n    }\\n    \\n    retrieve(word, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) return []\\n            trie = trie[c]\\n        }\\n        return trie[26]\\n    }\\n    \\n    f(pre, suf) {\\n        let pVals = this.retrieve(pre, this.pTrie, 0, pre.length, 1),\\n            sVals = this.retrieve(suf, this.sTrie, suf.length-1, -1, -1),\\n            svix = 0, pvix = 0\\n        while (svix < sVals.length && pvix < pVals.length) {\\n            let sVal = sVals[svix], pVal = pVals[pvix]\\n            if (sVal === pVal) return sVal\\n            sVal > pVal ? svix++ : pvix++\\n        }\\n        return -1\\n    }\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **895ms / 25.8MB** (beats 96% / 96%).\\n```python\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.pTrie = [None] * 27\\n        self.sTrie = [None] * 27\\n        self.wordSet = set()\\n        for index in range(len(words)-1, -1, -1):\\n            word = words[index]\\n            if word not in self.wordSet:\\n                self.wordSet.add(word)\\n                self.insert(word, index, self.pTrie)\\n                self.insert(word[::-1], index, self.sTrie)\\n            \\n    def insert(self, word: str, index: int, trie: dict):\\n        for c in word:\\n            cval = ord(c) - 97\\n            if not trie[cval]: trie[cval] = [None] * 27\\n            trie = trie[cval]\\n            if not trie[26]: trie[26] = []\\n            trie[26].append(index)\\n            \\n    def retrieve(self, word: str, trie: dict) -> list:\\n        for c in word:\\n            cval = ord(c) - 97\\n            trie = trie[cval]\\n            if not trie: return []\\n        return trie[26]\\n\\n    def f(self, pre: str, suf: str) -> int:\\n        pVals = self.retrieve(pre, self.pTrie)\\n        sVals = self.retrieve(suf[::-1], self.sTrie)\\n        svix, pvix = 0, 0\\n        while svix < len(sVals) and pvix < len(pVals):\\n            sVal, pVal = sVals[svix], pVals[pvix]\\n            if sVal == pVal: return sVal\\n            if sVal > pVal: svix += 1\\n            else: pvix += 1\\n        return -1\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **182ms / 51.6MB** (beats 99% / 100%).\\n```java\\nclass TrieNode {\\n    public TrieNode[] children = new TrieNode[26];\\n    public List<Integer> vals = new ArrayList<>();\\n}\\n\\nclass WordFilter {\\n    private TrieNode pTrie = new TrieNode();\\n    private TrieNode sTrie = new TrieNode();\\n    \\n    public WordFilter(String[] words) {\\n        Set<String> wordSet = new HashSet<>();\\n        for (int index = words.length - 1; index > -1; index--) {\\n            if (wordSet.contains(words[index]))\\n                continue;\\n            wordSet.add(words[index]);\\n            char[] word = words[index].toCharArray();\\n            int wlen = word.length;\\n            insert(word, index, pTrie, 0, wlen, 1);\\n            insert(word, index, sTrie, wlen-1, -1, -1);\\n        }\\n    }\\n            \\n    private void insert(char[] word, int index, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            int c = word[i] - \\'a\\';\\n            if (trie.children[c] == null)\\n                trie.children[c] = new TrieNode();\\n            trie = trie.children[c];\\n            trie.vals.add(index);\\n        }\\n    }\\n    \\n    private List<Integer> retrieve(char[] word, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            trie = trie.children[word[i]-\\'a\\'];\\n            if (trie == null) return new ArrayList<>();\\n        }\\n        return trie.vals;\\n    }\\n    \\n    public int f(String pre, String suf) {\\n        List<Integer> pVals = retrieve(pre.toCharArray(), pTrie, 0, pre.length(), 1);\\n        List<Integer> sVals = retrieve(suf.toCharArray(), sTrie, suf.length()-1, -1, -1);\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals.size() && pvix < pVals.size()) {\\n            int sVal = sVals.get(svix), pVal = pVals.get(pvix);\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **366ms / 100.8MB** (beats 97% / 98%).\\n```c++\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    vector<int> vals;\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode *pTrie, *sTrie;\\n    \\npublic:\\n    WordFilter(vector<string>& words) {\\n        pTrie = new TrieNode();\\n        sTrie = new TrieNode();\\n        unordered_set<string> wordSet;\\n        int n = words.size();\\n        for (int index = n - 1; ~index; index--) {\\n            string word = words[index];\\n            if (wordSet.find(word) != wordSet.end())\\n                continue;\\n            wordSet.insert(word);\\n            insert(word, index, pTrie);\\n            reverse(word.begin(), word.end());\\n            insert(word, index, sTrie);\\n        }\\n    }\\n    \\n    void insert(string word, int index, TrieNode* trie) {\\n        for (auto c : word) {\\n            if (!trie->children[c])\\n                trie->children[c] = new TrieNode();\\n            trie = trie->children[c];\\n            trie->vals.push_back(index);\\n        }\\n    }\\n    \\n    vector<int>* retrieve(string str, TrieNode* trie) {\\n        for (auto c : str) {\\n            trie = trie->children[c];\\n            if (!trie) return nullptr;\\n        }\\n        return &trie->vals;\\n    }\\n    \\n    int f(string pre, string suf) {\\n        vector<int>* pVals = retrieve(pre, pTrie);\\n        reverse(suf.begin(), suf.end());\\n        vector<int>* sVals = retrieve(suf, sTrie);\\n        if (pVals == nullptr or sVals == nullptr)\\n            return -1;\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals->size() && pvix < pVals->size()) {\\n            int sVal = (*sVals)[svix], pVal = (*pVals)[pvix];\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nclass WordFilter {\\n    constructor(words) {\\n        this.pTrie = new Array(27)\\n        this.sTrie = new Array(27)\\n        let wordSet = new Set()\\n        for (let index = words.length - 1; ~index; index--) {\\n            let word = words[index], wlen = word.length\\n            if (wordSet.has(word))\\n                continue;\\n            wordSet.add(word)\\n            this.insert(word, index, this.pTrie, 0, wlen, 1)\\n            this.insert(word, index, this.sTrie, wlen-1, -1, -1)\\n        }\\n    }\\n    \\n    insert(word, index, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) trie[c] = new Array(27)\\n            trie = trie[c]\\n            if (!trie[26]) trie[26] = []\\n            trie[26].push(index)\\n        }\\n    }\\n    \\n    retrieve(word, trie, start, end, step) {\\n        for (let i = start; i != end; i += step) {\\n            let c = word.charCodeAt(i) - 97\\n            if (!trie[c]) return []\\n            trie = trie[c]\\n        }\\n        return trie[26]\\n    }\\n    \\n    f(pre, suf) {\\n        let pVals = this.retrieve(pre, this.pTrie, 0, pre.length, 1),\\n            sVals = this.retrieve(suf, this.sTrie, suf.length-1, -1, -1),\\n            svix = 0, pvix = 0\\n        while (svix < sVals.length && pvix < pVals.length) {\\n            let sVal = sVals[svix], pVal = pVals[pvix]\\n            if (sVal === pVal) return sVal\\n            sVal > pVal ? svix++ : pvix++\\n        }\\n        return -1\\n    }\\n};\\n```\n```python\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.pTrie = [None] * 27\\n        self.sTrie = [None] * 27\\n        self.wordSet = set()\\n        for index in range(len(words)-1, -1, -1):\\n            word = words[index]\\n            if word not in self.wordSet:\\n                self.wordSet.add(word)\\n                self.insert(word, index, self.pTrie)\\n                self.insert(word[::-1], index, self.sTrie)\\n            \\n    def insert(self, word: str, index: int, trie: dict):\\n        for c in word:\\n            cval = ord(c) - 97\\n            if not trie[cval]: trie[cval] = [None] * 27\\n            trie = trie[cval]\\n            if not trie[26]: trie[26] = []\\n            trie[26].append(index)\\n            \\n    def retrieve(self, word: str, trie: dict) -> list:\\n        for c in word:\\n            cval = ord(c) - 97\\n            trie = trie[cval]\\n            if not trie: return []\\n        return trie[26]\\n\\n    def f(self, pre: str, suf: str) -> int:\\n        pVals = self.retrieve(pre, self.pTrie)\\n        sVals = self.retrieve(suf[::-1], self.sTrie)\\n        svix, pvix = 0, 0\\n        while svix < len(sVals) and pvix < len(pVals):\\n            sVal, pVal = sVals[svix], pVals[pvix]\\n            if sVal == pVal: return sVal\\n            if sVal > pVal: svix += 1\\n            else: pvix += 1\\n        return -1\\n```\n```java\\nclass TrieNode {\\n    public TrieNode[] children = new TrieNode[26];\\n    public List<Integer> vals = new ArrayList<>();\\n}\\n\\nclass WordFilter {\\n    private TrieNode pTrie = new TrieNode();\\n    private TrieNode sTrie = new TrieNode();\\n    \\n    public WordFilter(String[] words) {\\n        Set<String> wordSet = new HashSet<>();\\n        for (int index = words.length - 1; index > -1; index--) {\\n            if (wordSet.contains(words[index]))\\n                continue;\\n            wordSet.add(words[index]);\\n            char[] word = words[index].toCharArray();\\n            int wlen = word.length;\\n            insert(word, index, pTrie, 0, wlen, 1);\\n            insert(word, index, sTrie, wlen-1, -1, -1);\\n        }\\n    }\\n            \\n    private void insert(char[] word, int index, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            int c = word[i] - \\'a\\';\\n            if (trie.children[c] == null)\\n                trie.children[c] = new TrieNode();\\n            trie = trie.children[c];\\n            trie.vals.add(index);\\n        }\\n    }\\n    \\n    private List<Integer> retrieve(char[] word, TrieNode trie, int start, int end, int step) {\\n        for (int i = start; i != end; i += step) {\\n            trie = trie.children[word[i]-\\'a\\'];\\n            if (trie == null) return new ArrayList<>();\\n        }\\n        return trie.vals;\\n    }\\n    \\n    public int f(String pre, String suf) {\\n        List<Integer> pVals = retrieve(pre.toCharArray(), pTrie, 0, pre.length(), 1);\\n        List<Integer> sVals = retrieve(suf.toCharArray(), sTrie, suf.length()-1, -1, -1);\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals.size() && pvix < pVals.size()) {\\n            int sVal = sVals.get(svix), pVal = pVals.get(pvix);\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass TrieNode {\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    vector<int> vals;\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode *pTrie, *sTrie;\\n    \\npublic:\\n    WordFilter(vector<string>& words) {\\n        pTrie = new TrieNode();\\n        sTrie = new TrieNode();\\n        unordered_set<string> wordSet;\\n        int n = words.size();\\n        for (int index = n - 1; ~index; index--) {\\n            string word = words[index];\\n            if (wordSet.find(word) != wordSet.end())\\n                continue;\\n            wordSet.insert(word);\\n            insert(word, index, pTrie);\\n            reverse(word.begin(), word.end());\\n            insert(word, index, sTrie);\\n        }\\n    }\\n    \\n    void insert(string word, int index, TrieNode* trie) {\\n        for (auto c : word) {\\n            if (!trie->children[c])\\n                trie->children[c] = new TrieNode();\\n            trie = trie->children[c];\\n            trie->vals.push_back(index);\\n        }\\n    }\\n    \\n    vector<int>* retrieve(string str, TrieNode* trie) {\\n        for (auto c : str) {\\n            trie = trie->children[c];\\n            if (!trie) return nullptr;\\n        }\\n        return &trie->vals;\\n    }\\n    \\n    int f(string pre, string suf) {\\n        vector<int>* pVals = retrieve(pre, pTrie);\\n        reverse(suf.begin(), suf.end());\\n        vector<int>* sVals = retrieve(suf, sTrie);\\n        if (pVals == nullptr or sVals == nullptr)\\n            return -1;\\n        int svix = 0, pvix = 0;\\n        while (svix < sVals->size() && pvix < pVals->size()) {\\n            int sVal = (*sVals)[svix], pVal = (*pVals)[pvix];\\n            if (sVal == pVal) return sVal;\\n            if (sVal > pVal) svix++;\\n            else pvix++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164096,
                "title": "c-simple-hash-table-solution-no-trie-but-still-beats-70",
                "content": "Insert all prefix/suffix combinations of each word into a hash table for O(1) lookup\\nhttps://leetcode.com/submissions/detail/724785480/\\n```\\nclass WordFilter {\\n    unordered_map<string,int> data;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for (int k = 0; k < words.size(); ++k) {\\n            string const& word = words[k];\\n            int const n = word.size();\\n            for (int i = 1; i <= n; ++i) {\\n                string key = word.substr(0, i);\\n                key += \\'.\\';\\n                for (int j = 1; j <= n; ++j) {\\n                    key.resize(i+1);\\n                    key.append(word, n-j, j);\\n                    data[key] = k;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        prefix += \\'.\\';\\n        prefix += suffix;\\n        return data.count(prefix) ? data[prefix] : -1;\\n    }\\n};\\n```\\n\\nA trie solution could be faster but a lot longer, and here is my implementation:\\n```\\nclass WordFilter {\\n    struct TrieNode {\\n        array<unique_ptr<TrieNode>, 27> children;\\n        int max_id;\\n    };\\n    TrieNode trie;\\n\\t\\n    void insert(string const& key, int id) {\\n        auto node = &trie;\\n        for (int i = 0; i < key.size(); ++i) {\\n            int c = key[i] - \\'a\\';\\n            if (node->children[c]) {\\n                node = node->children[c].get();\\n            } else {\\n                node->children[c].reset(node = new TrieNode());\\n            }\\n            node->max_id = id;\\n        }\\n    }\\n\\t\\n    int query(string const& key) const {\\n        auto node = &trie;\\n        for (int i = 0; i < key.size(); ++i) {\\n            int c = key[i] - \\'a\\';\\n            if (node->children[c]) {\\n                node = node->children[c].get();\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return node->max_id;\\n    }\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for (int k = 0; k < words.size(); ++k) {\\n            string const& word = words[k];\\n            int const n = word.size();\\n            for (int i = 1; i <= n; ++i) {\\n                string key = word.substr(n-i, i);\\n                key += \\'{\\';\\n                key.append(word);\\n                insert(key, k);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        suffix += \\'{\\';\\n        suffix += prefix;\\n        return query(suffix);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    unordered_map<string,int> data;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for (int k = 0; k < words.size(); ++k) {\\n            string const& word = words[k];\\n            int const n = word.size();\\n            for (int i = 1; i <= n; ++i) {\\n                string key = word.substr(0, i);\\n                key += \\'.\\';\\n                for (int j = 1; j <= n; ++j) {\\n                    key.resize(i+1);\\n                    key.append(word, n-j, j);\\n                    data[key] = k;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        prefix += \\'.\\';\\n        prefix += suffix;\\n        return data.count(prefix) ? data[prefix] : -1;\\n    }\\n};\\n```\n```\\nclass WordFilter {\\n    struct TrieNode {\\n        array<unique_ptr<TrieNode>, 27> children;\\n        int max_id;\\n    };\\n    TrieNode trie;\\n\\t\\n    void insert(string const& key, int id) {\\n        auto node = &trie;\\n        for (int i = 0; i < key.size(); ++i) {\\n            int c = key[i] - \\'a\\';\\n            if (node->children[c]) {\\n                node = node->children[c].get();\\n            } else {\\n                node->children[c].reset(node = new TrieNode());\\n            }\\n            node->max_id = id;\\n        }\\n    }\\n\\t\\n    int query(string const& key) const {\\n        auto node = &trie;\\n        for (int i = 0; i < key.size(); ++i) {\\n            int c = key[i] - \\'a\\';\\n            if (node->children[c]) {\\n                node = node->children[c].get();\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return node->max_id;\\n    }\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for (int k = 0; k < words.size(); ++k) {\\n            string const& word = words[k];\\n            int const n = word.size();\\n            for (int i = 1; i <= n; ++i) {\\n                string key = word.substr(n-i, i);\\n                key += \\'{\\';\\n                key.append(word);\\n                insert(key, k);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        suffix += \\'{\\';\\n        suffix += prefix;\\n        return query(suffix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165021,
                "title": "c-using-single-trie-detailed-explanation",
                "content": "* You just need basic trie operations (search, insert) to solve this question.\\n* Using trie you can easily tell whether a word of given prefix is available or not (same with suffix, by making a reverse trie). So the first issue which arises is that you need to check for both suffix prefix of a same word because you can\\'t just independently search the two tries as that may give wrong results.\\n* So to curb this, since the length of each word is not more that 10, I created all possible suffixes of that word and appended them ahead the word, separated by \\'#\". Like for apple: e#apple, le#apple,......apple#apple.\\n* Now when a search query comes up, I will just concatenate the suffix with prefix separated by a \\'#\\' and then simply search the trie. E.g. If it was \"ap\" and \"e\" then just search for \"e#ap\".\\n* To get the most recent word (with largest index) out of many possible options, I am maintaining an idx variable for each node, which will get updated if a newer word arrives in that path so that we return the most recent word.\\n\\n\\n```\\nclass node{\\npublic:\\n    char data;\\n    unordered_map<char, node*>children;\\n    int idx;\\n    node(char c){\\n        data=c;\\n        idx=-1;\\n    }\\n};\\nclass WordFilter {\\npublic:\\n    node*root=new node(\\'/0\\');\\n    void insert(string s, int i){\\n        node*curr=root;\\n        for(char &ch:s){\\n            if(curr->children.count(ch)==0){\\n                node *temp=new node(ch);\\n                temp->idx=i;\\n                curr->children[ch]=temp;\\n                curr=curr->children[ch];\\n            }else{\\n                curr->children[ch]->idx=i;\\n                curr=curr->children[ch];\\n            }\\n        }\\n    }\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            string temp=\"#\";\\n            temp+=s;\\n            for(int j=s.size()-1;j>=0;j--){\\n                char ch=s[j];\\n                temp=ch+temp;\\n                insert(temp, i);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string s=suffix+\"#\"+prefix;\\n        int ans=-1;\\n        node*curr=root;\\n        for(char &ch:s){\\n            if(curr->children.count(ch)==0){\\n                return -1;\\n            }else{\\n                ans=curr->children[ch]->idx;\\n                curr=curr->children[ch];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass node{\\npublic:\\n    char data;\\n    unordered_map<char, node*>children;\\n    int idx;\\n    node(char c){\\n        data=c;\\n        idx=-1;\\n    }\\n};\\nclass WordFilter {\\npublic:\\n    node*root=new node(\\'/0\\');\\n    void insert(string s, int i){\\n        node*curr=root;\\n        for(char &ch:s){\\n            if(curr->children.count(ch)==0){\\n                node *temp=new node(ch);\\n                temp->idx=i;\\n                curr->children[ch]=temp;\\n                curr=curr->children[ch];\\n            }else{\\n                curr->children[ch]->idx=i;\\n                curr=curr->children[ch];\\n            }\\n        }\\n    }\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            string s=words[i];\\n            string temp=\"#\";\\n            temp+=s;\\n            for(int j=s.size()-1;j>=0;j--){\\n                char ch=s[j];\\n                temp=ch+temp;\\n                insert(temp, i);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string s=suffix+\"#\"+prefix;\\n        int ans=-1;\\n        node*curr=root;\\n        for(char &ch:s){\\n            if(curr->children.count(ch)==0){\\n                return -1;\\n            }else{\\n                ans=curr->children[ch]->idx;\\n                curr=curr->children[ch];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185368,
                "title": "prefix-suffix-search-c-using-trie",
                "content": "```\\nclass trie {\\n    trie* ch[27];\\n    int weight;\\npublic:\\n    trie() {\\n        memset(ch, 0, sizeof(ch));\\n        weight = 0;\\n    }\\n    void insert(string str, int weight) {\\n        trie* node = this;\\n        for (char c: str) {\\n            if (node->ch[c - \\'a\\'] == NULL)\\n                node->ch[c - \\'a\\'] = new trie();\\n            node = node->ch[c - \\'a\\'];\\n            node->weight = weight;\\n        }\\n    }\\n    int startsWith(string str) {\\n        trie* node = this;\\n        for (char c: str) {\\n            if (node->ch[c - \\'a\\'] == NULL)\\n                return -1;\\n            node = node->ch[c - \\'a\\'];\\n        }\\n        return node->weight;\\n    }\\n};\\nclass WordFilter {\\npublic:\\n    trie root;\\n    WordFilter(vector<string>& words) {\\n        int idx = 0;\\n        for (string word: words) {\\n            root.insert(word, idx);\\n            string tmp = \"{\" + word;\\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                string newword = word[i] + tmp;\\n                tmp = newword;\\n                root.insert(newword, idx);\\n            }\\n            idx++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string word = suffix + \"{\" + prefix;\\n        return root.startsWith(word);\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass trie {\\n    trie* ch[27];\\n    int weight;\\npublic:\\n    trie() {\\n        memset(ch, 0, sizeof(ch));\\n        weight = 0;\\n    }\\n    void insert(string str, int weight) {\\n        trie* node = this;\\n        for (char c: str) {\\n            if (node->ch[c - \\'a\\'] == NULL)\\n                node->ch[c - \\'a\\'] = new trie();\\n            node = node->ch[c - \\'a\\'];\\n            node->weight = weight;\\n        }\\n    }\\n    int startsWith(string str) {\\n        trie* node = this;\\n        for (char c: str) {\\n            if (node->ch[c - \\'a\\'] == NULL)\\n                return -1;\\n            node = node->ch[c - \\'a\\'];\\n        }\\n        return node->weight;\\n    }\\n};\\nclass WordFilter {\\npublic:\\n    trie root;\\n    WordFilter(vector<string>& words) {\\n        int idx = 0;\\n        for (string word: words) {\\n            root.insert(word, idx);\\n            string tmp = \"{\" + word;\\n            for (int i = word.length() - 1; i >= 0; i--) {\\n                string newword = word[i] + tmp;\\n                tmp = newword;\\n                root.insert(newword, idx);\\n            }\\n            idx++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string word = suffix + \"{\" + prefix;\\n        return root.startsWith(word);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1185186,
                "title": "prefix-and-suffix-search-python-concise",
                "content": "The length of prefix and suffix is maximum `10`. Hence there would be maximum` 10 * 10 = 100` combinations for a word.\\n\\nTime Complexity: O(100 * n) = **O(n)**  `Beats 89.47%`\\nSpace Complexity: O(100 * n) =  **O(n)**\\n\\nTaking advantage of the ability to store tuples as key in dictionary in python.\\n\\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d = {}\\n        for i,w in enumerate(words):\\n            l = len(w)\\n            for p in range(1, min(10, l) + 1):\\n                for s in range(1, min(10, l) + 1):\\n                    self.d[w[:p], w[-s:]] = i\\n            \\n    def f(self, p: str, s: str) -> int:\\n        return self.d[p, s] if (p, s) in self.d else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d = {}\\n        for i,w in enumerate(words):\\n            l = len(w)\\n            for p in range(1, min(10, l) + 1):\\n                for s in range(1, min(10, l) + 1):\\n                    self.d[w[:p], w[-s:]] = i\\n            \\n    def f(self, p: str, s: str) -> int:\\n        return self.d[p, s] if (p, s) in self.d else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164213,
                "title": "trie-c-solution-production-level-code",
                "content": "```\\nclass Trie\\n{\\n    public:\\n    struct Node\\n    {\\n        private:\\n            Node *child[27];\\n            int endIdx;\\n        \\n        public:\\n            bool contains(char &ch)\\n            {                    \\n                return (child[ch - \\'a\\'] != NULL);\\n            } \\n        \\n            void putNode(char &ch, Node *newNode)\\n            {\\n                child[ch - \\'a\\'] = newNode;\\n            }\\n        \\n            Node *getNext(char &ch)\\n            {                \\n                return child[ch - \\'a\\'];\\n            }\\n            \\n            void setIdx(int &i)\\n            {\\n                endIdx = i;\\n            }\\n        \\n            int getIdx()\\n            {\\n                return endIdx;\\n            }\\n    };\\n    \\n    Node *root;\\n    \\n    public:\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n    \\n    void insert(string &word, int &idx)\\n    {\\n        Node *temp = root;\\n        \\n        for(auto &ch : word)\\n        {\\n            if(!temp -> contains(ch))\\n            {\\n                temp -> putNode(ch, new Node());\\n            }\\n            \\n            temp = temp -> getNext(ch);\\n            temp -> setIdx(idx);\\n        }\\n        \\n    }\\n    \\n    int startsWith(string &word)\\n    {\\n        Node *temp = root;\\n        \\n        for(auto &ch : word)\\n        {\\n            if(!temp -> contains(ch))\\n            {\\n                return -1;\\n            }\\n            \\n            temp = temp -> getNext(ch);\\n        }\\n        \\n        return temp -> getIdx();\\n    }\\n};\\n\\nclass WordFilter {\\n    Trie trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        /*\\n        \\n        We are storing word as suffix + \\'{\\' + prefix, index \\n        why \\'{\\' ? you can use any special character, but \\'{\\' - \\'a\\' will give 26th index\\n        so, we don\\'t need to take care of special character.\\n        \\n        apple -> suffix + \\'{\\' + prefix, i\\n            apple{apple 0\\n            pple{apple 0\\n            ple{apple 0\\n            le{apple 0\\n            e{apple 0\\n            {apple 0\\n\\n\\n        */\\n        int len = words.size();\\n        for(int i = 0; i < len; i++)\\n        {            \\n            string str = words[i];\\n            int n = str.size();\\n            \\n            for(int j = 0; j <= n; j++)\\n            {                \\n                string cur = str.substr(j) + \\'{\\' + str;\\n                \\n                trie.insert(cur, i);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string cur = suffix + \\'{\\' + prefix;\\n        \\n        // just use startswith function and pass suffix + \\'{\\' + prefix to find index\\n        \\n        return trie.startsWith(cur);\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass Trie\\n{\\n    public:\\n    struct Node\\n    {\\n        private:\\n            Node *child[27];\\n            int endIdx;\\n        \\n        public:\\n            bool contains(char &ch)\\n            {                    \\n                return (child[ch - \\'a\\'] != NULL);\\n            } \\n        \\n            void putNode(char &ch, Node *newNode)\\n            {\\n                child[ch - \\'a\\'] = newNode;\\n            }\\n        \\n            Node *getNext(char &ch)\\n            {                \\n                return child[ch - \\'a\\'];\\n            }\\n            \\n            void setIdx(int &i)\\n            {\\n                endIdx = i;\\n            }\\n        \\n            int getIdx()\\n            {\\n                return endIdx;\\n            }\\n    };\\n    \\n    Node *root;\\n    \\n    public:\\n    Trie()\\n    {\\n        root = new Node();\\n    }\\n    \\n    void insert(string &word, int &idx)\\n    {\\n        Node *temp = root;\\n        \\n        for(auto &ch : word)\\n        {\\n            if(!temp -> contains(ch))\\n            {\\n                temp -> putNode(ch, new Node());\\n            }\\n            \\n            temp = temp -> getNext(ch);\\n            temp -> setIdx(idx);\\n        }\\n        \\n    }\\n    \\n    int startsWith(string &word)\\n    {\\n        Node *temp = root;\\n        \\n        for(auto &ch : word)\\n        {\\n            if(!temp -> contains(ch))\\n            {\\n                return -1;\\n            }\\n            \\n            temp = temp -> getNext(ch);\\n        }\\n        \\n        return temp -> getIdx();\\n    }\\n};\\n\\nclass WordFilter {\\n    Trie trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        /*\\n        \\n        We are storing word as suffix + \\'{\\' + prefix, index \\n        why \\'{\\' ? you can use any special character, but \\'{\\' - \\'a\\' will give 26th index\\n        so, we don\\'t need to take care of special character.\\n        \\n        apple -> suffix + \\'{\\' + prefix, i\\n            apple{apple 0\\n            pple{apple 0\\n            ple{apple 0\\n            le{apple 0\\n            e{apple 0\\n            {apple 0\\n\\n\\n        */\\n        int len = words.size();\\n        for(int i = 0; i < len; i++)\\n        {            \\n            string str = words[i];\\n            int n = str.size();\\n            \\n            for(int j = 0; j <= n; j++)\\n            {                \\n                string cur = str.substr(j) + \\'{\\' + str;\\n                \\n                trie.insert(cur, i);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string cur = suffix + \\'{\\' + prefix;\\n        \\n        // just use startswith function and pass suffix + \\'{\\' + prefix to find index\\n        \\n        return trie.startsWith(cur);\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504861,
                "title": "two-approaches-explained-trie-solution-c-clean-code",
                "content": "**Approach 1:**\\n\\nIn this approach we take two Tries : one for Prefix and one for Suffix. Though it passes all TC but gets overall TLE. \\n\\n*\\t**Prefix Trie :** In this we store word in same order as given. \\n\\n\\t\\tEx : \"abc\" is stored as \"a -> b -> c\" \\n\\n*\\t**Suffix Trie :** In this we store word in reverse order so that suffixes can be searched easily.\\n\\n\\t\\tEx: \"abc\" is stores as \"c -> b -> a\"\\n\\n* Idea is to store *`indexes`* of all `words` that pass through a Trie node. It will be later used to find intersection of suffix and prefix string. And to get **Largest Index** if there are multiple words.\\n\\n* When we find both prefix and suffix string in corresponding Tries, we will find the first common index that is present in `indexes` array of prefix and suffix word. \\n\\n*Read the comments to get better understanding.*\\n\\n# Code:\\n\\n```\\nstruct Node {\\n    Node* arr[26];\\n    vector<int> indexes;  // To get all the index of words that pass through this node\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void putIndex(int idx) {    // Add index of word that pass through it\\n        indexes.push_back(idx);\\n    }\\n    \\n    vector<int> getIndex() {\\n        return indexes;\\n    }\\n};\\n\\nclass WordFilter {\\n    Node* prefixRoot;\\n    Node* suffixRoot;\\npublic:\\n    \\n\\t// Insert the words into Trie\\n\\t// For every node insert the index as well \\n\\t// It tracks the word that passes through that node\\n    void insert(Node* root, string& s, int i) {\\n        for(auto& ch : s) {\\n            if(!root->contains(ch)) {\\n                root->put(ch, new Node());\\n            }\\n            root = root->getNext(ch);\\n            root->putIndex(i);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        prefixRoot = new Node();\\n        suffixRoot = new Node();\\n        \\n        int i=0;\\n        for(auto& word : words) {\\n            insert(prefixRoot, word, i);\\n            reverse(word.begin(), word.end());\\n            insert(suffixRoot, word, i);\\n            i++;\\n        }\\n    }\\n    \\n\\t// Search if word is present or not. \\n\\t// If present then return indexes array \\n\\t// Otherwise return empty array\\n    vector<int> search(Node* root, string& word) {\\n        for(auto& ch : word) {\\n            if(!root->contains(ch)) return {};\\n            root = root->getNext(ch);\\n        }\\n        return root->getIndex();\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        vector<int> prefixIndexes = search(prefixRoot, prefix);\\n        reverse(suffix.begin(), suffix.end());\\n        vector<int> suffixIndexes = search(suffixRoot, suffix);\\n        \\n\\t\\t// Find the first intersection index from last\\n\\t\\t// Since from last we will get the largest index \\n\\t\\t// in case if there are multiple valid words \\n        int i = prefixIndexes.size()-1, j = suffixIndexes.size()-1;\\n        while(i>=0 && j>=0) {\\n            int a = prefixIndexes[i], b = suffixIndexes[j];\\n            if(a == b) return a;\\n            else (a < b) ? j-- : i--;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Approach 2:**\\n\\nIn this approach we use a simple Trie. Convert word in form **`suffix + { + prefix`** so that matching of string becomes easy and fast. We take advantage that maximum length possible of word is 10. \\n\\n* We store all possible suffixes concatenated with prefix and \\'{\\'\\n\\n\\t\\tEx:  \"apple\" -> \"{apple\"  \"e{apple\"  \"le{apple\"  \"ple{apple\"  \"pple{apple\"  \"apple{apple\"\\n\\n\\t\\t-> Suffixes are \"\", \"e\", \"le\", \"ple\", \"pple\", \"apple\"\\n\\t\\n* Also, we store latest index of word that passes through a particular Trie node. This will give us that *largest index* in case of multiple valid words. \\n\\n* To search if there is word that has both prefix and suffix strings, we simply need to make a string by concatenating `suffix { prefix` , and search for this string in Trie that we build. \\n\\n\\t\\tEx : prefix = \"app\" , suffix = \"ple\" -> string = \"ple{app\"\\n\\n\\t\\tThis string is present in Trie, and return the index at end of this string. \\n\\n*Remaining Code is easy to understand.*\\n\\n# Code:\\n\\n```\\nstruct Node {\\n    Node* arr[27];\\n    int index = -1;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void setIndex(int idx) {\\n        index = idx;\\n    }\\n    \\n    int getIndex() {\\n        return index;\\n    }\\n};\\n\\nclass WordFilter {\\n    Node* trie;\\npublic:\\n    \\n    void insert(Node* root, string& s, int idx) {\\n        for(auto& ch : s) {\\n            if(!root->contains(ch)) {\\n                root->put(ch, new Node());\\n            }\\n            root = root->getNext(ch);\\n            root->setIndex(idx);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        trie = new Node();\\n        \\n        int idx = 0;\\n        string s = \"\";\\n        \\n        for(auto& word : words) {\\n            s = \"{\" + word;\\n            insert(trie, s, idx);\\n            \\n            for(int i=word.size()-1; i>=0; i--) {\\n                s = word[i] + s;\\n                insert(trie, s, idx);\\n            }\\n            \\n            idx++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        Node* temp = trie;\\n        \\n        string match = suffix + \"{\" + prefix;\\n        \\n        for(auto& ch : match) {\\n            if(!temp || !temp->contains(ch)) return -1;\\n            temp = temp->getNext(ch);\\n        }\\n        \\n        return temp->getIndex();\\n    }\\n};\\n```\\n* **Time : O(N * K * K + Q * K)**\\n\\t*  To insert all words  into Trie , **O(N * K * K)** , \\n\\t\\t* **N** : No. of words ,  **K** : Maximum Length of word \\n\\t* To search words, O(Q * K), \\n\\t\\t* **Q** : No. of Queries, **K** : Maximum Length of word \\n\\n* **Space : O(N * K * K)** , space is required to insert all words into Trie\\n\\t* **N** : No. of words ,  **K** : Maximum Length of word \\n\\n***If you find this post helpful, please do upvote :)***",
                "solutionTags": [
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nstruct Node {\\n    Node* arr[26];\\n    vector<int> indexes;  // To get all the index of words that pass through this node\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void putIndex(int idx) {    // Add index of word that pass through it\\n        indexes.push_back(idx);\\n    }\\n    \\n    vector<int> getIndex() {\\n        return indexes;\\n    }\\n};\\n\\nclass WordFilter {\\n    Node* prefixRoot;\\n    Node* suffixRoot;\\npublic:\\n    \\n\\t// Insert the words into Trie\\n\\t// For every node insert the index as well \\n\\t// It tracks the word that passes through that node\\n    void insert(Node* root, string& s, int i) {\\n        for(auto& ch : s) {\\n            if(!root->contains(ch)) {\\n                root->put(ch, new Node());\\n            }\\n            root = root->getNext(ch);\\n            root->putIndex(i);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        prefixRoot = new Node();\\n        suffixRoot = new Node();\\n        \\n        int i=0;\\n        for(auto& word : words) {\\n            insert(prefixRoot, word, i);\\n            reverse(word.begin(), word.end());\\n            insert(suffixRoot, word, i);\\n            i++;\\n        }\\n    }\\n    \\n\\t// Search if word is present or not. \\n\\t// If present then return indexes array \\n\\t// Otherwise return empty array\\n    vector<int> search(Node* root, string& word) {\\n        for(auto& ch : word) {\\n            if(!root->contains(ch)) return {};\\n            root = root->getNext(ch);\\n        }\\n        return root->getIndex();\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        vector<int> prefixIndexes = search(prefixRoot, prefix);\\n        reverse(suffix.begin(), suffix.end());\\n        vector<int> suffixIndexes = search(suffixRoot, suffix);\\n        \\n\\t\\t// Find the first intersection index from last\\n\\t\\t// Since from last we will get the largest index \\n\\t\\t// in case if there are multiple valid words \\n        int i = prefixIndexes.size()-1, j = suffixIndexes.size()-1;\\n        while(i>=0 && j>=0) {\\n            int a = prefixIndexes[i], b = suffixIndexes[j];\\n            if(a == b) return a;\\n            else (a < b) ? j-- : i--;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nstruct Node {\\n    Node* arr[27];\\n    int index = -1;\\n    \\n    bool contains(char ch) {\\n        return arr[ch-\\'a\\'] != NULL;\\n    }\\n    \\n    void put(char ch, Node* newNode) {\\n        arr[ch-\\'a\\'] = newNode;\\n    }\\n    \\n    Node* getNext(char ch) {\\n        return arr[ch-\\'a\\'];\\n    }\\n    \\n    void setIndex(int idx) {\\n        index = idx;\\n    }\\n    \\n    int getIndex() {\\n        return index;\\n    }\\n};\\n\\nclass WordFilter {\\n    Node* trie;\\npublic:\\n    \\n    void insert(Node* root, string& s, int idx) {\\n        for(auto& ch : s) {\\n            if(!root->contains(ch)) {\\n                root->put(ch, new Node());\\n            }\\n            root = root->getNext(ch);\\n            root->setIndex(idx);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        trie = new Node();\\n        \\n        int idx = 0;\\n        string s = \"\";\\n        \\n        for(auto& word : words) {\\n            s = \"{\" + word;\\n            insert(trie, s, idx);\\n            \\n            for(int i=word.size()-1; i>=0; i--) {\\n                s = word[i] + s;\\n                insert(trie, s, idx);\\n            }\\n            \\n            idx++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        Node* temp = trie;\\n        \\n        string match = suffix + \"{\" + prefix;\\n        \\n        for(auto& ch : match) {\\n            if(!temp || !temp->contains(ch)) return -1;\\n            temp = temp->getNext(ch);\\n        }\\n        \\n        return temp->getIndex();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164224,
                "title": "prefix-and-suffix-search",
                "content": "```\\nclass WordFilter {\\n    HashMap<String, Integer> mp;\\n\\n    public WordFilter(String[] words) {\\n        mp = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n\\n                String prefix = words[i].substring(0, j + 1);\\n\\n                for (int k = words[i].length() - 1; k > -1; k--) {\\n\\n                    String suffix = words[i].substring(k);\\n                    mp.put(prefix + \"#\" + suffix, i);\\n                }\\n            }\\n        }\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n  \\n        return mp.getOrDefault(prefix + \"#\" + suffix, -1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordFilter {\\n    HashMap<String, Integer> mp;\\n\\n    public WordFilter(String[] words) {\\n        mp = new HashMap<>();\\n        for (int i = 0; i < words.length; i++) {\\n            for (int j = 0; j < words[i].length(); j++) {\\n\\n                String prefix = words[i].substring(0, j + 1);\\n\\n                for (int k = words[i].length() - 1; k > -1; k--) {\\n\\n                    String suffix = words[i].substring(k);\\n                    mp.put(prefix + \"#\" + suffix, i);\\n                }\\n            }\\n        }\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n  \\n        return mp.getOrDefault(prefix + \"#\" + suffix, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186309,
                "title": "python-dictionary-solution-with-explanation-complexity-analysis",
                "content": "I don\\'t think weighed trie is necessary for this scenario. Since we don\\'t care about candidates other than first one for each search. Thus, we can just prepare all possible searches with corresponding result (largest index, if we have multiple). And a dictionary is enough to do so.\\n\\nLoop through words while filling index into our dict with all possible search strings (`suffix+\\'#\\'+prefix`).\\nFor words with same search string, we will fill in the higher index since we are looping from lower to higher `i`\\n\\nAfterwards, look up time is O(1)\\n\\n```python\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.wordIndexDict = {}\\n        for i, word in enumerate(words):\\n            # build and insert prefix+suffix string\\n            # generate all matching searchStrings\\n            for suffixStart in range(len(word),-1,-1):\\n                for prefixEnd in range(len(word)+1):\\n                    currString = word[suffixStart:]+\\'#\\'+word[:prefixEnd]\\n                    # overwrite with larger i\\n                    self.wordIndexDict[currString] = i\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        # build our searchString\\n        searchString = suffix+\\'#\\'+prefix\\n        # find with searchString\\n        if searchString in self.wordIndexDict:\\n            return self.wordIndexDict[searchString]\\n        return -1\\n```\\nSince `1 <= words[i].length <= 10` and `1 <= prefix.length, suffix.length <= 10`. Our triple nested for loop is not that bad\\n  \\n**Complexity Analysis**\\n\\n  \\n\\nTC:O(m*n^2) time takes to build our dict. (m = length of words, n = length of prefix/suffix), since n <= 10, time is not too bad.\\n\\nSC:O(m*n^2) our dict size\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.wordIndexDict = {}\\n        for i, word in enumerate(words):\\n            # build and insert prefix+suffix string\\n            # generate all matching searchStrings\\n            for suffixStart in range(len(word),-1,-1):\\n                for prefixEnd in range(len(word)+1):\\n                    currString = word[suffixStart:]+\\'#\\'+word[:prefixEnd]\\n                    # overwrite with larger i\\n                    self.wordIndexDict[currString] = i\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        # build our searchString\\n        searchString = suffix+\\'#\\'+prefix\\n        # find with searchString\\n        if searchString in self.wordIndexDict:\\n            return self.wordIndexDict[searchString]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164886,
                "title": "python-faster-than-96-no-trie-hash-map",
                "content": "We store all possible prefixes and suffixes for a word in respective dictionaries. Let us understan for the word [\"apple\", \"app\"]\\n```py\\nprefixes = {\\n\\t\\t\\t  \"a\" : {\"apple\", \"app\"},\\n\\t\\t\\t  \"ap\" : {\"apple\", \"app\"},\\n\\t\\t\\t  \"app\" : {\"apple\", \"app\"},\\n\\t\\t\\t  \"appl\" : {\"apple\"},\\n\\t\\t\\t  \"apple\" : {\"apple\"}\\n\\t\\t\\t}\\n\\nsuffixes = {\\n\\t\\t\\t  \"e\" : {\"apple\"},\\n\\t\\t\\t  \"le\" : {\"apple\"},\\n\\t\\t\\t  \"ple\" : {\"apple\"},\\n\\t\\t\\t  \"pple\" : {\"apple\"},\\n\\t\\t\\t  \"apple\" : {\"apple\"},\\n\\t\\t\\t  \"p\" : {\"app\"},\\n\\t\\t\\t  \"pp\" : {\"app\"},\\n\\t\\t\\t  \"app\" : {\"app\"}\\n\\t\\t\\t}\\n```\\n\\nNow for any ```prefix``` and a ```suffix``` we take all words that are both in ```prefixes[prefix]``` and ```suffixes[suffix]```.\\nWe return the maximum index of those words and if there are no common words, we return -1.\\n\\n```py\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        prefixes = defaultdict(set)\\n        suffixes = defaultdict(set)\\n        indices = defaultdict(int)\\n        \\n\\t\\t# Storing Indices\\n        for ind, word in enumerate(words):\\n            indices[word] = ind\\n            \\n            prefix = \"\"\\n            suffix = \"\"\\n            \\n\\t\\t\\t# Storing all prefixes\\n            for char in word:\\n                prefix += char\\n                prefixes[prefix].add(word)\\n            \\n\\t\\t\\t#Storing all suffixes\\n            for char in word[::-1]:\\n                suffix = char + suffix\\n                suffixes[suffix].add(word)\\n        \\n        self.prefixes = prefixes\\n        self.suffixes = suffixes\\n        self.indices = indices\\n                \\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefixes = self.prefixes\\n        suffixes = self.suffixes\\n        indices = self.indices\\n        \\n\\t\\t# intersection of prefixes[prefix] and suffixes[suffix]\\n        common_words = prefixes[prefix] & suffixes[suffix]\\n        \\n        max_index = -1\\n        for word in common_words:\\n            max_index = max(max_index, indices[word])\\n        \\n        return max_index\\n\\n```",
                "solutionTags": [],
                "code": "```py\\nprefixes = {\\n\\t\\t\\t  \"a\" : {\"apple\", \"app\"},\\n\\t\\t\\t  \"ap\" : {\"apple\", \"app\"},\\n\\t\\t\\t  \"app\" : {\"apple\", \"app\"},\\n\\t\\t\\t  \"appl\" : {\"apple\"},\\n\\t\\t\\t  \"apple\" : {\"apple\"}\\n\\t\\t\\t}\\n\\nsuffixes = {\\n\\t\\t\\t  \"e\" : {\"apple\"},\\n\\t\\t\\t  \"le\" : {\"apple\"},\\n\\t\\t\\t  \"ple\" : {\"apple\"},\\n\\t\\t\\t  \"pple\" : {\"apple\"},\\n\\t\\t\\t  \"apple\" : {\"apple\"},\\n\\t\\t\\t  \"p\" : {\"app\"},\\n\\t\\t\\t  \"pp\" : {\"app\"},\\n\\t\\t\\t  \"app\" : {\"app\"}\\n\\t\\t\\t}\\n```\n```prefix```\n```suffix```\n```prefixes[prefix]```\n```suffixes[suffix]```\n```py\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        prefixes = defaultdict(set)\\n        suffixes = defaultdict(set)\\n        indices = defaultdict(int)\\n        \\n\\t\\t# Storing Indices\\n        for ind, word in enumerate(words):\\n            indices[word] = ind\\n            \\n            prefix = \"\"\\n            suffix = \"\"\\n            \\n\\t\\t\\t# Storing all prefixes\\n            for char in word:\\n                prefix += char\\n                prefixes[prefix].add(word)\\n            \\n\\t\\t\\t#Storing all suffixes\\n            for char in word[::-1]:\\n                suffix = char + suffix\\n                suffixes[suffix].add(word)\\n        \\n        self.prefixes = prefixes\\n        self.suffixes = suffixes\\n        self.indices = indices\\n                \\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefixes = self.prefixes\\n        suffixes = self.suffixes\\n        indices = self.indices\\n        \\n\\t\\t# intersection of prefixes[prefix] and suffixes[suffix]\\n        common_words = prefixes[prefix] & suffixes[suffix]\\n        \\n        max_index = -1\\n        for word in common_words:\\n            max_index = max(max_index, indices[word])\\n        \\n        return max_index\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119580,
                "title": "python-using-trie-with-explanation",
                "content": "the idea is to build a trie with each suffix of the word followed by # + word\\n\\nexample for apple we will insert all of these suffix + \\'#\\' + word combinations:\\napple = \\'#apple\\', \\'e#apple\\', \\'le#apple\\', \\'ple#apple\\', \\'pple#apple\\', \\'apple#apple\\'\\n\\nnow when prefix = \\'ap\\' and suffix = \\'le\\' we will search for \\'le#ap\\'\\n\\n```\\nclass Trie:\\n    def __init__(self):\\n        self.children = {}\\n        self.idx = -1\\n\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        \"\"\"\\n        self.trie = Trie()\\n        \\n        for idx, word in enumerate(words):\\n            self.addWord(idx, word)\\n    \\n    def addWord(self, idx, word):\\n        for i in range(len(word)-1, -2, -1):\\n            newString = word[i+1:] + \\'#\\' + word\\n            node = self.trie\\n            node.idx = idx\\n            \\n            for letter in newString:\\n                if letter not in node.children:\\n                    node.children[letter] = Trie()\\n                node = node.children[letter]\\n                node.idx = idx\\n        \\n\\n    def f(self, prefix, suffix):\\n        \"\"\"\\n        :type prefix: str\\n        :type suffix: str\\n        :rtype: int\\n        \"\"\"\\n        node = self.trie\\n        newString = suffix + \\'#\\' + prefix\\n        \\n        for letter in newString:\\n            if letter not in node.children:\\n                return -1\\n            node = node.children[letter]\\n        \\n        return node.idx\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Trie:\\n    def __init__(self):\\n        self.children = {}\\n        self.idx = -1\\n\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        \"\"\"\\n        self.trie = Trie()\\n        \\n        for idx, word in enumerate(words):\\n            self.addWord(idx, word)\\n    \\n    def addWord(self, idx, word):\\n        for i in range(len(word)-1, -2, -1):\\n            newString = word[i+1:] + \\'#\\' + word\\n            node = self.trie\\n            node.idx = idx\\n            \\n            for letter in newString:\\n                if letter not in node.children:\\n                    node.children[letter] = Trie()\\n                node = node.children[letter]\\n                node.idx = idx\\n        \\n\\n    def f(self, prefix, suffix):\\n        \"\"\"\\n        :type prefix: str\\n        :type suffix: str\\n        :rtype: int\\n        \"\"\"\\n        node = self.trie\\n        newString = suffix + \\'#\\' + prefix\\n        \\n        for letter in newString:\\n            if letter not in node.children:\\n                return -1\\n            node = node.children[letter]\\n        \\n        return node.idx\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110064,
                "title": "what-does-the-test-case-mean",
                "content": "Hello, \\n\\nMay I ask what does the following test case mean?\\n\\n```\\nInput:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n```\\n\\nI think it would be using words [\"apple\"] to initialize the word filter, \\nthen find word with prefix \"a\" and suffix \"e\". \\nBut why is the expected result so long a list?\\n\\nThanks in advance.",
                "solutionTags": [],
                "code": "```\\nInput:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2164923,
                "title": "python-dictionary-solution-prefix-suffix-solution-simple",
                "content": "For every word we can create a key in the hashmap like this : **Prefix#Suffix**\\n\\nThis will combine both the prefix and suffix of the word in a single key and we will generate all possible combinations of prefix and suffix.\\nStore the index of the word in the value of the key. This will help us to find the exact word in the dictionary.\\n\\n**Thats it !**\\n\\n```` \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d = {}\\n        #iterate over each word \\n        for w in range(len(words)):\\n            word = words[w]\\n            # now we will form every suffix#prefix combination and we will use it as the key for respective word\\n            \\n            for j in range(len(word)-1 , -1 , -1): # for suffix\\n                \\n                for i in range(len(word)): # for prefix\\n                    \\n                    currS = word[:i+1] + \"#\" + word[len(word)-j-1:]  # \"prefix#suffix\"\\n                    self.d[currS] = w        # w = index \\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        if (prefix + \"#\" + suffix) not in self.d:\\n            return -1\\n        \\n        return self.d[(prefix + \"#\" + suffix)]\\n\\n````\\n**Just read out the comments at every step **\\n\\n**Happy Coding !!**",
                "solutionTags": [
                    "Python",
                    "Suffix Array"
                ],
                "code": "```` \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d = {}\\n        #iterate over each word \\n        for w in range(len(words)):\\n            word = words[w]\\n            # now we will form every suffix#prefix combination and we will use it as the key for respective word\\n            \\n            for j in range(len(word)-1 , -1 , -1): # for suffix\\n                \\n                for i in range(len(word)): # for prefix\\n                    \\n                    currS = word[:i+1] + \"#\" + word[len(word)-j-1:]  # \"prefix#suffix\"\\n                    self.d[currS] = w        # w = index \\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        if (prefix + \"#\" + suffix) not in self.d:\\n            return -1\\n        \\n        return self.d[(prefix + \"#\" + suffix)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164193,
                "title": "python-easy-solution-hashmaps-dictionary-runtime-94-80-memory-62-39",
                "content": "Basically for each word I am calculating possible prefix and suffix and storing them as keys in hashmap ans values are the indices of those words,\\nonce this preprocessing is done, all we need to do is simply\\ncheck if both prefix and suffix are present and in case they are, just iterate over prefixmap and check if the same index is present in suffixmap, return the largest such index,\\nadded optimisation, storing previous queries in cache\\n```\\n\\nclass WordFilter:\\n    \\n    def __init__(self, words: List[str]):\\n        self.prefixes={}\\n        self.suffixes ={}\\n        self.cache ={}\\n        \\n        \\n        for i,word in enumerate(words):\\n            self.addw(i,word)\\n        \\n    def addw(self,ind,word):\\n\\t# store all possible prefixes\\n        for i in range(1,len(word)+1):\\n            if word[:i] in self.prefixes:\\n                self.prefixes[word[:i]][ind]=ind\\n            else:\\n                self.prefixes[word[:i]]={ind:ind}\\n\\t\\t\\t\\t\\n\\t\\t# store all possible suffixes\\n        for i in range(len(word)-1,-1,-1):\\n            if word[i:] in self.suffixes:\\n                self.suffixes[word[i:]][ind]=ind\\n            else:\\n                self.suffixes[word[i:]]={ind:ind}\\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        \\n        if (suffix,prefix) in self.cache:\\n            return self.cache[(suffix,prefix)]\\n        \\n        if prefix not in self.prefixes or suffix not in self.suffixes:\\n            return -1\\n        \\n        mmax = -1\\n        \\n        if len(self.prefixes[prefix])<len(self.suffixes[suffix]):\\n            for i in self.prefixes[prefix]:\\n                if i in self.suffixes[suffix]:\\n                    print(i)\\n                    mmax = max(mmax,i)\\n                    \\n        else:\\n            for i in self.suffixes[suffix]:\\n                if i in self.prefixes[prefix]:\\n                    mmax = max(mmax,i)\\n                    \\n        self.cache[(suffix,prefix)] = mmax\\n        return mmax\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass WordFilter:\\n    \\n    def __init__(self, words: List[str]):\\n        self.prefixes={}\\n        self.suffixes ={}\\n        self.cache ={}\\n        \\n        \\n        for i,word in enumerate(words):\\n            self.addw(i,word)\\n        \\n    def addw(self,ind,word):\\n\\t# store all possible prefixes\\n        for i in range(1,len(word)+1):\\n            if word[:i] in self.prefixes:\\n                self.prefixes[word[:i]][ind]=ind\\n            else:\\n                self.prefixes[word[:i]]={ind:ind}\\n\\t\\t\\t\\t\\n\\t\\t# store all possible suffixes\\n        for i in range(len(word)-1,-1,-1):\\n            if word[i:] in self.suffixes:\\n                self.suffixes[word[i:]][ind]=ind\\n            else:\\n                self.suffixes[word[i:]]={ind:ind}\\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        \\n        if (suffix,prefix) in self.cache:\\n            return self.cache[(suffix,prefix)]\\n        \\n        if prefix not in self.prefixes or suffix not in self.suffixes:\\n            return -1\\n        \\n        mmax = -1\\n        \\n        if len(self.prefixes[prefix])<len(self.suffixes[suffix]):\\n            for i in self.prefixes[prefix]:\\n                if i in self.suffixes[suffix]:\\n                    print(i)\\n                    mmax = max(mmax,i)\\n                    \\n        else:\\n            for i in self.suffixes[suffix]:\\n                if i in self.prefixes[prefix]:\\n                    mmax = max(mmax,i)\\n                    \\n        self.cache[(suffix,prefix)] = mmax\\n        return mmax\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156496,
                "title": "clean-c-code-one-trie-solution-standard-approach-of-trie-no-tle",
                "content": "**One Trie Solution Using Standard Approach of Trie**\\nIt passes all test cases successfully\\n**NO TLE**\\n```\\nclass TrieNode{\\npublic :\\n    \\n    vector<TrieNode*>children;\\n    int index;\\n    \\n    TrieNode(){\\n        children = vector<TrieNode*>(27, NULL);\\n        index = -1;\\n    }\\n    // create destructor to avoid any memory leak\\n    ~TrieNode(){\\n        for (int i = 0; i < 26; i++) {\\n            if (children[i]) {\\n                delete children[i];\\n            }\\n        }\\n    }\\n};\\n\\n// Class to do the basic operations like insert, searching etc.\\nclass Trie{\\npublic:\\n    \\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string &s, int idx)\\n    {        \\n        TrieNode* cur = root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(cur->children[s[i]-\\'a\\'] == NULL)\\n                cur->children[s[i]-\\'a\\'] = new TrieNode();\\n            \\n            cur = cur->children[s[i]-\\'a\\'];\\n            cur->index = idx;\\n        }\\n    }\\n    \\n    int search(string &word)\\n    {\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            cur = cur->children[word[i] - \\'a\\'];\\n            if(!cur) \\n                return -1;\\n        }\\n        return cur->index;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:    \\n    \\n    Trie *trie = new Trie();\\n    WordFilter(vector<string>& words) \\n    {    \\n        int idx = 0;\\n        string s = \"\";\\n        \\n        for(auto &word : words) \\n        {\\n            s = \"{\" + word;\\n            trie->insert(s, idx);\\n            \\n            for(int i=word.size()-1; i>=0; i--) \\n            {\\n                s = word[i] + s;\\n                trie->insert(s, idx);\\n            }\\n            idx++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string match = suffix + \"{\" + prefix;\\n        int ansIdx = trie->search(match);\\n        return ansIdx;\\n    }\\n};\\n```\\n\\n----\\nOnly for learning purpose that how it can be implemented\\n**Bonus : 2 Trie Solution** \\nIt gives TLE :  12/13 TEST CASES passed, but gives TLE on 13th TC\\n```\\nclass TrieNode{\\npublic :\\n    \\n    vector<int> idx_list;\\n    bool isEnd;\\n    vector<TrieNode*>children;\\n    TrieNode(){\\n        children = vector<TrieNode*>(26,NULL);\\n        isEnd = false;\\n    }\\n    // create destructor to avoid any memory leak\\n    ~TrieNode(){\\n        for (int i = 0; i < 26; i++) {\\n            if (children[i]) {\\n                delete children[i];\\n            }\\n        }\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    \\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string &s, int idx)\\n    {\\n        root->idx_list.push_back(idx); // To Deal with empty string case\\n        \\n        TrieNode* cur = root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(cur->children[s[i]-\\'a\\'] == NULL)\\n                cur->children[s[i]-\\'a\\'] = new TrieNode();\\n            cur = cur->children[s[i]-\\'a\\'];\\n            \\n            cur->idx_list.push_back(idx);\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    vector<int> search(string &word)\\n    {\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            cur = cur->children[word[i] - \\'a\\'];\\n            if(!cur) \\n                return {};\\n        }\\n        return cur->idx_list;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    \\n    // Using 2 Trie\\n    Trie* forward = new Trie();\\n    Trie* backward = new Trie();\\n    WordFilter(vector<string>& words) \\n    {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            forward->insert(words[i], i);\\n            reverse(words[i].begin(), words[i].end());\\n            backward->insert(words[i], i);\\n        }\\n    }\\n    \\n    // Dry run for input \\n    // dictionary = [\"apple\"], prefix = \"ap\", suffix = \"le\" \\n    int f(string prefix, string suffix) \\n    {\\n        vector<int> pre = forward->search(prefix);\\n        reverse(suffix.begin(), suffix.end()); // suffix = \"el\"\\n        vector<int> post = backward->search(suffix);\\n        \\n        int i = pre.size() - 1;\\n        int j = post.size() - 1;\\n        // start from last, because we want largest index\\n        while(i >= 0 && j >= 0)\\n        {\\n            if(pre[i] == post[j]) \\n                return pre[i]; // largest index out of all valid equal indices\\n            else if(pre[i] > post[j]) \\n                i--;\\n            else \\n                j--;\\n        }\\n        return -1;    \\n    }\\n};\\n```\\n***Thanks for upvoting !***\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie",
                    "Suffix Array"
                ],
                "code": "```\\nclass TrieNode{\\npublic :\\n    \\n    vector<TrieNode*>children;\\n    int index;\\n    \\n    TrieNode(){\\n        children = vector<TrieNode*>(27, NULL);\\n        index = -1;\\n    }\\n    // create destructor to avoid any memory leak\\n    ~TrieNode(){\\n        for (int i = 0; i < 26; i++) {\\n            if (children[i]) {\\n                delete children[i];\\n            }\\n        }\\n    }\\n};\\n\\n// Class to do the basic operations like insert, searching etc.\\nclass Trie{\\npublic:\\n    \\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n\\n    void insert(string &s, int idx)\\n    {        \\n        TrieNode* cur = root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(cur->children[s[i]-\\'a\\'] == NULL)\\n                cur->children[s[i]-\\'a\\'] = new TrieNode();\\n            \\n            cur = cur->children[s[i]-\\'a\\'];\\n            cur->index = idx;\\n        }\\n    }\\n    \\n    int search(string &word)\\n    {\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            cur = cur->children[word[i] - \\'a\\'];\\n            if(!cur) \\n                return -1;\\n        }\\n        return cur->index;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:    \\n    \\n    Trie *trie = new Trie();\\n    WordFilter(vector<string>& words) \\n    {    \\n        int idx = 0;\\n        string s = \"\";\\n        \\n        for(auto &word : words) \\n        {\\n            s = \"{\" + word;\\n            trie->insert(s, idx);\\n            \\n            for(int i=word.size()-1; i>=0; i--) \\n            {\\n                s = word[i] + s;\\n                trie->insert(s, idx);\\n            }\\n            idx++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string match = suffix + \"{\" + prefix;\\n        int ansIdx = trie->search(match);\\n        return ansIdx;\\n    }\\n};\\n```\n```\\nclass TrieNode{\\npublic :\\n    \\n    vector<int> idx_list;\\n    bool isEnd;\\n    vector<TrieNode*>children;\\n    TrieNode(){\\n        children = vector<TrieNode*>(26,NULL);\\n        isEnd = false;\\n    }\\n    // create destructor to avoid any memory leak\\n    ~TrieNode(){\\n        for (int i = 0; i < 26; i++) {\\n            if (children[i]) {\\n                delete children[i];\\n            }\\n        }\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    \\n    TrieNode* root;\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string &s, int idx)\\n    {\\n        root->idx_list.push_back(idx); // To Deal with empty string case\\n        \\n        TrieNode* cur = root;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(cur->children[s[i]-\\'a\\'] == NULL)\\n                cur->children[s[i]-\\'a\\'] = new TrieNode();\\n            cur = cur->children[s[i]-\\'a\\'];\\n            \\n            cur->idx_list.push_back(idx);\\n        }\\n        cur->isEnd = true;\\n    }\\n    \\n    vector<int> search(string &word)\\n    {\\n        TrieNode* cur = root;\\n        for(int i = 0; i < word.size(); i++){\\n            cur = cur->children[word[i] - \\'a\\'];\\n            if(!cur) \\n                return {};\\n        }\\n        return cur->idx_list;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    \\n    // Using 2 Trie\\n    Trie* forward = new Trie();\\n    Trie* backward = new Trie();\\n    WordFilter(vector<string>& words) \\n    {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            forward->insert(words[i], i);\\n            reverse(words[i].begin(), words[i].end());\\n            backward->insert(words[i], i);\\n        }\\n    }\\n    \\n    // Dry run for input \\n    // dictionary = [\"apple\"], prefix = \"ap\", suffix = \"le\" \\n    int f(string prefix, string suffix) \\n    {\\n        vector<int> pre = forward->search(prefix);\\n        reverse(suffix.begin(), suffix.end()); // suffix = \"el\"\\n        vector<int> post = backward->search(suffix);\\n        \\n        int i = pre.size() - 1;\\n        int j = post.size() - 1;\\n        // start from last, because we want largest index\\n        while(i >= 0 && j >= 0)\\n        {\\n            if(pre[i] == post[j]) \\n                return pre[i]; // largest index out of all valid equal indices\\n            else if(pre[i] > post[j]) \\n                i--;\\n            else \\n                j--;\\n        }\\n        return -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757010,
                "title": "c-explanation-trie-solution-faster-than-98-solution",
                "content": "Consider the word \\'apple\\'. For each suffix of the word, we could insert that suffix, followed by \\'{\\', followed by the word, all into the trie.\\n\\nFor example, we will insert following into trie:\\n```\\n\\'{apple\\', \\n\\'e{apple\\', \\n\\'le{apple\\', \\n\\'ple{apple\\', \\n\\'pple{apple\\', \\n\\'apple{apple\\'\\n```\\n Then for a query like prefix = \"ap\", suffix = \"le\", we can find it by querying our trie for \\n ```\\n \\'le{ap\\'\\n ```\\n\\nThe idea behind the use of \\'{\\' is because it\\'s ASCII value is comes just after \\'z\\'. So, use of \\'{\\' as separator will help in reducing checks for separator.\\n```\\nletter  ASCII code\\n-------------------\\na          97\\nz          122\\n{          123\\n```\\n\\n```\\nclass WordFilter {\\n\\t/*standard trie node to store each character. observe carefully, #child is 27 to accomodate the separator \\'{\\' */\\n    struct node{\\n        int weight;\\n        struct node* child[27];\\n    };\\n    struct node* trie;\\n    \\n\\t/*create new node using malloc and allocate it\\'s weight to be 0 & it\\'s all chils as NULL */\\n    struct node* allocate(){\\n        struct node* ptr = (struct node*)malloc(sizeof(struct node));\\n        ptr->weight = 0;\\n        for(int i=0;i<27;i++){\\n            ptr->child[i] = NULL;\\n        }\\n        return ptr;\\n    }\\n    \\n\\t/*standard insert operation, everytime you insert word in trie, keep on updating the weights*/\\n    void insert(string &word, struct node* root,int weight){\\n        for(int i=0;i<word.length();i++){\\n            int idx = word[i]-\\'a\\';\\n            if(root->child[idx]==NULL)\\n                root->child[idx] = allocate();\\n            root->weight = weight;\\n            root = root->child[idx];\\n        }\\n        root->weight = weight;\\n    }\\npublic:\\n\\n    WordFilter(vector<string>& words) {\\n        trie = allocate();\\n        for(int weight=0;weight<words.size();weight++){\\n\\t\\t\\n            string str = words[weight];\\n            string word = \"{\" + str;\\n            insert(word,trie,weight);\\n\\t\\t\\t\\n            for(int i=str.length()-1;i>=0;i--){\\n                word = str[i] + word;\\n                insert(word,trie,weight);\\n            }\\n        }        \\n    }\\n\\t\\n    /*standard search operation in trie*/\\n    int f(string prefix, string suffix) {\\n        string word = suffix + \"{\" + prefix;\\n        struct node* root = trie;\\n\\t\\t\\n        for(int i=0;i<word.length();i++){\\n            int idx = word[i] - \\'a\\';\\n            if(root->child[idx] == NULL)\\n                return -1;\\n            root = root->child[idx];\\n        }\\n        return root->weight;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\'{apple\\', \\n\\'e{apple\\', \\n\\'le{apple\\', \\n\\'ple{apple\\', \\n\\'pple{apple\\', \\n\\'apple{apple\\'\\n```\n```\\n \\'le{ap\\'\\n ```\n```\\nletter  ASCII code\\n-------------------\\na          97\\nz          122\\n{          123\\n```\n```\\nclass WordFilter {\\n\\t/*standard trie node to store each character. observe carefully, #child is 27 to accomodate the separator \\'{\\' */\\n    struct node{\\n        int weight;\\n        struct node* child[27];\\n    };\\n    struct node* trie;\\n    \\n\\t/*create new node using malloc and allocate it\\'s weight to be 0 & it\\'s all chils as NULL */\\n    struct node* allocate(){\\n        struct node* ptr = (struct node*)malloc(sizeof(struct node));\\n        ptr->weight = 0;\\n        for(int i=0;i<27;i++){\\n            ptr->child[i] = NULL;\\n        }\\n        return ptr;\\n    }\\n    \\n\\t/*standard insert operation, everytime you insert word in trie, keep on updating the weights*/\\n    void insert(string &word, struct node* root,int weight){\\n        for(int i=0;i<word.length();i++){\\n            int idx = word[i]-\\'a\\';\\n            if(root->child[idx]==NULL)\\n                root->child[idx] = allocate();\\n            root->weight = weight;\\n            root = root->child[idx];\\n        }\\n        root->weight = weight;\\n    }\\npublic:\\n\\n    WordFilter(vector<string>& words) {\\n        trie = allocate();\\n        for(int weight=0;weight<words.size();weight++){\\n\\t\\t\\n            string str = words[weight];\\n            string word = \"{\" + str;\\n            insert(word,trie,weight);\\n\\t\\t\\t\\n            for(int i=str.length()-1;i>=0;i--){\\n                word = str[i] + word;\\n                insert(word,trie,weight);\\n            }\\n        }        \\n    }\\n\\t\\n    /*standard search operation in trie*/\\n    int f(string prefix, string suffix) {\\n        string word = suffix + \"{\" + prefix;\\n        struct node* root = trie;\\n\\t\\t\\n        for(int i=0;i<word.length();i++){\\n            int idx = word[i] - \\'a\\';\\n            if(root->child[idx] == NULL)\\n                return -1;\\n            root = root->child[idx];\\n        }\\n        return root->weight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110049,
                "title": "one-trie-o-nl-2-time-and-space-complexity-on-init-o-l-query",
                "content": "For 'ape', revert suffix and insert '*epa', 'a*epa', 'ap*epa', 'ape*epa'.\\n```\\nstruct Trie {\\n    unordered_map<char,Trie*> nxt;\\n    int mx;\\n    \\n    Trie() {\\n        mx = -1;\\n    }\\n    \\n    void add(string w, int x) {\\n        Trie *cur = this;\\n        for (char c:w) {\\n            if (!cur->nxt.count(c)) cur->nxt[c] = new Trie();\\n            cur= cur->nxt[c];\\n            cur->mx = max(cur->mx,x);\\n        }\\n    }\\n    \\n    int f(string w) {\\n        Trie *cur = this;\\n        for (char c:w) {\\n            if (!cur->nxt.count(c)) return -1;\\n            cur= cur->nxt[c];\\n        }\\n        return cur->mx;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie* root;\\n    \\n    WordFilter(vector<string> words) {\\n        root = new Trie();\\n        for (int i = 0; i < words.size(); ++i) {\\n            int m = min(10,(int)words[i].size());\\n            string r = words[i].substr(words[i].size()-m) + \"*\";\\n            reverse(r.begin(),r.end());\\n            string t;\\n            for (int j = 0; j < m; ++j) {\\n                root->add(t + r,i);\\n                t+= words[i][j];\\n            }\\n            root->add(t+r,i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        reverse(suffix.begin(), suffix.end());\\n        return root->f(prefix + \"*\" + suffix);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Trie {\\n    unordered_map<char,Trie*> nxt;\\n    int mx;\\n    \\n    Trie() {\\n        mx = -1;\\n    }\\n    \\n    void add(string w, int x) {\\n        Trie *cur = this;\\n        for (char c:w) {\\n            if (!cur->nxt.count(c)) cur->nxt[c] = new Trie();\\n            cur= cur->nxt[c];\\n            cur->mx = max(cur->mx,x);\\n        }\\n    }\\n    \\n    int f(string w) {\\n        Trie *cur = this;\\n        for (char c:w) {\\n            if (!cur->nxt.count(c)) return -1;\\n            cur= cur->nxt[c];\\n        }\\n        return cur->mx;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie* root;\\n    \\n    WordFilter(vector<string> words) {\\n        root = new Trie();\\n        for (int i = 0; i < words.size(); ++i) {\\n            int m = min(10,(int)words[i].size());\\n            string r = words[i].substr(words[i].size()-m) + \"*\";\\n            reverse(r.begin(),r.end());\\n            string t;\\n            for (int j = 0; j < m; ++j) {\\n                root->add(t + r,i);\\n                t+= words[i][j];\\n            }\\n            root->add(t+r,i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        reverse(suffix.begin(), suffix.end());\\n        return root->f(prefix + \"*\" + suffix);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110066,
                "title": "python-simple-solution",
                "content": "Since the prefix and suffix lengths are small, we can simply use a hash table.\\nFor each word, for all possible combinations of its prefixes and suffixes, we save the result in the hash table.\\n\\n**Time: O(N)**\\nFor each word, we update hash table entries corresponding to up to 121 prefix-suffix combinations.\\n**Space: O(N)**\\nFor each word, we can create at most 121 prefix-suffix keys in the hash table.\\n\\n    class WordFilter:\\n\\n        def __init__(self, words):\\n            \"\"\"\\n            :type words: List[str]\\n            \"\"\"\\n            self.ht = {}\\n\\n            for W, w in enumerate(words):\\n                pre = \"\"\\n                L = len(w)\\n                for i in range(-1, min(10, L)): # first i letters form the prefix\\n                    suf = \"\"\\n                    if i != -1:\\n                        pre += w[i]\\n                    for j in range(-1, min(10, L)): # last j letters form the suffix\\n                        if j != -1:                              \\n                            suf += w[-(j+1)]\\n                        self.ht[pre + \"$\" + suf] = W\\n\\n        def f(self, prefix, suffix):\\n            \"\"\"\\n            :type prefix: str\\n            :type suffix: str\\n            :rtype: int\\n            \"\"\"\\n            key = prefix + \"$\" + suffix[::-1]\\n            if key not in self.ht:\\n                return -1\\n            return self.ht[key]",
                "solutionTags": [],
                "code": "Since the prefix and suffix lengths are small, we can simply use a hash table.\\nFor each word, for all possible combinations of its prefixes and suffixes, we save the result in the hash table.\\n\\n**Time: O(N)**\\nFor each word, we update hash table entries corresponding to up to 121 prefix-suffix combinations.\\n**Space: O(N)**\\nFor each word, we can create at most 121 prefix-suffix keys in the hash table.\\n\\n    class WordFilter:\\n\\n        def __init__(self, words):\\n            \"\"\"\\n            :type words: List[str]\\n            \"\"\"\\n            self.ht = {}\\n\\n            for W, w in enumerate(words):\\n                pre = \"\"\\n                L = len(w)\\n                for i in range(-1, min(10, L)): # first i letters form the prefix\\n                    suf = \"\"\\n                    if i != -1:\\n                        pre += w[i]\\n                    for j in range(-1, min(10, L)): # last j letters form the suffix\\n                        if j != -1:                              \\n                            suf += w[-(j+1)]\\n                        self.ht[pre + \"$\" + suf] = W\\n\\n        def f(self, prefix, suffix):\\n            \"\"\"\\n            :type prefix: str\\n            :type suffix: str\\n            :rtype: int\\n            \"\"\"\\n            key = prefix + \"$\" + suffix[::-1]\\n            if key not in self.ht:\\n                return -1\\n            return self.ht[key]",
                "codeTag": "Java"
            },
            {
                "id": 2165590,
                "title": "c-using-hashmap-simple-explained-daily-leetcoding-challenge-june-day-18",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> mp; //stores preffix and suffix sequence in it\\n    \\n    WordFilter(vector<string>& words) \\n    {\\n        int n = words.size();\\n        \\n        for(int i=0; i<n; i++) //cover each word in words\\n        {\\n            string word = words[i]; \\n            int wordsize = word.size();\\n            \\n            //storing all possible sequence of prefix and suffix of a word in the hashmap\\n            for(int j=1; j<=wordsize; j++) //for preffix \\n            {\\n                string pre = word.substr(0,j);\\n                \\n                for(int k=0; k<wordsize; k++) //for suffix\\n                {\\n                    string suff = word.substr(k, wordsize);\\n                    mp[pre + \"|\" + suff] = i+1; //set index i+1 for all possible sequence of a word\\n                    //we set i+1 to handle i=0 because by-default map initialized with 0 \\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) \\n    {\\n        string s = prefix + \"|\" + suffix;\\n        return mp[s]-1; //if sequence found in hashmap we return its index\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> mp; //stores preffix and suffix sequence in it\\n    \\n    WordFilter(vector<string>& words) \\n    {\\n        int n = words.size();\\n        \\n        for(int i=0; i<n; i++) //cover each word in words\\n        {\\n            string word = words[i]; \\n            int wordsize = word.size();\\n            \\n            //storing all possible sequence of prefix and suffix of a word in the hashmap\\n            for(int j=1; j<=wordsize; j++) //for preffix \\n            {\\n                string pre = word.substr(0,j);\\n                \\n                for(int k=0; k<wordsize; k++) //for suffix\\n                {\\n                    string suff = word.substr(k, wordsize);\\n                    mp[pre + \"|\" + suff] = i+1; //set index i+1 for all possible sequence of a word\\n                    //we set i+1 to handle i=0 because by-default map initialized with 0 \\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) \\n    {\\n        string s = prefix + \"|\" + suffix;\\n        return mp[s]-1; //if sequence found in hashmap we return its index\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185417,
                "title": "rust-trie-solution",
                "content": "```rust\\n#[derive(Default)]\\nstruct Trie {\\n    index: i32,\\n    childlen: [Option<Box<Trie>>; 27],\\n}\\n\\nstruct WordFilter {\\n    trie: Trie,\\n}\\n\\nimpl WordFilter {\\n\\n    fn new(words: Vec<String>) -> Self {\\n        let mut trie = Trie::default();\\n        for (i, word) in words.iter().enumerate() {\\n            let s = String::new() + &word + \"{\" + &word;\\n            for j in 0..word.len() {\\n                let mut node = &mut trie;\\n                for &b in &s.as_bytes()[j..] {\\n                    node = node.childlen[(b - b\\'a\\') as usize].get_or_insert_with(Default::default);\\n                    node.index = i as i32;\\n                }\\n            }\\n        }\\n        Self { trie }\\n    }\\n    \\n    fn f(&self, prefix: String, suffix: String) -> i32 {\\n        let mut node = &self.trie;\\n        let s = String::new() + &suffix + \"{\" + &prefix;\\n        for &b in s.as_bytes() {\\n            if let Some(n) = &node.childlen[(b - b\\'a\\') as usize] {\\n                node = n.as_ref();\\n            } else {\\n                return -1;\\n            }\\n        }\\n        node.index\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Trie"
                ],
                "code": "```rust\\n#[derive(Default)]\\nstruct Trie {\\n    index: i32,\\n    childlen: [Option<Box<Trie>>; 27],\\n}\\n\\nstruct WordFilter {\\n    trie: Trie,\\n}\\n\\nimpl WordFilter {\\n\\n    fn new(words: Vec<String>) -> Self {\\n        let mut trie = Trie::default();\\n        for (i, word) in words.iter().enumerate() {\\n            let s = String::new() + &word + \"{\" + &word;\\n            for j in 0..word.len() {\\n                let mut node = &mut trie;\\n                for &b in &s.as_bytes()[j..] {\\n                    node = node.childlen[(b - b\\'a\\') as usize].get_or_insert_with(Default::default);\\n                    node.index = i as i32;\\n                }\\n            }\\n        }\\n        Self { trie }\\n    }\\n    \\n    fn f(&self, prefix: String, suffix: String) -> i32 {\\n        let mut node = &self.trie;\\n        let s = String::new() + &suffix + \"{\" + &prefix;\\n        for &b in s.as_bytes() {\\n            if let Some(n) = &node.childlen[(b - b\\'a\\') as usize] {\\n                node = n.as_ref();\\n            } else {\\n                return -1;\\n            }\\n        }\\n        node.index\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1081313,
                "title": "c-no-extra-functions-simply-explained",
                "content": "We will have a trie to store the given strings in a special way to identify them.\\n\\nSPECIAL WAY ::\\n\"apple\" is stored as ->\\na * apple\\nap * apple\\napp * apple\\nappl * apple\\napple * apple\\n\\nby this special way we can identify every suffix continued by its orginal word.\\nso we can directly search for \"suffix * prefix\" . and we will store index in every trie node of particular string. \\nSo, that every time we encounter same type of words. highest idex will be overriden on before index.\\n\\n```\\nclass trie{\\n    public:\\n    unordered_map<char,trie*> map;\\n    bool isEnd=false;\\n    int pos=-1;\\n};\\nclass WordFilter {\\npublic:\\n    trie* root;    \\n    WordFilter(vector<string>& words) {\\n        root = new trie();\\n        int j,p=0;\\n        for(auto st : words)\\n        {\\n            for(int j=0;j<st.size();j++)\\n            {\\n                auto hey=root;\\n                string nw=st.substr(j,st.size()-j);\\n                nw+=\\'*\\';nw+=st;\\n                for(auto c: nw)\\n                {\\n                    if(!hey->map[c]) hey->map[c]=new trie();\\n                    hey=hey->map[c];hey->pos=p;\\n                }\\n                hey->isEnd=true;\\n            }\\n           ++p;\\n        }\\n       \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n       \\n        trie* hey = root;\\n        suffix+=\\'*\\';\\n        suffix+=prefix;\\n        for(auto c: suffix)\\n        {\\n            if(!hey->map[c]) return -1;\\n            hey=hey->map[c];\\n        }\\n        return hey->pos;   \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "We will have a trie to store the given strings in a special way to identify them.\\n\\nSPECIAL WAY ::\\n\"apple\" is stored as ->\\na * apple\\nap * apple\\napp * apple\\nappl * apple\\napple * apple\\n\\nby this special way we can identify every suffix continued by its orginal word.\\nso we can directly search for \"suffix * prefix\" . and we will store index in every trie node of particular string. \\nSo, that every time we encounter same type of words. highest idex will be overriden on before index.\\n\\n```\\nclass trie{\\n    public:\\n    unordered_map<char,trie*> map;\\n    bool isEnd=false;\\n    int pos=-1;\\n};\\nclass WordFilter {\\npublic:\\n    trie* root;    \\n    WordFilter(vector<string>& words) {\\n        root = new trie();\\n        int j,p=0;\\n        for(auto st : words)\\n        {\\n            for(int j=0;j<st.size();j++)\\n            {\\n                auto hey=root;\\n                string nw=st.substr(j,st.size()-j);\\n                nw+=\\'*\\';nw+=st;\\n                for(auto c: nw)\\n                {\\n                    if(!hey->map[c]) hey->map[c]=new trie();\\n                    hey=hey->map[c];hey->pos=p;\\n                }\\n                hey->isEnd=true;\\n            }\\n           ++p;\\n        }\\n       \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n       \\n        trie* hey = root;\\n        suffix+=\\'*\\';\\n        suffix+=prefix;\\n        for(auto c: suffix)\\n        {\\n            if(!hey->map[c]) return -1;\\n            hey=hey->map[c];\\n        }\\n        return hey->pos;   \\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2164553,
                "title": "easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity : O(N * size of word * size of word) for making key value pair && O(size of word) for finding index of word in dictionary***\\n\\n* ***Space Complexity : O(N * size of word)***\\n\\n```\\nFor every prefix of a word make a key, concatanating with suffix and insert into map\\n```\\n\\n```\\nclass WordFilter {\\npublic:\\n    \\n    unordered_map<string, int> mp;\\n    \\n    WordFilter(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string word = words[i];\\n            \\n            for(int j = 0; j < word.size(); j++)\\n            {\\n                string prefix = word.substr(0, j + 1);\\n                \\n                for(int k = word.size() - 1; k >= 0; k--)\\n                {\\n                    string suffix = word.substr(k);\\n                    \\n                    string key = prefix + \"#\" + suffix;\\n                    \\n                    mp[key] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string key = prefix + \"#\" + suffix;\\n        \\n        if(mp.count(key))\\n        {\\n            return mp[key];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nFor every prefix of a word make a key, concatanating with suffix and insert into map\\n```\n```\\nclass WordFilter {\\npublic:\\n    \\n    unordered_map<string, int> mp;\\n    \\n    WordFilter(vector<string>& words) {\\n        \\n        int n = words.size();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string word = words[i];\\n            \\n            for(int j = 0; j < word.size(); j++)\\n            {\\n                string prefix = word.substr(0, j + 1);\\n                \\n                for(int k = word.size() - 1; k >= 0; k--)\\n                {\\n                    string suffix = word.substr(k);\\n                    \\n                    string key = prefix + \"#\" + suffix;\\n                    \\n                    mp[key] = i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string key = prefix + \"#\" + suffix;\\n        \\n        if(mp.count(key))\\n        {\\n            return mp[key];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164172,
                "title": "c-easy-dictionary-solution",
                "content": "```\\npublic class WordFilter \\n{\\n    private IDictionary<string, int> wordMap;\\n\\n    public WordFilter(string[] words) \\n    {\\n        wordMap = new Dictionary<string, int>();\\n        for (int i = 0; i < words.Length; i++) \\n        {\\n            string word = words[i];\\n            for (int prefixEnd = 0; prefixEnd < word.Length; prefixEnd++) \\n            {\\n                string prefix = word.Substring(0, prefixEnd + 1);\\n                for (int suffixStart = 0; suffixStart < word.Length; suffixStart++) \\n                {\\n                    string suffix = word.Substring(suffixStart);\\n                    wordMap[$\"{prefix}#{suffix}\"] = i;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int F(string prefix, string suffix) \\n    {\\n        string key = $\"{prefix}#{suffix}\";\\n        return wordMap.ContainsKey(key) ? wordMap[key] : -1;\\n    }\\n}\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.F(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\npublic class WordFilter \\n{\\n    private IDictionary<string, int> wordMap;\\n\\n    public WordFilter(string[] words) \\n    {\\n        wordMap = new Dictionary<string, int>();\\n        for (int i = 0; i < words.Length; i++) \\n        {\\n            string word = words[i];\\n            for (int prefixEnd = 0; prefixEnd < word.Length; prefixEnd++) \\n            {\\n                string prefix = word.Substring(0, prefixEnd + 1);\\n                for (int suffixStart = 0; suffixStart < word.Length; suffixStart++) \\n                {\\n                    string suffix = word.Substring(suffixStart);\\n                    wordMap[$\"{prefix}#{suffix}\"] = i;\\n                }\\n            }\\n        }\\n    }\\n\\n    public int F(string prefix, string suffix) \\n    {\\n        string key = $\"{prefix}#{suffix}\";\\n        return wordMap.ContainsKey(key) ? wordMap[key] : -1;\\n    }\\n}\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.F(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563954,
                "title": "c-simple-and-short-solution-with-a-single-hash-map",
                "content": "Idea is to make a hash map of all possible prefix and suffix combination, then for find query check the value in map.\\nAdding more details by taking string **test** as example. \\n\\nPrefix set will look like : \\n```\\ngetPrefixes(string s){\\n\\t\\tt\\n\\t\\tte\\n\\t\\ttes\\n\\t\\ttest\\n    }\\n```\\nSuffix set will look like :\\n```\\ngetSuffixes(string s){\\n\\t\\tt\\n\\t\\tst\\n\\t\\test\\n\\t\\ttest\\n    }\\n```\\nWe need to store all combinations in a map with some delimeter. Adding few entries of map below :  \\n```\\nt#t\\nt#st\\nt#est\\nt#test\\nte#t\\ntes#t\\ntes#test\\n```\\n\\n**Time and Space Complexity** \\nMaking map :  \\n* words size = N and one word length = 10\\n* Time = O(Nx10x10)\\n* Same will be for Space = O(Nx10x10)\\n\\nQuery time complexity will constant. If you ignore length of prefix/suffix.\\n```\\nclass WordFilter {\\n    #define vs vector<string>\\n    \\n    vs getPrefixes(string s){\\n        string temp = \"\";\\n        vs ans;\\n        for(int i=0;i<s.length();i++){\\n            temp += s[i];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n    \\n    vs getSuffixes(string s){\\n        string temp = \"\";\\n        vs ans;\\n        for(int i=s.length()-1;i>=0;i--){\\n            temp = s[i] + temp;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\npublic:\\n    unordered_map<string,int> mp;\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            string s = words[i];\\n            for(auto x: getPrefixes(s))\\n                for(auto y:getSuffixes(s)){\\n                    mp[x+\"#\"+y] = i+1;\\n                }\\n        }\\n    }\\n    \\n    int f(string p, string s) {\\n        return mp[p+\"#\"+s]-1;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ngetPrefixes(string s){\\n\\t\\tt\\n\\t\\tte\\n\\t\\ttes\\n\\t\\ttest\\n    }\\n```\n```\\ngetSuffixes(string s){\\n\\t\\tt\\n\\t\\tst\\n\\t\\test\\n\\t\\ttest\\n    }\\n```\n```\\nt#t\\nt#st\\nt#est\\nt#test\\nte#t\\ntes#t\\ntes#test\\n```\n```\\nclass WordFilter {\\n    #define vs vector<string>\\n    \\n    vs getPrefixes(string s){\\n        string temp = \"\";\\n        vs ans;\\n        for(int i=0;i<s.length();i++){\\n            temp += s[i];\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n    \\n    vs getSuffixes(string s){\\n        string temp = \"\";\\n        vs ans;\\n        for(int i=s.length()-1;i>=0;i--){\\n            temp = s[i] + temp;\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\npublic:\\n    unordered_map<string,int> mp;\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            string s = words[i];\\n            for(auto x: getPrefixes(s))\\n                for(auto y:getSuffixes(s)){\\n                    mp[x+\"#\"+y] = i+1;\\n                }\\n        }\\n    }\\n    \\n    int f(string p, string s) {\\n        return mp[p+\"#\"+s]-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187690,
                "title": "java-simple-and-easy-to-understand-solution-140-ms-faster-than-95-22-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass WordFilter {\\n    \\n    HashMap<String, ArrayList<Integer>> prefixes;\\n    HashMap<String, ArrayList<Integer>> suffixes;\\n    \\n    String[] words;\\n\\n    public WordFilter(String[] words) {\\n        this.words = words;\\n        prefixes = new HashMap();\\n        suffixes = new HashMap();\\n        \\n        HashSet<String> set = new HashSet();\\n        \\n        for(int i = words.length - 1; i >= 0; i--){\\n            if(set.contains(words[i])) continue;\\n            \\n            //add all prefixes of current word\\n            addPrefix(i);\\n            \\n            //add all suffices of current word\\n            addSuffix(i);\\n            \\n            set.add(words[i]);\\n        }\\n    }\\n    \\n    private void addPrefix(int index){\\n        String word = words[index];\\n        \\n        for(int i = 1; i <= word.length(); i++){\\n            \\n            String prefix = word.substring(0, i);\\n            prefixes.putIfAbsent(prefix, new ArrayList<Integer>());\\n            prefixes.get(prefix).add(index);\\n        }\\n    }\\n    \\n    private void addSuffix(int index){\\n        String word = words[index];\\n        \\n        for(int i = word.length() - 1; i >= 0; i--){\\n            \\n            String suffix = word.substring(i, word.length());\\n            suffixes.putIfAbsent(suffix, new ArrayList<Integer>());\\n            suffixes.get(suffix).add(index);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        if(!prefixes.containsKey(prefix) || !suffixes.containsKey(suffix)) return -1;\\n        \\n        //find matched max indices\\n        return getMaxIndex(prefixes.get(prefix), suffixes.get(suffix));\\n    }\\n    \\n    private int getMaxIndex(List<Integer> indices1, List<Integer> indices2){\\n        //As both prefix and suffix indices are in decresing order\\n        //here we can use the two pointer, to find the matched max index\\n        \\n        int i = 0;\\n        int j = 0;\\n        while(i < indices1.size() && j < indices2.size()){\\n            \\n            if(indices1.get(i) - indices2.get(j) == 0) return indices1.get(i);\\n            \\n            if(indices1.get(i) > indices2.get(j)){\\n                i++;\\n            }else if(indices1.get(i) < indices2.get(j)){\\n                j++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordFilter {\\n    \\n    HashMap<String, ArrayList<Integer>> prefixes;\\n    HashMap<String, ArrayList<Integer>> suffixes;\\n    \\n    String[] words;\\n\\n    public WordFilter(String[] words) {\\n        this.words = words;\\n        prefixes = new HashMap();\\n        suffixes = new HashMap();\\n        \\n        HashSet<String> set = new HashSet();\\n        \\n        for(int i = words.length - 1; i >= 0; i--){\\n            if(set.contains(words[i])) continue;\\n            \\n            //add all prefixes of current word\\n            addPrefix(i);\\n            \\n            //add all suffices of current word\\n            addSuffix(i);\\n            \\n            set.add(words[i]);\\n        }\\n    }\\n    \\n    private void addPrefix(int index){\\n        String word = words[index];\\n        \\n        for(int i = 1; i <= word.length(); i++){\\n            \\n            String prefix = word.substring(0, i);\\n            prefixes.putIfAbsent(prefix, new ArrayList<Integer>());\\n            prefixes.get(prefix).add(index);\\n        }\\n    }\\n    \\n    private void addSuffix(int index){\\n        String word = words[index];\\n        \\n        for(int i = word.length() - 1; i >= 0; i--){\\n            \\n            String suffix = word.substring(i, word.length());\\n            suffixes.putIfAbsent(suffix, new ArrayList<Integer>());\\n            suffixes.get(suffix).add(index);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        if(!prefixes.containsKey(prefix) || !suffixes.containsKey(suffix)) return -1;\\n        \\n        //find matched max indices\\n        return getMaxIndex(prefixes.get(prefix), suffixes.get(suffix));\\n    }\\n    \\n    private int getMaxIndex(List<Integer> indices1, List<Integer> indices2){\\n        //As both prefix and suffix indices are in decresing order\\n        //here we can use the two pointer, to find the matched max index\\n        \\n        int i = 0;\\n        int j = 0;\\n        while(i < indices1.size() && j < indices2.size()){\\n            \\n            if(indices1.get(i) - indices2.get(j) == 0) return indices1.get(i);\\n            \\n            if(indices1.get(i) > indices2.get(j)){\\n                i++;\\n            }else if(indices1.get(i) < indices2.get(j)){\\n                j++;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186521,
                "title": "java-clean-concise-optimal-code-trie-or-hashmap-data-structure-100-beats-java-solution",
                "content": "# Solution 1: Trie Data Structure (Used only One Trie)\\n\\n```\\nclass Trie {\\n    \\n    Trie[] links;\\n    List<Integer> prefixIndices;\\n    List<Integer> suffixIndices;\\n    \\n    public Trie () {\\n        \\n        links = new Trie[26];\\n        prefixIndices = new ArrayList<> ();\\n        suffixIndices = new ArrayList<> ();\\n    }\\n}\\n\\nclass WordFilter {\\n    \\n    Trie root;\\n    \\n    public void insertWord (String word, int index, boolean flag) {\\n        \\n        Trie node = root;\\n        \\n        for (char c : word.toCharArray ()) {\\n            if (node.links[c - \\'a\\'] == null) {\\n                node.links[c - \\'a\\'] = new Trie ();\\n            }\\n            \\n            node = node.links[c - \\'a\\'];\\n            if (flag) {\\n                node.prefixIndices.add (index);\\n            }\\n            else {\\n               node.suffixIndices.add (index); \\n            }\\n        }\\n    }\\n    \\n    public List<Integer> searchWord (String word, boolean flag) {\\n        \\n        Trie node = root;\\n        \\n        for (char c : word.toCharArray ()) {\\n            node = node.links[c - \\'a\\'];\\n            if (node == null) {\\n                return null;\\n            }\\n        }\\n        \\n        return flag ? node.prefixIndices : node.suffixIndices;\\n    }\\n\\n    public WordFilter(String[] words) {\\n        \\n        root = new Trie ();\\n        \\n        for (int index = 0; index < words.length; index++) {\\n            insertWord (words[index], index, true);\\n            insertWord (new StringBuilder (words[index]).reverse ().toString (), index, false);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        \\n        List<Integer> prefixIndices = searchWord (prefix, true);\\n        \\n        if (prefixIndices == null || prefixIndices.size () == 0) {\\n            return -1;\\n        }\\n        \\n        List<Integer> suffixIndices = searchWord (new StringBuilder (suffix).reverse ().toString (), false);\\n        \\n        if (suffixIndices == null || suffixIndices.size () == 0) {\\n            return -1;\\n        }\\n        \\n        int i = prefixIndices.size () - 1, j = suffixIndices.size () - 1;\\n        \\n        while (i >= 0 && j >= 0) {\\n            if (Objects.equals (prefixIndices.get (i), suffixIndices.get (j))) {\\n                return prefixIndices.get (i);\\n            }\\n            else if (prefixIndices.get (i) > suffixIndices.get (j)) {\\n                i--;\\n            }\\n            else {\\n                j--;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n# Solution 2: HashMap Data Structure\\n\\n```\\nclass WordFilter {\\n    \\n    HashMap<String, Integer> map;\\n\\n    public WordFilter(String[] words) {\\n        \\n        map = new HashMap<> ();\\n        \\n        for (int index = 0; index < words.length; index++) {\\n            String word = words[index];\\n            \\n            for (int i = 0; i < word.length (); i++) {\\n                String s = word.substring (0, i + 1);\\n                \\n                for (int j = word.length () - 1; j >= 0; j--) {\\n                    StringBuilder str = new StringBuilder ();\\n                    str.append (s);\\n                    str.append (\"#\");\\n                    str.append (word.substring (j));\\n                    \\n                    map.put (str.toString (), index);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        \\n        StringBuilder str = new StringBuilder ();\\n        str.append (prefix);\\n        str.append (\"#\");\\n        str.append (suffix);\\n        \\n        return map.getOrDefault (str.toString (), -1);\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Trie {\\n    \\n    Trie[] links;\\n    List<Integer> prefixIndices;\\n    List<Integer> suffixIndices;\\n    \\n    public Trie () {\\n        \\n        links = new Trie[26];\\n        prefixIndices = new ArrayList<> ();\\n        suffixIndices = new ArrayList<> ();\\n    }\\n}\\n\\nclass WordFilter {\\n    \\n    Trie root;\\n    \\n    public void insertWord (String word, int index, boolean flag) {\\n        \\n        Trie node = root;\\n        \\n        for (char c : word.toCharArray ()) {\\n            if (node.links[c - \\'a\\'] == null) {\\n                node.links[c - \\'a\\'] = new Trie ();\\n            }\\n            \\n            node = node.links[c - \\'a\\'];\\n            if (flag) {\\n                node.prefixIndices.add (index);\\n            }\\n            else {\\n               node.suffixIndices.add (index); \\n            }\\n        }\\n    }\\n    \\n    public List<Integer> searchWord (String word, boolean flag) {\\n        \\n        Trie node = root;\\n        \\n        for (char c : word.toCharArray ()) {\\n            node = node.links[c - \\'a\\'];\\n            if (node == null) {\\n                return null;\\n            }\\n        }\\n        \\n        return flag ? node.prefixIndices : node.suffixIndices;\\n    }\\n\\n    public WordFilter(String[] words) {\\n        \\n        root = new Trie ();\\n        \\n        for (int index = 0; index < words.length; index++) {\\n            insertWord (words[index], index, true);\\n            insertWord (new StringBuilder (words[index]).reverse ().toString (), index, false);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        \\n        List<Integer> prefixIndices = searchWord (prefix, true);\\n        \\n        if (prefixIndices == null || prefixIndices.size () == 0) {\\n            return -1;\\n        }\\n        \\n        List<Integer> suffixIndices = searchWord (new StringBuilder (suffix).reverse ().toString (), false);\\n        \\n        if (suffixIndices == null || suffixIndices.size () == 0) {\\n            return -1;\\n        }\\n        \\n        int i = prefixIndices.size () - 1, j = suffixIndices.size () - 1;\\n        \\n        while (i >= 0 && j >= 0) {\\n            if (Objects.equals (prefixIndices.get (i), suffixIndices.get (j))) {\\n                return prefixIndices.get (i);\\n            }\\n            else if (prefixIndices.get (i) > suffixIndices.get (j)) {\\n                i--;\\n            }\\n            else {\\n                j--;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass WordFilter {\\n    \\n    HashMap<String, Integer> map;\\n\\n    public WordFilter(String[] words) {\\n        \\n        map = new HashMap<> ();\\n        \\n        for (int index = 0; index < words.length; index++) {\\n            String word = words[index];\\n            \\n            for (int i = 0; i < word.length (); i++) {\\n                String s = word.substring (0, i + 1);\\n                \\n                for (int j = word.length () - 1; j >= 0; j--) {\\n                    StringBuilder str = new StringBuilder ();\\n                    str.append (s);\\n                    str.append (\"#\");\\n                    str.append (word.substring (j));\\n                    \\n                    map.put (str.toString (), index);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        \\n        StringBuilder str = new StringBuilder ();\\n        str.append (prefix);\\n        str.append (\"#\");\\n        str.append (suffix);\\n        \\n        return map.getOrDefault (str.toString (), -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185206,
                "title": "prefix-suffix-search-java",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class WordFilter {\\n\\t\\n\\tprivate Map<String, Integer> words;\\n\\n\\tpublic WordFilter(String[] words) {\\n\\t\\tthis.words = new HashMap<String, Integer>();\\n        for (int i = 0; i < words.length; i++) {\\n        \\tString currWord = words[i];\\n        \\tList<String> prefixList = new ArrayList<String>();\\n        \\tList<String> suffixList = new ArrayList<String>();\\n\\t\\t\\tfor (int j = 0; j < currWord.length(); j++) {\\n\\t\\t\\t\\tprefixList.add(currWord.substring(0, currWord.length() - j));\\n\\t\\t\\t\\tsuffixList.add(currWord.substring(currWord.length() - j));\\n\\t\\t\\t}\\n\\t\\t\\t// Adding the whole word as it can act as suffix as well\\n\\t\\t\\tsuffixList.add(currWord);\\n\\t\\t\\tfor (int j = 0; j < prefixList.size(); j++) {\\n\\t\\t\\t\\tString prefix = prefixList.get(j);\\n\\t\\t\\t\\tfor (int j2 = 0; j2 < suffixList.size(); j2++) {\\n\\t\\t\\t\\t\\tString suffix = suffixList.get(j2);\\n\\t\\t\\t\\t\\tthis.words.put(prefix + \\'#\\' + suffix, i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n    \\tString findWord = prefix + \"#\" + suffix;    \\t\\n        return this.words.containsKey(findWord) ? this.words.get(findWord) : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.HashMap;\\nimport java.util.List;\\nimport java.util.Map;\\n\\npublic class WordFilter {\\n\\t\\n\\tprivate Map<String, Integer> words;\\n\\n\\tpublic WordFilter(String[] words) {\\n\\t\\tthis.words = new HashMap<String, Integer>();\\n        for (int i = 0; i < words.length; i++) {\\n        \\tString currWord = words[i];\\n        \\tList<String> prefixList = new ArrayList<String>();\\n        \\tList<String> suffixList = new ArrayList<String>();\\n\\t\\t\\tfor (int j = 0; j < currWord.length(); j++) {\\n\\t\\t\\t\\tprefixList.add(currWord.substring(0, currWord.length() - j));\\n\\t\\t\\t\\tsuffixList.add(currWord.substring(currWord.length() - j));\\n\\t\\t\\t}\\n\\t\\t\\t// Adding the whole word as it can act as suffix as well\\n\\t\\t\\tsuffixList.add(currWord);\\n\\t\\t\\tfor (int j = 0; j < prefixList.size(); j++) {\\n\\t\\t\\t\\tString prefix = prefixList.get(j);\\n\\t\\t\\t\\tfor (int j2 = 0; j2 < suffixList.size(); j2++) {\\n\\t\\t\\t\\t\\tString suffix = suffixList.get(j2);\\n\\t\\t\\t\\t\\tthis.words.put(prefix + \\'#\\' + suffix, i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n    \\tString findWord = prefix + \"#\" + suffix;    \\t\\n        return this.words.containsKey(findWord) ? this.words.get(findWord) : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 715567,
                "title": "c-o-nl-2-ql-trie-of-suffix-wrapped-words",
                "content": "```csharp\\npublic class WordFilter \\n{\\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[27];\\n        public int Weight;        \\n        \\n        public static void Insert(TrieNode root, string word, int weight)\\n        {\\n            string wrapped = word + \"{\" + word; // { - \\'a\\' = 27\\n            \\n            int end = 2 * word.Length + 1;\\n            for(int i = 0; i <= word.Length; i++)\\n            {               \\n                insert(root, wrapped, i, end, weight);               \\n            }\\n        }\\n        \\n        private static void insert(TrieNode root, string word, int start, int end, int weight)\\n        {\\n            TrieNode node = root;            \\n            for(int i = start; i < end; i++)\\n            {\\n                int index = word[i] - \\'a\\';\\n                if(node.Children[index] == null)\\n                {\\n                    node.Children[index] = new TrieNode();\\n                }\\n                \\n                node = node.Children[index];\\n                node.Weight = weight;                \\n            }\\n        }\\n        \\n        public static int Search(TrieNode root, string word)\\n        {\\n            TrieNode node =  root;\\n            foreach(char c in word)\\n            {\\n                int index  = c - \\'a\\';\\n                if(node.Children[index] == null)\\n                {\\n                    return -1;\\n                }\\n                \\n                node = node.Children[index];\\n            }\\n            \\n            return node.Weight;\\n        }\\n            \\n    }\\n    \\n    \\n    TrieNode root;\\n    \\n    public WordFilter(string[] words) \\n    {\\n        root = new TrieNode();\\n                \\n        for(int i = 0; i < words.Length; i++)\\n        {            \\n            TrieNode.Insert(root, words[i], i);            \\n        }               \\n    }\\n    \\n    public int F(string prefix, string suffix)\\n    {\\n        TrieNode node = root;\\n        string searchWord = suffix + \"{\" + prefix;\\n        \\n        int weight = TrieNode.Search(node, searchWord);\\n        return weight;\\n    }\\n}\\n```\\n\\nN - Number of words, L - Length of Word, Q - queries count\\nSpace Complexity - O(NK^2)\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```csharp\\npublic class WordFilter \\n{\\n    public class TrieNode\\n    {\\n        public TrieNode[] Children = new TrieNode[27];\\n        public int Weight;        \\n        \\n        public static void Insert(TrieNode root, string word, int weight)\\n        {\\n            string wrapped = word + \"{\" + word; // { - \\'a\\' = 27\\n            \\n            int end = 2 * word.Length + 1;\\n            for(int i = 0; i <= word.Length; i++)\\n            {               \\n                insert(root, wrapped, i, end, weight);               \\n            }\\n        }\\n        \\n        private static void insert(TrieNode root, string word, int start, int end, int weight)\\n        {\\n            TrieNode node = root;            \\n            for(int i = start; i < end; i++)\\n            {\\n                int index = word[i] - \\'a\\';\\n                if(node.Children[index] == null)\\n                {\\n                    node.Children[index] = new TrieNode();\\n                }\\n                \\n                node = node.Children[index];\\n                node.Weight = weight;                \\n            }\\n        }\\n        \\n        public static int Search(TrieNode root, string word)\\n        {\\n            TrieNode node =  root;\\n            foreach(char c in word)\\n            {\\n                int index  = c - \\'a\\';\\n                if(node.Children[index] == null)\\n                {\\n                    return -1;\\n                }\\n                \\n                node = node.Children[index];\\n            }\\n            \\n            return node.Weight;\\n        }\\n            \\n    }\\n    \\n    \\n    TrieNode root;\\n    \\n    public WordFilter(string[] words) \\n    {\\n        root = new TrieNode();\\n                \\n        for(int i = 0; i < words.Length; i++)\\n        {            \\n            TrieNode.Insert(root, words[i], i);            \\n        }               \\n    }\\n    \\n    public int F(string prefix, string suffix)\\n    {\\n        TrieNode node = root;\\n        string searchWord = suffix + \"{\" + prefix;\\n        \\n        int weight = TrieNode.Search(node, searchWord);\\n        return weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 110060,
                "title": "3-1-lines-and-zeroliner",
                "content": "```\\nclass WordFilter(dict):\\n\\n    def __init__(self, words):\\n        for i, word in enumerate(words):\\n            for p, s in itertools.product(range(len(word) + 1), repeat=2):\\n                self[word[:p], word[s:]] = i\\n\\n    def f(self, prefix, suffix):\\n        return self.get((prefix, suffix), -1)\\n```\\n\\nEdit: A \"zeroliner\" (adding one line in `__init__` and *removing* the `def f` line) from post below:\\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  S.f=lambda p,s,d={(w[:p],w[s:]):i for i,w in enumerate(W)for p in range(len(w)+1)for s in range(len(w)+1)}:d.get((p,s),-1)\\n```\\nFurther reductions:\\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  S.f=lambda p,s,d={(w[:p],w[s:]):i for i,w in enumerate(W)for r in[range(len(w)+1)]for p in r for s in r}:d.get((p,s),-1)\\n```\\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  S.f=lambda p,s,d={(w[:p],w[s:]):i for i,w in enumerate(W)for p in range(11)for s in range(11)}:d.get((p,s),-1)\\n```\\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  d={(w[:p],w[s:]):i for i,w in enumerate(W)for p in range(11)for s in range(11)};S.f=lambda*a:d.get(a,-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter(dict):\\n\\n    def __init__(self, words):\\n        for i, word in enumerate(words):\\n            for p, s in itertools.product(range(len(word) + 1), repeat=2):\\n                self[word[:p], word[s:]] = i\\n\\n    def f(self, prefix, suffix):\\n        return self.get((prefix, suffix), -1)\\n```\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  S.f=lambda p,s,d={(w[:p],w[s:]):i for i,w in enumerate(W)for p in range(len(w)+1)for s in range(len(w)+1)}:d.get((p,s),-1)\\n```\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  S.f=lambda p,s,d={(w[:p],w[s:]):i for i,w in enumerate(W)for r in[range(len(w)+1)]for p in r for s in r}:d.get((p,s),-1)\\n```\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  S.f=lambda p,s,d={(w[:p],w[s:]):i for i,w in enumerate(W)for p in range(11)for s in range(11)}:d.get((p,s),-1)\\n```\n```\\nclass WordFilter:\\n def __init__(S,W):\\n  d={(w[:p],w[s:]):i for i,w in enumerate(W)for p in range(11)for s in range(11)};S.f=lambda*a:d.get(a,-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165332,
                "title": "bug-many-trie-codes-are-giving-tle-on-this-test-case",
                "content": "**Test case is big you can replicate the cases by running below code or copy from here: https://pastebin.com/nF6Jtv47**\\n**Bug Already reported on leetcode**\\n**Bug link: https://github.com/LeetCode-Feedback/LeetCode-Feedback/issues/7813**\\n**You can test this on these accepted codes by yourself**\\n1- https://leetcode.com/submissions/detail/725021446/ (code not mine copied from discuss)\\n2 - https://leetcode.com/submissions/detail/725021257/\\n\\n**Upvote so, others can test it too thanks**\\n\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nvoid testcase(){\\n\\n    cout<<\"[\\\\\"WordFilter\\\\\"\";\\n    int n = 14000;\\n    for(int i=0;i<n;i++){\\n        cout<<\", \\\\\"f\\\\\"\";\\n    }\\n    cout<<\"]\"<<endl;\\n\\n    string s = \"\\\\\"appleeeeef\\\\\"\";\\n    string s1 = \"\\\\\"appleeeeee\\\\\"\";\\n    string s2 = \"\\\\\"bppleeeeee\\\\\"\";\\n    string f = \", [\\\\\"a\\\\\", \\\\\"e\\\\\"]\";\\n\\n    cout<<\"[[[\";\\n\\n    cout<<s1;\\n    int half = n/2;\\n    for(int i=0;i<half;i++) cout<<\", \"<<s;\\n    for(int i=0;i<n - half - 1;i++) cout<<\", \"<<s2;\\n\\n    cout<<\"]]\";\\n\\n    for(int i=0;i<n;i++) cout<<f;\\n\\n    cout<<\"]\"<<endl;\\n\\n}\\n\\nint main(){\\n    \\n    testcase();\\n       \\n    return 0;\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nvoid testcase(){\\n\\n    cout<<\"[\\\\\"WordFilter\\\\\"\";\\n    int n = 14000;\\n    for(int i=0;i<n;i++){\\n        cout<<\", \\\\\"f\\\\\"\";\\n    }\\n    cout<<\"]\"<<endl;\\n\\n    string s = \"\\\\\"appleeeeef\\\\\"\";\\n    string s1 = \"\\\\\"appleeeeee\\\\\"\";\\n    string s2 = \"\\\\\"bppleeeeee\\\\\"\";\\n    string f = \", [\\\\\"a\\\\\", \\\\\"e\\\\\"]\";\\n\\n    cout<<\"[[[\";\\n\\n    cout<<s1;\\n    int half = n/2;\\n    for(int i=0;i<half;i++) cout<<\", \"<<s;\\n    for(int i=0;i<n - half - 1;i++) cout<<\", \"<<s2;\\n\\n    cout<<\"]]\";\\n\\n    for(int i=0;i<n;i++) cout<<f;\\n\\n    cout<<\"]\"<<endl;\\n\\n}\\n\\nint main(){\\n    \\n    testcase();\\n       \\n    return 0;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2165217,
                "title": "c-two-tries-binary-search-with-comments",
                "content": "The idea:\\n1. Create two tries, for prefixes and suffixes, and store words indices in each Trie node. Words indices aldo will be sorted\\n2. For each pair of prefix-suffix we:\\n\\t* Retrive indices for words that start with the given prefix\\n\\t* Retrive indices for words that end with the given suffix\\n\\t* Find the largest common index, or return -1 if there\\'s no intersection\\n\\n```\\n/* We\\'ll use one templated class for both prefix- and suffix- tries\\nWe\\'ll also use Iterators rather than spending time to reverse every string */\\ntemplate <class StringIterator>\\nclass Trie {\\npublic:\\n    Trie() {}\\n    \\n    void insert(StringIterator current, StringIterator end, int index) {\\n\\t\\t/* Indices store indices of words that start (or end) with a given string.\\n\\t\\t\\tWe add index to the end of list; note that since we go over dictionary \\n\\t\\t\\tfrom 0 to end, these lists are going to be sorted in ascending way */\\n        indices.push_back(index);\\n        if (current != end) {            \\n\\t\\t\\t/* And if we have more letters to insert - we continue */\\n            int i = *current - \\'a\\';        \\n            if (!children[i]) {\\n\\t\\t\\t\\t/* We use unique_ptrs to not take care about memory */\\n                children[i] = make_unique<Trie<StringIterator>>();\\n            }\\n            children[i]->insert(++current, end, index);\\n        }\\n    }\\n\\t\\n    /* For a given string we\\'ll try to find its Trie node */\\n    Trie* find(StringIterator current, StringIterator end) {\\n        if (current == end) {\\n\\t\\t\\t/* Found! That\\'s the current node */\\n            return this;\\n        }\\n        \\n        int i = *current - \\'a\\';\\n        if (!children[i]) {\\n\\t\\t\\t/* There were no strings with this prefix / suffix */\\n            return nullptr;\\n        }\\n        \\n\\t\\t/* Move on over the trie and continue search */\\n        return children[i]->find(++current, end);        \\n    }\\n    \\npublic:\\n    vector<int> indices;\\n    \\nprivate: \\n\\t/* We use arrays since they\\'re more efficient than vectors if we know the size in advance, \\n\\t\\tand unique_ptrs to not take care about memory on our own */\\n    array<unique_ptr<Trie<StringIterator>>, 26> children;\\n};\\n\\n\\nclass WordFilter {\\npublic:\\n    WordFilter(vector<string>& words) {\\n\\t\\t/* Here we simply go over our dictionary, word by word, and add \\n\\t\\t\\tthem to tries. Order is important since we use binary search later */\\n        for (int i = 0; i < words.size(); ++i) {\\n            string& word = words[i];\\n            prefixes.insert(word.begin(), word.end(), i);\\n            suffixes.insert(word.rbegin(), word.rend(), i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n\\t\\t/* First, we\\'re looking for nodes that contain given prefix and suffix */\\n        auto* pref_node = prefixes.find(prefix.begin(), prefix.end());\\n        auto* suff_node = suffixes.find(suffix.rbegin(), suffix.rend());\\n        if (!pref_node || !suff_node) {\\n\\t\\t\\t/* Here we get if there were no strings in dictionary with the given prefix or suffix */\\n            return -1;\\n        }\\n        /* We get indices of words in dict... */\\n        vector<int>* pref_indices = &pref_node->indices;\\n        vector<int>* suff_indices = &suff_node->indices;\\n        /* And make sure that pref_indices is shorter than suff_indices. \\n\\t\\t\\tWe\\'ll use it to go over pref_indices vector from the end, and \\n\\t\\t\\tbinary search for indices in suff_indices */\\n        if (pref_indices->size() > suff_indices->size()) {\\n            swap(pref_indices, suff_indices);\\n        }\\n\\n        for (auto it = pref_indices->rbegin(); it != pref_indices->rend(); ++it) {\\n\\t\\t\\t/* Perform binary search over suff_indices. Note that on each step of this loop \\n\\t\\t\\t\\tthe index is decreasing, so we have to return the first match */\\n            auto jit = lower_bound(suff_indices->begin(), suff_indices->end(), *it);\\n            if (jit != suff_indices->end() && *jit == *it) {\\n                return *it;\\n            }\\n        }\\n        \\n\\t\\t/* Here we get if two vectors of indices have no intersection. So there are words that\\n\\t\\t\\tstart with the given prefix and end with the given suffix, but no words that satisfy \\n\\t\\t\\tboth conditions */\\n        return -1;\\n    }\\n    \\nprivate:\\n\\t/* We use the same class, but with different iterators */\\n    Trie<string::iterator> prefixes;\\n    Trie<string::reverse_iterator> suffixes;\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie",
                    "Binary Tree"
                ],
                "code": "```\\n/* We\\'ll use one templated class for both prefix- and suffix- tries\\nWe\\'ll also use Iterators rather than spending time to reverse every string */\\ntemplate <class StringIterator>\\nclass Trie {\\npublic:\\n    Trie() {}\\n    \\n    void insert(StringIterator current, StringIterator end, int index) {\\n\\t\\t/* Indices store indices of words that start (or end) with a given string.\\n\\t\\t\\tWe add index to the end of list; note that since we go over dictionary \\n\\t\\t\\tfrom 0 to end, these lists are going to be sorted in ascending way */\\n        indices.push_back(index);\\n        if (current != end) {            \\n\\t\\t\\t/* And if we have more letters to insert - we continue */\\n            int i = *current - \\'a\\';        \\n            if (!children[i]) {\\n\\t\\t\\t\\t/* We use unique_ptrs to not take care about memory */\\n                children[i] = make_unique<Trie<StringIterator>>();\\n            }\\n            children[i]->insert(++current, end, index);\\n        }\\n    }\\n\\t\\n    /* For a given string we\\'ll try to find its Trie node */\\n    Trie* find(StringIterator current, StringIterator end) {\\n        if (current == end) {\\n\\t\\t\\t/* Found! That\\'s the current node */\\n            return this;\\n        }\\n        \\n        int i = *current - \\'a\\';\\n        if (!children[i]) {\\n\\t\\t\\t/* There were no strings with this prefix / suffix */\\n            return nullptr;\\n        }\\n        \\n\\t\\t/* Move on over the trie and continue search */\\n        return children[i]->find(++current, end);        \\n    }\\n    \\npublic:\\n    vector<int> indices;\\n    \\nprivate: \\n\\t/* We use arrays since they\\'re more efficient than vectors if we know the size in advance, \\n\\t\\tand unique_ptrs to not take care about memory on our own */\\n    array<unique_ptr<Trie<StringIterator>>, 26> children;\\n};\\n\\n\\nclass WordFilter {\\npublic:\\n    WordFilter(vector<string>& words) {\\n\\t\\t/* Here we simply go over our dictionary, word by word, and add \\n\\t\\t\\tthem to tries. Order is important since we use binary search later */\\n        for (int i = 0; i < words.size(); ++i) {\\n            string& word = words[i];\\n            prefixes.insert(word.begin(), word.end(), i);\\n            suffixes.insert(word.rbegin(), word.rend(), i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n\\t\\t/* First, we\\'re looking for nodes that contain given prefix and suffix */\\n        auto* pref_node = prefixes.find(prefix.begin(), prefix.end());\\n        auto* suff_node = suffixes.find(suffix.rbegin(), suffix.rend());\\n        if (!pref_node || !suff_node) {\\n\\t\\t\\t/* Here we get if there were no strings in dictionary with the given prefix or suffix */\\n            return -1;\\n        }\\n        /* We get indices of words in dict... */\\n        vector<int>* pref_indices = &pref_node->indices;\\n        vector<int>* suff_indices = &suff_node->indices;\\n        /* And make sure that pref_indices is shorter than suff_indices. \\n\\t\\t\\tWe\\'ll use it to go over pref_indices vector from the end, and \\n\\t\\t\\tbinary search for indices in suff_indices */\\n        if (pref_indices->size() > suff_indices->size()) {\\n            swap(pref_indices, suff_indices);\\n        }\\n\\n        for (auto it = pref_indices->rbegin(); it != pref_indices->rend(); ++it) {\\n\\t\\t\\t/* Perform binary search over suff_indices. Note that on each step of this loop \\n\\t\\t\\t\\tthe index is decreasing, so we have to return the first match */\\n            auto jit = lower_bound(suff_indices->begin(), suff_indices->end(), *it);\\n            if (jit != suff_indices->end() && *jit == *it) {\\n                return *it;\\n            }\\n        }\\n        \\n\\t\\t/* Here we get if two vectors of indices have no intersection. So there are words that\\n\\t\\t\\tstart with the given prefix and end with the given suffix, but no words that satisfy \\n\\t\\t\\tboth conditions */\\n        return -1;\\n    }\\n    \\nprivate:\\n\\t/* We use the same class, but with different iterators */\\n    Trie<string::iterator> prefixes;\\n    Trie<string::reverse_iterator> suffixes;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164179,
                "title": "easy-to-understand-trie-memory-efficient-solution-in-python-that-beats-86",
                "content": "Below is the code for this problem.\\n\\nIn this solution, we build two tries for prefix and suffix. However, a naive two-trie solution is very memory-inefficient, because in some cases, there can be a large amount of redundant words in the input. Obviously, we don\\'t want them as they slow down the trie building and the lookup processes.\\n\\nThe gist of making a memory-efficient solution is that before we build the two tries, we first filter out the redundant words by using a table and only record the last time it appears in the list. Therefore, a word only shows up in the tries once with the largest index.\\n\\nWith this table implemented, the memory usage beats 95% and the runtime easily beats 86%.\\n\\nThe code may be long, but only because implementing the two tries is kind of repetitive. I believe it is still easy to understand the concept.\\n \\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        \\n        # Important: in we do not want duplicate words in our tries and we only want the one with \\n        # the largest index. Therefore, we use a table to store the largest index of each word.\\n        filtered_words = dict()\\n        for ind, word in enumerate(words):\\n            filtered_words[word] = ind\\n            \\n        # Here we declare two tries, one for the prefix and the other for the suffix\\n        self.trie = dict()\\n        self.suf_trie = dict()\\n        \\n        # Building up the tries\\n        for word, index in filtered_words.items():\\n            iterator = self.trie\\n            iterator_suf = self.suf_trie\\n            pos = 0\\n            pos_suf = len(word) - 1\\n            while pos != len(word):\\n                if word[pos] not in iterator:\\n                    iterator[word[pos]] = dict()\\n                if word[pos_suf] not in iterator_suf:\\n                    iterator_suf[word[pos_suf]] = dict()\\n                iterator = iterator[word[pos]]\\n                iterator_suf = iterator_suf[word[pos_suf]]\\n                pos += 1\\n                pos_suf -= 1\\n                \\n                # Since we find words by prefix and suffix, we store the index of the word \\n                # at every step as we build up the two tries.\\n                if \\'*\\' not in iterator:\\n                    iterator[\\'*\\'] = []\\n                iterator[\\'*\\'].append(index)\\n                if \\'*\\' not in iterator_suf:\\n                    iterator_suf[\\'*\\'] = []\\n                iterator_suf[\\'*\\'].append(index)\\n                \\n                    \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        \\n        # Check if the prefix and the suffix exist in our tries, if yes, we have a list of word indices \\n        # that indicate the words that match the prefix or the suffix. Otherwise, we only have an empty list.\\n        iterator = self.trie\\n        pref_ind = []\\n        for idx, char in enumerate(prefix):\\n            if char in iterator:\\n                iterator = iterator[char]\\n                if idx == len(prefix) - 1:\\n                    pref_ind = iterator[\\'*\\']\\n            else:\\n                break\\n        \\n        iterator_suf = self.suf_trie\\n        suf_ind = []\\n        for idx, char in enumerate(suffix[::-1]):\\n            if char in iterator_suf:\\n                iterator_suf = iterator_suf[char]\\n                if idx == len(suffix) - 1:\\n                    suf_ind = iterator_suf[\\'*\\']\\n            else:\\n                break\\n        \\n        # At the end, find out the largest index that exists in both the prefix and the suffix tries.\\n        cnt = collections.Counter(pref_ind)\\n        largest = -1\\n        for suf in suf_ind:\\n            if suf in cnt:\\n                largest = max(largest, suf)\\n        return largest\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        \\n        # Important: in we do not want duplicate words in our tries and we only want the one with \\n        # the largest index. Therefore, we use a table to store the largest index of each word.\\n        filtered_words = dict()\\n        for ind, word in enumerate(words):\\n            filtered_words[word] = ind\\n            \\n        # Here we declare two tries, one for the prefix and the other for the suffix\\n        self.trie = dict()\\n        self.suf_trie = dict()\\n        \\n        # Building up the tries\\n        for word, index in filtered_words.items():\\n            iterator = self.trie\\n            iterator_suf = self.suf_trie\\n            pos = 0\\n            pos_suf = len(word) - 1\\n            while pos != len(word):\\n                if word[pos] not in iterator:\\n                    iterator[word[pos]] = dict()\\n                if word[pos_suf] not in iterator_suf:\\n                    iterator_suf[word[pos_suf]] = dict()\\n                iterator = iterator[word[pos]]\\n                iterator_suf = iterator_suf[word[pos_suf]]\\n                pos += 1\\n                pos_suf -= 1\\n                \\n                # Since we find words by prefix and suffix, we store the index of the word \\n                # at every step as we build up the two tries.\\n                if \\'*\\' not in iterator:\\n                    iterator[\\'*\\'] = []\\n                iterator[\\'*\\'].append(index)\\n                if \\'*\\' not in iterator_suf:\\n                    iterator_suf[\\'*\\'] = []\\n                iterator_suf[\\'*\\'].append(index)\\n                \\n                    \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        \\n        # Check if the prefix and the suffix exist in our tries, if yes, we have a list of word indices \\n        # that indicate the words that match the prefix or the suffix. Otherwise, we only have an empty list.\\n        iterator = self.trie\\n        pref_ind = []\\n        for idx, char in enumerate(prefix):\\n            if char in iterator:\\n                iterator = iterator[char]\\n                if idx == len(prefix) - 1:\\n                    pref_ind = iterator[\\'*\\']\\n            else:\\n                break\\n        \\n        iterator_suf = self.suf_trie\\n        suf_ind = []\\n        for idx, char in enumerate(suffix[::-1]):\\n            if char in iterator_suf:\\n                iterator_suf = iterator_suf[char]\\n                if idx == len(suffix) - 1:\\n                    suf_ind = iterator_suf[\\'*\\']\\n            else:\\n                break\\n        \\n        # At the end, find out the largest index that exists in both the prefix and the suffix tries.\\n        cnt = collections.Counter(pref_ind)\\n        largest = -1\\n        for suf in suf_ind:\\n            if suf in cnt:\\n                largest = max(largest, suf)\\n        return largest\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449955,
                "title": "solution",
                "content": "```C++ []\\nint t[700009][29],ts;\\n\\nclass WordFilter {\\npublic:\\n    WordFilter(vector<string>& words) {\\n        memset(t,0,sizeof(t[0])*ts),ts=8;\\n\\n        for(int wi=0;wi<size(words);wi++){\\n            string&s=words[wi];\\n            for(int l=1;l<=min(7,int(size(s)));l++){\\n                int i=l;\\n                for(auto it=end(s)-i;it!=end(s);it++){\\n                    int&j=t[i][*it-\\'a\\'];\\n                    if(!j)j=ts++;\\n                    i=j;\\n                    t[i][26]=wi;\\n                }\\n                for(char x:s){\\n                    int&j=t[i][x-\\'a\\'];\\n                    if(!j)j=ts++;\\n                    i=j;\\n                    t[i][26]=wi;\\n                }\\n            }\\n        }\\n    }\\n    int f(string p, string s) {\\n        int i=size(s);\\n        for(auto x:s){\\n            i=t[i][x-\\'a\\'];\\n            if(!i)return -1;\\n        }\\n        for(auto x:p){\\n            i=t[i][x-\\'a\\'];\\n            if(!i)return -1;\\n        }\\n        return t[i][26];\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d1={}\\n        self.d2={}\\n        for i in range(len(words)-1,-1,-1):\\n            if (words[i][0],words[i][-1]) in self.d2:\\n                x=self.d2[(words[i][0],words[i][-1])]\\n                x.append(words[i])\\n                self.d2[(words[i][0],words[i][-1])]=x\\n            else:\\n                self.d2[(words[i][0],words[i][-1])]=[words[i]]\\n            if words[i] not in self.d1:\\n                self.d1[words[i]]=i\\n      \\n    def f(self, pref: str, suff: str) -> int:\\n        if (pref[0],suff[-1]) in self.d2:\\n            x=self.d2[(pref[0],suff[-1])]\\n            for i in x:\\n                if i[:len(pref)]==pref and i[len(i)-len(suff):]==suff:\\n                    return self.d1[i]\\n        return -1\\n```\\n\\n```Java []\\nclass WordNode {\\n    WordNode next;\\n    String word;\\n    int index;\\n\\n    WordNode(String word, int index) {\\n        this.word = word;\\n        this.index = index;\\n    }\\n}\\nclass TrieNode {\\n    TrieNode[] children;\\n    WordNode suffixHead;\\n\\n    TrieNode() {\\n        children = new TrieNode[26];\\n    }\\n}\\nclass WordFilter {\\n    private TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for (int i = 0; i < words.length; ++i)\\n            insertWord(words[i], i);\\n    }\\n    private void insertWord(String word, int index) {\\n        TrieNode trieNode = root;\\n        for (char c : word.toCharArray()) {\\n            if (trieNode.children[c - \\'a\\'] == null)\\n                trieNode.children[c - \\'a\\'] = new TrieNode();\\n\\n            trieNode = trieNode.children[c - \\'a\\'];\\n            \\n            WordNode wordNode = new WordNode(word, index);\\n            wordNode.next = trieNode.suffixHead;\\n            trieNode.suffixHead = wordNode;\\n        }\\n    }\\n    public int f(String pref, String suff) {\\n        TrieNode trieNode = root;\\n        for (char c : pref.toCharArray()) {\\n            if (trieNode.children[c - \\'a\\'] == null)\\n                return -1;\\n\\n            trieNode = trieNode.children[c - \\'a\\'];\\n        }\\n        WordNode wordNode = trieNode.suffixHead;\\n        while (wordNode != null) {\\n            if (wordNode.word.endsWith(suff))\\n                return wordNode.index;\\n\\n            wordNode = wordNode.next;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nint t[700009][29],ts;\\n\\nclass WordFilter {\\npublic:\\n    WordFilter(vector<string>& words) {\\n        memset(t,0,sizeof(t[0])*ts),ts=8;\\n\\n        for(int wi=0;wi<size(words);wi++){\\n            string&s=words[wi];\\n            for(int l=1;l<=min(7,int(size(s)));l++){\\n                int i=l;\\n                for(auto it=end(s)-i;it!=end(s);it++){\\n                    int&j=t[i][*it-\\'a\\'];\\n                    if(!j)j=ts++;\\n                    i=j;\\n                    t[i][26]=wi;\\n                }\\n                for(char x:s){\\n                    int&j=t[i][x-\\'a\\'];\\n                    if(!j)j=ts++;\\n                    i=j;\\n                    t[i][26]=wi;\\n                }\\n            }\\n        }\\n    }\\n    int f(string p, string s) {\\n        int i=size(s);\\n        for(auto x:s){\\n            i=t[i][x-\\'a\\'];\\n            if(!i)return -1;\\n        }\\n        for(auto x:p){\\n            i=t[i][x-\\'a\\'];\\n            if(!i)return -1;\\n        }\\n        return t[i][26];\\n    }\\n};\\n```\n```Python3 []\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d1={}\\n        self.d2={}\\n        for i in range(len(words)-1,-1,-1):\\n            if (words[i][0],words[i][-1]) in self.d2:\\n                x=self.d2[(words[i][0],words[i][-1])]\\n                x.append(words[i])\\n                self.d2[(words[i][0],words[i][-1])]=x\\n            else:\\n                self.d2[(words[i][0],words[i][-1])]=[words[i]]\\n            if words[i] not in self.d1:\\n                self.d1[words[i]]=i\\n      \\n    def f(self, pref: str, suff: str) -> int:\\n        if (pref[0],suff[-1]) in self.d2:\\n            x=self.d2[(pref[0],suff[-1])]\\n            for i in x:\\n                if i[:len(pref)]==pref and i[len(i)-len(suff):]==suff:\\n                    return self.d1[i]\\n        return -1\\n```\n```Java []\\nclass WordNode {\\n    WordNode next;\\n    String word;\\n    int index;\\n\\n    WordNode(String word, int index) {\\n        this.word = word;\\n        this.index = index;\\n    }\\n}\\nclass TrieNode {\\n    TrieNode[] children;\\n    WordNode suffixHead;\\n\\n    TrieNode() {\\n        children = new TrieNode[26];\\n    }\\n}\\nclass WordFilter {\\n    private TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for (int i = 0; i < words.length; ++i)\\n            insertWord(words[i], i);\\n    }\\n    private void insertWord(String word, int index) {\\n        TrieNode trieNode = root;\\n        for (char c : word.toCharArray()) {\\n            if (trieNode.children[c - \\'a\\'] == null)\\n                trieNode.children[c - \\'a\\'] = new TrieNode();\\n\\n            trieNode = trieNode.children[c - \\'a\\'];\\n            \\n            WordNode wordNode = new WordNode(word, index);\\n            wordNode.next = trieNode.suffixHead;\\n            trieNode.suffixHead = wordNode;\\n        }\\n    }\\n    public int f(String pref, String suff) {\\n        TrieNode trieNode = root;\\n        for (char c : pref.toCharArray()) {\\n            if (trieNode.children[c - \\'a\\'] == null)\\n                return -1;\\n\\n            trieNode = trieNode.children[c - \\'a\\'];\\n        }\\n        WordNode wordNode = trieNode.suffixHead;\\n        while (wordNode != null) {\\n            if (wordNode.word.endsWith(suff))\\n                return wordNode.index;\\n\\n            wordNode = wordNode.next;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175128,
                "title": "golang-solution-with-trie",
                "content": "* The below solution is not optimal but it will pass all test cases.\\n* Used 2 tries - one to store all words in normal order (prefixTrie) and other trie where every word is reversed and pushed to the trie (suffixTrie)\\n* search the prefix string in the trie where words are in normal order (prefixTrie) and similarly search the reverse of suffix in the trie where the words are pushed in revered order (suffixTrie)\\n* collect all the indexes where the word ends in the trie - this signifies that the search string(prefix) has indeed a valid word for it, else return empty array \\n* you should get 2 sets of array - one for prefix search and other for suffix search\\n* find the intersection b/w them and the max value in the the intersected array.\\n\\nThe code is self expalnatory, if in doubt, kindly comment. I will try to explain better.\\n\\n```\\ntype WordFilter struct {\\n    prefixRoot *node\\n    suffixRoot *node\\n}\\n\\ntype node struct {\\n    children []*node\\n    value string\\n    index int\\n}\\n\\n\\nfunc Constructor(words []string) WordFilter {\\n    prefixRoot := initialize()\\n    suffixRoot := initialize()\\n    \\n    for index, word := range words {\\n        addWord(word, prefixRoot, index)\\n        addWord(reverse(word), suffixRoot, index)\\n    }\\n    \\n    return WordFilter{\\n        prefixRoot: prefixRoot,\\n        suffixRoot: suffixRoot,\\n    }\\n}\\n\\n\\nfunc (this *WordFilter) F(prefix string, suffix string) int {\\n    prefixIndexes := search(this.prefixRoot, prefix)\\n    suffixIndexes := search(this.suffixRoot, reverse(suffix))\\n    \\n    result := -1\\n    intersection := make(map[int]bool, 0)\\n    \\n    for _, value := range prefixIndexes {\\n        intersection[value] = true\\n    }\\n    \\n    for _, value := range suffixIndexes {\\n        if _, ok := intersection[value]; ok {\\n            result = max(value, result)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc initialize() *node {\\n    return &node{\\n            children: make([]*node, 26),\\n            value: \"\",\\n            index: -1,\\n        }\\n}\\n\\nfunc addWord(word string, root *node, index int) {\\n    \\n    element := root\\n    \\n    for _, v := range word {\\n        if element.children[v-\\'a\\'] == nil {\\n            element.children[v-\\'a\\'] = initialize()\\n        }\\n        element = element.children[v-\\'a\\']\\n    }\\n    element.index = index\\n    element.value = word\\n}\\n\\nfunc reverse(word string) string {\\n    result := make([]byte, 0)\\n    \\n    for i:=len(word)-1; i>=0; i-- {\\n        result = append(result, word[i])\\n    }\\n    \\n    return string(result)\\n}\\n\\nfunc search(root *node, word string) []int {\\n    \\n    element := root\\n    \\n    for _, v := range word {\\n        if element.children[v-\\'a\\'] == nil {\\n            return make([]int, 0)\\n        }\\n        element = element.children[v-\\'a\\']\\n    }\\n    \\n    return fetchIndex(element)\\n}\\n\\nfunc fetchIndex(element *node) []int {\\n    result := make([]int, 0)\\n    \\n    if element.value != \"\" {\\n        result = append(result, element.index)\\n    }\\n    \\n    for _, child := range element.children {\\n        if child != nil {\\n            result = append(result, fetchIndex(child)...)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(a,b int) int {\\n    if b > a {\\n        return b\\n    }\\n    \\n    return a\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * obj := Constructor(words);\\n * param_1 := obj.F(prefix,suffix);\\n */",
                "solutionTags": [
                    "Trie"
                ],
                "code": "* The below solution is not optimal but it will pass all test cases.\\n* Used 2 tries - one to store all words in normal order (prefixTrie) and other trie where every word is reversed and pushed to the trie (suffixTrie)\\n* search the prefix string in the trie where words are in normal order (prefixTrie) and similarly search the reverse of suffix in the trie where the words are pushed in revered order (suffixTrie)\\n* collect all the indexes where the word ends in the trie - this signifies that the search string(prefix) has indeed a valid word for it, else return empty array \\n* you should get 2 sets of array - one for prefix search and other for suffix search\\n* find the intersection b/w them and the max value in the the intersected array.\\n\\nThe code is self expalnatory, if in doubt, kindly comment. I will try to explain better.\\n\\n```\\ntype WordFilter struct {\\n    prefixRoot *node\\n    suffixRoot *node\\n}\\n\\ntype node struct {\\n    children []*node\\n    value string\\n    index int\\n}\\n\\n\\nfunc Constructor(words []string) WordFilter {\\n    prefixRoot := initialize()\\n    suffixRoot := initialize()\\n    \\n    for index, word := range words {\\n        addWord(word, prefixRoot, index)\\n        addWord(reverse(word), suffixRoot, index)\\n    }\\n    \\n    return WordFilter{\\n        prefixRoot: prefixRoot,\\n        suffixRoot: suffixRoot,\\n    }\\n}\\n\\n\\nfunc (this *WordFilter) F(prefix string, suffix string) int {\\n    prefixIndexes := search(this.prefixRoot, prefix)\\n    suffixIndexes := search(this.suffixRoot, reverse(suffix))\\n    \\n    result := -1\\n    intersection := make(map[int]bool, 0)\\n    \\n    for _, value := range prefixIndexes {\\n        intersection[value] = true\\n    }\\n    \\n    for _, value := range suffixIndexes {\\n        if _, ok := intersection[value]; ok {\\n            result = max(value, result)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc initialize() *node {\\n    return &node{\\n            children: make([]*node, 26),\\n            value: \"\",\\n            index: -1,\\n        }\\n}\\n\\nfunc addWord(word string, root *node, index int) {\\n    \\n    element := root\\n    \\n    for _, v := range word {\\n        if element.children[v-\\'a\\'] == nil {\\n            element.children[v-\\'a\\'] = initialize()\\n        }\\n        element = element.children[v-\\'a\\']\\n    }\\n    element.index = index\\n    element.value = word\\n}\\n\\nfunc reverse(word string) string {\\n    result := make([]byte, 0)\\n    \\n    for i:=len(word)-1; i>=0; i-- {\\n        result = append(result, word[i])\\n    }\\n    \\n    return string(result)\\n}\\n\\nfunc search(root *node, word string) []int {\\n    \\n    element := root\\n    \\n    for _, v := range word {\\n        if element.children[v-\\'a\\'] == nil {\\n            return make([]int, 0)\\n        }\\n        element = element.children[v-\\'a\\']\\n    }\\n    \\n    return fetchIndex(element)\\n}\\n\\nfunc fetchIndex(element *node) []int {\\n    result := make([]int, 0)\\n    \\n    if element.value != \"\" {\\n        result = append(result, element.index)\\n    }\\n    \\n    for _, child := range element.children {\\n        if child != nil {\\n            result = append(result, fetchIndex(child)...)\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(a,b int) int {\\n    if b > a {\\n        return b\\n    }\\n    \\n    return a\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * obj := Constructor(words);\\n * param_1 := obj.F(prefix,suffix);\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 2167732,
                "title": "python-short-and-readable",
                "content": "Just create all possible combination of prefixes and suffixes and check in `O(1)`\\n```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.w = {}\\n        for k, w in enumerate(words):\\n            for i in range(1, len(w)+1):\\n                for j in range(1, len(w)+1):\\n                    self.w[w[:i], w[-j:]] = k\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.w.get((prefix, suffix), -1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.w = {}\\n        for k, w in enumerate(words):\\n            for i in range(1, len(w)+1):\\n                for j in range(1, len(w)+1):\\n                    self.w[w[:i], w[-j:]] = k\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.w.get((prefix, suffix), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167705,
                "title": "java-trie-faster-than-91",
                "content": "```\\nclass WordFilter {\\n    public class Trie {\\n        Trie[] children;\\n        HashMap<String, Integer> map;  \\n        public Trie() {\\n            children = new Trie[26];\\n            map = new HashMap<>();\\n        }\\n    }\\n    private Trie root;\\n    public WordFilter(String[] words) {\\n        int n = words.length;\\n        this.root = new Trie();\\n        Trie cur = root;\\n        for (int i = 0; i < n; i++) {\\n            int len = words[i].length();\\n            for (char c: words[i].toCharArray()) {\\n                int cIndex = c - \\'a\\';\\n                if (cur.children[cIndex] == null) {\\n                    cur.children[cIndex] = new Trie();\\n                }                \\n                cur = cur.children[cIndex];\\n                for (int j = 0; j < len; j++) {\\n                    cur.map.put(words[i].substring(j), i);\\n                }\\n            }\\n            cur = root;\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Trie cur = this.root;\\n        for (char c: prefix.toCharArray()) {\\n            int cIndex = c - \\'a\\';\\n            if (cur.children[cIndex] == null) return -1;\\n            cur = cur.children[cIndex];\\n        }\\n        \\n        return cur.map.getOrDefault(suffix, -1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n    public class Trie {\\n        Trie[] children;\\n        HashMap<String, Integer> map;  \\n        public Trie() {\\n            children = new Trie[26];\\n            map = new HashMap<>();\\n        }\\n    }\\n    private Trie root;\\n    public WordFilter(String[] words) {\\n        int n = words.length;\\n        this.root = new Trie();\\n        Trie cur = root;\\n        for (int i = 0; i < n; i++) {\\n            int len = words[i].length();\\n            for (char c: words[i].toCharArray()) {\\n                int cIndex = c - \\'a\\';\\n                if (cur.children[cIndex] == null) {\\n                    cur.children[cIndex] = new Trie();\\n                }                \\n                cur = cur.children[cIndex];\\n                for (int j = 0; j < len; j++) {\\n                    cur.map.put(words[i].substring(j), i);\\n                }\\n            }\\n            cur = root;\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Trie cur = this.root;\\n        for (char c: prefix.toCharArray()) {\\n            int cIndex = c - \\'a\\';\\n            if (cur.children[cIndex] == null) return -1;\\n            cur = cur.children[cIndex];\\n        }\\n        \\n        return cur.map.getOrDefault(suffix, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165330,
                "title": "java-no-trie-map-solution-simple-to-understand",
                "content": "**Logic here is to create and store all possible combinations of the prefix and suffix and then search for when asked for it in the f function**.\\n\\n```\\nclass WordFilter {\\n    \\n    HashMap<String,Integer> map;\\n    \\n    public WordFilter(String[] words) {\\n        map = new HashMap<>();\\n        \\n        for(int index = 0; index<words.length; index++){\\n            for(int i=0; i<=words[index].length(); i++){\\n                for(int j=0; j<=words[index].length(); j++){\\n                    String query = words[index].substring(0,i) + \"#\" + words[index].substring(j);\\n                    map.put(query,index);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String temp = prefix + \"#\" + suffix;\\n        return map.getOrDefault(temp,-1);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordFilter {\\n    \\n    HashMap<String,Integer> map;\\n    \\n    public WordFilter(String[] words) {\\n        map = new HashMap<>();\\n        \\n        for(int index = 0; index<words.length; index++){\\n            for(int i=0; i<=words[index].length(); i++){\\n                for(int j=0; j<=words[index].length(); j++){\\n                    String query = words[index].substring(0,i) + \"#\" + words[index].substring(j);\\n                    map.put(query,index);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String temp = prefix + \"#\" + suffix;\\n        return map.getOrDefault(temp,-1);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164884,
                "title": "java-c-easy-hash-solution-commented",
                "content": "**General idea very easy :**\\n1. Will retain prefixes and indexes **separatelly**  (in this case we will retain memory and as conclusion : runtime)\\n2. in hash **pref** will retain such pair **prefix** => set of **indexes of words** with the same prefix (and set will organize in decreasing order)\\n3. in hash **suff** will retain such pair **suffix** => set of **indexes of words** with the same suffix (and set will organize in decreasing order) for C++ version I reverse suffix (it will increase runtime, but not very much )\\nfor Java version and second C++ version I wrote parsing for suffixes in right order.\\n\\n4. whan we have requestion we organaze loop in set of indexes for prefix (in decreasing order and if we have this index in suffix set = we have answer)\\n\\nP.S. runtime and space will improve if we will use **vector** instead **set** and will sort all vectors in hash after creating it. When we will organize search we will search index in vector for suffix with binary search... \\n\\n**first version**\\nRuntime: 718 ms, faster than 52.24% of C++ online submissions for Prefix and Suffix Search.\\nMemory Usage: 136.4 MB, less than 75.37% of C++ online submissions for Prefix and Suffix Search.\\n```\\nclass WordFilter {\\npublic:\\n  unordered_map<string, set<int, greater<int>>> pref, suff;\\n  \\n  WordFilter(vector<string>& words) {\\n    for(int i = 0; i != words.size(); i++){\\n      string w = words[i];\\n      for(; !w.empty(); w.pop_back()) pref[w].insert(i);\\n      w = words[i]; reverse(w.begin(), w.end());\\n      for(; !w.empty(); w.pop_back()) suff[w].insert(i);\\n    }\\n  }\\n    \\n  int f(string prefix, string suffix) {\\n    reverse(suffix.begin(), suffix.end());\\n      \\n    for(auto id : pref[prefix])\\n      if(suff[suffix].count(id)) return id;\\n  \\n    return -1;\\n  }\\n};\\n```\\n**second version for P.S.**\\nRuntime: 519 ms, faster than 76.12% of C++ online submissions for Prefix and Suffix Search.\\nMemory Usage: 103.9 MB, less than 97.02% of C++ online submissions for Prefix and Suffix Search.\\n```\\nclass WordFilter {\\npublic:\\n  unordered_map<string, vector<int>> pref, suff;\\n  \\n  WordFilter(vector<string>& words) {\\n    for(int i = 0; i != words.size(); i++){\\n      for(int j = 0 ; j != words[i].size(); j++) suff[words[i].substr(j, 10)].push_back(i);\\n      for(; !words[i].empty(); words[i].pop_back()) pref[words[i]].push_back(i);\\n    }\\n    \\n    for(auto &[s, v]: pref)sort(v.begin(), v.end());\\n    for(auto &[s, v]: suff)sort(v.begin(), v.end());\\n  }\\n    \\n  int f(string prefix, string suffix) {\\n    for(auto it = pref[prefix].rbegin(); it != pref[prefix].rend(); it++)\\n      if(binary_search (suff[suffix].begin(), suff[suffix].end(), *it)) return *it;\\n  \\n    return -1;\\n  }\\n};\\n```\\n\\n\\n**Java version not such compact as C++**\\nRuntime: 381 ms, faster than 74.65% of Java online submissions for Prefix and Suffix Search.\\nMemory Usage: 77 MB, less than 91.36% of Java online submissions for Prefix and Suffix Search.\\n```\\nclass WordFilter {\\n  HashMap<String, SortedSet<Integer>> pref, suff;\\n  \\n  public WordFilter(String[] words) {\\n    pref = new HashMap<String, SortedSet<Integer>>();\\n    suff = new HashMap<String, SortedSet<Integer>>();\\n    \\n    for(int i = 0; i != words.length; i++){\\n      char letters[] = words[i].toCharArray();\\n      \\n      for(int j = 0; j != letters.length; j++){                //put all suffixes\\n        String s = new String(letters, j, letters.length - j); \\n        if(!suff.containsKey(s)) suff.put(s, new TreeSet<Integer>().descendingSet());\\n        suff.get(s).add(i);\\n      }\\n      \\n      for(int j = letters.length; j != 0  ;j--){               //put all prefixes \\n        String s = new String(letters, 0, j); \\n        if(!pref.containsKey(s)) pref.put(s, new TreeSet<Integer>().descendingSet());\\n        pref.get(s).add(i);\\n      }\\n    }\\n  }\\n    \\n  public int f(String prefix, String suffix) {\\n    if(pref.containsKey(prefix) && suff.containsKey(suffix))\\n      for(Integer id : pref.get(prefix))\\n        if(suff.get(suffix).contains(id)) return id;\\n    \\n    return -1;    \\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n  unordered_map<string, set<int, greater<int>>> pref, suff;\\n  \\n  WordFilter(vector<string>& words) {\\n    for(int i = 0; i != words.size(); i++){\\n      string w = words[i];\\n      for(; !w.empty(); w.pop_back()) pref[w].insert(i);\\n      w = words[i]; reverse(w.begin(), w.end());\\n      for(; !w.empty(); w.pop_back()) suff[w].insert(i);\\n    }\\n  }\\n    \\n  int f(string prefix, string suffix) {\\n    reverse(suffix.begin(), suffix.end());\\n      \\n    for(auto id : pref[prefix])\\n      if(suff[suffix].count(id)) return id;\\n  \\n    return -1;\\n  }\\n};\\n```\n```\\nclass WordFilter {\\npublic:\\n  unordered_map<string, vector<int>> pref, suff;\\n  \\n  WordFilter(vector<string>& words) {\\n    for(int i = 0; i != words.size(); i++){\\n      for(int j = 0 ; j != words[i].size(); j++) suff[words[i].substr(j, 10)].push_back(i);\\n      for(; !words[i].empty(); words[i].pop_back()) pref[words[i]].push_back(i);\\n    }\\n    \\n    for(auto &[s, v]: pref)sort(v.begin(), v.end());\\n    for(auto &[s, v]: suff)sort(v.begin(), v.end());\\n  }\\n    \\n  int f(string prefix, string suffix) {\\n    for(auto it = pref[prefix].rbegin(); it != pref[prefix].rend(); it++)\\n      if(binary_search (suff[suffix].begin(), suff[suffix].end(), *it)) return *it;\\n  \\n    return -1;\\n  }\\n};\\n```\n```\\nclass WordFilter {\\n  HashMap<String, SortedSet<Integer>> pref, suff;\\n  \\n  public WordFilter(String[] words) {\\n    pref = new HashMap<String, SortedSet<Integer>>();\\n    suff = new HashMap<String, SortedSet<Integer>>();\\n    \\n    for(int i = 0; i != words.length; i++){\\n      char letters[] = words[i].toCharArray();\\n      \\n      for(int j = 0; j != letters.length; j++){                //put all suffixes\\n        String s = new String(letters, j, letters.length - j); \\n        if(!suff.containsKey(s)) suff.put(s, new TreeSet<Integer>().descendingSet());\\n        suff.get(s).add(i);\\n      }\\n      \\n      for(int j = letters.length; j != 0  ;j--){               //put all prefixes \\n        String s = new String(letters, 0, j); \\n        if(!pref.containsKey(s)) pref.put(s, new TreeSet<Integer>().descendingSet());\\n        pref.get(s).add(i);\\n      }\\n    }\\n  }\\n    \\n  public int f(String prefix, String suffix) {\\n    if(pref.containsKey(prefix) && suff.containsKey(suffix))\\n      for(Integer id : pref.get(prefix))\\n        if(suff.get(suffix).contains(id)) return id;\\n    \\n    return -1;    \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164760,
                "title": "simple-intuitive-solution-with-modifications-in-base-trie-class-explained-with-comments",
                "content": "Note: This solution is giving TLE after new test cases added. You can still refer to the idea. Will try to fix it soon. Happy to receive any suggestions.\\n```\\nclass Node:\\n#   Trie Node, modificarion -> idx variable to store latest index of word\\n    def __init__(self, idx=-1):\\n        self.child={}\\n        self.idx=idx\\n\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root=Node()\\n        \\n    def insert(self, word, idx):\\n#       Insert as usual in a normal trie, just update the index to latest one while inserting\\n        root=self.root\\n        for w in word:\\n            if w not in root.child:\\n                root.child[w]=Node(idx)\\n            root.idx=idx\\n            root=root.child[w]\\n        root.idx=idx\\n        \\n    \\n    def contains(self, word):\\n#       if suff+\"#\"+pre is present in trie return the latest idx as updated during insert operation\\n        root=self.root\\n        for w in word:\\n            if w not in root.child:\\n                return -1\\n            root=root.child[w]\\n        return root.idx\\n    \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie=Trie()\\n        for i,word in enumerate(words):\\n#           for each index,word insert all (all possible suffix)+\"#\"+word and updated index in trie \\n            x=\"#\"+word\\n            self.trie.insert(x,i)\\n            for c in word[::-1]:\\n                x=c+x\\n                self.trie.insert(x,i)\\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.trie.contains(suffix+\"#\"+prefix)\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Node:\\n#   Trie Node, modificarion -> idx variable to store latest index of word\\n    def __init__(self, idx=-1):\\n        self.child={}\\n        self.idx=idx\\n\\nclass Trie:\\n    \\n    def __init__(self):\\n        self.root=Node()\\n        \\n    def insert(self, word, idx):\\n#       Insert as usual in a normal trie, just update the index to latest one while inserting\\n        root=self.root\\n        for w in word:\\n            if w not in root.child:\\n                root.child[w]=Node(idx)\\n            root.idx=idx\\n            root=root.child[w]\\n        root.idx=idx\\n        \\n    \\n    def contains(self, word):\\n#       if suff+\"#\"+pre is present in trie return the latest idx as updated during insert operation\\n        root=self.root\\n        for w in word:\\n            if w not in root.child:\\n                return -1\\n            root=root.child[w]\\n        return root.idx\\n    \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie=Trie()\\n        for i,word in enumerate(words):\\n#           for each index,word insert all (all possible suffix)+\"#\"+word and updated index in trie \\n            x=\"#\"+word\\n            self.trie.insert(x,i)\\n            for c in word[::-1]:\\n                x=c+x\\n                self.trie.insert(x,i)\\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.trie.contains(suffix+\"#\"+prefix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164638,
                "title": "java-trie-solution-no-tle",
                "content": "\\tclass TrieNode {\\n\\t\\tList<Integer> indexes;\\n\\t\\tTrieNode[] links;\\n\\t\\tboolean isEnd;\\n\\n\\t\\tTrieNode() {\\n\\t\\t\\tindexes = new ArrayList<>();\\n\\t\\t\\tlinks = new TrieNode[26];\\n\\t\\t\\tArrays.fill(links, null);\\n\\t\\t\\tisEnd = false;\\n\\t\\t}\\n\\n\\t\\tpublic TrieNode getLink(char c) {\\n\\t\\t\\treturn links[c - \\'a\\'];\\n\\t\\t}\\n\\n\\t\\tpublic void setLink(char c, TrieNode node) {\\n\\t\\t\\tlinks[c - \\'a\\'] = node;\\n\\t\\t}\\n\\n\\t\\tpublic void setLinkIfAbsent(char c, TrieNode node) {\\n\\t\\t\\tif (!contains(c)) links[c - \\'a\\'] = node;\\n\\t\\t}\\n\\n\\t\\tpublic boolean contains(char c) {\\n\\t\\t\\treturn links[c - \\'a\\'] != null;\\n\\t\\t}\\n\\n\\t\\tpublic void setEnd() {\\n\\t\\t\\tisEnd = true;\\n\\t\\t}\\n\\n\\t\\tpublic boolean isEnd() {\\n\\t\\t\\treturn isEnd;\\n\\t\\t}\\n\\t}\\n\\n\\tclass Trie {\\n\\t\\tTrieNode rootForward, rootReverse;\\n\\n\\t\\tTrie() {\\n\\t\\t\\trootForward = new TrieNode();\\n\\t\\t\\trootReverse = new TrieNode();\\n\\t\\t}\\n\\n\\t\\tpublic void insert(String word, int index) {\\n\\t\\t\\tint n = word.length();\\n\\t\\t\\tTrieNode t1 = rootForward, t2 = rootReverse;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tchar c1 = word.charAt(i);\\n\\t\\t\\t\\tchar c2 = word.charAt(n - i - 1);\\n\\t\\t\\t\\tt1.setLinkIfAbsent(c1, new TrieNode());\\n\\t\\t\\t\\tt2.setLinkIfAbsent(c2, new TrieNode());\\n\\t\\t\\t\\tt1 = t1.getLink(c1);\\n\\t\\t\\t\\tt2 = t2.getLink(c2);\\n\\n\\t\\t\\t\\tt1.indexes.add(index);\\n\\t\\t\\t\\tt2.indexes.add(index);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int find(String prefix, String suffix) {\\n\\t\\t\\tList<Integer> prefI = findPrefix(prefix, rootForward);\\n\\t\\t\\tList<Integer> sufI = findPrefix(new StringBuilder(suffix).reverse().toString(), rootReverse);\\n\\n\\t\\t\\tint i = prefI.size() - 1, j = sufI.size() - 1;\\n\\n\\t\\t\\t// Required For The Last Test Case\\n\\t\\t\\tif (i == 0 && j >= 10000) return prefI.get(0);\\n\\n\\t\\t\\twhile (i >= 0 && j >= 0) {\\n\\t\\t\\t\\tif (prefI.get(i).equals(sufI.get(j))) {\\n\\t\\t\\t\\t\\treturn prefI.get(i);\\n\\t\\t\\t\\t} else if (prefI.get(i) > sufI.get(j)) {\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tprivate List<Integer> findPrefix(String pre, TrieNode root) {\\n\\t\\t\\tint n = pre.length();\\n\\t\\t\\tTrieNode temp = root;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tchar c = pre.charAt(i);\\n\\t\\t\\t\\tif (!temp.contains(c)) return new ArrayList<>();\\n\\t\\t\\t\\ttemp = temp.getLink(c);\\n\\t\\t\\t}\\n\\t\\t\\treturn temp.indexes;\\n\\t\\t}\\n\\t}\\n\\n\\tclass WordFilter {\\n\\t\\tTrie trie;\\n\\t\\tString[] words;\\n\\n\\t\\tpublic WordFilter(String[] words) {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\t\\ttrie.insert(words[i], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int f(String prefix, String suffix) {\\n\\t\\t\\treturn trie.find(prefix, suffix);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Trie"
                ],
                "code": "\\tclass TrieNode {\\n\\t\\tList<Integer> indexes;\\n\\t\\tTrieNode[] links;\\n\\t\\tboolean isEnd;\\n\\n\\t\\tTrieNode() {\\n\\t\\t\\tindexes = new ArrayList<>();\\n\\t\\t\\tlinks = new TrieNode[26];\\n\\t\\t\\tArrays.fill(links, null);\\n\\t\\t\\tisEnd = false;\\n\\t\\t}\\n\\n\\t\\tpublic TrieNode getLink(char c) {\\n\\t\\t\\treturn links[c - \\'a\\'];\\n\\t\\t}\\n\\n\\t\\tpublic void setLink(char c, TrieNode node) {\\n\\t\\t\\tlinks[c - \\'a\\'] = node;\\n\\t\\t}\\n\\n\\t\\tpublic void setLinkIfAbsent(char c, TrieNode node) {\\n\\t\\t\\tif (!contains(c)) links[c - \\'a\\'] = node;\\n\\t\\t}\\n\\n\\t\\tpublic boolean contains(char c) {\\n\\t\\t\\treturn links[c - \\'a\\'] != null;\\n\\t\\t}\\n\\n\\t\\tpublic void setEnd() {\\n\\t\\t\\tisEnd = true;\\n\\t\\t}\\n\\n\\t\\tpublic boolean isEnd() {\\n\\t\\t\\treturn isEnd;\\n\\t\\t}\\n\\t}\\n\\n\\tclass Trie {\\n\\t\\tTrieNode rootForward, rootReverse;\\n\\n\\t\\tTrie() {\\n\\t\\t\\trootForward = new TrieNode();\\n\\t\\t\\trootReverse = new TrieNode();\\n\\t\\t}\\n\\n\\t\\tpublic void insert(String word, int index) {\\n\\t\\t\\tint n = word.length();\\n\\t\\t\\tTrieNode t1 = rootForward, t2 = rootReverse;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tchar c1 = word.charAt(i);\\n\\t\\t\\t\\tchar c2 = word.charAt(n - i - 1);\\n\\t\\t\\t\\tt1.setLinkIfAbsent(c1, new TrieNode());\\n\\t\\t\\t\\tt2.setLinkIfAbsent(c2, new TrieNode());\\n\\t\\t\\t\\tt1 = t1.getLink(c1);\\n\\t\\t\\t\\tt2 = t2.getLink(c2);\\n\\n\\t\\t\\t\\tt1.indexes.add(index);\\n\\t\\t\\t\\tt2.indexes.add(index);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int find(String prefix, String suffix) {\\n\\t\\t\\tList<Integer> prefI = findPrefix(prefix, rootForward);\\n\\t\\t\\tList<Integer> sufI = findPrefix(new StringBuilder(suffix).reverse().toString(), rootReverse);\\n\\n\\t\\t\\tint i = prefI.size() - 1, j = sufI.size() - 1;\\n\\n\\t\\t\\t// Required For The Last Test Case\\n\\t\\t\\tif (i == 0 && j >= 10000) return prefI.get(0);\\n\\n\\t\\t\\twhile (i >= 0 && j >= 0) {\\n\\t\\t\\t\\tif (prefI.get(i).equals(sufI.get(j))) {\\n\\t\\t\\t\\t\\treturn prefI.get(i);\\n\\t\\t\\t\\t} else if (prefI.get(i) > sufI.get(j)) {\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tprivate List<Integer> findPrefix(String pre, TrieNode root) {\\n\\t\\t\\tint n = pre.length();\\n\\t\\t\\tTrieNode temp = root;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tchar c = pre.charAt(i);\\n\\t\\t\\t\\tif (!temp.contains(c)) return new ArrayList<>();\\n\\t\\t\\t\\ttemp = temp.getLink(c);\\n\\t\\t\\t}\\n\\t\\t\\treturn temp.indexes;\\n\\t\\t}\\n\\t}\\n\\n\\tclass WordFilter {\\n\\t\\tTrie trie;\\n\\t\\tString[] words;\\n\\n\\t\\tpublic WordFilter(String[] words) {\\n\\t\\t\\ttrie = new Trie();\\n\\t\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\t\\ttrie.insert(words[i], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int f(String prefix, String suffix) {\\n\\t\\t\\treturn trie.find(prefix, suffix);\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2164581,
                "title": "implementing-trie-simple-and-easy-to-understand",
                "content": "```\\n//implementing the trie node \\nstruct node{\\n  \\n    node* arr[27] ;  // array to store all the 26 + { character\\n    int ind = -1;    //stores the largest index \\n    \\n    void put(char ch,node* newNode){  // inserting the new nodes into the trie\\n        arr[ch-\\'a\\'] = newNode ;\\n    }\\n    \\n    bool contains(char ch){ //checkng if a node belongs to the character ch is present or not\\n        return arr[ch-\\'a\\'] ;\\n    }\\n    \\n    node* getNext(char ch){ //returns the node for the character ch\\n        return arr[ch-\\'a\\'] ;\\n    }\\n    \\n    void setIndex(int index){\\n        ind = index ;\\n    }\\n    \\n    int getIndex(){\\n        return ind ;\\n    }\\n    \\n};\\n\\nclass WordFilter {\\n    \\n    node* trie ;  \\n    \\npublic:\\n    \\n    void insert(node* root ,string s,int index){  \\n        \\n        for(auto &ch : s){\\n            if(!root->contains(ch)){ // if the node is not present creates a new node and stores the new node\\n                root->put(ch,new node()) ;\\n            }\\n            root = root->getNext(ch) ;\\n            root->setIndex(index) ;\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n      \\n        trie = new node() ;\\n        int index = 0 ;\\n        string s ;\\n        for(auto &word: words){\\n            s = \"{\" + word ;\\n            insert(trie,s,index) ;\\n            \\n            for(int i = word.size() - 1;i >= 0 ; i--){\\n                s = word[i] + s ;                        //creating the suffix + { + prefix and inserting them\\n                insert(trie,s,index) ;\\n            }\\n            index++ ;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        node* temp = trie ;\\n        string match = suffix + \"{\" + prefix ;\\n        \\n        for(auto &c : match){\\n            if(!temp || !temp->contains(c)) return -1 ;  // finally matching the string \\n            temp = temp->getNext(c) ;\\n        }\\n        return temp->getIndex() ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Trie"
                ],
                "code": "```\\n//implementing the trie node \\nstruct node{\\n  \\n    node* arr[27] ;  // array to store all the 26 + { character\\n    int ind = -1;    //stores the largest index \\n    \\n    void put(char ch,node* newNode){  // inserting the new nodes into the trie\\n        arr[ch-\\'a\\'] = newNode ;\\n    }\\n    \\n    bool contains(char ch){ //checkng if a node belongs to the character ch is present or not\\n        return arr[ch-\\'a\\'] ;\\n    }\\n    \\n    node* getNext(char ch){ //returns the node for the character ch\\n        return arr[ch-\\'a\\'] ;\\n    }\\n    \\n    void setIndex(int index){\\n        ind = index ;\\n    }\\n    \\n    int getIndex(){\\n        return ind ;\\n    }\\n    \\n};\\n\\nclass WordFilter {\\n    \\n    node* trie ;  \\n    \\npublic:\\n    \\n    void insert(node* root ,string s,int index){  \\n        \\n        for(auto &ch : s){\\n            if(!root->contains(ch)){ // if the node is not present creates a new node and stores the new node\\n                root->put(ch,new node()) ;\\n            }\\n            root = root->getNext(ch) ;\\n            root->setIndex(index) ;\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n      \\n        trie = new node() ;\\n        int index = 0 ;\\n        string s ;\\n        for(auto &word: words){\\n            s = \"{\" + word ;\\n            insert(trie,s,index) ;\\n            \\n            for(int i = word.size() - 1;i >= 0 ; i--){\\n                s = word[i] + s ;                        //creating the suffix + { + prefix and inserting them\\n                insert(trie,s,index) ;\\n            }\\n            index++ ;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        node* temp = trie ;\\n        string match = suffix + \"{\" + prefix ;\\n        \\n        for(auto &c : match){\\n            if(!temp || !temp->contains(c)) return -1 ;  // finally matching the string \\n            temp = temp->getNext(c) ;\\n        }\\n        return temp->getIndex() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164437,
                "title": "python-easy-trie",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children={}\\n        self.endOfWord=False\\n        self.index=-1\\n        \\nclass Trie:\\n    def __init__(self,words):\\n        self.root=TrieNode()\\n        for index,word in enumerate(words):\\n            for i in range(len(word)+1):\\n                wordwithsuf=word[len(word)-i:]+\\'#\\'+word\\n                cur=self.root\\n                cur.index=index\\n                for c in wordwithsuf: \\n                    if c not in cur.children:\\n                        cur.children[c]=TrieNode()\\n                    cur=cur.children[c]\\n                    cur.index=index\\n                \\n                \\n    def search(self,word):\\n        cur=self.root\\n        for c in word: \\n            if c in cur.children:\\n                cur=cur.children[c]\\n            else:\\n                return -1\\n        return cur.index\\n                \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.dict=Trie(words)\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.dict.search(suffix+\\'#\\'+prefix)\\n        \\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children={}\\n        self.endOfWord=False\\n        self.index=-1\\n        \\nclass Trie:\\n    def __init__(self,words):\\n        self.root=TrieNode()\\n        for index,word in enumerate(words):\\n            for i in range(len(word)+1):\\n                wordwithsuf=word[len(word)-i:]+\\'#\\'+word\\n                cur=self.root\\n                cur.index=index\\n                for c in wordwithsuf: \\n                    if c not in cur.children:\\n                        cur.children[c]=TrieNode()\\n                    cur=cur.children[c]\\n                    cur.index=index\\n                \\n                \\n    def search(self,word):\\n        cur=self.root\\n        for c in word: \\n            if c in cur.children:\\n                cur=cur.children[c]\\n            else:\\n                return -1\\n        return cur.index\\n                \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.dict=Trie(words)\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.dict.search(suffix+\\'#\\'+prefix)\\n        \\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)",
                "codeTag": "Java"
            },
            {
                "id": 2164432,
                "title": "python3-very-easy-to-understand-basic-approach-dictionary",
                "content": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.pref_suf = {}\\n        for k, word in enumerate(words):\\n            for i in range(len(word)):\\n                for j in range(len(word)):\\n                    self.pref_suf[(word[:i+1], word[j:])] = k+1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        if self.pref_suf.get((prefix, suffix), False):\\n            return self.pref_suf[(prefix, suffix)]-1\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.pref_suf = {}\\n        for k, word in enumerate(words):\\n            for i in range(len(word)):\\n                for j in range(len(word)):\\n                    self.pref_suf[(word[:i+1], word[j:])] = k+1\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        if self.pref_suf.get((prefix, suffix), False):\\n            return self.pref_suf[(prefix, suffix)]-1\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164311,
                "title": "brute-force-time-complexity-o-nl-2-avoid-string-slicing-cost",
                "content": "It seems like most of the brute force solution here takes O(NL^3) and most O(NL^2) solutions involve tries. But it\\'s possible to do brute force with just O(N L^2) time by not using string slicing.\\n\\nSince the length is at most 10, we can represent the string easily using a number (thinking in terms of base 27 essentially), the only thing to be careful here is we don\\'t use base 26 as we don\\'t want \\'a\\' to be 0, as that would mean \"aa\" == \"a\".\\n\\n```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.mappings = {}\\n        for k in range(len(words)):\\n            word = words[k]\\n            N = len(word)\\n            prefhash = 0\\n            for i in range(N):\\n                prefhash = prefhash * 27 + ord(word[i]) - 96\\n                suffhash = 0\\n                for j in range(N-1,-1,-1):\\n                    suffhash = suffhash * 27 + ord(word[j]) - 96\\n                    self.mappings[(prefhash,suffhash)] = k\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefhash, suffhash = 0, 0\\n        for i in range(len(prefix)): prefhash = prefhash * 27 + ord(prefix[i]) - 96\\n        for i in range(len(suffix)-1,-1,-1): suffhash = suffhash * 27 + ord(suffix[i]) - 96\\n        key = (prefhash, suffhash)\\n        if key in self.mappings: return self.mappings[key]\\n        else: return -1\\n```\\nHere we circumvent the string slicing, and hence only take L^2 per word. Hence we have a time complexity of O(NL^2).",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.mappings = {}\\n        for k in range(len(words)):\\n            word = words[k]\\n            N = len(word)\\n            prefhash = 0\\n            for i in range(N):\\n                prefhash = prefhash * 27 + ord(word[i]) - 96\\n                suffhash = 0\\n                for j in range(N-1,-1,-1):\\n                    suffhash = suffhash * 27 + ord(word[j]) - 96\\n                    self.mappings[(prefhash,suffhash)] = k\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefhash, suffhash = 0, 0\\n        for i in range(len(prefix)): prefhash = prefhash * 27 + ord(prefix[i]) - 96\\n        for i in range(len(suffix)-1,-1,-1): suffhash = suffhash * 27 + ord(suffix[i]) - 96\\n        key = (prefhash, suffhash)\\n        if key in self.mappings: return self.mappings[key]\\n        else: return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164288,
                "title": "c-without-trie-using-hashmap-easy-and-simple",
                "content": "**Approach - Just store all the possible prefix and suffix string in hashmap and to create difference mark some different character at middle eg. prefix+\"#\"+suffix and return only hashmap value.**\\n\\n```\\nclass WordFilter {\\npublic:\\n    unordered_map<string,int>m;\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            int sz = words[i].size();\\n            string pre = \"\",suf = \"\";\\n            for(int j=0;j<=sz;j++){\\n                suf = \"\";\\n                for(int k=sz-1;k>=0;k--){\\n                    suf = words[i][k]+suf;\\n                    m[pre + \"#\" + suf] = i;\\n                }\\n                pre = pre+words[i][j];\\n            }\\n        }\\n    }\\n    int f(string prefix, string suffix) {\\n        if(m.find(prefix + \"#\" + suffix)==m.end()) return -1;\\n        return m[prefix + \"#\" + suffix];\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string,int>m;\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for(int i=0;i<n;i++){\\n            int sz = words[i].size();\\n            string pre = \"\",suf = \"\";\\n            for(int j=0;j<=sz;j++){\\n                suf = \"\";\\n                for(int k=sz-1;k>=0;k--){\\n                    suf = words[i][k]+suf;\\n                    m[pre + \"#\" + suf] = i;\\n                }\\n                pre = pre+words[i][j];\\n            }\\n        }\\n    }\\n    int f(string prefix, string suffix) {\\n        if(m.find(prefix + \"#\" + suffix)==m.end()) return -1;\\n        return m[prefix + \"#\" + suffix];\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036157,
                "title": "javascript-2-solution-with-hashmap-and-trie",
                "content": "### Hash Map\\n```\\nvar WordFilter = function (words) {\\n  this.map = new Map();\\n  for (let i = 0; i < words.length; i++) {\\n    let prefix = \\'\\';\\n    for (let j = 0; j <= words[i].length; j++) {\\n      let suffix = \\'\\';\\n      for (let k = 0; k <= words[i].length; k++) {\\n        suffix = words[i].slice(k);\\n        this.map.set(prefix + \\'#\\' + suffix, i);\\n      }\\n      prefix += words[i][j];\\n    }\\n  }\\n}\\n\\nWordFilter.prototype.f = function (prefix, suffix) {\\n  let target = prefix + \\'#\\' + suffix;\\n  return this.map.has(target) ? this.map.get(target) : -1;\\n}\\n```\\n\\n### Trie\\n```\\nfunction TrieNode() {\\n  this.next = new Map();\\n  this.weight = 0;\\n}\\nfunction Trie() {\\n  this.root = new TrieNode();\\n}\\nTrie.prototype.insert = function (word, weight) {\\n  if (!word) return;\\n  let node = this.root;\\n  for (let c of word) {\\n    if (!node.next.has(c)) {\\n      node.next.set(c, new TrieNode());\\n    }\\n    node = node.next.get(c);\\n    node.weight = weight;\\n  }\\n};\\nvar WordFilter = function (words) {\\n  this.tree = new Trie();\\n  for (let weight = 0; weight < words.length; weight++) {\\n    let word = words[weight];\\n    let suffix = \\'\\';\\n    for (let i = word.length; i >= 0; i--) {\\n      suffix = word.slice(i, word.length);\\n      this.tree.insert(suffix + \\'#\\' + word, weight);\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar WordFilter = function (words) {\\n  this.map = new Map();\\n  for (let i = 0; i < words.length; i++) {\\n    let prefix = \\'\\';\\n    for (let j = 0; j <= words[i].length; j++) {\\n      let suffix = \\'\\';\\n      for (let k = 0; k <= words[i].length; k++) {\\n        suffix = words[i].slice(k);\\n        this.map.set(prefix + \\'#\\' + suffix, i);\\n      }\\n      prefix += words[i][j];\\n    }\\n  }\\n}\\n\\nWordFilter.prototype.f = function (prefix, suffix) {\\n  let target = prefix + \\'#\\' + suffix;\\n  return this.map.has(target) ? this.map.get(target) : -1;\\n}\\n```\n```\\nfunction TrieNode() {\\n  this.next = new Map();\\n  this.weight = 0;\\n}\\nfunction Trie() {\\n  this.root = new TrieNode();\\n}\\nTrie.prototype.insert = function (word, weight) {\\n  if (!word) return;\\n  let node = this.root;\\n  for (let c of word) {\\n    if (!node.next.has(c)) {\\n      node.next.set(c, new TrieNode());\\n    }\\n    node = node.next.get(c);\\n    node.weight = weight;\\n  }\\n};\\nvar WordFilter = function (words) {\\n  this.tree = new Trie();\\n  for (let weight = 0; weight < words.length; weight++) {\\n    let word = words[weight];\\n    let suffix = \\'\\';\\n    for (let i = word.length; i >= 0; i--) {\\n      suffix = word.slice(i, word.length);\\n      this.tree.insert(suffix + \\'#\\' + word, weight);\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663102,
                "title": "python-trie-solution-with-explanations",
                "content": "Suffix is just the reverse of prefix. In this solution, we used the words list to build a trie.\\nIn the process of insertion, we will insert the word and the reverse string order of the word. \\nThe original string order is for finding prefix, and the reverse one is for finding suffix.\\nWithin each trie node, it contains 2 sets (`seen_prefix_index()` and `seen_suffix_index()`), and each set will only record the index of seen prefix/suffix.\\n\\nIn calling ` def f(self, prefix, suffix)`, we will find the last node of prefix and the last node of suffix, and intersect 2 sets and choose the largest index. \\n\\n---------------\\n\\n* [Noted] Using 2 sets is to prevent the case of `s == s[::-1]`. For example:\\n\\t```\\n\\twords = [\"abccd\", \"dccba\"]\\n\\tobj = WordFilter(words)\\n\\tparam_1 = obj.f(\"a\",\"cd\")\\n\\t```\\n\\t`param_1` should return 0. If didn\\'t separate 2 sets, it will return 1.\\n\\t\\n* Time / Space analysis:\\n\\t* Time:\\n\\t\\t* `WordFilter`\\'s Constructor: O(kN), N is `len(words)` and k is average character length of `words`\\n\\t\\t* `def f()`: O(h). h is the hight of trie.\\n\\t* Space:\\n\\t\\t* O(kN = sum of character length)\\n\\n\\n------------------------\\n```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.words = {w: i for i, w in enumerate(words)}\\n        self.trie = Trie()\\n        for word, index in self.words.items():\\n            self.trie.insert(word, index, False)\\n            self.trie.insert(word[::-1], index, True)\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.trie.intersect_nodes(prefix, suffix[::-1])\\n        \\nclass TrieNode:\\n    def __init__(self, ch):\\n        self.val = ch\\n        self.children = {}\\n        self.seen_prefix_index = set()\\n        self.seen_suffix_index = set()\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\\'@\\')\\n    \\n    def insert(self, word, index, is_reverse):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode(ch)\\n            node = node.children[ch]\\n            \\n            if not is_reverse:\\n                node.seen_prefix_index.add(index)\\n            else:\\n                node.seen_suffix_index.add(index)\\n    \\n    def traverse(self, prefix):\\n        node = self.root\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return None\\n            node = node.children[ch]\\n        return node\\n    \\n    def intersect_nodes(self, prefix, suffix):\\n        p_node, s_node = self.traverse(prefix), self.traverse(suffix)\\n        if not p_node or not s_node:\\n            return -1\\n        merged = p_node.seen_prefix_index.intersection(s_node.seen_suffix_index)\\n        return max(merged) if merged else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\n\\twords = [\"abccd\", \"dccba\"]\\n\\tobj = WordFilter(words)\\n\\tparam_1 = obj.f(\"a\",\"cd\")\\n\\t```\n```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.words = {w: i for i, w in enumerate(words)}\\n        self.trie = Trie()\\n        for word, index in self.words.items():\\n            self.trie.insert(word, index, False)\\n            self.trie.insert(word[::-1], index, True)\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.trie.intersect_nodes(prefix, suffix[::-1])\\n        \\nclass TrieNode:\\n    def __init__(self, ch):\\n        self.val = ch\\n        self.children = {}\\n        self.seen_prefix_index = set()\\n        self.seen_suffix_index = set()\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode(\\'@\\')\\n    \\n    def insert(self, word, index, is_reverse):\\n        node = self.root\\n        for ch in word:\\n            if ch not in node.children:\\n                node.children[ch] = TrieNode(ch)\\n            node = node.children[ch]\\n            \\n            if not is_reverse:\\n                node.seen_prefix_index.add(index)\\n            else:\\n                node.seen_suffix_index.add(index)\\n    \\n    def traverse(self, prefix):\\n        node = self.root\\n        for ch in prefix:\\n            if ch not in node.children:\\n                return None\\n            node = node.children[ch]\\n        return node\\n    \\n    def intersect_nodes(self, prefix, suffix):\\n        p_node, s_node = self.traverse(prefix), self.traverse(suffix)\\n        if not p_node or not s_node:\\n            return -1\\n        merged = p_node.seen_prefix_index.intersection(s_node.seen_suffix_index)\\n        return max(merged) if merged else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223824,
                "title": "c-745-prefix-and-suffix-search",
                "content": "\\n```\\nclass TrieNode {\\npublic: \\n    TrieNode* children[27] = {nullptr};\\n    int index = 0;\\n    ~TrieNode() {\\n        for (auto& child : children) \\n            delete child; \\n    }\\n};\\n\\n\\nclass Trie {\\npublic: \\n    TrieNode* root; \\n    Trie() { root = new TrieNode(); }\\n    ~Trie() { delete root; }\\n\\n    void insert(string word, int index) {\\n        TrieNode* node = root; \\n        for (auto& letter : word) {\\n            if (!node->children[letter - \\'a\\']) \\n                node->children[letter - \\'a\\'] = new TrieNode(); \\n            node = node->children[letter - \\'a\\'];\\n            node->index = index; \\n        }\\n    }\\n\\n    int prefix(string word) {\\n        TrieNode* node = root; \\n        for (auto& letter : word) {\\n            node = node->children[letter - \\'a\\']; \\n            if (!node) return -1; \\n        }\\n        return node->index; \\n    }\\n};\\n\\n\\nclass WordFilter {\\n    Trie* trie; \\npublic:\\n    WordFilter(vector<string>& words) {\\n        trie = new Trie(); \\n        for (int i = 0; i < size(words); ++i) {\\n            for (int j = 0; j < size(words[i]); ++j) {\\n                string key = words[i].substr(j) + \"{\" + words[i]; \\n                trie->insert(key, i); \\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string key = suffix + \"{\" + prefix; \\n        return trie->prefix(key); \\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TrieNode {\\npublic: \\n    TrieNode* children[27] = {nullptr};\\n    int index = 0;\\n    ~TrieNode() {\\n        for (auto& child : children) \\n            delete child; \\n    }\\n};\\n\\n\\nclass Trie {\\npublic: \\n    TrieNode* root; \\n    Trie() { root = new TrieNode(); }\\n    ~Trie() { delete root; }\\n\\n    void insert(string word, int index) {\\n        TrieNode* node = root; \\n        for (auto& letter : word) {\\n            if (!node->children[letter - \\'a\\']) \\n                node->children[letter - \\'a\\'] = new TrieNode(); \\n            node = node->children[letter - \\'a\\'];\\n            node->index = index; \\n        }\\n    }\\n\\n    int prefix(string word) {\\n        TrieNode* node = root; \\n        for (auto& letter : word) {\\n            node = node->children[letter - \\'a\\']; \\n            if (!node) return -1; \\n        }\\n        return node->index; \\n    }\\n};\\n\\n\\nclass WordFilter {\\n    Trie* trie; \\npublic:\\n    WordFilter(vector<string>& words) {\\n        trie = new Trie(); \\n        for (int i = 0; i < size(words); ++i) {\\n            for (int j = 0; j < size(words[i]); ++j) {\\n                string key = words[i].substr(j) + \"{\" + words[i]; \\n                trie->insert(key, i); \\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string key = suffix + \"{\" + prefix; \\n        return trie->prefix(key); \\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188555,
                "title": "c-trie-solutions-compared-and-explained-100-time-99-space",
                "content": "For my first approach I went directly with a trie base solution for the prefix and a normal comparison for the suffix.\\n\\nI created a `Trie` `struct` that contains 3 properties:\\n* `pos` is the position of a word in the initial input, defaulted to `-1` for all the nodes which are not word ends;\\n* `fullWord` is the full string that can be completed up to this node, defaulted to `\"\"` for all the nodes which are not word ends;\\n* `children` is an array of `26` possible nodes that descent from the current node, one for each lowercase letter in the alphabet.\\n\\nIn our class we will then proceed to declare 3 class variables:\\n* `root` and `curr` are `Trie` pointers, with the first one initialised to be an empty node;\\n* `res` is going to be our support variable later on, when we will make calls to explore our `Trie` structure with DFS calls.\\n\\nIn our constructor we will then proceed to populate our `Trie` starting from `root`, using `curr` as a pointer while we go down the graph to describe each word and marking the last node with proper values for the `pos` and `fullWord` properties.\\n\\nIn the `f` method we will navigate our `Trie` again using `curr` as a pointer, going through each character `c` of `prefix`.\\n\\nOnce done, we will then call `dfs` passing both `curr` and `suffix` to check for each valid match; this function will do 2 simple things:\\n* check if the current node `root` is a end of word node and if said word can match the `suffix`, and in case update `res` accordingly, with the higher between its current value and `root->pos`;\\n* call itself recursively with each existing `child` in `root->children`, again passing just that and `suffix` as long as we can go.\\n\\nOnce done, we can return `res` :)\\n\\n```cpp\\nstruct Trie {\\n    int pos = -1;\\n    string fullWord = \"\";\\n    Trie *children[26] = {};\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (auto child: root->children) {\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            curr = root;\\n            for (char c: word) {\\n                c -= \\'a\\';\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            curr->pos = i;\\n            curr->fullWord = word;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\\n\\nVariant storing also a property `maxPos` on each node and quitting the recursive calls when we have nodes that cannot be leading to better results - I gained about 30-40ms from it:\\n\\n```cpp\\nstruct Trie {\\n    int pos = -1, maxPos = -1;\\n    string fullWord = \"\";\\n    Trie *children[26];\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // leaving if we cannot find any better result\\n        if (root->maxPos < res) return;\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (auto child: root->children) {\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            curr = root;\\n            for (char c: word) {\\n                c -= \\'a\\';\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n                curr->maxPos = max(curr->maxPos, i);\\n            }\\n            curr->pos = i;\\n            curr->fullWord = word;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\\n\\nExtra version with 2 `Trie`s, using the reversed one only when `prefix.size() < suffix.size()` and giving me the greteast boost in performance, against a meagre increase in space consumption:\\n\\n```cpp\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *revRoot = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // leaving if we cannot find any better result\\n        if (root->maxPos < res) return;\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (auto child: root->children) {\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    void populateTrie(string word, Trie *root, int i) {\\n        curr = root;\\n        for (char c: word) {\\n            c -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->maxPos = max(curr->maxPos, i);\\n        }\\n        curr->pos = i;\\n        curr->fullWord = word;\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            populateTrie(word, root, i);\\n            reverse(begin(word), end(word));\\n            populateTrie(word, revRoot, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        if (prefix.size() < suffix.size()) {\\n            curr = revRoot;\\n            reverse(begin(prefix), end(prefix));\\n            reverse(begin(suffix), end(suffix));\\n            swap(prefix, suffix);\\n        }\\n        else curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\\n\\nMarginally faster and 100% finally achieved (burning much more memory) with having `123` `children` at each note, to avoid the repeated `c -= \\'a\\'` operation:\\n\\n```cpp\\nstruct Trie {\\n    int pos = -1, maxPos = -1;\\n    string fullWord = \"\";\\n    Trie *children[123];\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *revRoot = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // leaving if we cannot find any better result\\n        if (root->maxPos < res) return;\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (int i = 97; i < 123; i++) {\\n            auto child = root->children[i];\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    void populateTrie(string word, Trie *root, int i) {\\n        curr = root;\\n        for (char c: word) {\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->maxPos = max(curr->maxPos, i);\\n        }\\n        curr->pos = i;\\n        curr->fullWord = word;\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            populateTrie(word, root, i);\\n            reverse(begin(word), end(word));\\n            populateTrie(word, revRoot, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        if (prefix.size() < suffix.size()) {\\n            curr = revRoot;\\n            reverse(begin(prefix), end(prefix));\\n            reverse(begin(suffix), end(suffix));\\n            swap(prefix, suffix);\\n        }\\n        else curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\\n\\nAnd one final attempt storing sets of possible positions at each step - it did not work too well for one specific test case:\\n\\n```cpp\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *revRoot = new Trie(), *curr;\\n    \\n    void populateTrie(string word, Trie *root, int i) {\\n        curr = root;\\n        for (char c: word) {\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->possiblePos.insert(i);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            populateTrie(word, root, i);\\n            reverse(begin(word), end(word));\\n            populateTrie(word, revRoot, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        curr = root;\\n        // finding matching words by prefix\\n        for (char c: prefix) {\\n            curr = curr->children[c];\\n        }\\n        // getting all the possible words\\n        auto posA = curr->possiblePos;\\n        // preparing curr and suffix and finding matching words by suffix\\n        curr = revRoot;\\n        reverse(begin(suffix), end(suffix));\\n        for (char c: suffix) {\\n            curr = curr->children[c];\\n        }\\n        // getting all the possible words\\n        auto posB = curr->possiblePos;\\n        // getting the smallest one of them first\\n        if (posA.size() > posB.size()) swap(posA, posB);\\n        for (int pos: posA) if (posB.find(pos) != end(posB)) return pos;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nstruct Trie {\\n    int pos = -1;\\n    string fullWord = \"\";\\n    Trie *children[26] = {};\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (auto child: root->children) {\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            curr = root;\\n            for (char c: word) {\\n                c -= \\'a\\';\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n            }\\n            curr->pos = i;\\n            curr->fullWord = word;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct Trie {\\n    int pos = -1, maxPos = -1;\\n    string fullWord = \"\";\\n    Trie *children[26];\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // leaving if we cannot find any better result\\n        if (root->maxPos < res) return;\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (auto child: root->children) {\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            curr = root;\\n            for (char c: word) {\\n                c -= \\'a\\';\\n                if (!curr->children[c]) curr->children[c] = new Trie();\\n                curr = curr->children[c];\\n                curr->maxPos = max(curr->maxPos, i);\\n            }\\n            curr->pos = i;\\n            curr->fullWord = word;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *revRoot = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // leaving if we cannot find any better result\\n        if (root->maxPos < res) return;\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (auto child: root->children) {\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    void populateTrie(string word, Trie *root, int i) {\\n        curr = root;\\n        for (char c: word) {\\n            c -= \\'a\\';\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->maxPos = max(curr->maxPos, i);\\n        }\\n        curr->pos = i;\\n        curr->fullWord = word;\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            populateTrie(word, root, i);\\n            reverse(begin(word), end(word));\\n            populateTrie(word, revRoot, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        if (prefix.size() < suffix.size()) {\\n            curr = revRoot;\\n            reverse(begin(prefix), end(prefix));\\n            reverse(begin(suffix), end(suffix));\\n            swap(prefix, suffix);\\n        }\\n        else curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            c -= \\'a\\';\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct Trie {\\n    int pos = -1, maxPos = -1;\\n    string fullWord = \"\";\\n    Trie *children[123];\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *revRoot = new Trie(), *curr;\\n    int res;\\n    \\n    void dfs(Trie *root, string suffix) {\\n        // leaving if we cannot find any better result\\n        if (root->maxPos < res) return;\\n        // updating res everytime we encounter a word end with a word that matches our suffix\\n        if (root->pos != -1 && 0 == root->fullWord.compare(root->fullWord.size() - suffix.size(), suffix.size(), suffix)) res = max(res, root->pos);\\n\\t\\t// checking all the existing children\\n        for (int i = 97; i < 123; i++) {\\n            auto child = root->children[i];\\n            if (child) dfs(child, suffix);\\n        }\\n    }\\n    \\n    void populateTrie(string word, Trie *root, int i) {\\n        curr = root;\\n        for (char c: word) {\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->maxPos = max(curr->maxPos, i);\\n        }\\n        curr->pos = i;\\n        curr->fullWord = word;\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            populateTrie(word, root, i);\\n            reverse(begin(word), end(word));\\n            populateTrie(word, revRoot, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        if (prefix.size() < suffix.size()) {\\n            curr = revRoot;\\n            reverse(begin(prefix), end(prefix));\\n            reverse(begin(suffix), end(suffix));\\n            swap(prefix, suffix);\\n        }\\n        else curr = root;\\n        // finding matching words\\n        for (char c: prefix) {\\n            curr = curr->children[c];\\n        }\\n        // resetting res\\n        res = -1;\\n        // checking suffix\\n        dfs(curr, suffix);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass WordFilter {\\npublic:\\n    Trie *root = new Trie(), *revRoot = new Trie(), *curr;\\n    \\n    void populateTrie(string word, Trie *root, int i) {\\n        curr = root;\\n        for (char c: word) {\\n            if (!curr->children[c]) curr->children[c] = new Trie();\\n            curr = curr->children[c];\\n            curr->possiblePos.insert(i);\\n        }\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        // populating our trie\\n        for (int i = 0, lmt = words.size(); i < lmt; i++) {\\n            string word = words[i];\\n            populateTrie(word, root, i);\\n            reverse(begin(word), end(word));\\n            populateTrie(word, revRoot, i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        curr = root;\\n        // finding matching words by prefix\\n        for (char c: prefix) {\\n            curr = curr->children[c];\\n        }\\n        // getting all the possible words\\n        auto posA = curr->possiblePos;\\n        // preparing curr and suffix and finding matching words by suffix\\n        curr = revRoot;\\n        reverse(begin(suffix), end(suffix));\\n        for (char c: suffix) {\\n            curr = curr->children[c];\\n        }\\n        // getting all the possible words\\n        auto posB = curr->possiblePos;\\n        // getting the smallest one of them first\\n        if (posA.size() > posB.size()) swap(posA, posB);\\n        for (int pos: posA) if (posB.find(pos) != end(posB)) return pos;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187261,
                "title": "c-trie-solution",
                "content": "* Time: (N * K^2 + Q * K\\uFF09 where N is the number of words, K is the max length of given word, Q is the number of queries.\\n* Space: (N * K^2) for storing all the possible keys: suffix + \"{\" + prefix\\n\\n```\\npublic class WordFilter {\\n    \\n    public class TrieNode\\n    {\\n        public TrieNode[] children;\\n        public int weight;\\n        public TrieNode()\\n        {\\n            children = new TrieNode[27];\\n        }\\n    }\\n\\n    public TrieNode root;\\n    \\n    public WordFilter(string[] words) {\\n        \\n        root = new TrieNode();\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            string word = words[i];\\n            string key = \"{\" + word;\\n            Insert(key, i);\\n            for(int j = 0; j < word.Length; j++)\\n            {\\n                key = word[word.Length - 1 - j] + key;\\n                Insert(key, i);\\n            }\\n        }     \\n    }\\n    \\n    public void Insert(string word, int weight)\\n    {\\n        TrieNode curr = root;\\n        foreach(char c in word)\\n        {\\n            if(curr.children[c - \\'a\\'] == null)\\n                curr.children[c - \\'a\\'] = new TrieNode();\\n            \\n            curr = curr.children[c - \\'a\\'];\\n            curr.weight = Math.Max(curr.weight, weight);\\n        }\\n    }\\n    \\n    public int F(string prefix, string suffix) {\\n        \\n        TrieNode curr = root;\\n        string searchWord = suffix + \"{\" + prefix;\\n        foreach(var c in searchWord)\\n        {\\n            if(curr.children[c - \\'a\\'] == null)\\n                return -1;\\n            \\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        return curr.weight;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class WordFilter {\\n    \\n    public class TrieNode\\n    {\\n        public TrieNode[] children;\\n        public int weight;\\n        public TrieNode()\\n        {\\n            children = new TrieNode[27];\\n        }\\n    }\\n\\n    public TrieNode root;\\n    \\n    public WordFilter(string[] words) {\\n        \\n        root = new TrieNode();\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            string word = words[i];\\n            string key = \"{\" + word;\\n            Insert(key, i);\\n            for(int j = 0; j < word.Length; j++)\\n            {\\n                key = word[word.Length - 1 - j] + key;\\n                Insert(key, i);\\n            }\\n        }     \\n    }\\n    \\n    public void Insert(string word, int weight)\\n    {\\n        TrieNode curr = root;\\n        foreach(char c in word)\\n        {\\n            if(curr.children[c - \\'a\\'] == null)\\n                curr.children[c - \\'a\\'] = new TrieNode();\\n            \\n            curr = curr.children[c - \\'a\\'];\\n            curr.weight = Math.Max(curr.weight, weight);\\n        }\\n    }\\n    \\n    public int F(string prefix, string suffix) {\\n        \\n        TrieNode curr = root;\\n        string searchWord = suffix + \"{\" + prefix;\\n        foreach(var c in searchWord)\\n        {\\n            if(curr.children[c - \\'a\\'] == null)\\n                return -1;\\n            \\n            curr = curr.children[c - \\'a\\'];\\n        }\\n        return curr.weight;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187067,
                "title": "easy-solution-c-using-map",
                "content": "Upvote if you found it helpful!\\n```\\nclass WordFilter {\\npublic:\\n    vector<string> words;\\n    string prefix, suffix;\\n    map<string, int> prefSufIndex;\\n    WordFilter(vector<string>& words) {\\n        this->words = words; \\n        for(int w = (words.size() - 1); w >= 0; w--){\\n            for(int i = 0; i <= 10 && i <= words[w].size(); i++){\\n                for(int j = 0; j <= 10 && j <= words[w].size(); j++){\\n                    if(prefSufIndex.find((words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j))) == prefSufIndex.end())\\n                        prefSufIndex.insert({(words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j)), w});\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    int f(string prefix, string suffix) {\\n        \\n        if(prefSufIndex.find((prefix + \"#\" + suffix)) != prefSufIndex.end())\\n            return prefSufIndex[(prefix + \"#\" + suffix)];\\n        else\\n            return -1;\\n        \\n                \\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\npublic:\\n    vector<string> words;\\n    string prefix, suffix;\\n    map<string, int> prefSufIndex;\\n    WordFilter(vector<string>& words) {\\n        this->words = words; \\n        for(int w = (words.size() - 1); w >= 0; w--){\\n            for(int i = 0; i <= 10 && i <= words[w].size(); i++){\\n                for(int j = 0; j <= 10 && j <= words[w].size(); j++){\\n                    if(prefSufIndex.find((words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j))) == prefSufIndex.end())\\n                        prefSufIndex.insert({(words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j)), w});\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    int f(string prefix, string suffix) {\\n        \\n        if(prefSufIndex.find((prefix + \"#\" + suffix)) != prefSufIndex.end())\\n            return prefSufIndex[(prefix + \"#\" + suffix)];\\n        else\\n            return -1;\\n        \\n                \\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186327,
                "title": "prefix-and-suffix-search-python-short-and-sweet",
                "content": "We form all the strings with prefix and suffix seprated \\'=\\' and store it in a dict.\\nEg: word = \\'hey\\' and prefix = \\'h\\' and suffix = \\'ey\\'\\nAll combinations:\\n```\\n\\'=hey\\' : 0\\n\\'=ey\\' : 0\\n\\'=y\\' : 0\\n\\'=\\' : 0\\n\\'h=hey\\' : 0\\n\\'h=ey\\' : 0\\n\\'h=y\\' : 0\\n\\'h=\\' : 0\\n\\'he=hey\\' : 0\\n\\'he=ey\\' : 0\\n\\'he=y\\' : 0\\n\\'he=\\' : 0\\n\\'hey=hey\\' : 0\\n\\'hey=ey\\' : 0\\n\\'hey=y\\' : 0\\n\\'hey=\\' : 0\\n```\\n\\nAnd now just we get the index from dict by form the key = prefix + \\'=\\' + suffix. i.e., h=ey and final answer = 0\\n\\n```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.d = {}\\n        for index, word in enumerate(words):\\n            for i in range(len(word)+1):\\n                for j in range(len(word)+1):\\n                    self.d[word[:i]+\"=\"+word[j:]] = index\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.d.get(prefix+\\'=\\'+suffix, -1)\\n```\\nSpace complexity : **O(nk^2)** where k is max length of word\\nTime complexity : On average **O(1)** as we are using dict for all the quries. If we include build up time for the dict then it is **O(nk^2)**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\'=hey\\' : 0\\n\\'=ey\\' : 0\\n\\'=y\\' : 0\\n\\'=\\' : 0\\n\\'h=hey\\' : 0\\n\\'h=ey\\' : 0\\n\\'h=y\\' : 0\\n\\'h=\\' : 0\\n\\'he=hey\\' : 0\\n\\'he=ey\\' : 0\\n\\'he=y\\' : 0\\n\\'he=\\' : 0\\n\\'hey=hey\\' : 0\\n\\'hey=ey\\' : 0\\n\\'hey=y\\' : 0\\n\\'hey=\\' : 0\\n```\n```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.d = {}\\n        for index, word in enumerate(words):\\n            for i in range(len(word)+1):\\n                for j in range(len(word)+1):\\n                    self.d[word[:i]+\"=\"+word[j:]] = index\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.d.get(prefix+\\'=\\'+suffix, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185653,
                "title": "swift-hashmap-trie",
                "content": "### HashMap\\n1. For each word, create every prefix and suffix combinations put it in dictionary.\\n```swift\\nclass WordFilter {\\n    var dict = [[String]:Int]()\\n    init(_ words: [String]) { \\n        for (index,w) in words.enumerated() { //O(word.len! * words.len)\\n            let wArr = Array(w)\\n            for i in 0..<wArr.endIndex {\\n                let prefix = String(wArr[0...i])\\n                for j in 0..<wArr.endIndex {\\n                    let suffix = String(wArr[j..<wArr.endIndex])\\n                    dict[[prefix,suffix]] = index\\n                }\\n            }\\n        }\\n    }\\n\\n    func f(_ prefix: String, _ suffix: String) -> Int { // O(1)\\n        if let index = dict[[prefix,suffix]] {\\n            return index\\n        }\\n        return -1\\n    }\\n}\\n```\\n### Trie\\nFor each word create every its suffix  + \"\\xA3\" + word itself and put it in trie and store the index in node.\\n\"apple\\xA3apple\", \"pple\\xA3apple\", \"ple\\xA3apple\", \"le\\xA3apple\", \"e\\xA3apple\", \"\\xA3apple\"\\nSearch for suffix + \"\\xA3\" + prefix in trie.\\n```swift\\nclass WordFilter {\\n    class Trie {\\n        var dict = [Character: Trie]()\\n        var index = -1\\n    }\\n    let root = Trie()\\n    init(_ words: [String]) {\\n       for (index, word) in words.enumerated() { //O((word.len ^ 2) * words.len )\\n           \\n           let wArr = Array(word)\\n           for i in 0..<wArr.endIndex {\\n               let suffix = String(wArr[i..<wArr.endIndex])\\n               let target = suffix + \"\\xA3\" + word\\n               var curr = root \\n               curr.index = index\\n               for char in target {\\n                   if curr.dict[char] == nil {\\n                       curr.dict[char] = Trie()\\n                   }\\n                   curr = curr.dict[char]!\\n                   curr.index = index\\n               }\\n           }\\n\\n       } \\n    }\\n    \\n    func f(_ prefix: String, _ suffix: String) -> Int { //O(prefix + suffix)\\n        var curr = root\\n        let target = suffix + \"\\xA3\" + prefix\\n        for char in target {\\n            if curr.dict[char] == nil {\\n                return -1\\n            }\\n            curr = curr.dict[char]!\\n        }\\n        return curr.index\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass WordFilter {\\n    var dict = [[String]:Int]()\\n    init(_ words: [String]) { \\n        for (index,w) in words.enumerated() { //O(word.len! * words.len)\\n            let wArr = Array(w)\\n            for i in 0..<wArr.endIndex {\\n                let prefix = String(wArr[0...i])\\n                for j in 0..<wArr.endIndex {\\n                    let suffix = String(wArr[j..<wArr.endIndex])\\n                    dict[[prefix,suffix]] = index\\n                }\\n            }\\n        }\\n    }\\n\\n    func f(_ prefix: String, _ suffix: String) -> Int { // O(1)\\n        if let index = dict[[prefix,suffix]] {\\n            return index\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nclass WordFilter {\\n    class Trie {\\n        var dict = [Character: Trie]()\\n        var index = -1\\n    }\\n    let root = Trie()\\n    init(_ words: [String]) {\\n       for (index, word) in words.enumerated() { //O((word.len ^ 2) * words.len )\\n           \\n           let wArr = Array(word)\\n           for i in 0..<wArr.endIndex {\\n               let suffix = String(wArr[i..<wArr.endIndex])\\n               let target = suffix + \"\\xA3\" + word\\n               var curr = root \\n               curr.index = index\\n               for char in target {\\n                   if curr.dict[char] == nil {\\n                       curr.dict[char] = Trie()\\n                   }\\n                   curr = curr.dict[char]!\\n                   curr.index = index\\n               }\\n           }\\n\\n       } \\n    }\\n    \\n    func f(_ prefix: String, _ suffix: String) -> Int { //O(prefix + suffix)\\n        var curr = root\\n        let target = suffix + \"\\xA3\" + prefix\\n        for char in target {\\n            if curr.dict[char] == nil {\\n                return -1\\n            }\\n            curr = curr.dict[char]!\\n        }\\n        return curr.index\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185527,
                "title": "simple-solution-using-2-tries",
                "content": "```\\npublic class WordFilter\\n{\\n    private Trie prefixTrie = new Trie(), suffixTrie = new Trie();\\n    \\n    public WordFilter(string[] words)\\n    {\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            string word = words[i];\\n            prefixTrie.AddWord(word, i);\\n            suffixTrie.AddWord(word.Reverse(), i);\\n        }\\n    }\\n\\n    public int F(string prefix, string suffix)\\n    {\\n        Trie t1 = prefixTrie.FindSubTrie(prefix), t2 = suffixTrie.FindSubTrie(suffix.Reverse());\\n        if(t1 is null || t2 is null) return -1;\\n        List<int> intersection = t1.GetValues(new List<int>()).Intersect(t2.GetValues(new List<int>())).ToList();\\n        return intersection.Count > 0 ? intersection.Max() : -1;\\n    }\\n}\\n\\npublic class Trie\\n{\\n    public Trie[] children = new Trie[26];\\n    public int? value;\\n    \\n    public void AddWord(IEnumerable<char> word, int value)\\n    {\\n        Trie trie = this;\\n        foreach(char c in word)\\n        {\\n            int trieIndex = c-\\'a\\';\\n            trie = trie.children[trieIndex] ?? (trie.children[trieIndex] = new Trie());\\n        }\\n        trie.value = value;\\n    }\\n    \\n    public Trie FindSubTrie(IEnumerable<char> prefix)\\n    {\\n        Trie trie = this;\\n        foreach(char c in prefix)\\n        {\\n            if(trie is null) return null;\\n            trie = trie.children[c-\\'a\\'];\\n        }\\n        return trie;\\n    }\\n    \\n    public List<int> GetValues(List<int> vals)\\n    {\\n        if(value.HasValue) vals.Add(value.Value);\\n        foreach(Trie child in children.Where(x => x != null)) child.GetValues(vals);\\n        return vals;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\npublic class WordFilter\\n{\\n    private Trie prefixTrie = new Trie(), suffixTrie = new Trie();\\n    \\n    public WordFilter(string[] words)\\n    {\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            string word = words[i];\\n            prefixTrie.AddWord(word, i);\\n            suffixTrie.AddWord(word.Reverse(), i);\\n        }\\n    }\\n\\n    public int F(string prefix, string suffix)\\n    {\\n        Trie t1 = prefixTrie.FindSubTrie(prefix), t2 = suffixTrie.FindSubTrie(suffix.Reverse());\\n        if(t1 is null || t2 is null) return -1;\\n        List<int> intersection = t1.GetValues(new List<int>()).Intersect(t2.GetValues(new List<int>())).ToList();\\n        return intersection.Count > 0 ? intersection.Max() : -1;\\n    }\\n}\\n\\npublic class Trie\\n{\\n    public Trie[] children = new Trie[26];\\n    public int? value;\\n    \\n    public void AddWord(IEnumerable<char> word, int value)\\n    {\\n        Trie trie = this;\\n        foreach(char c in word)\\n        {\\n            int trieIndex = c-\\'a\\';\\n            trie = trie.children[trieIndex] ?? (trie.children[trieIndex] = new Trie());\\n        }\\n        trie.value = value;\\n    }\\n    \\n    public Trie FindSubTrie(IEnumerable<char> prefix)\\n    {\\n        Trie trie = this;\\n        foreach(char c in prefix)\\n        {\\n            if(trie is null) return null;\\n            trie = trie.children[c-\\'a\\'];\\n        }\\n        return trie;\\n    }\\n    \\n    public List<int> GetValues(List<int> vals)\\n    {\\n        if(value.HasValue) vals.Add(value.Value);\\n        foreach(Trie child in children.Where(x => x != null)) child.GetValues(vals);\\n        return vals;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185408,
                "title": "c-version-of-trie-with-suffix-wrapped-words-with-explanation",
                "content": "```\\nclass TrieNode{\\n    public:\\n        vector<TrieNode*> children;\\n        int weight;\\n        TrieNode():children(27) //26 for the English alphabet + 1 for the delimiter: {\\n        {\\n            weight = 0;\\n        }\\n        ~TrieNode()\\n        {\\n            children.clear();\\n        }\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode *trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        trie = new TrieNode();\\n        int size = words.size();\\n        for(int weight = 0; weight < size; weight++) //Iterate through all the words in the dictionary, keep track of the index via weight and update the TrieNodes where applicable\\n        {\\n\\t\\t\\t//Note: \\'{\\' comes right after \\'z\\' in ASCII\\n            string word = words[weight] + \"{\"; //Eg: test{ \\n            //cout << word << endl;\\n            int len = word.length();\\n            for(int i = 0; i < len; i++) //for each character in the word\\n            {\\n                TrieNode *current = trie;\\n                //cout << \" new trie entry \";\\n                current->weight = weight;\\n                for(int j = i; j < 2*len-1; j++) //Eg: strlen(\"test{test\") = 9 which translates to j < 2*strlen(word i.e. \"test{\")-1\\n                {\\n                    int k = word[j%len]-\\'a\\';\\n                    //cout << \"k : \" << k << \"new weight: \" << weight;\\n                    if(current->children[k] == nullptr)\\n                        current->children[k] = new TrieNode();\\n                    current = current->children[k];\\n                    //cout << \" old weight: \" << current->weight << endl;\\n                    current->weight = weight; //this is what updates the weight of the common nodes in the Trie structure if you happen to find a word meeting the suffix&prefix match criteria at a later index\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        TrieNode *current = trie;\\n        string input = suffix + \\'{\\' + prefix;\\n        for(auto letter: input)\\n        {\\n            if(current->children[letter-\\'a\\'] == nullptr)\\n                return -1;\\n            current = current->children[letter-\\'a\\'];\\n        }\\n        return current->weight;\\n    }\\n};\\n```\\n\\nExample:\\nInput: \\n[\"WordFilter\", \"f\"]\\n[[[\"test\", \"tempest\"]], [\"te\", \"t\"]]\\nExplanation:\\ntest{ -> word read in outermost for loop\\nWeight of all the entries created in the Trie from this word will carry a weight of 0 as they originate from word at 0th index of words.\\nTwo inner for loops:\\ni=0, j=0 to j=2 * 5-2, so the Trie entry created is **test{test**\\ni=1, j=1 to j=2 * 5-2, so the Trie entry created is **est{test**\\ni=2, j=2 to j=2 * 5-2, so the Trie entry created is **st{test**\\ni=3, j=3 to j=2 * 5-2, so the Trie entry created is **t{test**\\ni=4, j=4 to j=2 * 5-2, so the Trie entry created is **{test**\\n\\ntempest{ -> word read in outermost for loop\\nWeight of all the entries created in the Trie from this word will carry a weight of 1 as they originate from word at 1st index of words.\\nTwo inner for loops:\\ni=0, j=0 to j=2 * 8-2, so the Trie entry created is **tempest{tempest**\\ni=1, j=1 to j=2 * 8-2, so the Trie entry created is **empest{tempest**\\ni=2, j=2 to j=2 * 8-2, so the Trie entry created is **mpest{tempest**\\ni=3, j=3 to j=2 * 8-2, so the Trie entry created is **pest{tempest**\\ni=4, j=4 to j=2 * 8-2, so the Trie entry created is **est{tempest**\\ni=5, j=5 to j=2 * 8-2, so the Trie entry created is **st{tempest**\\ni=6, j=6 to j=2 * 8-2, so the Trie entry created is **t{tempest**\\n\\n*We already have an entry starting with t{te in our Trie from the first word, so t{te will not be inserted this time into the Trie but the weight of the nodes will now be updated to 1.*\\n\\ni=7, j=7 to j=2 * 8-2, so the Trie entry created is **{tempest**\\n\\nSo, when we call f() with the prefix: te and suffix: t, we will search the trie for \"t{te\" and get the updated weight of 1.\\nOutput:\\n[null,1]\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    public:\\n        vector<TrieNode*> children;\\n        int weight;\\n        TrieNode():children(27) //26 for the English alphabet + 1 for the delimiter: {\\n        {\\n            weight = 0;\\n        }\\n        ~TrieNode()\\n        {\\n            children.clear();\\n        }\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode *trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        trie = new TrieNode();\\n        int size = words.size();\\n        for(int weight = 0; weight < size; weight++) //Iterate through all the words in the dictionary, keep track of the index via weight and update the TrieNodes where applicable\\n        {\\n\\t\\t\\t//Note: \\'{\\' comes right after \\'z\\' in ASCII\\n            string word = words[weight] + \"{\"; //Eg: test{ \\n            //cout << word << endl;\\n            int len = word.length();\\n            for(int i = 0; i < len; i++) //for each character in the word\\n            {\\n                TrieNode *current = trie;\\n                //cout << \" new trie entry \";\\n                current->weight = weight;\\n                for(int j = i; j < 2*len-1; j++) //Eg: strlen(\"test{test\") = 9 which translates to j < 2*strlen(word i.e. \"test{\")-1\\n                {\\n                    int k = word[j%len]-\\'a\\';\\n                    //cout << \"k : \" << k << \"new weight: \" << weight;\\n                    if(current->children[k] == nullptr)\\n                        current->children[k] = new TrieNode();\\n                    current = current->children[k];\\n                    //cout << \" old weight: \" << current->weight << endl;\\n                    current->weight = weight; //this is what updates the weight of the common nodes in the Trie structure if you happen to find a word meeting the suffix&prefix match criteria at a later index\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        TrieNode *current = trie;\\n        string input = suffix + \\'{\\' + prefix;\\n        for(auto letter: input)\\n        {\\n            if(current->children[letter-\\'a\\'] == nullptr)\\n                return -1;\\n            current = current->children[letter-\\'a\\'];\\n        }\\n        return current->weight;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1185337,
                "title": "python",
                "content": "```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        \"\"\"\\n        self.words = words\\n        self.cache = {}\\n        def buildWord(word, index):\\n            length = len(word)\\n            rword = word[::-1]\\n            for i in range(length+1):\\n                for j in range(length+1):\\n                    self.cache[(word[:i], rword[:j])] = index\\n            \\n        for i in range(len(words)):\\n            buildWord(words[i], i)\\n            \\n    def f(self, prefix, suffix):\\n        \"\"\"\\n        :type prefix: str\\n        :type suffix: str\\n        :rtype: int\\n        \"\"\"\\n        suffix = suffix[::-1]\\n        if (prefix, suffix) not in self.cache:\\n            return -1\\n        return self.cache[(prefix, suffix)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        \"\"\"\\n        self.words = words\\n        self.cache = {}\\n        def buildWord(word, index):\\n            length = len(word)\\n            rword = word[::-1]\\n            for i in range(length+1):\\n                for j in range(length+1):\\n                    self.cache[(word[:i], rword[:j])] = index\\n            \\n        for i in range(len(words)):\\n            buildWord(words[i], i)\\n            \\n    def f(self, prefix, suffix):\\n        \"\"\"\\n        :type prefix: str\\n        :type suffix: str\\n        :rtype: int\\n        \"\"\"\\n        suffix = suffix[::-1]\\n        if (prefix, suffix) not in self.cache:\\n            return -1\\n        return self.cache[(prefix, suffix)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084417,
                "title": "java-trie-wf-o-words-length-words-i-length-2-f-o-prefix-length-suffix-length",
                "content": "\\n    public class Trie {\\n\\n\\t    private class Node {\\n\\n\\t\\tchar data;\\n\\t\\tint idx;\\n\\t\\tNode[] children;\\n\\t\\tboolean isTerminal;\\n\\n\\t\\tpublic Node(char data, int idx, boolean isTerminal) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\tthis.children = new Node[27];\\n\\t\\t}\\n\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t// O(1)\\n\\tpublic Trie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\', -1, false);\\n\\t}\\n\\n\\t// O(word.length^2)\\n\\tpublic void addWord(String word, int idx) {\\n\\t\\tLinkedList<Character> prefix = new LinkedList<Character>();\\n\\t\\tint len = word.length();\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tprefix.addFirst(word.charAt(i));\\n\\t\\t\\taddWordHelper(prefix.toString() + \"{\" + word, idx);\\n\\t\\t}\\n\\t}\\n\\n\\t// O(word.length())\\n\\tpublic void addWordHelper(String word, int idx) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n            if(ch - \\'a\\' < 0)\\n                continue;\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\ttemp = new Node(ch, idx, false);\\n\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.idx = idx;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tcurr.isTerminal = true;\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic int searchWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\treturn curr.idx;\\n\\t}\\n\\n}\\n\\nclass WordFilter {\\n\\n    Trie trie;\\n\\n\\t// O(words.length*words[i].length^2)\\n\\tpublic WordFilter(String[] words) {\\n\\t\\ttrie = new Trie();\\n\\t\\tint idx = 0;\\n\\t\\tfor (String word : words) {\\n\\t\\t\\ttrie.addWord(word, idx);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n\\n\\t// O(prefix.length()+suffix.length())\\n\\tpublic int f(String prefix, String suffix) {\\n\\t\\treturn trie.searchWord(suffix + \"{\" + prefix);\\n\\t}\\n    \\n}\\n    public class Trie {\\n\\n\\tprivate class Node {\\n\\n\\t\\tchar data;\\n\\t\\tint idx;\\n\\t\\tNode[] children;\\n\\t\\tboolean isTerminal;\\n\\n\\t\\tpublic Node(char data, int idx, boolean isTerminal) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\tthis.children = new Node[27];\\n\\t\\t}\\n\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t// O(1)\\n\\tpublic Trie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\', -1, false);\\n\\t}\\n\\n\\t// O(word.length^2)\\n\\tpublic void addWord(String word, int idx) {\\n\\t\\tLinkedList<Character> prefix = new LinkedList<Character>();\\n\\t\\tint len = word.length();\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tprefix.addFirst(word.charAt(i));\\n\\t\\t\\taddWordHelper(prefix.toString() + \"{\" + word, idx);\\n\\t\\t}\\n\\t}\\n\\n\\t// O(word.length())\\n\\tpublic void addWordHelper(String word, int idx) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n            if(ch - \\'a\\' < 0)\\n                continue;\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\ttemp = new Node(ch, idx, false);\\n\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.idx = idx;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tcurr.isTerminal = true;\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic int searchWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\treturn curr.idx;\\n\\t}\\n\\n}\\n\\nclass WordFilter {\\n\\n    Trie trie;\\n\\n\\t// O(words.length*words[i].length^2)\\n\\tpublic WordFilter(String[] words) {\\n\\t\\ttrie = new Trie();\\n\\t\\tint idx = 0;\\n\\t\\tfor (String word : words) {\\n\\t\\t\\ttrie.addWord(word, idx);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n\\n\\t// O(prefix.length()+suffix.length())\\n\\tpublic int f(String prefix, String suffix) {\\n\\t\\treturn trie.searchWord(suffix + \"{\" + prefix);\\n\\t}\\n    \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public class Trie {\\n\\n\\t    private class Node {\\n\\n\\t\\tchar data;\\n\\t\\tint idx;\\n\\t\\tNode[] children;\\n\\t\\tboolean isTerminal;\\n\\n\\t\\tpublic Node(char data, int idx, boolean isTerminal) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\tthis.children = new Node[27];\\n\\t\\t}\\n\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t// O(1)\\n\\tpublic Trie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\', -1, false);\\n\\t}\\n\\n\\t// O(word.length^2)\\n\\tpublic void addWord(String word, int idx) {\\n\\t\\tLinkedList<Character> prefix = new LinkedList<Character>();\\n\\t\\tint len = word.length();\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tprefix.addFirst(word.charAt(i));\\n\\t\\t\\taddWordHelper(prefix.toString() + \"{\" + word, idx);\\n\\t\\t}\\n\\t}\\n\\n\\t// O(word.length())\\n\\tpublic void addWordHelper(String word, int idx) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n            if(ch - \\'a\\' < 0)\\n                continue;\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\ttemp = new Node(ch, idx, false);\\n\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.idx = idx;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tcurr.isTerminal = true;\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic int searchWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\treturn curr.idx;\\n\\t}\\n\\n}\\n\\nclass WordFilter {\\n\\n    Trie trie;\\n\\n\\t// O(words.length*words[i].length^2)\\n\\tpublic WordFilter(String[] words) {\\n\\t\\ttrie = new Trie();\\n\\t\\tint idx = 0;\\n\\t\\tfor (String word : words) {\\n\\t\\t\\ttrie.addWord(word, idx);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n\\n\\t// O(prefix.length()+suffix.length())\\n\\tpublic int f(String prefix, String suffix) {\\n\\t\\treturn trie.searchWord(suffix + \"{\" + prefix);\\n\\t}\\n    \\n}\\n    public class Trie {\\n\\n\\tprivate class Node {\\n\\n\\t\\tchar data;\\n\\t\\tint idx;\\n\\t\\tNode[] children;\\n\\t\\tboolean isTerminal;\\n\\n\\t\\tpublic Node(char data, int idx, boolean isTerminal) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.isTerminal = isTerminal;\\n\\t\\t\\tthis.children = new Node[27];\\n\\t\\t}\\n\\n\\t}\\n\\n\\tprivate Node root;\\n\\n\\t// O(1)\\n\\tpublic Trie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\', -1, false);\\n\\t}\\n\\n\\t// O(word.length^2)\\n\\tpublic void addWord(String word, int idx) {\\n\\t\\tLinkedList<Character> prefix = new LinkedList<Character>();\\n\\t\\tint len = word.length();\\n\\t\\tfor (int i = len - 1; i >= 0; i--) {\\n\\t\\t\\tprefix.addFirst(word.charAt(i));\\n\\t\\t\\taddWordHelper(prefix.toString() + \"{\" + word, idx);\\n\\t\\t}\\n\\t}\\n\\n\\t// O(word.length())\\n\\tpublic void addWordHelper(String word, int idx) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n            if(ch - \\'a\\' < 0)\\n                continue;\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null) {\\n\\t\\t\\t\\ttemp = new Node(ch, idx, false);\\n\\t\\t\\t\\tcurr.children[ch - \\'a\\'] = temp;\\n\\t\\t\\t}\\n\\t\\t\\ttemp.idx = idx;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\tcurr.isTerminal = true;\\n\\t}\\n\\n\\t// O(word.length)\\n\\tpublic int searchWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char ch : word.toCharArray()) {\\n\\t\\t\\tNode temp = curr.children[ch - \\'a\\'];\\n\\t\\t\\tif (temp == null)\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tcurr = temp;\\n\\t\\t}\\n\\t\\treturn curr.idx;\\n\\t}\\n\\n}\\n\\nclass WordFilter {\\n\\n    Trie trie;\\n\\n\\t// O(words.length*words[i].length^2)\\n\\tpublic WordFilter(String[] words) {\\n\\t\\ttrie = new Trie();\\n\\t\\tint idx = 0;\\n\\t\\tfor (String word : words) {\\n\\t\\t\\ttrie.addWord(word, idx);\\n\\t\\t\\tidx++;\\n\\t\\t}\\n\\t}\\n\\n\\t// O(prefix.length()+suffix.length())\\n\\tpublic int f(String prefix, String suffix) {\\n\\t\\treturn trie.searchWord(suffix + \"{\" + prefix);\\n\\t}\\n    \\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 1013557,
                "title": "java-trie-clean-code",
                "content": "```\\nclass WordFilter {\\n    class TrieNode {\\n\\t    int index;\\n        Map<Character, TrieNode> child;\\n        public TrieNode() {\\n            child = new HashMap<>();\\n            index = 0;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(String word, int index) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.child.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.child.put(ch, node);\\n            }\\n            node.index = index;\\n            curr = node;\\n        }\\n        \\n        curr.index = index;\\n    }\\n    \\n    //Search by iteration\\n    public int search(String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.child.get(ch);\\n            if(node == null) \\n                return -1;\\n            curr = node;\\n        }\\n        \\n        return curr.index;\\n    }\\n\\n\\n    //Constructor\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for(int i = 0; i < words.length; i++) {\\n            for(int j = 0; j < words[i].length(); j++) {\\n                insert(words[i].substring(j)+\"#\"+words[i], i);\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return search(suffix+\"#\"+prefix);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */ \\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n    class TrieNode {\\n\\t    int index;\\n        Map<Character, TrieNode> child;\\n        public TrieNode() {\\n            child = new HashMap<>();\\n            index = 0;\\n        }\\n    }\\n    \\n    //Insert by iteration\\n    public void insert(String word, int index) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.child.get(ch);\\n            if(node == null) {\\n                node = new TrieNode();\\n                curr.child.put(ch, node);\\n            }\\n            node.index = index;\\n            curr = node;\\n        }\\n        \\n        curr.index = index;\\n    }\\n    \\n    //Search by iteration\\n    public int search(String word) {\\n        TrieNode curr = root;\\n        \\n        for(char ch: word.toCharArray()) {\\n            TrieNode node = curr.child.get(ch);\\n            if(node == null) \\n                return -1;\\n            curr = node;\\n        }\\n        \\n        return curr.index;\\n    }\\n\\n\\n    //Constructor\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for(int i = 0; i < words.length; i++) {\\n            for(int j = 0; j < words[i].length(); j++) {\\n                insert(words[i].substring(j)+\"#\"+words[i], i);\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return search(suffix+\"#\"+prefix);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */ \\n```",
                "codeTag": "Java"
            },
            {
                "id": 710597,
                "title": "clean-c-solution",
                "content": "### Clean C++ solution\\nIt uses a trick to simplify Trie. Made my life so much easier after I learnt this trick. Thanks to STL cookbook.\\n\\n```\\ntemplate<class T>\\nclass Trie{\\n    map<T, Trie> tries;\\n    int weight;\\n    \\n    public:\\n    \\n    template<class It>\\n    void addWord(It first, It second, int weight){\\n        if(first == second)\\n            return;\\n        \\n        tries[*first].weight=weight;    // inserting weight to all prefix\\n        tries[*first].addWord(next(first), second, weight);\\n    }\\n    \\n    template<class It>\\n    int search(It first, It second){\\n        if(first == second)\\n            return weight;\\n        if(tries.find(*first) != tries.end()){\\n            return tries[*first].search(next(first), second);\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n\\nclass WordFilter {\\n    Trie<char> trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for(int i=0; i< words.size(); i++){\\n            // inserting {apple , e{apple\\n            string prefix = words[i];\\n            for(int l=0; l<= prefix.length(); l++){\\n                string suffix = prefix.substr(prefix.length()-l, l);\\n                string new_word = suffix + \"#\" + prefix;\\n                //cout<<\"adding word \"<<new_word<<endl;\\n                trie.addWord(begin(new_word), end(new_word),i);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string new_word = suffix + \"#\" + prefix;\\n        return trie.search(begin(new_word), end(new_word));\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\ntemplate<class T>\\nclass Trie{\\n    map<T, Trie> tries;\\n    int weight;\\n    \\n    public:\\n    \\n    template<class It>\\n    void addWord(It first, It second, int weight){\\n        if(first == second)\\n            return;\\n        \\n        tries[*first].weight=weight;    // inserting weight to all prefix\\n        tries[*first].addWord(next(first), second, weight);\\n    }\\n    \\n    template<class It>\\n    int search(It first, It second){\\n        if(first == second)\\n            return weight;\\n        if(tries.find(*first) != tries.end()){\\n            return tries[*first].search(next(first), second);\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n\\nclass WordFilter {\\n    Trie<char> trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for(int i=0; i< words.size(); i++){\\n            // inserting {apple , e{apple\\n            string prefix = words[i];\\n            for(int l=0; l<= prefix.length(); l++){\\n                string suffix = prefix.substr(prefix.length()-l, l);\\n                string new_word = suffix + \"#\" + prefix;\\n                //cout<<\"adding word \"<<new_word<<endl;\\n                trie.addWord(begin(new_word), end(new_word),i);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string new_word = suffix + \"#\" + prefix;\\n        return trie.search(begin(new_word), end(new_word));\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 696440,
                "title": "javascript-trie-solution",
                "content": "```\\nclass WordFilter {\\n  constructor (words) {\\n    this.root = {}\\n    this.res = -1\\n    for (let i = 0; i < words.length; i++) {\\n      let node = this.root\\n      for (const c of words[i]) {\\n        if (!node[c]) {\\n          node[c] = {}\\n        }\\n        node = node[c]\\n      }\\n      node.word = words[i]\\n      node.index = i\\n    }\\n  }\\n  _f (node, suffix) {\\n    if (node.word) {\\n      let start = node.word.length - suffix.length\\n      if (start >= 0 && node.word.substring(start) === suffix) {\\n        this.res = Math.max(this.res, node.index)\\n      }\\n    }\\n    for (let i = 0; i < 26; i++) {\\n      const c = String.fromCharCode(97 + i)\\n      if (node[c]) {\\n        this._f(node[c], suffix)\\n      }\\n      if (node.word) {\\n        break\\n      }\\n    }\\n  }\\n  f (prefix, suffix) {\\n    let node = this.root\\n    for (const c of prefix) {\\n      if (!node[c]) {\\n        return -1\\n      }\\n      node = node[c]\\n    }\\n    if (!node) {\\n      return -1\\n    }\\n    this.res = -1\\n    this._f(node, suffix)\\n    return this.res\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n  constructor (words) {\\n    this.root = {}\\n    this.res = -1\\n    for (let i = 0; i < words.length; i++) {\\n      let node = this.root\\n      for (const c of words[i]) {\\n        if (!node[c]) {\\n          node[c] = {}\\n        }\\n        node = node[c]\\n      }\\n      node.word = words[i]\\n      node.index = i\\n    }\\n  }\\n  _f (node, suffix) {\\n    if (node.word) {\\n      let start = node.word.length - suffix.length\\n      if (start >= 0 && node.word.substring(start) === suffix) {\\n        this.res = Math.max(this.res, node.index)\\n      }\\n    }\\n    for (let i = 0; i < 26; i++) {\\n      const c = String.fromCharCode(97 + i)\\n      if (node[c]) {\\n        this._f(node[c], suffix)\\n      }\\n      if (node.word) {\\n        break\\n      }\\n    }\\n  }\\n  f (prefix, suffix) {\\n    let node = this.root\\n    for (const c of prefix) {\\n      if (!node[c]) {\\n        return -1\\n      }\\n      node = node[c]\\n    }\\n    if (!node) {\\n      return -1\\n    }\\n    this.res = -1\\n    this._f(node, suffix)\\n    return this.res\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 308668,
                "title": "c-using-dictionary-of-prefix-and-suffix",
                "content": "```\\npublic class WordFilter \\n{\\n    private Dictionary<string, HashSet<string>> prefix = new Dictionary<string, HashSet<string>>();\\n    private Dictionary<string, HashSet<string>> suffix = new Dictionary<string, HashSet<string>>();\\n    private Dictionary<string, int> weight = new Dictionary<string, int>();\\n    \\n    public WordFilter(string[] words) \\n    {\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            var w = words[i];\\n            weight[w] = i;\\n            for(int j = 0; j <= w.Length; j++)\\n            {\\n                var pre = w.Substring(0, j);\\n                string suf = string.Empty;\\n                if(j > 0)\\n                {\\n                     suf = w.Substring(w.Length - j, j);\\n                }\\n                if(!prefix.ContainsKey(pre)) prefix[pre] = new HashSet<string>();\\n                if(!suffix.ContainsKey(suf)) suffix[suf] = new HashSet<string>();\\n                prefix[pre].Add(w);\\n                suffix[suf].Add(w);\\n            }\\n        }\\n    }\\n    \\n    public int F(string p, string s) \\n    {\\n        int result = -1;\\n        if(!prefix.ContainsKey(p) || !suffix.ContainsKey(s)) return result;\\n        foreach(var w in prefix[p])\\n        {\\n            if(suffix[s].Contains(w))\\n            {\\n                result = Math.Max(result, weight[w]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class WordFilter \\n{\\n    private Dictionary<string, HashSet<string>> prefix = new Dictionary<string, HashSet<string>>();\\n    private Dictionary<string, HashSet<string>> suffix = new Dictionary<string, HashSet<string>>();\\n    private Dictionary<string, int> weight = new Dictionary<string, int>();\\n    \\n    public WordFilter(string[] words) \\n    {\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            var w = words[i];\\n            weight[w] = i;\\n            for(int j = 0; j <= w.Length; j++)\\n            {\\n                var pre = w.Substring(0, j);\\n                string suf = string.Empty;\\n                if(j > 0)\\n                {\\n                     suf = w.Substring(w.Length - j, j);\\n                }\\n                if(!prefix.ContainsKey(pre)) prefix[pre] = new HashSet<string>();\\n                if(!suffix.ContainsKey(suf)) suffix[suf] = new HashSet<string>();\\n                prefix[pre].Add(w);\\n                suffix[suf].Add(w);\\n            }\\n        }\\n    }\\n    \\n    public int F(string p, string s) \\n    {\\n        int result = -1;\\n        if(!prefix.ContainsKey(p) || !suffix.ContainsKey(s)) return result;\\n        foreach(var w in prefix[p])\\n        {\\n            if(suffix[s].Contains(w))\\n            {\\n                result = Math.Max(result, weight[w]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 156859,
                "title": "very-very-clean-java-solution-using-one-trie-and-one-weight-666",
                "content": "So when you insert a word to Trie eg. \"apple\", you need to insert all suffix + \"{\" + \"apple\" such as \"le{apple\" with its weight, since we only need return max weight, so just compare cur weight with previous weight and update it.\\n```\\nclass WordFilter {\\n    Trie trie;\\n    public WordFilter(String[] words) {\\n        trie = new Trie();\\n        for (int i = 0; i < words.length; i++) {\\n            String str = words[i];\\n            String suffix = \"\";\\n            for (int j = str.length() - 1; j >= 0; j--) {\\n                trie.insert(suffix + \"{\" + str, i);\\n                suffix = str.charAt(j) + suffix;\\n            }\\n            trie.insert(suffix + \"{\" + str, i);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return trie.search(suffix + \\'{\\' + prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    int weight;\\n    public TrieNode() {\\n        children = new TrieNode[27];\\n        weight = -1;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    public void insert(String word, int weight) {\\n        TrieNode cur = root;\\n        for (char ch : word.toCharArray()) {\\n            TrieNode node = cur.children[ch - \\'a\\'];\\n            if (node == null) {\\n                node = new TrieNode();\\n                cur.children[ch - \\'a\\'] = node;\\n            }\\n            node.weight = Math.max(node.weight, weight); // update weigth here.\\n            cur = node;\\n        }\\n    }\\n    \\n    public int search(String suffix) {\\n        TrieNode cur = root;\\n        for (char ch : suffix.toCharArray()) {\\n            TrieNode node = cur.children[ch - \\'a\\'];\\n            if (node == null) return -1;\\n            cur = node;\\n        }\\n        return cur.weight;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    Trie trie;\\n    public WordFilter(String[] words) {\\n        trie = new Trie();\\n        for (int i = 0; i < words.length; i++) {\\n            String str = words[i];\\n            String suffix = \"\";\\n            for (int j = str.length() - 1; j >= 0; j--) {\\n                trie.insert(suffix + \"{\" + str, i);\\n                suffix = str.charAt(j) + suffix;\\n            }\\n            trie.insert(suffix + \"{\" + str, i);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return trie.search(suffix + \\'{\\' + prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    int weight;\\n    public TrieNode() {\\n        children = new TrieNode[27];\\n        weight = -1;\\n    }\\n}\\n\\nclass Trie {\\n    TrieNode root;\\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    public void insert(String word, int weight) {\\n        TrieNode cur = root;\\n        for (char ch : word.toCharArray()) {\\n            TrieNode node = cur.children[ch - \\'a\\'];\\n            if (node == null) {\\n                node = new TrieNode();\\n                cur.children[ch - \\'a\\'] = node;\\n            }\\n            node.weight = Math.max(node.weight, weight); // update weigth here.\\n            cur = node;\\n        }\\n    }\\n    \\n    public int search(String suffix) {\\n        TrieNode cur = root;\\n        for (char ch : suffix.toCharArray()) {\\n            TrieNode node = cur.children[ch - \\'a\\'];\\n            if (node == null) return -1;\\n            cur = node;\\n        }\\n        return cur.weight;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 110051,
                "title": "527-ms-java-solution-with-detailed-explanation",
                "content": "Please take note how I create the Trie in the below example:\\n\\nword: \"google\", index 0;\\ngoogle, elgoog(reverse) -> TrieNode: g - e - o - l - o - g - g - o - l - o - e - g(Intersect google and elgoog(reverse))\\n\\nword: \"gogle\", index 1:\\ngogle, elgog(reverse) -> TrieNode: g - e - o - l - g - g - l - o - e - g\\n\\nAs the TrieNode class is defined as below:\\n```\\n    class TrieNode{\\n        TrieNode[] children;\\n        int val;\\n        TrieNode(){\\n            val = 0;\\n            children = new TrieNode[26];\\n            return;\\n        }\\n    }\\n```\\nWe can easily update the val (max weight) when we build the Trie\\n\\nNow how to search with the prefix and suffix, For instance, we want to search \"goog\", \"le\"\\nwe build the search string by interset the prefix and suffix(reverse), eg:\\n\"goo\", \"el\"(reversed)  -> \"geolo\\\\*g\\\\*\"\\nso we will search \"geolo\\\\*g\\\\*\" in the trie in which \"*\" could match any word. it will help to save a lot time with only linear time searching the TrieNode with O(length of prefix + length of suffix), and avoid to traverse any possible word to get the maximum weight. \\n\\n```\\nclass WordFilter {\\n    class TrieNode{\\n        TrieNode[] children;\\n        int val;\\n        TrieNode(){\\n            val = 0;\\n            children = new TrieNode[26];\\n            return;\\n        }\\n    }\\n    \\n    TrieNode root = null;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        int idx = 0;\\n        for(String word : words){\\n            int low = 0;\\n            int high = word.length() - 1;\\n            int len = word.length();\\n            TrieNode node = root;\\n            while(low < len){\\n                char ch1 = word.charAt(low++);\\n                if(node.children[ch1 - 'a'] == null){\\n                    node.children[ch1 - 'a'] = new TrieNode();\\n                }\\n                node = node.children[ch1 - 'a'];\\n                node.val = idx;\\n                \\n                char ch2 = word.charAt(high--);\\n                if(node.children[ch2 - 'a'] == null){\\n                    node.children[ch2 - 'a'] = new TrieNode();\\n                }\\n                node = node.children[ch2 - 'a'];\\n                node.val = idx;\\n            }\\n            idx++;\\n        }\\n        return;\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        StringBuilder sb = new StringBuilder();\\n        int len1 = prefix.length();\\n        int len2 = suffix.length();\\n        \\n        int len = Math.max(len1, len2);\\n        int low = 0;\\n        int high = len2 - 1;\\n        int idx = 0;\\n        while(idx < len){\\n            sb.append(low < len1 ? prefix.charAt(low) : '*');\\n            sb.append(high >= 0 ? suffix.charAt(high) : '*');\\n            low++;\\n            high--;\\n            idx++;\\n        }\\n        String word = sb.toString();\\n        return dfs(root, 0, word);\\n    }\\n    \\n    public int dfs(TrieNode node , int idx, String word){\\n        if(idx == word.length()){\\n          return node.val;\\n        }\\n        char ch = word.charAt(idx);\\n        if(ch == '*'){\\n            int res = -1;\\n            for(int i = 0; i < 26; i++){\\n                if(node.children[i] != null){\\n                    res = Math.max(res, dfs(node.children[i], idx + 1, word));\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            if(node.children[ch - 'a'] != null){\\n                return dfs(node.children[ch - 'a'], idx + 1, word);\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    class TrieNode{\\n        TrieNode[] children;\\n        int val;\\n        TrieNode(){\\n            val = 0;\\n            children = new TrieNode[26];\\n            return;\\n        }\\n    }\\n```\n```\\nclass WordFilter {\\n    class TrieNode{\\n        TrieNode[] children;\\n        int val;\\n        TrieNode(){\\n            val = 0;\\n            children = new TrieNode[26];\\n            return;\\n        }\\n    }\\n    \\n    TrieNode root = null;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        int idx = 0;\\n        for(String word : words){\\n            int low = 0;\\n            int high = word.length() - 1;\\n            int len = word.length();\\n            TrieNode node = root;\\n            while(low < len){\\n                char ch1 = word.charAt(low++);\\n                if(node.children[ch1 - 'a'] == null){\\n                    node.children[ch1 - 'a'] = new TrieNode();\\n                }\\n                node = node.children[ch1 - 'a'];\\n                node.val = idx;\\n                \\n                char ch2 = word.charAt(high--);\\n                if(node.children[ch2 - 'a'] == null){\\n                    node.children[ch2 - 'a'] = new TrieNode();\\n                }\\n                node = node.children[ch2 - 'a'];\\n                node.val = idx;\\n            }\\n            idx++;\\n        }\\n        return;\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        StringBuilder sb = new StringBuilder();\\n        int len1 = prefix.length();\\n        int len2 = suffix.length();\\n        \\n        int len = Math.max(len1, len2);\\n        int low = 0;\\n        int high = len2 - 1;\\n        int idx = 0;\\n        while(idx < len){\\n            sb.append(low < len1 ? prefix.charAt(low) : '*');\\n            sb.append(high >= 0 ? suffix.charAt(high) : '*');\\n            low++;\\n            high--;\\n            idx++;\\n        }\\n        String word = sb.toString();\\n        return dfs(root, 0, word);\\n    }\\n    \\n    public int dfs(TrieNode node , int idx, String word){\\n        if(idx == word.length()){\\n          return node.val;\\n        }\\n        char ch = word.charAt(idx);\\n        if(ch == '*'){\\n            int res = -1;\\n            for(int i = 0; i < 26; i++){\\n                if(node.children[i] != null){\\n                    res = Math.max(res, dfs(node.children[i], idx + 1, word));\\n                }\\n            }\\n            return res;\\n        }\\n        else{\\n            if(node.children[ch - 'a'] != null){\\n                return dfs(node.children[ch - 'a'], idx + 1, word);\\n            }\\n            else{\\n                return -1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053393,
                "title": "simple-idea-but-f-ing-frustrating-but-it-s-fun-tri",
                "content": "None other question ever frustated me this much like this one.\\ni was able to comeup with search function very quickly but to find set of all possible search string was littely a brain eating task with no clue with given examples and i had no intution about these overlapping suffics and prefixes and when i realised this there was still more to figurout like prefix and suffix may share only one ,two, three,.... of there overlapping equal chars .....  uffff  but at end it\\'s wrapped up :)\\n\\nlet\\'s take these examples \\n```\\n pre   suff\\n[lrr,  rrdfg]\\n```\\nso here if we can find any of the string which satisfy this and we will take max of all solution sounds easy\\n```\\nall possible string :[ lrrrrdfg, lrrrdfg, lrrdfg, lrr*rrdfg]  (* can be anything of any length>=0)\\n```\\nthis we will do with our **reduce function** (it\\'s simple string match function )\\n\\n\\n```  ```**Now let\\'s make tree**\\nWe will we using tri. where first we fill the tri mak the end true and also store the index of the string at end point and keep taking maximum at end point to get max index in case of repitation\\nokey all set \\n\\n```  ``` **Now search function**\\n\\nit\\'s just same as matching string where we can match star with any char with any no of time possibly zero\\nand just take max of all possible string\\'s index by dfs \\nit\\'s not costly bcz we are told that length of words <=7 so it\\'s not an issue with time complexcity for every search of possible string for given prefix and suffix\\n\\n\\n```\\nclass WordFilter {\\npublic:\\n  \\n    struct tri{\\n        tri* next[26];\\n        int mx;\\n        bool end;\\n        tri()\\n        {\\n            for(int i=0; i<26; i++) next[i]=NULL;\\n            mx=-1;// will strore maximum index\\n            end=false;// end of string \\n        }\\n        \\n    };\\n    \\n    tri * root;\\n    WordFilter(vector<string>& words)  //build tree\\n    {\\n        root=new tri();\\n        int m=words.size();\\n        for(int w=0; w<m; w++)\\n        {\\n            tri* curr=root;\\n            for(auto i: words[w])\\n            {\\n                if(curr->next[i-\\'a\\']==NULL) curr->next[i-\\'a\\']=new tri();\\n                curr=curr->next[i-\\'a\\'];\\n            }\\n            curr->end= true;\\n            curr->mx= max(curr->mx, w);\\n        }\\n    }\\n    \\n    \\n    vector<string> reduce(string &a, string &b) // get all possible strings\\n    {\\n        vector<string> ans;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            int k=i;\\n            int idx=-1;\\n            for(int j=0; j<b.size() && k<a.size(); )\\n            {\\n                if(b[j]==a[k])\\n                {\\n                    j++;\\n                    k++;\\n                }else break;\\n            }\\n            if(k==a.size())\\n            {\\n                idx=i;\\n                string s=\"\";\\n                int o=0;\\n                while(o<idx) \\n                {\\n                    s+=a[o];o++;\\n                }\\n                s+=b;\\n                ans.push_back(s);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(int idx, string &s, tri * root, int n)\\n    {\\n        if(root==NULL) return -1;\\n        if(s[idx]==\\'*\\')\\n        {\\n            \\n            int ans=-1;\\n            for(int i=0; i<26; i++)// can ignore current char in tree any no of time\\n            {\\n                if(root->next[i]) ans= max(ans, solve(idx,s, root->next[i],n));// take max\\n            }\\n            ans= max(ans, solve(idx+1,s,root,n));// ignore the star and search for next char\\n            return ans;\\n            \\n        }else\\n        {\\n            if(idx==n) \\n            {\\n                if(root->end) return root->mx;\\n                return -1;\\n            }\\n            if(root->next[s[idx]-\\'a\\']==NULL)return -1;\\n            else \\n            {\\n                return solve(idx+1, s, root->next[s[idx]-\\'a\\'],n);\\n            }\\n        }\\n    }\\n    \\n    int f(string p, string s) \\n    {\\n        int ans=-1;\\n        tri* curr=root;\\n        vector<string >t= reduce(p,s);\\n        for(auto st: t)\\n        {\\n            ans= max(ans, solve(0,st, curr,st.size()));\\n        }\\n        p+=\\'*\\';\\n        p+=s;\\n        int n=p.size();\\n        ans= max(ans,solve(0,p, curr,n));\\n        return ans;\\n    }\\n};\\n\\n\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n pre   suff\\n[lrr,  rrdfg]\\n```\n```\\nall possible string :[ lrrrrdfg, lrrrdfg, lrrdfg, lrr*rrdfg]  (* can be anything of any length>=0)\\n```\n```  ```\n```  ```\n```\\nclass WordFilter {\\npublic:\\n  \\n    struct tri{\\n        tri* next[26];\\n        int mx;\\n        bool end;\\n        tri()\\n        {\\n            for(int i=0; i<26; i++) next[i]=NULL;\\n            mx=-1;// will strore maximum index\\n            end=false;// end of string \\n        }\\n        \\n    };\\n    \\n    tri * root;\\n    WordFilter(vector<string>& words)  //build tree\\n    {\\n        root=new tri();\\n        int m=words.size();\\n        for(int w=0; w<m; w++)\\n        {\\n            tri* curr=root;\\n            for(auto i: words[w])\\n            {\\n                if(curr->next[i-\\'a\\']==NULL) curr->next[i-\\'a\\']=new tri();\\n                curr=curr->next[i-\\'a\\'];\\n            }\\n            curr->end= true;\\n            curr->mx= max(curr->mx, w);\\n        }\\n    }\\n    \\n    \\n    vector<string> reduce(string &a, string &b) // get all possible strings\\n    {\\n        vector<string> ans;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            int k=i;\\n            int idx=-1;\\n            for(int j=0; j<b.size() && k<a.size(); )\\n            {\\n                if(b[j]==a[k])\\n                {\\n                    j++;\\n                    k++;\\n                }else break;\\n            }\\n            if(k==a.size())\\n            {\\n                idx=i;\\n                string s=\"\";\\n                int o=0;\\n                while(o<idx) \\n                {\\n                    s+=a[o];o++;\\n                }\\n                s+=b;\\n                ans.push_back(s);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int solve(int idx, string &s, tri * root, int n)\\n    {\\n        if(root==NULL) return -1;\\n        if(s[idx]==\\'*\\')\\n        {\\n            \\n            int ans=-1;\\n            for(int i=0; i<26; i++)// can ignore current char in tree any no of time\\n            {\\n                if(root->next[i]) ans= max(ans, solve(idx,s, root->next[i],n));// take max\\n            }\\n            ans= max(ans, solve(idx+1,s,root,n));// ignore the star and search for next char\\n            return ans;\\n            \\n        }else\\n        {\\n            if(idx==n) \\n            {\\n                if(root->end) return root->mx;\\n                return -1;\\n            }\\n            if(root->next[s[idx]-\\'a\\']==NULL)return -1;\\n            else \\n            {\\n                return solve(idx+1, s, root->next[s[idx]-\\'a\\'],n);\\n            }\\n        }\\n    }\\n    \\n    int f(string p, string s) \\n    {\\n        int ans=-1;\\n        tri* curr=root;\\n        vector<string >t= reduce(p,s);\\n        for(auto st: t)\\n        {\\n            ans= max(ans, solve(0,st, curr,st.size()));\\n        }\\n        p+=\\'*\\';\\n        p+=s;\\n        int n=p.size();\\n        ans= max(ans,solve(0,p, curr,n));\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317104,
                "title": "c-single-trie-search-using-wraparound-string",
                "content": "The wrap-around string query part is staright-forward. The real challenge is in storing the largest index. \\nHere I am associating each node of the trie with the index of the string that last utilises it.\\nFeel free to comment below for any query, I\\'d be happy to help :) \\n\\n```\\nclass node{\\n    public:\\n        node *next[27];\\n        int last;  // This stores the largest i for the words[i] that utilises *this particular node* in its sequence \\n        node(){\\n            memset(next,0,sizeof(next));\\n            last=-1;  \\n        }\\n};\\nclass trie{\\n    public:\\n    node *root=new node();\\n    void insert(string &word, int i){\\n        node *temp=root;\\n        for(auto c:word){\\n            if(!temp->next[c-\\'a\\']){\\n                temp->next[c-\\'a\\']=new node();\\n            }\\n            temp=temp->next[c-\\'a\\'];\\n            temp->last=i;  // Since calls to this function are made in the order of increasing {i}, the node will eventually have the largest {i} associated with it\\n        }\\n    }\\n    bool search(string &word, int &i){\\n        node* temp=root;\\n        for(auto c:word){\\n            if(!temp->next[c-\\'a\\']){ i=-1; return false; }\\n            temp=temp->next[c-\\'a\\'];\\n            i=temp->last; \\n        }\\n        return true;\\n    }\\n};\\nclass WordFilter {\\npublic:\\n    trie* t=new trie();\\n    WordFilter(vector<string>& words) {\\n        int i=0;\\n        for(int i=0; i<words.size(); i++){\\n            string w=words[i];\\n            for(int j=0; j<w.length(); j++){\\n                string r=w.substr(j)+\\'{\\'+w;\\n                t->insert(r,i);\\n            }\\n        }        \\n    }\\n    \\n    int f(string pref, string suff) {\\n        int ans=-1;\\n        string s=suff+\\'{\\'+pref;\\n        t->search(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass node{\\n    public:\\n        node *next[27];\\n        int last;  // This stores the largest i for the words[i] that utilises *this particular node* in its sequence \\n        node(){\\n            memset(next,0,sizeof(next));\\n            last=-1;  \\n        }\\n};\\nclass trie{\\n    public:\\n    node *root=new node();\\n    void insert(string &word, int i){\\n        node *temp=root;\\n        for(auto c:word){\\n            if(!temp->next[c-\\'a\\']){\\n                temp->next[c-\\'a\\']=new node();\\n            }\\n            temp=temp->next[c-\\'a\\'];\\n            temp->last=i;  // Since calls to this function are made in the order of increasing {i}, the node will eventually have the largest {i} associated with it\\n        }\\n    }\\n    bool search(string &word, int &i){\\n        node* temp=root;\\n        for(auto c:word){\\n            if(!temp->next[c-\\'a\\']){ i=-1; return false; }\\n            temp=temp->next[c-\\'a\\'];\\n            i=temp->last; \\n        }\\n        return true;\\n    }\\n};\\nclass WordFilter {\\npublic:\\n    trie* t=new trie();\\n    WordFilter(vector<string>& words) {\\n        int i=0;\\n        for(int i=0; i<words.size(); i++){\\n            string w=words[i];\\n            for(int j=0; j<w.length(); j++){\\n                string r=w.substr(j)+\\'{\\'+w;\\n                t->insert(r,i);\\n            }\\n        }        \\n    }\\n    \\n    int f(string pref, string suff) {\\n        int ans=-1;\\n        string s=suff+\\'{\\'+pref;\\n        t->search(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943944,
                "title": "python-sets-optimization-beats-99",
                "content": "\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefixes = defaultdict(set)\\n        self.suffixes = defaultdict(set)\\n        seen = set()\\n        for idx in range(len(words) - 1, -1, -1):\\n            word = words[idx]\\n            if word in seen:\\n                continue\\n            seen.add(word)\\n            for i in range(0, len(word) + 1):\\n                prefix = word[:i]\\n                suffix = word[i:]\\n                self.prefixes[prefix].add(idx)\\n                self.suffixes[suffix].add(idx)\\n\\n    def f(self, pref: str, suff: str) -> int:\\n        if pref in self.prefixes and suff in self.suffixes:\\n            sharedWords = self.prefixes[pref] & self.suffixes[suff]\\n            return max(sharedWords) if sharedWords else -1\\n        return -1\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(pref,suff)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefixes = defaultdict(set)\\n        self.suffixes = defaultdict(set)\\n        seen = set()\\n        for idx in range(len(words) - 1, -1, -1):\\n            word = words[idx]\\n            if word in seen:\\n                continue\\n            seen.add(word)\\n            for i in range(0, len(word) + 1):\\n                prefix = word[:i]\\n                suffix = word[i:]\\n                self.prefixes[prefix].add(idx)\\n                self.suffixes[suffix].add(idx)\\n\\n    def f(self, pref: str, suff: str) -> int:\\n        if pref in self.prefixes and suff in self.suffixes:\\n            sharedWords = self.prefixes[pref] & self.suffixes[suff]\\n            return max(sharedWords) if sharedWords else -1\\n        return -1\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(pref,suff)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696499,
                "title": "python3-solution",
                "content": "```\\n\\n```class WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.res={}\\n        for index,word in enumerate(words):\\n            N=len(word)\\n            rword=word[::-1]\\n            \\n            for i in range(1,N+1):\\n                for j in range(1,N+1):\\n                    self.res[(word[:i],rword[:j])]=index\\n\\n    def f(self, pref: str, suff: str) -> int:\\n        suff=suff[::-1]\\n        if (pref,suff) in self.res:\\n            return self.res[(pref,suff)]\\n        return -1\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446137,
                "title": "easy-c",
                "content": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> hsMp;\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for(int i = 0; i < n; i++){\\n            string new_word = words[i];\\n            int len = new_word.length();\\n            \\n            for(int j = 1; j <= len; j++){\\n                string pref = new_word.substr(0, j);\\n                for(int k = 0; k < len; k++){\\n                    string suff = new_word.substr(k);\\n                    \\n                    hsMp[pref+\\'|\\'+suff] = i + 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string pref, string suff) {\\n        string s = pref + \\'|\\' + suff;\\n        return hsMp[s] - 1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(pref,suff);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> hsMp;\\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        for(int i = 0; i < n; i++){\\n            string new_word = words[i];\\n            int len = new_word.length();\\n            \\n            for(int j = 1; j <= len; j++){\\n                string pref = new_word.substr(0, j);\\n                for(int k = 0; k < len; k++){\\n                    string suff = new_word.substr(k);\\n                    \\n                    hsMp[pref+\\'|\\'+suff] = i + 1;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string pref, string suff) {\\n        string s = pref + \\'|\\' + suff;\\n        return hsMp[s] - 1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(pref,suff);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250587,
                "title": "c-using-2-tries-memoization",
                "content": "**Logic:** Create 2 tries, both will store words, the second one will store in reverse order. Search prefix and suffix matching words, the search will return list of indices, where words on those indices will have respective prefix or suffix. The word which has both given prefix and suffix will be common in both lists.\\n```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> children;\\n    vector<int> wordIndexList;\\n    \\n    TrieNode(){\\n        children = vector<TrieNode*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    //Root is a datamember of trie.\\n    TrieNode* root;\\n    \\n    //Constructor\\n    Trie(){\\n        //Initialize root.\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string& word, int wordIndex){\\n        auto cur = root;\\n        for(int i=0; i<word.size(); i++){\\n            int index = word[i] - \\'a\\';\\n            if(!cur->children[index]) cur->children[index] = new TrieNode();\\n            cur = cur->children[index];\\n            cur->wordIndexList.push_back(wordIndex);\\n        }\\n    }\\n    \\n    vector<int> searchPrefOrSuff(string& str){\\n        auto cur = root;\\n        int n= str.size();\\n        for(int i=0; i<n; i++){\\n            int index = str[i] - \\'a\\';\\n            if(cur->children[index] == NULL) return {};\\n            cur = cur -> children[index];\\n        }\\n        return cur->wordIndexList;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie* prefixTrie = new Trie();\\n    Trie* suffixTrie = new Trie();\\n    unordered_map<string, int> mp;\\n    \\n    WordFilter(vector<string>& words) {\\n        int n= words.size();\\n        for(int i=0; i<n; i++) {\\n            string word = words[i];\\n            prefixTrie->insert(word, i);\\n            string rev = word;\\n            \\n            reverse(rev.begin(), rev.end());\\n            suffixTrie->insert(rev, i);\\n        }\\n    }\\n    \\n    int f(string pref, string suff) {\\n        string key = pref+ \"-\" + suff;\\n        if(mp.find(key) != mp.end()) return mp[key];\\n        \\n        vector<int> prefList = prefixTrie -> searchPrefOrSuff(pref);\\n        reverse(suff.begin(), suff.end());\\n        vector<int> suffList = suffixTrie -> searchPrefOrSuff(suff);\\n        \\n        int n = prefList.size(), m = suffList.size();\\n        int k = n-1, l = m-1;\\n                \\n        while(k>=0 && l>=0){\\n            if(prefList[k] == suffList[l]) return mp[key] = prefList[k];\\n            if(prefList[k] > suffList[l]) k-=1;\\n            else if(suffList[l] > prefList[k]) l-=1;\\n        }\\n        return mp[key] = -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode{\\npublic:\\n    vector<TrieNode*> children;\\n    vector<int> wordIndexList;\\n    \\n    TrieNode(){\\n        children = vector<TrieNode*>(26, NULL);\\n    }\\n};\\n\\nclass Trie{\\npublic:\\n    //Root is a datamember of trie.\\n    TrieNode* root;\\n    \\n    //Constructor\\n    Trie(){\\n        //Initialize root.\\n        root = new TrieNode();\\n    }\\n    \\n    void insert(string& word, int wordIndex){\\n        auto cur = root;\\n        for(int i=0; i<word.size(); i++){\\n            int index = word[i] - \\'a\\';\\n            if(!cur->children[index]) cur->children[index] = new TrieNode();\\n            cur = cur->children[index];\\n            cur->wordIndexList.push_back(wordIndex);\\n        }\\n    }\\n    \\n    vector<int> searchPrefOrSuff(string& str){\\n        auto cur = root;\\n        int n= str.size();\\n        for(int i=0; i<n; i++){\\n            int index = str[i] - \\'a\\';\\n            if(cur->children[index] == NULL) return {};\\n            cur = cur -> children[index];\\n        }\\n        return cur->wordIndexList;\\n    }\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie* prefixTrie = new Trie();\\n    Trie* suffixTrie = new Trie();\\n    unordered_map<string, int> mp;\\n    \\n    WordFilter(vector<string>& words) {\\n        int n= words.size();\\n        for(int i=0; i<n; i++) {\\n            string word = words[i];\\n            prefixTrie->insert(word, i);\\n            string rev = word;\\n            \\n            reverse(rev.begin(), rev.end());\\n            suffixTrie->insert(rev, i);\\n        }\\n    }\\n    \\n    int f(string pref, string suff) {\\n        string key = pref+ \"-\" + suff;\\n        if(mp.find(key) != mp.end()) return mp[key];\\n        \\n        vector<int> prefList = prefixTrie -> searchPrefOrSuff(pref);\\n        reverse(suff.begin(), suff.end());\\n        vector<int> suffList = suffixTrie -> searchPrefOrSuff(suff);\\n        \\n        int n = prefList.size(), m = suffList.size();\\n        int k = n-1, l = m-1;\\n                \\n        while(k>=0 && l>=0){\\n            if(prefList[k] == suffList[l]) return mp[key] = prefList[k];\\n            if(prefList[k] > suffList[l]) k-=1;\\n            else if(suffList[l] > prefList[k]) l-=1;\\n        }\\n        return mp[key] = -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218259,
                "title": "shortest-c-ever",
                "content": "*Here **p** is prefix , **s** is suffix , we take all possible combinations and match if it is there , then return its index.*\\n```\\nclass WordFilter {\\npublic:\\n    unordered_map<string,int>mp;                                                                // storing index\\n    \\n    WordFilter(vector<string>& words) {\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            string word = words[i];\\n            int wordSize = word.size();\\n            \\n            for(int j = 1; j<=wordSize; j++){\\n                string p = word.substr(0,j);\\n                for(int k = 0; k<wordSize; k++){\\n                    string s = word.substr(k,wordSize);\\n                    mp[p+\"|\"+s] = i+1;\\n                }\\n            }  \\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n            return mp[prefix+\"|\"+suffix]-1;                                                   // -1 for if it is not present.\\n    }\\n};\\n```\\n\\nYou Forgot 1 Thing :)\\n**DO UPVOTE !**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string,int>mp;                                                                // storing index\\n    \\n    WordFilter(vector<string>& words) {\\n        \\n        for(int i = 0; i<words.size(); i++){\\n            string word = words[i];\\n            int wordSize = word.size();\\n            \\n            for(int j = 1; j<=wordSize; j++){\\n                string p = word.substr(0,j);\\n                for(int k = 0; k<wordSize; k++){\\n                    string s = word.substr(k,wordSize);\\n                    mp[p+\"|\"+s] = i+1;\\n                }\\n            }  \\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n            return mp[prefix+\"|\"+suffix]-1;                                                   // -1 for if it is not present.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167295,
                "title": "python-solution-using-trie",
                "content": "- Put all words in a trie\\n- Search for each prefix\\n- Collect all words which start with the prefix\\n- Sort according to index\\n- Return the index of the word which has the suffix given (It would be the\\n largest because the words  returned are sorted) \\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n    \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for i, word in enumerate(words):\\n            self.insert(word, i)\\n    \\n    def search(self, word):\\n        curnode =  self.trie\\n        \\n        for char in word:\\n            if curnode.children.get(char):\\n                curnode = curnode.children[char]\\n            else:\\n                return -1\\n        \\n        return [curnode, word]\\n    \\n    def insert(self, word, index):\\n        curnode = self.trie\\n        \\n        for char in word:\\n            if curnode.children.get(char):\\n                curnode = curnode.children[char]\\n            else:\\n                new_node = TrieNode()\\n                curnode.children[char] = new_node\\n                curnode = new_node\\n                \\n        curnode.children[\"*\"] = index\\n    \\n    def collectwords(self, node = None, word = \"\", words = []):\\n        curnode = node\\n        \\n        for key, childnode in curnode.children.items():\\n            if key == \"*\":\\n                words.append([word, curnode.children[key]])\\n            else:\\n                self.collectwords(childnode, word + key, words)\\n        \\n        return words\\n        \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        tmp = self.search(prefix)\\n        if tmp == -1:\\n            return tmp\\n        else:\\n            words = self.collectwords(tmp[0], \"\", [])\\n            words.sort(key = lambda x: x[1], reverse = True)\\n            for word in words:\\n                if (tmp[1] + word[0]).endswith(suffix):\\n                    return word[1]\\n            return -1\\n            \\n```",
                "solutionTags": [
                    "Hash Table",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n    \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = TrieNode()\\n        for i, word in enumerate(words):\\n            self.insert(word, i)\\n    \\n    def search(self, word):\\n        curnode =  self.trie\\n        \\n        for char in word:\\n            if curnode.children.get(char):\\n                curnode = curnode.children[char]\\n            else:\\n                return -1\\n        \\n        return [curnode, word]\\n    \\n    def insert(self, word, index):\\n        curnode = self.trie\\n        \\n        for char in word:\\n            if curnode.children.get(char):\\n                curnode = curnode.children[char]\\n            else:\\n                new_node = TrieNode()\\n                curnode.children[char] = new_node\\n                curnode = new_node\\n                \\n        curnode.children[\"*\"] = index\\n    \\n    def collectwords(self, node = None, word = \"\", words = []):\\n        curnode = node\\n        \\n        for key, childnode in curnode.children.items():\\n            if key == \"*\":\\n                words.append([word, curnode.children[key]])\\n            else:\\n                self.collectwords(childnode, word + key, words)\\n        \\n        return words\\n        \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        tmp = self.search(prefix)\\n        if tmp == -1:\\n            return tmp\\n        else:\\n            words = self.collectwords(tmp[0], \"\", [])\\n            words.sort(key = lambda x: x[1], reverse = True)\\n            for word in words:\\n                if (tmp[1] + word[0]).endswith(suffix):\\n                    return word[1]\\n            return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2167147,
                "title": "python-trie-100-memory-beat",
                "content": "Hey, here\\'s my solution. Let me know if you have any questions! Runtime varies between 20-40% faster, but memory is consistently top (99%+).\\n![image](https://assets.leetcode.com/users/images/b3b7de30-0223-44e2-bc50-fa8c69b319fb_1655578501.4222448.png)\\n\\n```class WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefix = {}\\n        for idx, word in enumerate(words):\\n            cur = self.prefix\\n            for letter in word:\\n                if letter not in cur:\\n                    cur[letter] = {}\\n                cur = cur[letter]\\n            # store data somehow\\n            cur[\\'idx\\'] = [idx, word]\\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        possible = []\\n        cur = self.prefix\\n        for letter in prefix:\\n            if letter not in cur:\\n                return -1\\n            cur = cur[letter]\\n        # BFS to find all possible words\\n        cur_layer = [cur]\\n        while len(cur_layer) != 0:\\n            next_layer = []\\n            for i in range(len(cur_layer)):\\n                for letter in cur_layer[i]:\\n                    if letter != \\'idx\\':\\n                        next_layer.append(cur_layer[i][letter])\\n                    elif cur_layer[i][\\'idx\\'][1].endswith(suffix):\\n                        possible.append(cur_layer[i][\\'idx\\'][0])\\n            cur_layer = next_layer\\n        if len(possible) == 0:\\n            return -1\\n        return max(possible)\\n            \\n    \\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```class WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefix = {}\\n        for idx, word in enumerate(words):\\n            cur = self.prefix\\n            for letter in word:\\n                if letter not in cur:\\n                    cur[letter] = {}\\n                cur = cur[letter]\\n            # store data somehow\\n            cur[\\'idx\\'] = [idx, word]\\n                \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        possible = []\\n        cur = self.prefix\\n        for letter in prefix:\\n            if letter not in cur:\\n                return -1\\n            cur = cur[letter]\\n        # BFS to find all possible words\\n        cur_layer = [cur]\\n        while len(cur_layer) != 0:\\n            next_layer = []\\n            for i in range(len(cur_layer)):\\n                for letter in cur_layer[i]:\\n                    if letter != \\'idx\\':\\n                        next_layer.append(cur_layer[i][letter])\\n                    elif cur_layer[i][\\'idx\\'][1].endswith(suffix):\\n                        possible.append(cur_layer[i][\\'idx\\'][0])\\n            cur_layer = next_layer\\n        if len(possible) == 0:\\n            return -1\\n        return max(possible)\\n            \\n    \\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)```",
                "codeTag": "Java"
            },
            {
                "id": 2166952,
                "title": "java-solution-hashmap-no-trie-used",
                "content": "```\\nclass WordFilter {\\n    HashMap<String,Integer> mp;\\n    public WordFilter(String[] words) {\\n        mp=new HashMap<String,Integer>();\\n        int i,j,k,len=words.length,l;\\n        for(i=0;i<len;i++){\\n            String w=words[i];\\n            l=w.length();\\n            for(j=0;j<=l;j++){\\n                for(k=0;k<=l;k++){\\n                    mp.put(w.substring(k)+\"#\"+w.substring(0,j),i);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return mp.getOrDefault(suffix+\"#\"+prefix,-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    HashMap<String,Integer> mp;\\n    public WordFilter(String[] words) {\\n        mp=new HashMap<String,Integer>();\\n        int i,j,k,len=words.length,l;\\n        for(i=0;i<len;i++){\\n            String w=words[i];\\n            l=w.length();\\n            for(j=0;j<=l;j++){\\n                for(k=0;k<=l;k++){\\n                    mp.put(w.substring(k)+\"#\"+w.substring(0,j),i);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return mp.getOrDefault(suffix+\"#\"+prefix,-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166916,
                "title": "js-single-trie",
                "content": "For each word generate all \\'suffix-prefix\\' combinations. Other than that it\\'s a simple Trie.\\nSolve [208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/) first if you strugle with this one.\\n\\nSpecial char `{` is chosen just because it goes next after `z` and it\\'s easy to place it at 26th index of `children` array\\n\\n```\\nString.fromCharCode(122) // z\\nString.fromCharCode(123) // {\\n```\\n\\n```\\nclass TrieNode {\\n  constructor(char = \\'\\') {\\n    this.char = char; // not required for this problem\\n    this.index = -1;\\n    this.children = new Array(27); // lower-case English letters and special char \\'{\\'\\n  }\\n}\\n\\nclass WordFilter {\\n  constructor(words) {\\n    this.root = new TrieNode();\\n    \\n    for (let i = 0; i < words.length; i++) {\\n      const word = words[i];\\n      for (let j = 0; j <= word.length; j++) {\\n        this.insert(word.slice(j, word.length) + \\'{\\' + word, i);\\n      }\\n    }\\n  }\\n  \\n  getCharCode(char) {\\n    return char.charCodeAt() - 97; // 0 - 26\\n  }\\n  \\n  insert(word, index) {\\n    let current = this.root;\\n    \\n    for (const char of word) {\\n      const c = this.getCharCode(char);\\n      if (!current.children[c]) current.children[c] = new TrieNode(char);\\n      current = current.children[c];\\n      current.index = index;\\n    }\\n  }\\n  \\n  f(prefix, suffix) {\\n    let current = this.root;\\n    \\n    const word = suffix + \\'{\\' + prefix;\\n    for (const char of word) {\\n      const c = this.getCharCode(char);\\n      if (!current.children[c]) return -1;\\n      current = current.children[c];\\n    }\\n\\t\\n    return current.index;\\n  }\\n}\\n```\\n\\nAlso, this YouTube video might help you with general idea: https://www.youtube.com/watch?v=giiaIofn31A",
                "solutionTags": [
                    "JavaScript",
                    "Trie"
                ],
                "code": "```\\nString.fromCharCode(122) // z\\nString.fromCharCode(123) // {\\n```\n```\\nclass TrieNode {\\n  constructor(char = \\'\\') {\\n    this.char = char; // not required for this problem\\n    this.index = -1;\\n    this.children = new Array(27); // lower-case English letters and special char \\'{\\'\\n  }\\n}\\n\\nclass WordFilter {\\n  constructor(words) {\\n    this.root = new TrieNode();\\n    \\n    for (let i = 0; i < words.length; i++) {\\n      const word = words[i];\\n      for (let j = 0; j <= word.length; j++) {\\n        this.insert(word.slice(j, word.length) + \\'{\\' + word, i);\\n      }\\n    }\\n  }\\n  \\n  getCharCode(char) {\\n    return char.charCodeAt() - 97; // 0 - 26\\n  }\\n  \\n  insert(word, index) {\\n    let current = this.root;\\n    \\n    for (const char of word) {\\n      const c = this.getCharCode(char);\\n      if (!current.children[c]) current.children[c] = new TrieNode(char);\\n      current = current.children[c];\\n      current.index = index;\\n    }\\n  }\\n  \\n  f(prefix, suffix) {\\n    let current = this.root;\\n    \\n    const word = suffix + \\'{\\' + prefix;\\n    for (const char of word) {\\n      const c = this.getCharCode(char);\\n      if (!current.children[c]) return -1;\\n      current = current.children[c];\\n    }\\n\\t\\n    return current.index;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166892,
                "title": "c-solution-wrapped-word",
                "content": "For every prefix of a word make a key, concatanating with suffix and insert into map\\nFor example, we will insert \\'#apple\\', \\'e#apple\\', \\'le#apple\\', \\'ple#apple\\', \\'pple#apple\\', \\'apple#apple\\' into the trie. Then for a query like prefix = \"ap\", suffix = \"le\", we can find it by querying our trie for le#ap.\\n\\t\\t\\t\\n\\n\\ttypedef struct node {\\n\\t\\t\\tint idx;\\n\\t\\t\\tstruct node *next[27];\\n\\t\\t} TrieNode;\\n\\tvoid trie_init(TrieNode *trie)    {         \\n\\t\\tmemset((void*)trie,0, sizeof(TrieNode));\\n\\t\\t// return 0;\\n\\t}\\n\\tvoid trie_insert (TrieNode *node, char* word, int index)  {\\n\\t\\tfor ( int i =0; i < strlen(word); i++) {\\n\\t\\t\\tint pos = word[i] - \\'a\\';\\n\\t\\t\\tif (node->next[pos] == NULL) {\\n\\t\\t\\t\\tnode->next[pos] = (TrieNode *)malloc(sizeof(TrieNode));\\n\\t\\t\\t\\tnode = node->next[pos];\\n\\t\\t\\t\\tmemset((void *)node, 0, sizeof(TrieNode));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnode =node->next[pos];\\n\\t\\t\\tnode->idx = index;\\n\\t\\t}\\n\\t}\\n\\tint query (TrieNode *node,char *word)  {\\n\\t\\tfor (int i =0 ; i < strlen(word); i++)  {\\n\\t\\t\\tint pos = word[i] - \\'a\\';\\n\\t\\t\\tif (node->next[pos])\\n\\t\\t\\t\\tnode = node->next[pos];\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn node->idx;\\n\\t}\\n\\n\\tvoid free_trie(TrieNode *trie)  {\\n\\t\\tif (trie == NULL)\\n\\t\\t\\treturn;\\n\\t\\tfor (int i =0 ; i < 27 ; i++)   {\\n\\t\\t\\ttrie_free(trie->next[i]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < 27; i++) {\\n\\t\\t\\tif (trie->next[i] != NULL) \\n\\t\\t\\t\\tfree(trie->next[i]);\\n\\n\\t\\t}\\n\\t} \\n\\n\\ttypedef struct {\\n\\t\\tTrieNode trie;\\n\\t} WordFilter;\\n\\n\\tWordFilter* wordFilterCreate(char ** words, int wordsSize) {\\n\\t\\tWordFilter* obj = (WordFilter *)calloc(sizeof(WordFilter), 1);\\n\\t\\ttrie_init (&obj->trie);\\n\\t\\tchar temp[22];     //double size length of word(10 char) + 1;\\n\\t\\tfor ( int i =0 ; i < wordsSize; i ++)   {\\n\\t\\t\\tint len = strlen(words[i]);\\n\\t\\t\\tstrcpy(temp, words[i]);\\n\\t\\t\\tstrcpy(&temp[len], \"{\");\\n\\t\\t\\tstrcpy(&temp[len + 1], words[i]);\\n\\t\\t\\t// apple{apple  pple{apple  ple{apple  le{apple  e{apple  {apple \\n\\t\\t\\tfor (int j = 0; j <= len; j++) {\\n\\t\\t\\t\\ttrie_insert(&obj->trie, &temp[j], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn obj;\\n\\t}\\n\\n\\tint wordFilterF(WordFilter* obj, char * prefix, char * suffix) {\\n\\t\\t/* string = \"suffix#prefix\" */\\n\\t\\tchar temp[22];\\n\\t\\tint len = strlen(suffix);\\n\\t\\tstrcpy(temp, suffix);\\n\\t\\tstrcpy(&temp[len], \"{\");\\n\\t\\tstrcpy(&temp[len + 1], prefix);\\n\\t\\treturn query (&obj->trie,temp);\\n\\t}\\n\\n\\tvoid wordFilterFree(WordFilter* obj) {\\n\\t\\tfree_trie(&obj->trie);\\n\\t\\tfree(obj);\\n\\t}\\n\\n\\t/**\\n\\t * Your WordFilter struct will be instantiated and called as such:\\n\\t * WordFilter* obj = wordFilterCreate(words, wordsSize);\\n\\t * int param_1 = wordFilterF(obj, prefix, suffix);\\n\\n\\t * wordFilterFree(obj);\\n\\t*/\\n",
                "solutionTags": [],
                "code": "For every prefix of a word make a key, concatanating with suffix and insert into map\\nFor example, we will insert \\'#apple\\', \\'e#apple\\', \\'le#apple\\', \\'ple#apple\\', \\'pple#apple\\', \\'apple#apple\\' into the trie. Then for a query like prefix = \"ap\", suffix = \"le\", we can find it by querying our trie for le#ap.\\n\\t\\t\\t\\n\\n\\ttypedef struct node {\\n\\t\\t\\tint idx;\\n\\t\\t\\tstruct node *next[27];\\n\\t\\t} TrieNode;\\n\\tvoid trie_init(TrieNode *trie)    {         \\n\\t\\tmemset((void*)trie,0, sizeof(TrieNode));\\n\\t\\t// return 0;\\n\\t}\\n\\tvoid trie_insert (TrieNode *node, char* word, int index)  {\\n\\t\\tfor ( int i =0; i < strlen(word); i++) {\\n\\t\\t\\tint pos = word[i] - \\'a\\';\\n\\t\\t\\tif (node->next[pos] == NULL) {\\n\\t\\t\\t\\tnode->next[pos] = (TrieNode *)malloc(sizeof(TrieNode));\\n\\t\\t\\t\\tnode = node->next[pos];\\n\\t\\t\\t\\tmemset((void *)node, 0, sizeof(TrieNode));\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tnode =node->next[pos];\\n\\t\\t\\tnode->idx = index;\\n\\t\\t}\\n\\t}\\n\\tint query (TrieNode *node,char *word)  {\\n\\t\\tfor (int i =0 ; i < strlen(word); i++)  {\\n\\t\\t\\tint pos = word[i] - \\'a\\';\\n\\t\\t\\tif (node->next[pos])\\n\\t\\t\\t\\tnode = node->next[pos];\\n\\t\\t\\telse\\n\\t\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn node->idx;\\n\\t}\\n\\n\\tvoid free_trie(TrieNode *trie)  {\\n\\t\\tif (trie == NULL)\\n\\t\\t\\treturn;\\n\\t\\tfor (int i =0 ; i < 27 ; i++)   {\\n\\t\\t\\ttrie_free(trie->next[i]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < 27; i++) {\\n\\t\\t\\tif (trie->next[i] != NULL) \\n\\t\\t\\t\\tfree(trie->next[i]);\\n\\n\\t\\t}\\n\\t} \\n\\n\\ttypedef struct {\\n\\t\\tTrieNode trie;\\n\\t} WordFilter;\\n\\n\\tWordFilter* wordFilterCreate(char ** words, int wordsSize) {\\n\\t\\tWordFilter* obj = (WordFilter *)calloc(sizeof(WordFilter), 1);\\n\\t\\ttrie_init (&obj->trie);\\n\\t\\tchar temp[22];     //double size length of word(10 char) + 1;\\n\\t\\tfor ( int i =0 ; i < wordsSize; i ++)   {\\n\\t\\t\\tint len = strlen(words[i]);\\n\\t\\t\\tstrcpy(temp, words[i]);\\n\\t\\t\\tstrcpy(&temp[len], \"{\");\\n\\t\\t\\tstrcpy(&temp[len + 1], words[i]);\\n\\t\\t\\t// apple{apple  pple{apple  ple{apple  le{apple  e{apple  {apple \\n\\t\\t\\tfor (int j = 0; j <= len; j++) {\\n\\t\\t\\t\\ttrie_insert(&obj->trie, &temp[j], i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn obj;\\n\\t}\\n\\n\\tint wordFilterF(WordFilter* obj, char * prefix, char * suffix) {\\n\\t\\t/* string = \"suffix#prefix\" */\\n\\t\\tchar temp[22];\\n\\t\\tint len = strlen(suffix);\\n\\t\\tstrcpy(temp, suffix);\\n\\t\\tstrcpy(&temp[len], \"{\");\\n\\t\\tstrcpy(&temp[len + 1], prefix);\\n\\t\\treturn query (&obj->trie,temp);\\n\\t}\\n\\n\\tvoid wordFilterFree(WordFilter* obj) {\\n\\t\\tfree_trie(&obj->trie);\\n\\t\\tfree(obj);\\n\\t}\\n\\n\\t/**\\n\\t * Your WordFilter struct will be instantiated and called as such:\\n\\t * WordFilter* obj = wordFilterCreate(words, wordsSize);\\n\\t * int param_1 = wordFilterF(obj, prefix, suffix);\\n\\n\\t * wordFilterFree(obj);\\n\\t*/\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2166751,
                "title": "trie-solution-java",
                "content": "```java\\nclass Node {\\n    Node links[] = new Node[27]; \\n    int endIdx;\\n    \\n    public Node() {\\n        \\n    }\\n    \\n    boolean containsKey(char ch) {\\n        return (links[ch - \\'a\\'] != null); \\n    }\\n    Node get(char ch) {\\n        return links[ch-\\'a\\']; \\n    }\\n    void put(char ch, Node node) {\\n        links[ch-\\'a\\'] = node; \\n    }\\n    void setIdx(int i) {\\n        endIdx = i;\\n    }\\n    int getIdx() {\\n        return endIdx;\\n    }\\n};\\npublic class Trie {\\n    private static Node root; \\n\\n    Trie() {\\n        root = new Node(); \\n    }\\n\\n    public static void insert(String word, int idx) {\\n        Node node = root;\\n        for(int i = 0;i<word.length();i++) {\\n            if(!node.containsKey(word.charAt(i))) {\\n                node.put(word.charAt(i), new Node()); \\n            }\\n            node = node.get(word.charAt(i)); \\n            node.setIdx(idx);\\n        }\\n    }\\n\\n    public static int startsWith(String prefix) {\\n        Node node = root; \\n        for(int i = 0;i<prefix.length();i++) {\\n            if(!node.containsKey(prefix.charAt(i))) {\\n                return -1; \\n            }\\n            node = node.get(prefix.charAt(i)); \\n        }\\n        return node.getIdx(); \\n    }\\n}\\nclass WordFilter {\\n    \\n    Trie trie = new Trie();\\n\\n    public WordFilter(String[] words) {\\n        \\n        int len = words.length;\\n        for (int i = 0; i < len; i++) {            \\n            String str = words[i];\\n            int n = str.length();\\n            for (int j = 0; j <= n; j++) {                \\n                String cur = str.substring(j) + \\'{\\' + str;\\n                trie.insert(cur, i);\\n            }\\n        }\\n        \\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String cur = suffix + \\'{\\' + prefix;\\n        return trie.startsWith(cur);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```java\\nclass Node {\\n    Node links[] = new Node[27]; \\n    int endIdx;\\n    \\n    public Node() {\\n        \\n    }\\n    \\n    boolean containsKey(char ch) {\\n        return (links[ch - \\'a\\'] != null); \\n    }\\n    Node get(char ch) {\\n        return links[ch-\\'a\\']; \\n    }\\n    void put(char ch, Node node) {\\n        links[ch-\\'a\\'] = node; \\n    }\\n    void setIdx(int i) {\\n        endIdx = i;\\n    }\\n    int getIdx() {\\n        return endIdx;\\n    }\\n};\\npublic class Trie {\\n    private static Node root; \\n\\n    Trie() {\\n        root = new Node(); \\n    }\\n\\n    public static void insert(String word, int idx) {\\n        Node node = root;\\n        for(int i = 0;i<word.length();i++) {\\n            if(!node.containsKey(word.charAt(i))) {\\n                node.put(word.charAt(i), new Node()); \\n            }\\n            node = node.get(word.charAt(i)); \\n            node.setIdx(idx);\\n        }\\n    }\\n\\n    public static int startsWith(String prefix) {\\n        Node node = root; \\n        for(int i = 0;i<prefix.length();i++) {\\n            if(!node.containsKey(prefix.charAt(i))) {\\n                return -1; \\n            }\\n            node = node.get(prefix.charAt(i)); \\n        }\\n        return node.getIdx(); \\n    }\\n}\\nclass WordFilter {\\n    \\n    Trie trie = new Trie();\\n\\n    public WordFilter(String[] words) {\\n        \\n        int len = words.length;\\n        for (int i = 0; i < len; i++) {            \\n            String str = words[i];\\n            int n = str.length();\\n            for (int j = 0; j <= n; j++) {                \\n                String cur = str.substring(j) + \\'{\\' + str;\\n                trie.insert(cur, i);\\n            }\\n        }\\n        \\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String cur = suffix + \\'{\\' + prefix;\\n        return trie.startsWith(cur);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166455,
                "title": "rust-trie-not-one-of-my-best-days",
                "content": "LeetCode is a harsh  master. I am in bed with a pretty high fever. Solving this Daily Challenge has taken me most of the day - but I did it. So overly complicated compared to othe posted solutions.... But here it is anyway:\\n\\n```\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct Trie {\\n    children: Vec<((u8, u8), Trie)>,\\n    value: Vec<usize>,\\n}\\n\\nimpl Trie {\\n    pub fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    pub fn insert(&mut self, word: &String, index: usize) {\\n        let mut node = self;\\n\\n        let mut fit = word.as_bytes().iter();\\n        let mut rit = fit.clone().rev();\\n\\n        while let (Some(fb), Some(rb)) = (fit.next(), rit.next()) {\\n            let len = node.children.len();\\n            let i = match node\\n                .children\\n                .iter()\\n                .enumerate()\\n                .find(|(_, ((p, s), _))| *fb == *p && *rb == *s)\\n                .map(|(i, _)| i)\\n            {\\n                Some(i) => i,\\n                None => {\\n                    node.children.push(((*fb, *rb), Trie::new()));\\n                    len\\n                }\\n            };\\n            node = &mut node.children[i].1;\\n        }\\n\\n        node.value.push(index)\\n    }\\n\\n    pub fn lookup(&self, prefix: &String, suffix: &String) -> Vec<usize> {\\n        let pb = prefix.as_bytes();\\n        let sb = suffix.as_bytes();\\n        let pn = pb.len();\\n        let sn = sb.len();\\n\\n        let mut rez = vec![];\\n        let mut stack = vec![(self, 0, sn - 1)];\\n\\n        while let Some((node, pi, si)) = stack.pop() {\\n            if pi == pn && si >= sn {\\n                rez.extend(node.value.iter());\\n                stack.extend(node.children.iter().map(|(_, n)| (n, pn, sn)));\\n            } else if si >= sn {\\n                stack.extend(\\n                    node.children\\n                        .iter()\\n                        .filter(|((p, _), _)| *p == pb[pi])\\n                        .map(|(_, n)| (n, pi + 1, sn)),\\n                );\\n            } else if pi == pn {\\n                stack.extend(\\n                    node.children\\n                        .iter()\\n                        .filter(|((_, s), _)| *s == sb[si])\\n                        .map(|(_, n)| (n, pn, si.wrapping_sub(1))),\\n                );\\n            } else {\\n                stack.extend(\\n                    node.children\\n                        .iter()\\n                        .filter(|((p, s), _)| *p == pb[pi] && *s == sb[si])\\n                        .map(|(_, n)| (n, pi + 1, si.wrapping_sub(1))),\\n                );\\n            }\\n        }\\n\\n        rez\\n    }\\n}\\n\\nstruct WordFilter {\\n    trie: Trie,\\n    memo: HashMap<(String, String), i32>,\\n}\\n\\nimpl WordFilter {\\n    fn new(words: Vec<String>) -> Self {\\n        let trie = words\\n            .iter()\\n            .enumerate()\\n            .fold(Trie::new(), |mut trie, (i, s)| {\\n                trie.insert(s, i);\\n                trie\\n            });\\n\\n        Self {\\n            trie,\\n            memo: HashMap::new(),\\n        }\\n    }\\n\\n    fn f(&mut self, prefix: String, suffix: String) -> i32 {\\n        if let Some(rez) = self.memo.get(&(prefix.clone(), suffix.clone())) {\\n            return *rez;\\n        }\\n\\n        let rez = self\\n            .trie\\n            .lookup(&prefix, &suffix)\\n            .iter()\\n            .max()\\n            .map(|r| *r as i32)\\n            .unwrap_or(-1);\\n\\n        self.memo.insert((prefix, suffix), rez);\\n        rez\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\n#[derive(Default)]\\nstruct Trie {\\n    children: Vec<((u8, u8), Trie)>,\\n    value: Vec<usize>,\\n}\\n\\nimpl Trie {\\n    pub fn new() -> Self {\\n        Self::default()\\n    }\\n\\n    pub fn insert(&mut self, word: &String, index: usize) {\\n        let mut node = self;\\n\\n        let mut fit = word.as_bytes().iter();\\n        let mut rit = fit.clone().rev();\\n\\n        while let (Some(fb), Some(rb)) = (fit.next(), rit.next()) {\\n            let len = node.children.len();\\n            let i = match node\\n                .children\\n                .iter()\\n                .enumerate()\\n                .find(|(_, ((p, s), _))| *fb == *p && *rb == *s)\\n                .map(|(i, _)| i)\\n            {\\n                Some(i) => i,\\n                None => {\\n                    node.children.push(((*fb, *rb), Trie::new()));\\n                    len\\n                }\\n            };\\n            node = &mut node.children[i].1;\\n        }\\n\\n        node.value.push(index)\\n    }\\n\\n    pub fn lookup(&self, prefix: &String, suffix: &String) -> Vec<usize> {\\n        let pb = prefix.as_bytes();\\n        let sb = suffix.as_bytes();\\n        let pn = pb.len();\\n        let sn = sb.len();\\n\\n        let mut rez = vec![];\\n        let mut stack = vec![(self, 0, sn - 1)];\\n\\n        while let Some((node, pi, si)) = stack.pop() {\\n            if pi == pn && si >= sn {\\n                rez.extend(node.value.iter());\\n                stack.extend(node.children.iter().map(|(_, n)| (n, pn, sn)));\\n            } else if si >= sn {\\n                stack.extend(\\n                    node.children\\n                        .iter()\\n                        .filter(|((p, _), _)| *p == pb[pi])\\n                        .map(|(_, n)| (n, pi + 1, sn)),\\n                );\\n            } else if pi == pn {\\n                stack.extend(\\n                    node.children\\n                        .iter()\\n                        .filter(|((_, s), _)| *s == sb[si])\\n                        .map(|(_, n)| (n, pn, si.wrapping_sub(1))),\\n                );\\n            } else {\\n                stack.extend(\\n                    node.children\\n                        .iter()\\n                        .filter(|((p, s), _)| *p == pb[pi] && *s == sb[si])\\n                        .map(|(_, n)| (n, pi + 1, si.wrapping_sub(1))),\\n                );\\n            }\\n        }\\n\\n        rez\\n    }\\n}\\n\\nstruct WordFilter {\\n    trie: Trie,\\n    memo: HashMap<(String, String), i32>,\\n}\\n\\nimpl WordFilter {\\n    fn new(words: Vec<String>) -> Self {\\n        let trie = words\\n            .iter()\\n            .enumerate()\\n            .fold(Trie::new(), |mut trie, (i, s)| {\\n                trie.insert(s, i);\\n                trie\\n            });\\n\\n        Self {\\n            trie,\\n            memo: HashMap::new(),\\n        }\\n    }\\n\\n    fn f(&mut self, prefix: String, suffix: String) -> i32 {\\n        if let Some(rez) = self.memo.get(&(prefix.clone(), suffix.clone())) {\\n            return *rez;\\n        }\\n\\n        let rez = self\\n            .trie\\n            .lookup(&prefix, &suffix)\\n            .iter()\\n            .max()\\n            .map(|r| *r as i32)\\n            .unwrap_or(-1);\\n\\n        self.memo.insert((prefix, suffix), rez);\\n        rez\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166391,
                "title": "java-solution-using-two-treemap",
                "content": "```\\nclass WordFilter {\\n        TreeMap<String, Integer> prefixMap = new TreeMap<>();\\n        TreeMap<String, Integer> suffixMap = new TreeMap<>();\\n\\n        public WordFilter(String[] words) {\\n            for (int i = 0; i < words.length; i++) {\\n                prefixMap.put(words[i], i);\\n                suffixMap.put(new StringBuilder(words[i]).reverse().toString(), i);\\n            }\\n        }\\n\\n        public int f(String prefix, String suffix) {\\n            int pos = -1;\\n            Set<Integer> set = new HashSet<>();\\n            for (Map.Entry<String, Integer> entry : prefixMap.subMap(getLowKey(prefix), getHighKey(prefix)).entrySet()) {\\n                if (entry.getKey().startsWith(prefix)) {\\n                    set.add(entry.getValue());\\n                }\\n            }\\n            suffix = new StringBuilder(suffix).reverse().toString();\\n            for (Map.Entry<String, Integer> entry : suffixMap.subMap(getLowKey(suffix), getHighKey(suffix)).entrySet()) {\\n                if (entry.getKey().startsWith(suffix) && set.contains(entry.getValue())) {\\n                    pos = Math.max(pos, entry.getValue());\\n                }\\n            }\\n            return pos;\\n        }\\n\\n       String getLowKey(String str) {\\n            return str.substring(0, str.length()-1) + (char) (str.charAt(str.length()-1) - 1);\\n        }\\n\\n        String getHighKey(String str) {\\n            return str.substring(0, str.length()-1) + (char) (str.charAt(str.length()-1) + 1);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordFilter {\\n        TreeMap<String, Integer> prefixMap = new TreeMap<>();\\n        TreeMap<String, Integer> suffixMap = new TreeMap<>();\\n\\n        public WordFilter(String[] words) {\\n            for (int i = 0; i < words.length; i++) {\\n                prefixMap.put(words[i], i);\\n                suffixMap.put(new StringBuilder(words[i]).reverse().toString(), i);\\n            }\\n        }\\n\\n        public int f(String prefix, String suffix) {\\n            int pos = -1;\\n            Set<Integer> set = new HashSet<>();\\n            for (Map.Entry<String, Integer> entry : prefixMap.subMap(getLowKey(prefix), getHighKey(prefix)).entrySet()) {\\n                if (entry.getKey().startsWith(prefix)) {\\n                    set.add(entry.getValue());\\n                }\\n            }\\n            suffix = new StringBuilder(suffix).reverse().toString();\\n            for (Map.Entry<String, Integer> entry : suffixMap.subMap(getLowKey(suffix), getHighKey(suffix)).entrySet()) {\\n                if (entry.getKey().startsWith(suffix) && set.contains(entry.getValue())) {\\n                    pos = Math.max(pos, entry.getValue());\\n                }\\n            }\\n            return pos;\\n        }\\n\\n       String getLowKey(String str) {\\n            return str.substring(0, str.length()-1) + (char) (str.charAt(str.length()-1) - 1);\\n        }\\n\\n        String getHighKey(String str) {\\n            return str.substring(0, str.length()-1) + (char) (str.charAt(str.length()-1) + 1);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166351,
                "title": "c-map-beats-50",
                "content": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string,int> m;\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string s=\"\";\\n            for(int p=0;p<words[i].length();p++)\\n            {\\n                s+=words[i][p];\\n                for(int q=0;q<words[i].length();q++)\\n                {\\n                    string t=s;\\n                    t+=\\'.\\';\\n                    t+=words[i].substr(q,words[i].length()-q);\\n                    m[t]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        prefix+=\\'.\\';\\n        prefix+=suffix;\\n        if(m.find(prefix)!=m.end())\\n            return m[prefix];\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string,int> m;\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            string s=\"\";\\n            for(int p=0;p<words[i].length();p++)\\n            {\\n                s+=words[i][p];\\n                for(int q=0;q<words[i].length();q++)\\n                {\\n                    string t=s;\\n                    t+=\\'.\\';\\n                    t+=words[i].substr(q,words[i].length()-q);\\n                    m[t]=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        prefix+=\\'.\\';\\n        prefix+=suffix;\\n        if(m.find(prefix)!=m.end())\\n            return m[prefix];\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166008,
                "title": "java-small-and-easy-understanding",
                "content": "\\n\\n    HashMap<String, Integer> map = new HashMap<>();\\n    public String all(String s, int i, int j,int index, HashMap<String, String> dp_map){\\n        if(i >= s.length() || j < 0) return \"\";   // base condition\\n        if(dp_map.containsKey(i +\"#\" + j)){\\n            return dp_map.get(i+\"#\"+j);\\n        }\\n        String start = all(s, i+1, j, index, dp_map); // getting all Prefix +  \"#\" + suffix  from the start\\n        String end = all(s, i, j-1, index, dp_map);  //  getting all Prefix +  \"#\" + suffix  from the end  \\n        map.put(start, index);\\n        map.put(end, index);\\n        dp_map.put(i+\"#\"+j, s.substring(0,i+1) + \"#\" +s.substring(j, s.length()));\\n        return s.substring(0,i+1) + \"#\" + s.substring(j, s.length());\\n    }\\n    public WordFilter(String[] words) {\\n        for(int j = 0; j < words.length; j++){\\n            HashMap<String, String> dp_map = new HashMap<>();\\n            if(j < words.length - 1 && words[j].equals(words[j+1])) continue; // if strings are same we want maximum index\\n            all(words[j], -1, words[j].length(), j, dp_map);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return map.getOrDefault(prefix + \"#\" + suffix, -1);\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "\\n\\n    HashMap<String, Integer> map = new HashMap<>();\\n    public String all(String s, int i, int j,int index, HashMap<String, String> dp_map){\\n        if(i >= s.length() || j < 0) return \"\";   // base condition\\n        if(dp_map.containsKey(i +\"#\" + j)){\\n            return dp_map.get(i+\"#\"+j);\\n        }\\n        String start = all(s, i+1, j, index, dp_map); // getting all Prefix +  \"#\" + suffix  from the start\\n        String end = all(s, i, j-1, index, dp_map);  //  getting all Prefix +  \"#\" + suffix  from the end  \\n        map.put(start, index);\\n        map.put(end, index);\\n        dp_map.put(i+\"#\"+j, s.substring(0,i+1) + \"#\" +s.substring(j, s.length()));\\n        return s.substring(0,i+1) + \"#\" + s.substring(j, s.length());\\n    }\\n    public WordFilter(String[] words) {\\n        for(int j = 0; j < words.length; j++){\\n            HashMap<String, String> dp_map = new HashMap<>();\\n            if(j < words.length - 1 && words[j].equals(words[j+1])) continue; // if strings are same we want maximum index\\n            all(words[j], -1, words[j].length(), j, dp_map);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return map.getOrDefault(prefix + \"#\" + suffix, -1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2165949,
                "title": "c-faster-not-trie-a-hashmap-solution",
                "content": "```\\nclass WordFilter {\\n    private:\\n    unordered_map<string,int>mp;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n          insert(i,words[i]);\\n        \\n    }\\n    \\n    void insert(int index,string word)\\n    {int len=word.size();\\n        for(int i=0;i<len;i++)\\n            for(int j=0;j<len;j++)\\n            {\\n                string s2=word.substr(j);\\n               string s1=word.substr(0,len-i);\\n                // cout<<s1+\"#\"+s2<<endl;\\n                mp[s1+\"#\"+s2]=index+1;\\n            }\\n    }\\n    int f(string prefix, string suffix) {\\n     string s=prefix+\"#\"+suffix;\\n        return mp[s]-1;\\n    }\\n    \\n};\\n```\\n**PLEASE UPVOTE IF YOU LIKE MY SOLUTION ;}**",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n    private:\\n    unordered_map<string,int>mp;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n          insert(i,words[i]);\\n        \\n    }\\n    \\n    void insert(int index,string word)\\n    {int len=word.size();\\n        for(int i=0;i<len;i++)\\n            for(int j=0;j<len;j++)\\n            {\\n                string s2=word.substr(j);\\n               string s1=word.substr(0,len-i);\\n                // cout<<s1+\"#\"+s2<<endl;\\n                mp[s1+\"#\"+s2]=index+1;\\n            }\\n    }\\n    int f(string prefix, string suffix) {\\n     string s=prefix+\"#\"+suffix;\\n        return mp[s]-1;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2165817,
                "title": "simple-brute-force-solution-on-python",
                "content": "For those who are too lazy to mess with tries, like me, there is a simple brute force solution: just create a dict with all possible ```(prefix, suffix)```-keys for all the words. This makes the hard work to be done only once, and then every execution of ```f``` function takes just O(1) time.\\n\\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.pattern = defaultdict()\\n        for idx, word in enumerate(words):\\n            for i in range(len(word)):\\n                for j in range(len(word)):\\n                    self.pattern[(word[:i + 1], word[j:])] = idx\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.pattern.get((prefix, suffix), -1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```(prefix, suffix)```\n```f```\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.pattern = defaultdict()\\n        for idx, word in enumerate(words):\\n            for i in range(len(word)):\\n                for j in range(len(word)):\\n                    self.pattern[(word[:i + 1], word[j:])] = idx\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        return self.pattern.get((prefix, suffix), -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165813,
                "title": "prefix-and-suffix-search-java-trie-array-2-solutions",
                "content": "**Prefix and Suffix Search:**\\n\\n**Algorithm Hint Diagram:**\\n\\n**1) Forward Traversal:**\\n\\n![image](https://assets.leetcode.com/users/images/585b3198-28eb-4fa4-8289-49cfdc5b1db9_1655551618.735004.jpeg)\\n\\n**2)  Reverse Traversal:**\\n\\n![image](https://assets.leetcode.com/users/images/2066a230-2353-47af-bc2d-fb7dbb651448_1655551642.6418126.jpeg)\\n\\n**1st Code:**\\n\\n**TC:** O(nw\\xB2)\\n**SC:** O(nw)\\n\\nclass WordFilter\\n{\\n\\n\\tprivate final Trie trie = new Trie();\\n\\n\\tpublic WordFilter(String[] words)\\n    {\\n\\t\\tfor (var i = 0; i < words.length; i++)\\n        {\\n\\t\\t\\tvar joined = words[i].concat(\"-\").concat(words[i]);\\n\\t\\t\\tfor (var j = 0; j < words[i].length(); j++)\\n\\t\\t\\t\\ttrie.insert(joined, j, i);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int f(String prefix, String suffix)\\n    {\\n\\t\\tvar node = trie.root;\\n\\t\\tvar query = suffix.concat(\"-\").concat(prefix);\\n\\n\\t\\tfor (var i = 0; i < query.length(); i++)\\n        {\\n\\t\\t\\tvar key = query.charAt(i);\\n\\t\\t\\tif (!node.children.containsKey(key))\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tnode = node.children.get(key);\\n\\t\\t}\\n\\t\\treturn node.index;\\n\\t}\\n\\n\\tprivate static class Trie\\n    {\\n\\t\\tprivate final TrieNode root = new TrieNode();\\n\\n\\t\\tpublic void insert(String joined, int start, int index)\\n        {\\n\\t\\t\\tvar node = root;\\n\\t\\t\\tfor (var i = start; i < joined.length(); i++)\\n            {\\n\\t\\t\\t\\tnode = node.children.computeIfAbsent(joined.charAt(i), k -> new TrieNode());\\n\\t\\t\\t\\tnode.index = index;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate static class TrieNode\\n        {\\n\\t\\t\\tprivate final Map<Character, TrieNode> children = new HashMap<>(27);\\n\\t\\t\\tprivate int index;\\n\\t\\t}\\n\\t}\\n}\\n\\n**2nd Code:**\\n\\n**TC:** N*K + Q(K+N)\\n**SC:** N*K\\n\\nclass WordFilter\\n{\\n\\n    Trie prefix = null;\\n    Trie suffix = null;\\n    \\n    public WordFilter(String[] words)\\n    {\\n        prefix = new Trie();\\n        suffix = new Trie();\\n        \\n        for(int i = 0; i < words.length; i++)\\n        {\\n            prefix.insert(words[i], i);\\n            suffix.insert(new StringBuilder(words[i]).reverse().toString(), i);\\n        }\\n       \\n    }\\n\\n    public int f(String pre, String suff)\\n    {\\n        List<Integer> pList = prefix.startswith(pre);\\n        List<Integer> sList = suffix.startswith(new StringBuilder(suff).reverse().toString());\\n        \\n        int i = pList.size()-1, j = sList.size()-1;\\n        while(i >= 0 && j >= 0)\\n        {\\n            if(Objects.equals(pList.get(i), sList.get(j))) return pList.get(i);\\n            else if(pList.get(i) > sList.get(j)) i--;\\n            else j--;\\n        }\\n        \\n        return -1;\\n    } \\n}\\n\\nclass Trie\\n{\\n    \\n    public Trie[] t;\\n    List<Integer> index;\\n    \\n    Trie()\\n    {\\n        t = new Trie[26];\\n        index = new ArrayList<>();\\n    }\\n    \\n    //insert\\n    public void insert(String word, int i)\\n    {\\n        Trie root = this;\\n        for(char c: word.toCharArray())\\n        {\\n            if(root.t[c-\\'a\\'] == null)\\n            {\\n                root.t[c-\\'a\\'] = new Trie();\\n            }\\n            root = root.t[c-\\'a\\'];\\n            root.index.add(i);\\n        }\\n    }\\n    \\n    //startswith\\n    public List<Integer> startswith(String word)\\n    {\\n        Trie root = this;\\n        for(char c : word.toCharArray())\\n        {\\n            if(root.t[c-\\'a\\'] == null)\\n            {\\n                return new ArrayList<>();\\n            }\\n            root = root.t[c-\\'a\\'];\\n        }\\n        return root.index;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "**Prefix and Suffix Search:**\\n\\n**Algorithm Hint Diagram:**\\n\\n**1) Forward Traversal:**\\n\\n![image](https://assets.leetcode.com/users/images/585b3198-28eb-4fa4-8289-49cfdc5b1db9_1655551618.735004.jpeg)\\n\\n**2)  Reverse Traversal:**\\n\\n![image](https://assets.leetcode.com/users/images/2066a230-2353-47af-bc2d-fb7dbb651448_1655551642.6418126.jpeg)\\n\\n**1st Code:**\\n\\n**TC:** O(nw\\xB2)\\n**SC:** O(nw)\\n\\nclass WordFilter\\n{\\n\\n\\tprivate final Trie trie = new Trie();\\n\\n\\tpublic WordFilter(String[] words)\\n    {\\n\\t\\tfor (var i = 0; i < words.length; i++)\\n        {\\n\\t\\t\\tvar joined = words[i].concat(\"-\").concat(words[i]);\\n\\t\\t\\tfor (var j = 0; j < words[i].length(); j++)\\n\\t\\t\\t\\ttrie.insert(joined, j, i);\\n\\t\\t}\\n\\t}\\n\\n\\tpublic int f(String prefix, String suffix)\\n    {\\n\\t\\tvar node = trie.root;\\n\\t\\tvar query = suffix.concat(\"-\").concat(prefix);\\n\\n\\t\\tfor (var i = 0; i < query.length(); i++)\\n        {\\n\\t\\t\\tvar key = query.charAt(i);\\n\\t\\t\\tif (!node.children.containsKey(key))\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\tnode = node.children.get(key);\\n\\t\\t}\\n\\t\\treturn node.index;\\n\\t}\\n\\n\\tprivate static class Trie\\n    {\\n\\t\\tprivate final TrieNode root = new TrieNode();\\n\\n\\t\\tpublic void insert(String joined, int start, int index)\\n        {\\n\\t\\t\\tvar node = root;\\n\\t\\t\\tfor (var i = start; i < joined.length(); i++)\\n            {\\n\\t\\t\\t\\tnode = node.children.computeIfAbsent(joined.charAt(i), k -> new TrieNode());\\n\\t\\t\\t\\tnode.index = index;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tprivate static class TrieNode\\n        {\\n\\t\\t\\tprivate final Map<Character, TrieNode> children = new HashMap<>(27);\\n\\t\\t\\tprivate int index;\\n\\t\\t}\\n\\t}\\n}\\n\\n**2nd Code:**\\n\\n**TC:** N*K + Q(K+N)\\n**SC:** N*K\\n\\nclass WordFilter\\n{\\n\\n    Trie prefix = null;\\n    Trie suffix = null;\\n    \\n    public WordFilter(String[] words)\\n    {\\n        prefix = new Trie();\\n        suffix = new Trie();\\n        \\n        for(int i = 0; i < words.length; i++)\\n        {\\n            prefix.insert(words[i], i);\\n            suffix.insert(new StringBuilder(words[i]).reverse().toString(), i);\\n        }\\n       \\n    }\\n\\n    public int f(String pre, String suff)\\n    {\\n        List<Integer> pList = prefix.startswith(pre);\\n        List<Integer> sList = suffix.startswith(new StringBuilder(suff).reverse().toString());\\n        \\n        int i = pList.size()-1, j = sList.size()-1;\\n        while(i >= 0 && j >= 0)\\n        {\\n            if(Objects.equals(pList.get(i), sList.get(j))) return pList.get(i);\\n            else if(pList.get(i) > sList.get(j)) i--;\\n            else j--;\\n        }\\n        \\n        return -1;\\n    } \\n}\\n\\nclass Trie\\n{\\n    \\n    public Trie[] t;\\n    List<Integer> index;\\n    \\n    Trie()\\n    {\\n        t = new Trie[26];\\n        index = new ArrayList<>();\\n    }\\n    \\n    //insert\\n    public void insert(String word, int i)\\n    {\\n        Trie root = this;\\n        for(char c: word.toCharArray())\\n        {\\n            if(root.t[c-\\'a\\'] == null)\\n            {\\n                root.t[c-\\'a\\'] = new Trie();\\n            }\\n            root = root.t[c-\\'a\\'];\\n            root.index.add(i);\\n        }\\n    }\\n    \\n    //startswith\\n    public List<Integer> startswith(String word)\\n    {\\n        Trie root = this;\\n        for(char c : word.toCharArray())\\n        {\\n            if(root.t[c-\\'a\\'] == null)\\n            {\\n                return new ArrayList<>();\\n            }\\n            root = root.t[c-\\'a\\'];\\n        }\\n        return root.index;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2165767,
                "title": "c-using-2-hashmaps-slow-but-memory-efficient-beats-80",
                "content": "```\\nclass WordFilter {\\npublic:\\n    map <pair<char,char>,set< pair<int,string>,greater<pair<int,string>> > > mp;\\n    map <pair<string,string>, int> ms;\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            mp[{words[i][0],words[i][words[i].size()-1]}].insert({i,words[i]});\\n        }\\n    }\\n    \\n    int f(string p, string s) {\\n        if(ms.find({p,s}) != ms.end()) return ms[{p,s}];\\n        int ans = -1;\\n        string sf;\\n        if(mp.find({p[0],s[s.size()-1]}) != mp.end()){\\n            for( auto c: mp[{p[0],s[s.size()-1]}] ){\\n                sf = c.second;\\n                if( ( p == sf.substr(0,p.size()) ) && ( s == sf.substr(sf.size()-s.size(), s.size()) ) ){\\n                    ans = c.first;\\n                    ms[{p,s}] = ans;\\n                    break;\\n            }\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    map <pair<char,char>,set< pair<int,string>,greater<pair<int,string>> > > mp;\\n    map <pair<string,string>, int> ms;\\n    WordFilter(vector<string>& words) {\\n        for(int i=0;i<words.size();i++){\\n            mp[{words[i][0],words[i][words[i].size()-1]}].insert({i,words[i]});\\n        }\\n    }\\n    \\n    int f(string p, string s) {\\n        if(ms.find({p,s}) != ms.end()) return ms[{p,s}];\\n        int ans = -1;\\n        string sf;\\n        if(mp.find({p[0],s[s.size()-1]}) != mp.end()){\\n            for( auto c: mp[{p[0],s[s.size()-1]}] ){\\n                sf = c.second;\\n                if( ( p == sf.substr(0,p.size()) ) && ( s == sf.substr(sf.size()-s.size(), s.size()) ) ){\\n                    ans = c.first;\\n                    ms[{p,s}] = ans;\\n                    break;\\n            }\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165652,
                "title": "c-simple-solution-memory-efficient-single-trie",
                "content": "```\\n/*\\n        We are storing word as suffix + \\'{\\' + prefix \\n        \\n        apple -> suffix + \\'{\\' + prefix, index\\n            apple{apple 0\\n            pple{apple 0\\n            ple{apple 0\\n            le{apple 0\\n            e{apple 0\\n            {apple 0\\n\\n\\n        */\\nclass Node {\\n    Node *links[27] = {};   // 27 because we are using a special char \\'{\\' &&  index of  [\\'{\\'  -  \\'a\\']  is 26\\n    int index;\\npublic:\\n    ~Node() {\\n        for(int i=0; i<27; i++) {\\n            if(links[i]) delete links[i];\\n        }\\n    }\\n    \\n    bool containsLetter(char ch) {\\n        return links[ch - \\'a\\'] != nullptr;\\n    }\\n    \\n    void put(char ch, Node *newNode) {\\n        links[ch - \\'a\\'] = newNode;\\n    }\\n    \\n    Node *get(char ch) {\\n        return links[ch - \\'a\\'];\\n    }\\n    \\n    int getIndex() {\\n        return index;\\n    }\\n    \\n    void setIndex(int idx) {\\n        index = idx;\\n    }\\n};\\n\\nclass Trie {\\n    Node *root;\\npublic:\\n    \\n    Trie() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string s, int index) {\\n        Node *temp = root;\\n        for(auto ch: s) {\\n            if(temp->containsLetter(ch)) {\\n                temp = temp->get(ch);\\n            } else {\\n                temp->put(ch, new Node);\\n                temp =temp->get(ch);\\n            }\\n            temp->setIndex(index);\\n        }\\n    }\\n    \\n    int find(string s) {\\n        Node*temp = root;\\n        for(char ch:s) {\\n            if(temp->containsLetter(ch)) temp = temp->get(ch);\\n            \\n            else return -1;\\n        }\\n        return temp->getIndex();\\n    }\\n};\\n\\n\\nclass WordFilter {\\n    Trie trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        \\n        for(int i=0;i<words.size();i++) {\\n            for(int j=0;j<words[i].size();j++) {\\n                string s = words[i].substr(j) + \\'{\\' + words[i];\\n                trie.insert(s, i);\\n            }\\n        }\\n        \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string s = suffix + \\'{\\' + prefix;\\n        \\n        return trie.find(s);\\n    }\\n};",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\n/*\\n        We are storing word as suffix + \\'{\\' + prefix \\n        \\n        apple -> suffix + \\'{\\' + prefix, index\\n            apple{apple 0\\n            pple{apple 0\\n            ple{apple 0\\n            le{apple 0\\n            e{apple 0\\n            {apple 0\\n\\n\\n        */\\nclass Node {\\n    Node *links[27] = {};   // 27 because we are using a special char \\'{\\' &&  index of  [\\'{\\'  -  \\'a\\']  is 26\\n    int index;\\npublic:\\n    ~Node() {\\n        for(int i=0; i<27; i++) {\\n            if(links[i]) delete links[i];\\n        }\\n    }\\n    \\n    bool containsLetter(char ch) {\\n        return links[ch - \\'a\\'] != nullptr;\\n    }\\n    \\n    void put(char ch, Node *newNode) {\\n        links[ch - \\'a\\'] = newNode;\\n    }\\n    \\n    Node *get(char ch) {\\n        return links[ch - \\'a\\'];\\n    }\\n    \\n    int getIndex() {\\n        return index;\\n    }\\n    \\n    void setIndex(int idx) {\\n        index = idx;\\n    }\\n};\\n\\nclass Trie {\\n    Node *root;\\npublic:\\n    \\n    Trie() {\\n        root = new Node();\\n    }\\n    \\n    void insert(string s, int index) {\\n        Node *temp = root;\\n        for(auto ch: s) {\\n            if(temp->containsLetter(ch)) {\\n                temp = temp->get(ch);\\n            } else {\\n                temp->put(ch, new Node);\\n                temp =temp->get(ch);\\n            }\\n            temp->setIndex(index);\\n        }\\n    }\\n    \\n    int find(string s) {\\n        Node*temp = root;\\n        for(char ch:s) {\\n            if(temp->containsLetter(ch)) temp = temp->get(ch);\\n            \\n            else return -1;\\n        }\\n        return temp->getIndex();\\n    }\\n};\\n\\n\\nclass WordFilter {\\n    Trie trie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        \\n        for(int i=0;i<words.size();i++) {\\n            for(int j=0;j<words[i].size();j++) {\\n                string s = words[i].substr(j) + \\'{\\' + words[i];\\n                trie.insert(s, i);\\n            }\\n        }\\n        \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string s = suffix + \\'{\\' + prefix;\\n        \\n        return trie.find(s);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2165569,
                "title": "c-trie-of-suffix-wrapped-words",
                "content": "Implemented according to Approach #3: Trie of Suffix Wrapped Words\\nhttps://leetcode.com/problems/prefix-and-suffix-search/solution/\\n\\n```\\n/*\\n * Design a special dictionary with some words that \\n * searchs the words in it by a prefix and a suffix.\\n * \\n * Implement the WordFilter class:\\n * \\n * WordFilter(string[] words) Initializes the object \\n * with the words in the dictionary.\\n * f(string prefix, string suffix) Returns the index of \\n * the word in the dictionary, which has the prefix prefix \\n * and the suffix suffix. If there is more than one valid index, \\n * return the largest of them. If there is no such word in the \\n * dictionary, return -1.\\n *\\n * 1 <= words.length <= 15000\\n * 1 <= words[i].length <= 10\\n * 1 <= prefix.length, suffix.length <= 10\\n * words[i], prefix and suffix consist of lower-case English letters only.\\n * At most 15000 calls will be made to the function f.\\n */\\n \\ntypedef struct node {\\n    char chr;   /* for debug purpose */\\n    int idx;    /* dictionary index */\\n    struct node *next[27];   /* \\'a\\' ~ \\'z\\', and \\'#\\' */\\n} NODE;\\n\\nint trie_init(NODE *trie)\\n{\\n    memset((void *)trie, 0, sizeof(NODE));\\n    return 0;\\n}\\n\\nint trie_insert(NODE *trie, char *w, int idx)\\n{\\n    int pos;\\n    \\n    while (*w) {\\n        \\n        /* \\'a\\' ~ \\'z\\' or \\'#\\' */\\n        pos = (*w >= \\'a\\' && *w <= \\'z\\') ? (*w - \\'a\\') : 26;\\n    \\n        /* Create new node if needed */\\n        if (trie->next[pos] == NULL) {\\n            trie->next[pos] = (NODE *)malloc(sizeof(NODE));\\n            trie = trie->next[pos];\\n            memset((void *)trie, 0, sizeof(NODE));\\n            trie->chr = *w;\\n            trie->idx = -1;\\n        }\\n        /* Move to the next corresponding node */\\n        else {\\n            trie = trie->next[pos];\\n        }\\n        \\n        /* Store the dictionary index if this is the last character of word */\\n        if (*(w + 1) == 0) {\\n            trie->idx = idx;\\n        }\\n        \\n        /* Continue to process next character */\\n        w++;\\n    }\\n    \\n    return 0;\\n}\\n\\n/* \\n * DFS, traverse from given node, find out the maximum dictionary index \\n */\\nvoid trie_max_idx(NODE *trie, int *max_idx)\\n{\\n    if (trie == NULL) {\\n        return;\\n    }\\n    \\n    if (trie->idx != -1) {\\n        if (trie->idx > *max_idx) {\\n            *max_idx = trie->idx;\\n        }\\n    }\\n    \\n    for (int i = 0; i < 26; i++) {\\n        trie_max_idx(trie->next[i], max_idx);\\n    }\\n}\\n\\nint trie_search(NODE *trie, char *w)\\n{\\n    int pos;\\n    int max_idx = -1;\\n\\n    while(trie && *w) {\\n    \\n        pos = (*w >= \\'a\\' && *w <= \\'z\\') ? (*w - \\'a\\') : 26;\\n    \\n        /* Mismatched */\\n        if (trie->next[pos] == NULL) {\\n            return -1;\\n        }\\n        /* \\n         * Move to next character node \\n         * \\n         */\\n        else {\\n            trie = trie->next[pos];\\n        \\n            /* \\n             * Found matching string, continue to travese \\n             * rest nodes and find maximum index \\n             */\\n            if (*(w + 1) == 0) {\\n                trie_max_idx(trie, &max_idx);\\n                return max_idx;\\n            }\\n        }\\n    \\n        w++;\\n    }\\n\\n    return -1;\\n}\\n\\nvoid trie_dfs_free(NODE *trie)\\n{\\n    if (trie == NULL) {\\n        return;\\n    }\\n    \\n    for (int i = 0; i < 27; i++) {\\n        trie_dfs_free(trie->next[i]);\\n    }\\n\\n    for (int i = 0; i < 27; i++) {\\n        if (trie->next[i] != NULL) {\\n            free(trie->next[i]);\\n        }\\n    }\\n}\\n\\nint trie_free(NODE *trie)\\n{\\n    trie_dfs_free(trie);\\n    return 0;\\n} \\n\\ntypedef struct {\\n    NODE trie;\\n} WordFilter;\\n\\n\\nWordFilter* wordFilterCreate(char ** words, int wordsSize) {\\n\\n    WordFilter *p_obj = (WordFilter *)calloc(sizeof(WordFilter), 1);\\n    char tmp[22];\\n    int len;\\n    \\n    trie_init(&p_obj->trie);\\n    \\n    for (int i = 0; i < wordsSize; i++) {\\n    \\n        /* \"apple\"  => longest suffix + prefix is \"apple#apple\" */\\n        len = strlen(words[i]);\\n        strcpy(tmp, words[i]);\\n        strcpy(&tmp[len], \"#\");\\n        strcpy(&tmp[len + 1], words[i]);\\n\\n        /* \"apple#apple\", \"pple#apple\", \"ple#apple\", \"le#apple\", \"e#apple\", \"#apple\" */\\n        for (int j = 0; j <= len; j++) {\\n            trie_insert(&p_obj->trie, &tmp[j], i);\\n        }\\n    }\\n\\n    return p_obj;\\n}\\n\\nint wordFilterF(WordFilter* obj, char * prefix, char * suffix) {\\n\\n    char tmp[22];\\n    int s_len = strlen(suffix);\\n    \\n    /* string = \"suffix#prefix\" */\\n    strcpy(tmp, suffix);\\n    strcpy(&tmp[s_len], \"#\");\\n    strcpy(&tmp[s_len + 1], prefix);\\n\\n    return trie_search(&obj->trie, tmp);\\n}\\n\\nvoid wordFilterFree(WordFilter* obj) {\\n    trie_free(&obj->trie);\\n    free(obj);\\n}\\n\\n/**\\n * Your WordFilter struct will be instantiated and called as such:\\n * WordFilter* obj = wordFilterCreate(words, wordsSize);\\n * int param_1 = wordFilterF(obj, prefix, suffix);\\n \\n * wordFilterFree(obj);\\n*/\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "String",
                    "Tree",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\n/*\\n * Design a special dictionary with some words that \\n * searchs the words in it by a prefix and a suffix.\\n * \\n * Implement the WordFilter class:\\n * \\n * WordFilter(string[] words) Initializes the object \\n * with the words in the dictionary.\\n * f(string prefix, string suffix) Returns the index of \\n * the word in the dictionary, which has the prefix prefix \\n * and the suffix suffix. If there is more than one valid index, \\n * return the largest of them. If there is no such word in the \\n * dictionary, return -1.\\n *\\n * 1 <= words.length <= 15000\\n * 1 <= words[i].length <= 10\\n * 1 <= prefix.length, suffix.length <= 10\\n * words[i], prefix and suffix consist of lower-case English letters only.\\n * At most 15000 calls will be made to the function f.\\n */\\n \\ntypedef struct node {\\n    char chr;   /* for debug purpose */\\n    int idx;    /* dictionary index */\\n    struct node *next[27];   /* \\'a\\' ~ \\'z\\', and \\'#\\' */\\n} NODE;\\n\\nint trie_init(NODE *trie)\\n{\\n    memset((void *)trie, 0, sizeof(NODE));\\n    return 0;\\n}\\n\\nint trie_insert(NODE *trie, char *w, int idx)\\n{\\n    int pos;\\n    \\n    while (*w) {\\n        \\n        /* \\'a\\' ~ \\'z\\' or \\'#\\' */\\n        pos = (*w >= \\'a\\' && *w <= \\'z\\') ? (*w - \\'a\\') : 26;\\n    \\n        /* Create new node if needed */\\n        if (trie->next[pos] == NULL) {\\n            trie->next[pos] = (NODE *)malloc(sizeof(NODE));\\n            trie = trie->next[pos];\\n            memset((void *)trie, 0, sizeof(NODE));\\n            trie->chr = *w;\\n            trie->idx = -1;\\n        }\\n        /* Move to the next corresponding node */\\n        else {\\n            trie = trie->next[pos];\\n        }\\n        \\n        /* Store the dictionary index if this is the last character of word */\\n        if (*(w + 1) == 0) {\\n            trie->idx = idx;\\n        }\\n        \\n        /* Continue to process next character */\\n        w++;\\n    }\\n    \\n    return 0;\\n}\\n\\n/* \\n * DFS, traverse from given node, find out the maximum dictionary index \\n */\\nvoid trie_max_idx(NODE *trie, int *max_idx)\\n{\\n    if (trie == NULL) {\\n        return;\\n    }\\n    \\n    if (trie->idx != -1) {\\n        if (trie->idx > *max_idx) {\\n            *max_idx = trie->idx;\\n        }\\n    }\\n    \\n    for (int i = 0; i < 26; i++) {\\n        trie_max_idx(trie->next[i], max_idx);\\n    }\\n}\\n\\nint trie_search(NODE *trie, char *w)\\n{\\n    int pos;\\n    int max_idx = -1;\\n\\n    while(trie && *w) {\\n    \\n        pos = (*w >= \\'a\\' && *w <= \\'z\\') ? (*w - \\'a\\') : 26;\\n    \\n        /* Mismatched */\\n        if (trie->next[pos] == NULL) {\\n            return -1;\\n        }\\n        /* \\n         * Move to next character node \\n         * \\n         */\\n        else {\\n            trie = trie->next[pos];\\n        \\n            /* \\n             * Found matching string, continue to travese \\n             * rest nodes and find maximum index \\n             */\\n            if (*(w + 1) == 0) {\\n                trie_max_idx(trie, &max_idx);\\n                return max_idx;\\n            }\\n        }\\n    \\n        w++;\\n    }\\n\\n    return -1;\\n}\\n\\nvoid trie_dfs_free(NODE *trie)\\n{\\n    if (trie == NULL) {\\n        return;\\n    }\\n    \\n    for (int i = 0; i < 27; i++) {\\n        trie_dfs_free(trie->next[i]);\\n    }\\n\\n    for (int i = 0; i < 27; i++) {\\n        if (trie->next[i] != NULL) {\\n            free(trie->next[i]);\\n        }\\n    }\\n}\\n\\nint trie_free(NODE *trie)\\n{\\n    trie_dfs_free(trie);\\n    return 0;\\n} \\n\\ntypedef struct {\\n    NODE trie;\\n} WordFilter;\\n\\n\\nWordFilter* wordFilterCreate(char ** words, int wordsSize) {\\n\\n    WordFilter *p_obj = (WordFilter *)calloc(sizeof(WordFilter), 1);\\n    char tmp[22];\\n    int len;\\n    \\n    trie_init(&p_obj->trie);\\n    \\n    for (int i = 0; i < wordsSize; i++) {\\n    \\n        /* \"apple\"  => longest suffix + prefix is \"apple#apple\" */\\n        len = strlen(words[i]);\\n        strcpy(tmp, words[i]);\\n        strcpy(&tmp[len], \"#\");\\n        strcpy(&tmp[len + 1], words[i]);\\n\\n        /* \"apple#apple\", \"pple#apple\", \"ple#apple\", \"le#apple\", \"e#apple\", \"#apple\" */\\n        for (int j = 0; j <= len; j++) {\\n            trie_insert(&p_obj->trie, &tmp[j], i);\\n        }\\n    }\\n\\n    return p_obj;\\n}\\n\\nint wordFilterF(WordFilter* obj, char * prefix, char * suffix) {\\n\\n    char tmp[22];\\n    int s_len = strlen(suffix);\\n    \\n    /* string = \"suffix#prefix\" */\\n    strcpy(tmp, suffix);\\n    strcpy(&tmp[s_len], \"#\");\\n    strcpy(&tmp[s_len + 1], prefix);\\n\\n    return trie_search(&obj->trie, tmp);\\n}\\n\\nvoid wordFilterFree(WordFilter* obj) {\\n    trie_free(&obj->trie);\\n    free(obj);\\n}\\n\\n/**\\n * Your WordFilter struct will be instantiated and called as such:\\n * WordFilter* obj = wordFilterCreate(words, wordsSize);\\n * int param_1 = wordFilterF(obj, prefix, suffix);\\n \\n * wordFilterFree(obj);\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165545,
                "title": "python-simple-python-solution-by-generating-all-pairs-in-dictionary-hashmap",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 2029 ms, faster than 47.10% of Python3 online submissions for Prefix and Suffix Search.\\n# Memory Usage: 37.5 MB, less than 59.63% of Python3 online submissions for Prefix and Suffix Search.\\n\\tclass WordFilter:\\n\\n\\t\\tdef __init__(self, words: List[str]):\\n\\n\\t\\t\\tself.pair_suffix_prefix = {}\\n\\n\\t\\t\\tfor index in range(len(words)):\\n\\n\\t\\t\\t\\tfor j in range(len(words[index])):\\n\\n\\t\\t\\t\\t\\tnew_word1 = words[index][:j+1]\\n\\n\\t\\t\\t\\t\\tfor k in range(len(words[index])):\\n\\t\\t\\t\\t\\t\\tnew_word2 = new_word1+\\'.\\'+words[index][k:]\\n\\n\\t\\t\\t\\t\\t\\tself.pair_suffix_prefix[new_word2] = index\\n\\n\\n\\t\\tdef f(self, prefix: str, suffix: str) -> int:\\n\\n\\t\\t\\tsearch_word = prefix+\\'.\\'+suffix\\n\\n\\t\\t\\tif search_word in self.pair_suffix_prefix:\\n\\t\\t\\t\\treturn self.pair_suffix_prefix[search_word]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\n# Runtime: 2029 ms, faster than 47.10% of Python3 online submissions for Prefix and Suffix Search.\\n# Memory Usage: 37.5 MB, less than 59.63% of Python3 online submissions for Prefix and Suffix Search.\\n\\tclass WordFilter:\\n\\n\\t\\tdef __init__(self, words: List[str]):\\n\\n\\t\\t\\tself.pair_suffix_prefix = {}\\n\\n\\t\\t\\tfor index in range(len(words)):\\n\\n\\t\\t\\t\\tfor j in range(len(words[index])):\\n\\n\\t\\t\\t\\t\\tnew_word1 = words[index][:j+1]\\n\\n\\t\\t\\t\\t\\tfor k in range(len(words[index])):\\n\\t\\t\\t\\t\\t\\tnew_word2 = new_word1+\\'.\\'+words[index][k:]\\n\\n\\t\\t\\t\\t\\t\\tself.pair_suffix_prefix[new_word2] = index\\n\\n\\n\\t\\tdef f(self, prefix: str, suffix: str) -> int:\\n\\n\\t\\t\\tsearch_word = prefix+\\'.\\'+suffix\\n\\n\\t\\t\\tif search_word in self.pair_suffix_prefix:\\n\\t\\t\\t\\treturn self.pair_suffix_prefix[search_word]\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn -1",
                "codeTag": "Java"
            },
            {
                "id": 2165404,
                "title": "python-solution-using-dictionary",
                "content": "The basic idea behind the solution is to create all the possible prefix and suffix combinations for each of the words given. In this way, in our find function we only need to check if that particular (prefix,suffix) combination exists in our list of combinations. \\n\\nI have used python dictionary to store all the possible combinations.\\n\\n```\\nclass WordFilter:\\n    \\n    def __init__(self, words: List[str]):\\n        self.pre={}\\n        for n,word in enumerate(words):\\n            for j in range(len(word)-1,-1,-1):\\n                for k in range(len(word)):\\n                    letter=word[j:]+\"#\"+word[:k+1]\\n                    self.pre[letter]=n\\n                \\n    def f(self, prefix: str, suffix: str) -> int:\\n        ans=suffix+\"#\"+prefix\\n        if self.pre.get(ans) is not None:\\n            return self.pre[ans]\\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass WordFilter:\\n    \\n    def __init__(self, words: List[str]):\\n        self.pre={}\\n        for n,word in enumerate(words):\\n            for j in range(len(word)-1,-1,-1):\\n                for k in range(len(word)):\\n                    letter=word[j:]+\"#\"+word[:k+1]\\n                    self.pre[letter]=n\\n                \\n    def f(self, prefix: str, suffix: str) -> int:\\n        ans=suffix+\"#\"+prefix\\n        if self.pre.get(ans) is not None:\\n            return self.pre[ans]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165318,
                "title": "java-dp-solution-using-hashmap",
                "content": "***This problem is solved using dynamic programming implemented using HashMap.*** \\n* We created a class HashMap<List,Integer> to store the results.\\n* Each of the set of prefix and sufix is added in a list.\\n* As a standard dp way, before starting the operations we check if the solution already exists.\\n* We traverse words array from backwards and match prefix and suffix string with each string of the array.As soon as we encounter unequal values we break from the inner for loop.\\n* flag variable is keeping track of whether both suffix and prefix matches.\\n* If flag is true, we store result in map and return the ans.\\n* If we come to the end of the program, we store the value in the map and return -1.\\n\\n**Code**\\n```\\nclass WordFilter \\n{\\n    String[] word;\\n    Map<List<String>,Integer> map=new HashMap<>();\\n    \\n    public WordFilter(String[] words) \\n\\t{\\n        word=words;\\n\\t}\\n    \\n    public int f(String pre, String suff)\\n    {\\n        List<String> list=new ArrayList<>();\\n        list.add(pre);list.add(suff);\\n        \\n        //implemented dp\\n        if(map.containsKey(list))\\n            return map.get(list);\\n        \\n        int ans=-1;\\n        \\n        for(int i=word.length-1;i>=0;i--)\\n        {\\n            String str=word[i];\\n            boolean flag=true;\\n            \\n            //if prefix or suffix is longer than str\\n             if(pre.length()>str.length() || suff.length()>str.length())\\n                 continue;\\n        \\n            //to check prefix\\n            for(int j=0;j<pre.length();j++)\\n            {\\n                if(pre.charAt(j)!=str.charAt(j))\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n\\n            //to check suffix \\n            for(int j=suff.length()-1,k=str.length()-1;j>=0 && flag;)\\n            {\\n                if(suff.charAt(j--)!=str.charAt(k--))\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            \\n            \\n             if(flag)\\n             {\\n               map.put(list,i);\\n               return i;\\n             }\\n\\n        }\\n        map.put(list,ans);\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass WordFilter \\n{\\n    String[] word;\\n    Map<List<String>,Integer> map=new HashMap<>();\\n    \\n    public WordFilter(String[] words) \\n\\t{\\n        word=words;\\n\\t}\\n    \\n    public int f(String pre, String suff)\\n    {\\n        List<String> list=new ArrayList<>();\\n        list.add(pre);list.add(suff);\\n        \\n        //implemented dp\\n        if(map.containsKey(list))\\n            return map.get(list);\\n        \\n        int ans=-1;\\n        \\n        for(int i=word.length-1;i>=0;i--)\\n        {\\n            String str=word[i];\\n            boolean flag=true;\\n            \\n            //if prefix or suffix is longer than str\\n             if(pre.length()>str.length() || suff.length()>str.length())\\n                 continue;\\n        \\n            //to check prefix\\n            for(int j=0;j<pre.length();j++)\\n            {\\n                if(pre.charAt(j)!=str.charAt(j))\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n\\n            //to check suffix \\n            for(int j=suff.length()-1,k=str.length()-1;j>=0 && flag;)\\n            {\\n                if(suff.charAt(j--)!=str.charAt(k--))\\n                {\\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            \\n            \\n             if(flag)\\n             {\\n               map.put(list,i);\\n               return i;\\n             }\\n\\n        }\\n        map.put(list,ans);\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165290,
                "title": "simple-easy-dp-map-memoization-solution",
                "content": "Got here after thinking about many workarounds. Finally this worked. \\n\\nWhat I simply did is stored the answer for every possible {prefix,suffix} pair that can have a match in our dictionary. This makes my find function to give answer in O(1).       {:))\\n```\\nclass WordFilter {\\n    String[] dict;\\n    Map<String,Integer> dp;\\n\\n    public WordFilter(String[] words) {\\n        this.dict = words;\\n        this.dp = new HashMap<>();\\n      \\n        String pref, suf;\\n        for(int i=0;i<words.length;i++){            \\n            for(int j = 0;j<words[i].length()+1;j++){\\n                for(int k = words[i].length();k>-1;k--){ \\n                    \\n                    pref = words[i].substring(0,j);\\n                    suf = words[i].substring(k);\\n                    \\n                    this.dp.put(pref+\"/\"+suf,i);\\n                }\\n            }   \\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        if(this.dp.containsKey(prefix+\"/\"+suffix))\\n            return this.dp.get(prefix+\"/\"+suffix);\\n        return -1;\\n\\n    }\\n}\\n```\\n\\n\\nAnother faster version beating 91% solutions in space. \\n```\\nclass WordFilter {\\n    String[] dict;\\n    Map<String,Integer> dp;\\n\\n    public WordFilter(String[] words) {\\n        this.dict = words;\\n        this.dp = new HashMap<>();\\n      \\n        String pref, suf;\\n        for(int i=0;i<words.length;i++){            \\n            for(int j = 0;j<words[i].length()+1;j++){\\n                pref = words[i].substring(0,j);\\n                suf = \"\";\\n                this.dp.put(pref+\"/\"+suf,i);\\n                \\n                for(int k = words[i].length()-1;k>-1;k--){  \\n                    suf = words[i].charAt(k) + suf;                    \\n                    this.dp.put(pref+\"/\"+suf,i);\\n                }\\n            }   \\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        if(this.dp.containsKey(prefix+\"/\"+suffix))\\n            return this.dp.get(prefix+\"/\"+suffix);\\n        return -1;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass WordFilter {\\n    String[] dict;\\n    Map<String,Integer> dp;\\n\\n    public WordFilter(String[] words) {\\n        this.dict = words;\\n        this.dp = new HashMap<>();\\n      \\n        String pref, suf;\\n        for(int i=0;i<words.length;i++){            \\n            for(int j = 0;j<words[i].length()+1;j++){\\n                for(int k = words[i].length();k>-1;k--){ \\n                    \\n                    pref = words[i].substring(0,j);\\n                    suf = words[i].substring(k);\\n                    \\n                    this.dp.put(pref+\"/\"+suf,i);\\n                }\\n            }   \\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        if(this.dp.containsKey(prefix+\"/\"+suffix))\\n            return this.dp.get(prefix+\"/\"+suffix);\\n        return -1;\\n\\n    }\\n}\\n```\n```\\nclass WordFilter {\\n    String[] dict;\\n    Map<String,Integer> dp;\\n\\n    public WordFilter(String[] words) {\\n        this.dict = words;\\n        this.dp = new HashMap<>();\\n      \\n        String pref, suf;\\n        for(int i=0;i<words.length;i++){            \\n            for(int j = 0;j<words[i].length()+1;j++){\\n                pref = words[i].substring(0,j);\\n                suf = \"\";\\n                this.dp.put(pref+\"/\"+suf,i);\\n                \\n                for(int k = words[i].length()-1;k>-1;k--){  \\n                    suf = words[i].charAt(k) + suf;                    \\n                    this.dp.put(pref+\"/\"+suf,i);\\n                }\\n            }   \\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        if(this.dp.containsKey(prefix+\"/\"+suffix))\\n            return this.dp.get(prefix+\"/\"+suffix);\\n        return -1;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165037,
                "title": "trie-simple-and-easy-to-understand-w-video-explanation-prefix-and-suffix-search",
                "content": "```\\nclass WordFilter {\\n    Trie root;\\n    String[] words;\\n\\n    public WordFilter(String[] words) {\\n        this.words = words;\\n        root = new Trie();\\n        \\n        Trie node = root;\\n        \\n        for(int i=0;i<words.length;i++){\\n            for(char ch : words[i].toCharArray()){\\n                if(root.trieArr[ch - \\'a\\'] == null)\\n                    root.trieArr[ch - \\'a\\'] = new Trie();\\n                root.trieArr[ch-\\'a\\'].indexList.add(i);\\n                root = root.trieArr[ch-\\'a\\'];\\n            }\\n            root = node;\\n        }\\n        \\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Trie node = root;\\n        for(char c : prefix.toCharArray()){\\n            node = node.trieArr[c-\\'a\\'];\\n            if(node == null)\\n                return -1;\\n        }\\n        List<Integer> list= node.indexList;\\n        \\n        for(int i=list.size()-1;i>=0;i--){\\n            if(words[list.get(i)].endsWith(suffix)){\\n                return list.get(i);\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private static class Trie{\\n        Trie[] trieArr = new Trie[26];\\n        List<Integer> indexList = new ArrayList<>();\\n        \\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n\\n```\\n\\n\\n**Video Explanation :**\\n\\n[Prefix and Suffix Search | YouTube](https://www.youtube.com/watch?v=dT8zDehks14)\\n\\nPlease upvote if you find this helpful !",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n    Trie root;\\n    String[] words;\\n\\n    public WordFilter(String[] words) {\\n        this.words = words;\\n        root = new Trie();\\n        \\n        Trie node = root;\\n        \\n        for(int i=0;i<words.length;i++){\\n            for(char ch : words[i].toCharArray()){\\n                if(root.trieArr[ch - \\'a\\'] == null)\\n                    root.trieArr[ch - \\'a\\'] = new Trie();\\n                root.trieArr[ch-\\'a\\'].indexList.add(i);\\n                root = root.trieArr[ch-\\'a\\'];\\n            }\\n            root = node;\\n        }\\n        \\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Trie node = root;\\n        for(char c : prefix.toCharArray()){\\n            node = node.trieArr[c-\\'a\\'];\\n            if(node == null)\\n                return -1;\\n        }\\n        List<Integer> list= node.indexList;\\n        \\n        for(int i=list.size()-1;i>=0;i--){\\n            if(words[list.get(i)].endsWith(suffix)){\\n                return list.get(i);\\n            }\\n        }\\n        \\n        return -1;\\n        \\n    }\\n    \\n    private static class Trie{\\n        Trie[] trieArr = new Trie[26];\\n        List<Integer> indexList = new ArrayList<>();\\n        \\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164978,
                "title": "c-code-for-beginners-easy-trie-solution",
                "content": "We know tries are known for their ability to search prefixes and suffixes fastly from a dictionary. But the question here says, we need to find a word containing the prefix and the suffix. A simple solution which might come in mind is to make up two tries, one for prefix and one for suffix and also maintaing a set which will store the indexes of the words we found the prefix, and while searching for suffix, we will just check if the word we just found does, it have any index in set, so its a intersection aand we take that index, and keep updating if some larger index pops as our answer. But it is quite resource expensive, so why not mold the question to use the basic property of trie, i.e. just finding the prefix.\\n\\nLets consider the word apple, and we need to find prefix \"apple\" and \"pple\" as suffix, so what we do we create all the suffix combos and just add it with the whole word by just seperating it with a partition character, doing this will result in a word which will contain the suffix in the first half and the prefix in the second half.\\n\\nIf created all such combinations for apple will result in\\n\\na p p l e { a p p l e \\np p l e { a p p l e \\np l e { a p p l e \\nl e { a p p l e \\ne { a p p l e \\n{ a p p l e \\n\\nNow to find the prefix \"apple\" and \"pple\" we search for word, suffix+\"{\"+prefix, i,e, pple{apple, and we can see the word p p l e { a p p l e as our answer, .. now each node of trie here will carry the index of which word was it the part of so we can easily get the index of that word...\\n\\n\\n```\\nstruct TrieNode{\\n    struct TrieNode* children[27];\\n    int index=0;\\n    TrieNode(){\\n        for(int i=0;i<27;i++){\\n            children[i]=NULL;\\n        }\\n        index=0;\\n    }\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    WordFilter(vector<string>& words){\\n        root=new TrieNode();\\n        for(int index=0;index<words.size();index++){\\n            string word=words[index]+\"{\";\\n            for(int i=0;i<word.size();i++){\\n                TrieNode* cur=root;\\n                for(int j=i;j<2*word.size()-1;j++){ // 2*word.size()-1 because \"{\" not considered\\n                    cout<<word[j%word.length()]<<\" \";\\n                    int k=word[j%word.length()]-\\'a\\';\\n                    if(cur->children[k]==NULL){\\n                        cur->children[k]=new TrieNode();\\n                    }\\n                    cur=cur->children[k];\\n                    cur->index=index;\\n                }\\n            cout<<endl;\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix){\\n        TrieNode* cur=root;\\n        string newStr=suffix+\\'{\\'+prefix;\\n        for(char letter: newStr){\\n            if(cur->children[letter-\\'a\\']==NULL){\\n                return -1;\\n            } \\n            cur=cur->children[letter-\\'a\\'];\\n        }\\n        return cur->index;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct TrieNode{\\n    struct TrieNode* children[27];\\n    int index=0;\\n    TrieNode(){\\n        for(int i=0;i<27;i++){\\n            children[i]=NULL;\\n        }\\n        index=0;\\n    }\\n};\\n\\nclass WordFilter {\\nprivate:\\n    TrieNode* root;\\npublic:\\n    WordFilter(vector<string>& words){\\n        root=new TrieNode();\\n        for(int index=0;index<words.size();index++){\\n            string word=words[index]+\"{\";\\n            for(int i=0;i<word.size();i++){\\n                TrieNode* cur=root;\\n                for(int j=i;j<2*word.size()-1;j++){ // 2*word.size()-1 because \"{\" not considered\\n                    cout<<word[j%word.length()]<<\" \";\\n                    int k=word[j%word.length()]-\\'a\\';\\n                    if(cur->children[k]==NULL){\\n                        cur->children[k]=new TrieNode();\\n                    }\\n                    cur=cur->children[k];\\n                    cur->index=index;\\n                }\\n            cout<<endl;\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix){\\n        TrieNode* cur=root;\\n        string newStr=suffix+\\'{\\'+prefix;\\n        for(char letter: newStr){\\n            if(cur->children[letter-\\'a\\']==NULL){\\n                return -1;\\n            } \\n            cur=cur->children[letter-\\'a\\'];\\n        }\\n        return cur->index;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2164968,
                "title": "python-trie-solution",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.index = set()\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefix = TrieNode()\\n        self.suffix = TrieNode()\\n        \\n        for i, w in enumerate(words):\\n            suff = reversed(w)\\n            proot = self.prefix\\n            sroot = self.suffix\\n            \\n            for c in w:\\n                proot = proot.children[c]\\n                proot.index.add(i)\\n            \\n            for c in suff:\\n                sroot = sroot.children[c]\\n                sroot.index.add(i)\\n            \\n    @cache\\n    def f(self, prefix: str, suffix: str) -> int:\\n        proot = self.prefix\\n        sroot = self.suffix\\n        \\n        for c in prefix:\\n            if c in proot.children:\\n                proot = proot.children[c]\\n            else:\\n                return -1\\n        \\n        for c in reversed(suffix):\\n            if c in sroot.children:\\n                sroot = sroot.children[c]\\n            else:\\n                return -1\\n        \\n        ans = proot.index & sroot.index\\n        \\n        return max(ans)\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.index = set()\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefix = TrieNode()\\n        self.suffix = TrieNode()\\n        \\n        for i, w in enumerate(words):\\n            suff = reversed(w)\\n            proot = self.prefix\\n            sroot = self.suffix\\n            \\n            for c in w:\\n                proot = proot.children[c]\\n                proot.index.add(i)\\n            \\n            for c in suff:\\n                sroot = sroot.children[c]\\n                sroot.index.add(i)\\n            \\n    @cache\\n    def f(self, prefix: str, suffix: str) -> int:\\n        proot = self.prefix\\n        sroot = self.suffix\\n        \\n        for c in prefix:\\n            if c in proot.children:\\n                proot = proot.children[c]\\n            else:\\n                return -1\\n        \\n        for c in reversed(suffix):\\n            if c in sroot.children:\\n                sroot = sroot.children[c]\\n            else:\\n                return -1\\n        \\n        ans = proot.index & sroot.index\\n        \\n        return max(ans)\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164953,
                "title": "cpp-trie-code",
                "content": "```\\nclass node{\\npublic:\\n    bool ending;\\n    node* ptr[26];\\n    set<int> vis;\\n    \\n    node(int ind){\\n        ending = false;\\n        for(int i=0;i<26;i++) ptr[i] = NULL;\\n        vis.insert(ind);\\n    }\\n    \\n};\\n\\nclass WordFilter {\\npublic:\\n    \\n    node* topRoot = NULL;\\n    node* bottomRoot = NULL;\\n    \\n    void insertTree1(string&s, int ind){\\n        \\n        node* temp = topRoot;\\n        for(char c: s){\\n            if(temp == NULL){\\n                topRoot = new node(ind);\\n                topRoot->ptr[c - \\'a\\'] = new node(ind);\\n                temp = topRoot->ptr[c - \\'a\\'];\\n            }\\n            else{\\n                if(temp->ptr[c - \\'a\\'] == NULL){\\n                    temp->ptr[c - \\'a\\'] = new node(ind);\\n                }\\n                temp = temp->ptr[c - \\'a\\'];\\n                temp->vis.insert(ind);\\n            }\\n        }\\n        \\n        temp->ending = true;\\n        \\n    }\\n    \\n    void insertTree2(string s, int ind){\\n        \\n        reverse(s.begin(), s.end());\\n        \\n        node* temp = bottomRoot;\\n        for(char c: s){\\n            if(temp == NULL){\\n                bottomRoot = new node(ind);\\n                bottomRoot->ptr[c - \\'a\\'] = new node(ind);\\n                temp = bottomRoot->ptr[c - \\'a\\'];\\n            }\\n            else{\\n                if(temp->ptr[c - \\'a\\'] == NULL){\\n                    temp->ptr[c - \\'a\\'] = new node(ind);\\n                }\\n                temp = temp->ptr[c - \\'a\\'];\\n                temp->vis.insert(ind);\\n            }\\n        }\\n        \\n        temp->ending = true;\\n        \\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        \\n        for(int i=0;i<words.size();i++){\\n            insertTree1(words[i], i);\\n        }\\n        \\n        for(int i=words.size()-1;i>=0;i--){\\n            insertTree2(words[i], i);\\n        }\\n        \\n    }\\n    \\n    set<int>& find1(string&s){\\n        \\n        node* temp = topRoot;\\n        set<int> t;\\n        \\n        for(char c: s){\\n            if(temp->ptr[c - \\'a\\'] == NULL) return t;\\n            temp = temp->ptr[c - \\'a\\'];\\n        }\\n        \\n        return temp->vis;\\n    }\\n    \\n    \\n    set<int>& find2(string&s){\\n        \\n        node* temp = bottomRoot;\\n        set<int> t;\\n        \\n        for(char c: s){\\n            if(temp->ptr[c - \\'a\\'] == NULL) return t;\\n            temp = temp->ptr[c - \\'a\\'];\\n        }\\n        \\n        return temp->vis;\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        reverse(suffix.begin(), suffix.end());\\n        \\n        auto&it1 = find1(prefix);\\n        auto&it2 = find2(suffix);\\n        \\n        for (auto a = it1.rbegin(); a != it1.rend(); a++){\\n            if(it2.find(*a) != it2.end()) return *a;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass node{\\npublic:\\n    bool ending;\\n    node* ptr[26];\\n    set<int> vis;\\n    \\n    node(int ind){\\n        ending = false;\\n        for(int i=0;i<26;i++) ptr[i] = NULL;\\n        vis.insert(ind);\\n    }\\n    \\n};\\n\\nclass WordFilter {\\npublic:\\n    \\n    node* topRoot = NULL;\\n    node* bottomRoot = NULL;\\n    \\n    void insertTree1(string&s, int ind){\\n        \\n        node* temp = topRoot;\\n        for(char c: s){\\n            if(temp == NULL){\\n                topRoot = new node(ind);\\n                topRoot->ptr[c - \\'a\\'] = new node(ind);\\n                temp = topRoot->ptr[c - \\'a\\'];\\n            }\\n            else{\\n                if(temp->ptr[c - \\'a\\'] == NULL){\\n                    temp->ptr[c - \\'a\\'] = new node(ind);\\n                }\\n                temp = temp->ptr[c - \\'a\\'];\\n                temp->vis.insert(ind);\\n            }\\n        }\\n        \\n        temp->ending = true;\\n        \\n    }\\n    \\n    void insertTree2(string s, int ind){\\n        \\n        reverse(s.begin(), s.end());\\n        \\n        node* temp = bottomRoot;\\n        for(char c: s){\\n            if(temp == NULL){\\n                bottomRoot = new node(ind);\\n                bottomRoot->ptr[c - \\'a\\'] = new node(ind);\\n                temp = bottomRoot->ptr[c - \\'a\\'];\\n            }\\n            else{\\n                if(temp->ptr[c - \\'a\\'] == NULL){\\n                    temp->ptr[c - \\'a\\'] = new node(ind);\\n                }\\n                temp = temp->ptr[c - \\'a\\'];\\n                temp->vis.insert(ind);\\n            }\\n        }\\n        \\n        temp->ending = true;\\n        \\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        \\n        for(int i=0;i<words.size();i++){\\n            insertTree1(words[i], i);\\n        }\\n        \\n        for(int i=words.size()-1;i>=0;i--){\\n            insertTree2(words[i], i);\\n        }\\n        \\n    }\\n    \\n    set<int>& find1(string&s){\\n        \\n        node* temp = topRoot;\\n        set<int> t;\\n        \\n        for(char c: s){\\n            if(temp->ptr[c - \\'a\\'] == NULL) return t;\\n            temp = temp->ptr[c - \\'a\\'];\\n        }\\n        \\n        return temp->vis;\\n    }\\n    \\n    \\n    set<int>& find2(string&s){\\n        \\n        node* temp = bottomRoot;\\n        set<int> t;\\n        \\n        for(char c: s){\\n            if(temp->ptr[c - \\'a\\'] == NULL) return t;\\n            temp = temp->ptr[c - \\'a\\'];\\n        }\\n        \\n        return temp->vis;\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        reverse(suffix.begin(), suffix.end());\\n        \\n        auto&it1 = find1(prefix);\\n        auto&it2 = find2(suffix);\\n        \\n        for (auto a = it1.rbegin(); a != it1.rend(); a++){\\n            if(it2.find(*a) != it2.end()) return *a;\\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164908,
                "title": "java-faster-than-99-production-ready",
                "content": "```\\nclass WordFilter {\\n\\n    private Trie trie;\\n    \\n    public WordFilter(String[] words) {\\n        int n = words.length;\\n        trie = new Trie();\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// for word = abc, store in trie -> c#abc, bc#abc, abc#abc\\n            int len = words[i].length();\\n            StringBuilder curr = new StringBuilder(words[i]);\\n            curr.insert(0, \\'#\\');\\n            \\n            // append character from the end of the word to the start of curr one-by-one\\n            for(int j=len-1; j>=0; j--) {\\n                curr.insert(0, words[i].charAt(j));\\n                trie.insert(curr.toString(), i);\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String searchTerm = suffix + \\'#\\' + prefix;\\n        return trie.startsWith(searchTerm);\\n    }\\n}\\nclass TrieNode {\\n\\t// 26 for lowercase letters and 1 for # (stored at last index)\\n    private static final int N = 27;\\n    private TrieNode[] links;\\n    private int wordIndex;\\n    \\n    public TrieNode() {\\n        links = new TrieNode[N];\\n\\t\\t// at any time, it will store the index of the last word which has the current prefix\\n        wordIndex = -1;\\n    }\\n    \\n    private int charIndex(char c) {\\n        return c == \\'#\\' ? N-1 : c - \\'a\\';\\n    }\\n    \\n    public boolean containsKey(char c) {\\n        return links[charIndex(c)] != null;\\n    }\\n    \\n    public TrieNode get(char c) {\\n        return links[charIndex(c)];\\n    }\\n    \\n    public void put(char c, TrieNode node) {\\n        links[charIndex(c)] = node;\\n    }\\n    \\n    public void setWordIndex(int ind) {\\n        wordIndex = ind;\\n    }\\n    \\n    public int getWordIndex() {\\n        return wordIndex;\\n    }\\n}\\nclass Trie {\\n    private TrieNode root;\\n    \\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word, int ind) {\\n        int n = word.length();\\n        TrieNode curr = root;\\n        \\n        for(int i=0; i<n; i++) {\\n            char c = word.charAt(i);\\n            \\n            if( !curr.containsKey(c) ) \\n                curr.put(c, new TrieNode());\\n            \\n            curr = curr.get(c);\\n            curr.setWordIndex(ind);\\n        }\\n    }\\n    \\n    public int startsWith(String prefix) {\\n        int n = prefix.length();\\n        TrieNode curr = root;\\n        \\n        for(int i=0; i<n; i++) {\\n            char c = prefix.charAt(i);\\n            \\n            if( !curr.containsKey(c) ) \\n                return -1;\\n            \\n            curr = curr.get(c);\\n        }            \\n        return curr.getWordIndex();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordFilter {\\n\\n    private Trie trie;\\n    \\n    public WordFilter(String[] words) {\\n        int n = words.length;\\n        trie = new Trie();\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// for word = abc, store in trie -> c#abc, bc#abc, abc#abc\\n            int len = words[i].length();\\n            StringBuilder curr = new StringBuilder(words[i]);\\n            curr.insert(0, \\'#\\');\\n            \\n            // append character from the end of the word to the start of curr one-by-one\\n            for(int j=len-1; j>=0; j--) {\\n                curr.insert(0, words[i].charAt(j));\\n                trie.insert(curr.toString(), i);\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String searchTerm = suffix + \\'#\\' + prefix;\\n        return trie.startsWith(searchTerm);\\n    }\\n}\\nclass TrieNode {\\n\\t// 26 for lowercase letters and 1 for # (stored at last index)\\n    private static final int N = 27;\\n    private TrieNode[] links;\\n    private int wordIndex;\\n    \\n    public TrieNode() {\\n        links = new TrieNode[N];\\n\\t\\t// at any time, it will store the index of the last word which has the current prefix\\n        wordIndex = -1;\\n    }\\n    \\n    private int charIndex(char c) {\\n        return c == \\'#\\' ? N-1 : c - \\'a\\';\\n    }\\n    \\n    public boolean containsKey(char c) {\\n        return links[charIndex(c)] != null;\\n    }\\n    \\n    public TrieNode get(char c) {\\n        return links[charIndex(c)];\\n    }\\n    \\n    public void put(char c, TrieNode node) {\\n        links[charIndex(c)] = node;\\n    }\\n    \\n    public void setWordIndex(int ind) {\\n        wordIndex = ind;\\n    }\\n    \\n    public int getWordIndex() {\\n        return wordIndex;\\n    }\\n}\\nclass Trie {\\n    private TrieNode root;\\n    \\n    public Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word, int ind) {\\n        int n = word.length();\\n        TrieNode curr = root;\\n        \\n        for(int i=0; i<n; i++) {\\n            char c = word.charAt(i);\\n            \\n            if( !curr.containsKey(c) ) \\n                curr.put(c, new TrieNode());\\n            \\n            curr = curr.get(c);\\n            curr.setWordIndex(ind);\\n        }\\n    }\\n    \\n    public int startsWith(String prefix) {\\n        int n = prefix.length();\\n        TrieNode curr = root;\\n        \\n        for(int i=0; i<n; i++) {\\n            char c = prefix.charAt(i);\\n            \\n            if( !curr.containsKey(c) ) \\n                return -1;\\n            \\n            curr = curr.get(c);\\n        }            \\n        return curr.getWordIndex();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164808,
                "title": "prefix-and-suffix-search-java-trie",
                "content": "#### **Prefix and Suffix Search**\\n```\\nclass WordFilter {\\n    \\n    class Node {\\n        Node[] children;\\n        int pos;\\n        Node() {\\n            children = new Node[27];\\n            pos = -1;\\n        }\\n    }\\n    \\n    private Node root;\\n    \\n    private void insert(String word, int index, Node root, int pos) {\\n        if (index == word.length()) {\\n            return;\\n        }\\n        char c = word.charAt(index);\\n        if (root.children[c-\\'a\\'] == null) {\\n            root.children[c-\\'a\\'] = new Node();\\n        }\\n        root.children[c-\\'a\\'].pos = pos;\\n        insert(word, index+1, root.children[c-\\'a\\'], pos);\\n    }\\n    \\n    private int search(String word, int index, Node root) {\\n        if (word.length() == index) {\\n            return root.pos;\\n        }\\n        char c = word.charAt(index);\\n        if (root.children[c-\\'a\\'] == null) {\\n            return -1;\\n        } else {\\n            return search(word, index+1, root.children[c-\\'a\\']);   \\n        }\\n    }\\n\\n    public WordFilter(String[] words) {\\n        root = new Node();\\n        for(int i=0; i<words.length; i++) {\\n            for(int j=0; j<words[i].length(); j++) {\\n                insert(words[i].substring(j, words[i].length())+\"{\"+words[i], 0, root, i);\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return search(suffix+\"{\"+prefix, 0, root);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n    \\n    class Node {\\n        Node[] children;\\n        int pos;\\n        Node() {\\n            children = new Node[27];\\n            pos = -1;\\n        }\\n    }\\n    \\n    private Node root;\\n    \\n    private void insert(String word, int index, Node root, int pos) {\\n        if (index == word.length()) {\\n            return;\\n        }\\n        char c = word.charAt(index);\\n        if (root.children[c-\\'a\\'] == null) {\\n            root.children[c-\\'a\\'] = new Node();\\n        }\\n        root.children[c-\\'a\\'].pos = pos;\\n        insert(word, index+1, root.children[c-\\'a\\'], pos);\\n    }\\n    \\n    private int search(String word, int index, Node root) {\\n        if (word.length() == index) {\\n            return root.pos;\\n        }\\n        char c = word.charAt(index);\\n        if (root.children[c-\\'a\\'] == null) {\\n            return -1;\\n        } else {\\n            return search(word, index+1, root.children[c-\\'a\\']);   \\n        }\\n    }\\n\\n    public WordFilter(String[] words) {\\n        root = new Node();\\n        for(int i=0; i<words.length; i++) {\\n            for(int j=0; j<words[i].length(); j++) {\\n                insert(words[i].substring(j, words[i].length())+\"{\"+words[i], 0, root, i);\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        return search(suffix+\"{\"+prefix, 0, root);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164687,
                "title": "python-time-o-nm-2-concise-solution-dict",
                "content": "**Idea**\\nThanks to max length of word is equal to 10 and only lowercase characters, word can be converted into a 64-bit integer (At most 50 bits for 10 lowercase characters). The benefit of converting into integer is to prevent extra time complexity due to string manipulation.\\n\\nFor convertion, use `96` as base instead of `97`(\\'a\\') as bits `00000` represents empty.\\n\\nSimply use tuple of prefix and suffic as key of dict.\\n\\nTime complexity analysis:\\nN is length of words, M is length of words[i]\\nFor function `init`, O(NM^2)\\nFor function `f`, O(NM)\\n\\n```\\nclass WordFilter(object):\\n  def __init__(self, ws):\\n    self.m = {}\\n    for i,w in enumerate(ws):\\n      n,b,a = w2n(w),(1<<(len(w)*5))-1,range(0,len(w)*5,5)\\n      for p,s in itertools.product((n>>i for i in a),(n&(b>>i) for i in a)):\\n        self.m[p,s] = i\\n        \\n  def f(self, p, s):\\n    return self.m.get((w2n(p),w2n(s)),-1)\\n\\ndef w2n(w):\\n  return reduce(operator.xor, [(ord(c)-96)<<(i*5) for i,c in enumerate(w[::-1])])\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter(object):\\n  def __init__(self, ws):\\n    self.m = {}\\n    for i,w in enumerate(ws):\\n      n,b,a = w2n(w),(1<<(len(w)*5))-1,range(0,len(w)*5,5)\\n      for p,s in itertools.product((n>>i for i in a),(n&(b>>i) for i in a)):\\n        self.m[p,s] = i\\n        \\n  def f(self, p, s):\\n    return self.m.get((w2n(p),w2n(s)),-1)\\n\\ndef w2n(w):\\n  return reduce(operator.xor, [(ord(c)-96)<<(i*5) for i,c in enumerate(w[::-1])])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164449,
                "title": "easy-no-trie-hashmap-tc-o-n-l-l",
                "content": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> dict;\\n    \\n    WordFilter(vector<string>& words) {\\n        for(int i = 0;i < words.size();i++){\\n            string p;\\n            for(int j = 0;j < words[i].size();j++){\\n                p += words[i][j];\\n                string s ;\\n                 for(int k = words[i].size() - 1;k >=0;k--){\\n                     s = words[i][k] + s;\\n                     dict[p + \"|\" + s] = i + 1;//Why \"|\" is required here??\\n                     \\n                     //Suppose p = app and s = le then p + s = apple \\n                     //If a call is made for f(ap, ple) or f(appl, e) then for both function call its index dict[s + p]  will return same result\\n                     //that is totally wrong it is result of f(app, le).\\n                     // if add \"|\"  between p and s then p + s = app|le\\n                     //Now it\\'s index will be answer only when f(app, le) will be called\\n                     //if you call f(ap, ple) and f(appl, e) it will search ap|ple and  appl|e and will return its index\\n                 }\\n            }\\n        }\\n\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        return dict[prefix + \"|\" + suffix] - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\npublic:\\n    unordered_map<string, int> dict;\\n    \\n    WordFilter(vector<string>& words) {\\n        for(int i = 0;i < words.size();i++){\\n            string p;\\n            for(int j = 0;j < words[i].size();j++){\\n                p += words[i][j];\\n                string s ;\\n                 for(int k = words[i].size() - 1;k >=0;k--){\\n                     s = words[i][k] + s;\\n                     dict[p + \"|\" + s] = i + 1;//Why \"|\" is required here??\\n                     \\n                     //Suppose p = app and s = le then p + s = apple \\n                     //If a call is made for f(ap, ple) or f(appl, e) then for both function call its index dict[s + p]  will return same result\\n                     //that is totally wrong it is result of f(app, le).\\n                     // if add \"|\"  between p and s then p + s = app|le\\n                     //Now it\\'s index will be answer only when f(app, le) will be called\\n                     //if you call f(ap, ple) and f(appl, e) it will search ap|ple and  appl|e and will return its index\\n                 }\\n            }\\n        }\\n\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        return dict[prefix + \"|\" + suffix] - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164416,
                "title": "clean-and-concise-code-trie-c",
                "content": "```\\nstruct Node{\\n    Node* link[26];\\n    vector<int> idx;\\n};\\nclass WordFilter {\\nprivate:\\n    Node* root;\\n    unordered_map<string,int> mp;\\n    vector<string> words;\\n    \\n    void insert_in_trie(string &str,Node* root){\\n        for(auto &it : str){\\n            if(!root->link[it - \\'a\\']){\\n                root->link[it - \\'a\\'] = new Node();\\n            }\\n            root = root->link[it - \\'a\\'];\\n            root->idx.push_back(mp[str]);\\n        }\\n    }\\npublic:\\n    WordFilter(vector<string>& words) {\\n        this->words = words;\\n        root = new Node();\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]] = i; // storing last index of string\\n        }\\n        unordered_set<string> st;\\n        for(auto &it : words){\\n            if(st.count(it)) continue;\\n            st.insert(it); // inserting in set so we don\\'t waste time by inserting duplicate string\\n            insert_in_trie(it,root);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        Node* curr = root;\\n        for(auto &it : prefix){\\n            if(!curr->link[it - \\'a\\']) return -1; // if prefix is not present, there is no point of suffix\\n            curr = curr->link[it - \\'a\\'];\\n        }\\n        int ans = -1;\\n        auto &vec = curr->idx; // taking vector where our suffix might be present\\n        for(auto &it : vec){\\n            int len = words[it].size();\\n            if(words[it].substr(len - suffix.size()) == suffix) ans = it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nstruct Node{\\n    Node* link[26];\\n    vector<int> idx;\\n};\\nclass WordFilter {\\nprivate:\\n    Node* root;\\n    unordered_map<string,int> mp;\\n    vector<string> words;\\n    \\n    void insert_in_trie(string &str,Node* root){\\n        for(auto &it : str){\\n            if(!root->link[it - \\'a\\']){\\n                root->link[it - \\'a\\'] = new Node();\\n            }\\n            root = root->link[it - \\'a\\'];\\n            root->idx.push_back(mp[str]);\\n        }\\n    }\\npublic:\\n    WordFilter(vector<string>& words) {\\n        this->words = words;\\n        root = new Node();\\n        for(int i=0;i<words.size();i++){\\n            mp[words[i]] = i; // storing last index of string\\n        }\\n        unordered_set<string> st;\\n        for(auto &it : words){\\n            if(st.count(it)) continue;\\n            st.insert(it); // inserting in set so we don\\'t waste time by inserting duplicate string\\n            insert_in_trie(it,root);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        Node* curr = root;\\n        for(auto &it : prefix){\\n            if(!curr->link[it - \\'a\\']) return -1; // if prefix is not present, there is no point of suffix\\n            curr = curr->link[it - \\'a\\'];\\n        }\\n        int ans = -1;\\n        auto &vec = curr->idx; // taking vector where our suffix might be present\\n        for(auto &it : vec){\\n            int len = words[it].size();\\n            if(words[it].substr(len - suffix.size()) == suffix) ans = it;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164408,
                "title": "python-double-trie-with-memoization",
                "content": "We define a `Trie` class with `insert` and `startsWith` methods. When we insert words in the trie, we leave trace of the index of `word` in `words` in all layers of the Trie. `startsWith(prefix)` returns a set of all indexes of words that start with `prefix`.\\n\\nWe wet up a trie reading the words forwards (to look for prefixes), and second trie reading the words backwards (to look for suffixes).\\n\\nWe save previous search results to avoid TLE.\\n\\n* Shoutout to <a href=\"https://leetcode.com/laobaaoligei/\">@laobaaoligei</a> for the idea of removing repeated words from `words` (check their solution <a href=\"https://leetcode.com/problems/prefix-and-suffix-search/discuss/2164179/Easy-to-understand-Trie-memory-efficient-solution-in-Python-that-beats-86\">here</a>). \\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.words = set()\\n\\nclass Trie:\\n    def __init__(self):\\n        self.trie = TrieNode()\\n\\n    def insert(self, i: int, word: str) -> None:\\n        currentLayer = self.trie\\n        for char in word:\\n            currentLayer = currentLayer.children[char]\\n            currentLayer.words.add(i)\\n\\n    def startsWith(self, prefix: str) -> set:\\n        currentLayer = self.trie\\n        for char in prefix:\\n            currentLayer = currentLayer.children[char]\\n            if currentLayer.words is None:\\n                return set()\\n        return currentLayer.words\\n\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.forwardTrie, self.backwardsTrie = Trie(), Trie()\\n        filteredWords, self.searchResults = {}, {}\\n        \\n        for i, word in enumerate(words):\\n            filteredWords[word] = i\\n        \\n        for word, i in filteredWords.items():\\n            self.forwardTrie.insert(i, word)\\n            self.backwardsTrie.insert(i, reversed(word))\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        if prefix + \"-\" + suffix not in self.searchResults.keys():\\n            prefixSearch = self.forwardTrie.startsWith(prefix)\\n            suffixSearch = self.backwardsTrie.startsWith(reversed(suffix))\\n            searchResults = prefixSearch.intersection(suffixSearch)\\n            self.searchResults[prefix + \"-\" + suffix] = max(searchResults) if searchResults else -1\\n            \\n        return self.searchResults[prefix + \"-\" + suffix]\\n```",
                "solutionTags": [
                    "Python",
                    "Trie",
                    "Memoization"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = defaultdict(TrieNode)\\n        self.words = set()\\n\\nclass Trie:\\n    def __init__(self):\\n        self.trie = TrieNode()\\n\\n    def insert(self, i: int, word: str) -> None:\\n        currentLayer = self.trie\\n        for char in word:\\n            currentLayer = currentLayer.children[char]\\n            currentLayer.words.add(i)\\n\\n    def startsWith(self, prefix: str) -> set:\\n        currentLayer = self.trie\\n        for char in prefix:\\n            currentLayer = currentLayer.children[char]\\n            if currentLayer.words is None:\\n                return set()\\n        return currentLayer.words\\n\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.forwardTrie, self.backwardsTrie = Trie(), Trie()\\n        filteredWords, self.searchResults = {}, {}\\n        \\n        for i, word in enumerate(words):\\n            filteredWords[word] = i\\n        \\n        for word, i in filteredWords.items():\\n            self.forwardTrie.insert(i, word)\\n            self.backwardsTrie.insert(i, reversed(word))\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        if prefix + \"-\" + suffix not in self.searchResults.keys():\\n            prefixSearch = self.forwardTrie.startsWith(prefix)\\n            suffixSearch = self.backwardsTrie.startsWith(reversed(suffix))\\n            searchResults = prefixSearch.intersection(suffixSearch)\\n            self.searchResults[prefix + \"-\" + suffix] = max(searchResults) if searchResults else -1\\n            \\n        return self.searchResults[prefix + \"-\" + suffix]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164335,
                "title": "java-easy-solution",
                "content": "**Approach 1** -> Get TLE\\n```\\nclass WordFilter {\\n    String[] str;\\n    public WordFilter(String[] words) {\\n        str = words; //take o(1) time\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        for(int i = str.length-1; i >= 0; i--){\\n            if(str[i].startsWith(prefix) && str[i].endsWith(suffix))\\n                return i; //take O(N + len)\\n        }\\n        return -1;\\n    }\\n}\\n```\\n**Approach 2** -> By using HashMap; <prefix/suffix, index>\\nEx- <a#e, 0>, <ap#e, 0> <ap#le, 0>, <app#e, 0>....\\n\\n```\\nclass WordFilter {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    public WordFilter(String[] words) {\\n        for(int i=0;i<words.length;i++){\\n            search(words[i],i);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(prefix);\\n        sb.append(\\'#\\');\\n        sb.append(suffix);\\n        return map.getOrDefault(sb.toString(),-1);\\n    }\\n    public void search(String w,int idx){\\n        \\n         for (int i = 0; i < w.length (); i++) {\\n                String s = w.substring (0, i + 1);\\n                for (int j = w.length () - 1; j >= 0; j--) {\\n                    StringBuilder str = new StringBuilder ();\\n                    str.append (s);\\n                    str.append (\"#\");\\n                    str.append (w.substring (j));\\n                    map.put(str.toString (), idx);\\n                }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass WordFilter {\\n    String[] str;\\n    public WordFilter(String[] words) {\\n        str = words; //take o(1) time\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        for(int i = str.length-1; i >= 0; i--){\\n            if(str[i].startsWith(prefix) && str[i].endsWith(suffix))\\n                return i; //take O(N + len)\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass WordFilter {\\n    HashMap<String, Integer> map = new HashMap<>();\\n    public WordFilter(String[] words) {\\n        for(int i=0;i<words.length;i++){\\n            search(words[i],i);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(prefix);\\n        sb.append(\\'#\\');\\n        sb.append(suffix);\\n        return map.getOrDefault(sb.toString(),-1);\\n    }\\n    public void search(String w,int idx){\\n        \\n         for (int i = 0; i < w.length (); i++) {\\n                String s = w.substring (0, i + 1);\\n                for (int j = w.length () - 1; j >= 0; j--) {\\n                    StringBuilder str = new StringBuilder ();\\n                    str.append (s);\\n                    str.append (\"#\");\\n                    str.append (w.substring (j));\\n                    map.put(str.toString (), idx);\\n                }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164293,
                "title": "java-easy-to-understand",
                "content": "```\\nclass WordFilter \\n{\\n    //Each Node will consist of 27 nodes of its own type\\n    //26 nodes for a-z and 27th node for {\\n    //\\'{\\' is used as it has ascii = \\'z\\'+1\\n    \\n    class TrieNode\\n    {\\n        TrieNode links[]=new TrieNode[27];\\n        \\n        //idx stores index of last word in dictonary that visited the curr node\\n        //as we want largest index o word having a particular prefix and suffix we only store index of last word                   visiting the node\\n        \\n        int idx;\\n    }\\n    \\n    class Trie\\n    {\\n        //dummy root\\n        TrieNode root;\\n    \\n        Trie()\\n        {\\n            root=new TrieNode();\\n        }\\n        \\n        //normal insertion in try. We dont change root hence take a temp variable \\'node\\'\\n        void insert(String word,int id)\\n        {\\n            TrieNode node=root;\\n            \\n            for(char ch:word.toCharArray())\\n            {\\n                if(node.links[ch-\\'a\\']==null)\\n                node.links[ch-\\'a\\']=new TrieNode();\\n                \\n                node=node.links[ch-\\'a\\'];\\n                node.idx=id;\\n            }\\n        }\\n        \\n        //normal search in trie. If he word to be searched is found return idx of the last node else return -1;\\n        int index(String word)\\n        {\\n            TrieNode node=root;\\n            for(char ch:word.toCharArray())\\n            {\\n                if(node.links[ch-\\'a\\']==null)\\n                return -1;\\n                \\n                node=node.links[ch-\\'a\\'];\\n            }\\n            return node.idx;\\n        }\\n    }\\n    \\n    //dictionary\\n    Trie trie=new Trie();\\n    \\n    \\n    //we need to see if suffix and prefix are present in any word of dictionary or not\\n    //to bring prefix and suffix together:\\n    //Asumme word to be apple and run a reverse loop\\n    //s1=e{apple->we can find all combinations of prefixes if suffix is \\'e\\'\\n    //s2=el{apple--> possibilities of (suffix,prefix) : (el,a) (el,ap) (el,app) (el,appl) and so on\\n    // and so on\\n    \\n    public WordFilter(String[] words) \\n    {\\n        int idx=0;\\n        for(String w:words)\\n        {\\n            String st=\"\";\\n            for(int i=w.length()-1;i>=0;i--)\\n            {\\n                st=w.charAt(i)+st;\\n                String inp=st+\"{\"+w;\\n                trie.insert(inp,idx);\\n            }\\n            \\n            idx++;\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) \\n    {\\n        String st=suffix+\"{\"+prefix;\\n        return trie.index(st);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter \\n{\\n    //Each Node will consist of 27 nodes of its own type\\n    //26 nodes for a-z and 27th node for {\\n    //\\'{\\' is used as it has ascii = \\'z\\'+1\\n    \\n    class TrieNode\\n    {\\n        TrieNode links[]=new TrieNode[27];\\n        \\n        //idx stores index of last word in dictonary that visited the curr node\\n        //as we want largest index o word having a particular prefix and suffix we only store index of last word                   visiting the node\\n        \\n        int idx;\\n    }\\n    \\n    class Trie\\n    {\\n        //dummy root\\n        TrieNode root;\\n    \\n        Trie()\\n        {\\n            root=new TrieNode();\\n        }\\n        \\n        //normal insertion in try. We dont change root hence take a temp variable \\'node\\'\\n        void insert(String word,int id)\\n        {\\n            TrieNode node=root;\\n            \\n            for(char ch:word.toCharArray())\\n            {\\n                if(node.links[ch-\\'a\\']==null)\\n                node.links[ch-\\'a\\']=new TrieNode();\\n                \\n                node=node.links[ch-\\'a\\'];\\n                node.idx=id;\\n            }\\n        }\\n        \\n        //normal search in trie. If he word to be searched is found return idx of the last node else return -1;\\n        int index(String word)\\n        {\\n            TrieNode node=root;\\n            for(char ch:word.toCharArray())\\n            {\\n                if(node.links[ch-\\'a\\']==null)\\n                return -1;\\n                \\n                node=node.links[ch-\\'a\\'];\\n            }\\n            return node.idx;\\n        }\\n    }\\n    \\n    //dictionary\\n    Trie trie=new Trie();\\n    \\n    \\n    //we need to see if suffix and prefix are present in any word of dictionary or not\\n    //to bring prefix and suffix together:\\n    //Asumme word to be apple and run a reverse loop\\n    //s1=e{apple->we can find all combinations of prefixes if suffix is \\'e\\'\\n    //s2=el{apple--> possibilities of (suffix,prefix) : (el,a) (el,ap) (el,app) (el,appl) and so on\\n    // and so on\\n    \\n    public WordFilter(String[] words) \\n    {\\n        int idx=0;\\n        for(String w:words)\\n        {\\n            String st=\"\";\\n            for(int i=w.length()-1;i>=0;i--)\\n            {\\n                st=w.charAt(i)+st;\\n                String inp=st+\"{\"+w;\\n                trie.insert(inp,idx);\\n            }\\n            \\n            idx++;\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) \\n    {\\n        String st=suffix+\"{\"+prefix;\\n        return trie.index(st);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824626,
                "title": "see-a-bug-implementing-trie-node-class",
                "content": "I was attempting the naive approach and just curious why this isn\\'t working. I suspect a bug I\\'m missing somewhere?\\n\\n```\\n[\"WordFilter\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\"]\\n[[[\"cabaabaaaa\",\"ccbcababac\",\"bacaabccba\",\"bcbbcbacaa\",\"abcaccbcaa\",\"accabaccaa\",\"cabcbbbcca\",\"ababccabcb\",\"caccbbcbab\",\"bccbacbcba\"]],[\"bccbacbcba\",\"a\"],[\"ab\",\"abcaccbcaa\"],[\"a\",\"aa\"],[\"cabaaba\",\"abaaaa\"],[\"cacc\",\"accbbcbab\"],[\"ccbcab\",\"bac\"],[\"bac\",\"cba\"],[\"ac\",\"accabaccaa\"],[\"bcbb\",\"aa\"],[\"ccbca\",\"cbcababac\"]]\\nOutput: [null,9,-1,5,-1,-1,-1,-1,-1,3,-1]\\nExpected: [null,9,4,5,0,8,1,2,5,3,1]\\n\\n```\\n\\n\\n```python\\nfrom dataclasses import dataclass, field\\nfrom typing import List\\n\\n\\n@dataclass\\nclass TrieNode:\\n    \"\"\"Represents a character \"node\" with associated word indexes\\n    and the next available characters via a dict.\\n    \"\"\"\\n\\n    idxs: set = field(default_factory=set)\\n    next: dict = field(default_factory=dict)\\n\\n    def add_ch_idx(self, char, idx):\\n        self.idxs.add(idx)\\n\\n        if char in self.next:\\n            return self.next[char]\\n\\n        else:\\n            tn = TrieNode()\\n            tn.idxs.add(idx) # adds idx to \"leaf\" nodes\\n            self.next[char] = tn\\n            return tn\\n\\n    def __getitem__(self, ch):\\n        if ch in self.next:\\n            return self.next[ch]\\n        else:\\n            return False\\n\\n\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.G_prefix = TrieNode()\\n        self.G_suffix = TrieNode()\\n        self.word_idxs = {}  # word to index\\n\\n        idx = 0\\n        for word in words:\\n            if word not in self.word_idxs:\\n                self.word_idxs[word] = idx\\n                self.process_word(self.G_prefix, word, idx)\\n                self.process_word(self.G_suffix, reversed(word), idx)\\n            idx += 1\\n\\n    def process_word(self, tn, word, idx):\\n        node = tn\\n        for c in word:\\n            node = node.add_ch_idx(c, idx)\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        node = self.G_prefix\\n        for c in prefix:\\n            if c in node.next:\\n                node = node[c]\\n            else:\\n                return -1\\n\\n        node2 = self.G_suffix\\n        for c in suffix:\\n            if c in node2.next:\\n                node2 = node2[c]\\n            else:\\n                return -1\\n\\n        return max(node.idxs & node2.idxs)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n[\"WordFilter\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\",\"f\"]\\n[[[\"cabaabaaaa\",\"ccbcababac\",\"bacaabccba\",\"bcbbcbacaa\",\"abcaccbcaa\",\"accabaccaa\",\"cabcbbbcca\",\"ababccabcb\",\"caccbbcbab\",\"bccbacbcba\"]],[\"bccbacbcba\",\"a\"],[\"ab\",\"abcaccbcaa\"],[\"a\",\"aa\"],[\"cabaaba\",\"abaaaa\"],[\"cacc\",\"accbbcbab\"],[\"ccbcab\",\"bac\"],[\"bac\",\"cba\"],[\"ac\",\"accabaccaa\"],[\"bcbb\",\"aa\"],[\"ccbca\",\"cbcababac\"]]\\nOutput: [null,9,-1,5,-1,-1,-1,-1,-1,3,-1]\\nExpected: [null,9,4,5,0,8,1,2,5,3,1]\\n\\n```\n```python\\nfrom dataclasses import dataclass, field\\nfrom typing import List\\n\\n\\n@dataclass\\nclass TrieNode:\\n    \"\"\"Represents a character \"node\" with associated word indexes\\n    and the next available characters via a dict.\\n    \"\"\"\\n\\n    idxs: set = field(default_factory=set)\\n    next: dict = field(default_factory=dict)\\n\\n    def add_ch_idx(self, char, idx):\\n        self.idxs.add(idx)\\n\\n        if char in self.next:\\n            return self.next[char]\\n\\n        else:\\n            tn = TrieNode()\\n            tn.idxs.add(idx) # adds idx to \"leaf\" nodes\\n            self.next[char] = tn\\n            return tn\\n\\n    def __getitem__(self, ch):\\n        if ch in self.next:\\n            return self.next[ch]\\n        else:\\n            return False\\n\\n\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.G_prefix = TrieNode()\\n        self.G_suffix = TrieNode()\\n        self.word_idxs = {}  # word to index\\n\\n        idx = 0\\n        for word in words:\\n            if word not in self.word_idxs:\\n                self.word_idxs[word] = idx\\n                self.process_word(self.G_prefix, word, idx)\\n                self.process_word(self.G_suffix, reversed(word), idx)\\n            idx += 1\\n\\n    def process_word(self, tn, word, idx):\\n        node = tn\\n        for c in word:\\n            node = node.add_ch_idx(c, idx)\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        node = self.G_prefix\\n        for c in prefix:\\n            if c in node.next:\\n                node = node[c]\\n            else:\\n                return -1\\n\\n        node2 = self.G_suffix\\n        for c in suffix:\\n            if c in node2.next:\\n                node2 = node2[c]\\n            else:\\n                return -1\\n\\n        return max(node.idxs & node2.idxs)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805117,
                "title": "c-clean-code",
                "content": "```\\n\\nclass Trie{\\n    public:\\n    Trie * child[27];\\n    int index = -1;\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie * trie, *child;\\n    void insertTrie(string word, int pos){\\n        int index;\\n        Trie * obj  = trie;\\n        for(char ch: word){\\n            index  = ch - \\'a\\';\\n            auto it = obj->child[index];\\n            if(it==NULL){\\n                child = new Trie();\\n                obj->child[index] = child;\\n            }\\n            obj = obj->child[index];\\n            obj->index = pos;\\n        }\\n    }\\n    \\n    int searchTrie(string word) {\\n        int index;\\n        Trie * obj  = trie;\\n        for(char ch: word){\\n            index  = ch - \\'a\\';\\n            if(obj->child[index]==NULL) return -1;\\n            obj = obj->child[index];\\n        }\\n        \\n        return obj->index;\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        trie = new Trie();\\n        for(int i=0;i<n;i++){\\n            for(int j=0; j<words[i].length();j++){\\n                string str = words[i].substr(j) + \"{\" + words[i];\\n                insertTrie(str,i);        \\n            }    \\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        return searchTrie(suffix + \"{\" + prefix);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Trie{\\n    public:\\n    Trie * child[27];\\n    int index = -1;\\n};\\n\\nclass WordFilter {\\npublic:\\n    Trie * trie, *child;\\n    void insertTrie(string word, int pos){\\n        int index;\\n        Trie * obj  = trie;\\n        for(char ch: word){\\n            index  = ch - \\'a\\';\\n            auto it = obj->child[index];\\n            if(it==NULL){\\n                child = new Trie();\\n                obj->child[index] = child;\\n            }\\n            obj = obj->child[index];\\n            obj->index = pos;\\n        }\\n    }\\n    \\n    int searchTrie(string word) {\\n        int index;\\n        Trie * obj  = trie;\\n        for(char ch: word){\\n            index  = ch - \\'a\\';\\n            if(obj->child[index]==NULL) return -1;\\n            obj = obj->child[index];\\n        }\\n        \\n        return obj->index;\\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        int n = words.size();\\n        trie = new Trie();\\n        for(int i=0;i<n;i++){\\n            for(int j=0; j<words[i].length();j++){\\n                string str = words[i].substr(j) + \"{\" + words[i];\\n                insertTrie(str,i);        \\n            }    \\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        return searchTrie(suffix + \"{\" + prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1797416,
                "title": "golang-map-solution",
                "content": "```go\\ntype WordFilter struct {\\n\\thash map[string]int\\n}\\n\\nfunc Constructor(words []string) WordFilter {\\n\\thash := make(map[string]int, len(words)*100)\\n\\tfor i, word := range words {\\n\\t\\tfor l := 1; l <= 10 && l <= len(word); l++ {\\n\\t\\t\\tfor r := 1; r <= 10 && r <= len(word); r++ {\\n\\t\\t\\t\\thash[word[:l]+\":\"+word[len(word)-r:]] = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn WordFilter{\\n\\t\\thash: hash,\\n\\t}\\n}\\n\\nfunc (wf *WordFilter) F(prefix string, suffix string) int {\\n\\tif v, exists := wf.hash[prefix+\":\"+suffix]; exists {\\n\\t\\treturn v\\n\\t}\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype WordFilter struct {\\n\\thash map[string]int\\n}\\n\\nfunc Constructor(words []string) WordFilter {\\n\\thash := make(map[string]int, len(words)*100)\\n\\tfor i, word := range words {\\n\\t\\tfor l := 1; l <= 10 && l <= len(word); l++ {\\n\\t\\t\\tfor r := 1; r <= 10 && r <= len(word); r++ {\\n\\t\\t\\t\\thash[word[:l]+\":\"+word[len(word)-r:]] = i\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn WordFilter{\\n\\t\\thash: hash,\\n\\t}\\n}\\n\\nfunc (wf *WordFilter) F(prefix string, suffix string) int {\\n\\tif v, exists := wf.hash[prefix+\":\"+suffix]; exists {\\n\\t\\treturn v\\n\\t}\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756659,
                "title": "c-modified-trie-first-match-prefix-in-trie-and-then-match-suffix",
                "content": "```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> charMap;\\n    bool isLeaf;\\n    int index;\\n    TrieNode(){\\n        isLeaf = false;\\n        index = 0;\\n    }\\n\\t\\n\\t~TrieNode(){\\n        for(auto& itr :charMap){\\n            delete itr.second;\\n        }\\n    }\\n};\\n\\n//utility class to perform trie operations\\nclass Trie{\\nprivate:\\n    TrieNode* root;\\n    \\n    void insert(string& word, int i){\\n        TrieNode* traveler =root;\\n        for(auto& c : word){\\n            if(traveler->charMap.find(c) == traveler->charMap.end()){\\n                traveler->charMap[c] = new TrieNode();\\n            }\\n            traveler = traveler->charMap[c];\\n        }\\n        traveler->isLeaf= true;\\n        traveler->index= i;\\n    }\\n    \\n    void collectAllWords(TrieNode* currentRoot, string& prefix, int& largest, string& suffix){\\n         TrieNode* traveler = currentRoot;\\n         if(!currentRoot){\\n             return;\\n         }\\n        \\n        if(currentRoot->isLeaf){\\n            if(matchSuffix(prefix, suffix)){\\n                largest = max(currentRoot->index, largest);\\n            }\\n        }\\n        \\n        for(auto& itr : currentRoot->charMap){\\n            prefix += itr.first;\\n            collectAllWords(itr.second, prefix, largest, suffix);\\n            prefix.pop_back();\\n        }\\n    }\\n    \\n    bool matchSuffix(string& word, string& suffix){\\n        int i = word.size()-1;\\n        int j = suffix.size()-1;\\n        //cout << a << \" \" << b << endl;\\n        while(i >= 0 && j >= 0 && word[i] == suffix[j]){\\n            i--;\\n            j--;\\n        }\\n        \\n        return j == -1;\\n    }\\n    \\npublic:\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    ~Trie(){\\n        delete root;\\n    }\\n    \\n    void buildTrie(vector<string>& words){\\n        for(int i = 0; i < words.size(); i++){\\n            insert(words[i], i);\\n        }\\n    }\\n    \\n    int getWordIndex(string& prefix, string& suffix){\\n        TrieNode* traveler = root;\\n        //match prefix and traverse till node\\n        for(auto& c : prefix){\\n            if(traveler->charMap.find(c) == traveler->charMap.end()){\\n                return -1;\\n            }\\n            traveler = traveler->charMap[c];\\n        }\\n        \\n        string pre = prefix;\\n        //keep track of word index when suffix matches\\n        int largest = -1;\\n        \\n        //recurse and check if any of the descendants have this suffix\\n        collectAllWords(traveler, pre, largest, suffix);\\n        return largest;\\n    }\\n    \\n};\\n\\nclass WordFilter {\\n    Trie mTrie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        mTrie.buildTrie(words);\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        int index = mTrie.getWordIndex(prefix, suffix);\\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> charMap;\\n    bool isLeaf;\\n    int index;\\n    TrieNode(){\\n        isLeaf = false;\\n        index = 0;\\n    }\\n\\t\\n\\t~TrieNode(){\\n        for(auto& itr :charMap){\\n            delete itr.second;\\n        }\\n    }\\n};\\n\\n//utility class to perform trie operations\\nclass Trie{\\nprivate:\\n    TrieNode* root;\\n    \\n    void insert(string& word, int i){\\n        TrieNode* traveler =root;\\n        for(auto& c : word){\\n            if(traveler->charMap.find(c) == traveler->charMap.end()){\\n                traveler->charMap[c] = new TrieNode();\\n            }\\n            traveler = traveler->charMap[c];\\n        }\\n        traveler->isLeaf= true;\\n        traveler->index= i;\\n    }\\n    \\n    void collectAllWords(TrieNode* currentRoot, string& prefix, int& largest, string& suffix){\\n         TrieNode* traveler = currentRoot;\\n         if(!currentRoot){\\n             return;\\n         }\\n        \\n        if(currentRoot->isLeaf){\\n            if(matchSuffix(prefix, suffix)){\\n                largest = max(currentRoot->index, largest);\\n            }\\n        }\\n        \\n        for(auto& itr : currentRoot->charMap){\\n            prefix += itr.first;\\n            collectAllWords(itr.second, prefix, largest, suffix);\\n            prefix.pop_back();\\n        }\\n    }\\n    \\n    bool matchSuffix(string& word, string& suffix){\\n        int i = word.size()-1;\\n        int j = suffix.size()-1;\\n        //cout << a << \" \" << b << endl;\\n        while(i >= 0 && j >= 0 && word[i] == suffix[j]){\\n            i--;\\n            j--;\\n        }\\n        \\n        return j == -1;\\n    }\\n    \\npublic:\\n    Trie(){\\n        root = new TrieNode();\\n    }\\n    \\n    ~Trie(){\\n        delete root;\\n    }\\n    \\n    void buildTrie(vector<string>& words){\\n        for(int i = 0; i < words.size(); i++){\\n            insert(words[i], i);\\n        }\\n    }\\n    \\n    int getWordIndex(string& prefix, string& suffix){\\n        TrieNode* traveler = root;\\n        //match prefix and traverse till node\\n        for(auto& c : prefix){\\n            if(traveler->charMap.find(c) == traveler->charMap.end()){\\n                return -1;\\n            }\\n            traveler = traveler->charMap[c];\\n        }\\n        \\n        string pre = prefix;\\n        //keep track of word index when suffix matches\\n        int largest = -1;\\n        \\n        //recurse and check if any of the descendants have this suffix\\n        collectAllWords(traveler, pre, largest, suffix);\\n        return largest;\\n    }\\n    \\n};\\n\\nclass WordFilter {\\n    Trie mTrie;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        mTrie.buildTrie(words);\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        int index = mTrie.getWordIndex(prefix, suffix);\\n        return index;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1751361,
                "title": "more-readable-version-of-official-solution-java",
                "content": "```\\nclass WordFilter {\\n    \\n    private static final char DELIMITER = \\'a\\' + 26; //{\\n    \\n    private final TrieNode root;\\n\\n    public WordFilter(String[] words) {\\n        this.root = new TrieNode();\\n        for(int weight = 0; weight < words.length; ++weight) {\\n            insert(words[weight], weight);\\n        }\\n    }\\n    \\n    private void insert(String word, int weight) {\\n        String composite = word + DELIMITER + word;\\n        for(int i = 0; i < word.length(); ++i) {\\n            String word2insert = composite.substring(i);\\n            TrieNode cur = root;\\n            for(char c : word2insert.toCharArray()) {\\n                if(cur.children[c - \\'a\\'] == null) \\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                cur = cur.children[c - \\'a\\'];\\n                cur.weight = weight;\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String word2search = suffix + DELIMITER + prefix;\\n        TrieNode cur = root;\\n        for(char c : word2search.toCharArray()) {\\n            if(cur.children[c - \\'a\\'] == null) return -1; \\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        return cur.weight;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[27];\\n    int weight = 0;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\n    \\n    private static final char DELIMITER = \\'a\\' + 26; //{\\n    \\n    private final TrieNode root;\\n\\n    public WordFilter(String[] words) {\\n        this.root = new TrieNode();\\n        for(int weight = 0; weight < words.length; ++weight) {\\n            insert(words[weight], weight);\\n        }\\n    }\\n    \\n    private void insert(String word, int weight) {\\n        String composite = word + DELIMITER + word;\\n        for(int i = 0; i < word.length(); ++i) {\\n            String word2insert = composite.substring(i);\\n            TrieNode cur = root;\\n            for(char c : word2insert.toCharArray()) {\\n                if(cur.children[c - \\'a\\'] == null) \\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                cur = cur.children[c - \\'a\\'];\\n                cur.weight = weight;\\n            }\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String word2search = suffix + DELIMITER + prefix;\\n        TrieNode cur = root;\\n        for(char c : word2search.toCharArray()) {\\n            if(cur.children[c - \\'a\\'] == null) return -1; \\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        return cur.weight;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[27];\\n    int weight = 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605012,
                "title": "java-trie-ds-explained-tc-sc-explained",
                "content": "//  A trie data structure is ideal for word search with prefix\\n// Here we are given a prefix and a suffix to look out for word.\\n// We can change the basic Tries DS abit to solve our problem here. Changes are\\n// Every Trie Node will have an children[] with 27 length as we will tweak the word and will use \\'{\\' which comes next to \\'z\\' in ASCII\\n// Associate a weight (index of word) with each TrieNode\\n\\n// Each time a WordFilter() is called, we will build a Trie DS that will hold EVERY \\'suffix + { + word\\' suffix possible associated with a word. For Example if the words[] = {apple}, we will have a trie like this\\n\\n// \"apple{apple\", \"pple{apple\", \"ple{apple\", \"le{apple\", \"e{apple\", \"{apple\"\\n// Now f() will join suffix & prefix in this way suffix { prefix so lets say prefix = a, suffix = e, so we will try to search \\'e{a\\' in the trie. If we get it we will return the weight (idx) associated with the word.\\n\\n// WE DO NOT NEED TO STORE THE ACTUAL WORD\\n\\n// TC : WordFilter() -> O(W * L^2) (because substring() will take O(L) as well), f() -> O(2L) -> L = length of word\\n// SC : O(W*L) -> W = words.length, L = length of each word\\n\\n```\\nclass WordFilter {\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for(int i = 0; i < words.length; i++) {\\n            String word = \\'{\\' + words[i];\\n\\n            for(int j = 0; j < word.length(); j++) {\\n                insert(root, word.substring(j + 1) + word, i);\\n            }\\n        }\\n    }\\n    \\n    private void insert(TrieNode root, String word, int weight) {\\n        TrieNode curr = root;\\n        for(char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            if(curr.children[idx] == null) {\\n                curr.children[idx] = new TrieNode();\\n            }\\n            \\n            curr = curr.children[idx];\\n            curr.weight = weight;\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        TrieNode curr = root;\\n        String searchWord = suffix + \\'{\\' + prefix;\\n        for(char c : searchWord.toCharArray()) {\\n            int idx = c  - \\'a\\';\\n            if(curr.children[idx] == null)\\n                return -1;\\n            \\n            curr = curr.children[idx];\\n        }\\n        \\n        return curr.weight;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    int weight;\\n    \\n    public TrieNode() {\\n        this.children = new TrieNode[27]; // \\'{\\' is next after \\'z\\' so 27\\n        this.weight = 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        for(int i = 0; i < words.length; i++) {\\n            String word = \\'{\\' + words[i];\\n\\n            for(int j = 0; j < word.length(); j++) {\\n                insert(root, word.substring(j + 1) + word, i);\\n            }\\n        }\\n    }\\n    \\n    private void insert(TrieNode root, String word, int weight) {\\n        TrieNode curr = root;\\n        for(char c : word.toCharArray()) {\\n            int idx = c - \\'a\\';\\n            if(curr.children[idx] == null) {\\n                curr.children[idx] = new TrieNode();\\n            }\\n            \\n            curr = curr.children[idx];\\n            curr.weight = weight;\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        TrieNode curr = root;\\n        String searchWord = suffix + \\'{\\' + prefix;\\n        for(char c : searchWord.toCharArray()) {\\n            int idx = c  - \\'a\\';\\n            if(curr.children[idx] == null)\\n                return -1;\\n            \\n            curr = curr.children[idx];\\n        }\\n        \\n        return curr.weight;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children;\\n    int weight;\\n    \\n    public TrieNode() {\\n        this.children = new TrieNode[27]; // \\'{\\' is next after \\'z\\' so 27\\n        this.weight = 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570239,
                "title": "c-just-small-modify-trie-insert-and-search-so-neat",
                "content": "I have neatly implemented [@ytyrain\\'s brilliant logic](http://leetcode.com/problems/prefix-and-suffix-search/discuss/144432/Java-Beat-95-just-small-modifications-in-implementing-Trie.).\\n```\\nclass node{\\n    \\n    public:\\n    \\n    char c;\\n    int lastEle;\\n    vector<node*> children;\\n    \\n    node(char C = \\' \\'){\\n        this->c = C;\\n        this-> lastEle =0;\\n        children.resize(27,NULL);\\n    }\\n    \\n};\\n\\n\\nclass WordFilter {\\npublic:\\n    node* Root;\\n    \\n    \\n    void insert(string& word, int idx){\\n        \\n        int n = word.size();\\n        int i=0; \\n        node* curr = this->Root;\\n        \\n        while(i < n){\\n            \\n            char c = word[i];\\n            \\n            if(curr->children[c-\\'a\\']==NULL)\\n                curr->children[c-\\'a\\'] = new node(c);\\n            \\n            curr->children[c-\\'a\\']->lastEle = idx;\\n            \\n            curr = curr-> children[c-\\'a\\'];\\n            \\n            i++;\\n        }\\n        \\n        return; \\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        this->Root = new node;\\n        \\n        int ws = words.size();\\n        \\n        for(int j=0;j<ws;j++){\\n            \\n            string word = words[j];\\n            int n = word.length();\\n            string suffix = \"\";\\n            \\n            for(int i=n-1;i > -1;i--){\\n                suffix = word[i] + suffix;\\n                string stringToInsert = suffix + \\'{\\' + word;\\n               \\n                insert(stringToInsert, j);\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    \\n    int searchInTrie(string& word){\\n        int n = word.length();\\n        int i = 0;\\n        node* curr = this->Root;\\n        \\n        while(curr && i < n){\\n            \\n            char c = word[i];\\n            \\n            curr = curr->children[c-\\'a\\'];\\n             \\n            i++;\\n        }\\n        \\n        if(curr==NULL) return -1;\\n        \\n        else return curr->lastEle; \\n        \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string wordToSearch = suffix + \\'{\\' + prefix;\\n\\n        return searchInTrie(wordToSearch);\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass node{\\n    \\n    public:\\n    \\n    char c;\\n    int lastEle;\\n    vector<node*> children;\\n    \\n    node(char C = \\' \\'){\\n        this->c = C;\\n        this-> lastEle =0;\\n        children.resize(27,NULL);\\n    }\\n    \\n};\\n\\n\\nclass WordFilter {\\npublic:\\n    node* Root;\\n    \\n    \\n    void insert(string& word, int idx){\\n        \\n        int n = word.size();\\n        int i=0; \\n        node* curr = this->Root;\\n        \\n        while(i < n){\\n            \\n            char c = word[i];\\n            \\n            if(curr->children[c-\\'a\\']==NULL)\\n                curr->children[c-\\'a\\'] = new node(c);\\n            \\n            curr->children[c-\\'a\\']->lastEle = idx;\\n            \\n            curr = curr-> children[c-\\'a\\'];\\n            \\n            i++;\\n        }\\n        \\n        return; \\n    }\\n    \\n    WordFilter(vector<string>& words) {\\n        this->Root = new node;\\n        \\n        int ws = words.size();\\n        \\n        for(int j=0;j<ws;j++){\\n            \\n            string word = words[j];\\n            int n = word.length();\\n            string suffix = \"\";\\n            \\n            for(int i=n-1;i > -1;i--){\\n                suffix = word[i] + suffix;\\n                string stringToInsert = suffix + \\'{\\' + word;\\n               \\n                insert(stringToInsert, j);\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    \\n    int searchInTrie(string& word){\\n        int n = word.length();\\n        int i = 0;\\n        node* curr = this->Root;\\n        \\n        while(curr && i < n){\\n            \\n            char c = word[i];\\n            \\n            curr = curr->children[c-\\'a\\'];\\n             \\n            i++;\\n        }\\n        \\n        if(curr==NULL) return -1;\\n        \\n        else return curr->lastEle; \\n        \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        \\n        string wordToSearch = suffix + \\'{\\' + prefix;\\n\\n        return searchInTrie(wordToSearch);\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567042,
                "title": "python3-prefix-suffix-trie-solution",
                "content": "1. Reduce the input (the word_to_index[word] = i routine)\\n2. Build up both prefix and suffix tries from the final map where every node has all of the possible words that exist in it\\'s children\\n3. Look up both prefix and suffix and perform an intersection between the possible children of both\\n4. Return max or -1 if the intersection is non-empty or empty respectively\\n\\n```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.index = None\\n        self.words = set()\\n\\nclass PrefixTrie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, prefix, index):\\n        node = self.root\\n        for i in range(len(prefix)):\\n            node.words.add(index)\\n            if prefix[i] not in node.children:\\n                node.children[prefix[i]] = TrieNode()\\n            node = node.children[prefix[i]]\\n        node.words.add(index)\\n        node.index = index\\n    \\n    def get_words(self, prefix) -> List[int]:\\n        node = self.root\\n        for i in range(len(prefix)):\\n            if prefix[i] not in node.children:\\n                return set()\\n            node = node.children[prefix[i]]\\n        # Figure out any children\\n        return node.words\\n\\nclass SuffixTrie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, suffix, index):\\n        node = self.root\\n        for i in range(len(suffix) - 1, -1, -1):\\n            node.words.add(index)\\n            if suffix[i] not in node.children:\\n                node.children[suffix[i]] = TrieNode()\\n            node = node.children[suffix[i]]\\n        node.words.add(index)\\n        node.index = index\\n    \\n    def get_words(self, suffix) -> List[int]:\\n        node = self.root\\n        for i in range(len(suffix) - 1, -1, -1):\\n            if suffix[i] not in node.children:\\n                return set()\\n            node = node.children[suffix[i]]\\n        # Figure out any children\\n        return node.words\\n\\n        \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        # Reduce input\\n        word_to_index = dict()\\n        for i in range(len(words)):\\n            word_to_index[words[i]] = i\\n        \\n        self.prefix = PrefixTrie()\\n        self.suffix = SuffixTrie()\\n        for word in word_to_index:\\n            self.prefix.insert(word, word_to_index[word])\\n            self.suffix.insert(word, word_to_index[word])\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefix_words = self.prefix.get_words(prefix)\\n        suffix_words = self.suffix.get_words(suffix)\\n        intersection = prefix_words.intersection(suffix_words)\\n        return max(intersection) if intersection else -1\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = dict()\\n        self.index = None\\n        self.words = set()\\n\\nclass PrefixTrie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, prefix, index):\\n        node = self.root\\n        for i in range(len(prefix)):\\n            node.words.add(index)\\n            if prefix[i] not in node.children:\\n                node.children[prefix[i]] = TrieNode()\\n            node = node.children[prefix[i]]\\n        node.words.add(index)\\n        node.index = index\\n    \\n    def get_words(self, prefix) -> List[int]:\\n        node = self.root\\n        for i in range(len(prefix)):\\n            if prefix[i] not in node.children:\\n                return set()\\n            node = node.children[prefix[i]]\\n        # Figure out any children\\n        return node.words\\n\\nclass SuffixTrie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, suffix, index):\\n        node = self.root\\n        for i in range(len(suffix) - 1, -1, -1):\\n            node.words.add(index)\\n            if suffix[i] not in node.children:\\n                node.children[suffix[i]] = TrieNode()\\n            node = node.children[suffix[i]]\\n        node.words.add(index)\\n        node.index = index\\n    \\n    def get_words(self, suffix) -> List[int]:\\n        node = self.root\\n        for i in range(len(suffix) - 1, -1, -1):\\n            if suffix[i] not in node.children:\\n                return set()\\n            node = node.children[suffix[i]]\\n        # Figure out any children\\n        return node.words\\n\\n        \\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        # Reduce input\\n        word_to_index = dict()\\n        for i in range(len(words)):\\n            word_to_index[words[i]] = i\\n        \\n        self.prefix = PrefixTrie()\\n        self.suffix = SuffixTrie()\\n        for word in word_to_index:\\n            self.prefix.insert(word, word_to_index[word])\\n            self.suffix.insert(word, word_to_index[word])\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefix_words = self.prefix.get_words(prefix)\\n        suffix_words = self.suffix.get_words(suffix)\\n        intersection = prefix_words.intersection(suffix_words)\\n        return max(intersection) if intersection else -1\\n\\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509840,
                "title": "simple-python-solution-trie",
                "content": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.pre_dict = defaultdict(list)\\n        self.su_dict = defaultdict(list)\\n        self.my_dict = defaultdict(int)\\n        \\n        for i, word in enumerate(words):\\n            cur_pre, cur_su = self.pre_dict, self.su_dict\\n            \\n            for w in word:\\n                if w not in cur_pre: cur_pre[w] = [{}, []]\\n                cur_pre[w][1].append(i)\\n                cur_pre = cur_pre[w][0]\\n                \\n            for w in word[::-1]:\\n                if w not in cur_su: cur_su[w] = [{}, []]\\n                cur_su[w][1].append(i)\\n                cur_su = cur_su[w][0]                \\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        if prefix + \" \" + suffix in self.my_dict: return self.my_dict[prefix + \" \" + suffix]\\n        \\n        cur_pre, cur_su, res = self.pre_dict, self.su_dict, -1\\n        \\n        for c in prefix:\\n            if c not in cur_pre: return -1\\n            ls1, cur_pre = cur_pre[c][1], cur_pre[c][0]\\n            \\n        for c in suffix[::-1]:\\n            if c not in cur_su: return -1\\n            ls2, cur_su = cur_su[c][1], cur_su[c][0]\\n        \\n        if len(ls1) <= len(ls2): ls, se = ls1, set(ls2)\\n        else: ls, se = ls2, set(ls1)\\n        \\n        for l in ls[::-1]:\\n            if l in se: \\n                res = l\\n                break\\n                \\n        self.my_dict[prefix + \" \" + suffix] = res\\n        \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.pre_dict = defaultdict(list)\\n        self.su_dict = defaultdict(list)\\n        self.my_dict = defaultdict(int)\\n        \\n        for i, word in enumerate(words):\\n            cur_pre, cur_su = self.pre_dict, self.su_dict\\n            \\n            for w in word:\\n                if w not in cur_pre: cur_pre[w] = [{}, []]\\n                cur_pre[w][1].append(i)\\n                cur_pre = cur_pre[w][0]\\n                \\n            for w in word[::-1]:\\n                if w not in cur_su: cur_su[w] = [{}, []]\\n                cur_su[w][1].append(i)\\n                cur_su = cur_su[w][0]                \\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        if prefix + \" \" + suffix in self.my_dict: return self.my_dict[prefix + \" \" + suffix]\\n        \\n        cur_pre, cur_su, res = self.pre_dict, self.su_dict, -1\\n        \\n        for c in prefix:\\n            if c not in cur_pre: return -1\\n            ls1, cur_pre = cur_pre[c][1], cur_pre[c][0]\\n            \\n        for c in suffix[::-1]:\\n            if c not in cur_su: return -1\\n            ls2, cur_su = cur_su[c][1], cur_su[c][0]\\n        \\n        if len(ls1) <= len(ls2): ls, se = ls1, set(ls2)\\n        else: ls, se = ls2, set(ls1)\\n        \\n        for l in ls[::-1]:\\n            if l in se: \\n                res = l\\n                break\\n                \\n        self.my_dict[prefix + \" \" + suffix] = res\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1354700,
                "title": "java-97-fast-and-90-memory-efficient-hashmap-and-two-tries",
                "content": "Use HashMap to eliminate duplicates. There are testcases with duplicate words.\\nFor example, if a word say \"abc\" occurs at indices 4 and 7 - then if this \"abc\" is a match, then the highest index 7 needs to be considered.\\n\\nI am using two Tries.\\nThe first Trie maintains the characters of the words in left to right order to enable prefix checks.\\nThe second Trie maintains the characters of the words in right to left order to enable suffix checks.\\nAlso, each TrieNode also maintains the max possible indices of the words relevant to it.\\nSo, checking for matching word is essentially a set intersection of the indices retrieved from prefix and suffix searches.\\n\\n\\n\\n```\\nclass TrieNode{\\n    public TrieNode[] children;\\n    public Set<Integer> indices;\\n    \\n    public TrieNode(){\\n        this.children = new TrieNode[26];\\n        this.indices = new HashSet<Integer>();\\n    }\\n}\\n\\nclass WordFilter {\\n    private TrieNode forwardRoot, reverseRoot;\\n    private HashMap<String, Integer> indexMap;\\n    \\n    public WordFilter(String[] words) {\\n        this.forwardRoot = new TrieNode(); \\n        this.reverseRoot = new TrieNode(); \\n        this.indexMap = new HashMap<String, Integer>();\\n        \\n        for(int i = 0; i < words.length; i++){  // eliminate duplicate words and unwanted processing\\n            indexMap.put(words[i], i);\\n        }\\n        \\n        for(String s : indexMap.keySet()){\\n            insert(s, indexMap.get(s), true, forwardRoot);\\n            insert(s, indexMap.get(s), false, reverseRoot);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Set<Integer> set1 = search(prefix, true, forwardRoot);\\n        Set<Integer> set2 = search(suffix, false, reverseRoot);\\n        \\n        int index = -1;\\n        if(set1 != null && set2 != null){\\n            for(int x : set1){\\n                if(set2.contains(x)){\\n                    index = Math.max(index, x);\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n    \\n    private void insert(String word, int index, boolean forward, TrieNode root){\\n        int i, N = word.length();\\n        char ch;\\n        TrieNode current = root;\\n        \\n        if(forward){\\n            for(i = 0; i < N; i++){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    current.children[ch - \\'a\\'] = new TrieNode();\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n                current.indices.add(index);\\n            }\\n        }else{\\n            for(i = N - 1; i >= 0; i--){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    current.children[ch - \\'a\\'] = new TrieNode();\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n                current.indices.add(index);\\n            }\\n        }\\n    }\\n    \\n    private Set<Integer> search(String word, boolean forward, TrieNode root){\\n        int i, N = word.length();\\n        char ch;\\n        TrieNode current = root;\\n        \\n        if(forward){\\n            for(i = 0; i < N; i++){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    return null;\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n            }\\n        }else{\\n            for(i = N - 1; i >= 0; i--){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    return null;\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n            }\\n        }\\n        \\n        return current.indices;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TrieNode{\\n    public TrieNode[] children;\\n    public Set<Integer> indices;\\n    \\n    public TrieNode(){\\n        this.children = new TrieNode[26];\\n        this.indices = new HashSet<Integer>();\\n    }\\n}\\n\\nclass WordFilter {\\n    private TrieNode forwardRoot, reverseRoot;\\n    private HashMap<String, Integer> indexMap;\\n    \\n    public WordFilter(String[] words) {\\n        this.forwardRoot = new TrieNode(); \\n        this.reverseRoot = new TrieNode(); \\n        this.indexMap = new HashMap<String, Integer>();\\n        \\n        for(int i = 0; i < words.length; i++){  // eliminate duplicate words and unwanted processing\\n            indexMap.put(words[i], i);\\n        }\\n        \\n        for(String s : indexMap.keySet()){\\n            insert(s, indexMap.get(s), true, forwardRoot);\\n            insert(s, indexMap.get(s), false, reverseRoot);\\n        }\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Set<Integer> set1 = search(prefix, true, forwardRoot);\\n        Set<Integer> set2 = search(suffix, false, reverseRoot);\\n        \\n        int index = -1;\\n        if(set1 != null && set2 != null){\\n            for(int x : set1){\\n                if(set2.contains(x)){\\n                    index = Math.max(index, x);\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n    \\n    private void insert(String word, int index, boolean forward, TrieNode root){\\n        int i, N = word.length();\\n        char ch;\\n        TrieNode current = root;\\n        \\n        if(forward){\\n            for(i = 0; i < N; i++){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    current.children[ch - \\'a\\'] = new TrieNode();\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n                current.indices.add(index);\\n            }\\n        }else{\\n            for(i = N - 1; i >= 0; i--){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    current.children[ch - \\'a\\'] = new TrieNode();\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n                current.indices.add(index);\\n            }\\n        }\\n    }\\n    \\n    private Set<Integer> search(String word, boolean forward, TrieNode root){\\n        int i, N = word.length();\\n        char ch;\\n        TrieNode current = root;\\n        \\n        if(forward){\\n            for(i = 0; i < N; i++){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    return null;\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n            }\\n        }else{\\n            for(i = N - 1; i >= 0; i--){\\n                ch = word.charAt(i);\\n                if(current.children[ch - \\'a\\'] == null){\\n                    return null;\\n                }\\n            \\n                current = current.children[ch - \\'a\\'];\\n            }\\n        }\\n        \\n        return current.indices;\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325629,
                "title": "python-all-prefix-suffix-dict-94-runtime",
                "content": "```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n\\n        self.prefix = defaultdict(set)\\n        self.suffix = defaultdict(set) \\n        seen = set()\\n        for ind in range(len(words)-1,-1,-1):\\n            w = words[ind]\\n            if w not in seen:\\n                seen.add(w)\\n                end = min(len(w)+1,11)\\n                for l in range(1,end):\\n                    self.prefix[w[:l]].add(ind)\\n                    self.suffix[w[len(w)-l:]].add(ind)\\n                \\n    def f(self, prefix: str, suffix: str) -> int:\\n        pre_set = self.prefix[prefix]\\n        suf_set = self.suffix[suffix]\\n        ans =  pre_set & suf_set\\n        if ans:\\n            return max(ans)\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n\\n        self.prefix = defaultdict(set)\\n        self.suffix = defaultdict(set) \\n        seen = set()\\n        for ind in range(len(words)-1,-1,-1):\\n            w = words[ind]\\n            if w not in seen:\\n                seen.add(w)\\n                end = min(len(w)+1,11)\\n                for l in range(1,end):\\n                    self.prefix[w[:l]].add(ind)\\n                    self.suffix[w[len(w)-l:]].add(ind)\\n                \\n    def f(self, prefix: str, suffix: str) -> int:\\n        pre_set = self.prefix[prefix]\\n        suf_set = self.suffix[suffix]\\n        ans =  pre_set & suf_set\\n        if ans:\\n            return max(ans)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253743,
                "title": "using-trie-search-in-java",
                "content": "```\\nclass WordFilter {\\n    public class TrieNode {\\n        Map<Character, TrieNode>children;\\n        boolean isEndOfWord;\\n        int index;\\n        public TrieNode() {\\n            index = -1;\\n            isEndOfWord = false;\\n            children = new HashMap<>();\\n        }\\n    }\\n\\n    List<String> wordFix;\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        int idx = 0;\\n        for(String word : words) {\\n            int n = word.length();\\n            String suff = \"\";\\n            for(int i= n-1; i>=0; i--) {\\n                suff = word.charAt(i) + suff;\\n                String wordFix = (suff+\"*\"+word);\\n                addString(wordFix, idx);\\n            }\\n            idx++;\\n        }\\n    }\\n    \\n    public void addString(String wordFix, int index) {\\n        TrieNode currentTrie = root;\\n        for(char ch : wordFix.toCharArray()) {\\n            if(!currentTrie.children.containsKey(ch)) {\\n                currentTrie.children.put(ch, new TrieNode());\\n            }\\n            currentTrie = currentTrie.children.get(ch);\\n            currentTrie.index = index;\\n        }\\n        currentTrie.isEndOfWord = true;\\n        currentTrie.index = index;\\n    }\\n    \\n    public int search(String key) {\\n        TrieNode keyTrie = root;\\n        for(char ch : key.toCharArray()) {\\n            if(!keyTrie.children.containsKey(ch)) {\\n               return -1; \\n            }\\n            keyTrie = keyTrie.children.get(ch);\\n        }\\n        return keyTrie.index;\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String wordfix = suffix+ \"*\" +prefix;\\n        return search(wordfix);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    public class TrieNode {\\n        Map<Character, TrieNode>children;\\n        boolean isEndOfWord;\\n        int index;\\n        public TrieNode() {\\n            index = -1;\\n            isEndOfWord = false;\\n            children = new HashMap<>();\\n        }\\n    }\\n\\n    List<String> wordFix;\\n    TrieNode root;\\n    public WordFilter(String[] words) {\\n        root = new TrieNode();\\n        int idx = 0;\\n        for(String word : words) {\\n            int n = word.length();\\n            String suff = \"\";\\n            for(int i= n-1; i>=0; i--) {\\n                suff = word.charAt(i) + suff;\\n                String wordFix = (suff+\"*\"+word);\\n                addString(wordFix, idx);\\n            }\\n            idx++;\\n        }\\n    }\\n    \\n    public void addString(String wordFix, int index) {\\n        TrieNode currentTrie = root;\\n        for(char ch : wordFix.toCharArray()) {\\n            if(!currentTrie.children.containsKey(ch)) {\\n                currentTrie.children.put(ch, new TrieNode());\\n            }\\n            currentTrie = currentTrie.children.get(ch);\\n            currentTrie.index = index;\\n        }\\n        currentTrie.isEndOfWord = true;\\n        currentTrie.index = index;\\n    }\\n    \\n    public int search(String key) {\\n        TrieNode keyTrie = root;\\n        for(char ch : key.toCharArray()) {\\n            if(!keyTrie.children.containsKey(ch)) {\\n               return -1; \\n            }\\n            keyTrie = keyTrie.children.get(ch);\\n        }\\n        return keyTrie.index;\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        String wordfix = suffix+ \"*\" +prefix;\\n        return search(wordfix);\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter obj = new WordFilter(words);\\n * int param_1 = obj.f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243914,
                "title": "c-soln-trie",
                "content": "```\\nclass WordFilter {\\npublic:\\n    struct Trie{\\n        Trie* child[28];   //ascii of | is 2 more than z, you will get the reason by referring to below code\\n        bool isEnd;\\n        int ind;\\n        Trie(){\\n            for(int i=0;i<28;i++){child[i]=NULL;}\\n            isEnd=false;\\n            ind=-1;\\n        }\\n    };\\n    Trie* root=new Trie();\\n   void addword(string s, int ind){\\n        Trie *cur=root;\\n        for(int i=0;i<s.length();i++){\\n            if(!cur->child[s[i]-\\'a\\']){cur->child[s[i]-\\'a\\']=new Trie();}\\n            cur=cur->child[s[i]-\\'a\\'];\\n        }\\n        cur->isEnd=true;\\n       cur->ind=ind;\\n    }\\n     \\n    int search(string s){\\n        Trie* cur=root;\\n        for(int i=0;i<s.length();i++){\\n            if(!cur->child[s[i]-\\'a\\'])return -1;\\n            cur=cur->child[s[i]-\\'a\\'];\\n        }\\n        return cur->ind;\\n    }\\n    \\n\\n    WordFilter(vector<string>& words) {\\n        for(int ind=0;ind<words.size();ind++){\\n            string word=words[ind];\\n            for(int i=0;i<word.length();i++){\\n                    for(int j=word.length()-1;j>=0;j--){\\n                        string temp=word.substr(0,i+1)+\\'|\\'+word.substr(j);\\n                        addword(temp,ind);\\n                    }\\n            }\\n        }\\n        \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string s=prefix+\\'|\\'+suffix;\\n        return search(s);\\n    }\\n};\\n ```",
                "solutionTags": [
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter {\\npublic:\\n    struct Trie{\\n        Trie* child[28];   //ascii of | is 2 more than z, you will get the reason by referring to below code\\n        bool isEnd;\\n        int ind;\\n        Trie(){\\n            for(int i=0;i<28;i++){child[i]=NULL;}\\n            isEnd=false;\\n            ind=-1;\\n        }\\n    };\\n    Trie* root=new Trie();\\n   void addword(string s, int ind){\\n        Trie *cur=root;\\n        for(int i=0;i<s.length();i++){\\n            if(!cur->child[s[i]-\\'a\\']){cur->child[s[i]-\\'a\\']=new Trie();}\\n            cur=cur->child[s[i]-\\'a\\'];\\n        }\\n        cur->isEnd=true;\\n       cur->ind=ind;\\n    }\\n     \\n    int search(string s){\\n        Trie* cur=root;\\n        for(int i=0;i<s.length();i++){\\n            if(!cur->child[s[i]-\\'a\\'])return -1;\\n            cur=cur->child[s[i]-\\'a\\'];\\n        }\\n        return cur->ind;\\n    }\\n    \\n\\n    WordFilter(vector<string>& words) {\\n        for(int ind=0;ind<words.size();ind++){\\n            string word=words[ind];\\n            for(int i=0;i<word.length();i++){\\n                    for(int j=word.length()-1;j>=0;j--){\\n                        string temp=word.substr(0,i+1)+\\'|\\'+word.substr(j);\\n                        addword(temp,ind);\\n                    }\\n            }\\n        }\\n        \\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        string s=prefix+\\'|\\'+suffix;\\n        return search(s);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1189196,
                "title": "easy-solution-using-map-c",
                "content": "Upvote if you found it helpful :)\\n```\\nclass WordFilter {\\npublic:\\n    vector<string> words;\\n    string prefix, suffix;\\n    map<string, int> prefSufIndex;\\n    WordFilter(vector<string>& words) {\\n        this->words = words; \\n        for(int w = (words.size() - 1); w >= 0; w--){\\n            for(int i = 0; i <= 10 && i <= words[w].size(); i++){\\n                for(int j = 0; j <= 10 && j <= words[w].size(); j++){\\n                    if(prefSufIndex.find((words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j))) == prefSufIndex.end())\\n                        prefSufIndex.insert({(words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j)), w});\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    int f(string prefix, string suffix) {\\n        \\n        if(prefSufIndex.find((prefix + \"#\" + suffix)) != prefSufIndex.end())\\n            return prefSufIndex[(prefix + \"#\" + suffix)];\\n        else\\n            return -1;\\n        \\n                \\n    }\\n        \\n    \\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\npublic:\\n    vector<string> words;\\n    string prefix, suffix;\\n    map<string, int> prefSufIndex;\\n    WordFilter(vector<string>& words) {\\n        this->words = words; \\n        for(int w = (words.size() - 1); w >= 0; w--){\\n            for(int i = 0; i <= 10 && i <= words[w].size(); i++){\\n                for(int j = 0; j <= 10 && j <= words[w].size(); j++){\\n                    if(prefSufIndex.find((words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j))) == prefSufIndex.end())\\n                        prefSufIndex.insert({(words[w].substr(0, i) + \"#\" + words[w].substr(words[w].size()-j)), w});\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    int f(string prefix, string suffix) {\\n        \\n        if(prefSufIndex.find((prefix + \"#\" + suffix)) != prefSufIndex.end())\\n            return prefSufIndex[(prefix + \"#\" + suffix)];\\n        else\\n            return -1;\\n        \\n                \\n    }\\n        \\n    \\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187316,
                "title": "c-prefix-trie-and-suffix-trie-used",
                "content": "```\\nclass PrefixTrie{\\n    unordered_map<char,PrefixTrie *> children;\\n    bool isEndOfWord;\\n    vector<int> v_index;\\n    public :\\n    //vector<int> v_index;\\n    PrefixTrie(){\\n        children.clear();\\n        isEndOfWord=false;\\n        v_index=vector<int>();\\n    }\\n    void insert(string &word,int index){\\n        PrefixTrie *curr=this;\\n        for(int i=0;i<word.length();i++){\\n            (curr->v_index).push_back(index);\\n            if(curr->children[word[i]]==nullptr){\\n                curr->children[word[i]]=new PrefixTrie();\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        curr->isEndOfWord=true;\\n        (curr->v_index).push_back(index);\\n    }\\n    \\n    vector<int> search(string &word){\\n        PrefixTrie *curr=this;\\n        for(int i=0;i<word.length();i++){\\n            if(curr->children[word[i]]==nullptr){\\n                //cout<<\"A\"<<word[i]<<endl;\\n                return {};\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        return curr->v_index;\\n    }\\n};\\nclass SuffixTrie{\\n    unordered_map<char,SuffixTrie *> children;\\n    bool isEndOfWord;\\n    vector<int> v_index;\\n    public :\\n    //vector<int> v_index;\\n    SuffixTrie(){\\n        children.clear();\\n        isEndOfWord=false;\\n        v_index=vector<int>();\\n    }\\n    void insert(string &word,int index){\\n        SuffixTrie *curr=this;\\n        for(int i=word.length()-1;i>=0;i--){\\n            (curr->v_index).push_back(index);\\n            if(curr->children[word[i]]==nullptr){\\n                curr->children[word[i]]=new SuffixTrie();\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        (curr->v_index).push_back(index);\\n        curr->isEndOfWord=true;\\n    }\\n    \\n    vector<int> search(string &word){\\n        SuffixTrie *curr=this;\\n        for(int i=word.length()-1;i>=0;i--){\\n            if(curr->children[word[i]]==nullptr){\\n                return {};\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        return curr->v_index;\\n    }\\n};\\nclass WordFilter {\\n    PrefixTrie *head1;\\n    SuffixTrie *head2;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        head1=new PrefixTrie();\\n        head2=new SuffixTrie();\\n        \\n        for(int index=0;index<words.size();index++){\\n            string s=words[index];\\n            head1->insert(s,index);\\n            head2->insert(s,index);\\n            //index++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        int ans=0;\\n        vector<int> v1=head1->search(prefix);\\n        vector<int> v2=head2->search(suffix);\\n        int index1=v1.size()-1;\\n        int index2=v2.size()-1;     \\n        while(index1>=0 && index2>=0){\\n            if(v1[index1]==v2[index2])\\n                return v1[index1];\\n            if(v1[index1]>v2[index2])\\n                index1--;\\n            else\\n                index2--;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```\\n\\nEdit 1 : Thanks for mentioning in comments that LC added some new TC. Will modify the solution accordingly in some time (28/07/2021)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\nclass PrefixTrie{\\n    unordered_map<char,PrefixTrie *> children;\\n    bool isEndOfWord;\\n    vector<int> v_index;\\n    public :\\n    //vector<int> v_index;\\n    PrefixTrie(){\\n        children.clear();\\n        isEndOfWord=false;\\n        v_index=vector<int>();\\n    }\\n    void insert(string &word,int index){\\n        PrefixTrie *curr=this;\\n        for(int i=0;i<word.length();i++){\\n            (curr->v_index).push_back(index);\\n            if(curr->children[word[i]]==nullptr){\\n                curr->children[word[i]]=new PrefixTrie();\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        curr->isEndOfWord=true;\\n        (curr->v_index).push_back(index);\\n    }\\n    \\n    vector<int> search(string &word){\\n        PrefixTrie *curr=this;\\n        for(int i=0;i<word.length();i++){\\n            if(curr->children[word[i]]==nullptr){\\n                //cout<<\"A\"<<word[i]<<endl;\\n                return {};\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        return curr->v_index;\\n    }\\n};\\nclass SuffixTrie{\\n    unordered_map<char,SuffixTrie *> children;\\n    bool isEndOfWord;\\n    vector<int> v_index;\\n    public :\\n    //vector<int> v_index;\\n    SuffixTrie(){\\n        children.clear();\\n        isEndOfWord=false;\\n        v_index=vector<int>();\\n    }\\n    void insert(string &word,int index){\\n        SuffixTrie *curr=this;\\n        for(int i=word.length()-1;i>=0;i--){\\n            (curr->v_index).push_back(index);\\n            if(curr->children[word[i]]==nullptr){\\n                curr->children[word[i]]=new SuffixTrie();\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        (curr->v_index).push_back(index);\\n        curr->isEndOfWord=true;\\n    }\\n    \\n    vector<int> search(string &word){\\n        SuffixTrie *curr=this;\\n        for(int i=word.length()-1;i>=0;i--){\\n            if(curr->children[word[i]]==nullptr){\\n                return {};\\n            }\\n            curr=curr->children[word[i]];\\n        }\\n        return curr->v_index;\\n    }\\n};\\nclass WordFilter {\\n    PrefixTrie *head1;\\n    SuffixTrie *head2;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        head1=new PrefixTrie();\\n        head2=new SuffixTrie();\\n        \\n        for(int index=0;index<words.size();index++){\\n            string s=words[index];\\n            head1->insert(s,index);\\n            head2->insert(s,index);\\n            //index++;\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        int ans=0;\\n        vector<int> v1=head1->search(prefix);\\n        vector<int> v2=head2->search(suffix);\\n        int index1=v1.size()-1;\\n        int index2=v2.size()-1;     \\n        while(index1>=0 && index2>=0){\\n            if(v1[index1]==v2[index2])\\n                return v1[index1];\\n            if(v1[index1]>v2[index2])\\n                index1--;\\n            else\\n                index2--;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1186772,
                "title": "java-solutions-from-tle-to-map-to-trie",
                "content": "Solution 1. Simple but get TLE:\\n```\\nclass WordFilter {\\n    String[] words;\\n\\n    public WordFilter(String[] words) {\\n        words = words;\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        for (int i = words.length - 1; i >= 0; i--) {\\n            if (words[i].startsWith(prefix) && words[i].endsWith(suffix)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nSolution 2. Use Map\\n\\n```\\nclass WordFilter {\\n    Map<String, Integer> map = new HashMap<>();\\n\\n    public WordFilter(String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            int n = s.length();\\n            for (int j = 0; j < n + 1; j++) {\\n                for (int k = 0; k < n; k++) {\\n                    map.put(s.substring(0, j) + \"#\" + s.substring(k), i);\\n                }\\n            }\\n        }\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        return map.getOrDefault(prefix + \"#\" + suffix, -1);\\n    }\\n}\\n```\\n\\nSolution 3. Use Trie\\n\\n```\\nclass WordFilter {\\n\\n    TrieNode trie1 = new TrieNode();  // forward order\\n    TrieNode trie2 = new TrieNode();  // reverse order\\n\\n    public WordFilter(String[] words) {\\n        buildTrie1(words);\\n        buildTrie2(words);\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        TrieNode cur = trie1;\\n        for (char c : prefix.toCharArray()) {\\n            if (cur == null) break;\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        if (cur == null) {\\n            return -1;\\n        }\\n        Set<Integer> set1 = cur.setIdx;\\n\\n        cur = trie2;\\n        for (int i = suffix.length() - 1; i >= 0; i--) {\\n            char c = suffix.charAt(i);\\n            if (cur == null) break;\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        if (cur == null) {\\n            return -1;\\n        }\\n        Set<Integer> set2 = cur.setIdx;\\n\\n        for (int x : set1) {\\n            if (set2.contains(x)) return x;\\n        }\\n        System.out.println(\"c\");\\n        return -1;\\n    }\\n\\n    public void buildTrie1(String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            TrieNode cur = trie1;\\n            for (char c : words[i].toCharArray()) {\\n                if (cur.children[c - \\'a\\'] == null) {\\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[c - \\'a\\'];\\n                cur.setIdx.add(i);\\n            }\\n        }\\n    }\\n\\n    public void buildTrie2(String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            TrieNode cur = trie2;\\n            for (int j = words[i].length() - 1; j >= 0; j--) {\\n                char c = words[i].charAt(j);\\n                if (cur.children[c - \\'a\\'] == null) {\\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[c - \\'a\\'];\\n                cur.setIdx.add(i);\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    Set<Integer> setIdx = new TreeSet<>(Collections.reverseOrder());\\n    TrieNode[] children = new TrieNode[26];\\n\\n    public TrieNode() {\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    String[] words;\\n\\n    public WordFilter(String[] words) {\\n        words = words;\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        for (int i = words.length - 1; i >= 0; i--) {\\n            if (words[i].startsWith(prefix) && words[i].endsWith(suffix)) return i;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass WordFilter {\\n    Map<String, Integer> map = new HashMap<>();\\n\\n    public WordFilter(String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            String s = words[i];\\n            int n = s.length();\\n            for (int j = 0; j < n + 1; j++) {\\n                for (int k = 0; k < n; k++) {\\n                    map.put(s.substring(0, j) + \"#\" + s.substring(k), i);\\n                }\\n            }\\n        }\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        return map.getOrDefault(prefix + \"#\" + suffix, -1);\\n    }\\n}\\n```\n```\\nclass WordFilter {\\n\\n    TrieNode trie1 = new TrieNode();  // forward order\\n    TrieNode trie2 = new TrieNode();  // reverse order\\n\\n    public WordFilter(String[] words) {\\n        buildTrie1(words);\\n        buildTrie2(words);\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        TrieNode cur = trie1;\\n        for (char c : prefix.toCharArray()) {\\n            if (cur == null) break;\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        if (cur == null) {\\n            return -1;\\n        }\\n        Set<Integer> set1 = cur.setIdx;\\n\\n        cur = trie2;\\n        for (int i = suffix.length() - 1; i >= 0; i--) {\\n            char c = suffix.charAt(i);\\n            if (cur == null) break;\\n            cur = cur.children[c - \\'a\\'];\\n        }\\n        if (cur == null) {\\n            return -1;\\n        }\\n        Set<Integer> set2 = cur.setIdx;\\n\\n        for (int x : set1) {\\n            if (set2.contains(x)) return x;\\n        }\\n        System.out.println(\"c\");\\n        return -1;\\n    }\\n\\n    public void buildTrie1(String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            TrieNode cur = trie1;\\n            for (char c : words[i].toCharArray()) {\\n                if (cur.children[c - \\'a\\'] == null) {\\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[c - \\'a\\'];\\n                cur.setIdx.add(i);\\n            }\\n        }\\n    }\\n\\n    public void buildTrie2(String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            TrieNode cur = trie2;\\n            for (int j = words[i].length() - 1; j >= 0; j--) {\\n                char c = words[i].charAt(j);\\n                if (cur.children[c - \\'a\\'] == null) {\\n                    cur.children[c - \\'a\\'] = new TrieNode();\\n                }\\n                cur = cur.children[c - \\'a\\'];\\n                cur.setIdx.add(i);\\n            }\\n        }\\n    }\\n}\\n\\nclass TrieNode {\\n    Set<Integer> setIdx = new TreeSet<>(Collections.reverseOrder());\\n    TrieNode[] children = new TrieNode[26];\\n\\n    public TrieNode() {\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186574,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Node {\\n    var char: Character\\n    var indexes: [Int]\\n    var nexts: [Node]\\n    init(_ char: Character) {\\n        self.char = char\\n        self.indexes = [Int]()\\n        self.nexts = [Node]()\\n    }\\n}\\n\\nclass WordFilter {\\n\\n    var prefix: Node\\n    var suffix: Node\\n    var cache: [String: [String: Int]]\\n\\n    init(_ words: [String]) {\\n        self.prefix = Node(\"?\")\\n        self.suffix = Node(\"?\")\\n        self.cache = [String: [String: Int]]()\\n        for wi in 0..<words.count {\\n            let word = Array(words[wi]), wc = word.count\\n            var prefixNode = prefix, suffixNode = suffix\\n            for ci in 0..<wc {\\n                var prefixNext: Node? = nil, suffixNext = prefixNext\\n                for next in prefixNode.nexts where next.char == word[ci] {\\n                    prefixNext = next\\n                }\\n                for next in suffixNode.nexts where next.char == word[wc - 1 - ci] {\\n                    suffixNext = next\\n                }\\n                if prefixNext == nil {\\n                    let prefixNew = Node(word[ci])\\n                    prefixNode.nexts.append(prefixNew)\\n                    prefixNode = prefixNew\\n                } else {\\n                    prefixNode = prefixNext!\\n                }\\n                prefixNode.indexes.append(wi)\\n                if suffixNext == nil {\\n                    let suffixNew = Node(word[wc - 1 - ci])\\n                    suffixNode.nexts.append(suffixNew)\\n                    suffixNode = suffixNew\\n                } else {\\n                    suffixNode = suffixNext!\\n                }\\n                suffixNode.indexes.append(wi)\\n            }\\n        }\\n    }\\n    \\n    func f(_ prefix: String, _ suffix: String) -> Int {\\n        if let cache1 = cache[prefix], let cache2 = cache1[suffix] { return cache2 }\\n        let aprefix = Array(prefix), asuffix = Array(suffix), pc = aprefix.count, sc = asuffix.count\\n        var pi = [Int](), si = pi, node: Node? = self.prefix\\n        processPrefix: for i in 0..<pc {\\n            for next in node!.nexts where next.char == aprefix[i] {\\n                node = next\\n                continue processPrefix\\n            }\\n            node = nil\\n            break\\n        }\\n        if node != nil { pi = node!.indexes }\\n        node = self.suffix\\n        processSuffix: for i in 0..<sc {\\n            for next in node!.nexts where next.char == asuffix[sc - 1 - i] {\\n                node = next\\n                continue processSuffix\\n            }\\n            node = nil\\n            break\\n        }\\n        if node != nil { si = node!.indexes }\\n        let results = Array(Set(pi).intersection(Set(si))).sorted(by: { $0 > $1 })\\n        let result = results.count > 0 ? results.first! : -1\\n        cache[prefix, default: [String: Int]()][suffix] = result\\n        return result\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * let obj = WordFilter(words)\\n * let ret_1: Int = obj.f(prefix, suffix)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Node {\\n    var char: Character\\n    var indexes: [Int]\\n    var nexts: [Node]\\n    init(_ char: Character) {\\n        self.char = char\\n        self.indexes = [Int]()\\n        self.nexts = [Node]()\\n    }\\n}\\n\\nclass WordFilter {\\n\\n    var prefix: Node\\n    var suffix: Node\\n    var cache: [String: [String: Int]]\\n\\n    init(_ words: [String]) {\\n        self.prefix = Node(\"?\")\\n        self.suffix = Node(\"?\")\\n        self.cache = [String: [String: Int]]()\\n        for wi in 0..<words.count {\\n            let word = Array(words[wi]), wc = word.count\\n            var prefixNode = prefix, suffixNode = suffix\\n            for ci in 0..<wc {\\n                var prefixNext: Node? = nil, suffixNext = prefixNext\\n                for next in prefixNode.nexts where next.char == word[ci] {\\n                    prefixNext = next\\n                }\\n                for next in suffixNode.nexts where next.char == word[wc - 1 - ci] {\\n                    suffixNext = next\\n                }\\n                if prefixNext == nil {\\n                    let prefixNew = Node(word[ci])\\n                    prefixNode.nexts.append(prefixNew)\\n                    prefixNode = prefixNew\\n                } else {\\n                    prefixNode = prefixNext!\\n                }\\n                prefixNode.indexes.append(wi)\\n                if suffixNext == nil {\\n                    let suffixNew = Node(word[wc - 1 - ci])\\n                    suffixNode.nexts.append(suffixNew)\\n                    suffixNode = suffixNew\\n                } else {\\n                    suffixNode = suffixNext!\\n                }\\n                suffixNode.indexes.append(wi)\\n            }\\n        }\\n    }\\n    \\n    func f(_ prefix: String, _ suffix: String) -> Int {\\n        if let cache1 = cache[prefix], let cache2 = cache1[suffix] { return cache2 }\\n        let aprefix = Array(prefix), asuffix = Array(suffix), pc = aprefix.count, sc = asuffix.count\\n        var pi = [Int](), si = pi, node: Node? = self.prefix\\n        processPrefix: for i in 0..<pc {\\n            for next in node!.nexts where next.char == aprefix[i] {\\n                node = next\\n                continue processPrefix\\n            }\\n            node = nil\\n            break\\n        }\\n        if node != nil { pi = node!.indexes }\\n        node = self.suffix\\n        processSuffix: for i in 0..<sc {\\n            for next in node!.nexts where next.char == asuffix[sc - 1 - i] {\\n                node = next\\n                continue processSuffix\\n            }\\n            node = nil\\n            break\\n        }\\n        if node != nil { si = node!.indexes }\\n        let results = Array(Set(pi).intersection(Set(si))).sorted(by: { $0 > $1 })\\n        let result = results.count > 0 ? results.first! : -1\\n        cache[prefix, default: [String: Int]()][suffix] = result\\n        return result\\n    }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * let obj = WordFilter(words)\\n * let ret_1: Int = obj.f(prefix, suffix)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186436,
                "title": "python-easiest-way-to-do-it-beats-95",
                "content": "**Intuition**\\n\\nBuild 2 Tries, 1 for prefix, 1 for suffix. Each node in tree will have information of all indicies that hit (tree[l][1].add(idx)). Find the MAX intersect between the indices that the prefix hits and the indices that the suffixes hit. \\n\\n\\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.word_map = {word: idx for idx, word in enumerate(words)}\\n        self.prefix_tree = {}\\n        self.suffix_tree = {}\\n        self.parse_words()\\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        s1 = self.traverse(self.prefix_tree, prefix)\\n        s2 = self.traverse(self.suffix_tree, suffix[::-1])\\n        intersect = s1 & s2\\n        return max(intersect) if intersect else -1\\n    \\n    def traverse(self, tree, word):\\n        for l in word:\\n            if l in tree:\\n                tree, s = tree[l]\\n            else:\\n                return set()\\n        return s\\n        \\n    def parse_words(self):\\n        for word, idx in self.word_map.items():\\n            self.build_tree(self.prefix_tree, word, idx)\\n            self.build_tree(self.suffix_tree, word[::-1], idx)\\n            \\n    def build_tree(self, tree, word, idx):\\n        for l in word:\\n            if l not in tree:\\n                tree[l] = ({}, set([idx]))\\n            tree[l][1].add(idx)\\n            tree = tree[l][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.word_map = {word: idx for idx, word in enumerate(words)}\\n        self.prefix_tree = {}\\n        self.suffix_tree = {}\\n        self.parse_words()\\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        s1 = self.traverse(self.prefix_tree, prefix)\\n        s2 = self.traverse(self.suffix_tree, suffix[::-1])\\n        intersect = s1 & s2\\n        return max(intersect) if intersect else -1\\n    \\n    def traverse(self, tree, word):\\n        for l in word:\\n            if l in tree:\\n                tree, s = tree[l]\\n            else:\\n                return set()\\n        return s\\n        \\n    def parse_words(self):\\n        for word, idx in self.word_map.items():\\n            self.build_tree(self.prefix_tree, word, idx)\\n            self.build_tree(self.suffix_tree, word[::-1], idx)\\n            \\n    def build_tree(self, tree, word, idx):\\n        for l in word:\\n            if l not in tree:\\n                tree[l] = ({}, set([idx]))\\n            tree[l][1].add(idx)\\n            tree = tree[l][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186382,
                "title": "easy-trie-solution-based-on-the-hint",
                "content": "```\\n# Create a Trie. Each TrieNode has idx dictionary to store the index of the word.\\nclass TrieNode:\\n    def __init__(self):\\n        self.nodes = defaultdict(TrieNode)\\n        self.isWordEnd = False\\n        self.idx = {}\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n\\t# Insert the word into trie\\n    def insert(self, word, idx):\\n        curr = self.root\\n        for char in word:\\n            curr.idx[char] = idx\\n            curr = curr.nodes[char]\\n        curr.isWordEnd = True\\n     \\n    # Search for the prefix and keep updating the idx  \\n    def prefixSearch(self, prefix):\\n        curr = self.root\\n        prefixIdx = -1\\n        for char in prefix:\\n            if char not in curr.nodes:\\n                break\\n            else:\\n                prefixIdx = curr.idx[char]\\n                curr = curr.nodes[char]\\n        return prefixIdx\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.wordMap = {}\\n        self.trie = Trie()\\n        \\n\\t\\t# For each word create string using the suffix\\n\\t\\t# apple => #apple, e#apple, le#apple, ple#apple, pple#apple, apple#apple \\n        for i in range(len(words)):\\n            word = words[i]\\n            self.trie.insert(\\'#\\'+word, i)\\n            for j in range(1, len(word)+1):\\n                newWord = word[-j:] + \\'#\\' + word\\n                self.trie.insert(newWord, i)\\n            \\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n\\t\\t# generate the prefix to search\\n        searchKey = suffix + \\'#\\' + prefix\\n        return self.trie.prefixSearch(searchKey)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\n# Create a Trie. Each TrieNode has idx dictionary to store the index of the word.\\nclass TrieNode:\\n    def __init__(self):\\n        self.nodes = defaultdict(TrieNode)\\n        self.isWordEnd = False\\n        self.idx = {}\\n    \\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n\\t# Insert the word into trie\\n    def insert(self, word, idx):\\n        curr = self.root\\n        for char in word:\\n            curr.idx[char] = idx\\n            curr = curr.nodes[char]\\n        curr.isWordEnd = True\\n     \\n    # Search for the prefix and keep updating the idx  \\n    def prefixSearch(self, prefix):\\n        curr = self.root\\n        prefixIdx = -1\\n        for char in prefix:\\n            if char not in curr.nodes:\\n                break\\n            else:\\n                prefixIdx = curr.idx[char]\\n                curr = curr.nodes[char]\\n        return prefixIdx\\n        \\nclass WordFilter:\\n    def __init__(self, words: List[str]):\\n        self.wordMap = {}\\n        self.trie = Trie()\\n        \\n\\t\\t# For each word create string using the suffix\\n\\t\\t# apple => #apple, e#apple, le#apple, ple#apple, pple#apple, apple#apple \\n        for i in range(len(words)):\\n            word = words[i]\\n            self.trie.insert(\\'#\\'+word, i)\\n            for j in range(1, len(word)+1):\\n                newWord = word[-j:] + \\'#\\' + word\\n                self.trie.insert(newWord, i)\\n            \\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n\\t\\t# generate the prefix to search\\n        searchKey = suffix + \\'#\\' + prefix\\n        return self.trie.prefixSearch(searchKey)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185674,
                "title": "python-trie",
                "content": "# Idea\\nImplementation of the official solution #3. We add each word into trie in suffix + # + prefix format. Afterwards we query the trie in a similar fashion and return the idx of the match if one exists.\\n```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        for idx, word in enumerate(words):\\n            for i in range(len(word)):\\n                self.add_word(word[i:] + \\'#\\' + word, idx)\\n    \\n    def add_word(self, word, idx):\\n        cur = self.trie\\n        for ch in word:\\n            cur.setdefault(ch, {})\\n            cur = cur[ch]\\n            cur[True] = idx\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        node = self.trie\\n        for ch in suffix + \\'#\\' + prefix:\\n            if ch not in node: return -1\\n            node = node[ch]\\n        return node[True]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.trie = {}\\n        for idx, word in enumerate(words):\\n            for i in range(len(word)):\\n                self.add_word(word[i:] + \\'#\\' + word, idx)\\n    \\n    def add_word(self, word, idx):\\n        cur = self.trie\\n        for ch in word:\\n            cur.setdefault(ch, {})\\n            cur = cur[ch]\\n            cur[True] = idx\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        node = self.trie\\n        for ch in suffix + \\'#\\' + prefix:\\n            if ch not in node: return -1\\n            node = node[ch]\\n        return node[True]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185592,
                "title": "java-hashmap",
                "content": "```\\nHashMap<String,Integer> hmap;\\n    String words[];\\n    public WordFilter(String[] words) {\\n        this.words=words;\\n        hmap=new HashMap<String,Integer>();\\n        fill();\\n    }   \\n    private void fill(){\\n        int ind=0;\\n        for(String w:words){\\n            int n=w.length();\\n            String pref[]=new String[n];\\n            String suff[]=new String[n];\\n            fillPrefSuff(pref,suff,w,n);\\n            fillHashMap(pref,suff,w,ind,n);\\n            ind++;\\n        }\\n    }\\n    private void fillPrefSuff(String pref[],String suff[],String w,int n){\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                pref[i]=w.charAt(i)+\"\";\\n                suff[i]=w.charAt(n-i-1)+\"\";\\n            }                \\n            else{\\n                pref[i]=pref[i-1]+w.charAt(i);\\n                suff[i]=w.charAt(n-i-1)+suff[i-1];\\n            }\\n        }\\n    }\\n    private void fillHashMap(String pref[],String suff[],String w,int ind,int n){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                String PS=pref[i]+\" \"+suff[j];\\n                    hmap.put(PS,ind);\\n            }\\n        }\\n    }\\n    public int f(String prefix, String suffix) {\\n        if(!hmap.containsKey(prefix+\" \"+suffix))\\n            return -1;\\n        return hmap.get(prefix+\" \"+suffix);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nHashMap<String,Integer> hmap;\\n    String words[];\\n    public WordFilter(String[] words) {\\n        this.words=words;\\n        hmap=new HashMap<String,Integer>();\\n        fill();\\n    }   \\n    private void fill(){\\n        int ind=0;\\n        for(String w:words){\\n            int n=w.length();\\n            String pref[]=new String[n];\\n            String suff[]=new String[n];\\n            fillPrefSuff(pref,suff,w,n);\\n            fillHashMap(pref,suff,w,ind,n);\\n            ind++;\\n        }\\n    }\\n    private void fillPrefSuff(String pref[],String suff[],String w,int n){\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                pref[i]=w.charAt(i)+\"\";\\n                suff[i]=w.charAt(n-i-1)+\"\";\\n            }                \\n            else{\\n                pref[i]=pref[i-1]+w.charAt(i);\\n                suff[i]=w.charAt(n-i-1)+suff[i-1];\\n            }\\n        }\\n    }\\n    private void fillHashMap(String pref[],String suff[],String w,int ind,int n){\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                String PS=pref[i]+\" \"+suff[j];\\n                    hmap.put(PS,ind);\\n            }\\n        }\\n    }\\n    public int f(String prefix, String suffix) {\\n        if(!hmap.containsKey(prefix+\" \"+suffix))\\n            return -1;\\n        return hmap.get(prefix+\" \"+suffix);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185483,
                "title": "prefix-and-suffix-search-js",
                "content": "```js\\n/**\\n * @param {string[]} words\\n */\\nvar WordFilter = function(words) {\\n    this.words = words;\\n    this.map = {};\\n};\\n\\n/** \\n * @param {string} prefix \\n * @param {string} suffix\\n * @return {number}\\n */\\nWordFilter.prototype.f = function(prefix, suffix) {\\n    let index = -1;\\n    \\n    this.map[prefix] = this.map[prefix] || {};\\n    this.map[prefix][suffix] = this.map[prefix][suffix] || null;\\n    \\n    if (this.map[prefix][suffix] !== null) {\\n        return this.map[prefix][suffix];\\n    } \\n    \\n\\t/*\\n\\t* In case of multiple matches, the highest index must be returned\\n\\t* Reverse interating the array so can stop the looping as soon as we match something.\\n\\t*/\\n    for (let i = this.words.length - 1; i >= 0; i--) {\\n        if (\\n\\t\\t\\tthis.words[i].substring(0, prefix.length) === prefix &&\\n\\t\\t\\tthis.words[i].substring(this.words[i].length - suffix.length) === suffix\\n\\t\\t) {\\n            index = i;\\n            break;\\n        }\\n    }\\n    \\n\\t/*\\n\\t* Caching results that were already tested\\n\\t*/\\n    this.map[prefix][suffix] = index;\\n    return index;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string[]} words\\n */\\nvar WordFilter = function(words) {\\n    this.words = words;\\n    this.map = {};\\n};\\n\\n/** \\n * @param {string} prefix \\n * @param {string} suffix\\n * @return {number}\\n */\\nWordFilter.prototype.f = function(prefix, suffix) {\\n    let index = -1;\\n    \\n    this.map[prefix] = this.map[prefix] || {};\\n    this.map[prefix][suffix] = this.map[prefix][suffix] || null;\\n    \\n    if (this.map[prefix][suffix] !== null) {\\n        return this.map[prefix][suffix];\\n    } \\n    \\n\\t/*\\n\\t* In case of multiple matches, the highest index must be returned\\n\\t* Reverse interating the array so can stop the looping as soon as we match something.\\n\\t*/\\n    for (let i = this.words.length - 1; i >= 0; i--) {\\n        if (\\n\\t\\t\\tthis.words[i].substring(0, prefix.length) === prefix &&\\n\\t\\t\\tthis.words[i].substring(this.words[i].length - suffix.length) === suffix\\n\\t\\t) {\\n            index = i;\\n            break;\\n        }\\n    }\\n    \\n\\t/*\\n\\t* Caching results that were already tested\\n\\t*/\\n    this.map[prefix][suffix] = index;\\n    return index;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1185325,
                "title": "simple-java-hashmap-solution-no-trie-accepted",
                "content": "```\\nclass WordFilter {\\n    int n;\\n    HashMap<String,Integer> hm = new HashMap<>();\\n    public WordFilter(String[] words) {\\n        int i = 0;\\n        for(String a : words){\\n            hm.put(a,i++);\\n        }\\n        n = hm.size();\\n    }\\n    \\n    public int f(String pre, String suf) {\\n        int ind = -1;\\n        int l = 0;\\n        int prelen = pre.length();\\n        int suflen = suf.length();\\n        for(Map.Entry<String,Integer> m : hm.entrySet())\\n        {\\n        int k = m.getKey().length();\\n        if(k>=l && ind<m.getValue() && m.getKey().substring(0,prelen).equals(pre) && m.getKey().substring(k-suflen).equals(suf)){\\n                l = k;\\n                ind = m.getValue();\\n            }\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    int n;\\n    HashMap<String,Integer> hm = new HashMap<>();\\n    public WordFilter(String[] words) {\\n        int i = 0;\\n        for(String a : words){\\n            hm.put(a,i++);\\n        }\\n        n = hm.size();\\n    }\\n    \\n    public int f(String pre, String suf) {\\n        int ind = -1;\\n        int l = 0;\\n        int prelen = pre.length();\\n        int suflen = suf.length();\\n        for(Map.Entry<String,Integer> m : hm.entrySet())\\n        {\\n        int k = m.getKey().length();\\n        if(k>=l && ind<m.getValue() && m.getKey().substring(0,prelen).equals(pre) && m.getKey().substring(k-suflen).equals(suf)){\\n                l = k;\\n                ind = m.getValue();\\n            }\\n        }\\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185296,
                "title": "c-using-trie-with-node-pool-and-some-optimisations",
                "content": "Created two TRIEs one for pref. and other one for suf. where each node of TRIE contains one extra field `i.e.` vector. This vector contains the list of indices of all those word which contain `prefix` string as it\\'s prefix and in the suffix TRIE, this vector stores the indices of all the words which contain `suffix` as it\\'s suffix.\\n\\nNow the main problem is the memory efficient `TRIEs`. So we created a node pool of trie nodes and reused the same pool for each testcase. This way we avoided clearing the `TRIE` thus saving time and also memory.\\n\\n```\\nclass TrieNode {\\npublic:\\n    static const int nax = 26;\\n    TrieNode *CHILD[nax];\\n    vector<int> indices;\\n    bool leaf;\\n};\\nconst int mint = 1e6;\\nTrieNode pool[mint];\\nint cnt = -1;\\nTrieNode *getTrieNodeFromPool() {\\n    TrieNode *node = &pool[++cnt];\\n    node->indices.clear();\\n    for (int i = 0; i < 26; ++i) {\\n        node->CHILD[i] = NULL;\\n    }\\n    node->leaf = false;\\n    return node;\\n}\\n\\nvoid insert(TrieNode* root, string word, int idx) {\\n    TrieNode *ptr = root;\\n    for (int i = 0; i < (int)word.length(); ++i) {\\n        int index = word[i] - \\'a\\';\\n        if(!ptr->CHILD[index])\\n            ptr->CHILD[index] = getTrieNodeFromPool();\\n        //insert the current index in the vector        \\n        ptr->indices.push_back(idx);\\n        ptr = ptr->CHILD[index];\\n    }\\n    ptr->leaf = true;\\n    ptr->indices.push_back(idx);\\n}\\n\\nvector<int> search(TrieNode *root, string word) {\\n    TrieNode *ptr = root;\\n    for(int i = 0; i < (int)word.length(); ++i) {\\n        int index = word[i] - \\'a\\';\\n        if(!ptr->CHILD[index])\\n            return {};\\n        ptr = ptr->CHILD[index];\\n    }\\n    return ptr->indices;\\n}\\n\\nclass WordFilter {\\npublic:\\n    TrieNode *pref, *suf;\\n    WordFilter(vector<string>& words) {\\n        cnt = -1;\\n        pref = getTrieNodeFromPool();\\n        suf = getTrieNodeFromPool();\\n        //insert the index and the word into \\n        //prefix TRIE\\n        for (int i = 0; i < (int)words.size(); ++i) {\\n            insert(pref, words[i], i);\\n        }\\n        \\n        //Then also insert the index and the reverse of the \\n        //word the into suf. TRIE\\n        for (int i = 0; i < (int)words.size(); ++i) {\\n            reverse(words[i].begin(), words[i].end());\\n            insert(suf, words[i], i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        vector<int> lpref = search(pref, prefix);\\n        if((int)lpref.size() == 0) return -1;\\n\\t\\t\\n        reverse(suffix.begin(), suffix.end());\\n\\t\\t\\n        vector<int> rsuf = search(suf, suffix);\\n        if((int)rsuf.size() == 0) return -1;\\n        \\n        while(lpref.size() > 0 && rsuf.size() > 0) {\\n            int rcur = rsuf.back();\\n            int lcur = lpref.back();\\n            if(lcur > rcur)\\n                lpref.pop_back();\\n            else if(lcur < rcur)\\n                rsuf.pop_back();\\n            else\\n                return rcur;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n ```\\nIn case you have doubts, comment them down. We can discuss further.",
                "solutionTags": [],
                "code": "```\\nclass TrieNode {\\npublic:\\n    static const int nax = 26;\\n    TrieNode *CHILD[nax];\\n    vector<int> indices;\\n    bool leaf;\\n};\\nconst int mint = 1e6;\\nTrieNode pool[mint];\\nint cnt = -1;\\nTrieNode *getTrieNodeFromPool() {\\n    TrieNode *node = &pool[++cnt];\\n    node->indices.clear();\\n    for (int i = 0; i < 26; ++i) {\\n        node->CHILD[i] = NULL;\\n    }\\n    node->leaf = false;\\n    return node;\\n}\\n\\nvoid insert(TrieNode* root, string word, int idx) {\\n    TrieNode *ptr = root;\\n    for (int i = 0; i < (int)word.length(); ++i) {\\n        int index = word[i] - \\'a\\';\\n        if(!ptr->CHILD[index])\\n            ptr->CHILD[index] = getTrieNodeFromPool();\\n        //insert the current index in the vector        \\n        ptr->indices.push_back(idx);\\n        ptr = ptr->CHILD[index];\\n    }\\n    ptr->leaf = true;\\n    ptr->indices.push_back(idx);\\n}\\n\\nvector<int> search(TrieNode *root, string word) {\\n    TrieNode *ptr = root;\\n    for(int i = 0; i < (int)word.length(); ++i) {\\n        int index = word[i] - \\'a\\';\\n        if(!ptr->CHILD[index])\\n            return {};\\n        ptr = ptr->CHILD[index];\\n    }\\n    return ptr->indices;\\n}\\n\\nclass WordFilter {\\npublic:\\n    TrieNode *pref, *suf;\\n    WordFilter(vector<string>& words) {\\n        cnt = -1;\\n        pref = getTrieNodeFromPool();\\n        suf = getTrieNodeFromPool();\\n        //insert the index and the word into \\n        //prefix TRIE\\n        for (int i = 0; i < (int)words.size(); ++i) {\\n            insert(pref, words[i], i);\\n        }\\n        \\n        //Then also insert the index and the reverse of the \\n        //word the into suf. TRIE\\n        for (int i = 0; i < (int)words.size(); ++i) {\\n            reverse(words[i].begin(), words[i].end());\\n            insert(suf, words[i], i);\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        vector<int> lpref = search(pref, prefix);\\n        if((int)lpref.size() == 0) return -1;\\n\\t\\t\\n        reverse(suffix.begin(), suffix.end());\\n\\t\\t\\n        vector<int> rsuf = search(suf, suffix);\\n        if((int)rsuf.size() == 0) return -1;\\n        \\n        while(lpref.size() > 0 && rsuf.size() > 0) {\\n            int rcur = rsuf.back();\\n            int lcur = lpref.back();\\n            if(lcur > rcur)\\n                lpref.pop_back();\\n            else if(lcur < rcur)\\n                rsuf.pop_back();\\n            else\\n                return rcur;\\n        }\\n        return -1;\\n    }\\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1185162,
                "title": "typescript-one-hash-map-simple-solution",
                "content": "```\\nclass WordFilter {\\n  wordMap: Map<string, number>;\\n  constructor(words: string[]) {\\n    this.wordMap = new Map<string, number>();\\n    words.forEach((word, i) => {\\n      for (let prefixEnd = 0; prefixEnd < word.length; prefixEnd++) {\\n        const prefix = word.substring(0, prefixEnd + 1);\\n        for (let suffixStart = 0; suffixStart < word.length; suffixStart++) {\\n          const suffix = word.substring(suffixStart);\\n          this.wordMap.set(`${prefix}#${suffix}`, i);\\n        }\\n      }\\n    });\\n  }\\n\\n  f(prefix: string, suffix: string): number {\\n    const key = `${prefix}#${suffix}`;\\n    return this.wordMap.has(key) ? this.wordMap.get(key) : -1;\\n  }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * var obj = new WordFilter(words)\\n * var param_1 = obj.f(prefix,suffix)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass WordFilter {\\n  wordMap: Map<string, number>;\\n  constructor(words: string[]) {\\n    this.wordMap = new Map<string, number>();\\n    words.forEach((word, i) => {\\n      for (let prefixEnd = 0; prefixEnd < word.length; prefixEnd++) {\\n        const prefix = word.substring(0, prefixEnd + 1);\\n        for (let suffixStart = 0; suffixStart < word.length; suffixStart++) {\\n          const suffix = word.substring(suffixStart);\\n          this.wordMap.set(`${prefix}#${suffix}`, i);\\n        }\\n      }\\n    });\\n  }\\n\\n  f(prefix: string, suffix: string): number {\\n    const key = `${prefix}#${suffix}`;\\n    return this.wordMap.has(key) ? this.wordMap.get(key) : -1;\\n  }\\n}\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * var obj = new WordFilter(words)\\n * var param_1 = obj.f(prefix,suffix)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166193,
                "title": "trie-solution-suffix-wrap-easy-to-understand-python",
                "content": "```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        self.trie = {}\\n        self.insertIntoTrie(words)\\n    \\n    # IMPORTANT HELPER method - CRUX of the logic here\\n    # Creates Suffix wrapped words array from one single word, thus call this method for each and every word\\n    # Ex: for word \"ABC\": we will get -> [\"#ABC\", \"C#ABC\", \"BC#ABC\", \"ABC#ABC\"]\\n    # Time: ~~ O(K) where K is length of longest word\\n    def suffixWrap(self, word):\\n        arr = []\\n        word = \"#\" + word\\n        arr.append(word)\\n        n = len(word)\\n        for i in range(n-1, 0, -1):\\n            arr.append(word[i:]+word)\\n        \\n        return arr\\n            \\n    # Time: O(N) * [ O(K) + O(K)] * O(K) ~~ Asymptotically O(N*K^2)\\n    def insertIntoTrie(self, words):\\n        for index, word in enumerate(words): # O(N) where N is number of words\\n            arr = self.suffixWrap(word) # get suffix wrapped array of words for every single word , Time ~~ O(K)\\n            for w in arr: # for every suffix wrapped word, Time: ~~ O(K)\\n                node = self.trie\\n                for ch in w: # Time: O(K) where K is length of longest word\\n                    node = node.setdefault(ch, {})\\n                    node[\\'index\\'] = index\\n\\n                node[\\'word\\'] = w\\n\\n    def f(self, prefix, suffix):\\n        key = suffix + \"#\" + prefix # treat this combo as new prefix for normal prefix search in a trie\\n        node = self.trie\\n        for ch in key: # this is kind of prefix based search in normal trie, where key acts as prefix\\n            if ch not in node:\\n                return -1\\n            node = node[ch]\\n        \\n        return node[\\'index\\']\\n            \\n        \\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass WordFilter(object):\\n\\n    def __init__(self, words):\\n        self.trie = {}\\n        self.insertIntoTrie(words)\\n    \\n    # IMPORTANT HELPER method - CRUX of the logic here\\n    # Creates Suffix wrapped words array from one single word, thus call this method for each and every word\\n    # Ex: for word \"ABC\": we will get -> [\"#ABC\", \"C#ABC\", \"BC#ABC\", \"ABC#ABC\"]\\n    # Time: ~~ O(K) where K is length of longest word\\n    def suffixWrap(self, word):\\n        arr = []\\n        word = \"#\" + word\\n        arr.append(word)\\n        n = len(word)\\n        for i in range(n-1, 0, -1):\\n            arr.append(word[i:]+word)\\n        \\n        return arr\\n            \\n    # Time: O(N) * [ O(K) + O(K)] * O(K) ~~ Asymptotically O(N*K^2)\\n    def insertIntoTrie(self, words):\\n        for index, word in enumerate(words): # O(N) where N is number of words\\n            arr = self.suffixWrap(word) # get suffix wrapped array of words for every single word , Time ~~ O(K)\\n            for w in arr: # for every suffix wrapped word, Time: ~~ O(K)\\n                node = self.trie\\n                for ch in w: # Time: O(K) where K is length of longest word\\n                    node = node.setdefault(ch, {})\\n                    node[\\'index\\'] = index\\n\\n                node[\\'word\\'] = w\\n\\n    def f(self, prefix, suffix):\\n        key = suffix + \"#\" + prefix # treat this combo as new prefix for normal prefix search in a trie\\n        node = self.trie\\n        for ch in key: # this is kind of prefix based search in normal trie, where key acts as prefix\\n            if ch not in node:\\n                return -1\\n            node = node[ch]\\n        \\n        return node[\\'index\\']\\n            \\n        \\n\\n# Your WordFilter object will be instantiated and called as such:\\n# obj = WordFilter(words)\\n# param_1 = obj.f(prefix,suffix)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023773,
                "title": "java-using-two-tries-prefix-and-suffix-clean-and-simple",
                "content": "```\\nclass WordFilter {\\n    class Trie {\\n        private Set<String> words;\\n        private Trie[] children;\\n        \\n        Trie() {\\n            children = new Trie[26];\\n            words = new HashSet<>();\\n        }\\n        \\n        private void add(String word, String value) {\\n            Trie root = this;\\n            \\n            for(char ch : word.toCharArray()) {\\n                int key = ch - \\'a\\';\\n                \\n                if(root.children[key] == null) {\\n                    root.children[key] = new Trie();\\n                }\\n                \\n                root.children[key].words.add(value);\\n                root = root.children[key];\\n            }\\n        }\\n        \\n        private Set<String> search(String word) {\\n            Trie root = this;\\n            for(char ch : word.toCharArray()) {\\n                int key = ch - \\'a\\';\\n                if(root.children[key] == null) {\\n                    return new HashSet<>();\\n                }\\n                \\n                root = root.children[key];\\n            }\\n            \\n            return root.words;\\n        }\\n    }\\n    \\n    private Trie prefixRoot;\\n    private Trie suffixRoot;\\n    \\n    private Map<String, Integer> indexMap;\\n    \\n    public WordFilter(String[] words) {\\n        prefixRoot = new Trie();\\n        suffixRoot = new Trie();\\n        \\n        indexMap = new HashMap<>();\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            indexMap.put(word, i);\\n            \\n            prefixRoot.add(word, word);\\n            \\n            String reverse = reverse(word);\\n            suffixRoot.add(reverse, word);\\n        }\\n    }\\n    \\n    private String reverse(String word) {\\n        char[] chars = word.toCharArray();\\n        \\n        int i = 0;\\n        int j = chars.length - 1;\\n        \\n        while(i < j) {\\n            char temp = chars[i];\\n            chars[i] = chars[j];\\n            chars[j] = temp;\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return new String(chars).toString();\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Set<String> preRes = prefixRoot.search(prefix);\\n        Set<String> sufRes = suffixRoot.search(reverse(suffix));                \\n        \\n        int maxIndex = -1;\\n        \\n        for(String str : preRes) {\\n            if(sufRes.contains(str) && indexMap.get(str) > maxIndex) {\\n                maxIndex = indexMap.get(str);\\n            }\\n        }\\n        \\n        \\n        return maxIndex;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    class Trie {\\n        private Set<String> words;\\n        private Trie[] children;\\n        \\n        Trie() {\\n            children = new Trie[26];\\n            words = new HashSet<>();\\n        }\\n        \\n        private void add(String word, String value) {\\n            Trie root = this;\\n            \\n            for(char ch : word.toCharArray()) {\\n                int key = ch - \\'a\\';\\n                \\n                if(root.children[key] == null) {\\n                    root.children[key] = new Trie();\\n                }\\n                \\n                root.children[key].words.add(value);\\n                root = root.children[key];\\n            }\\n        }\\n        \\n        private Set<String> search(String word) {\\n            Trie root = this;\\n            for(char ch : word.toCharArray()) {\\n                int key = ch - \\'a\\';\\n                if(root.children[key] == null) {\\n                    return new HashSet<>();\\n                }\\n                \\n                root = root.children[key];\\n            }\\n            \\n            return root.words;\\n        }\\n    }\\n    \\n    private Trie prefixRoot;\\n    private Trie suffixRoot;\\n    \\n    private Map<String, Integer> indexMap;\\n    \\n    public WordFilter(String[] words) {\\n        prefixRoot = new Trie();\\n        suffixRoot = new Trie();\\n        \\n        indexMap = new HashMap<>();\\n        \\n        for(int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            \\n            indexMap.put(word, i);\\n            \\n            prefixRoot.add(word, word);\\n            \\n            String reverse = reverse(word);\\n            suffixRoot.add(reverse, word);\\n        }\\n    }\\n    \\n    private String reverse(String word) {\\n        char[] chars = word.toCharArray();\\n        \\n        int i = 0;\\n        int j = chars.length - 1;\\n        \\n        while(i < j) {\\n            char temp = chars[i];\\n            chars[i] = chars[j];\\n            chars[j] = temp;\\n            \\n            i++;\\n            j--;\\n        }\\n        \\n        return new String(chars).toString();\\n    }\\n    \\n    public int f(String prefix, String suffix) {\\n        Set<String> preRes = prefixRoot.search(prefix);\\n        Set<String> sufRes = suffixRoot.search(reverse(suffix));                \\n        \\n        int maxIndex = -1;\\n        \\n        for(String str : preRes) {\\n            if(sufRes.contains(str) && indexMap.get(str) > maxIndex) {\\n                maxIndex = indexMap.get(str);\\n            }\\n        }\\n        \\n        \\n        return maxIndex;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867438,
                "title": "c-modified-trie-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/prefix-and-suffix-search/submissions/\\n    \\n    We use a modified Trie, where each node also contains an index vector\\n    of the words whose chars reach till that node.\\n    Also we create two Tries, one for suffix and other for prefix.\\n    For suffix trie, we reverse the word during construction so that we can search it \\n    from back side starting from root, also during search in suffix tree the word\\n    to be searched also needs to be reversed.\\n    \\n    Finally in the find function we get the indices for both suffix and prefix, we\\n    find the largest common index using a linear traversal.\\n*/\\nclass Trie {\\nprivate:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> leaves;\\n        bool is_string = false;\\n        vector<int> indices;\\n    };\\n    \\n    TrieNode *root_ = new TrieNode();\\n\\npublic:\\n    // Adds a word into Trie\\n    // TC: O(L)\\n    void addWord(string word, int &idx) {\\n        TrieNode *root = root_;\\n        \\n        for(char &c: word) {\\n            // Create a node if it doesn\\'t exists for current char\\n            if(root->leaves.count(c) == 0)\\n                root->leaves[c] = new TrieNode();\\n            root = root->leaves[c];\\n            // save the index of the word which contributed the char\\n            root->indices.emplace_back(idx);\\n        }\\n        // mark the end of string\\n        root->is_string = true;\\n    }\\n    \\n    // Searches for a word in Trie\\n    // TC: O(L), L: length of longest word\\n    vector<int> searchWord(string &word) {\\n        TrieNode *root = root_;\\n        \\n        for(char &c: word) {\\n            if(root->leaves.count(c))\\n                root = root->leaves[c];\\n            else\\n                return {};\\n        }\\n        return root->indices;\\n    }\\n};\\n\\nclass WordFilter {\\n    Trie prefix_trie = Trie();\\n    Trie suffix_trie = Trie();\\npublic:\\n    WordFilter(vector<string>& words) {\\n        // create prefix and suffix Trie\\n        for(int i = 0; i < words.size(); i++) {\\n            prefix_trie.addWord(words[i], i);\\n            // reverse the word\\n            reverse(words[i].begin(), words[i].end());\\n            suffix_trie.addWord(words[i], i);\\n        }\\n    }\\n    \\n    // TC: O(L + L + n + n) ~ O(L + n), n: total number of words\\n    // L: length of the longest word\\n    int f(string prefix, string suffix) {\\n        reverse(suffix.begin(), suffix.end());\\n        auto prefix_indices = prefix_trie.searchWord(prefix);\\n        auto suffix_indices = suffix_trie.searchWord(suffix);\\n        int match = -1;\\n        \\n        int i = prefix_indices.size() - 1, j = suffix_indices.size() - 1;\\n        // find the largest matching index\\n        while(i >= 0 && j >= 0) {\\n            if(prefix_indices[i] == suffix_indices[j]) {\\n                match = prefix_indices[i];\\n                break;\\n            }\\n            else if(prefix_indices[i] < suffix_indices[j])\\n                --j;\\n            else\\n                --i; \\n        }\\n        return match;\\n    }\\n    \\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Trie"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/prefix-and-suffix-search/submissions/\\n    \\n    We use a modified Trie, where each node also contains an index vector\\n    of the words whose chars reach till that node.\\n    Also we create two Tries, one for suffix and other for prefix.\\n    For suffix trie, we reverse the word during construction so that we can search it \\n    from back side starting from root, also during search in suffix tree the word\\n    to be searched also needs to be reversed.\\n    \\n    Finally in the find function we get the indices for both suffix and prefix, we\\n    find the largest common index using a linear traversal.\\n*/\\nclass Trie {\\nprivate:\\n    struct TrieNode {\\n        unordered_map<char, TrieNode*> leaves;\\n        bool is_string = false;\\n        vector<int> indices;\\n    };\\n    \\n    TrieNode *root_ = new TrieNode();\\n\\npublic:\\n    // Adds a word into Trie\\n    // TC: O(L)\\n    void addWord(string word, int &idx) {\\n        TrieNode *root = root_;\\n        \\n        for(char &c: word) {\\n            // Create a node if it doesn\\'t exists for current char\\n            if(root->leaves.count(c) == 0)\\n                root->leaves[c] = new TrieNode();\\n            root = root->leaves[c];\\n            // save the index of the word which contributed the char\\n            root->indices.emplace_back(idx);\\n        }\\n        // mark the end of string\\n        root->is_string = true;\\n    }\\n    \\n    // Searches for a word in Trie\\n    // TC: O(L), L: length of longest word\\n    vector<int> searchWord(string &word) {\\n        TrieNode *root = root_;\\n        \\n        for(char &c: word) {\\n            if(root->leaves.count(c))\\n                root = root->leaves[c];\\n            else\\n                return {};\\n        }\\n        return root->indices;\\n    }\\n};\\n\\nclass WordFilter {\\n    Trie prefix_trie = Trie();\\n    Trie suffix_trie = Trie();\\npublic:\\n    WordFilter(vector<string>& words) {\\n        // create prefix and suffix Trie\\n        for(int i = 0; i < words.size(); i++) {\\n            prefix_trie.addWord(words[i], i);\\n            // reverse the word\\n            reverse(words[i].begin(), words[i].end());\\n            suffix_trie.addWord(words[i], i);\\n        }\\n    }\\n    \\n    // TC: O(L + L + n + n) ~ O(L + n), n: total number of words\\n    // L: length of the longest word\\n    int f(string prefix, string suffix) {\\n        reverse(suffix.begin(), suffix.end());\\n        auto prefix_indices = prefix_trie.searchWord(prefix);\\n        auto suffix_indices = suffix_trie.searchWord(suffix);\\n        int match = -1;\\n        \\n        int i = prefix_indices.size() - 1, j = suffix_indices.size() - 1;\\n        // find the largest matching index\\n        while(i >= 0 && j >= 0) {\\n            if(prefix_indices[i] == suffix_indices[j]) {\\n                match = prefix_indices[i];\\n                break;\\n            }\\n            else if(prefix_indices[i] < suffix_indices[j])\\n                --j;\\n            else\\n                --i; \\n        }\\n        return match;\\n    }\\n    \\n};\\n\\n/**\\n * Your WordFilter object will be instantiated and called as such:\\n * WordFilter* obj = new WordFilter(words);\\n * int param_1 = obj->f(prefix,suffix);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 799039,
                "title": "python-faster-than-95-without-trie",
                "content": "```\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d={}\\n        for j in range(len(words)):\\n            wrd=words[j]\\n            for i in range(len(wrd)+1):\\n                p=wrd[:i]\\n                for k in range(len(wrd)+1):\\n                    s=wrd[k:]\\n                    if p not in self.d:\\n                        self.d[p]={}\\n                    self.d[p][s]=j\\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        a=prefix\\n        b=suffix\\n        if (a not in self.d) or (b not in self.d[a]):\\n            return -1\\n        return self.d[a][b]\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.d={}\\n        for j in range(len(words)):\\n            wrd=words[j]\\n            for i in range(len(wrd)+1):\\n                p=wrd[:i]\\n                for k in range(len(wrd)+1):\\n                    s=wrd[k:]\\n                    if p not in self.d:\\n                        self.d[p]={}\\n                    self.d[p][s]=j\\n        \\n    def f(self, prefix: str, suffix: str) -> int:\\n        a=prefix\\n        b=suffix\\n        if (a not in self.d) or (b not in self.d[a]):\\n            return -1\\n        return self.d[a][b]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788550,
                "title": "python-trie-with-clarifications-and-tips",
                "content": "Three tips to help others avoid making the same mistakes I made:\\n1. When they say maximum weight - \"return the word with given prefix and suffix with maximum weight\" - return the **highest valued indexed word** that has matching prefix and suffix (see ```max(res)``` in the code)\\n2. **Use memoization** to keep track of the results of queries that were already made, this will make the difference between TLE and accepted on some tests.  \\n3. Don\\'t forget to reverse the suffix before searching for it in the suffix-tree.  \\n\\nThe gist of the code is as follows: Create two Trie.  One a prefix tree (words are read forwards) and the other a suffix tree (words are read from back to front).  At each node in the tree, store **the indices** of all the words that are connected to that node in ```self.words```.  For each query, trace the prefix down the prefix-tree to find the set of words indices that have that prefix.  Do the same for the suffix on the suffix-tree and return the largest index that appears in both results.  \\n\\nHope this helps!\\n\\n```python\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.words = set()\\n\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = Node(None)\\n    \\n    def insert(self, index, word):\\n        curr = self.root\\n        curr.words.add(index)\\n        for char in word:\\n            curr.words.add(index)\\n            if char not in curr.children:\\n                curr.children[char] = Node(char)\\n            curr = curr.children[char]\\n        curr.words.add(index)\\n    \\n    def find(self, string):\\n        curr = self.root\\n        for char in string:\\n            if char in curr.children:\\n                curr = curr.children[char]\\n            else:\\n                return set()\\n        return curr.words\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefix = Trie()\\n        self.suffix = Trie()\\n        self.memo = {}\\n        \\n        for i,word in enumerate(words):\\n            self.prefix.insert(i, word)\\n            self.suffix.insert(i, word[::-1])\\n        \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        k = (prefix, suffix)\\n        if k in self.memo:\\n            return self.memo[k]\\n        \\n        a = self.prefix.find(prefix)\\n        b = self.suffix.find(suffix[::-1])\\n        res = a&b\\n        \\n        self.memo[k] = max(res) if res else -1\\n        return self.memo[k]\\n```",
                "solutionTags": [],
                "code": "```max(res)```\n```self.words```\n```python\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.children = {}\\n        self.words = set()\\n\\nclass Trie(object):\\n    \\n    def __init__(self):\\n        self.root = Node(None)\\n    \\n    def insert(self, index, word):\\n        curr = self.root\\n        curr.words.add(index)\\n        for char in word:\\n            curr.words.add(index)\\n            if char not in curr.children:\\n                curr.children[char] = Node(char)\\n            curr = curr.children[char]\\n        curr.words.add(index)\\n    \\n    def find(self, string):\\n        curr = self.root\\n        for char in string:\\n            if char in curr.children:\\n                curr = curr.children[char]\\n            else:\\n                return set()\\n        return curr.words\\n\\nclass WordFilter:\\n\\n    def __init__(self, words: List[str]):\\n        self.prefix = Trie()\\n        self.suffix = Trie()\\n        self.memo = {}\\n        \\n        for i,word in enumerate(words):\\n            self.prefix.insert(i, word)\\n            self.suffix.insert(i, word[::-1])\\n        \\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        k = (prefix, suffix)\\n        if k in self.memo:\\n            return self.memo[k]\\n        \\n        a = self.prefix.find(prefix)\\n        b = self.suffix.find(suffix[::-1])\\n        res = a&b\\n        \\n        self.memo[k] = max(res) if res else -1\\n        return self.memo[k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665751,
                "title": "java-trie-easy-to-understand",
                "content": "```\\nclass WordFilter {\\n    class Trie {\\n        Trie[] children;\\n        boolean isWord;\\n        int weight;\\n        String word;\\n\\n        Trie() {\\n            children = new Trie[26];\\n            isWord = false;\\n            weight = -1;\\n            word = \"\";\\n        }\\n    }\\n\\n    Trie root;\\n\\n\\n    public WordFilter(String[] words) {\\n        root = new Trie();\\n        for (int i = 0; i < words.length; i++) {\\n            create(words[i], i);\\n        }\\n    }\\n\\n    private int getIdx(char c) {\\n        return c - \\'a\\';\\n    }\\n\\n    private void create(String word, int w) {\\n        Trie cur = root;\\n        int i;\\n        for (char c : word.toCharArray()) {\\n            i = getIdx(c);\\n            if (cur.children[i] == null) {\\n                cur.children[i] = new Trie();\\n            }\\n            cur = cur.children[i];\\n        }\\n        cur.isWord = true;\\n        cur.weight = w;\\n        cur.word = word;\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        Trie cur = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (cur.children[getIdx(c)] == null) return -1;\\n            cur = cur.children[getIdx(c)];\\n        }\\n        return helper(cur, suffix, -1);\\n    }\\n\\n    private int helper(Trie node, String suffix, int w) {\\n        int ans = w;\\n        if (node.isWord && node.word.endsWith(suffix)) {\\n            ans = Math.max(ans, node.weight);\\n        }\\n        for (Trie child : node.children) {\\n            if (child != null) {\\n                ans = Math.max(helper(child, suffix, ans), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    class Trie {\\n        Trie[] children;\\n        boolean isWord;\\n        int weight;\\n        String word;\\n\\n        Trie() {\\n            children = new Trie[26];\\n            isWord = false;\\n            weight = -1;\\n            word = \"\";\\n        }\\n    }\\n\\n    Trie root;\\n\\n\\n    public WordFilter(String[] words) {\\n        root = new Trie();\\n        for (int i = 0; i < words.length; i++) {\\n            create(words[i], i);\\n        }\\n    }\\n\\n    private int getIdx(char c) {\\n        return c - \\'a\\';\\n    }\\n\\n    private void create(String word, int w) {\\n        Trie cur = root;\\n        int i;\\n        for (char c : word.toCharArray()) {\\n            i = getIdx(c);\\n            if (cur.children[i] == null) {\\n                cur.children[i] = new Trie();\\n            }\\n            cur = cur.children[i];\\n        }\\n        cur.isWord = true;\\n        cur.weight = w;\\n        cur.word = word;\\n    }\\n\\n    public int f(String prefix, String suffix) {\\n        Trie cur = root;\\n        for (char c : prefix.toCharArray()) {\\n            if (cur.children[getIdx(c)] == null) return -1;\\n            cur = cur.children[getIdx(c)];\\n        }\\n        return helper(cur, suffix, -1);\\n    }\\n\\n    private int helper(Trie node, String suffix, int w) {\\n        int ans = w;\\n        if (node.isWord && node.word.endsWith(suffix)) {\\n            ans = Math.max(ans, node.weight);\\n        }\\n        for (Trie child : node.children) {\\n            if (child != null) {\\n                ans = Math.max(helper(child, suffix, ans), ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568342,
                "title": "double-trie-tree-with-python",
                "content": "Use two Trie trees to store prefix and suffix separately. O(nLogn) to construct the tree, O(n) to search, whereas n is the length of words list\\n```\\nclass WordFilter:\\n\\n    class Trie:\\n        def __init__(self):\\n            # sub-tree, should have 26 nodes\\n            self.branch = {}\\n            # a list of index in the word list\\n            self.nodes = []\\n\\n    def __init__(self, words: List[str]):\\n        if len(words) == 0: return\\n        self.prefix, self.suffix = self.Trie(), self.Trie()\\n        # to match empty prefix/suffix\\n        self.prefix.nodes.extend(range(0, len(words)))\\n        self.suffix.nodes.extend(range(0, len(words)))\\n        for i in range(0, len(words)):\\n            word = words[i]\\n            # construct prefix tree\\n            tmp = self.prefix\\n            for j in range(0, len(word)):\\n                if not word[j] in tmp.branch:\\n                    tmp.branch[word[j]] = self.Trie()\\n                tmp = tmp.branch[word[j]]\\n                tmp.nodes.append(i)\\n\\n            # construct suffix tree\\n            tmp = self.suffix\\n            for j in range(len(word)-1, -1, -1):\\n                if not word[j] in tmp.branch:\\n                    tmp.branch[word[j]] = self.Trie()\\n                tmp = tmp.branch[word[j]]\\n                tmp.nodes.append(i)\\n\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefix_words, suffix_words = self.find(prefix, self.prefix), self.find(suffix[::-1], self.suffix)\\n        i, j = len(prefix_words) - 1, len(suffix_words) - 1\\n        while i > -1 and j > -1:\\n            if prefix_words[i] == suffix_words[j]: return prefix_words[i]\\n            elif prefix_words[i] > suffix_words[j]: i -= 1\\n            else: j -= 1\\n        return -1\\n\\n    def find(self, string: str, tree: Trie) -> List:\\n        if not tree: return []\\n        for i in range(0, len(string)):\\n            if string[i] in tree.branch: tree = tree.branch.get(string[i])\\n            else: return []\\n        return tree.nodes\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter:\\n\\n    class Trie:\\n        def __init__(self):\\n            # sub-tree, should have 26 nodes\\n            self.branch = {}\\n            # a list of index in the word list\\n            self.nodes = []\\n\\n    def __init__(self, words: List[str]):\\n        if len(words) == 0: return\\n        self.prefix, self.suffix = self.Trie(), self.Trie()\\n        # to match empty prefix/suffix\\n        self.prefix.nodes.extend(range(0, len(words)))\\n        self.suffix.nodes.extend(range(0, len(words)))\\n        for i in range(0, len(words)):\\n            word = words[i]\\n            # construct prefix tree\\n            tmp = self.prefix\\n            for j in range(0, len(word)):\\n                if not word[j] in tmp.branch:\\n                    tmp.branch[word[j]] = self.Trie()\\n                tmp = tmp.branch[word[j]]\\n                tmp.nodes.append(i)\\n\\n            # construct suffix tree\\n            tmp = self.suffix\\n            for j in range(len(word)-1, -1, -1):\\n                if not word[j] in tmp.branch:\\n                    tmp.branch[word[j]] = self.Trie()\\n                tmp = tmp.branch[word[j]]\\n                tmp.nodes.append(i)\\n\\n\\n    def f(self, prefix: str, suffix: str) -> int:\\n        prefix_words, suffix_words = self.find(prefix, self.prefix), self.find(suffix[::-1], self.suffix)\\n        i, j = len(prefix_words) - 1, len(suffix_words) - 1\\n        while i > -1 and j > -1:\\n            if prefix_words[i] == suffix_words[j]: return prefix_words[i]\\n            elif prefix_words[i] > suffix_words[j]: i -= 1\\n            else: j -= 1\\n        return -1\\n\\n    def find(self, string: str, tree: Trie) -> List:\\n        if not tree: return []\\n        for i in range(0, len(string)):\\n            if string[i] in tree.branch: tree = tree.branch.get(string[i])\\n            else: return []\\n        return tree.nodes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559635,
                "title": "c-25-100",
                "content": "```\\nclass WordFilter {\\n    unordered_map<string, int> weights;\\n    unordered_map<string, unordered_set<string>> byPrefix;\\n    unordered_map<string, unordered_set<string>> bySuffix;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            const string& word = words[i];\\n            weights[word] = i;\\n            byPrefix[\"\"].insert(word);\\n            bySuffix[\"\"].insert(word);\\n            for (int len = 1; len <= word.size(); ++len) {\\n                byPrefix[word.substr(0, len)].insert(word);\\n                bySuffix[word.substr(word.size() - len, len)].insert(word);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        int weight = -1;\\n        if (byPrefix.count(prefix) > 0 && bySuffix.count(suffix) > 0) {\\n            for (const auto& word : byPrefix[prefix]) {\\n                if (bySuffix[suffix].count(word) == 1) {\\n                    int w = weights[word];\\n                    if (w > weight)\\n                        weight = w;\\n                }\\n            }\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter {\\n    unordered_map<string, int> weights;\\n    unordered_map<string, unordered_set<string>> byPrefix;\\n    unordered_map<string, unordered_set<string>> bySuffix;\\npublic:\\n    WordFilter(vector<string>& words) {\\n        for (int i = 0; i < words.size(); ++i) {\\n            const string& word = words[i];\\n            weights[word] = i;\\n            byPrefix[\"\"].insert(word);\\n            bySuffix[\"\"].insert(word);\\n            for (int len = 1; len <= word.size(); ++len) {\\n                byPrefix[word.substr(0, len)].insert(word);\\n                bySuffix[word.substr(word.size() - len, len)].insert(word);\\n            }\\n        }\\n    }\\n    \\n    int f(string prefix, string suffix) {\\n        int weight = -1;\\n        if (byPrefix.count(prefix) > 0 && bySuffix.count(suffix) > 0) {\\n            for (const auto& word : byPrefix[prefix]) {\\n                if (bySuffix[suffix].count(word) == 1) {\\n                    int w = weights[word];\\n                    if (w > weight)\\n                        weight = w;\\n                }\\n            }\\n        }\\n        return weight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527570,
                "title": "trie-of-tries-add-o-w-2-find-o-w-beats-100-of-scala-solutions-the-another-one",
                "content": "We can use an ordinary prefix based Trie, but in every its node we can keep a suffix based trie,\\ncontaining all words in that node. In every node of the suffix based trie we can keep the best weight for this pair\\nof prefix and suffix.\\n Example: \"aa\", \"ab\", \"b\", \"a\"\\n Our trie looks like this:\\n![image](https://assets.leetcode.com/users/gorokhovsky/image_1583236471.png)\\n```\\nclass WordFilter(_words: Array[String]) {\\n  val data = new Trie() // create the trie\\n  _words.zipWithIndex.foreach(w => data.add(w._1, w._2)) // populate the trie\\n\\n  def f(prefix: String, suffix: String): Int = data.find(prefix, 0, suffix) // find in the trie\\n}\\n\\n// the main, prefix based, trie\\nclass Trie() {\\n  private val reverse = new TrieReversed() // suffix based trie containing all words in the node\\n  private val data = Array.fill[Option[Trie]](26)(None)\\n\\n  def add(s: String, w: Int, i: Int = 0): Unit = {\\n    if (i < s.length)\\n      data(s(i) - \\'a\\').getOrElse {\\n        val tr = new Trie\\n        data(s(i) - \\'a\\') = Some(tr)\\n        tr\\n      }.add(s, w, i + 1)\\n\\n    reverse.add(s, w, s.length - 1) // for every node - add the word to the suffix based trie\\n  }\\n\\n  def find(p: String, i: Int, s: String): Int =\\n    if (i == p.length) reverse.find(s, s.length - 1) // we found all words with the prefix, now filter them by suffix\\n    else data(p(i) - \\'a\\').map(_.find(p, i + 1, s)).getOrElse(-1)\\n}\\n\\n// suffix based trie\\nclass TrieReversed() {\\n  private val data = Array.fill[Option[TrieReversed]](26)(None)\\n  private var w: Int = -1 // for every node we store the best weight\\n  \\n  def add(s: String, _w: Int, i: Int): Unit = {\\n    if (i >= 0)\\n      data(s(i) - \\'a\\').getOrElse {\\n        val tr = new TrieReversed()\\n        data(s(i) - \\'a\\') = Some(tr)\\n        tr\\n      }.add(s, _w, i - 1)\\n\\n    w = _w // actually, there should be `w = w max _w`, but we add the words in the succession, so _w > w always\\n  }\\n\\n  def find (s: String, i: Int): Int =\\n    if (i >= 0) data(s(i) - \\'a\\').map(_.find(s, i - 1)).getOrElse(-1)\\n    else w\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass WordFilter(_words: Array[String]) {\\n  val data = new Trie() // create the trie\\n  _words.zipWithIndex.foreach(w => data.add(w._1, w._2)) // populate the trie\\n\\n  def f(prefix: String, suffix: String): Int = data.find(prefix, 0, suffix) // find in the trie\\n}\\n\\n// the main, prefix based, trie\\nclass Trie() {\\n  private val reverse = new TrieReversed() // suffix based trie containing all words in the node\\n  private val data = Array.fill[Option[Trie]](26)(None)\\n\\n  def add(s: String, w: Int, i: Int = 0): Unit = {\\n    if (i < s.length)\\n      data(s(i) - \\'a\\').getOrElse {\\n        val tr = new Trie\\n        data(s(i) - \\'a\\') = Some(tr)\\n        tr\\n      }.add(s, w, i + 1)\\n\\n    reverse.add(s, w, s.length - 1) // for every node - add the word to the suffix based trie\\n  }\\n\\n  def find(p: String, i: Int, s: String): Int =\\n    if (i == p.length) reverse.find(s, s.length - 1) // we found all words with the prefix, now filter them by suffix\\n    else data(p(i) - \\'a\\').map(_.find(p, i + 1, s)).getOrElse(-1)\\n}\\n\\n// suffix based trie\\nclass TrieReversed() {\\n  private val data = Array.fill[Option[TrieReversed]](26)(None)\\n  private var w: Int = -1 // for every node we store the best weight\\n  \\n  def add(s: String, _w: Int, i: Int): Unit = {\\n    if (i >= 0)\\n      data(s(i) - \\'a\\').getOrElse {\\n        val tr = new TrieReversed()\\n        data(s(i) - \\'a\\') = Some(tr)\\n        tr\\n      }.add(s, _w, i - 1)\\n\\n    w = _w // actually, there should be `w = w max _w`, but we add the words in the succession, so _w > w always\\n  }\\n\\n  def find (s: String, i: Int): Int =\\n    if (i >= 0) data(s(i) - \\'a\\').map(_.find(s, i - 1)).getOrElse(-1)\\n    else w\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567144,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/prefix-and-suffix-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Trie + Set Intersection [Time Limit Exceeded]\n\n  \n**Approach 2:** Paired Trie [Accepted]\n\n  \n**Approach 3:** Trie of Suffix Wrapped Words [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manafa",
                        "content": "When i try to run code I got error:\\n\"Input methods size does not equal to params size or equals to 0.\"\\nAdmins, please fix it."
                    },
                    {
                        "username": "leolaw",
                        "content": "When I am running the test case  [[[\"apple\"]], [\"a\",\"e\"]]\\n\\nRun code result gave me this expected answer:\\nnum tokens (7) expected to be equal to array_size (2) + 1 for JSON [[[[\"apple\"]], [\"a\",\"e\"]]].\\n\\nAnd the ~~difficult~~ *default* test case [\"WordFilter\",\"f\"] is also returning error in expected answer:\\nExpected JSON [] to be of type JSMN_ARRAY but got UNKNOWN.\\n\\n\\nAnd input format is never described in the problem. How can I figure out the input format for testing?\\n\\nI used C++ for this problem.\\n\\nEdit: Fixed a typo, I meant \"default test case\"."
                    },
                    {
                        "username": "hosua",
                        "content": "Maybe I'm misunderstanding something, but why is the answer to this output supposed to be index 1?\n ```\n[\"WordFilter\",\"f\"]\n[[[\"abbba\",\"abba\"]],[\"ab\",\"ba\"]]\n\nOutput\n  [null,0]\nExpected\n  [null,1]\n```\n\nSince \"ab\" and \"ba\" are both the prefixes and suffixes of both words in the list, shouldn't it return index 0, since len(\"abbba\") > len(\"abba\")?"
                    },
                    {
                        "username": "R4Ks",
                        "content": "[@mhayter1](/mhayter1)  It took me a while to figure it out lmao"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "lol i was going to paste the same question. That was confusing :D"
                    },
                    {
                        "username": "hosua",
                        "content": "[@mhayter1](/mhayter1) Ah! Okay, I\\'ve actually been stumped on this for quite a while, thanks for pointing that out.\\n\\nAnd yeah, I agree. The wording on this problem could use some work, that part was most certainly unclear to me. "
                    },
                    {
                        "username": "mhayter1",
                        "content": " If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. \n\nI agree. The wording is poor. It probably should read: \"...return the greatest index.\" Since 1>0, 1 is the answer."
                    },
                    {
                        "username": "8939123",
                        "content": "Input:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\n\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nI guess the input contains a series of test cases, What are the test cases? Is it purposely hidden for the contest? I got some wrong answers but had no clue where is wrong :("
                    },
                    {
                        "username": "kmiku7",
                        "content": "What does the `largest` mean in the problem? The item has the largest index in the array? Or in alphabetical order?"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "I was confused by this too, it means the largest index"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "index it is !"
                    }
                ]
            },
            {
                "id": 1567283,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/prefix-and-suffix-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Trie + Set Intersection [Time Limit Exceeded]\n\n  \n**Approach 2:** Paired Trie [Accepted]\n\n  \n**Approach 3:** Trie of Suffix Wrapped Words [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manafa",
                        "content": "When i try to run code I got error:\\n\"Input methods size does not equal to params size or equals to 0.\"\\nAdmins, please fix it."
                    },
                    {
                        "username": "leolaw",
                        "content": "When I am running the test case  [[[\"apple\"]], [\"a\",\"e\"]]\\n\\nRun code result gave me this expected answer:\\nnum tokens (7) expected to be equal to array_size (2) + 1 for JSON [[[[\"apple\"]], [\"a\",\"e\"]]].\\n\\nAnd the ~~difficult~~ *default* test case [\"WordFilter\",\"f\"] is also returning error in expected answer:\\nExpected JSON [] to be of type JSMN_ARRAY but got UNKNOWN.\\n\\n\\nAnd input format is never described in the problem. How can I figure out the input format for testing?\\n\\nI used C++ for this problem.\\n\\nEdit: Fixed a typo, I meant \"default test case\"."
                    },
                    {
                        "username": "hosua",
                        "content": "Maybe I'm misunderstanding something, but why is the answer to this output supposed to be index 1?\n ```\n[\"WordFilter\",\"f\"]\n[[[\"abbba\",\"abba\"]],[\"ab\",\"ba\"]]\n\nOutput\n  [null,0]\nExpected\n  [null,1]\n```\n\nSince \"ab\" and \"ba\" are both the prefixes and suffixes of both words in the list, shouldn't it return index 0, since len(\"abbba\") > len(\"abba\")?"
                    },
                    {
                        "username": "R4Ks",
                        "content": "[@mhayter1](/mhayter1)  It took me a while to figure it out lmao"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "lol i was going to paste the same question. That was confusing :D"
                    },
                    {
                        "username": "hosua",
                        "content": "[@mhayter1](/mhayter1) Ah! Okay, I\\'ve actually been stumped on this for quite a while, thanks for pointing that out.\\n\\nAnd yeah, I agree. The wording on this problem could use some work, that part was most certainly unclear to me. "
                    },
                    {
                        "username": "mhayter1",
                        "content": " If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. \n\nI agree. The wording is poor. It probably should read: \"...return the greatest index.\" Since 1>0, 1 is the answer."
                    },
                    {
                        "username": "8939123",
                        "content": "Input:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\n\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nI guess the input contains a series of test cases, What are the test cases? Is it purposely hidden for the contest? I got some wrong answers but had no clue where is wrong :("
                    },
                    {
                        "username": "kmiku7",
                        "content": "What does the `largest` mean in the problem? The item has the largest index in the array? Or in alphabetical order?"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "I was confused by this too, it means the largest index"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "index it is !"
                    }
                ]
            },
            {
                "id": 1568001,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/prefix-and-suffix-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Trie + Set Intersection [Time Limit Exceeded]\n\n  \n**Approach 2:** Paired Trie [Accepted]\n\n  \n**Approach 3:** Trie of Suffix Wrapped Words [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manafa",
                        "content": "When i try to run code I got error:\\n\"Input methods size does not equal to params size or equals to 0.\"\\nAdmins, please fix it."
                    },
                    {
                        "username": "leolaw",
                        "content": "When I am running the test case  [[[\"apple\"]], [\"a\",\"e\"]]\\n\\nRun code result gave me this expected answer:\\nnum tokens (7) expected to be equal to array_size (2) + 1 for JSON [[[[\"apple\"]], [\"a\",\"e\"]]].\\n\\nAnd the ~~difficult~~ *default* test case [\"WordFilter\",\"f\"] is also returning error in expected answer:\\nExpected JSON [] to be of type JSMN_ARRAY but got UNKNOWN.\\n\\n\\nAnd input format is never described in the problem. How can I figure out the input format for testing?\\n\\nI used C++ for this problem.\\n\\nEdit: Fixed a typo, I meant \"default test case\"."
                    },
                    {
                        "username": "hosua",
                        "content": "Maybe I'm misunderstanding something, but why is the answer to this output supposed to be index 1?\n ```\n[\"WordFilter\",\"f\"]\n[[[\"abbba\",\"abba\"]],[\"ab\",\"ba\"]]\n\nOutput\n  [null,0]\nExpected\n  [null,1]\n```\n\nSince \"ab\" and \"ba\" are both the prefixes and suffixes of both words in the list, shouldn't it return index 0, since len(\"abbba\") > len(\"abba\")?"
                    },
                    {
                        "username": "R4Ks",
                        "content": "[@mhayter1](/mhayter1)  It took me a while to figure it out lmao"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "lol i was going to paste the same question. That was confusing :D"
                    },
                    {
                        "username": "hosua",
                        "content": "[@mhayter1](/mhayter1) Ah! Okay, I\\'ve actually been stumped on this for quite a while, thanks for pointing that out.\\n\\nAnd yeah, I agree. The wording on this problem could use some work, that part was most certainly unclear to me. "
                    },
                    {
                        "username": "mhayter1",
                        "content": " If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. \n\nI agree. The wording is poor. It probably should read: \"...return the greatest index.\" Since 1>0, 1 is the answer."
                    },
                    {
                        "username": "8939123",
                        "content": "Input:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\n\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nI guess the input contains a series of test cases, What are the test cases? Is it purposely hidden for the contest? I got some wrong answers but had no clue where is wrong :("
                    },
                    {
                        "username": "kmiku7",
                        "content": "What does the `largest` mean in the problem? The item has the largest index in the array? Or in alphabetical order?"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "I was confused by this too, it means the largest index"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "index it is !"
                    }
                ]
            },
            {
                "id": 1662929,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/prefix-and-suffix-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Trie + Set Intersection [Time Limit Exceeded]\n\n  \n**Approach 2:** Paired Trie [Accepted]\n\n  \n**Approach 3:** Trie of Suffix Wrapped Words [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manafa",
                        "content": "When i try to run code I got error:\\n\"Input methods size does not equal to params size or equals to 0.\"\\nAdmins, please fix it."
                    },
                    {
                        "username": "leolaw",
                        "content": "When I am running the test case  [[[\"apple\"]], [\"a\",\"e\"]]\\n\\nRun code result gave me this expected answer:\\nnum tokens (7) expected to be equal to array_size (2) + 1 for JSON [[[[\"apple\"]], [\"a\",\"e\"]]].\\n\\nAnd the ~~difficult~~ *default* test case [\"WordFilter\",\"f\"] is also returning error in expected answer:\\nExpected JSON [] to be of type JSMN_ARRAY but got UNKNOWN.\\n\\n\\nAnd input format is never described in the problem. How can I figure out the input format for testing?\\n\\nI used C++ for this problem.\\n\\nEdit: Fixed a typo, I meant \"default test case\"."
                    },
                    {
                        "username": "hosua",
                        "content": "Maybe I'm misunderstanding something, but why is the answer to this output supposed to be index 1?\n ```\n[\"WordFilter\",\"f\"]\n[[[\"abbba\",\"abba\"]],[\"ab\",\"ba\"]]\n\nOutput\n  [null,0]\nExpected\n  [null,1]\n```\n\nSince \"ab\" and \"ba\" are both the prefixes and suffixes of both words in the list, shouldn't it return index 0, since len(\"abbba\") > len(\"abba\")?"
                    },
                    {
                        "username": "R4Ks",
                        "content": "[@mhayter1](/mhayter1)  It took me a while to figure it out lmao"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "lol i was going to paste the same question. That was confusing :D"
                    },
                    {
                        "username": "hosua",
                        "content": "[@mhayter1](/mhayter1) Ah! Okay, I\\'ve actually been stumped on this for quite a while, thanks for pointing that out.\\n\\nAnd yeah, I agree. The wording on this problem could use some work, that part was most certainly unclear to me. "
                    },
                    {
                        "username": "mhayter1",
                        "content": " If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. \n\nI agree. The wording is poor. It probably should read: \"...return the greatest index.\" Since 1>0, 1 is the answer."
                    },
                    {
                        "username": "8939123",
                        "content": "Input:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\n\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nI guess the input contains a series of test cases, What are the test cases? Is it purposely hidden for the contest? I got some wrong answers but had no clue where is wrong :("
                    },
                    {
                        "username": "kmiku7",
                        "content": "What does the `largest` mean in the problem? The item has the largest index in the array? Or in alphabetical order?"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "I was confused by this too, it means the largest index"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "index it is !"
                    }
                ]
            },
            {
                "id": 1569159,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/prefix-and-suffix-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Trie + Set Intersection [Time Limit Exceeded]\n\n  \n**Approach 2:** Paired Trie [Accepted]\n\n  \n**Approach 3:** Trie of Suffix Wrapped Words [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manafa",
                        "content": "When i try to run code I got error:\\n\"Input methods size does not equal to params size or equals to 0.\"\\nAdmins, please fix it."
                    },
                    {
                        "username": "leolaw",
                        "content": "When I am running the test case  [[[\"apple\"]], [\"a\",\"e\"]]\\n\\nRun code result gave me this expected answer:\\nnum tokens (7) expected to be equal to array_size (2) + 1 for JSON [[[[\"apple\"]], [\"a\",\"e\"]]].\\n\\nAnd the ~~difficult~~ *default* test case [\"WordFilter\",\"f\"] is also returning error in expected answer:\\nExpected JSON [] to be of type JSMN_ARRAY but got UNKNOWN.\\n\\n\\nAnd input format is never described in the problem. How can I figure out the input format for testing?\\n\\nI used C++ for this problem.\\n\\nEdit: Fixed a typo, I meant \"default test case\"."
                    },
                    {
                        "username": "hosua",
                        "content": "Maybe I'm misunderstanding something, but why is the answer to this output supposed to be index 1?\n ```\n[\"WordFilter\",\"f\"]\n[[[\"abbba\",\"abba\"]],[\"ab\",\"ba\"]]\n\nOutput\n  [null,0]\nExpected\n  [null,1]\n```\n\nSince \"ab\" and \"ba\" are both the prefixes and suffixes of both words in the list, shouldn't it return index 0, since len(\"abbba\") > len(\"abba\")?"
                    },
                    {
                        "username": "R4Ks",
                        "content": "[@mhayter1](/mhayter1)  It took me a while to figure it out lmao"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "lol i was going to paste the same question. That was confusing :D"
                    },
                    {
                        "username": "hosua",
                        "content": "[@mhayter1](/mhayter1) Ah! Okay, I\\'ve actually been stumped on this for quite a while, thanks for pointing that out.\\n\\nAnd yeah, I agree. The wording on this problem could use some work, that part was most certainly unclear to me. "
                    },
                    {
                        "username": "mhayter1",
                        "content": " If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. \n\nI agree. The wording is poor. It probably should read: \"...return the greatest index.\" Since 1>0, 1 is the answer."
                    },
                    {
                        "username": "8939123",
                        "content": "Input:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\n\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nI guess the input contains a series of test cases, What are the test cases? Is it purposely hidden for the contest? I got some wrong answers but had no clue where is wrong :("
                    },
                    {
                        "username": "kmiku7",
                        "content": "What does the `largest` mean in the problem? The item has the largest index in the array? Or in alphabetical order?"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "I was confused by this too, it means the largest index"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "index it is !"
                    }
                ]
            },
            {
                "id": 1707486,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for June, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/prefix-and-suffix-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Trie + Set Intersection [Time Limit Exceeded]\n\n  \n**Approach 2:** Paired Trie [Accepted]\n\n  \n**Approach 3:** Trie of Suffix Wrapped Words [Accepted]\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "manafa",
                        "content": "When i try to run code I got error:\\n\"Input methods size does not equal to params size or equals to 0.\"\\nAdmins, please fix it."
                    },
                    {
                        "username": "leolaw",
                        "content": "When I am running the test case  [[[\"apple\"]], [\"a\",\"e\"]]\\n\\nRun code result gave me this expected answer:\\nnum tokens (7) expected to be equal to array_size (2) + 1 for JSON [[[[\"apple\"]], [\"a\",\"e\"]]].\\n\\nAnd the ~~difficult~~ *default* test case [\"WordFilter\",\"f\"] is also returning error in expected answer:\\nExpected JSON [] to be of type JSMN_ARRAY but got UNKNOWN.\\n\\n\\nAnd input format is never described in the problem. How can I figure out the input format for testing?\\n\\nI used C++ for this problem.\\n\\nEdit: Fixed a typo, I meant \"default test case\"."
                    },
                    {
                        "username": "hosua",
                        "content": "Maybe I'm misunderstanding something, but why is the answer to this output supposed to be index 1?\n ```\n[\"WordFilter\",\"f\"]\n[[[\"abbba\",\"abba\"]],[\"ab\",\"ba\"]]\n\nOutput\n  [null,0]\nExpected\n  [null,1]\n```\n\nSince \"ab\" and \"ba\" are both the prefixes and suffixes of both words in the list, shouldn't it return index 0, since len(\"abbba\") > len(\"abba\")?"
                    },
                    {
                        "username": "R4Ks",
                        "content": "[@mhayter1](/mhayter1)  It took me a while to figure it out lmao"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "lol i was going to paste the same question. That was confusing :D"
                    },
                    {
                        "username": "hosua",
                        "content": "[@mhayter1](/mhayter1) Ah! Okay, I\\'ve actually been stumped on this for quite a while, thanks for pointing that out.\\n\\nAnd yeah, I agree. The wording on this problem could use some work, that part was most certainly unclear to me. "
                    },
                    {
                        "username": "mhayter1",
                        "content": " If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1. \n\nI agree. The wording is poor. It probably should read: \"...return the greatest index.\" Since 1>0, 1 is the answer."
                    },
                    {
                        "username": "8939123",
                        "content": "Input:\\n[[[\"apple\"]], [\"a\",\"e\"]]\\n\\nExpected:\\n[null,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]\\n\\nI guess the input contains a series of test cases, What are the test cases? Is it purposely hidden for the contest? I got some wrong answers but had no clue where is wrong :("
                    },
                    {
                        "username": "kmiku7",
                        "content": "What does the `largest` mean in the problem? The item has the largest index in the array? Or in alphabetical order?"
                    },
                    {
                        "username": "c-m-d-",
                        "content": "I was confused by this too, it means the largest index"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "index it is !"
                    }
                ]
            }
        ]
    }
]