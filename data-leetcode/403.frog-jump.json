[
    {
        "title": "Frog Jump",
        "question_content": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\nGiven a list of stones&nbsp;positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\nIf the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n&nbsp;\nExample 1:\n\nInput: stones = [0,1,3,5,6,8,12,17]\nOutput: true\nExplanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\nExample 2:\n\nInput: stones = [0,1,2,3,4,8,9,11]\nOutput: false\nExplanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n\n&nbsp;\nConstraints:\n\n\t2 <= stones.length <= 2000\n\t0 <= stones[i] <= 231 - 1\n\tstones[0] == 0\n\tstones&nbsp;is sorted in a strictly increasing order.",
        "solutions": [
            {
                "id": 88824,
                "title": "very-easy-to-understand-java-solution-with-explanations",
                "content": "Use map to represent a mapping from the stone (not index) to the steps that can be taken from this stone.\\n\\nso this will be \\n\\n[0,1,3,5,6,8,12,17]\\n\\n{17=[], 0=[1], 1=[1, 2], 3=[1, 2, 3], 5=[1, 2, 3], 6=[1, 2, 3, 4], 8=[1, 2, 3, 4], 12=[3, 4, 5]}\\n\\nNotice that no need to calculate the last stone.\\n\\nOn each step, we look if any other stone can be reached from it, if so, we update that stone's steps by adding step, step + 1, step - 1. If we can reach the final stone, we return true. No need to calculate to the last stone.\\n\\nHere is the code:\\n\\n```\\n    public boolean canCross(int[] stones) {\\n        if (stones.length == 0) {\\n        \\treturn true;\\n        }\\n        \\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<Integer, HashSet<Integer>>(stones.length);\\n        map.put(0, new HashSet<Integer>());\\n        map.get(0).add(1);\\n        for (int i = 1; i < stones.length; i++) {\\n        \\tmap.put(stones[i], new HashSet<Integer>() );\\n        }\\n        \\n        for (int i = 0; i < stones.length - 1; i++) {\\n        \\tint stone = stones[i];\\n        \\tfor (int step : map.get(stone)) {\\n        \\t\\tint reach = step + stone;\\n        \\t\\tif (reach == stones[stones.length - 1]) {\\n        \\t\\t\\treturn true;\\n        \\t\\t}\\n        \\t\\tHashSet<Integer> set = map.get(reach);\\n        \\t\\tif (set != null) {\\n        \\t\\t    set.add(step);\\n        \\t\\t    if (step - 1 > 0) set.add(step - 1);\\n        \\t\\t    set.add(step + 1);\\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return false;\\n    } \\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canCross(int[] stones) {\\n        if (stones.length == 0) {\\n        \\treturn true;\\n        }\\n        \\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<Integer, HashSet<Integer>>(stones.length);\\n        map.put(0, new HashSet<Integer>());\\n        map.get(0).add(1);\\n        for (int i = 1; i < stones.length; i++) {\\n        \\tmap.put(stones[i], new HashSet<Integer>() );\\n        }\\n        \\n        for (int i = 0; i < stones.length - 1; i++) {\\n        \\tint stone = stones[i];\\n        \\tfor (int step : map.get(stone)) {\\n        \\t\\tint reach = step + stone;\\n        \\t\\tif (reach == stones[stones.length - 1]) {\\n        \\t\\t\\treturn true;\\n        \\t\\t}\\n        \\t\\tHashSet<Integer> set = map.get(reach);\\n        \\t\\tif (set != null) {\\n        \\t\\t    set.add(step);\\n        \\t\\t    if (step - 1 > 0) set.add(step - 1);\\n        \\t\\t    set.add(step + 1);\\n        \\t\\t}\\n        \\t}\\n        }\\n        \\n        return false;\\n    } \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 193816,
                "title": "concise-and-fast-dp-solution-using-2d-array-instead-of-hashmap-with-text-and-video-explanation",
                "content": "## LeetCode 403. Frog Jump\\n### Note\\nIf you prefer video over text, please check out this link: https://www.youtube.com/watch?v=oTCPG1ezlKc\\nwhich has the same content as follows.\\n### Explanation\\n```java\\n                +----+    +----+        +----+     +----+       \\nstone:          | S1 |    | S2 |        | S3 |     | S4 | \\n            ____|____|____|____|________|____|_____|____|____________\\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\nposition:\"         0         1             3          5             \"        \\n\\njump size:         1     [0, 1, 2]     [1, 2, 3]\\n\\n// Suppose we want to know if the frog can reach stone 2 (S2),\\n// and we know the frog must come from S1, \\n// dist(S1->S2) = 1 - 0 = 1, and we already know the frog is able to make a jump of size 1 at S1.\\n// Hence, the frog is able to reach S2, and the next jump would be 0, 1 or 2 units.\\n\\n\\n// Then, we want to know if the frog can reach stone 3 (S3),\\n// we know the frog must be at either S1 or S2 before reaching S3,\\n\\n// If the frog comes from S1, then \\n// we know dist(S1->S3) = 3 - 0 = 3, and we know frog couldn\\'t make a jump of size 3 at S1.\\n// So it is not possible the frog can jump from S1 to S3.\\n\\n// If the frog comes from S2, then\\n// we know dist(S2->S3) = 3 - 1 = 2, and we know frog could make a jump of size 2 at S2.\\n// Hence, the frog is able to reach S3, and the next jump would be 1, 2 or 3 units.\\n\\n// If we repeat doing this for the rest stones, we\\'ll end with something like below:\\nExapme 1:\\n            \\nindex:        0   1   2   3   4   5   6   7 \\n            +---+---+---+---+---+---+---+---+\\nstone pos:  | 0 | 1 | 3 | 5 | 6 | 8 | 12| 17|\\n            +---+---+---+---+---+---+---+---+\\nk:          | 1 | 0 | 1 | 1 | 0 | 1 | 3 | 5 |\\n            |   | 1 | 2 | 2 | 1 | 2 | 4 | 6 |\\n            |   | 2 | 3 | 3 | 2 | 3 | 5 | 7 |\\n            |   |   |   |   | 3 | 4 |   |   |\\n            |   |   |   |   | 4 |   |   |   |\\n            |   |   |   |   |   |   |   |   |\\n\\n// Sub-problem and state:\\nlet dp(i) denote a set containing all next jump size at stone i\\n\\n// Recurrence relation:\\nfor any j < i,\\ndist = stones[i] - stones[j];\\nif dist is in dp(j):\\n    put dist - 1, dist, dist + 1 into dp(i). \\n\\n// Now lets make this approach more efficient.\\n// BECAUSE \\n// 1. The number of stones is \\u2265 2 and is < 1,100. \\n// 2. The frog is on the first stone and assume the first jump must be 1 unit.\\n// 3. If the frog\\'s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units,\\n\\n// The maximum jump size the frog can make at each stone if possible is shown as followings: \\n// stone:      0, 1, 2, 3, 4, 5\\n// jump size:  1, 2, 3, 4, 5, 6 (suppose frog made jump with size k + 1 at each stone)\\n\\n// So instead of creating a HashSet for lookup for each stone, \\n// we can create a boolean array with size of N + 1 (N is the number of stones),\\n// Like in the given example, at stone 2 the next jump could be 1, 2, 3, \\n// we can use a bool array to represent this like\\n// index:    0  1  2  3  4  5  6  7  ...\\n//          [0, 1, 1, 1, 0, 0, 0, 0, ...]\\n// index is jump size, boolean value represents if the frog can make this jump.\\n\\n// Then, the 2D array will be something like below.\\n\\nindex:        0   1   2   3   4   5   6   7 \\n            +---+---+---+---+---+---+---+---+\\nstone pos:  | 0 | 1 | 3 | 5 | 6 | 8 | 12| 17|\\n            +---+---+---+---+---+---+---+---+\\nk:        0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |\\n          1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |\\n          2 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |\\n          3 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 |\\n          4 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 |\\n          5 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |\\n          6 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |\\n          7 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |\\n\\n// Sub-problem and state:\\nlet dp[i][j] denote at stone i, the frog can or cannot make jump of size j\\n\\n// Recurrence relation:\\nfor any j < i,\\ndist = stones[i] - stones[j];\\nif dp[j][dist]:\\n    dp[i][dist - 1] = ture\\n    dp[i][dist] = ture\\n    dp[i][dist + 1] = ture\\n```\\n### Code\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int N = stones.length;\\n        boolean[][] dp = new boolean[N][N + 1];\\n        dp[0][1] = true;\\n        \\n        for(int i = 1; i < N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                int diff = stones[i] - stones[j];\\n                if(diff < 0 || diff > N || !dp[j][diff]) continue;\\n                dp[i][diff] = true;\\n                if(diff - 1 >= 0) dp[i][diff - 1] = true;\\n                if(diff + 1 <= N) dp[i][diff + 1] = true;\\n                if(i == N - 1) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n                +----+    +----+        +----+     +----+       \\nstone:          | S1 |    | S2 |        | S3 |     | S4 | \\n            ____|____|____|____|________|____|_____|____|____________\\n           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ \\nposition:\"         0         1             3          5             \"        \\n\\njump size:         1     [0, 1, 2]     [1, 2, 3]\\n\\n// Suppose we want to know if the frog can reach stone 2 (S2),\\n// and we know the frog must come from S1, \\n// dist(S1->S2) = 1 - 0 = 1, and we already know the frog is able to make a jump of size 1 at S1.\\n// Hence, the frog is able to reach S2, and the next jump would be 0, 1 or 2 units.\\n\\n\\n// Then, we want to know if the frog can reach stone 3 (S3),\\n// we know the frog must be at either S1 or S2 before reaching S3,\\n\\n// If the frog comes from S1, then \\n// we know dist(S1->S3) = 3 - 0 = 3, and we know frog couldn\\'t make a jump of size 3 at S1.\\n// So it is not possible the frog can jump from S1 to S3.\\n\\n// If the frog comes from S2, then\\n// we know dist(S2->S3) = 3 - 1 = 2, and we know frog could make a jump of size 2 at S2.\\n// Hence, the frog is able to reach S3, and the next jump would be 1, 2 or 3 units.\\n\\n// If we repeat doing this for the rest stones, we\\'ll end with something like below:\\nExapme 1:\\n            \\nindex:        0   1   2   3   4   5   6   7 \\n            +---+---+---+---+---+---+---+---+\\nstone pos:  | 0 | 1 | 3 | 5 | 6 | 8 | 12| 17|\\n            +---+---+---+---+---+---+---+---+\\nk:          | 1 | 0 | 1 | 1 | 0 | 1 | 3 | 5 |\\n            |   | 1 | 2 | 2 | 1 | 2 | 4 | 6 |\\n            |   | 2 | 3 | 3 | 2 | 3 | 5 | 7 |\\n            |   |   |   |   | 3 | 4 |   |   |\\n            |   |   |   |   | 4 |   |   |   |\\n            |   |   |   |   |   |   |   |   |\\n\\n// Sub-problem and state:\\nlet dp(i) denote a set containing all next jump size at stone i\\n\\n// Recurrence relation:\\nfor any j < i,\\ndist = stones[i] - stones[j];\\nif dist is in dp(j):\\n    put dist - 1, dist, dist + 1 into dp(i). \\n\\n// Now lets make this approach more efficient.\\n// BECAUSE \\n// 1. The number of stones is \\u2265 2 and is < 1,100. \\n// 2. The frog is on the first stone and assume the first jump must be 1 unit.\\n// 3. If the frog\\'s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units,\\n\\n// The maximum jump size the frog can make at each stone if possible is shown as followings: \\n// stone:      0, 1, 2, 3, 4, 5\\n// jump size:  1, 2, 3, 4, 5, 6 (suppose frog made jump with size k + 1 at each stone)\\n\\n// So instead of creating a HashSet for lookup for each stone, \\n// we can create a boolean array with size of N + 1 (N is the number of stones),\\n// Like in the given example, at stone 2 the next jump could be 1, 2, 3, \\n// we can use a bool array to represent this like\\n// index:    0  1  2  3  4  5  6  7  ...\\n//          [0, 1, 1, 1, 0, 0, 0, 0, ...]\\n// index is jump size, boolean value represents if the frog can make this jump.\\n\\n// Then, the 2D array will be something like below.\\n\\nindex:        0   1   2   3   4   5   6   7 \\n            +---+---+---+---+---+---+---+---+\\nstone pos:  | 0 | 1 | 3 | 5 | 6 | 8 | 12| 17|\\n            +---+---+---+---+---+---+---+---+\\nk:        0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 |\\n          1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |\\n          2 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 0 |\\n          3 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 |\\n          4 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 0 |\\n          5 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |\\n          6 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |\\n          7 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |\\n\\n// Sub-problem and state:\\nlet dp[i][j] denote at stone i, the frog can or cannot make jump of size j\\n\\n// Recurrence relation:\\nfor any j < i,\\ndist = stones[i] - stones[j];\\nif dp[j][dist]:\\n    dp[i][dist - 1] = ture\\n    dp[i][dist] = ture\\n    dp[i][dist + 1] = ture\\n```\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int N = stones.length;\\n        boolean[][] dp = new boolean[N][N + 1];\\n        dp[0][1] = true;\\n        \\n        for(int i = 1; i < N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                int diff = stones[i] - stones[j];\\n                if(diff < 0 || diff > N || !dp[j][diff]) continue;\\n                dp[i][diff] = true;\\n                if(diff - 1 >= 0) dp[i][diff - 1] = true;\\n                if(diff + 1 <= N) dp[i][diff + 1] = true;\\n                if(i == N - 1) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88805,
                "title": "straight-forward-9ms-7-line-c-solution-with-explanation",
                "content": "Search for the last stone in a depth-first way, prune those exceeding the [k-1,k+1] range. Well, I think the code is simple enough and need no more explanation.\\n```\\nbool canCross(vector<int>& stones, int pos = 0, int k = 0) {\\n    for (int i = pos + 1; i < stones.size(); i++) {\\n        int gap = stones[i] - stones[pos];\\n        if (gap < k - 1) continue;\\n        if (gap > k + 1) return false;\\n        if (canCross(stones, i, gap)) return true;\\n    }\\n    return pos == stones.size() - 1;\\n}\\n```\\nThis can pass OJ at 9ms but is inefficient for extreme cases. (update: new test cases are added and the solution above no longer passes OJ, please see the solution below which takes 62ms) We can memorize the returns with minimum effort:\\n```\\nunordered_map<int, bool> dp;\\n\\nbool canCross(vector<int>& stones, int pos = 0, int k = 0) {\\n    int key = pos | k << 11;\\n\\n    if (dp.count(key) > 0)\\n        return dp[key];\\n\\n    for (int i = pos + 1; i < stones.size(); i++) {\\n        int gap = stones[i] - stones[pos];\\n        if (gap < k - 1)\\n            continue;\\n        if (gap > k + 1)\\n            return dp[key] = false;\\n        if (canCross(stones, i, gap))\\n            return dp[key] = true;\\n    }\\n\\n    return dp[key] = (pos == stones.size() - 1);\\n}\\n```\\nThe number of stones is less than 1100 so **pos** will always be less than 2^11 (2048).\\nStone positions could be theoretically up to 2^31 but **k** is practically not possible to be that big for the parameter as the steps must start from 0 and 1 and at the 1100th step the greatest valid k would be 1100. So combining **pos** and **k** is safe here.",
                "solutionTags": [],
                "code": "```\\nbool canCross(vector<int>& stones, int pos = 0, int k = 0) {\\n    for (int i = pos + 1; i < stones.size(); i++) {\\n        int gap = stones[i] - stones[pos];\\n        if (gap < k - 1) continue;\\n        if (gap > k + 1) return false;\\n        if (canCross(stones, i, gap)) return true;\\n    }\\n    return pos == stones.size() - 1;\\n}\\n```\n```\\nunordered_map<int, bool> dp;\\n\\nbool canCross(vector<int>& stones, int pos = 0, int k = 0) {\\n    int key = pos | k << 11;\\n\\n    if (dp.count(key) > 0)\\n        return dp[key];\\n\\n    for (int i = pos + 1; i < stones.size(); i++) {\\n        int gap = stones[i] - stones[pos];\\n        if (gap < k - 1)\\n            continue;\\n        if (gap > k + 1)\\n            return dp[key] = false;\\n        if (canCross(stones, i, gap))\\n            return dp[key] = true;\\n    }\\n\\n    return dp[key] = (pos == stones.size() - 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287736,
                "title": "easy-c-solution-5-approaches-recursion-dp",
                "content": "#  -> Approach 1 : Recursion (TLE)\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]-stones[0]>1)\\n            return false;\\n        \\n        return func(0, 1, stones);\\n    }\\n    \\n    bool func(int i, int jumps, vector<int> &stones){\\n        if(i==stones.size()-1)\\n            return true;\\n            \\n        bool ans=false;\\n        for(int ind=i+1; ind<stones.size(); ind++){\\n            if(stones[ind]-stones[i]>jumps+1)\\n                break;\\n            for(int t=-1; t<2; t++){\\n                if(stones[ind]-stones[i]==jumps+t)\\n                    ans = func(ind, jumps+t, stones) || ans;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n#  -> Approach 2 : Memoisation (MLE)\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]-stones[0]>1)\\n            return false;\\n        \\n        if(stones.size()==2)\\n            return (stones[1]-stones[0]==1);\\n        \\n        vector<vector<int>> dp(stones.size(), vector<int> (stones[stones.size()-1]-stones[0], -1));\\n        return func(0, 1, stones, dp);\\n    }\\n    \\n    bool func(int i, int jumps, vector<int> &stones, vector<vector<int>> &dp){\\n        if(i==stones.size()-1)\\n            return true;\\n            \\n        if(dp[i][jumps] != -1)\\n            return dp[i][jumps];\\n        \\n        bool ans=false;\\n        for(int ind=i+1; ind<stones.size(); ind++){\\n            if(stones[ind]-stones[i]>jumps+1)\\n                break;\\n            for(int t=-1; t<2; t++){\\n                if(stones[ind]-stones[i]==jumps+t)\\n                    ans = func(ind, jumps+t, stones, dp) || ans;\\n            }\\n        }\\n    \\n        return dp[i][jumps] = ans;\\n    }\\n};\\n```\\n\\n# -> Approach 3 : Tabulation using 2D vector (accepted)\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int N = stones.size();\\n        vector<vector<bool>> dp(N, vector<bool> (N+1, false));\\n        dp[0][1] = true;\\n        \\n        for(int i = 1; i < N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                int diff = stones[i] - stones[j];\\n                if(diff > N || !dp[j][diff]) \\n                    continue;\\n                \\n                if(i == N - 1) \\n                    return true;\\n                \\n                dp[i][diff] = true;\\n                if(diff - 1 >= 0) dp[i][diff - 1] = true;\\n                if(diff + 1 <= N) dp[i][diff + 1] = true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\n#  -> Approach 4 : Tabulation using Map (Accepted)\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int , unordered_set<int>> hashMap;    \\n        hashMap[stones[0] + 1] = {1};       \\n        for(int i = 1 ; i < stones.size() ; ++i){      \\n            int position = stones[i];               \\n            for(auto it : hashMap[position]){           \\n                hashMap[position + it].insert(it);      \\n                hashMap[position + it + 1].insert(it + 1);\\n                hashMap[position + it - 1].insert(it - 1);\\n            }\\n        }\\n        return hashMap[stones.back()].size() != 0;    \\n    }\\n};\\n```\\n\\n#  -> Approach 5 : Tabulation + Binary Search (Accepted)\\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool find(vector<int> &stones, int i, int k){\\n      if(i==stones.size()-1)\\n          return true;\\n\\n      if(i>=stones.size()) \\n          return false;\\n\\n      if(dp[i][k]!=-1) \\n          return dp[i][k]; \\n\\n      bool res = false;\\n      for(int j=-1;j<=1;j++){\\n          int next_jump=k+j;\\n          if(next_jump>0){\\n                int in= lower_bound(stones.begin(),stones.end(),stones[i]+next_jump)-stones.begin();\\n                if(in == stones.size() || stones[in]!=stones[i]+next_jump) \\n                  continue;\\n\\n                res=res||find(stones,in,next_jump);\\n          }\\n      }\\n\\n      return dp[i][k]=res;\\n\\n  }\\n  \\n  bool canCross(vector<int>& stones) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(stones, 0, 0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]-stones[0]>1)\\n            return false;\\n        \\n        return func(0, 1, stones);\\n    }\\n    \\n    bool func(int i, int jumps, vector<int> &stones){\\n        if(i==stones.size()-1)\\n            return true;\\n            \\n        bool ans=false;\\n        for(int ind=i+1; ind<stones.size(); ind++){\\n            if(stones[ind]-stones[i]>jumps+1)\\n                break;\\n            for(int t=-1; t<2; t++){\\n                if(stones[ind]-stones[i]==jumps+t)\\n                    ans = func(ind, jumps+t, stones) || ans;\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]-stones[0]>1)\\n            return false;\\n        \\n        if(stones.size()==2)\\n            return (stones[1]-stones[0]==1);\\n        \\n        vector<vector<int>> dp(stones.size(), vector<int> (stones[stones.size()-1]-stones[0], -1));\\n        return func(0, 1, stones, dp);\\n    }\\n    \\n    bool func(int i, int jumps, vector<int> &stones, vector<vector<int>> &dp){\\n        if(i==stones.size()-1)\\n            return true;\\n            \\n        if(dp[i][jumps] != -1)\\n            return dp[i][jumps];\\n        \\n        bool ans=false;\\n        for(int ind=i+1; ind<stones.size(); ind++){\\n            if(stones[ind]-stones[i]>jumps+1)\\n                break;\\n            for(int t=-1; t<2; t++){\\n                if(stones[ind]-stones[i]==jumps+t)\\n                    ans = func(ind, jumps+t, stones, dp) || ans;\\n            }\\n        }\\n    \\n        return dp[i][jumps] = ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int N = stones.size();\\n        vector<vector<bool>> dp(N, vector<bool> (N+1, false));\\n        dp[0][1] = true;\\n        \\n        for(int i = 1; i < N; ++i){\\n            for(int j = 0; j < i; ++j){\\n                int diff = stones[i] - stones[j];\\n                if(diff > N || !dp[j][diff]) \\n                    continue;\\n                \\n                if(i == N - 1) \\n                    return true;\\n                \\n                dp[i][diff] = true;\\n                if(diff - 1 >= 0) dp[i][diff - 1] = true;\\n                if(diff + 1 <= N) dp[i][diff + 1] = true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int , unordered_set<int>> hashMap;    \\n        hashMap[stones[0] + 1] = {1};       \\n        for(int i = 1 ; i < stones.size() ; ++i){      \\n            int position = stones[i];               \\n            for(auto it : hashMap[position]){           \\n                hashMap[position + it].insert(it);      \\n                hashMap[position + it + 1].insert(it + 1);\\n                hashMap[position + it - 1].insert(it - 1);\\n            }\\n        }\\n        return hashMap[stones.back()].size() != 0;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool find(vector<int> &stones, int i, int k){\\n      if(i==stones.size()-1)\\n          return true;\\n\\n      if(i>=stones.size()) \\n          return false;\\n\\n      if(dp[i][k]!=-1) \\n          return dp[i][k]; \\n\\n      bool res = false;\\n      for(int j=-1;j<=1;j++){\\n          int next_jump=k+j;\\n          if(next_jump>0){\\n                int in= lower_bound(stones.begin(),stones.end(),stones[i]+next_jump)-stones.begin();\\n                if(in == stones.size() || stones[in]!=stones[i]+next_jump) \\n                  continue;\\n\\n                res=res||find(stones,in,next_jump);\\n          }\\n      }\\n\\n      return dp[i][k]=res;\\n\\n  }\\n  \\n  bool canCross(vector<int>& stones) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(stones, 0, 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88873,
                "title": "python-dfs-easy-understanding-using-memo",
                "content": "Following is my backtracking solution using dict for memorization.\\n\\nThe **memo** dict is using for save those dead end. So when we get to the same stone with the same speed we don't need to search further.\\n\\n```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        self.memo = set()\\n        target = stones[-1]\\n        stones = set(stones)\\n\\n        res = self.bt(stones, 1, 1, target)\\n        return res\\n\\n    def bt(self, stones, cur, speed, target):\\n        # check memo\\n        if (cur, speed) in self.memo:\\n            return False\\n\\n        if cur==target:\\n            return True\\n        \\n        if cur>target or cur<0 or speed<=0 or cur not in stones:\\n            return False\\n        # dfs\\n        candidate = [speed-1, speed, speed+1]\\n        for c in candidate:\\n            if (cur + c) in stones:\\n                if self.bt(stones, cur+c, c, target):\\n                    return True\\n\\n        self.memo.add((cur,speed))\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        self.memo = set()\\n        target = stones[-1]\\n        stones = set(stones)\\n\\n        res = self.bt(stones, 1, 1, target)\\n        return res\\n\\n    def bt(self, stones, cur, speed, target):\\n        # check memo\\n        if (cur, speed) in self.memo:\\n            return False\\n\\n        if cur==target:\\n            return True\\n        \\n        if cur>target or cur<0 or speed<=0 or cur not in stones:\\n            return False\\n        # dfs\\n        candidate = [speed-1, speed, speed+1]\\n        for c in candidate:\\n            if (cur + c) in stones:\\n                if self.bt(stones, cur+c, c, target):\\n                    return True\\n\\n        self.memo.add((cur,speed))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965107,
                "title": "dp-beginners-friendly-easy-to-understand-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nExplore options of jump that frog can make.\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Dynamic Programming with Memoization:**\\n   - Create a map `m` to store the index of each stone.\\n   - Initialize a 2D memoization array `dp` with -1.\\n   - Define a recursive function `solve(i, k)` that checks if the frog can reach the last stone starting from stone `i` with jump distance `k`.\\n   - If the function result is already memoized in `dp[i][k]`, return it.\\n   - Try three jump distances: `k`, `k-1`, and `k+1`, and see if the frog can reach a stone with these jump distances.\\n   - Memoize the result and return `true` if the frog can reach the last stone from the current position.\\n   \\n2. **Main Function:**\\n   - If the second stone\\'s position is not one unit ahead of the first stone, return `false`.\\n   - Populate the map `m` with stone positions and indices.\\n   - Call the `solve` function starting from the second stone with jump distance 1.\\n   - Return the result of the `solve` function as the answer.\\n\\n# Complexity\\n- Time complexity:$$O(n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int dp[2000][2000];\\n\\n    int solve(int i, int k, vector<int>& stones) {\\n        if (i == stones.size() - 1) {\\n            return true;\\n        }\\n        \\n        if (dp[i][k] != -1) {\\n            return dp[i][k];\\n        }\\n\\n        bool k0 = false;\\n        bool kp = false;\\n        bool k1 = false;\\n\\n        if (m.find(stones[i] + k) != m.end()) {\\n            k0 = solve(m[stones[i] + k], k, stones);\\n        }\\n        if (k > 1 && m.find(stones[i] + k - 1) != m.end()) {\\n            kp = solve(m[stones[i] + k - 1], k - 1, stones);\\n        }\\n        if (m.find(stones[i] + k + 1) != m.end()) {\\n            k1 = solve(m[stones[i] + k + 1], k + 1, stones);\\n        }\\n\\n        dp[i][k] = k0 || kp || k1;\\n        return dp[i][k];\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        if (stones[1] - stones[0] != 1) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < stones.size(); i++) {\\n            m[stones[i]] = i;\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n\\n        return solve(1, 1, stones);\\n    }\\n};\\n\\n```\\n```java []\\n\\nclass Solution {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    int[][] dp;\\n\\n    boolean solve(int i, int k, int[] stones) {\\n        if (i == stones.length - 1) {\\n            return true;\\n        }\\n\\n        if (dp[i][k] != -1) {\\n            return dp[i][k] == 1;\\n        }\\n\\n        boolean k0 = false, kp = false, k1 = false;\\n\\n        if (m.containsKey(stones[i] + k)) {\\n            k0 = solve(m.get(stones[i] + k), k, stones);\\n        }\\n        if (k > 1 && m.containsKey(stones[i] + k - 1)) {\\n            kp = solve(m.get(stones[i] + k - 1), k - 1, stones);\\n        }\\n        if (m.containsKey(stones[i] + k + 1)) {\\n            k1 = solve(m.get(stones[i] + k + 1), k + 1, stones);\\n        }\\n\\n        dp[i][k] = (k0 || kp || k1) ? 1 : 0;\\n        return dp[i][k] == 1;\\n    }\\n\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] - stones[0] != 1) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            m.put(stones[i], i);\\n        }\\n\\n        dp = new int[stones.length][stones.length];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(1, 1, stones);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        m = {}  # stone positions to indices\\n        n = len(stones)\\n        dp = [[-1] * n for _ in range(n)]\\n\\n        def solve(i, k):\\n            if i == n - 1:\\n                return True\\n\\n            if dp[i][k] != -1:\\n                return dp[i][k] == 1\\n\\n            k0, kp, k1 = False, False, False\\n\\n            if stones[i] + k in m:\\n                k0 = solve(m[stones[i] + k], k)\\n            if k > 1 and stones[i] + k - 1 in m:\\n                kp = solve(m[stones[i] + k - 1], k - 1)\\n            if stones[i] + k + 1 in m:\\n                k1 = solve(m[stones[i] + k + 1], k + 1)\\n\\n            dp[i][k] = 1 if k0 or kp or k1 else 0\\n            return dp[i][k] == 1\\n\\n        if stones[1] - stones[0] != 1:\\n            return False\\n\\n        for i in range(n):\\n            m[stones[i]] = i\\n\\n        return solve(1, 1)\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m;\\n    int dp[2000][2000];\\n\\n    int solve(int i, int k, vector<int>& stones) {\\n        if (i == stones.size() - 1) {\\n            return true;\\n        }\\n        \\n        if (dp[i][k] != -1) {\\n            return dp[i][k];\\n        }\\n\\n        bool k0 = false;\\n        bool kp = false;\\n        bool k1 = false;\\n\\n        if (m.find(stones[i] + k) != m.end()) {\\n            k0 = solve(m[stones[i] + k], k, stones);\\n        }\\n        if (k > 1 && m.find(stones[i] + k - 1) != m.end()) {\\n            kp = solve(m[stones[i] + k - 1], k - 1, stones);\\n        }\\n        if (m.find(stones[i] + k + 1) != m.end()) {\\n            k1 = solve(m[stones[i] + k + 1], k + 1, stones);\\n        }\\n\\n        dp[i][k] = k0 || kp || k1;\\n        return dp[i][k];\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        if (stones[1] - stones[0] != 1) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < stones.size(); i++) {\\n            m[stones[i]] = i;\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n\\n        return solve(1, 1, stones);\\n    }\\n};\\n\\n```\n```java []\\n\\nclass Solution {\\n    HashMap<Integer, Integer> m = new HashMap<>();\\n    int[][] dp;\\n\\n    boolean solve(int i, int k, int[] stones) {\\n        if (i == stones.length - 1) {\\n            return true;\\n        }\\n\\n        if (dp[i][k] != -1) {\\n            return dp[i][k] == 1;\\n        }\\n\\n        boolean k0 = false, kp = false, k1 = false;\\n\\n        if (m.containsKey(stones[i] + k)) {\\n            k0 = solve(m.get(stones[i] + k), k, stones);\\n        }\\n        if (k > 1 && m.containsKey(stones[i] + k - 1)) {\\n            kp = solve(m.get(stones[i] + k - 1), k - 1, stones);\\n        }\\n        if (m.containsKey(stones[i] + k + 1)) {\\n            k1 = solve(m.get(stones[i] + k + 1), k + 1, stones);\\n        }\\n\\n        dp[i][k] = (k0 || kp || k1) ? 1 : 0;\\n        return dp[i][k] == 1;\\n    }\\n\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] - stones[0] != 1) {\\n            return false;\\n        }\\n\\n        for (int i = 0; i < stones.length; i++) {\\n            m.put(stones[i], i);\\n        }\\n\\n        dp = new int[stones.length][stones.length];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n\\n        return solve(1, 1, stones);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        m = {}  # stone positions to indices\\n        n = len(stones)\\n        dp = [[-1] * n for _ in range(n)]\\n\\n        def solve(i, k):\\n            if i == n - 1:\\n                return True\\n\\n            if dp[i][k] != -1:\\n                return dp[i][k] == 1\\n\\n            k0, kp, k1 = False, False, False\\n\\n            if stones[i] + k in m:\\n                k0 = solve(m[stones[i] + k], k)\\n            if k > 1 and stones[i] + k - 1 in m:\\n                kp = solve(m[stones[i] + k - 1], k - 1)\\n            if stones[i] + k + 1 in m:\\n                k1 = solve(m[stones[i] + k + 1], k + 1)\\n\\n            dp[i][k] = 1 if k0 or kp or k1 else 0\\n            return dp[i][k] == 1\\n\\n        if stones[1] - stones[0] != 1:\\n            return False\\n\\n        for i in range(n):\\n            m[stones[i]] = i\\n\\n        return solve(1, 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984868,
                "title": "c-memo-recursion-tree-diagram-another-dp-problem-with-a-recursive-approach",
                "content": "Lets first note down all the important point from the question:\\n1.   stones is sorted in a strictly increasing order.\\n2. \\t Initial jump which starts from pos 0 (first element of the array) can only be of 1 step jump.\\n\\n3. \\t If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units.\\n\\nLets explain all those points with an example  : \\nstones = [0,1,3,5,6,8,12,17]\\n* Intial jump start from stones[0] (***Position 0***) which is only 1. \\nSo, for next state frog would be in stones[1] and the Previous Jump would be 1\\n\\n* From stones[1](***Position 1***) he can take 0 steps (k-1 steps), 1 steps -> (k), 2 steps->(k+1) steps [see point no. 3], \\nIf he takes 1 step he will be at pos 2. But there is no stones marked with position 2 in the array.\\nSo, he has to take ***2 steps*** to which he will be reaching at 1(Initial Position)+2 = 3.\\n*  From stones[2](***Position 3***) he again have 3 choices either  k - 1, k, or k + 1 units. Now the previous steps is 2 therefore he the three choices are **1, 2, 3** if he can\\'t jump **1 step as there is no stones marked with position 4**. So, he has two option left either to choose ***step 2 or step 3***\\n    -> If he choose to jump  2 steps his final position would become 3 ***(his current position)*** + 2 = 5\\n\\t->  If he choose to jump 3 steps his final position would become 3 ***(his current position)*** + 3 = 6\\n\\n\\n**This will continue till he is able to jump to the last stone. If he is able to jump to the last stone then return True else return False**\\n\\n\\nTree Diagram will explain things more properly :\\nstones = [0,1,3,5,6,8,12,17]\\n![image](https://assets.leetcode.com/users/images/a23078d5-999e-44da-b710-5c7c5f12aba9_1651006507.6331363.jpeg)\\n\\nRecursive Solution:\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> mp;\\n    bool recursion(int pos, int prevStep, vector<int>& arr, int n){\\n\\n        if(mp[pos]== false || pos > arr[n-1]) return false;\\n        if(pos == arr[n-1]) return true;  \\n\\n\\n        bool isPossible;\\n\\n        if(pos==0){\\n            isPossible = recursion(pos+1,1,arr,n);\\n        }\\n        else{\\n            if(prevStep-1>0) \\n                isPossible = recursion(pos+(prevStep-1),prevStep-1,arr,n);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+prevStep,prevStep,arr,n);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+(prevStep+1),prevStep+1,arr,n);\\n            if(isPossible) return true;\\n        }\\n\\n        return isPossible;\\n\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        for(auto itr : stones) mp[itr] = true;\\n        int n = stones.size();\\n        return recursion(0,1,stones,n);\\n    }\\n};\\n```\\n\\n\\nRecursion + Memo :\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> mp;\\n    bool recursion(int pos, int prevStep, vector<int>& arr, int n, map<pair<int,int>,bool>& memo){\\n\\n        if(mp[pos]== false || pos > arr[n-1]) return false;\\n        if(pos == arr[n-1]) return true;  \\n        if(memo.find({pos,prevStep}) != memo.end()) return memo[{pos,prevStep}];\\n\\n        bool isPossible;\\n\\n        if(pos==0){\\n            isPossible = recursion(pos+1,1,arr,n,memo);\\n        }\\n        else{\\n            if(prevStep-1>0) \\n                isPossible = recursion(pos+(prevStep-1),prevStep-1,arr,n,memo);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+prevStep,prevStep,arr,n,memo);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+(prevStep+1),prevStep+1,arr,n,memo);\\n            if(isPossible) return true;\\n        }\\n        \\n        memo[{pos,prevStep}] = isPossible;\\n        return isPossible;\\n\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        \\n        for(auto itr : stones){ \\n            mp[itr] = true;\\n           \\n        }\\n        map<pair<int,int>,bool> memo;\\n        int n = stones.size();\\n        return recursion(0,1,stones,n,memo);\\n    }\\n};\\n```\\n\\nDo upvote if you like the solution.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> mp;\\n    bool recursion(int pos, int prevStep, vector<int>& arr, int n){\\n\\n        if(mp[pos]== false || pos > arr[n-1]) return false;\\n        if(pos == arr[n-1]) return true;  \\n\\n\\n        bool isPossible;\\n\\n        if(pos==0){\\n            isPossible = recursion(pos+1,1,arr,n);\\n        }\\n        else{\\n            if(prevStep-1>0) \\n                isPossible = recursion(pos+(prevStep-1),prevStep-1,arr,n);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+prevStep,prevStep,arr,n);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+(prevStep+1),prevStep+1,arr,n);\\n            if(isPossible) return true;\\n        }\\n\\n        return isPossible;\\n\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        for(auto itr : stones) mp[itr] = true;\\n        int n = stones.size();\\n        return recursion(0,1,stones,n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,bool> mp;\\n    bool recursion(int pos, int prevStep, vector<int>& arr, int n, map<pair<int,int>,bool>& memo){\\n\\n        if(mp[pos]== false || pos > arr[n-1]) return false;\\n        if(pos == arr[n-1]) return true;  \\n        if(memo.find({pos,prevStep}) != memo.end()) return memo[{pos,prevStep}];\\n\\n        bool isPossible;\\n\\n        if(pos==0){\\n            isPossible = recursion(pos+1,1,arr,n,memo);\\n        }\\n        else{\\n            if(prevStep-1>0) \\n                isPossible = recursion(pos+(prevStep-1),prevStep-1,arr,n,memo);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+prevStep,prevStep,arr,n,memo);\\n            if(isPossible) return true;\\n            isPossible = recursion(pos+(prevStep+1),prevStep+1,arr,n,memo);\\n            if(isPossible) return true;\\n        }\\n        \\n        memo[{pos,prevStep}] = isPossible;\\n        return isPossible;\\n\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        \\n        for(auto itr : stones){ \\n            mp[itr] = true;\\n           \\n        }\\n        map<pair<int,int>,bool> memo;\\n        int n = stones.size();\\n        return recursion(0,1,stones,n,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88800,
                "title": "python-documented-solution-that-is-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        \\n        # create a dictionary where the keys are the stones \\n        # and the values are empty sets that will contain \\n        # integers which represent the jump lengths that \\n        # can reach the stone represented by the key\\n        d = dict((x,set()) for x in stones)\\n        \\n        # catches a tricky test case: stones = [0,2]\\n        if stones[1] != 1:\\n            return False\\n            \\n        # the problems says that the first jump made is \\n        # always of length 1 and starts at stone 0. That\\n        # means the jump length that was used to reach \\n        # stone 1 is 1 so I add it into the set at stone 1\\n        d[1].add(1)\\n        \\n        # iterate over all the stones after 0\\n        for i in xrange(len(stones[1:])):\\n            \\n            # iterate over each jump length used to reach\\n            # the current stone\\n            for j in d[stones[i]]:\\n                \\n                # iterate over every jump length possible \\n                # (k-1, k, k+1) given the current jump length\\n                for k in xrange(j-1, j+2):\\n                    \\n                    # if that jump length lands on a stone\\n                    if k > 0 and stones[i]+k in d:\\n                        \\n                        # add that jump length used to get there to\\n                        # the set of jump lengths for the stone the \\n                        # jump puts the frog on\\n                        d[stones[i]+k].add(k)\\n                        \\n        # if the last stone has any jump lengths in it's\\n        # set, that means that it is possible to get to \\n        # the last stone\\n        return d[stones[-1]] != set()",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        \\n        # create a dictionary where the keys are the stones \\n        # and the values are empty sets that will contain \\n        # integers which represent the jump lengths that \\n        # can reach the stone represented by the key\\n        d = dict((x,set()) for x in stones)\\n        \\n        # catches a tricky test case: stones = [0,2]\\n        if stones[1] != 1:\\n            return False\\n            \\n        # the problems says that the first jump made is \\n        # always of length 1 and starts at stone 0. That\\n        # means the jump length that was used to reach \\n        # stone 1 is 1 so I add it into the set at stone 1\\n        d[1].add(1)\\n        \\n        # iterate over all the stones after 0\\n        for i in xrange(len(stones[1:])):\\n            \\n            # iterate over each jump length used to reach\\n            # the current stone\\n            for j in d[stones[i]]:\\n                \\n                # iterate over every jump length possible \\n                # (k-1, k, k+1) given the current jump length\\n                for k in xrange(j-1, j+2):\\n                    \\n                    # if that jump length lands on a stone\\n                    if k > 0 and stones[i]+k in d:\\n                        \\n                        # add that jump length used to get there to\\n                        # the set of jump lengths for the stone the \\n                        # jump puts the frog on\\n                        d[stones[i]+k].add(k)\\n                        \\n        # if the last stone has any jump lengths in it's\\n        # set, that means that it is possible to get to \\n        # the last stone\\n        return d[stones[-1]] != set()",
                "codeTag": "Java"
            },
            {
                "id": 1672029,
                "title": "c-hashmap-simple-solution-and-explanation",
                "content": "### Approach\\n\\nAnswer would be true if we can reach to last stone using some number of viable jump size, and false if we could not reach to last stone with any number of viable jump size.\\n\\nAlgorithm: \\n\\n- Make a hashmap of each stone, which would contain a set. That set would store the viable jump sizes that could be used to reach at that stone. E.g.: For 2nd stone, it would be 1 only.\\n- Traverse the stone array from 1st index (2nd stone). That can be the current position of frog at any time. \\n- Populate the sets of stones that can be reached from current position using a **viable jump size** (that is k - 1 or k or k + 1). Next Viable jump size can be calculated from previous jump size, and this previous jump size would be found in set of current position.\\n- Return true if set of last stone is unempty, that means we can reach to it somehow, false otherwise.\\n\\nMy Code:\\n\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int , unordered_set<int>> hashMap;    // Initializing required hashmap.\\n        hashMap[stones[0] + 1] = {1};       // Viable Jump Sizes to reach 2nd stone.\\n        for(int i = 1 ; i < stones.size() ; ++i){       // Traversing all positions\\n            int position = stones[i];                   // Current Position\\n            for(auto it : hashMap[position]){           // Traversing all viable jump sizes that can be used from current position.\\n                hashMap[position + it].insert(it);      // Populating the sets of positions that can be reached from current position with a viable jump size.\\n                hashMap[position + it + 1].insert(it + 1);\\n                hashMap[position + it - 1].insert(it - 1);\\n            }\\n        }\\n        return hashMap[stones.back()].size() != 0;     // Checking the set size of last stone.\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int , unordered_set<int>> hashMap;    // Initializing required hashmap.\\n        hashMap[stones[0] + 1] = {1};       // Viable Jump Sizes to reach 2nd stone.\\n        for(int i = 1 ; i < stones.size() ; ++i){       // Traversing all positions\\n            int position = stones[i];                   // Current Position\\n            for(auto it : hashMap[position]){           // Traversing all viable jump sizes that can be used from current position.\\n                hashMap[position + it].insert(it);      // Populating the sets of positions that can be reached from current position with a viable jump size.\\n                hashMap[position + it + 1].insert(it + 1);\\n                hashMap[position + it - 1].insert(it - 1);\\n            }\\n        }\\n        return hashMap[stones.back()].size() != 0;     // Checking the set size of last stone.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 264202,
                "title": "something-that-you-may-not-realize-about-bfs-and-dfs-solution",
                "content": "The following discussion is not about new solutions, but about some important details about DFS and BFS solution for this problem.\\n\\n### DFS solution\\n\\nThe idea is directly borrowed from [this post](https://leetcode.com/problems/frog-jump/discuss/88804/JAVA-DFS-17ms-beat-99.28-so-far), while my implementation is 2ms.  \\n\\nImportant facts (correct me if I\\'m wrong):  \\n* Pre-check is necessary (otherwise Time Limit Exceed) : *if (i > 0 && stones[i] - stones[i-1] > i) return false;* Reason: when the answer if false, the time complexity of DFS will be exp, but pre-check will detect it before beginning DFS.   \\n* During DFS, we should try to jump as far as we can cause this strategy is more likely to reach the destination. Therefore we should try *unit+preStep+1* then *unit+preStep* and finally *unit+preStep-1*. If we try *unit+preStep-1* first, it will be *Time Limit Exceed*.   \\n\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] != 1) return false;\\n        \\n        Set<Integer> units = new HashSet<>(); // stone locations\\n        for (int i = 0; i < stones.length; i++) {\\n            if (i > 0 && stones[i] - stones[i-1] > i) return false; // necessary!  \\n            units.add(stones[i]);\\n        }\\n        return cross(units, 1, 1, stones[stones.length-1]);\\n    }\\n    \\n    private boolean cross(Set<Integer> units, int unit, int preStep, int destination) {\\n        if (preStep <= 0) return false;\\n        if (!units.contains(unit)) return false;\\n        if (unit == destination) return true;\\n        if ( destination <= unit + preStep + 1 && destination >= unit + preStep - 1) return true;\\n        \\n        return cross(units, unit+preStep+1, preStep+1, destination) ||\\n            cross(units, unit+preStep, preStep, destination) ||\\n            cross(units, unit+preStep-1, preStep-1, destination);\\n    }\\n}\\n```\\n\\n### BFS solution\\n\\nThe solution is directly borrowed from [this post](https://leetcode.com/problems/frog-jump/discuss/88824/Very-easy-to-understand-JAVA-solution-with-explanations).  \\n\\nImportant facts (correct me if I\\'m wrong):  \\n* When the answer is True, DFS is typically faster than BFS.   \\n* In BFS, pre-check is not necessary. Though it still decreases the general running time.   \\n* Worst case time complexity: [read this](https://leetcode.com/problems/frog-jump/discuss/88824/Very-easy-to-understand-JAVA-solution-with-explanations/221175)  \\n\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>(); // stone location --> step options that can be take from this stone\\n        for (int i = 0; i < stones.length; i++) {\\n            if (i > 0 && stones[i] - stones[i-1] > i) return false;\\n            map.put(stones[i], new HashSet<>());\\n        }\\n        map.get(0).add(1);\\n        \\n        for (int i = 0; i < stones.length; i++) {\\n            if (map.get(stones[i]).isEmpty()) return false;\\n            for (int step : map.get(stones[i])) {\\n                int reach = stones[i] + step;\\n                if (reach == stones[stones.length-1]) return true;\\n                if (!map.containsKey(reach)) continue;\\n                for (int s = step + 1; s >= step - 1; s--) {\\n                    if (s > 0) map.get(reach).add(s);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] != 1) return false;\\n        \\n        Set<Integer> units = new HashSet<>(); // stone locations\\n        for (int i = 0; i < stones.length; i++) {\\n            if (i > 0 && stones[i] - stones[i-1] > i) return false; // necessary!  \\n            units.add(stones[i]);\\n        }\\n        return cross(units, 1, 1, stones[stones.length-1]);\\n    }\\n    \\n    private boolean cross(Set<Integer> units, int unit, int preStep, int destination) {\\n        if (preStep <= 0) return false;\\n        if (!units.contains(unit)) return false;\\n        if (unit == destination) return true;\\n        if ( destination <= unit + preStep + 1 && destination >= unit + preStep - 1) return true;\\n        \\n        return cross(units, unit+preStep+1, preStep+1, destination) ||\\n            cross(units, unit+preStep, preStep, destination) ||\\n            cross(units, unit+preStep-1, preStep-1, destination);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>(); // stone location --> step options that can be take from this stone\\n        for (int i = 0; i < stones.length; i++) {\\n            if (i > 0 && stones[i] - stones[i-1] > i) return false;\\n            map.put(stones[i], new HashSet<>());\\n        }\\n        map.get(0).add(1);\\n        \\n        for (int i = 0; i < stones.length; i++) {\\n            if (map.get(stones[i]).isEmpty()) return false;\\n            for (int step : map.get(stones[i])) {\\n                int reach = stones[i] + step;\\n                if (reach == stones[stones.length-1]) return true;\\n                if (!map.containsKey(reach)) continue;\\n                for (int s = step + 1; s >= step - 1; s--) {\\n                    if (s > 0) map.get(reach).add(s);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88804,
                "title": "java-dfs-17ms-beat-99-28-so-far",
                "content": "The idea is simple: \\n\\n(1) Using a HashSet to store all the positions of the stones. So when you are trying to jump to a position, you will know whether there is a stone at that position or not.\\n(2) Starting from the first valid position (the second stone if it is 1), you try to jump as far as possible. At each position, if you jumped x steps to this position, the next possible positions are position + x - 1, position + x and position + x + 1. If any of them is the last stone's position, then you can return true. If not, use DFS from the longest jump first.\\n(3) This path finding process can be terminated much earlier if there are two stones that are too far away. \\n\\n```   \\n public boolean canCross(int[] stones) {\\n        if (stones == null || stones.length == 0) {return false;}\\n        int n = stones.length;\\n        if (n == 1) {return true;}\\n        if (stones[1] != 1) {return false;}\\n        if (n == 2) {return true;}\\n        int last = stones[n - 1];\\n        HashSet<Integer> hs = new HashSet();\\n        for (int i = 0; i < n; i++) {\\n            if (i > 3 && stones[i] > stones[i - 1] * 2) {return false;} // The two stones are too far away. \\n            hs.add(stones[i]);\\n        }\\n        return canReach(hs, last, 1, 1);\\n    }\\n    \\n    private boolean canReach(HashSet<Integer> hs, int last, int pos, int jump) {\\n        if (pos + jump - 1 == last || pos + jump == last || pos + jump + 1 == last) {\\n            return true;\\n        }\\n        if (hs.contains(pos + jump + 1)) {\\n            if (canReach(hs, last, pos + jump + 1, jump + 1)) {return true;}\\n        }\\n        if (hs.contains(pos + jump)) {\\n            if (canReach(hs, last, pos + jump, jump)) {return true;}\\n        }\\n        if (jump > 1 && hs.contains(pos + jump - 1)) {\\n            if (canReach(hs, last, pos + jump - 1, jump - 1)) {return true;}\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n public boolean canCross(int[] stones) {\\n        if (stones == null || stones.length == 0) {return false;}\\n        int n = stones.length;\\n        if (n == 1) {return true;}\\n        if (stones[1] != 1) {return false;}\\n        if (n == 2) {return true;}\\n        int last = stones[n - 1];\\n        HashSet<Integer> hs = new HashSet();\\n        for (int i = 0; i < n; i++) {\\n            if (i > 3 && stones[i] > stones[i - 1] * 2) {return false;} // The two stones are too far away. \\n            hs.add(stones[i]);\\n        }\\n        return canReach(hs, last, 1, 1);\\n    }\\n    \\n    private boolean canReach(HashSet<Integer> hs, int last, int pos, int jump) {\\n        if (pos + jump - 1 == last || pos + jump == last || pos + jump + 1 == last) {\\n            return true;\\n        }\\n        if (hs.contains(pos + jump + 1)) {\\n            if (canReach(hs, last, pos + jump + 1, jump + 1)) {return true;}\\n        }\\n        if (hs.contains(pos + jump)) {\\n            if (canReach(hs, last, pos + jump, jump)) {return true;}\\n        }\\n        if (jump > 1 && hs.contains(pos + jump - 1)) {\\n            if (canReach(hs, last, pos + jump - 1, jump - 1)) {return true;}\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964889,
                "title": "simple-java-solution-beginner-friendly-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In this code we have use a 2D dynamic programming array `dp` where `dp[i][j] `indicates if the frog can reach stone `i` with a jump of length `j`.\\n- Initialize `dp[0][1]` as true because the frog starts at the first stone and can jump one unit.\\n- Iterate through each stone from the second one (`i` starting from 1):\\n- For each stone, iterate through all previous stones (`j` from 0 to `i - 1`).\\n- Calculate the jump distance `jump` between the current stone and the previous stone.\\n- If `jump` is within the valid range of jump distances (from `1` to `j + 1`).\\n- Update `dp[i][jump]` based on previous states: `dp[j][jump - 1], dp[j][jump], `and` dp[j][jump + 1].`\\n- If the current stone is the last stone and the frog can reach it with a valid jump distance, return `true`.\\n- If no valid jump sequence is found for the last stone, return `false`.\\n\\n# Complexity\\n- Time complexity: `O(n^2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        boolean[][] dp = new boolean[n][n + 1];\\n        dp[0][1] = true;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int jump = stones[i] - stones[j];\\n                \\n                if (jump <= j + 1) {\\n                    dp[i][jump] = dp[j][jump - 1] || dp[j][jump] || dp[j][jump + 1];\\n                    if (i == n - 1 && dp[i][jump]) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```\\n# If you like the solution please Upvote.\\n![5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg](https://assets.leetcode.com/users/images/27eb5f92-53c4-49e3-99f8-78eeafb93c8a_1693101113.0559518.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        boolean[][] dp = new boolean[n][n + 1];\\n        dp[0][1] = true;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < i; j++) {\\n                int jump = stones[i] - stones[j];\\n                \\n                if (jump <= j + 1) {\\n                    dp[i][jump] = dp[j][jump - 1] || dp[j][jump] || dp[j][jump + 1];\\n                    if (i == n - 1 && dp[i][jump]) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418003,
                "title": "11-line-dfs-solution",
                "content": "Standard dfs with two base conditions and three recursive calls\\n\\nIf the same values has been explored before or if value not present in array, then return false.\\nIf destination found, then return True\\nKeep log of the path visited so that not to visit that one again\\nElse go further with all the possible options\\n\\nUse a set of stones for faster lookup\\n```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        n = len(stones)\\n        stoneSet = set(stones)\\n        visited = set()\\n        def goFurther(value,units):\\n            if (value+units not in stoneSet) or ((value,units) in visited):\\n                return False\\n            if value+units == stones[n-1]:\\n                return True\\n            visited.add((value,units))\\n            return goFurther(value+units,units) or goFurther(value+units,units-1) or goFurther(value+units,units+1)\\n        return goFurther(stones[0],1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        n = len(stones)\\n        stoneSet = set(stones)\\n        visited = set()\\n        def goFurther(value,units):\\n            if (value+units not in stoneSet) or ((value,units) in visited):\\n                return False\\n            if value+units == stones[n-1]:\\n                return True\\n            visited.add((value,units))\\n            return goFurther(value+units,units) or goFurther(value+units,units-1) or goFurther(value+units,units+1)\\n        return goFurther(stones[0],1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653480,
                "title": "c-clean-dp-lis-like-approach-short-and-concise",
                "content": "**Intuition:**\\n\\ndp[i][j] = Upon standing at index i, jump j steps right.\\ndp[0][1] = true, because we can 1st step from 0 is 1.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        \\n        vector<vector<int>>dp(n, vector<int>(n, false));\\n        dp[0][1] = true;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                int d = stones[i] - stones[j];\\n                if (d > 0 && d < n && dp[j][d]) {\\n                    if (i == n-1) return true;\\n                    dp[i][d] = true;\\n                    if (d+1 < n) dp[i][d+1] = true;\\n                    if (d-1 < n) dp[i][d-1] = true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        \\n        vector<vector<int>>dp(n, vector<int>(n, false));\\n        dp[0][1] = true;\\n        \\n        for (int i = 1; i < n; i++) {\\n            for(int j = 0; j < i; j++) {\\n                int d = stones[i] - stones[j];\\n                if (d > 0 && d < n && dp[j][d]) {\\n                    if (i == n-1) return true;\\n                    dp[i][d] = true;\\n                    if (d+1 < n) dp[i][d+1] = true;\\n                    if (d-1 < n) dp[i][d-1] = true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964859,
                "title": "python3-simple-dfs-with-memo",
                "content": "From reading the description, we can see that at each position, we have three neighbor positions (```curPosition+lastStep-1```, ```curPosition+lastStep```, ```curPosition+lastStep+1```). The goal is to reach to the last position in ```stones```. Thus, DFS seems like a good choice.\\n\\nThe trick here is that at each position, we have to move forward. i.e., the next position has to have an index that is larger than the index of the current position. We can use a pre computed indices (hash map) to figure this out during the DFS.\\n\\n```python\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1]!=1: return False \\t\\t\\t\\t\\t\\t# the first position has to be 1.\\n        \\n        indices = {v:i for i,v in enumerate(stones)}\\t\\t# Hashmap which stores value and index pairs.\\n        \\n        @cache\\n        def dfs(i,lastStep):\\n            if i==len(stones)-1: \\t\\t\\t\\t\\t\\t\\t# If we reach to the last position, we are done and return True\\n                return True\\n            res = False\\n            for curStep in range(lastStep-1,lastStep+2):\\t# The 3 neighbor states discussed above\\n                if stones[i]+curStep in indices and indices[stones[i]+curStep]>i:\\t# The next position has to occur after the current position.\\n                    res = res or dfs(indices[stones[i]+curStep],curStep)\\n            return res\\n        \\n        return dfs(1,1)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```curPosition+lastStep-1```\n```curPosition+lastStep```\n```curPosition+lastStep+1```\n```stones```\n```python\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1]!=1: return False \\t\\t\\t\\t\\t\\t# the first position has to be 1.\\n        \\n        indices = {v:i for i,v in enumerate(stones)}\\t\\t# Hashmap which stores value and index pairs.\\n        \\n        @cache\\n        def dfs(i,lastStep):\\n            if i==len(stones)-1: \\t\\t\\t\\t\\t\\t\\t# If we reach to the last position, we are done and return True\\n                return True\\n            res = False\\n            for curStep in range(lastStep-1,lastStep+2):\\t# The 3 neighbor states discussed above\\n                if stones[i]+curStep in indices and indices[stones[i]+curStep]>i:\\t# The next position has to occur after the current position.\\n                    res = res or dfs(indices[stones[i]+curStep],curStep)\\n            return res\\n        \\n        return dfs(1,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968651,
                "title": "video-ex-amazon-explains-a-solution-with-python-javascript-java-and-c",
                "content": "# Intuition\\nUse dynamic programming to keep the last jump and I thought why the frog can\\'t jump into the water.\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 249 videos as of August 28th, 2023.\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/dvoouRUguvw\\n\\n## In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. **Initialization and Base Case Setup:**\\n   Initialize a dictionary `dp` where keys represent the positions of stones, and values are sets to store possible jump distances for each stone. Initialize the stone at position 0 with a set containing only the jump distance 0.\\n\\n   **Explanation:** At the start, we create a dictionary to keep track of the possible jump distances for each stone. Since the frog starts at position 0, we initialize the set for the stone at position 0 with a jump distance of 0, indicating that it\\'s the starting point.\\n\\n2. **Iterating Through Stones:**\\n   Iterate through each stone in the list `stones`.\\n\\n   a. **Loop Through Jump Distances of Current Stone:**\\n      For the current stone\\'s position, loop through the possible jump distances stored in `dp[stone]`.\\n\\n   b. **Considering Different Jump Distances:**\\n      For each jump distance, consider three potential jump distances: `jump - 1`, `jump`, and `jump + 1`.\\n\\n   c. **Checking and Updating Valid Jumps:**\\n      Check if the calculated `jump_distance` is greater than 0 and if the resulting position (`stone + jump_distance`) is present in the `dp` dictionary. If both conditions are met, add the current `jump_distance` to the set of possible jump distances for the next stone\\'s position (`stone + jump_distance`).\\n\\n   **Explanation:** This nested loop structure is crucial for exploring the different jump distances the frog can take and updating the `dp` dictionary with valid jump possibilities.\\n\\n3. **Checking if Frog Can Reach the Last Stone:**\\n   After processing all stones and their respective jump distances:\\n\\n   a. **Checking Last Stone\\'s Jump Distances:**\\n      Check if the last stone\\'s position (`stones[-1]`) has any possible jump distances greater than 0 in the `dp` dictionary.\\n\\n   b. **Returning the Result:**\\n      If there are any valid jump distances for the last stone, return `True` to indicate that the frog can successfully cross the river. Otherwise, return `False` to indicate that the frog cannot cross the river.\\n\\n   **Explanation:** This step is the final determination of whether the frog can cross the river based on the calculated jump possibilities for each stone.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n^2)\\n\\n```python []\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        dp = {stone : set() for stone in stones}\\n        dp[0] = {0}\\n\\n        for stone in stones:\\n            for jump in dp[stone]:\\n                for jump_distance in [jump - 1, jump, jump + 1]:\\n                    if jump_distance > 0 and stone + jump_distance in dp:\\n                        dp[stone + jump_distance].add(jump_distance)\\n        \\n        return len(dp[stones[-1]]) > 0\\n```\\n```javascript []\\n/**\\n * @param {number[]} stones\\n * @return {boolean}\\n */\\nvar canCross = function(stones) {\\n    const dp = new Map();\\n    stones.forEach(stone => dp.set(stone, new Set()));\\n    dp.get(0).add(0);\\n\\n    for (const stone of stones) {\\n        for (const jump of dp.get(stone)) {\\n            for (const jumpDistance of [jump - 1, jump, jump + 1]) {\\n                if (jumpDistance > 0 && dp.has(stone + jumpDistance)) {\\n                    dp.get(stone + jumpDistance).add(jumpDistance);\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp.get(stones[stones.length - 1]).size > 0;    \\n};\\n```\\n```java []\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for (int stone : stones) {\\n            dp.put(stone, new HashSet<>());\\n        }\\n        dp.get(0).add(0);\\n\\n        for (int stone : stones) {\\n            for (int jump : dp.get(stone)) {\\n                for (int jumpDistance : new int[] {jump - 1, jump, jump + 1}) {\\n                    if (jumpDistance > 0 && dp.containsKey(stone + jumpDistance)) {\\n                        dp.get(stone + jumpDistance).add(jumpDistance);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return !dp.get(stones[stones.length - 1]).isEmpty();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        std::unordered_map<int, std::unordered_set<int>> dp;\\n        for (int stone : stones) {\\n            dp[stone] = std::unordered_set<int>();\\n        }\\n        dp[0].insert(0);\\n\\n        for (int stone : stones) {\\n            for (int jump : dp[stone]) {\\n                for (int jumpDistance : {jump - 1, jump, jump + 1}) {\\n                    if (jumpDistance > 0 && dp.find(stone + jumpDistance) != dp.end()) {\\n                        dp[stone + jumpDistance].insert(jumpDistance);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return !dp[stones.back()].empty();        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        dp = {stone : set() for stone in stones}\\n        dp[0] = {0}\\n\\n        for stone in stones:\\n            for jump in dp[stone]:\\n                for jump_distance in [jump - 1, jump, jump + 1]:\\n                    if jump_distance > 0 and stone + jump_distance in dp:\\n                        dp[stone + jump_distance].add(jump_distance)\\n        \\n        return len(dp[stones[-1]]) > 0\\n```\n```javascript []\\n/**\\n * @param {number[]} stones\\n * @return {boolean}\\n */\\nvar canCross = function(stones) {\\n    const dp = new Map();\\n    stones.forEach(stone => dp.set(stone, new Set()));\\n    dp.get(0).add(0);\\n\\n    for (const stone of stones) {\\n        for (const jump of dp.get(stone)) {\\n            for (const jumpDistance of [jump - 1, jump, jump + 1]) {\\n                if (jumpDistance > 0 && dp.has(stone + jumpDistance)) {\\n                    dp.get(stone + jumpDistance).add(jumpDistance);\\n                }\\n            }\\n        }\\n    }\\n\\n    return dp.get(stones[stones.length - 1]).size > 0;    \\n};\\n```\n```java []\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for (int stone : stones) {\\n            dp.put(stone, new HashSet<>());\\n        }\\n        dp.get(0).add(0);\\n\\n        for (int stone : stones) {\\n            for (int jump : dp.get(stone)) {\\n                for (int jumpDistance : new int[] {jump - 1, jump, jump + 1}) {\\n                    if (jumpDistance > 0 && dp.containsKey(stone + jumpDistance)) {\\n                        dp.get(stone + jumpDistance).add(jumpDistance);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return !dp.get(stones[stones.length - 1]).isEmpty();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        std::unordered_map<int, std::unordered_set<int>> dp;\\n        for (int stone : stones) {\\n            dp[stone] = std::unordered_set<int>();\\n        }\\n        dp[0].insert(0);\\n\\n        for (int stone : stones) {\\n            for (int jump : dp[stone]) {\\n                for (int jumpDistance : {jump - 1, jump, jump + 1}) {\\n                    if (jumpDistance > 0 && dp.find(stone + jumpDistance) != dp.end()) {\\n                        dp[stone + jumpDistance].insert(jumpDistance);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return !dp[stones.back()].empty();        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88810,
                "title": "c-9-lines-o-n-2-iterative-dp-solution",
                "content": "This solution is not as fast as some other O(n^2) DFS solutions possibly due to the OJ test cases. But it's simple and clean.\\nSpecial thanks @farahcs and @vesion for correcting the bug in previous code.\\n```\\nbool canCross(vector<int>& stones) {\\n        // To record available last steps to reach current position. Position 0 need 0 step to be reached\\n        unordered_map<int, unordered_set<int>> steps = {{0, {0}}};  \\n        \\n        for (int pos : stones) {\\n            for (auto it = steps[pos].begin(); it != steps[pos].end(); it++) {  // record all future reachable positions\\n                if (*it - 1) { steps[pos + *it - 1].insert(*it - 1); }\\n                steps[pos + *it].insert(*it);\\n                steps[pos + *it + 1].insert(*it + 1);\\n            }\\n        }\\n        \\n        return steps[stones.back()].size();                                     // check if the last position is reachable\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool canCross(vector<int>& stones) {\\n        // To record available last steps to reach current position. Position 0 need 0 step to be reached\\n        unordered_map<int, unordered_set<int>> steps = {{0, {0}}};  \\n        \\n        for (int pos : stones) {\\n            for (auto it = steps[pos].begin(); it != steps[pos].end(); it++) {  // record all future reachable positions\\n                if (*it - 1) { steps[pos + *it - 1].insert(*it - 1); }\\n                steps[pos + *it].insert(*it);\\n                steps[pos + *it + 1].insert(*it + 1);\\n            }\\n        }\\n        \\n        return steps[stones.back()].size();                                     // check if the last position is reachable\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 923547,
                "title": "dfs-dp-progression-with-explanation-o-n-2-o-n-2",
                "content": "In this problem, we are tasked to find out if a frog can cross a river only using the given `stones`, constrained by a movement requirement.  A great way to visualize this is by using DFS and drawing a DFS tree.  We can imagine an instance of the function as the current state, and the recursive calls as possible actions you can take from the current state to another possible state.  Looking through all possible state combinations will tell us if our little frog friend can make it to the end or not.  Let\\'s take a look at the DFS tree (green = `k`, invalid transitions are crossed out in red)\\n![image](https://assets.leetcode.com/users/images/abf905d2-8a41-4793-86ab-d649237dc833_1604519612.0057123.png)\\nLet\\'s replicate this in code.\\n```\\ndef dfs(stones, curr, k, target):\\n\\tprint(curr, k)\\n\\tif curr == target:\\n\\t\\treturn True\\n\\tleft = mid = right = False\\n\\tif curr + (k - 1) in stones and k - 1 > 0:\\n\\t\\tleft = dfs(stones, curr + (k - 1), k - 1, target)\\n\\tif curr + (k) in stones and k > 0:\\n\\t\\tmid = dfs(stones, curr + (k), k, target)\\n\\tif curr + (k + 1) in stones:\\n\\t\\tright = dfs(stones, curr + (k + 1), k + 1, target)\\n\\treturn left or mid or right\\nreturn dfs(set(stones), 0, 0, stones[-1])\\n```\\nThe DFS approach works and will solve the problem, however it takes far too long and times out.  Why is that?  There are two reasons.  First, notice in the above picture we find a path that leads to the `target` three times (the circled `8`).  This implementation of DFS will always explore all possible combinations before returning if one of the paths suceeded or not.  Second, imagine we had the following paths:\\n```\\n1 -> 2 -> 4 -> 5\\n1 -> 3 -> 4 -> 5\\n```\\nFor both of these paths, we arrive at the `5` with `k = 1`.  The calculation for both of these paths from this point onwards will yield the same answer, but instead of referencing the answer after calculating it once, DFS wastes time and calculates it again.  Both of these issues grows exponentially as the input becomes larger, creating a taller DFS tree.  This is where the DP solution comes in.\\n\\nIn the DFS approach, we are solving the problem from the top down, meaning we need to recurse all the way to the base case `(if curr == target)`, until we know if a path has successfully reached the end or not.  Instead, let\\'s build the solution from the ground up, saving the solution to the current subproblem at each step.  Our dynamic programming subproblem would be `A[i][k] = True if we can reach the ith stone with a jump of distance k`, and we are looking for any `k` that would land us on the final stone.\\n```\\ndef dp(stones):\\n\\tA = [[0] * len(stones) for _ in range(len(stones))]\\n\\tif stones[1] == 1:\\n\\t\\tA[1][1] = 1            \\n\\tfor i in range(2, len(stones)):\\n\\t\\tfor j in range(1, i):\\n\\t\\t\\tk = stones[i] - stones[j]\\n\\t\\t\\tif 0 < k <= i:\\n\\t\\t\\t\\tleft = mid = right = 0\\n\\t\\t\\t\\tif k - 1 >= 0:\\n\\t\\t\\t\\t\\tleft = A[j][k - 1]\\n\\t\\t\\t\\tmid = A[j][k]\\n\\t\\t\\t\\tif k + 1 < len(stones):\\n\\t\\t\\t\\t\\tright = A[j][k + 1]\\n\\t\\t\\t\\tA[i][k] = left or mid or right\\n\\n\\tfor i in range(len(A)):\\n\\t\\tif A[-1][i]:\\n\\t\\t\\treturn True\\n\\treturn False  \\nreturn dp(stones)\\n```\\nNotice that the recursion relation (along with the boundary conditions) are exactly the same as in the DFS solution.  The only difference really is that we are saving the solutions at each step.  Now, we can imagine being at some node in the DFS tree, and instead of branching downwards, we are _looking upwards_ to see if we could have reach this point from one of the previous nodes.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\ndef dfs(stones, curr, k, target):\\n\\tprint(curr, k)\\n\\tif curr == target:\\n\\t\\treturn True\\n\\tleft = mid = right = False\\n\\tif curr + (k - 1) in stones and k - 1 > 0:\\n\\t\\tleft = dfs(stones, curr + (k - 1), k - 1, target)\\n\\tif curr + (k) in stones and k > 0:\\n\\t\\tmid = dfs(stones, curr + (k), k, target)\\n\\tif curr + (k + 1) in stones:\\n\\t\\tright = dfs(stones, curr + (k + 1), k + 1, target)\\n\\treturn left or mid or right\\nreturn dfs(set(stones), 0, 0, stones[-1])\\n```\n```\\n1 -> 2 -> 4 -> 5\\n1 -> 3 -> 4 -> 5\\n```\n```\\ndef dp(stones):\\n\\tA = [[0] * len(stones) for _ in range(len(stones))]\\n\\tif stones[1] == 1:\\n\\t\\tA[1][1] = 1            \\n\\tfor i in range(2, len(stones)):\\n\\t\\tfor j in range(1, i):\\n\\t\\t\\tk = stones[i] - stones[j]\\n\\t\\t\\tif 0 < k <= i:\\n\\t\\t\\t\\tleft = mid = right = 0\\n\\t\\t\\t\\tif k - 1 >= 0:\\n\\t\\t\\t\\t\\tleft = A[j][k - 1]\\n\\t\\t\\t\\tmid = A[j][k]\\n\\t\\t\\t\\tif k + 1 < len(stones):\\n\\t\\t\\t\\t\\tright = A[j][k + 1]\\n\\t\\t\\t\\tA[i][k] = left or mid or right\\n\\n\\tfor i in range(len(A)):\\n\\t\\tif A[-1][i]:\\n\\t\\t\\treturn True\\n\\treturn False  \\nreturn dp(stones)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3965866,
                "title": "c-dp-recursion-memoization-day-27",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool help(int i,int k,vector<int>&s,vector<vector<int>>&dp){\\n        if(i==s.size()-1){\\n            return true;\\n        }\\n        bool a=false;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        for(int j=i+1;j<s.size();j++){\\n            if(s[j]>(s[i]+k+1))break;\\n            else if(s[j]==(s[i]+k-1)){\\n                a |= help(j,k-1,s,dp);\\n            }\\n            else if(s[j]==(s[i]+k)){\\n                 a |= help(j,k,s,dp);\\n            }\\n            else if(s[j]==(s[i]+k+1)){\\n                a |= help(j,k+1,s,dp);\\n            }\\n        }\\n        return dp[i][k]= a;\\n    }\\n    bool canCross(vector<int>& s) {\\n        vector<vector<int>>dp(s.size()+2,vector<int>(4000,-1));\\n        return help(0,0,s,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/62f989f1-6126-4fcf-9541-fa94b9698c4c_1693117485.2971659.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help(int i,int k,vector<int>&s,vector<vector<int>>&dp){\\n        if(i==s.size()-1){\\n            return true;\\n        }\\n        bool a=false;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        for(int j=i+1;j<s.size();j++){\\n            if(s[j]>(s[i]+k+1))break;\\n            else if(s[j]==(s[i]+k-1)){\\n                a |= help(j,k-1,s,dp);\\n            }\\n            else if(s[j]==(s[i]+k)){\\n                 a |= help(j,k,s,dp);\\n            }\\n            else if(s[j]==(s[i]+k+1)){\\n                a |= help(j,k+1,s,dp);\\n            }\\n        }\\n        return dp[i][k]= a;\\n    }\\n    bool canCross(vector<int>& s) {\\n        vector<vector<int>>dp(s.size()+2,vector<int>(4000,-1));\\n        return help(0,0,s,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378725,
                "title": "simple-memoization-binary-search-solution-c-with-explanation",
                "content": "\\n  ```\\nint dp[2001][2001];\\n    bool find(vector<int> &stones, int i,int k){\\n\\t\\t//we reached the ith stone with k jumps \\n\\t\\t\\n        if(i==stones.size()-1) // if i== n-1 i.e. we have reached the last stone so we simply return true\\n            return true;\\n        if(i>=stones.size()) \\n            return false;\\n\\t\\t\\n        if(dp[i][k]!=-1) // if we already encountered this state ,we\\'ll simply return it\\n            return dp[i][k]; \\n\\t\\t\\t\\n        bool res = false;\\n\\t\\t// from here we can either go to k-1 , k , k +1 th stone \\n        for(int j=-1;j<=1;j++){\\n            int next_jump=k+j;\\n            if(next_jump>0){\\n\\t\\t\\t\\n\\t\\t\\t//now the next stone would be = currstone + jump\\n\\t\\t\\t//using binary search to find the index of next stone if it exists\\n             int in= lower_bound(stones.begin(),stones.end(),stones[i]+next_jump)-stones.begin();\\n\\t\\t\\t\\t\\n             if(in == stones.size() || stones[in]!=stones[i]+next_jump) // checking existence of next_stone in array\\n                    continue;\\n\\t\\t\\t\\t//if next stone exists then we will move to that index (in) with the jump that we took\\n                res=res||find(stones,in,next_jump);\\n            }\\n        }\\n\\t\\t\\n        return dp[i][k]=res;\\n        \\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n       memset(dp,-1,sizeof(dp));\\n\\t   \\n        return find(stones, 0,0);\\n        \\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nint dp[2001][2001];\\n    bool find(vector<int> &stones, int i,int k){\\n\\t\\t//we reached the ith stone with k jumps \\n\\t\\t\\n        if(i==stones.size()-1) // if i== n-1 i.e. we have reached the last stone so we simply return true\\n            return true;\\n        if(i>=stones.size()) \\n            return false;\\n\\t\\t\\n        if(dp[i][k]!=-1) // if we already encountered this state ,we\\'ll simply return it\\n            return dp[i][k]; \\n\\t\\t\\t\\n        bool res = false;\\n\\t\\t// from here we can either go to k-1 , k , k +1 th stone \\n        for(int j=-1;j<=1;j++){\\n            int next_jump=k+j;\\n            if(next_jump>0){\\n\\t\\t\\t\\n\\t\\t\\t//now the next stone would be = currstone + jump\\n\\t\\t\\t//using binary search to find the index of next stone if it exists\\n             int in= lower_bound(stones.begin(),stones.end(),stones[i]+next_jump)-stones.begin();\\n\\t\\t\\t\\t\\n             if(in == stones.size() || stones[in]!=stones[i]+next_jump) // checking existence of next_stone in array\\n                    continue;\\n\\t\\t\\t\\t//if next stone exists then we will move to that index (in) with the jump that we took\\n                res=res||find(stones,in,next_jump);\\n            }\\n        }\\n\\t\\t\\n        return dp[i][k]=res;\\n        \\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n       memset(dp,-1,sizeof(dp));\\n\\t   \\n        return find(stones, 0,0);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 223586,
                "title": "python-solution",
                "content": "Dynamic programming bottom-up:\\n\\nUse a dictionary `dic` which maps the position of a stone in `stones` to the set of stepsizes that can jump onto the stone. We initialize `dic = {0:{0}}`, meaning that we start with the stone at position `0`. Next, we iterate `i` over `range(len(stones))`, and check if `stones[i]` is in `dic`, if it is, it means that there are previous jumps that land on this stone, and we can continue jumping ahead, in which case we iterate over all `val` in `dic[stones[i]]`, and for each `val`, we can continue jumping ahead with three stepsizes (`val-1`, `val`, and `val+1`). Therefore, we add `val-1` to `dic[stones[i]+val-1]`, `val` to `dic[stones[i]+val]`, and `val+1` to `dic[stones[i]+val+1]`. Finally, we check if `stones[-1]` is in `dic`, if it is, we return `True`; Else we return `False`.\\n\\nTime complexity: `O(n^2)`, space complexity: `O(n^2)`.\\n\\n```\\nclass Solution:\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dic = collections.defaultdict(set)\\n        dic[0].add(0)\\n        for i in range(len(stones)):\\n            if stones[i] in dic:\\n                for val in dic[stones[i]]:\\n                    if val > 0:\\n                        dic[stones[i]+val].add(val)\\n                    if val > 1:\\n                        dic[stones[i]+val-1].add(val-1)\\n                    dic[stones[i]+val+1].add(val+1)\\n        return stones[-1] in dic\\n```\\n\\nDynamic programming top-down:\\n\\nWe first construct a dictionary mapping the position of each stone in `stones` to its index in `stones`. Now suppose we reach `stones[i]` with a jump of stepsize `step`. Can we reach the last stone (`stones[-1]`)? We define a function `dfs(i, step)` which returns `True` if we can, and returns `False` if we cannot. We can define `dfs(i, step)` recursively by jumping one more step from `stones[i]`. We can jump from `stones[i]` with stepsizes `step-1`, `step`, `step+1`, for each possible `stepsize`, we check if `stones[i]+stepsize` is in `dic`, if it is, it means that we are jumping onto a stone, and it is a valid jump, so we can recursively call `dfs(dic[stones[i]+stepsize], stepsize)`, if it returns `True`, we return `True`; Else we try other stepsizes. If no recursive call returns `True`, it means that we cannot reach the last stone starting with state `(i, step)`, and we return `False`.\\n\\nThe base case for the recursive function `dfs(i, step)` is if `step == 0 or i >= len(stones)`, we return `False`; if `i == len(stones)-1`, we return `True`. \\n\\nWe can also make use of a dictionary to store the values of `dfs(i, step)` for each tuple `(i, step)`, so that we can avoid making the same computation multiple times.\\n\\nTime complexity: `O(n^2)`, space complexity: `O(n^2)`.\\n\\n```\\nclass Solution:\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i, step, first = False):\\n            if step == 0 or i >= len(stones):\\n                return False\\n            if i == len(stones)-1:\\n                return True\\n            if (i, step) in rec:\\n                return rec[(i, step)]\\n            if first:\\n                steps = {step}\\n            else:\\n                steps = {step-1, step, step+1}\\n            for s in steps:\\n                if stones[i]+s in dic:\\n                    if dfs(dic[stones[i]+s], s):\\n                        rec[(i, step)] = True\\n                        return True\\n            rec[(i, step)] = False\\n            return False\\n        \\n        rec = {}\\n        dic = {stones[i]:i for i in range(len(stones))} \\n        return dfs(0, 1, True)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        dic = collections.defaultdict(set)\\n        dic[0].add(0)\\n        for i in range(len(stones)):\\n            if stones[i] in dic:\\n                for val in dic[stones[i]]:\\n                    if val > 0:\\n                        dic[stones[i]+val].add(val)\\n                    if val > 1:\\n                        dic[stones[i]+val-1].add(val-1)\\n                    dic[stones[i]+val+1].add(val+1)\\n        return stones[-1] in dic\\n```\n```\\nclass Solution:\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(i, step, first = False):\\n            if step == 0 or i >= len(stones):\\n                return False\\n            if i == len(stones)-1:\\n                return True\\n            if (i, step) in rec:\\n                return rec[(i, step)]\\n            if first:\\n                steps = {step}\\n            else:\\n                steps = {step-1, step, step+1}\\n            for s in steps:\\n                if stones[i]+s in dic:\\n                    if dfs(dic[stones[i]+s], s):\\n                        rec[(i, step)] = True\\n                        return True\\n            rec[(i, step)] = False\\n            return False\\n        \\n        rec = {}\\n        dic = {stones[i]:i for i in range(len(stones))} \\n        return dfs(0, 1, True)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029170,
                "title": "dp-must-know-this-simple-and-easy-recursion-memo-c-explanation",
                "content": "***If you\\'re able to understand this solution or like the approach do consider to upvote!!*** \\u2728\\n\\n\\nThe basic Idea for recursion is try out all the three possible recursion call i.e for K-1, K and K+1. \\nThese are the following base case I have included.\\n\\n1. if **K <= 0**, that means we can not make a jump so **return false**.\\n2. Then we need to find that whatever the move that has been made, is present in the array or not. That is **stones[i-1] + k** is present ahead in the array or not, We can do simple iteration and find but for quicker implementation i have used **unordered map**.\\n3. Then if dp[i][k] != -1 then used the memo concept, this case could be add after you write recursion.\\n4. Then final base would be if you are able to reach the last element then return true. i == stones.size()-1 .\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool solve(vector<int>& stones, int k, int i, unordered_map<int, int>&mp)\\n    {   \\n          \\n        if(k<=0) return false;\\n        \\n        if(mp.find(k+stones[i-1]) == mp.end()) \\n            return false;\\n        else\\n            i = mp[k+stones[i-1]];\\n        \\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n      \\n        if(i == stones.size()-1) return true;\\n\\n        dp[i][k]  = solve(stones, k-1, i+1,mp) ||  solve(stones, k, i+1,mp) ||  solve(stones, k+1, i+1,mp);\\n        return dp[i][k];\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int k = 1;\\n        int i = 1;\\n        unordered_map<int, int>mp;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<stones.size();i++)\\n            mp.insert({stones[i], i});\\n    \\n        \\n        if(stones[1] != 1) return false;\\n        \\n        return solve(stones, k, i, mp);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool solve(vector<int>& stones, int k, int i, unordered_map<int, int>&mp)\\n    {   \\n          \\n        if(k<=0) return false;\\n        \\n        if(mp.find(k+stones[i-1]) == mp.end()) \\n            return false;\\n        else\\n            i = mp[k+stones[i-1]];\\n        \\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n      \\n        if(i == stones.size()-1) return true;\\n\\n        dp[i][k]  = solve(stones, k-1, i+1,mp) ||  solve(stones, k, i+1,mp) ||  solve(stones, k+1, i+1,mp);\\n        return dp[i][k];\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int k = 1;\\n        int i = 1;\\n        unordered_map<int, int>mp;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<stones.size();i++)\\n            mp.insert({stones[i], i});\\n    \\n        \\n        if(stones[1] != 1) return false;\\n        \\n        return solve(stones, k, i, mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611412,
                "title": "c-recursion-memoization-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[stones[i]] = i;\\n        }\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return recur(stones, mp, 0, 0, dp);\\n    }\\n    \\n    bool recur(vector<int>& stones, map<int, int> &mp, int i, int k, vector<vector<int>>& dp){\\n        if(i == stones.size()-1) return dp[i][k] = 1;\\n        if(dp[i][k] != -1) return dp[i][k];\\n        for(int t=k-1; t<=k+1; t++){\\n            if(t > 0 && mp.find(stones[i]+t) != mp.end()){\\n                int ind = mp[stones[i]+t];\\n                if(recur(stones, mp, ind, t, dp)) return dp[i][k] = 1;\\n            }\\n        }\\n        return dp[i][k] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        map<int, int> mp;\\n        for(int i=0; i<n; i++){\\n            mp[stones[i]] = i;\\n        }\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return recur(stones, mp, 0, 0, dp);\\n    }\\n    \\n    bool recur(vector<int>& stones, map<int, int> &mp, int i, int k, vector<vector<int>>& dp){\\n        if(i == stones.size()-1) return dp[i][k] = 1;\\n        if(dp[i][k] != -1) return dp[i][k];\\n        for(int t=k-1; t<=k+1; t++){\\n            if(t > 0 && mp.find(stones[i]+t) != mp.end()){\\n                int ind = mp[stones[i]+t];\\n                if(recur(stones, mp, ind, t, dp)) return dp[i][k] = 1;\\n            }\\n        }\\n        return dp[i][k] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044350,
                "title": "python-3-very-simple-dynamic-programming-inline-explanation",
                "content": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        dp = [set() for _ in range(len(stones))]\\n        \\n        # 1st step only 1 move possible of value 1\\n        dp[0].add(1)\\n        \\n        for i in range(1,len(stones)):\\n            # check all the previous stones from where the jumps are possible\\n            for j in range(i):\\n                # store the move value required from jth to ith stone\\n                diff = stones[i]-stones[j]\\n                # check if that move value is present in jth stone\\n                if diff in dp[j]:\\n                    # If possible, then add possibilities of move values in the ith stone set\\n                    dp[i].add(diff-1)\\n                    dp[i].add(diff)\\n                    dp[i].add(diff+1)\\n        # If the len of last stone\\'s set is zero, it means no jumps to this stone possible\\n        return True if len(dp[-1])>0 else False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        dp = [set() for _ in range(len(stones))]\\n        \\n        # 1st step only 1 move possible of value 1\\n        dp[0].add(1)\\n        \\n        for i in range(1,len(stones)):\\n            # check all the previous stones from where the jumps are possible\\n            for j in range(i):\\n                # store the move value required from jth to ith stone\\n                diff = stones[i]-stones[j]\\n                # check if that move value is present in jth stone\\n                if diff in dp[j]:\\n                    # If possible, then add possibilities of move values in the ith stone set\\n                    dp[i].add(diff-1)\\n                    dp[i].add(diff)\\n                    dp[i].add(diff+1)\\n        # If the len of last stone\\'s set is zero, it means no jumps to this stone possible\\n        return True if len(dp[-1])>0 else False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268816,
                "title": "do-check-out-c-clean-code-nicely-explained-with-comments",
                "content": "***->*** *Here instead of going to every index one by one, i\\'m just checking if we can make the **next jump** or not, and if we can make that jump then we again check if the **index** corresponding to that **nums[i]+jump** is **greater** than our **current index**, (as frog can only jump in the forward direction) where we are currently standing at.*\\n\\n***->*** *Since it is given that  list of **stones positions (in units)** in sorted **ascending order**,*\\n\\n***->*** *I\\'m **storing the every stone  position and maping it to the index** to check whether the jump we are making from **i\\'th index** to **nums[i] + jump** actually exists on our map.*\\n\\n***->*** *If **nums[i] + jump** exists then we again check whether the **index** corresponding to that **mp[nums[i] + jump]** is greater than the **current index** where we are standing at.*\\n\\n```\\nclass Solution {\\n    unordered_map<int,int> mp;\\n    vector<vector<int>> dp;\\n    bool dfs(vector<int> &nums, int prevJump, int i)\\n    {\\n        if(prevJump<0 or i>=nums.size()) return false;\\n        if(i==nums.size()-1) return true;\\n        if(dp[prevJump][i]!=-1) return dp[prevJump][i];\\n        \\n        bool flag = false;\\n        \\n        if(mp.find(nums[i] + prevJump + 1)!=mp.end() && mp[nums[i] + prevJump + 1]>i) flag|=dfs(nums,prevJump + 1, mp[nums[i] + prevJump + 1]);\\n        \\n        if(mp.find(nums[i] + prevJump - 1)!=mp.end() && mp[nums[i] + prevJump - 1]>i) flag|=dfs(nums,prevJump - 1, mp[nums[i] + prevJump - 1]);\\n        \\n        if(mp.find(nums[i] + prevJump)!=mp.end() && mp[nums[i] + prevJump]>i) flag|=dfs(nums,prevJump, mp[nums[i] + prevJump]);\\n        \\n         return dp[prevJump][i] = flag;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        for(int i=0; i<n; i++) mp[stones[i]] = i;\\n        dp.resize(n+1,vector<int>(n,-1));\\n        return dfs(stones,0,0);\\n    }\\n};\\n```\\n\\n***Please do upvote if you really like the solution :-)***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int,int> mp;\\n    vector<vector<int>> dp;\\n    bool dfs(vector<int> &nums, int prevJump, int i)\\n    {\\n        if(prevJump<0 or i>=nums.size()) return false;\\n        if(i==nums.size()-1) return true;\\n        if(dp[prevJump][i]!=-1) return dp[prevJump][i];\\n        \\n        bool flag = false;\\n        \\n        if(mp.find(nums[i] + prevJump + 1)!=mp.end() && mp[nums[i] + prevJump + 1]>i) flag|=dfs(nums,prevJump + 1, mp[nums[i] + prevJump + 1]);\\n        \\n        if(mp.find(nums[i] + prevJump - 1)!=mp.end() && mp[nums[i] + prevJump - 1]>i) flag|=dfs(nums,prevJump - 1, mp[nums[i] + prevJump - 1]);\\n        \\n        if(mp.find(nums[i] + prevJump)!=mp.end() && mp[nums[i] + prevJump]>i) flag|=dfs(nums,prevJump, mp[nums[i] + prevJump]);\\n        \\n         return dp[prevJump][i] = flag;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        for(int i=0; i<n; i++) mp[stones[i]] = i;\\n        dp.resize(n+1,vector<int>(n,-1));\\n        return dfs(stones,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 660804,
                "title": "complete-explanation-from-basic-with-c-code-using-recursion-and-memoization",
                "content": "Before coming to the intuition and explanation part I would like to emphasize on three important observation needed for this question.\\n***(1.)*** if(1 + stones[0] < stones[1])  return false;\\n      we should check this condition before hand, it is mentioned in this question that you can only   take 1 step from 0th position.\\n***(2.)*** while jumping from one stone location to another, we should land exactly at that particular location, neither before nor ahead, as if you do so you will miss out the stone and will fall into water.\\n***(3.)*** It might be possible that the given array may contain multiple stone at a particular location, say [0,1,2,3,3,4,5,6,6,7], this thing effectivily reduces to [0,1,2,3,4,5,6,7]. We consider multiple stones at a given location to be attached and index associated with them to be the largest (this thing will be clear when we build our map in solution)\\n\\n***INTUITION***\\nIt is quiet easy to think that while standing at a particular location you should try all possible jumps i.e. (k-1), (k) and (k+1). If any of the call returns true, then our frog will be able to cross the river. We store all the stone location in a map to determine whether the jump is valid or not, if not we return false and it is valid we recur further. This thing will be clear from the code.\\n\\n***BASIC RECURSION CODE***\\n```\\nbool isJumpPossible(int n,unordered_map<int,int>& mp,int value,int index,int k,vector<int>& stones){\\n    \\n    if(index == n-1)    return true;\\n    \\n    if(value != stones[index]) return false;\\n    \\n    bool opt1 = false;\\n    bool opt2 = false;\\n    bool opt3 = false;\\n    \\n    if(k-1 > 0 && mp.find(value+k-1) != mp.end()){\\n        opt1 = isJumpPossible(n,mp,value+k-1,mp[value+k-1],k-1,stones);\\n    }\\n    \\n    if(mp.find(value+k) != mp.end()){\\n        opt2 = isJumpPossible(n,mp,value+k,mp[value+k],k,stones);\\n    }\\n    \\n    if(mp.find(value+k+1) != mp.end()){\\n        opt3 = isJumpPossible(n,mp,value+k+1,mp[value+k+1],k+1,stones);\\n    }\\n    \\n    if(opt1 || opt2 || opt3)    return true;\\n    return false;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        if(n < 2) return false;\\n        if(1 + stones[0] < stones[1])   return false;\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[stones[i]] = i;\\n        }\\n        \\n        return isJumpPossible(n,mp,stones[1],1,1,stones);\\n        \\n    }\\n};\\n```\\n \\n***complexity of above code is (3^n), because at every position we have three possible calls to evaluate. To improve upon time complexity we will apply memoization.***\\n\\n```\\nbool isJumpPossible(int n,unordered_map<int,int>& mp,int value,int index,int k,vector<int>& stones,vector<vector<int>>& dp){\\n    \\n    if(index == n-1)   return dp[index][k] = true;\\n    \\n    if(dp[index][k] != -1){\\n        if(dp[index][k] == 1)   return true;\\n        return false;\\n    }\\n    \\n    if(value != stones[index]) return dp[index][k] = false;\\n    \\n    bool opt1 = false;\\n    bool opt2 = false;\\n    bool opt3 = false;\\n    \\n    if(k-1 > 0 && mp.find(value+k-1) != mp.end()){\\n        opt1 = isJumpPossible(n,mp,value+k-1,mp[value+k-1],k-1,stones,dp);\\n    }\\n    \\n    if(mp.find(value+k) != mp.end()){\\n        opt2 = isJumpPossible(n,mp,value+k,mp[value+k],k,stones,dp);\\n    }\\n    \\n    if(mp.find(value+k+1) != mp.end()){\\n        opt3 = isJumpPossible(n,mp,value+k+1,mp[value+k+1],k+1,stones,dp);\\n    }\\n    \\n    if(opt1 || opt2 || opt3)    return dp[index][k] = true;\\n    return dp[index][k] = false;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        if(n < 2) return false;\\n        if(1 + stones[0] < stones[1])   return false;\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[stones[i]] = i;\\n        }\\n        vector<vector<int>> dp(n,vector<int>(1000,-1));\\n        return isJumpPossible(n,mp,stones[1],1,1,stones,dp);\\n        \\n    }\\n};\\n```\\n\\nhope it helps!!\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nbool isJumpPossible(int n,unordered_map<int,int>& mp,int value,int index,int k,vector<int>& stones){\\n    \\n    if(index == n-1)    return true;\\n    \\n    if(value != stones[index]) return false;\\n    \\n    bool opt1 = false;\\n    bool opt2 = false;\\n    bool opt3 = false;\\n    \\n    if(k-1 > 0 && mp.find(value+k-1) != mp.end()){\\n        opt1 = isJumpPossible(n,mp,value+k-1,mp[value+k-1],k-1,stones);\\n    }\\n    \\n    if(mp.find(value+k) != mp.end()){\\n        opt2 = isJumpPossible(n,mp,value+k,mp[value+k],k,stones);\\n    }\\n    \\n    if(mp.find(value+k+1) != mp.end()){\\n        opt3 = isJumpPossible(n,mp,value+k+1,mp[value+k+1],k+1,stones);\\n    }\\n    \\n    if(opt1 || opt2 || opt3)    return true;\\n    return false;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        if(n < 2) return false;\\n        if(1 + stones[0] < stones[1])   return false;\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[stones[i]] = i;\\n        }\\n        \\n        return isJumpPossible(n,mp,stones[1],1,1,stones);\\n        \\n    }\\n};\\n```\n```\\nbool isJumpPossible(int n,unordered_map<int,int>& mp,int value,int index,int k,vector<int>& stones,vector<vector<int>>& dp){\\n    \\n    if(index == n-1)   return dp[index][k] = true;\\n    \\n    if(dp[index][k] != -1){\\n        if(dp[index][k] == 1)   return true;\\n        return false;\\n    }\\n    \\n    if(value != stones[index]) return dp[index][k] = false;\\n    \\n    bool opt1 = false;\\n    bool opt2 = false;\\n    bool opt3 = false;\\n    \\n    if(k-1 > 0 && mp.find(value+k-1) != mp.end()){\\n        opt1 = isJumpPossible(n,mp,value+k-1,mp[value+k-1],k-1,stones,dp);\\n    }\\n    \\n    if(mp.find(value+k) != mp.end()){\\n        opt2 = isJumpPossible(n,mp,value+k,mp[value+k],k,stones,dp);\\n    }\\n    \\n    if(mp.find(value+k+1) != mp.end()){\\n        opt3 = isJumpPossible(n,mp,value+k+1,mp[value+k+1],k+1,stones,dp);\\n    }\\n    \\n    if(opt1 || opt2 || opt3)    return dp[index][k] = true;\\n    return dp[index][k] = false;\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        int n = stones.size();\\n        if(n < 2) return false;\\n        if(1 + stones[0] < stones[1])   return false;\\n        \\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            mp[stones[i]] = i;\\n        }\\n        vector<vector<int>> dp(n,vector<int>(1000,-1));\\n        return isJumpPossible(n,mp,stones[1],1,1,stones,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967612,
                "title": "recursion-memoization-using-binary-search-or-hashmap-complexity-analysis",
                "content": "# Intuition:\\nVery simple once you understand the description.\\nThe frog starts at index 0.\\nIn every input case, it will first take 1 unit jump. Therefore, it will go from 0 to 1. So, if any input case doesn\\'t contain `stones[1] = 1`, we directly return false. Because, the frog wont be able to take 1 unit of jump initially.\\nThen when, it is in index i, it has 3 options to choose: (assume previous jump was 1 unit and current stone value = 2)\\n- it can jump to `current stone + (previous unit - 1)` stone if exists.\\n- it can jump to `current stone + previous unit` stone if exists.\\n- it can jump to `current stone + (previous unit + 1)` stone if exists.\\n- If the frog reaches `idx == n-1` it reaches the end. We `return true`.\\n\\n# Using Binary Search:\\n``` java []\\nclass Solution {\\n    int n;\\n    Boolean[][] memo;\\n    public boolean canCross(int[] stones) {\\n        n = stones.length;\\n        if(stones[1]!=1) {\\n            return false;\\n        }\\n        memo = new Boolean[2001][2001];\\n        return helper(1, 1, stones);\\n    }\\n    boolean helper(int idx, int prevUnit, int[] stones) {\\n        if(idx == n-1) {\\n            return true;\\n        }\\n        if(memo[idx][prevUnit]!=null) {\\n            return memo[idx][prevUnit];\\n        }\\n        boolean ans = false;\\n        for(int nextJump = prevUnit-1; nextJump<=prevUnit+1 && !ans; nextJump++) {\\n            if(nextJump>0) {\\n                int nextStone = stones[idx]+nextJump;\\n                int nextIdx = binSearch(idx, stones, nextStone);\\n                if(nextIdx!=-1) {\\n                    ans = ans || helper(nextIdx, nextJump, stones);\\n                }\\n            }\\n        }\\n        return memo[idx][prevUnit] = ans;\\n    }\\n\\n    int binSearch(int idx, int[] stones, int target) {\\n        int left = idx;\\n        int right = n-1;\\n        while(left <= right) {\\n            int mid = right - (right-left)/2;\\n            if(stones[mid] == target) {\\n                return mid;\\n            }\\n            else if(stones[mid]>target) {\\n                right = mid-1;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n# Complexity Analysis:\\n\\nHere, $N$ is the number of stones in the river.\\n- Time Complexity: $O(N^2 \\\\log N)$\\n$O(N^2)$ for recursion with memoization. Additional $\\\\log N$ is because we do binary search.\\n\\n- Space Complexity: $O(N^2)$\\nThe array `Boolean[][] memo` will take $N^2$ space.\\n\\n\\n# Using HashMap:\\n\\n``` java []\\nclass Solution {\\n    int n;\\n    Boolean[][] memo;\\n    Map<Integer, Integer> mp;\\n    public boolean canCross(int[] stones) {\\n        n = stones.length;\\n        if(stones[1]!=1) {\\n            return false;\\n        }\\n        memo = new Boolean[2001][2001];\\n        mp = new HashMap<>();\\n        for(int i=0; i<n; i++) {\\n            mp.put(stones[i], i);\\n        }\\n        return helper(1, 1, stones);\\n    }\\n    boolean helper(int idx, int prevUnit, int[] stones) {\\n        if(idx == n-1) {\\n            return true;\\n        }\\n        if(memo[idx][prevUnit]!=null) {\\n            return memo[idx][prevUnit];\\n        }\\n        boolean ans = false;\\n        for(int nextJump = prevUnit-1; nextJump<=prevUnit+1 && !ans; nextJump++) {\\n            if(nextJump > 0) {\\n                int nextStone = stones[idx]+nextJump;\\n                if(mp.containsKey(nextStone)) {\\n                    ans = ans || helper(mp.get(nextStone), nextJump, stones);\\n                }\\n            }\\n        }\\n        return memo[idx][prevUnit] = ans;\\n    }\\n}\\n```\\n\\n# Complexity Analysis:\\n\\nHere, $N$ is the number of stones in the river.\\n- Time Complexity: $O(N^2)$\\n$O(N^2)$ for recursion with memoization.\\n\\n- Space Complexity: $O(N^2)$\\nThe array `Boolean[][] memo` and `HashMap<Integer, Integer>` will take $N^2$ space.\\n\\n![images.jpg](https://assets.leetcode.com/users/images/a7e11553-743d-47b2-9092-025d3fe036d1_1693143945.7202945.jpeg)\\n\\n### Writing a solution takes a lot of effort. Feel free to upvote this one!\\n",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` java []\\nclass Solution {\\n    int n;\\n    Boolean[][] memo;\\n    public boolean canCross(int[] stones) {\\n        n = stones.length;\\n        if(stones[1]!=1) {\\n            return false;\\n        }\\n        memo = new Boolean[2001][2001];\\n        return helper(1, 1, stones);\\n    }\\n    boolean helper(int idx, int prevUnit, int[] stones) {\\n        if(idx == n-1) {\\n            return true;\\n        }\\n        if(memo[idx][prevUnit]!=null) {\\n            return memo[idx][prevUnit];\\n        }\\n        boolean ans = false;\\n        for(int nextJump = prevUnit-1; nextJump<=prevUnit+1 && !ans; nextJump++) {\\n            if(nextJump>0) {\\n                int nextStone = stones[idx]+nextJump;\\n                int nextIdx = binSearch(idx, stones, nextStone);\\n                if(nextIdx!=-1) {\\n                    ans = ans || helper(nextIdx, nextJump, stones);\\n                }\\n            }\\n        }\\n        return memo[idx][prevUnit] = ans;\\n    }\\n\\n    int binSearch(int idx, int[] stones, int target) {\\n        int left = idx;\\n        int right = n-1;\\n        while(left <= right) {\\n            int mid = right - (right-left)/2;\\n            if(stones[mid] == target) {\\n                return mid;\\n            }\\n            else if(stones[mid]>target) {\\n                right = mid-1;\\n            }\\n            else {\\n                left = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    int n;\\n    Boolean[][] memo;\\n    Map<Integer, Integer> mp;\\n    public boolean canCross(int[] stones) {\\n        n = stones.length;\\n        if(stones[1]!=1) {\\n            return false;\\n        }\\n        memo = new Boolean[2001][2001];\\n        mp = new HashMap<>();\\n        for(int i=0; i<n; i++) {\\n            mp.put(stones[i], i);\\n        }\\n        return helper(1, 1, stones);\\n    }\\n    boolean helper(int idx, int prevUnit, int[] stones) {\\n        if(idx == n-1) {\\n            return true;\\n        }\\n        if(memo[idx][prevUnit]!=null) {\\n            return memo[idx][prevUnit];\\n        }\\n        boolean ans = false;\\n        for(int nextJump = prevUnit-1; nextJump<=prevUnit+1 && !ans; nextJump++) {\\n            if(nextJump > 0) {\\n                int nextStone = stones[idx]+nextJump;\\n                if(mp.containsKey(nextStone)) {\\n                    ans = ans || helper(mp.get(nextStone), nextJump, stones);\\n                }\\n            }\\n        }\\n        return memo[idx][prevUnit] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965593,
                "title": "simple-code-in-c-multiple-approaches-explanation-not-needed",
                "content": "PLS UPVOTE IF YOU UNDERSTOOD :) \\n# RECURSION (TLE)\\n```\\nclass Solution {\\npublic:\\n    bool canCrossHelper(int currentPosition, vector<int> &stones, int lastJump, int totalStones) {\\n        // Base case: If the current position is at the last stone, we have successfully crossed the river.\\n        if (currentPosition == totalStones - 1)\\n            return true;\\n\\n        bool canCrossFlag = false;\\n\\n        // Iterate through stones from the current position to explore possible jumps.\\n        for (int nextPosition = currentPosition + 1; nextPosition < totalStones; nextPosition++) {\\n            // Try different jump sizes, including one step less, current step, and one step more.\\n            for (int jumpSize = lastJump - 1; jumpSize <= lastJump + 1; jumpSize++) {\\n                // Check if the difference between the next stone\\'s position and the current stone\\'s position\\n                // matches the expected jump size. If so, recursively check if we can cross from the next stone.\\n                if (stones[nextPosition] - stones[currentPosition] == jumpSize)\\n                    canCrossFlag |= canCrossHelper(nextPosition, stones, jumpSize, totalStones);\\n            }\\n        }\\n\\n        return canCrossFlag;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        int totalStones = stones.size();\\n        return canCrossHelper(0, stones, 0, totalStones);\\n    }\\n};\\n\\n```\\n\\n# MEMOIZATION (PASSED)\\n```\\nclass Solution {\\npublic:\\n    bool canCrossHelper(int currentPosition, vector<int> &stones, int lastJump, int totalStones, vector<vector<int>> &memo) {\\n        // Base case: If the current position is beyond the last stone, we cannot cross.\\n        if (currentPosition >= totalStones)\\n            return false;\\n        \\n        // If we\\'ve reached the last stone, we\\'ve successfully crossed.\\n        if (currentPosition == totalStones - 1)\\n            return true;\\n\\n        // If the result for the current state is already computed, return it.\\n        if (memo[currentPosition][lastJump] != -1)\\n            return memo[currentPosition][lastJump];\\n\\n        bool canCrossFlag = false;\\n\\n        // Iterate through stones from the current position to explore possible jumps.\\n        for (int nextPosition = currentPosition + 1; nextPosition < totalStones; nextPosition++) {\\n            // Try different jump sizes, including one step less, current step, and one step more.\\n            for (int jumpSize = lastJump - 1; jumpSize <= lastJump + 1; jumpSize++) {\\n                // Check if the difference between the next stone\\'s position and the current stone\\'s position\\n                // matches the expected jump size. If so, recursively check if we can cross from the next stone.\\n                if (stones[nextPosition] - stones[currentPosition] == jumpSize)\\n                    canCrossFlag |= canCrossHelper(nextPosition, stones, jumpSize, totalStones, memo);\\n            }\\n        }\\n\\n        // Store the result in the memoization table and return it.\\n        return memo[currentPosition][lastJump] = canCrossFlag;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        int totalStones = stones.size();\\n        vector<vector<int>> memo(totalStones, vector<int>(totalStones, -1)); // Initialize memoization table.\\n        return canCrossHelper(0, stones, 0, totalStones, memo);\\n    }\\n};\\n\\n```\\n# MEMOIZATION + HASHMAP FASTER (PASSED)\\n```\\nclass Solution {\\npublic:\\n    bool helper(int i,vector<int> &stones,int jump,vector<vector<int>> &dp,unordered_map<int,int> &um){\\n        if(i==stones.size()-1)\\n            return true;\\n        if(dp[i][jump]!=-1)\\n            return dp[i][jump];\\n        bool flag = false;\\n\\n        for(int t = -1;t<2;t++){\\n            int curr = stones[i] + jump + t;\\n            if(curr>0 && um.find(curr)!=um.end() && um[curr]!=i){\\n                flag|=helper(um[curr],stones,jump+t,dp,um);\\n            }\\n        }\\n        return dp[i][jump] = flag;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        vector<vector<int>> dp(2010,vector<int>(2010,-1));\\n        unordered_map<int,int> um;\\n        for(int i=0;i<stones.size();i++)\\n            um[stones[i]] = i;\\n        return helper(0,stones,0,dp,um);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCrossHelper(int currentPosition, vector<int> &stones, int lastJump, int totalStones) {\\n        // Base case: If the current position is at the last stone, we have successfully crossed the river.\\n        if (currentPosition == totalStones - 1)\\n            return true;\\n\\n        bool canCrossFlag = false;\\n\\n        // Iterate through stones from the current position to explore possible jumps.\\n        for (int nextPosition = currentPosition + 1; nextPosition < totalStones; nextPosition++) {\\n            // Try different jump sizes, including one step less, current step, and one step more.\\n            for (int jumpSize = lastJump - 1; jumpSize <= lastJump + 1; jumpSize++) {\\n                // Check if the difference between the next stone\\'s position and the current stone\\'s position\\n                // matches the expected jump size. If so, recursively check if we can cross from the next stone.\\n                if (stones[nextPosition] - stones[currentPosition] == jumpSize)\\n                    canCrossFlag |= canCrossHelper(nextPosition, stones, jumpSize, totalStones);\\n            }\\n        }\\n\\n        return canCrossFlag;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        int totalStones = stones.size();\\n        return canCrossHelper(0, stones, 0, totalStones);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool canCrossHelper(int currentPosition, vector<int> &stones, int lastJump, int totalStones, vector<vector<int>> &memo) {\\n        // Base case: If the current position is beyond the last stone, we cannot cross.\\n        if (currentPosition >= totalStones)\\n            return false;\\n        \\n        // If we\\'ve reached the last stone, we\\'ve successfully crossed.\\n        if (currentPosition == totalStones - 1)\\n            return true;\\n\\n        // If the result for the current state is already computed, return it.\\n        if (memo[currentPosition][lastJump] != -1)\\n            return memo[currentPosition][lastJump];\\n\\n        bool canCrossFlag = false;\\n\\n        // Iterate through stones from the current position to explore possible jumps.\\n        for (int nextPosition = currentPosition + 1; nextPosition < totalStones; nextPosition++) {\\n            // Try different jump sizes, including one step less, current step, and one step more.\\n            for (int jumpSize = lastJump - 1; jumpSize <= lastJump + 1; jumpSize++) {\\n                // Check if the difference between the next stone\\'s position and the current stone\\'s position\\n                // matches the expected jump size. If so, recursively check if we can cross from the next stone.\\n                if (stones[nextPosition] - stones[currentPosition] == jumpSize)\\n                    canCrossFlag |= canCrossHelper(nextPosition, stones, jumpSize, totalStones, memo);\\n            }\\n        }\\n\\n        // Store the result in the memoization table and return it.\\n        return memo[currentPosition][lastJump] = canCrossFlag;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        int totalStones = stones.size();\\n        vector<vector<int>> memo(totalStones, vector<int>(totalStones, -1)); // Initialize memoization table.\\n        return canCrossHelper(0, stones, 0, totalStones, memo);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool helper(int i,vector<int> &stones,int jump,vector<vector<int>> &dp,unordered_map<int,int> &um){\\n        if(i==stones.size()-1)\\n            return true;\\n        if(dp[i][jump]!=-1)\\n            return dp[i][jump];\\n        bool flag = false;\\n\\n        for(int t = -1;t<2;t++){\\n            int curr = stones[i] + jump + t;\\n            if(curr>0 && um.find(curr)!=um.end() && um[curr]!=i){\\n                flag|=helper(um[curr],stones,jump+t,dp,um);\\n            }\\n        }\\n        return dp[i][jump] = flag;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        vector<vector<int>> dp(2010,vector<int>(2010,-1));\\n        unordered_map<int,int> um;\\n        for(int i=0;i<stones.size();i++)\\n            um[stones[i]] = i;\\n        return helper(0,stones,0,dp,um);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528107,
                "title": "recursive-dp-memoization-bruteforce-to-better-c",
                "content": "**Recursive Approach**\\nIt is clearly stated in problem that  each stone can reached from previous stone by making a jump of sizes (k - 1, k, k + 1),  where k is the step size to reach the previous stone, implies that for every stone we have three possibilities ignoring wheather the steps are valid or invalid.\\nThis simply becomes our recursive cases/ calls from current stone where the frog is present.\\n\\n\\n\\nApproaching to recursive Solution\\n**Step - 1:**\\n\\t\\tuse unordered_map<int,int> basically a hash Map to store the particular stone location along with the Index\\n```\\n for(int i = 0; i < stones.size(); i++)\\n            hashMap[stones[i]] = i;\\n```\\n**Step-2**\\n\\twriting a function that takes stones vector, current Index, steps that are possible.(int our case current Index = 0, steps = 1) from problem statement\\n\\t**Base Cases**\\n\\t\\t1. It is clearly stated in the problem that frog should reach to the last stone present in the river, if we somehow reach this final stone, then the frog can cross the river.\\n\\t\\t2.  If the current stone we looking for is not found or steps size becomes less than or equal to zero we should return false(invalid State), since from problem statement it is clear there should be only forward moment.\\n```\\nif(currIdx == stones.size() - 1)\\n            return true;\\nif(hashMap.find(stones[currIdx] + steps) == hashMap.end() or steps <= 0)\\n            return false;\\n```\\n\\n**Recursive Code**\\n\\n```\\n\\tunordered_map<int,int> hashMap;\\n\\tbool isPossible(vector<int>& stones, int currIdx, int steps){\\n\\n\\t\\tif(hashMap.find(stones[currIdx] + steps) == hashMap.end() or steps <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// shifting current index to stone position that can be reachable\\n\\t\\tcurrIdx = hashMap[stones[currIdx] + steps];\\n\\n\\t\\tif(currIdx == stones.size() - 1)\\n\\t\\t\\treturn true;\\n\\n\\t\\tbool oneStepBack = isPossible(stones, currIdx, steps - 1);\\n\\t\\tbool sameSteps = isPossible(stones, currIdx, steps);\\n\\t\\tbool oneStepForward = isPossible(stones, currIdx, steps + 1);\\n\\n\\t\\treturn oneStepBack or sameSteps or oneStepForward;\\n\\n\\t}\\n\\tbool canCross(vector<int>& stones) {\\n\\t\\tfor(int i = 0; i < stones.size(); i++)\\n\\t\\t\\thashMap[stones[i]] = i;\\n\\t\\treturn isPossible(stones, 0, 1);\\n\\t}\\n```\\n\\n**Recrsive to Dp conversion** **Memoization**\\n****Identify the recursive function argument that are going to change for each recursive call****\\nThose are steps, currIdex if we some how store that subProblem that we solved before so that it can be reused, since we can clearly see overlapping,(draw stack space tree if you can).\\n\\n\\t    class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tunordered_map<int,int> hashMap;\\n\\t\\t\\tunordered_map<string,bool> memo;\\n\\t\\t\\tbool isPossible(vector<int>& stones, int currIdx, int steps){\\n\\n\\t\\t\\t\\tif(hashMap.find(stones[currIdx] + steps) == hashMap.end() or steps <= 0)\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\tcurrIdx = hashMap[stones[currIdx] + steps];\\n\\n\\t\\t\\t\\tstring currKey = to_string(currIdx) + \\';\\' + to_string(steps);\\n\\n\\t\\t\\t\\tif(memo.find(currKey) != memo.end())\\n\\t\\t\\t\\t\\treturn memo[currKey];\\n\\n\\t\\t\\t\\tif(currIdx == stones.size() - 1)\\n\\t\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t\\tbool oneStepBack = isPossible(stones, currIdx, steps - 1);\\n\\t\\t\\t\\tbool sameSteps = isPossible(stones, currIdx, steps);\\n\\t\\t\\t\\tbool oneStepForward = isPossible(stones, currIdx, steps + 1);\\n\\n\\t\\t\\t\\tmemo[currKey] = oneStepBack or sameSteps or oneStepForward;\\n\\n\\t\\t\\t\\treturn memo[currKey];\\n\\n\\t\\t}\\n\\t\\tbool canCross(vector<int>& stones) {\\n\\t\\t\\tfor(int i = 0; i < stones.size(); i++)\\n\\t\\t\\t\\thashMap[stones[i]] = i;\\n\\t\\t\\treturn isPossible(stones, 0, 1);\\n\\t\\t}\\n\\t};\\n********\\n\\n\\t\\n\\n",
                "solutionTags": [],
                "code": "```\\n for(int i = 0; i < stones.size(); i++)\\n            hashMap[stones[i]] = i;\\n```\n```\\nif(currIdx == stones.size() - 1)\\n            return true;\\nif(hashMap.find(stones[currIdx] + steps) == hashMap.end() or steps <= 0)\\n            return false;\\n```\n```\\n\\tunordered_map<int,int> hashMap;\\n\\tbool isPossible(vector<int>& stones, int currIdx, int steps){\\n\\n\\t\\tif(hashMap.find(stones[currIdx] + steps) == hashMap.end() or steps <= 0)\\n\\t\\t\\treturn false;\\n\\n\\t\\t// shifting current index to stone position that can be reachable\\n\\t\\tcurrIdx = hashMap[stones[currIdx] + steps];\\n\\n\\t\\tif(currIdx == stones.size() - 1)\\n\\t\\t\\treturn true;\\n\\n\\t\\tbool oneStepBack = isPossible(stones, currIdx, steps - 1);\\n\\t\\tbool sameSteps = isPossible(stones, currIdx, steps);\\n\\t\\tbool oneStepForward = isPossible(stones, currIdx, steps + 1);\\n\\n\\t\\treturn oneStepBack or sameSteps or oneStepForward;\\n\\n\\t}\\n\\tbool canCross(vector<int>& stones) {\\n\\t\\tfor(int i = 0; i < stones.size(); i++)\\n\\t\\t\\thashMap[stones[i]] = i;\\n\\t\\treturn isPossible(stones, 0, 1);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128294,
                "title": "java-short-dp-solution",
                "content": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap();\\n        \\n        for(int val: stones) dp.put(val, new HashSet());\\n        dp.get(stones[0]).add(1);\\n        \\n        for(int val: stones){\\n            for(int jump: dp.get(val)){\\n                if(jump!= 0 && dp.containsKey(val+jump)){\\n                    dp.get(val+jump).add(jump-1);\\n                    dp.get(val+jump).add(jump);\\n                    dp.get(val+jump).add(jump+1);\\n                }\\n            }\\n        }\\n        \\n        return !dp.get(stones[stones.length-1]).isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap();\\n        \\n        for(int val: stones) dp.put(val, new HashSet());\\n        dp.get(stones[0]).add(1);\\n        \\n        for(int val: stones){\\n            for(int jump: dp.get(val)){\\n                if(jump!= 0 && dp.containsKey(val+jump)){\\n                    dp.get(val+jump).add(jump-1);\\n                    dp.get(val+jump).add(jump);\\n                    dp.get(val+jump).add(jump+1);\\n                }\\n            }\\n        }\\n        \\n        return !dp.get(stones[stones.length-1]).isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251326,
                "title": "general-dp-lis-solution-in-python",
                "content": "The problem is a member of the ```longest increasing subsequence``` problems family which is called ```LIS``` usually. And its DP solution is also general. It looks very consice.\\n```\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        N = len(stones)\\n        if N == 0 or (N > 1 and stones[1] != 1):\\n            return False\\n\\t\\t\\t\\n        dp = [False for _ in range(N)]  # dp[i] means whether stone i can be reached or not\\n        dp[0] = dp[1] = True\\n        next_jump = collections.defaultdict(list)   # to record the possible next jumps from stone i\\n        next_jump[1] = [0, 1, 2]\\n\\n        for i in range(2, N):\\n            for j in range(1, i):\\n                need_jump = stones[i] - stones[j]\\n                if dp[j] and need_jump in next_jump[j]:\\n                    dp[i] = True\\n                    next_jump[i].extend([need_jump, need_jump + 1, need_jump - 1])\\n\\n        return dp[N - 1]\\n```",
                "solutionTags": [],
                "code": "```longest increasing subsequence```\n```LIS```\n```\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n\\n        N = len(stones)\\n        if N == 0 or (N > 1 and stones[1] != 1):\\n            return False\\n\\t\\t\\t\\n        dp = [False for _ in range(N)]  # dp[i] means whether stone i can be reached or not\\n        dp[0] = dp[1] = True\\n        next_jump = collections.defaultdict(list)   # to record the possible next jumps from stone i\\n        next_jump[1] = [0, 1, 2]\\n\\n        for i in range(2, N):\\n            for j in range(1, i):\\n                need_jump = stones[i] - stones[j]\\n                if dp[j] and need_jump in next_jump[j]:\\n                    dp[i] = True\\n                    next_jump[i].extend([need_jump, need_jump + 1, need_jump - 1])\\n\\n        return dp[N - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 938897,
                "title": "java-dfs-memo-o-n-2-didn-t-see-mine-in-solution",
                "content": "Since speed can only max +1 for each stone, speed is bounded by n\\nWe can create a memo for Boolean[n][n] = Boolean[at which stone][at what speed]\\nThe base case is if we reached to last stone we return true, and default as false for any other position.\\nWe use stoneIndex(HashMap) to track if (our stone position + speed) can reach to next stone.\\n```\\nclass Solution {\\n    Map<Integer, Integer> stoneIndex = new HashMap<>();\\n    Boolean[][] dp;\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        for(int i = 0; i < n; i++)\\n            stoneIndex.put(stones[i], i);\\n        dp = new Boolean[n][n];\\n        return dfs(0, n, stones, 0);\\n    }\\n    \\n    boolean dfs(int pos, int n, int[] stones, int speed){\\n        if(pos == n-1)\\n            return true;\\n        if(dp[pos][speed] != null)\\n            return dp[pos][speed];\\n        \\n        boolean local = false;\\n        \\n        Integer slow = stoneIndex.get(stones[pos] + speed-1);\\n        Integer same = stoneIndex.get(stones[pos] + speed);\\n        Integer fast = stoneIndex.get(stones[pos] + speed+1);\\n        \\n        if(slow != null && speed-1 > 0)\\n            local = local || dfs(slow, n, stones, speed-1);\\n        if(same != null && speed > 0)\\n            local = local || dfs(same, n, stones, speed);\\n        if(fast != null)\\n            local = local || dfs(fast, n, stones, speed+1);\\n        \\n        dp[pos][speed] = local;\\n        return local;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Iterator"
                ],
                "code": "class Solution {\\n    Map<Integer, Integer> stoneIndex = new HashMap<>();\\n    Boolean[][] dp;\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        for(int i = 0; i < n; i++)\\n            stoneIndex.put(stones[i], i);\\n        dp = new Boolean[n][n];\\n        return dfs(0, n, stones, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 635538,
                "title": "easy-to-understand-c-solution-using-top-down-approach-with-memoization-faster-than-92-63",
                "content": "```\\nclass Solution {\\npublic:\\n    int cal(int i,int k,vector<int>&v,unordered_map<int,int>&index,int dp[][1100]){\\n        if(i+1==v.size())\\n            return 1;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        int x=0,y=0,z=0;\\n        \\n        if(k-1>0 and index.count(v[i]+k-1)>0)\\n            x=cal(index[v[i]+k-1],k-1,v,index,dp);\\n        \\n        if(x==0 and index.count(v[i]+k)>0)\\n            y=cal(index[v[i]+k],k,v,index,dp);\\n        \\n        if(x==0 and y==0 and index.count(v[i]+k+1)>0)\\n            z=cal(index[v[i]+k+1],k+1,v,index,dp);\\n        \\n        dp[i][k]=(x|y)|z;\\n        \\n        return dp[i][k];\\n    }\\n    \\n    bool canCross(vector<int>&v) {\\n        unordered_map<int,int>index;\\n        for(int i=0;i<v.size();i++)\\n            index[v[i]]=i;\\n        int dp[1100][1100];\\n        memset(dp,-1,sizeof(dp));\\n        if(v[1]==1 and cal(1,1,v,index,dp))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cal(int i,int k,vector<int>&v,unordered_map<int,int>&index,int dp[][1100]){\\n        if(i+1==v.size())\\n            return 1;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        int x=0,y=0,z=0;\\n        \\n        if(k-1>0 and index.count(v[i]+k-1)>0)\\n            x=cal(index[v[i]+k-1],k-1,v,index,dp);\\n        \\n        if(x==0 and index.count(v[i]+k)>0)\\n            y=cal(index[v[i]+k],k,v,index,dp);\\n        \\n        if(x==0 and y==0 and index.count(v[i]+k+1)>0)\\n            z=cal(index[v[i]+k+1],k+1,v,index,dp);\\n        \\n        dp[i][k]=(x|y)|z;\\n        \\n        return dp[i][k];\\n    }\\n    \\n    bool canCross(vector<int>&v) {\\n        unordered_map<int,int>index;\\n        for(int i=0;i<v.size();i++)\\n            index[v[i]]=i;\\n        int dp[1100][1100];\\n        memset(dp,-1,sizeof(dp));\\n        if(v[1]==1 and cal(1,1,v,index,dp))\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423430,
                "title": "dead-simple-js-solution-work-backwards-100-100",
                "content": "By working backwards, we can eliminate the vast majority of possibilities because of the given constraints. There\\'s one advantage in particular we have when working backwards: we know we must end on 1 hop.\\n\\nStarting at the end of the array, calculate the distance (`dst`) between the current element (`i`) and each of the previous elements (`j`) in the array:\\n* If `dst` is greater than `j+1`, that means we won\\'t be able to end on 1 hop, even if we subtract 1 from every hop from `i` down to 0. We can immediately abort this path.\\n* At next step, the last `dst` used becomes our `k` -- so we know that `k-1` <= `dst` <= `k+1` must hold true. If `dst` > `k+1`, we can immediately abort this path since `dst` will only increase as `j` decreases. If `dst` < `k-1`, we should skip this iteration because `dst` falls outside of our required range, but we still continue down this path since `dst` will increase as `j` decreases.\\n\\n```\\n/**\\n * @param {number[]} stones\\n * @return {boolean}\\n */\\nvar canCross = function(stones) {\\n    function recurse(i, k) {\\n        const last = stones[i];\\n        for (let j = i - 1; j >= 0; j--) {\\n            const dst = last - stones[j];\\n            if (dst > j + 1) return false;\\n            if (k) {\\n                if (dst > k + 1) return false;\\n                if (dst < k - 1) continue;\\n            }\\n            if (recurse(j, dst))\\n                return true;\\n        }\\n        return true;\\n    }\\n    \\n    return recurse(stones.length - 1, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {boolean}\\n */\\nvar canCross = function(stones) {\\n    function recurse(i, k) {\\n        const last = stones[i];\\n        for (let j = i - 1; j >= 0; j--) {\\n            const dst = last - stones[j];\\n            if (dst > j + 1) return false;\\n            if (k) {\\n                if (dst > k + 1) return false;\\n                if (dst < k - 1) continue;\\n            }\\n            if (recurse(j, dst))\\n                return true;\\n        }\\n        return true;\\n    }\\n    \\n    return recurse(stones.length - 1, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3966623,
                "title": "c-dp-binary-search-easy-to-understand-intuition-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought that comes to mind is that we have to try out all the possible paths through which we can reach the last stone. And the easiest way to try out all the paths is through recursion. Now if we try to draw the recursion tree we will see that there are many repeatations, so we can try the memoize the results using DP. \\n\\nAnd as the array is sorted to know the next index where we can move, considering all the constraints, we can use binary search(upper_bound and lower_bound). I will elaborate on this in the approach section.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFrom any position we can go to (pos + (k - 1)), (pos + k) and (pos + (k + 1)) considering previous jump was of k steps. Now if we are a at an index we can go the a number of indices. we can use the concept of lower bound and upper bound in this (ub and lb explained below). If you don\\'t have idea about ub and lb, I would recommand you to give it a read because it comes handy in many situations.\\n\\n`ind1 = lower_bound(pos + (k - 1))` : this will give the first index that has value >= (pos + (k - 1)). Now it might cross (pos + (k + 1)) if no value in the permissable range is present. and in that case ind2 will also point to same index.\\n\\n`ind2 = upper_bound(pos + (k + 1))` : this will give the first index that has value > (pos + (k + 1)). So we can\\'t go upto this index. we have to stop before this.\\n\\nIf no value in the permissable range is present then both will point to the same index. So in that case no recursion call happens because we are running loop from (ind1 to ind2 - 1). otherwise recursion call for all possible permissable index will be made. \\n\\n`min_steps = max(1, prev_step - 1)` is taken becasue no backward movement is allowed and if min_steps == 0 then we will stay at the same index which makes no sense.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**$$O(3 * n)$$**\\nconsidering n is the size of the stones array.\\nBacause for every index we can take k - 1 , k and k + 1 step. so there are maximum 3 possibility for every index.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**$$O(n * n)$$**\\nas we are using a n * n dp array. \\nif we keep of taking prev_step + 1 step for every index then we might end up taking n step for the last index so so we have to take n * n array.\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool can(int ind, int prev_step, vector<int> &stones, vector<vector<int>> &dp) {\\n        if(ind == stones.size() - 1) return true;\\n\\n        if(dp[ind][prev_step] != -1) return dp[ind][prev_step];\\n\\n        int min_step = max(1, prev_step - 1);\\n        int max_step = prev_step + 1;\\n\\n        int ind1 = lower_bound(stones.begin(), stones.end(), stones[ind] + min_step) - stones.begin();\\n        int ind2 = upper_bound(stones.begin(), stones.end(), stones[ind] + max_step) - stones.begin();\\n\\n        bool res = false;\\n        for(int i = ind1; i < ind2; i++) {\\n            res = res || can(i, stones[i] - stones[ind], stones, dp);\\n        }\\n        return dp[ind][prev_step] = res;\\n    }\\n\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size(), vector<int> (stones.size(), -1));\\n        return can(0, 0, stones, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool can(int ind, int prev_step, vector<int> &stones, vector<vector<int>> &dp) {\\n        if(ind == stones.size() - 1) return true;\\n\\n        if(dp[ind][prev_step] != -1) return dp[ind][prev_step];\\n\\n        int min_step = max(1, prev_step - 1);\\n        int max_step = prev_step + 1;\\n\\n        int ind1 = lower_bound(stones.begin(), stones.end(), stones[ind] + min_step) - stones.begin();\\n        int ind2 = upper_bound(stones.begin(), stones.end(), stones[ind] + max_step) - stones.begin();\\n\\n        bool res = false;\\n        for(int i = ind1; i < ind2; i++) {\\n            res = res || can(i, stones[i] - stones[ind], stones, dp);\\n        }\\n        return dp[ind][prev_step] = res;\\n    }\\n\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size(), vector<int> (stones.size(), -1));\\n        return can(0, 0, stones, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965008,
                "title": "simple-java-memoization-no-confusion",
                "content": "# Intuition\\nSome how make recursion work to generate all possible outcomes, and introduce space to reduce time complexity\\n\\n# Approach\\n# **Recursion Approach**\\n- Consider frog starts at index 0\\n- So as the starting jump is of value 0\\n- We store (key,value) pairs in which key->stone position, value->index\\n- If our currIndx reaches n-1 than we are at the last stone we reached our destination we return true.\\n- Let\\'s see further, they mentioned that if i make a step of k value then we can make k-1, k , k+1 so we can simply make a recursion call for these 3 values. \\n- There is a small problem that is what If our currIndx+(one of three operations) is not in HashMap i.e.what if the current step we took is not a stone then the frog jumps into river right!, so to avoid this we check even before calling the recursion call getOrDefault.\\n- If currIndx==-1 then it is not a stone we return false\\n- Now our prev step taken will become one of the 3 values (prev-1,prev,prev+1)\\n- 2 care taking points are if prev-1 is not greater than 1 we start calling the same recursion call again and again so we should take care of that and other is if prev>0 only we can call for current becuase this may cause the same problem\\n\\n# **Memoization**\\nOnly 2 steps to be taken care of:\\ndp[n][m]\\n1. n = simply length of the stones array as we are considering index\\n2. m = consider you increment 1 for every index then what will be your maximum prev step can be taken that is simply 2*n.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean recursion(int currIndx,int[] stones,int n,HashMap<Integer,Integer>hmp,int prev,int[][] dp){\\n        if(currIndx==-1) return false;\\n        if(currIndx==n-1) return true;\\n        if(dp[currIndx][prev]!=-1) return dp[currIndx][prev]==1?true:false;\\n        boolean left=false,curr=false,right=false;\\n        if(prev>1)\\n            left = recursion(hmp.getOrDefault(stones[currIndx]+prev-1,-1),stones,n,hmp,prev-1,dp);\\n        if(prev>0)\\n         curr = recursion(hmp.getOrDefault(stones[currIndx]+prev,-1),stones,n,hmp,prev,dp);\\n        right = recursion(hmp.getOrDefault(stones[currIndx]+prev+1,-1),stones,n,hmp,prev+1,dp);  \\n        dp[currIndx][prev] = (left || curr || right)?1:0;\\n        return left || curr || right; \\n    }\\n    public boolean canCross(int[] stones) {\\n        HashMap<Integer,Integer>hmp = new HashMap<>();\\n        int n=stones.length;\\n        for(int i=0;i<n;i++){\\n            hmp.put(stones[i],i);\\n        }\\n        int[][] dp=new int[n][2*n];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return recursion(0,stones,n,hmp,0,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean recursion(int currIndx,int[] stones,int n,HashMap<Integer,Integer>hmp,int prev,int[][] dp){\\n        if(currIndx==-1) return false;\\n        if(currIndx==n-1) return true;\\n        if(dp[currIndx][prev]!=-1) return dp[currIndx][prev]==1?true:false;\\n        boolean left=false,curr=false,right=false;\\n        if(prev>1)\\n            left = recursion(hmp.getOrDefault(stones[currIndx]+prev-1,-1),stones,n,hmp,prev-1,dp);\\n        if(prev>0)\\n         curr = recursion(hmp.getOrDefault(stones[currIndx]+prev,-1),stones,n,hmp,prev,dp);\\n        right = recursion(hmp.getOrDefault(stones[currIndx]+prev+1,-1),stones,n,hmp,prev+1,dp);  \\n        dp[currIndx][prev] = (left || curr || right)?1:0;\\n        return left || curr || right; \\n    }\\n    public boolean canCross(int[] stones) {\\n        HashMap<Integer,Integer>hmp = new HashMap<>();\\n        int n=stones.length;\\n        for(int i=0;i<n;i++){\\n            hmp.put(stones[i],i);\\n        }\\n        int[][] dp=new int[n][2*n];\\n        for(int i=0;i<n;i++){\\n            Arrays.fill(dp[i],-1);\\n        }\\n        return recursion(0,stones,n,hmp,0,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964842,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n=len(stones)\\n        dp={stone:set() for stone in stones}\\n        dp[0].add(0)\\n        for i in range(n):\\n            for k in dp[stones[i]]:\\n                for step in range(k-1,k+2):\\n                    if step and stones[i]+step in dp:\\n                        dp[stones[i]+step].add(step)\\n\\n        return len(dp[stones[-1]])>0                                  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n=len(stones)\\n        dp={stone:set() for stone in stones}\\n        dp[0].add(0)\\n        for i in range(n):\\n            for k in dp[stones[i]]:\\n                for step in range(k-1,k+2):\\n                    if step and stones[i]+step in dp:\\n                        dp[stones[i]+step].add(step)\\n\\n        return len(dp[stones[-1]])>0                                  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722536,
                "title": "recursion-memoization-optimized-using-binary-search-c-python-java",
                "content": "# Intuition\\nAs stated you will always have `1` step and $$1st$$ stone is `0` with that you can reach $$2nd$$ stone BUT!!! the catch here is you can reach that stone only if the $$2nd$$ stone is 1, since clearly stated that \\n\\n```\\nnext_stone = curr_stone + past_jumps\\n```\\nSo let\\'s remove the possibility such that $$2nd$$ stone is greater than `1`, where you will never reach the last stone.\\n\\nAnd then try out all possible ways to to reach last stone using **Recursion**. \\n\\n# Approach-1 Recursion (OBVIOUS TLE)\\n\\nIn Recursion, We try out all possible ways at each state by checking whether with the `prev_jump` and `curr_stone` we are able to reach the `last_stone`.\\n\\nAt any state when we cross the stones without reaching `last_stone` situated at `n-1`, we consider it as **not reaching**.\\nSo our Base case is defined as below\\n\\n```\\nif(i >= n)\\n{\\n    return false;   // Not Reached\\n}\\nif(i == n-1)\\n{\\n    return true;    // Reached\\n}\\n```\\n\\nNow At any state, we try out simple recursion with `prev_jump-1`, `prev_jump`, `prev_jump+1` with `curr_stone`.\\n\\nAs stated the frog can jump to a stone with `curr_stone + prev_jump` value, we try to find a stone such that `new_stone = curr_stone + prev_jump` \\n\\nI\\'ve generalized those jumps using a *for loop*.\\n\\n```\\nfor(int& t: jumps)\\n{\\n    int jump = prev + t;\\n    for(int j=i+1; j<n; j++)\\n    {\\n        if(curr + jump == new_stone in nums)\\n        {\\n            // Check for the curr_stone + prev_jump\\n        }\\n    }\\n}\\n```\\n\\n# Code\\n\\n<iframe src=\"https://leetcode.com/playground/TDiAdUmw/shared\" frameBorder=\"0\" width=\"1100\" height=\"900\"></iframe>\\n\\n**Other Languages**\\n\\n```cpp []\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> jumps = {-1, 0, 1};\\n    bool solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i >= n)\\n        {\\n            return false;\\n        }\\n        if(i == n-1)\\n        {\\n            return true;\\n        }\\n        int curr = nums[i];\\n        bool isPossible = false;\\n        for(int& t: jumps)\\n        {\\n            int jump = prev + t;\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(curr + jump == nums[j])\\n                {\\n                    isPossible = solve(nums, j, jump);\\n                    if(isPossible)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return isPossible;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        n = stones.size();\\n        if(stones[1] > 1)\\n        {\\n            return false;\\n        }\\n        return solve(stones, 1, 1);\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.n = 0\\n        self.jumps = [-1, 0, 1]\\n    \\n    def solve(self, nums, i, prev):\\n        if i >= self.n:\\n            return False\\n        if i == self.n - 1:\\n            return True\\n        curr = nums[i]\\n        isPossible = False\\n        for t in self.jumps:\\n            jump = prev + t\\n            for j in range(i + 1, self.n):\\n                if curr + jump == nums[j]:\\n                    isPossible = self.solve(nums, j, jump)\\n                    if isPossible:\\n                        return True\\n        return isPossible\\n    \\n    def canCross(self, stones):\\n        self.n = len(stones)\\n        if stones[1] > 1:\\n            return False\\n        return self.solve(stones, 1, 1)\\n```\\n```java []\\nclass Solution {\\n    private int n;\\n    private List<Integer> jumps = Arrays.asList(-1, 0, 1);\\n    \\n    private boolean solve(List<Integer> nums, int i, int prev) {\\n        if (i >= n) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return true;\\n        }\\n        int curr = nums.get(i);\\n        boolean isPossible = false;\\n        for (int t : jumps) {\\n            int jump = prev + t;\\n            for (int j = i + 1; j < n; j++) {\\n                if (curr + jump == nums.get(j)) {\\n                    isPossible = solve(nums, j, jump);\\n                    if (isPossible) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return isPossible;\\n    }\\n    \\n    public boolean canCross(List<Integer> stones) {\\n        n = stones.size();\\n        if (stones.get(1) > 1) {\\n            return false;\\n        }\\n        return solve(stones, 1, 1);\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2^N)$$ \\n\\n- Space complexity: $$O(2^N)$$\\n\\n# Approach-2 Memoization (Gets Submitted!)\\n\\nAs Usual, In Memoization we try to reduce number of recursive calls by storing them.\\nHere only two values are changing at each state, so we define a `hashMap` to store the previous computations to use them whenever we encounter the previous state.\\nThis helps us to reduce the number of calls and Reduce the Time Complexity from $$O(2^N)$$ to $$O(N^2)$$\\n\\n# Code\\n\\n<iframe src=\"https://leetcode.com/playground/KbPoS6bA/shared\" frameBorder=\"0\" width=\"1100\" height=\"900\"></iframe>\\n\\n**Other Languages**\\n\\n```cpp []\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> jumps = {-1, 0, 1};\\n    unordered_map<string, int> hashMap;\\n    bool solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i >= n)\\n        {\\n            return false;\\n        }\\n        if(i == n-1)\\n        {\\n            return true;\\n        }\\n        string key = to_string(i) + \"_\" + to_string(prev);\\n        if(hashMap.count(key))\\n        {\\n            return hashMap[key];\\n        }\\n        int curr = nums[i];\\n        bool isPossible = false;\\n        for(int& t: jumps)\\n        {\\n            int jump = prev + t;\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(curr + jump == nums[j])\\n                {\\n                    isPossible = solve(nums, j, jump);\\n                    if(isPossible)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return hashMap[key] = isPossible;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] > 1)\\n        {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.n = 0\\n        self.jumps = [-1, 0, 1]\\n        self.hashMap = {}\\n    \\n    def solve(self, nums, i, prev):\\n        if i >= self.n:\\n            return False\\n        if i == self.n - 1:\\n            return True\\n        key = str(i) + \"_\" + str(prev)\\n        if key in self.hashMap:\\n            return self.hashMap[key]\\n        curr = nums[i]\\n        isPossible = False\\n        for t in self.jumps:\\n            jump = prev + t\\n            for j in range(i + 1, self.n):\\n                if curr + jump == nums[j]:\\n                    isPossible = self.solve(nums, j, jump)\\n                    if isPossible:\\n                        return True\\n        self.hashMap[key] = isPossible\\n        return isPossible\\n    \\n    def canCross(self, stones):\\n        if stones[1] > 1:\\n            return False\\n        self.n = len(stones)\\n        self.hashMap = {}\\n        return self.solve(stones, 1, 1)\\n```\\n```java []\\nclass Solution {\\n    private int n;\\n    private List<Integer> jumps = Arrays.asList(-1, 0, 1);\\n    private Map<String, Integer> hashMap = new HashMap<>();\\n\\n    private boolean solve(List<Integer> nums, int i, int prev) {\\n        if (i >= n) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return true;\\n        }\\n        String key = i + \"_\" + prev;\\n        if (hashMap.containsKey(key)) {\\n            return hashMap.get(key) == 1;\\n        }\\n        int curr = nums.get(i);\\n        boolean isPossible = false;\\n        for (int t : jumps) {\\n            int jump = prev + t;\\n            for (int j = i + 1; j < n; j++) {\\n                if (curr + jump == nums.get(j)) {\\n                    isPossible = solve(nums, j, jump);\\n                    if (isPossible) {\\n                        hashMap.put(key, 1);\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        hashMap.put(key, 0);\\n        return false;\\n    }\\n\\n    public boolean canCross(List<Integer> stones) {\\n        if (stones.get(1) > 1) {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$ \\n\\n- Space complexity: $$O(N^2)$$\\n\\n\\n# Approach-3 Memoization + Binary Search (Optimized)\\n\\nNow in the given question it is stated that list `stones` of are in ascending(***sorted***) order.\\n\\nIn recursive function we are linearly iterating and through each `stones` to find a `new_stone` which is equal to `curr_stone + prev_jump`.\\n\\nHere we are applying $$Linear Search$$ instead of that we can apply $$Binary Search$$ to find out the `new_stone` as the given list of `stones` are in sorted Order.\\n\\n# Code\\n<iframe src=\"https://leetcode.com/playground/7u5ma8TN/shared\" frameBorder=\"0\" width=\"1100\" height=\"1000\"></iframe>\\n\\n**Other Languages**\\n\\n```cpp []\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> jumps = {-1, 0, 1};\\n    unordered_map<string, int> hashMap;\\n    int binarySearch(vector<int>& nums, int l, int r, int key)\\n    {\\n        int mid;\\n        while(l <= r)\\n        {\\n            mid = l + (r-l)/2;\\n            if(key < nums[mid])\\n            {\\n                r = mid-1;\\n            }\\n            else if(key > nums[mid])\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    bool solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i >= n)\\n        {\\n            return false;\\n        }\\n        if(i == n-1)\\n        {\\n            return true;\\n        }\\n        string key = to_string(i) + \"_\" + to_string(prev);\\n        if(hashMap.count(key))\\n        {\\n            return hashMap[key];\\n        }\\n        int curr = nums[i];\\n        for(int& t: jumps)\\n        {\\n            int jump = prev + t;\\n            int j = binarySearch(nums, i+1, n-1, curr + jump);\\n            if(j == -1)\\n            {\\n                continue;\\n            }\\n            if(solve(nums, j, jump))\\n            {\\n                return true;\\n            }\\n        }\\n        return hashMap[key] = false;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] > 1)\\n        {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.n = 0\\n        self.jumps = [-1, 0, 1]\\n        self.hashMap = {}\\n    \\n    def binarySearch(self, nums, l, r, key):\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if key < nums[mid]:\\n                r = mid - 1\\n            elif key > nums[mid]:\\n                l = mid + 1\\n            else:\\n                return mid\\n        return -1\\n    \\n    def solve(self, nums, i, prev):\\n        if i >= self.n:\\n            return False\\n        if i == self.n - 1:\\n            return True\\n        key = str(i) + \"_\" + str(prev)\\n        if key in self.hashMap:\\n            return self.hashMap[key]\\n        curr = nums[i]\\n        for t in self.jumps:\\n            jump = prev + t\\n            j = self.binarySearch(nums, i + 1, self.n - 1, curr + jump)\\n            if j == -1:\\n                continue\\n            if self.solve(nums, j, jump):\\n                return True\\n        self.hashMap[key] = False\\n        return False\\n    \\n    def canCross(self, stones):\\n        if stones[1] > 1:\\n            return False\\n        self.n = len(stones)\\n        self.hashMap = {}\\n        return self.solve(stones, 1, 1)\\n```\\n```java []\\nclass Solution {\\n    private int n;\\n    private List<Integer> jumps = Arrays.asList(-1, 0, 1);\\n    private Map<String, Integer> hashMap = new HashMap<>();\\n    \\n    private int binarySearch(List<Integer> nums, int l, int r, int key) {\\n        int mid;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (key < nums.get(mid)) {\\n                r = mid - 1;\\n            } else if (key > nums.get(mid)) {\\n                l = mid + 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean solve(List<Integer> nums, int i, int prev) {\\n        if (i >= n) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return true;\\n        }\\n        String key = i + \"_\" + prev;\\n        if (hashMap.containsKey(key)) {\\n            return hashMap.get(key) == 1;\\n        }\\n        int curr = nums.get(i);\\n        for (int t : jumps) {\\n            int jump = prev + t;\\n            int j = binarySearch(nums, i + 1, n - 1, curr + jump);\\n            if (j == -1) {\\n                continue;\\n            }\\n            if (solve(nums, j, jump)) {\\n                hashMap.put(key, 1);\\n                return true;\\n            }\\n        }\\n        hashMap.put(key, 0);\\n        return false;\\n    }\\n    \\n    public boolean canCross(List<Integer> stones) {\\n        if (stones.get(1) > 1) {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(N*log(N))$$ \\n\\n- Space complexity: $$O(N^2)$$\\n\\n![naruto-thumbsup.gif](https://assets.leetcode.com/users/images/3627f73f-7682-49f4-b356-d80778b18d9d_1688562884.4619386.gif)\\n\\nHope you understood this Solution, Just in case you understod please Upvote and share this Awesome question with your fellow coders.\\n\\nWith this I\\'m Signing off.\\n\\n![minato.gif](https://assets.leetcode.com/users/images/3d54e746-995d-4485-9ccf-9d376636e81f_1688562951.6500254.gif)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nnext_stone = curr_stone + past_jumps\\n```\n```\\nif(i >= n)\\n{\\n    return false;   // Not Reached\\n}\\nif(i == n-1)\\n{\\n    return true;    // Reached\\n}\\n```\n```\\nfor(int& t: jumps)\\n{\\n    int jump = prev + t;\\n    for(int j=i+1; j<n; j++)\\n    {\\n        if(curr + jump == new_stone in nums)\\n        {\\n            // Check for the curr_stone + prev_jump\\n        }\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> jumps = {-1, 0, 1};\\n    bool solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i >= n)\\n        {\\n            return false;\\n        }\\n        if(i == n-1)\\n        {\\n            return true;\\n        }\\n        int curr = nums[i];\\n        bool isPossible = false;\\n        for(int& t: jumps)\\n        {\\n            int jump = prev + t;\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(curr + jump == nums[j])\\n                {\\n                    isPossible = solve(nums, j, jump);\\n                    if(isPossible)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return isPossible;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        n = stones.size();\\n        if(stones[1] > 1)\\n        {\\n            return false;\\n        }\\n        return solve(stones, 1, 1);\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.n = 0\\n        self.jumps = [-1, 0, 1]\\n    \\n    def solve(self, nums, i, prev):\\n        if i >= self.n:\\n            return False\\n        if i == self.n - 1:\\n            return True\\n        curr = nums[i]\\n        isPossible = False\\n        for t in self.jumps:\\n            jump = prev + t\\n            for j in range(i + 1, self.n):\\n                if curr + jump == nums[j]:\\n                    isPossible = self.solve(nums, j, jump)\\n                    if isPossible:\\n                        return True\\n        return isPossible\\n    \\n    def canCross(self, stones):\\n        self.n = len(stones)\\n        if stones[1] > 1:\\n            return False\\n        return self.solve(stones, 1, 1)\\n```\n```java []\\nclass Solution {\\n    private int n;\\n    private List<Integer> jumps = Arrays.asList(-1, 0, 1);\\n    \\n    private boolean solve(List<Integer> nums, int i, int prev) {\\n        if (i >= n) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return true;\\n        }\\n        int curr = nums.get(i);\\n        boolean isPossible = false;\\n        for (int t : jumps) {\\n            int jump = prev + t;\\n            for (int j = i + 1; j < n; j++) {\\n                if (curr + jump == nums.get(j)) {\\n                    isPossible = solve(nums, j, jump);\\n                    if (isPossible) {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return isPossible;\\n    }\\n    \\n    public boolean canCross(List<Integer> stones) {\\n        n = stones.size();\\n        if (stones.get(1) > 1) {\\n            return false;\\n        }\\n        return solve(stones, 1, 1);\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> jumps = {-1, 0, 1};\\n    unordered_map<string, int> hashMap;\\n    bool solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i >= n)\\n        {\\n            return false;\\n        }\\n        if(i == n-1)\\n        {\\n            return true;\\n        }\\n        string key = to_string(i) + \"_\" + to_string(prev);\\n        if(hashMap.count(key))\\n        {\\n            return hashMap[key];\\n        }\\n        int curr = nums[i];\\n        bool isPossible = false;\\n        for(int& t: jumps)\\n        {\\n            int jump = prev + t;\\n            for(int j=i+1; j<n; j++)\\n            {\\n                if(curr + jump == nums[j])\\n                {\\n                    isPossible = solve(nums, j, jump);\\n                    if(isPossible)\\n                    {\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        return hashMap[key] = isPossible;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] > 1)\\n        {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.n = 0\\n        self.jumps = [-1, 0, 1]\\n        self.hashMap = {}\\n    \\n    def solve(self, nums, i, prev):\\n        if i >= self.n:\\n            return False\\n        if i == self.n - 1:\\n            return True\\n        key = str(i) + \"_\" + str(prev)\\n        if key in self.hashMap:\\n            return self.hashMap[key]\\n        curr = nums[i]\\n        isPossible = False\\n        for t in self.jumps:\\n            jump = prev + t\\n            for j in range(i + 1, self.n):\\n                if curr + jump == nums[j]:\\n                    isPossible = self.solve(nums, j, jump)\\n                    if isPossible:\\n                        return True\\n        self.hashMap[key] = isPossible\\n        return isPossible\\n    \\n    def canCross(self, stones):\\n        if stones[1] > 1:\\n            return False\\n        self.n = len(stones)\\n        self.hashMap = {}\\n        return self.solve(stones, 1, 1)\\n```\n```java []\\nclass Solution {\\n    private int n;\\n    private List<Integer> jumps = Arrays.asList(-1, 0, 1);\\n    private Map<String, Integer> hashMap = new HashMap<>();\\n\\n    private boolean solve(List<Integer> nums, int i, int prev) {\\n        if (i >= n) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return true;\\n        }\\n        String key = i + \"_\" + prev;\\n        if (hashMap.containsKey(key)) {\\n            return hashMap.get(key) == 1;\\n        }\\n        int curr = nums.get(i);\\n        boolean isPossible = false;\\n        for (int t : jumps) {\\n            int jump = prev + t;\\n            for (int j = i + 1; j < n; j++) {\\n                if (curr + jump == nums.get(j)) {\\n                    isPossible = solve(nums, j, jump);\\n                    if (isPossible) {\\n                        hashMap.put(key, 1);\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        hashMap.put(key, 0);\\n        return false;\\n    }\\n\\n    public boolean canCross(List<Integer> stones) {\\n        if (stones.get(1) > 1) {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\nprivate:\\n    int n;\\n    vector<int> jumps = {-1, 0, 1};\\n    unordered_map<string, int> hashMap;\\n    int binarySearch(vector<int>& nums, int l, int r, int key)\\n    {\\n        int mid;\\n        while(l <= r)\\n        {\\n            mid = l + (r-l)/2;\\n            if(key < nums[mid])\\n            {\\n                r = mid-1;\\n            }\\n            else if(key > nums[mid])\\n            {\\n                l = mid+1;\\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    bool solve(vector<int>& nums, int i, int prev)\\n    {\\n        if(i >= n)\\n        {\\n            return false;\\n        }\\n        if(i == n-1)\\n        {\\n            return true;\\n        }\\n        string key = to_string(i) + \"_\" + to_string(prev);\\n        if(hashMap.count(key))\\n        {\\n            return hashMap[key];\\n        }\\n        int curr = nums[i];\\n        for(int& t: jumps)\\n        {\\n            int jump = prev + t;\\n            int j = binarySearch(nums, i+1, n-1, curr + jump);\\n            if(j == -1)\\n            {\\n                continue;\\n            }\\n            if(solve(nums, j, jump))\\n            {\\n                return true;\\n            }\\n        }\\n        return hashMap[key] = false;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] > 1)\\n        {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def __init__(self):\\n        self.n = 0\\n        self.jumps = [-1, 0, 1]\\n        self.hashMap = {}\\n    \\n    def binarySearch(self, nums, l, r, key):\\n        while l <= r:\\n            mid = l + (r - l) // 2\\n            if key < nums[mid]:\\n                r = mid - 1\\n            elif key > nums[mid]:\\n                l = mid + 1\\n            else:\\n                return mid\\n        return -1\\n    \\n    def solve(self, nums, i, prev):\\n        if i >= self.n:\\n            return False\\n        if i == self.n - 1:\\n            return True\\n        key = str(i) + \"_\" + str(prev)\\n        if key in self.hashMap:\\n            return self.hashMap[key]\\n        curr = nums[i]\\n        for t in self.jumps:\\n            jump = prev + t\\n            j = self.binarySearch(nums, i + 1, self.n - 1, curr + jump)\\n            if j == -1:\\n                continue\\n            if self.solve(nums, j, jump):\\n                return True\\n        self.hashMap[key] = False\\n        return False\\n    \\n    def canCross(self, stones):\\n        if stones[1] > 1:\\n            return False\\n        self.n = len(stones)\\n        self.hashMap = {}\\n        return self.solve(stones, 1, 1)\\n```\n```java []\\nclass Solution {\\n    private int n;\\n    private List<Integer> jumps = Arrays.asList(-1, 0, 1);\\n    private Map<String, Integer> hashMap = new HashMap<>();\\n    \\n    private int binarySearch(List<Integer> nums, int l, int r, int key) {\\n        int mid;\\n        while (l <= r) {\\n            mid = l + (r - l) / 2;\\n            if (key < nums.get(mid)) {\\n                r = mid - 1;\\n            } else if (key > nums.get(mid)) {\\n                l = mid + 1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean solve(List<Integer> nums, int i, int prev) {\\n        if (i >= n) {\\n            return false;\\n        }\\n        if (i == n - 1) {\\n            return true;\\n        }\\n        String key = i + \"_\" + prev;\\n        if (hashMap.containsKey(key)) {\\n            return hashMap.get(key) == 1;\\n        }\\n        int curr = nums.get(i);\\n        for (int t : jumps) {\\n            int jump = prev + t;\\n            int j = binarySearch(nums, i + 1, n - 1, curr + jump);\\n            if (j == -1) {\\n                continue;\\n            }\\n            if (solve(nums, j, jump)) {\\n                hashMap.put(key, 1);\\n                return true;\\n            }\\n        }\\n        hashMap.put(key, 0);\\n        return false;\\n    }\\n    \\n    public boolean canCross(List<Integer> stones) {\\n        if (stones.get(1) > 1) {\\n            return false;\\n        }\\n        n = stones.size();\\n        hashMap.clear();\\n        return solve(stones, 1, 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584392,
                "title": "easy-to-understand-python-code-using-recursion",
                "content": "**Points to remember:**\\n1. 0th index is always equal to zero.\\n2. 1st index must be one, because we are only allowed to make a jump of length 1 when we are at the 0th index.\\n3. If the above point satisfies we move on to find if we can reach the stone on the end index.\\n\\n**Code Explanation:**\\n1. Recursion starts when we are standing at the 1st index and k=1 and we have 3 options [k-1,k,k+1] to make a jump.\\n2. `if i+j>i and helper(i+j,j):` Here we are ensuring the by making a jump we are only moving in the forward direction.\\n3. By making a jump of size (i+j) where j is (k-1) or k or (k+1) we must make sure that we land on a stone and not in water. So, We stored all the stones and its indeces in a dictionary to check if its a stone or not while landing.\\n4. If its not a stone we return False and go back. If it is a stone we continue.\\n5. Once we reach the final stone by any means thats it, we are done and we return True.  \\n```\\n    def canCross(self, stones: List[int]) -> bool:\\n        n = stones[-1]\\n        hm = {}\\n        for i in range(len(stones)):\\n            hm[stones[i]] = i\\n        dp = {}\\n        def helper(i,k):\\n            if i not in hm:\\n                return False\\n            if i==n:\\n                return True\\n            if (i,k) in dp:\\n                return dp[(i,k)]\\n            for j in [k-1,k,k+1]:\\n                if i+j>i and helper(i+j,j):\\n                    dp[(i,k)] = True\\n                    return True\\n            dp[(i,k)] = False\\n            return False\\n        if stones[1]==1:\\n            return helper(1,1)\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def canCross(self, stones: List[int]) -> bool:\\n        n = stones[-1]\\n        hm = {}\\n        for i in range(len(stones)):\\n            hm[stones[i]] = i\\n        dp = {}\\n        def helper(i,k):\\n            if i not in hm:\\n                return False\\n            if i==n:\\n                return True\\n            if (i,k) in dp:\\n                return dp[(i,k)]\\n            for j in [k-1,k,k+1]:\\n                if i+j>i and helper(i+j,j):\\n                    dp[(i,k)] = True\\n                    return True\\n            dp[(i,k)] = False\\n            return False\\n        if stones[1]==1:\\n            return helper(1,1)\\n        else:\\n            return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2192998,
                "title": "python3-top-bottom-dp-with-binary-search-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nWe use a recursive helper function that answers the question: _Can a frog cross the river starting from the particular stone `stone` and having `k` units\\'?_ For every call, we iterate over the available space of actions, and for every reachable stone, call the helper again. To find reachable stones, we use binary search `bisect_left` since the given array is sorted. To cache the overlapping calls, we use memoization `@cache`.\\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        L = len(stones)\\n        \\n        if stones[1] != 1: return False\\n        \\n        @cache\\n        def canCross(stone, k):\\n            if stone == stones[-1]:\\n                return True\\n\\n            jumps = [k, k+1]\\n            if k > 1: jumps.append(k-1)\\n            \\n            for jump in jumps:\\n                nextStone = stone + jump\\n                found = bisect_left(stones, nextStone)\\n                if found < L and stones[found] == nextStone and canCross(nextStone, jump):\\n                    return True\\n                \\n            return False\\n        \\n        return canCross(1, 1)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        L = len(stones)\\n        \\n        if stones[1] != 1: return False\\n        \\n        @cache\\n        def canCross(stone, k):\\n            if stone == stones[-1]:\\n                return True\\n\\n            jumps = [k, k+1]\\n            if k > 1: jumps.append(k-1)\\n            \\n            for jump in jumps:\\n                nextStone = stone + jump\\n                found = bisect_left(stones, nextStone)\\n                if found < L and stones[found] == nextStone and canCross(nextStone, jump):\\n                    return True\\n                \\n            return False\\n        \\n        return canCross(1, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397918,
                "title": "java-simple-solution-beats-92",
                "content": "// stone position -> k values that cannot jump from this position\\n    private HashMap<Integer, HashSet<Integer>> checked = new HashMap<>();\\n\\n    public boolean canCross(int[] stones) {\\n        for (int i = 0; i < stones.length; i++) checked.put(stones[i], new HashSet<>());\\n        return jump(0, 1, stones[stones.length - 1]);\\n    }\\n\\n    private boolean jump(int current, int k, int last) {\\n        if (current == last) return true;\\n\\t\\t// skip if we have checked this k at the current stone\\n        if (k <= 0 || checked.get(current).contains(k)) return false;\\n        int next = current + k;\\n        if (checked.containsKey(next)) {\\n            if (jump(next, k + 1, last) || jump(next, k, last) || jump(next, k - 1, last)) return true;\\n        }\\n        checked.get(current).add(k);\\n        return false;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "// stone position -> k values that cannot jump from this position\\n    private HashMap<Integer, HashSet<Integer>> checked = new HashMap<>();\\n\\n    public boolean canCross(int[] stones) {\\n        for (int i = 0; i < stones.length; i++) checked.put(stones[i], new HashSet<>());\\n        return jump(0, 1, stones[stones.length - 1]);\\n    }\\n\\n    private boolean jump(int current, int k, int last) {\\n        if (current == last) return true;\\n\\t\\t// skip if we have checked this k at the current stone\\n        if (k <= 0 || checked.get(current).contains(k)) return false;\\n        int next = current + k;\\n        if (checked.containsKey(next)) {\\n            if (jump(next, k + 1, last) || jump(next, k, last) || jump(next, k - 1, last)) return true;\\n        }\\n        checked.get(current).add(k);\\n        return false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 88809,
                "title": "60ms-java-o-n-2-use-a-matrix-for-memorization",
                "content": "memo[i][j] = 1 means that the frog can reach the final destination from i-th stone, with j being the previous step size. Because the maximum previous step size for the 0th, 1th, 2th stone is 0, 1, 2, ... , which means the maximum j is equal to i. So we can declare the matrix size as n*n where n is the number of stones.\\n\\nIf ignoring the recursive call overhead, this algorithm should have a time complexity of O(n^2) because we are just filling half of this matrix memo.\\n\\n```\\npublic class Solution {\\n    public boolean canCross(int[] stones) {\\n        if(stones[1] != 1) return false;\\n        int n = stones.length;\\n        int[][] memo = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++)\\n            {\\n                memo[i][j] = -1;\\n            }\\n        }\\n        \\n        return canCross(stones, 0, 0, memo, n);\\n    }\\n    private boolean canCross(int[] stones, int i, int j, int[][] memo, int n) {\\n        if(memo[i][j]!=-1) return memo[i][j] == 1;\\n        if(i == n - 1) {\\n            memo[i][j] = 1;\\n            return true;\\n        }\\n\\n        for(int k = i + 1; k < n; k++) { \\n            if(stones[k] < j - 1 + stones[i]) continue;\\n            else if(stones[k] > j + 1 + stones[i]) {\\n                memo[i][j] = 0;\\n                return false;\\n            }\\n            else {\\n                if(canCross(stones, k, stones[k] - stones[i], memo, n)) {\\n                    memo[i][j] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        memo[i][j] = 0;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean canCross(int[] stones) {\\n        if(stones[1] != 1) return false;\\n        int n = stones.length;\\n        int[][] memo = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++)\\n            {\\n                memo[i][j] = -1;\\n            }\\n        }\\n        \\n        return canCross(stones, 0, 0, memo, n);\\n    }\\n    private boolean canCross(int[] stones, int i, int j, int[][] memo, int n) {\\n        if(memo[i][j]!=-1) return memo[i][j] == 1;\\n        if(i == n - 1) {\\n            memo[i][j] = 1;\\n            return true;\\n        }\\n\\n        for(int k = i + 1; k < n; k++) { \\n            if(stones[k] < j - 1 + stones[i]) continue;\\n            else if(stones[k] > j + 1 + stones[i]) {\\n                memo[i][j] = 0;\\n                return false;\\n            }\\n            else {\\n                if(canCross(stones, k, stones[k] - stones[i], memo, n)) {\\n                    memo[i][j] = 1;\\n                    return true;\\n                }\\n            }\\n        }\\n        memo[i][j] = 0;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964790,
                "title": "c-python-2d-dp-binary-search-vs-hash-table-beats-98-48",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse recursion with meomory to solve. That is DP. Since stones is in ascending order, one approach is using binary search to find the next stone for frog jump. 2nd approach a hash table is established without BS.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[Please turn English subtitles if neccessary]\\n[https://youtu.be/IkUmZHbsyl0?si=pAF9VqtXj8ordm2t](https://youtu.be/IkUmZHbsyl0?si=pAF9VqtXj8ordm2t)\\nThe code uses DP approach to solve the frog river crossing problem. \\n\\nThe 2D dp[i][k] matrix is indexed by (index for stone, jump units).\\nIt maintains a 2D dp matrix to store results. The recursive function f explores possible jump units and uses binary search to find the next stone the frog can jump to. Consider dp[next][jump] where stones[next]=stones[i]+jump & jump=k-1, k, k+1.\\n\\nThe results of subproblems are memoized in the dp matrix to avoid redundant calculations. \\n![frogJimp.png](https://assets.leetcode.com/users/images/c2b8edf1-82d2-4582-82f8-860f417a8947_1693113731.635507.png)\\n\\n2 approaches have the similar speed behaviors, although the code using hash table has smaller time complexity!\\n\\n# Code using binary search Runtime 36 ms Beats 98.48%\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp; //2D dp matrix (index for stone, jump units)\\n    bool f(vector<int>& stones, int i, int k){\\n        if (i==n-1) return 1;\\n        if (dp[i][k]!=-1) return dp[i][k];\\n        bool ans=0;\\n        for(int jump: {k-1, k, k+1}){//possible jump units: k-1, k, k+1\\n            if (jump==0) continue;\\n            //Use binary search, since stones[i] is ascending\\n            int next=lower_bound(stones.begin()+(i+1), stones.end(), stones[i]+jump)\\n                -stones.begin();\\n            if (next==n || stones[next]!=stones[i]+jump) continue; // not found\\n            ans=ans||f(stones, next, jump);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        n=stones.size();\\n        dp.assign(n+1, vector<int>(n+1, -1));\\n        return f(stones, 0, 0); \\n    }\\n};\\n```\\n# Code using Hash table without binary Search 49ms Beats 94.53%\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp; //2D dp matrix (index for stone, jump units)\\n    unordered_map<int, int> stone2i; // Save Binary search\\n    bool f(vector<int>& stones, int i, int k){\\n        if (i==n-1) return 1;\\n        if (dp[i][k]!=-1) return dp[i][k];\\n        bool ans=0;\\n        for(int jump: {k-1, k, k+1}){//possible jump units: k-1, k, k+1\\n            if (jump==0) continue;\\n            //See whether stones[i]+jump in the hashTable stone2i\\n            if (stone2i.count(stones[i]+jump)==0) continue; // not found\\n            int next=stone2i[stones[i]+jump];\\n            ans=ans||f(stones, next, jump);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        n=stones.size();\\n        dp.assign(n+1, vector<int>(n+1, -1));\\n        for(int i=0; i<n; i++)\\n            stone2i[stones[i]]=i;\\n        return f(stones, 0, 0); \\n    }\\n};\\n\\n```\\n# Python solution using 1st approach\\n\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n=len(stones)\\n\\n        @cache\\n        def f(i, k):\\n            if i==n-1: return True\\n            ans=False\\n            for jump in [k-1, k, k+1]:\\n                if jump==0: continue\\n                next= bisect_left(stones[i+1:], stones[i]+jump)+(i+1)\\n                if next==n or stones[next]!=stones[i]+jump: continue\\n                ans = ans or f(next, jump)\\n            return ans\\n        \\n        return f(0, 0)\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp; //2D dp matrix (index for stone, jump units)\\n    bool f(vector<int>& stones, int i, int k){\\n        if (i==n-1) return 1;\\n        if (dp[i][k]!=-1) return dp[i][k];\\n        bool ans=0;\\n        for(int jump: {k-1, k, k+1}){//possible jump units: k-1, k, k+1\\n            if (jump==0) continue;\\n            //Use binary search, since stones[i] is ascending\\n            int next=lower_bound(stones.begin()+(i+1), stones.end(), stones[i]+jump)\\n                -stones.begin();\\n            if (next==n || stones[next]!=stones[i]+jump) continue; // not found\\n            ans=ans||f(stones, next, jump);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        n=stones.size();\\n        dp.assign(n+1, vector<int>(n+1, -1));\\n        return f(stones, 0, 0); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp; //2D dp matrix (index for stone, jump units)\\n    unordered_map<int, int> stone2i; // Save Binary search\\n    bool f(vector<int>& stones, int i, int k){\\n        if (i==n-1) return 1;\\n        if (dp[i][k]!=-1) return dp[i][k];\\n        bool ans=0;\\n        for(int jump: {k-1, k, k+1}){//possible jump units: k-1, k, k+1\\n            if (jump==0) continue;\\n            //See whether stones[i]+jump in the hashTable stone2i\\n            if (stone2i.count(stones[i]+jump)==0) continue; // not found\\n            int next=stone2i[stones[i]+jump];\\n            ans=ans||f(stones, next, jump);\\n        }\\n        return dp[i][k]=ans;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        n=stones.size();\\n        dp.assign(n+1, vector<int>(n+1, -1));\\n        for(int i=0; i<n; i++)\\n            stone2i[stones[i]]=i;\\n        return f(stones, 0, 0); \\n    }\\n};\\n\\n```\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n=len(stones)\\n\\n        @cache\\n        def f(i, k):\\n            if i==n-1: return True\\n            ans=False\\n            for jump in [k-1, k, k+1]:\\n                if jump==0: continue\\n                next= bisect_left(stones[i+1:], stones[i]+jump)+(i+1)\\n                if next==n or stones[next]!=stones[i]+jump: continue\\n                ans = ans or f(next, jump)\\n            return ans\\n        \\n        return f(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964782,
                "title": "c-2-simple-approach-hashmap-dp",
                "content": "![image](https://assets.leetcode.com/users/images/8a1d6298-dc30-4fe1-8162-3b627ba910c7_1693098059.9976435.webp)\\nMethod 1\\nTime Complexity-  O(n^2)\\nSpace Complexity- O(n^2)\\n```\\nclass Solution {\\npublic:\\n   bool canCross(vector<int>& stones) {\\n        unordered_map<int, unordered_set<int>> mp;  //  form a map in which we store the index and in set to store the possible jump sizes that can be used to reach a particular stone\\n        mp[stones[0]] = {0};  // starting index \\n// iterate\\n        for (int i = 0; i < stones.size(); ++i) {\\n            int position = stones[i];\\n\\n            for (auto it : mp[position]) { //for each jump\\n                for (int jump = it - 1; jump <= it + 1; ++jump) {  // there are 3 possiblity \\n\\t\\t\\t\\t//1 )it-1   \\n\\t\\t\\t\\t//2) it \\n\\t\\t\\t\\t//3) it+1\\n                    if (jump > 0) {  // if possible or reachable\\n                        mp[stones[i] +  jump].insert(jump); // add in map   \\n                    }\\n                }\\n            }\\n        }\\n        return !mp[stones.back()].empty();  // if mp should not empty it means we should reach at the last index from some of the index.\\n//\\t\\tfor example- [0, 1, 3, 5, 6, 8, 12, 17]\\n//\\t\\tmp[0] = {0};  \\n//\\t\\tmp[1] = {1};  \\n//\\t\\tmp[3] = {1, 2}; \\n//\\t\\tmp[5] = {1};   \\n//\\t\\tmp[6] = {1, 2}; \\n//\\t\\tmp[8] = {1, 2}; \\n//\\t\\tmp[12] = {1, 2};\\n//\\t\\tmp[17] = {1};  // not empty mean we should reach the last index \\n    }\\n};\\n```\\n\\nMethod 2 \\nTime Complexity-  O(n^2)\\nSpace Complexity- O(n^2)\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_set<int> stoneSet(stones.begin(), stones.end());\\n\\n        vector<vector<bool>> dp(n, vector<bool>(n + 1, false)); // create dp array\\n        \\n\\n        dp[0][0] = true;// base case: when frog  start from first stone or we change say if stones.size==1 then it mean start and end index is same\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                int jump = stones[i] - stones[j];\\n    \\n                if (jump <= j + 1) { // check the jump is possible \\n                    dp[i][jump] = dp[j][jump - 1] || dp[j][jump] || dp[j][jump + 1]; \\n                    // 3 possiblilty 1) jump - 1 2) jump   3) jump + 1\\n                    if (i == n - 1 && dp[i][jump]) {  //reach last index \\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canCross(vector<int>& stones) {\\n        unordered_map<int, unordered_set<int>> mp;  //  form a map in which we store the index and in set to store the possible jump sizes that can be used to reach a particular stone\\n        mp[stones[0]] = {0};  // starting index \\n// iterate\\n        for (int i = 0; i < stones.size(); ++i) {\\n            int position = stones[i];\\n\\n            for (auto it : mp[position]) { //for each jump\\n                for (int jump = it - 1; jump <= it + 1; ++jump) {  // there are 3 possiblity \\n\\t\\t\\t\\t//1 )it-1   \\n\\t\\t\\t\\t//2) it \\n\\t\\t\\t\\t//3) it+1\\n                    if (jump > 0) {  // if possible or reachable\\n                        mp[stones[i] +  jump].insert(jump); // add in map   \\n                    }\\n                }\\n            }\\n        }\\n        return !mp[stones.back()].empty();  // if mp should not empty it means we should reach at the last index from some of the index.\\n//\\t\\tfor example- [0, 1, 3, 5, 6, 8, 12, 17]\\n//\\t\\tmp[0] = {0};  \\n//\\t\\tmp[1] = {1};  \\n//\\t\\tmp[3] = {1, 2}; \\n//\\t\\tmp[5] = {1};   \\n//\\t\\tmp[6] = {1, 2}; \\n//\\t\\tmp[8] = {1, 2}; \\n//\\t\\tmp[12] = {1, 2};\\n//\\t\\tmp[17] = {1};  // not empty mean we should reach the last index \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_set<int> stoneSet(stones.begin(), stones.end());\\n\\n        vector<vector<bool>> dp(n, vector<bool>(n + 1, false)); // create dp array\\n        \\n\\n        dp[0][0] = true;// base case: when frog  start from first stone or we change say if stones.size==1 then it mean start and end index is same\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int j = i - 1; j >= 0; --j) {\\n                int jump = stones[i] - stones[j];\\n    \\n                if (jump <= j + 1) { // check the jump is possible \\n                    dp[i][jump] = dp[j][jump - 1] || dp[j][jump] || dp[j][jump + 1]; \\n                    // 3 possiblilty 1) jump - 1 2) jump   3) jump + 1\\n                    if (i == n - 1 && dp[i][jump]) {  //reach last index \\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044995,
                "title": "c-90-fast-clean-and-easy-solution-recursive-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool solve(map<int, int> &mp, vector<int>& stones, int last, int k, vector<vector<int>> &dp){\\n        int num = stones[last] + k;\\n        if(num == stones.back()) return true;\\n        if(mp.find(num) == mp.end()) return false;\\n\\n        if(dp[last][k] != -1) return dp[last][k];\\n\\n        int idx = mp[num];\\n        bool ans;\\n\\n        ans = solve(mp, stones, idx, k+1, dp);\\n        ans = ans || solve(mp, stones, idx, k, dp);\\n        if(k > 1){\\n            ans = ans || solve(mp, stones, idx, k-1, dp);\\n        }\\n\\n        return dp[last][k] = ans;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        map<int, int> mp;\\n        for(int i=0; i<stones.size(); i++){\\n            mp[stones[i]] = i;\\n        }\\n\\n        vector<vector<int>> dp(stones.size(), vector<int>(stones.size(), -1));\\n        return solve(mp, stones, 0, 1, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(map<int, int> &mp, vector<int>& stones, int last, int k, vector<vector<int>> &dp){\\n        int num = stones[last] + k;\\n        if(num == stones.back()) return true;\\n        if(mp.find(num) == mp.end()) return false;\\n\\n        if(dp[last][k] != -1) return dp[last][k];\\n\\n        int idx = mp[num];\\n        bool ans;\\n\\n        ans = solve(mp, stones, idx, k+1, dp);\\n        ans = ans || solve(mp, stones, idx, k, dp);\\n        if(k > 1){\\n            ans = ans || solve(mp, stones, idx, k-1, dp);\\n        }\\n\\n        return dp[last][k] = ans;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        map<int, int> mp;\\n        for(int i=0; i<stones.size(); i++){\\n            mp[stones[i]] = i;\\n        }\\n\\n        vector<vector<int>> dp(stones.size(), vector<int>(stones.size(), -1));\\n        return solve(mp, stones, 0, 1, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933347,
                "title": "easy-to-understand-c-recursion-with-memoization-faster-than-90",
                "content": "First let us think normal recursion then we will go for memoization.\\nSo suppose we reached at ith stone by jumping **next** number of units. Now we can take **next-1** or **next** or **next+1** jumps to reach to any of the next stones until we reach last stone.\\nSo we need to check if we can reach to a next stone by taking one of above three jumps(i.e. next, next-1, next+1). For this we have to search for that number stone(prev stone + number of jumps) in rest of the array. To reduce multiple searches we will use map to store indices of each element of stones array.\\nBelow is code for the same:\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        unordered_map<int,int>mp;\\n\\t\\t// store indicies of stones in map\\n        for(int i=0;i<n;i++)\\n            mp[stones[i]]=i;\\n\\t\\t// we are at 0th stone and we must take 1 jump to move forward (question requirement)\\n        return solve(0,1,stones,mp);\\n    }\\n    bool solve(int i, int next, vector<int>&stones, unordered_map<int,int>&mp){\\n\\t\\t// Parameter understanding: **i** means we reached at ith stone and want to take **next** number of jumps\\n\\t\\t// if we reached at last stone return true\\n        if(i==stones.size()-1)\\n            return true;\\n        // check if we can go to any next stone by taking **next** number of jumps?\\n        int nex = stones[i]+next;\\n\\t\\t// here mp[nex]==i is a necessary condition in case when **next** is 0 and if we do not include this condition then we will stuck in infinite loop by going to same stone every time\\n        if(!mp.count(nex) || mp[nex]==i)\\n            return false;\\n\\t\\t// now we can reach to next stone which is mp[nex]th stone and we have three ways to jump, check for each of these by recursively calling **solve** functionn and if we can reach to last stone by any of these, we return true;\\n        return solve(mp[nex],next-1,stones,mp) || solve(mp[nex],next,stones,mp) || solve(mp[nex],next+1,stones,mp);\\n    }\\n};\\n```\\n\\nTime compexity: For each stone we are checking three possibilities, so worst case TC can be 3^n which is very high.\\nLet us try to use memoization in this approach.\\nSo what are the states we are changing in every function call? They are **i** and **next**. If we get to know if we can reach to final stone when we are **ith** stone and want to take **next** number of jumps then we can avoid repetitive recursive calls. So we make a 2d array for **i** and **next** state. Now what are the possible **next** jumps. Suppose we have n stones, and we start by taking one jump for 2nd stone, now we can take 0,1,or 2 jump so max we can take is 2 for 3rd stone, then 3 for 4th jump and soon. So max we can take is **n-1** jump for **nth** stone.\\nSo size of 2d array will be n*n.\\nBelow is code for your refrence:\\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>memo;\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        unordered_map<int,int>mp;\\n        memo = vector<vector<int>>(n,vector<int>(n,-1));\\n        for(int i=0;i<n;i++)\\n            mp[stones[i]]=i;\\n        return solve(0,1,stones,mp);\\n    }\\n    bool solve(int i, int next, vector<int>&stones, unordered_map<int,int>&mp){\\n        if(i==stones.size()-1)\\n            return true;\\n        // check if we can go to any next stone by taking next steps?\\n        int nex = stones[i]+next;\\n\\t\\t// check if we have already gone from **ith** stone by taking **next** number of jumps\\n        if(memo[i][next]!=-1)\\n            return memo[i][next];\\n        if(!mp.count(nex) || mp[nex]==i)\\n            return false;\\n\\t\\t// update memo[i][next] also\\n        return memo[i][next] = solve(mp[nex],next-1,stones,mp) || solve(mp[nex],next,stones,mp) || solve(mp[nex],next+1,stones,mp);\\n    }\\n};\\n```\\n\\nPlease upvote if you like it.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        unordered_map<int,int>mp;\\n\\t\\t// store indicies of stones in map\\n        for(int i=0;i<n;i++)\\n            mp[stones[i]]=i;\\n\\t\\t// we are at 0th stone and we must take 1 jump to move forward (question requirement)\\n        return solve(0,1,stones,mp);\\n    }\\n    bool solve(int i, int next, vector<int>&stones, unordered_map<int,int>&mp){\\n\\t\\t// Parameter understanding: **i** means we reached at ith stone and want to take **next** number of jumps\\n\\t\\t// if we reached at last stone return true\\n        if(i==stones.size()-1)\\n            return true;\\n        // check if we can go to any next stone by taking **next** number of jumps?\\n        int nex = stones[i]+next;\\n\\t\\t// here mp[nex]==i is a necessary condition in case when **next** is 0 and if we do not include this condition then we will stuck in infinite loop by going to same stone every time\\n        if(!mp.count(nex) || mp[nex]==i)\\n            return false;\\n\\t\\t// now we can reach to next stone which is mp[nex]th stone and we have three ways to jump, check for each of these by recursively calling **solve** functionn and if we can reach to last stone by any of these, we return true;\\n        return solve(mp[nex],next-1,stones,mp) || solve(mp[nex],next,stones,mp) || solve(mp[nex],next+1,stones,mp);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    vector<vector<int>>memo;\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        unordered_map<int,int>mp;\\n        memo = vector<vector<int>>(n,vector<int>(n,-1));\\n        for(int i=0;i<n;i++)\\n            mp[stones[i]]=i;\\n        return solve(0,1,stones,mp);\\n    }\\n    bool solve(int i, int next, vector<int>&stones, unordered_map<int,int>&mp){\\n        if(i==stones.size()-1)\\n            return true;\\n        // check if we can go to any next stone by taking next steps?\\n        int nex = stones[i]+next;\\n\\t\\t// check if we have already gone from **ith** stone by taking **next** number of jumps\\n        if(memo[i][next]!=-1)\\n            return memo[i][next];\\n        if(!mp.count(nex) || mp[nex]==i)\\n            return false;\\n\\t\\t// update memo[i][next] also\\n        return memo[i][next] = solve(mp[nex],next-1,stones,mp) || solve(mp[nex],next,stones,mp) || solve(mp[nex],next+1,stones,mp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914678,
                "title": "clean-c-dp-recursion-with-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick not-pick approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasic recurrence.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) + auxiliary stack space for recursion;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    bool canCross(vector<int>& st) {\\n        int n = st.size();\\n        vector<vector<int>> dp(n,vector<int> (2*n,-1));\\n        for(int i = 1 ; i < n ; i++){\\n            mp[st[i]] = i ;\\n        }\\n        if(st[1] - st[0] > 1){\\n            return false;\\n        }\\n        return f(1,1,st,dp);\\n    }\\n    bool f(int i , int k, vector<int>& st,vector<vector<int>>&dp){\\n        if(i == st.size() - 1){\\n            return true;\\n        }\\n        bool bk = false;\\n        bool atk = false;\\n        bool ak = false;\\n        if(dp[i][k] !=-1){\\n            return dp[i][k];\\n        }\\n        <!-- For k - 1 -->\\n        if(mp[st[i] + k-1] > i){\\n            bk = f(mp[st[i] + k-1],k-1,st,dp);\\n        }\\n        <!-- For k -->\\n        if(mp[st[i] + k] > i){\\n            atk = f(mp[st[i] + k],k,st,dp);\\n        }\\n        <!-- For k + 1 -->\\n        if(mp[st[i] + k+1] > i){\\n            ak = f(mp[st[i] + k+1],k+1,st,dp);\\n        }\\n        return dp[i][k] = (bk || atk || ak);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    bool canCross(vector<int>& st) {\\n        int n = st.size();\\n        vector<vector<int>> dp(n,vector<int> (2*n,-1));\\n        for(int i = 1 ; i < n ; i++){\\n            mp[st[i]] = i ;\\n        }\\n        if(st[1] - st[0] > 1){\\n            return false;\\n        }\\n        return f(1,1,st,dp);\\n    }\\n    bool f(int i , int k, vector<int>& st,vector<vector<int>>&dp){\\n        if(i == st.size() - 1){\\n            return true;\\n        }\\n        bool bk = false;\\n        bool atk = false;\\n        bool ak = false;\\n        if(dp[i][k] !=-1){\\n            return dp[i][k];\\n        }\\n        <!-- For k - 1 -->\\n        if(mp[st[i] + k-1] > i){\\n            bk = f(mp[st[i] + k-1],k-1,st,dp);\\n        }\\n        <!-- For k -->\\n        if(mp[st[i] + k] > i){\\n            atk = f(mp[st[i] + k],k,st,dp);\\n        }\\n        <!-- For k + 1 -->\\n        if(mp[st[i] + k+1] > i){\\n            ak = f(mp[st[i] + k+1],k+1,st,dp);\\n        }\\n        return dp[i][k] = (bk || atk || ak);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357858,
                "title": "c-easy-approach-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        vector<vector<bool>> dp(n,vector<bool>(n+1,false));\\n        dp[0][0] = true;\\n    \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                int k=stones[i] -stones[j];\\n                if(k > j+1) break;\\n                dp[i][k] = dp[j][k-1] or dp[j][k] or dp[j][k+1];\\n                if(i==n-1 and dp[i][k]) return true;\\n            }\\n        }\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        vector<vector<bool>> dp(n,vector<bool>(n+1,false));\\n        dp[0][0] = true;\\n    \\n        for(int i=1;i<n;i++){\\n            for(int j=i-1;j>=0;j--){\\n                int k=stones[i] -stones[j];\\n                if(k > j+1) break;\\n                dp[i][k] = dp[j][k-1] or dp[j][k] or dp[j][k+1];\\n                if(i==n-1 and dp[i][k]) return true;\\n            }\\n        }\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703111,
                "title": "c-using-map-and-sets-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n//      using map that stores number and the lenghts of jumps we took to reach there\\n//         for eg m[3] = {2} this means we reached 3 by jumping with k units. we don\\'t care where we jumped from, we just know,from 3 we can go to 3+2-1, 3+2,3+2+1 points. we store corresponding jumplengths for these numbers too. \\n//         at the end we check the last element, if we were able to reach it, the jump lenght wd be stored so return true;\\n        \\n        unordered_map<int, unordered_set<int>> m;\\n        m[stones[0]+1] = {1}; //becaause from 0th postion we can jump by only 1 unit\\n        for(int i =1;i<stones.size();i++){\\n            for(auto jump : m[stones[i]]){\\n//                 types of jumps we took to reach stones[i],\\n                // for eg m[4] = {2,3} that means we can jump with k =2 and k=3 \\n                m[stones[i]+jump].insert(jump);\\n                m[stones[i]+jump-1].insert( jump-1);\\n                m[stones[i]+jump+1].insert( jump+1);\\n            }\\n            \\n        }\\n        if(m[(stones[stones.size()-1])].size())\\n            return true; //means we somehow jumped to the end stone\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n//      using map that stores number and the lenghts of jumps we took to reach there\\n//         for eg m[3] = {2} this means we reached 3 by jumping with k units. we don\\'t care where we jumped from, we just know,from 3 we can go to 3+2-1, 3+2,3+2+1 points. we store corresponding jumplengths for these numbers too. \\n//         at the end we check the last element, if we were able to reach it, the jump lenght wd be stored so return true;\\n        \\n        unordered_map<int, unordered_set<int>> m;\\n        m[stones[0]+1] = {1}; //becaause from 0th postion we can jump by only 1 unit\\n        for(int i =1;i<stones.size();i++){\\n            for(auto jump : m[stones[i]]){\\n//                 types of jumps we took to reach stones[i],\\n                // for eg m[4] = {2,3} that means we can jump with k =2 and k=3 \\n                m[stones[i]+jump].insert(jump);\\n                m[stones[i]+jump-1].insert( jump-1);\\n                m[stones[i]+jump+1].insert( jump+1);\\n            }\\n            \\n        }\\n        if(m[(stones[stones.size()-1])].size())\\n            return true; //means we somehow jumped to the end stone\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3940111,
                "title": "pure-recursion-memoization-no-hashtable-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Boolean [][] memo = new Boolean[stones.length+1][stones.length+1];\\n        return recursion(0,1,stones,memo);\\n    }\\n    public boolean recursion(int i, int jump, int[] stones,Boolean [][] memo){\\n        if(i>=stones.length){\\n            return false;\\n        }\\n        if(i==stones.length-1){\\n            return true;\\n        }\\n        if(memo[i][jump]!=null){\\n            return memo[i][jump];\\n        }\\n        int nextPossibleStone = stones[i]+jump;\\n        int index = Arrays.binarySearch(stones,nextPossibleStone);\\n        if(index>i){\\n            boolean jump1 = recursion(index,jump-1,stones,memo);\\n            boolean jump2 = recursion(index,jump,stones,memo);\\n            boolean jump3 = recursion(index,jump+1,stones,memo);\\n            return memo[i][jump] = jump1||jump2||jump3;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Boolean [][] memo = new Boolean[stones.length+1][stones.length+1];\\n        return recursion(0,1,stones,memo);\\n    }\\n    public boolean recursion(int i, int jump, int[] stones,Boolean [][] memo){\\n        if(i>=stones.length){\\n            return false;\\n        }\\n        if(i==stones.length-1){\\n            return true;\\n        }\\n        if(memo[i][jump]!=null){\\n            return memo[i][jump];\\n        }\\n        int nextPossibleStone = stones[i]+jump;\\n        int index = Arrays.binarySearch(stones,nextPossibleStone);\\n        if(index>i){\\n            boolean jump1 = recursion(index,jump-1,stones,memo);\\n            boolean jump2 = recursion(index,jump,stones,memo);\\n            boolean jump3 = recursion(index,jump+1,stones,memo);\\n            return memo[i][jump] = jump1||jump2||jump3;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370810,
                "title": "very-easy-to-understand-for-beginners",
                "content": "```\\n int last;\\n    map<pair<int,int>,int>mp;\\n    \\n    bool dfs(int i,int k,  multiset<int>&m)\\n    {   \\n       if(mp.find({i,k})!=mp.end()) return mp[{i,k}];\\n        \\n        if(i==last){return 1;}\\n        \\n        if(i>(last)){return 0;}\\n        \\n        int x[]={0,-1,1};\\n        int f=0;\\n        \\n        for(int g=0;g<3;g++)\\n        {\\n            int p=k+x[g];\\n            if(p>0 && m.find(i+p)!=m.end())\\n            {\\n                if(dfs(i+p,p,m)){f=1;break;}\\n            }\\n            if(f==1){break;}\\n        }\\n        \\n       return mp[{i,k}]=f; \\n    }\\n    \\n    \\n    bool canCross(vector<int>& st) {\\n        multiset<int>m;\\n        m.clear();mp.clear();\\n        for(int i=0;i<st.size();i++){m.insert(st[i]);}\\n        \\n     last=st[st.size()-1];\\n       \\n      // cout<<last;\\n        \\n       // return 0;\\n        return dfs(0,0,m);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n int last;\\n    map<pair<int,int>,int>mp;\\n    \\n    bool dfs(int i,int k,  multiset<int>&m)\\n    {   \\n       if(mp.find({i,k})!=mp.end()) return mp[{i,k}];\\n        \\n        if(i==last){return 1;}\\n        \\n        if(i>(last)){return 0;}\\n        \\n        int x[]={0,-1,1};\\n        int f=0;\\n        \\n        for(int g=0;g<3;g++)\\n        {\\n            int p=k+x[g];\\n            if(p>0 && m.find(i+p)!=m.end())\\n            {\\n                if(dfs(i+p,p,m)){f=1;break;}\\n            }\\n            if(f==1){break;}\\n        }\\n        \\n       return mp[{i,k}]=f; \\n    }\\n    \\n    \\n    bool canCross(vector<int>& st) {\\n        multiset<int>m;\\n        m.clear();mp.clear();\\n        for(int i=0;i<st.size();i++){m.insert(st[i]);}\\n        \\n     last=st[st.size()-1];\\n       \\n      // cout<<last;\\n        \\n       // return 0;\\n        return dfs(0,0,m);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 894292,
                "title": "short-and-simple-dp-solution-using-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int,set<int>>m;\\n        int n = stones.size();\\n        \\n        for(int x:stones)\\n            m[x] = {};\\n        m[0].insert(1);\\n        \\n        for(int i=0;i<stones.size();i++){\\n            set<int>s = m[stones[i]];\\n            for(int k : s){\\n                int x = stones[i];\\n                if(m.find(x+k)!=m.end()){\\n                    m[x+k].insert(k);\\n                    m[x+k].insert(k+1);\\n                    m[x+k].insert(k-1);\\n                    if(x+k==stones[n-1])\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int,set<int>>m;\\n        int n = stones.size();\\n        \\n        for(int x:stones)\\n            m[x] = {};\\n        m[0].insert(1);\\n        \\n        for(int i=0;i<stones.size();i++){\\n            set<int>s = m[stones[i]];\\n            for(int k : s){\\n                int x = stones[i];\\n                if(m.find(x+k)!=m.end()){\\n                    m[x+k].insert(k);\\n                    m[x+k].insert(k+1);\\n                    m[x+k].insert(k-1);\\n                    if(x+k==stones[n-1])\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88858,
                "title": "easy-version-java",
                "content": "```\\npublic boolean canCross(int[] stones) {\\n        if(stones[1] > 1) return false;\\n        if(stones.length == 2) return true;\\n        return helper(stones, 1, 1);\\n    }\\n    private boolean helper(int[] arr, int i, int step){\\n        boolean pass = false;\\n        if(i == arr.length-1) return true;\\n        for(int j = i+1; j < arr.length; j++){\\n            if(arr[j] <= arr[i] + step + 1 && arr[j] >= arr[i]+step-1){\\n                pass = pass || helper(arr, j, arr[j] - arr[i]);\\n            }\\n        }\\n        return pass;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canCross(int[] stones) {\\n        if(stones[1] > 1) return false;\\n        if(stones.length == 2) return true;\\n        return helper(stones, 1, 1);\\n    }\\n    private boolean helper(int[] arr, int i, int step){\\n        boolean pass = false;\\n        if(i == arr.length-1) return true;\\n        for(int j = i+1; j < arr.length; j++){\\n            if(arr[j] <= arr[i] + step + 1 && arr[j] >= arr[i]+step-1){\\n                pass = pass || helper(arr, j, arr[j] - arr[i]);\\n            }\\n        }\\n        return pass;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3967257,
                "title": "c-simple-hashmap-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nn^2\\n\\n- Space complexity:\\nn^2\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        map<int,set<int>> mp;\\n        mp[0].insert(1);\\n        for(int i = 0;i<stones.size();i++){\\n            for(int jump : mp[stones[i]]){\\n                int pos = jump + stones[i];\\n                if(pos==stones[stones.size()-1]) return true;\\n               if(jump-1>0) mp[pos].insert(jump - 1);\\n               mp[pos].insert(jump);\\n               mp[pos].insert(jump + 1);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        map<int,set<int>> mp;\\n        mp[0].insert(1);\\n        for(int i = 0;i<stones.size();i++){\\n            for(int jump : mp[stones[i]]){\\n                int pos = jump + stones[i];\\n                if(pos==stones[stones.size()-1]) return true;\\n               if(jump-1>0) mp[pos].insert(jump - 1);\\n               mp[pos].insert(jump);\\n               mp[pos].insert(jump + 1);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966588,
                "title": "dp-binary-search-recursion-memoization-cpp",
                "content": "\\n# Approach\\n\\ndp[2001][2001]: A 2D array used for dynamic programming to store results of subproblems.\\n1. **solve(int i, int prev, vector<int>& stones, int n)**: \\nA recursive function that checks if the frog can cross the river. It takes the current stone index i, previous stone index prev, stone positions array stones, and the total number of stones n.\\n\\n2.**Base Cases:**\\n\\nif (i == n - 1): If the current stone is the last stone, the frog has successfully crossed, so return true.\\nif (i >= n): If the current index is out of bounds (beyond the last stone), the frog has gone too far, so return false.\\nif (dp[i][prev] != -1): If the result for the current state (i, prev) is already calculated, return that result.\\n\\n3 .**Jumping and Checking Possibilities**:\\n\\nint k = stones[i] - stones[prev];: Calculate the distance between the current stone and the previous stone.\\nLoop through possible jump distances within the range [k - 1, k + 1]:\\nIf j is 0, skip (the frog can\\'t jump a distance of 0).\\nCalculate the jump target position as stones[i] + j.\\nFind the index of the target position in the stones array using lower_bound.\\nIf the target position is a valid stone (ind < n and stones[ind] == jump), recursively call the solve function with updated indices.\\n\\n4. **Recursive Call and Update Answer**:\\n\\nIf a valid stone is found at the jump target position, update ans using a bitwise OR (ans = ans | ...) to track if any valid jump leads to crossing.\\nMemoization and Return:\\n\\nStore the calculated result in dp[i][prev] and return ans.\\nMain Function - canCross:\\n\\n5. **canCross(vector<int>& stones)**: Entry point function.\\nCheck if the first jump from the first stone to the second stone has a distance of 1. If not, the frog can\\'t make the initial jump, so return false.\\nInitialize the dp array with -1 using memset.\\nCall the solve function starting from the second stone and initial previous stone.\\n# Complexity\\n- Time complexity:O(n^2logn)\\n\\n- Space complexity:O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool solve(int i,int prev,vector<int>&nums,int n){\\n        // Base cases\\n        if(i==n-1)\\n            return true;\\n        if(i>=n)\\n            return false;\\n        // Memoization\\n        if(dp[i][prev]!=-1)\\n            return dp[i][prev];\\n        \\n        bool ans=false;\\n        int k=nums[i]-nums[prev];\\n        for(int j=k-1;j<=k+1;j++){\\n            if(j==0) continue;\\n            int jump=nums[i]+j;\\n            int ind=lower_bound(nums.begin(),nums.end(),jump)-nums.begin();\\n            if(ind<n && nums[ind]==jump){\\n                 ans=ans|solve(ind,i,nums,n);\\n            }\\n        }\\n        return dp[i][prev]= ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        if((stones[1]-stones[0])!=1) return false;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,0,stones,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool solve(int i,int prev,vector<int>&nums,int n){\\n        // Base cases\\n        if(i==n-1)\\n            return true;\\n        if(i>=n)\\n            return false;\\n        // Memoization\\n        if(dp[i][prev]!=-1)\\n            return dp[i][prev];\\n        \\n        bool ans=false;\\n        int k=nums[i]-nums[prev];\\n        for(int j=k-1;j<=k+1;j++){\\n            if(j==0) continue;\\n            int jump=nums[i]+j;\\n            int ind=lower_bound(nums.begin(),nums.end(),jump)-nums.begin();\\n            if(ind<n && nums[ind]==jump){\\n                 ans=ans|solve(ind,i,nums,n);\\n            }\\n        }\\n        return dp[i][prev]= ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        if((stones[1]-stones[0])!=1) return false;\\n        memset(dp,-1,sizeof(dp));\\n        return solve(1,0,stones,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966547,
                "title": "my-first-hard-question-solved-without-any-help-java-recursion-memoization-have-a-look",
                "content": "Approach is :\\n* Basically first storing all values of stones places with the index with which they appear on the array.\\n* This will help in retreiving whether we have reached a valid stone.\\n* Then we can start iterating from first stone, with value of k as 1.\\n* Base Case is if we reach n-1th index, then we have found a way to reach the end stone.\\n* From each index we consider all values of k and return the combined boolean value at the end of the iteration.\\n\\n\\n**Recursive TLE Solution**\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        if(stones[1]>1){\\n            return false;\\n        }\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            map.put(stones[i],i);\\n        }\\n        return solve(stones,1,n,1,map);\\n    }\\n    private boolean solve(int[] stones, int index, int n, int k,Map<Integer,Integer> map){\\n        if(index==n-1){\\n            return true;\\n        }\\n        boolean x=false,y=false,z=false;\\n        if(k>1 && map.containsKey(stones[index]+k-1)){\\n            x = solve(stones,map.get(stones[index]+k-1),n,k-1,map); \\n        }\\n        if(map.containsKey(stones[index]+k)){\\n            y = solve(stones,map.get(stones[index]+k),n,k,map);\\n        }\\n        if(map.containsKey(stones[index]+k+1)){\\n            z = solve(stones,map.get(stones[index]+k+1),n,k+1,map);\\n        }\\n        return x||y||z;\\n    }\\n}\\n```\\n\\n**Memoized Solution**\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        if(stones[1]>1){\\n            return false;\\n        }\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            map.put(stones[i],i);\\n        }\\n        Boolean[][] memo = new Boolean[n][2000];\\n        return solve(stones,1,n,1,map,memo);\\n    }\\n    private boolean solve(int[] stones, int index, int n, int k,Map<Integer,Integer> map,Boolean[][] memo){\\n        if(index==n-1){\\n            return true;\\n        }\\n        if(memo[index][k]!=null){\\n            return memo[index][k];\\n        }\\n        boolean x=false,y=false,z=false;\\n        if(k>1 && map.containsKey(stones[index]+k-1)){\\n            x = solve(stones,map.get(stones[index]+k-1),n,k-1,map,memo); \\n        }\\n        if(map.containsKey(stones[index]+k)){\\n            y = solve(stones,map.get(stones[index]+k),n,k,map,memo);\\n        }\\n        if(map.containsKey(stones[index]+k+1)){\\n            z = solve(stones,map.get(stones[index]+k+1),n,k+1,map,memo);\\n        }\\n        return memo[index][k] = x||y||z;\\n    }\\n}\\n```\\n\\nPlease UPVOTE if its helps you!!.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        if(stones[1]>1){\\n            return false;\\n        }\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            map.put(stones[i],i);\\n        }\\n        return solve(stones,1,n,1,map);\\n    }\\n    private boolean solve(int[] stones, int index, int n, int k,Map<Integer,Integer> map){\\n        if(index==n-1){\\n            return true;\\n        }\\n        boolean x=false,y=false,z=false;\\n        if(k>1 && map.containsKey(stones[index]+k-1)){\\n            x = solve(stones,map.get(stones[index]+k-1),n,k-1,map); \\n        }\\n        if(map.containsKey(stones[index]+k)){\\n            y = solve(stones,map.get(stones[index]+k),n,k,map);\\n        }\\n        if(map.containsKey(stones[index]+k+1)){\\n            z = solve(stones,map.get(stones[index]+k+1),n,k+1,map);\\n        }\\n        return x||y||z;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        if(stones[1]>1){\\n            return false;\\n        }\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            map.put(stones[i],i);\\n        }\\n        Boolean[][] memo = new Boolean[n][2000];\\n        return solve(stones,1,n,1,map,memo);\\n    }\\n    private boolean solve(int[] stones, int index, int n, int k,Map<Integer,Integer> map,Boolean[][] memo){\\n        if(index==n-1){\\n            return true;\\n        }\\n        if(memo[index][k]!=null){\\n            return memo[index][k];\\n        }\\n        boolean x=false,y=false,z=false;\\n        if(k>1 && map.containsKey(stones[index]+k-1)){\\n            x = solve(stones,map.get(stones[index]+k-1),n,k-1,map,memo); \\n        }\\n        if(map.containsKey(stones[index]+k)){\\n            y = solve(stones,map.get(stones[index]+k),n,k,map,memo);\\n        }\\n        if(map.containsKey(stones[index]+k+1)){\\n            z = solve(stones,map.get(stones[index]+k+1),n,k+1,map,memo);\\n        }\\n        return memo[index][k] = x||y||z;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966517,
                "title": "beats-100-dynamic-programming-c-hashmap",
                "content": "# Intuition\\n The frog jumping problem involves determining whether a frog can successfully jump from the starting stone to the last stone by adhering to certain jump rules. To solve this problem, we can use a recursive approach with memoization. At each stone, the frog can attempt jumps of various sizes, and we need to explore all possible jump combinations to determine if the frog can reach the end.\\n# Approach\\nWe start by defining a helper function f that will perform the recursive exploration of jump possibilities while keeping track of already computed results using memoization.\\n\\nThe base cases of the recursive function include scenarios where the frog has either jumped beyond the last stone (impossible) or successfully reached the last stone (possible).\\n\\nTo avoid recalculating results for the same subproblems, we use a memoization table (dp map) to store the computed results for different stone positions and jump sizes.\\n\\nFor each stone, we loop through possible jump variations: -1, 0, and 1. We skip a jump of size 0 as it\\'s not valid. We also ensure that the jump doesn\\'t take the frog to a negative index or beyond the last stone.\\n\\nFor each valid jump variation, we check if the frog can jump to the next stone by recursively calling the f function with updated stone index and jump size.\\n\\nIf at any point during the exploration, the frog successfully reaches the end, we break out of the loop and return true.\\n\\nFinally, we store the result of the current subproblem in the memoization table and return it.\\n\\nIn the main function canCross, we handle the special case where the second stone isn\\'t reachable by a jump of size 1. If this is the case, the frog can\\'t cross the river, and we return false.\\n\\nWe create two maps: m to store stone positions for quick access and dp to store computed results for memoization.\\n\\nWe mark stones as reachable in the m map and start the recursive check from the second stone with jump size 1 using the f function.\\n\\n# Complexity\\n- Time complexity: **O(n * k)**  \\n where n is the number of stones and k is the maximum jump size. \\n\\n- Space complexity: **O(n + k^2)** \\nwhere n is the number of stones and k is the maximum jump size. This is due to the space used for storing the stone positions (m map) and the memoization table (dp map).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper function to check if index i is within valid range [0, n]\\n    bool inline isV(int i, int n) {\\n        return (i >= 0 && i <= n);\\n    }\\n    \\n    // Recursive function to check if the frog can cross the river\\n    bool f(map<int, bool>& m, map<pair<int, int>, bool>& dp, int i, int n, int cj) {\\n        // Base case: If frog jumps beyond the last stone, it can\\'t cross\\n        if (i > n) return false;\\n        \\n        // Base case: If frog reaches the last stone, it can cross\\n        if (i == n) return true;\\n        \\n        // Check if the result for current (i, cj) is already calculated\\n        if (dp.find({i, cj}) != dp.end()) return dp[{i, cj}];\\n        \\n        bool canCross = false;\\n        \\n        // Loop through possible jump variations (-1, 0, 1)\\n        for (int j = -1; j <= 1; j++) {\\n            if (isV(i + cj + j, n) && cj + j != 0) {\\n                if (m[i + cj + j]) {\\n                    // Recursively check if frog can jump from current stone to next stone\\n                    canCross |= f(m, dp, i + cj + j, n, cj + j);\\n                }\\n            }\\n            if (canCross) break; // If frog can cross, no need to continue\\n        }\\n        \\n        // Store the result in the memoization table and return\\n        return dp[{i, cj}] = canCross;\\n    } \\n    \\n    // Main function to check if frog can cross the river using given stones\\n    bool canCross(vector<int>& s) {\\n        // Special case: If the second stone isn\\'t reachable by jump size 1, frog can\\'t cross\\n        if (s[1] != 1) return false;\\n        \\n        map<int, bool> m; // Store stone positions for quick access\\n        map<pair<int, int>, bool> dp; // Memoization table to store computed results\\n        \\n        // Mark stones as reachable in the map\\n        for (int i = 1; i < s.size(); i++) {\\n            m[s[i]] = true;\\n        }\\n        \\n        // Start recursive check from the second stone with jump size 1\\n        return f(m, dp, s[1], s.back(), 1);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if index i is within valid range [0, n]\\n    bool inline isV(int i, int n) {\\n        return (i >= 0 && i <= n);\\n    }\\n    \\n    // Recursive function to check if the frog can cross the river\\n    bool f(map<int, bool>& m, map<pair<int, int>, bool>& dp, int i, int n, int cj) {\\n        // Base case: If frog jumps beyond the last stone, it can\\'t cross\\n        if (i > n) return false;\\n        \\n        // Base case: If frog reaches the last stone, it can cross\\n        if (i == n) return true;\\n        \\n        // Check if the result for current (i, cj) is already calculated\\n        if (dp.find({i, cj}) != dp.end()) return dp[{i, cj}];\\n        \\n        bool canCross = false;\\n        \\n        // Loop through possible jump variations (-1, 0, 1)\\n        for (int j = -1; j <= 1; j++) {\\n            if (isV(i + cj + j, n) && cj + j != 0) {\\n                if (m[i + cj + j]) {\\n                    // Recursively check if frog can jump from current stone to next stone\\n                    canCross |= f(m, dp, i + cj + j, n, cj + j);\\n                }\\n            }\\n            if (canCross) break; // If frog can cross, no need to continue\\n        }\\n        \\n        // Store the result in the memoization table and return\\n        return dp[{i, cj}] = canCross;\\n    } \\n    \\n    // Main function to check if frog can cross the river using given stones\\n    bool canCross(vector<int>& s) {\\n        // Special case: If the second stone isn\\'t reachable by jump size 1, frog can\\'t cross\\n        if (s[1] != 1) return false;\\n        \\n        map<int, bool> m; // Store stone positions for quick access\\n        map<pair<int, int>, bool> dp; // Memoization table to store computed results\\n        \\n        // Mark stones as reachable in the map\\n        for (int i = 1; i < s.size(); i++) {\\n            m[s[i]] = true;\\n        }\\n        \\n        // Start recursive check from the second stone with jump size 1\\n        return f(m, dp, s[1], s.back(), 1);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966058,
                "title": "explained-in-hindi-easy-to-understand-optimized-using-unordered-map",
                "content": "![478xve.jpg](https://assets.leetcode.com/users/images/b0964976-3d6f-49d2-927b-5b44cf43364f_1693120252.7637296.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool frogCrosses(vector<int>& stones, int jump, int idx, int n, vector<vector<int>> &dp, unordered_map<int, int> &sIdx){\\n\\n        //base case agr hm last index pr hai toh return true\\n        if(idx == n-1)\\n            return true;\\n\\n        //kya current index se jump krne pr hm last index tk phch paege? -1 = Pata Nhi; 0 = NO; 1 = Yes\\n        if(dp[idx][jump] != -1)\\n            return dp[idx][jump];\\n\\n        //agr jump 0 hai toh infinte loop me aajaege isliye return 0 - means nhi phch paege\\n        if(jump == 0)\\n            return dp[idx][jump] = 0;\\n\\n        //save stone value jha jump krne ke baad phchege\\n        int stoneVal = jump + stones[idx];\\n        int newIdx = -1;\\n\\n        //find index of stone value in stones array using stone-index map \\n        if(sIdx[stoneVal] != 0)\\n            newIdx = sIdx[stoneVal];\\n        else\\n            return dp[idx][jump] = 0;\\n\\n        //call kro saare possible jumps ke liye\\n        if(newIdx <= n-1){\\n            bool j1 = frogCrosses(stones, jump-1, newIdx, n, dp, sIdx);\\n            bool j2 = frogCrosses(stones, jump, newIdx, n, dp, sIdx);\\n            bool j3 = frogCrosses(stones, jump+1, newIdx, n, dp, sIdx);\\n            return dp[idx][jump] = j1 | j2 | j3;\\n        }\\n\\n        return dp[idx][jump] = 0;\\n    }\\n\\npublic:\\n    bool canCross(vector<int>& stones) {\\n\\n        int n = stones.size();\\n\\n        //Create stone-index map for fast search of index location - O(1) time Complexity me\\n        unordered_map<int, int>sIdx;\\n        for(int i=0; i<n; i++){\\n            sIdx[stones[i]] = i;\\n        }\\n\\n        //dp[i][j] which stores if I make jump \\'j\\' from index \\'i\\'\\n        //then: if dp[i][j] = 0 means nhi phch paege n-1(last) index tk\\n        //     if dp[i][j] = 1 means phch paege n-1(last) index tk\\n        //     if dp[i][j] = -1 means abhi pta nhi hai\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return frogCrosses(stones, 1, 0, n, dp, sIdx);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool frogCrosses(vector<int>& stones, int jump, int idx, int n, vector<vector<int>> &dp, unordered_map<int, int> &sIdx){\\n\\n        //base case agr hm last index pr hai toh return true\\n        if(idx == n-1)\\n            return true;\\n\\n        //kya current index se jump krne pr hm last index tk phch paege? -1 = Pata Nhi; 0 = NO; 1 = Yes\\n        if(dp[idx][jump] != -1)\\n            return dp[idx][jump];\\n\\n        //agr jump 0 hai toh infinte loop me aajaege isliye return 0 - means nhi phch paege\\n        if(jump == 0)\\n            return dp[idx][jump] = 0;\\n\\n        //save stone value jha jump krne ke baad phchege\\n        int stoneVal = jump + stones[idx];\\n        int newIdx = -1;\\n\\n        //find index of stone value in stones array using stone-index map \\n        if(sIdx[stoneVal] != 0)\\n            newIdx = sIdx[stoneVal];\\n        else\\n            return dp[idx][jump] = 0;\\n\\n        //call kro saare possible jumps ke liye\\n        if(newIdx <= n-1){\\n            bool j1 = frogCrosses(stones, jump-1, newIdx, n, dp, sIdx);\\n            bool j2 = frogCrosses(stones, jump, newIdx, n, dp, sIdx);\\n            bool j3 = frogCrosses(stones, jump+1, newIdx, n, dp, sIdx);\\n            return dp[idx][jump] = j1 | j2 | j3;\\n        }\\n\\n        return dp[idx][jump] = 0;\\n    }\\n\\npublic:\\n    bool canCross(vector<int>& stones) {\\n\\n        int n = stones.size();\\n\\n        //Create stone-index map for fast search of index location - O(1) time Complexity me\\n        unordered_map<int, int>sIdx;\\n        for(int i=0; i<n; i++){\\n            sIdx[stones[i]] = i;\\n        }\\n\\n        //dp[i][j] which stores if I make jump \\'j\\' from index \\'i\\'\\n        //then: if dp[i][j] = 0 means nhi phch paege n-1(last) index tk\\n        //     if dp[i][j] = 1 means phch paege n-1(last) index tk\\n        //     if dp[i][j] = -1 means abhi pta nhi hai\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return frogCrosses(stones, 1, 0, n, dp, sIdx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965124,
                "title": "c-dynamic-programming",
                "content": "\\n# Code\\n```\\npublic class Solution \\n{\\n    bool[,] mem;\\n    public bool CanCross(int[] stones) \\n    {\\n        mem = new bool[stones.Length, stones.Length];\\n        return Cross(stones,0,0);\\n    }\\n    public bool Cross(int[] stones,int k,int index)\\n    {\\n        if(mem[index,k]) return false;\\n        if(index == stones.Length - 1) return true;\\n        \\n        int a = index;\\n        while(++a < stones.Length && (stones[a] - stones[index]) - k < 2)\\n        {\\n            if((stones[a] - stones[index]) - k > -2)\\n                if(Cross(stones,(stones[a] - stones[index]),a)) return true;\\n        }\\n        mem[index,k] = true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution \\n{\\n    bool[,] mem;\\n    public bool CanCross(int[] stones) \\n    {\\n        mem = new bool[stones.Length, stones.Length];\\n        return Cross(stones,0,0);\\n    }\\n    public bool Cross(int[] stones,int k,int index)\\n    {\\n        if(mem[index,k]) return false;\\n        if(index == stones.Length - 1) return true;\\n        \\n        int a = index;\\n        while(++a < stones.Length && (stones[a] - stones[index]) - k < 2)\\n        {\\n            if((stones[a] - stones[index]) - k > -2)\\n                if(Cross(stones,(stones[a] - stones[index]),a)) return true;\\n        }\\n        mem[index,k] = true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258611,
                "title": "403-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a dictionary jumps to store the set of possible jumps for each stone.\\n\\n2. Initialize the set of possible jumps for the first stone (position 0) with 1.\\n\\n3. Iterate through each stone in the input list stones.\\n\\n4. For each stone, iterate through its set of possible jumps.\\n\\n5. For each possible jump, check if the stone at the current position plus the jump size is in the list of stones.\\n\\n6. If the stone at the next position is in the list of stones, add the possible jump sizes (jump, jump-1, jump+1) to the set of possible jumps for the stone at the next position.\\n\\n7. Continue steps 4-6 until we have processed all the stones or we find a stone that has no possible jumps.\\n\\n8. If we reach the last stone and it has a non-empty set of possible jumps, return True, indicating that the frog can cross the river. Otherwise, return False.\\n\\nThe algorithm uses dynamic programming to keep track of the possible jumps from each stone, and it checks all the possible jump sizes from each stone to determine if the frog can reach the last stone. The use of dynamic programming helps to avoid unnecessary computations by storing the results of subproblems (possible jumps from each stone) in a dictionary and reusing them as needed. This makes the algorithm more efficient than a brute-force approach that would check all possible jump sequences.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        # Create a dictionary to store the set of possible jumps for each stone\\n        jumps = {}\\n        for stone in stones:\\n            jumps[stone] = set()\\n\\n        # Initialize the set of possible jumps for the first stone with 1\\n        jumps[0].add(1)\\n\\n        # Iterate through each stone\\n        for stone in stones:\\n            # Iterate through the set of possible jumps for the current stone\\n            for jump in jumps[stone]:\\n                # Check if the stone at the current position plus the jump size is in the list of stones\\n                next_stone = stone + jump\\n                if next_stone in jumps:\\n                    # Add the possible jump sizes to the set of possible jumps for the stone at the next position\\n                    jumps[next_stone].add(jump)\\n                    if jump > 1:\\n                        jumps[next_stone].add(jump - 1)\\n                    jumps[next_stone].add(jump + 1)\\n\\n        # Check if the last stone has a non-empty set of possible jumps\\n        return len(jumps[stones[-1]]) > 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        # Create a dictionary to store the set of possible jumps for each stone\\n        jumps = {}\\n        for stone in stones:\\n            jumps[stone] = set()\\n\\n        # Initialize the set of possible jumps for the first stone with 1\\n        jumps[0].add(1)\\n\\n        # Iterate through each stone\\n        for stone in stones:\\n            # Iterate through the set of possible jumps for the current stone\\n            for jump in jumps[stone]:\\n                # Check if the stone at the current position plus the jump size is in the list of stones\\n                next_stone = stone + jump\\n                if next_stone in jumps:\\n                    # Add the possible jump sizes to the set of possible jumps for the stone at the next position\\n                    jumps[next_stone].add(jump)\\n                    if jump > 1:\\n                        jumps[next_stone].add(jump - 1)\\n                    jumps[next_stone].add(jump + 1)\\n\\n        # Check if the last stone has a non-empty set of possible jumps\\n        return len(jumps[stones[-1]]) > 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941496,
                "title": "dp-recursion-memoization-pruning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for all the possible paths in a smart way.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the difference between the neighbours is greater than the maxmimum possible jump at that index which is equal to the index then its always an unreachable state and we return false.\\n\\nIn recursion check for all the possible jumps possible in the order checking k + 1 , k , k - 1 jumps because the answer exists more towards higher number of jumps.\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<int , bool> mp;\\n    map<pair<int , int> , int> dp;\\npublic:\\n    bool recur(int x , int k , int dest){\\n        if(x == dest) // we reach the final stone\\n            return true;\\n        if(k <= 0 or mp.find(x) == mp.end()) // if stone is not present or jumps is always positive\\n            return false;\\n        if(dp.find({x , k}) != dp.end()) // memoization\\n            return dp[{x , k}];\\n        // Check k + 1 , k , k - 1 jumps\\n        // Its advisable to move more jumps forward so k + 1 , k , k - 1;\\n        return dp[{x , k}] = recur(x + k + 1 , k + 1 , dest) || recur(x + k , k , dest) || recur(x + k - 1 , k - 1 , dest);\\n    }\\n    bool canCross(vector<int>& stones) {\\n        for(int i{}; i < stones.size(); ++i) mp[stones[i]] = true;\\n        if(stones[1] != 1) return false; // First jump is of 1 units\\n        for(int i{2}; i < stones.size(); ++i){\\n            if(stones[i] - stones[i - 1] - i > 0) return false; // pruning as this is unreachable\\n        }\\n        return recur(stones[1] , 1 , stones.back());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int , bool> mp;\\n    map<pair<int , int> , int> dp;\\npublic:\\n    bool recur(int x , int k , int dest){\\n        if(x == dest) // we reach the final stone\\n            return true;\\n        if(k <= 0 or mp.find(x) == mp.end()) // if stone is not present or jumps is always positive\\n            return false;\\n        if(dp.find({x , k}) != dp.end()) // memoization\\n            return dp[{x , k}];\\n        // Check k + 1 , k , k - 1 jumps\\n        // Its advisable to move more jumps forward so k + 1 , k , k - 1;\\n        return dp[{x , k}] = recur(x + k + 1 , k + 1 , dest) || recur(x + k , k , dest) || recur(x + k - 1 , k - 1 , dest);\\n    }\\n    bool canCross(vector<int>& stones) {\\n        for(int i{}; i < stones.size(); ++i) mp[stones[i]] = true;\\n        if(stones[1] != 1) return false; // First jump is of 1 units\\n        for(int i{2}; i < stones.size(); ++i){\\n            if(stones[i] - stones[i - 1] - i > 0) return false; // pruning as this is unreachable\\n        }\\n        return recur(stones[1] , 1 , stones.back());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2583664,
                "title": "dp-binary-search",
                "content": "->states are index and jump , we check if the stones[index1]+jump exists in the stones array using binary search\\n->if present check possiblity for the index2 such that stones[index2]=stones[index1]+jump\\n->with jump2= jump, jump+-1  ie. rec(index2,jump2,stones)\\n```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    // \\'ans\\' just to check if we reached the last index, not necessary to use this\\n    //max jump can reach ~2001 (1+1+1+1+....)\\n    // let states be prev INDEX (not position) and cur jump \\n    // here prev denotes the previous index we reached\\n    // and jump denotes the jump from \\'prev\\'\\n    // we check if stones[prev]+(jump) exists in the stones array \\n    //if it is present we check the next states\\n    //time complexity (n^2)log n , space n^2\\n    vector<vector<int>>dp{2010,vector<int>(2010,-1)};\\n    \\n    //recursive function\\n    int rec(int jump, int prev,vector<int>&stones){\\n        int n  = stones.size();\\n        if(jump+ stones[prev]==stones[n-1]){dp[prev][jump]=1;ans =true;return 1;}\\n        // answer =true, we reached the last index\\n        if(jump + stones[prev]> stones [n-1])return 0  ;\\n        // jumped more than the last position \\n       \\n        if(dp[prev][jump]!=-1)return dp[prev][jump];\\n        // checking if we already calculated this state\\n        if(ans)return 1;// not necessary just to reduce some function calls \\n        \\n        \\n        int cur = jump+stones[prev];// this denotes what would be the position after we jump \\'jump\\' from prev index\\n        int x = lower_bound(stones.begin(),stones.end(),cur)-stones.begin();\\n        // check if that position exists in the stones array-> binary search\\n        if(x==n  )return 0;//position not present\\n        if(stones[x]!=cur)return 0;// position not present\\n        \\n        //position present now check for the next possible states with jump,jump+1,jump-1\\n        bool ans =false;\\n        ans  |=rec(jump,x,stones); \\n       if(jump>1)ans |=rec(jump-1,x,stones);//a jump of 0 will cause TLE\\n        ans  |=rec(jump+1,x,stones);\\n      return dp[prev][jump]=ans;\\n    }\\n    \\n    \\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]!=1)return false;\\n        \\n         rec(1,0,stones);//start index 0, start jump 1\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool ans = false;\\n    // \\'ans\\' just to check if we reached the last index, not necessary to use this\\n    //max jump can reach ~2001 (1+1+1+1+....)\\n    // let states be prev INDEX (not position) and cur jump \\n    // here prev denotes the previous index we reached\\n    // and jump denotes the jump from \\'prev\\'\\n    // we check if stones[prev]+(jump) exists in the stones array \\n    //if it is present we check the next states\\n    //time complexity (n^2)log n , space n^2\\n    vector<vector<int>>dp{2010,vector<int>(2010,-1)};\\n    \\n    //recursive function\\n    int rec(int jump, int prev,vector<int>&stones){\\n        int n  = stones.size();\\n        if(jump+ stones[prev]==stones[n-1]){dp[prev][jump]=1;ans =true;return 1;}\\n        // answer =true, we reached the last index\\n        if(jump + stones[prev]> stones [n-1])return 0  ;\\n        // jumped more than the last position \\n       \\n        if(dp[prev][jump]!=-1)return dp[prev][jump];\\n        // checking if we already calculated this state\\n        if(ans)return 1;// not necessary just to reduce some function calls \\n        \\n        \\n        int cur = jump+stones[prev];// this denotes what would be the position after we jump \\'jump\\' from prev index\\n        int x = lower_bound(stones.begin(),stones.end(),cur)-stones.begin();\\n        // check if that position exists in the stones array-> binary search\\n        if(x==n  )return 0;//position not present\\n        if(stones[x]!=cur)return 0;// position not present\\n        \\n        //position present now check for the next possible states with jump,jump+1,jump-1\\n        bool ans =false;\\n        ans  |=rec(jump,x,stones); \\n       if(jump>1)ans |=rec(jump-1,x,stones);//a jump of 0 will cause TLE\\n        ans  |=rec(jump+1,x,stones);\\n      return dp[prev][jump]=ans;\\n    }\\n    \\n    \\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]!=1)return false;\\n        \\n         rec(1,0,stones);//start index 0, start jump 1\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289437,
                "title": "frog-jump-java-hashmap-hashset-easy",
                "content": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        HashMap<Integer, HashSet<Integer>> hm=new HashMap<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            hm.put(stones[i],new HashSet<>());\\n        }\\n        \\n        hm.get(stones[0]).add(1);\\n        \\n        int n=stones.length;\\n        \\n        for(int i=0;i<n;i++){\\n            HashSet<Integer> hs=hm.get(stones[i]);\\n            \\n            for(int j:hs){\\n                int pos=stones[i]+j;\\n                \\n                if(pos==stones[n-1]){\\n                    return true; \\n                }\\n                \\n                if(hm.containsKey(pos)){\\n                    if(j-1>0){\\n                        hm.get(pos).add(j-1);\\n                    }\\n                    \\n                    hm.get(pos).add(j);\\n                    hm.get(pos).add(j+1);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        HashMap<Integer, HashSet<Integer>> hm=new HashMap<>();\\n        \\n        for(int i=0;i<stones.length;i++){\\n            hm.put(stones[i],new HashSet<>());\\n        }\\n        \\n        hm.get(stones[0]).add(1);\\n        \\n        int n=stones.length;\\n        \\n        for(int i=0;i<n;i++){\\n            HashSet<Integer> hs=hm.get(stones[i]);\\n            \\n            for(int j:hs){\\n                int pos=stones[i]+j;\\n                \\n                if(pos==stones[n-1]){\\n                    return true; \\n                }\\n                \\n                if(hm.containsKey(pos)){\\n                    if(j-1>0){\\n                        hm.get(pos).add(j-1);\\n                    }\\n                    \\n                    hm.get(pos).add(j);\\n                    hm.get(pos).add(j+1);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658762,
                "title": "super-easy-solution-with-hashmap",
                "content": "```\\n# Approach 1: \\n# Time:  O(n^2)\\n# Space: O(n)\\n\\ndef canCross(stones):\\n    \"\"\"\\n    :type stones: List[int]\\n    :rtype: bool\\n    \"\"\"\\n    # standing on every stones, knowing the possible incoming velocities (vi) to it\\n    # we see to what stones we can reach with (vi,vi-1,vi+1) then we record new incoming velocities in the destination stones\\n    # if the last stone has at least one incoming velocity, it means there has been a valid path going from first stone to the last stone\\n    dp = {i:set() for i in stones}\\n    dp[0].add(0)\\n    neigh = [-1,0,1]\\n    for stone in stones:\\n        for vel in dp[stone]:\\n            for n in neigh:\\n                if stone + vel + n in dp and stone + vel + n > stone:\\n                    dp[stone + vel + n].add(vel+n)\\n    # print(dp)       \\n    return len(dp[stones[-1]]) > 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Approach 1: \\n# Time:  O(n^2)\\n# Space: O(n)\\n\\ndef canCross(stones):\\n    \"\"\"\\n    :type stones: List[int]\\n    :rtype: bool\\n    \"\"\"\\n    # standing on every stones, knowing the possible incoming velocities (vi) to it\\n    # we see to what stones we can reach with (vi,vi-1,vi+1) then we record new incoming velocities in the destination stones\\n    # if the last stone has at least one incoming velocity, it means there has been a valid path going from first stone to the last stone\\n    dp = {i:set() for i in stones}\\n    dp[0].add(0)\\n    neigh = [-1,0,1]\\n    for stone in stones:\\n        for vel in dp[stone]:\\n            for n in neigh:\\n                if stone + vel + n in dp and stone + vel + n > stone:\\n                    dp[stone + vel + n].add(vel+n)\\n    # print(dp)       \\n    return len(dp[stones[-1]]) > 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1327854,
                "title": "c-clean-code-and-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n     unordered_map<int,unordered_set<int>>mp;\\n        \\n        for(auto x:stones){\\n            // inserting values of stones into the map\\n            mp[x];\\n        }\\n        \\n        mp[stones[0]].insert(1);\\n        // given first jump will be of only one\\n        \\n        for(int i=0;i<stones.size();i++){\\n            \\n            unordered_set<int>temp=mp[stones[i]];\\n            // taking values of steps \\n            for(auto steps:temp){\\n                \\n                if(mp.find(steps+stones[i])!= mp.end()){\\n                    \\n                    mp[stones[i]+steps].insert(steps);\\n                    mp[stones[i]+steps].insert(steps+1);\\n                    if(steps-1 !=0){\\n                        \\n                        mp[stones[i]+steps].insert(steps-1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return mp[stones[stones.size()-1]].size()!=0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n     unordered_map<int,unordered_set<int>>mp;\\n        \\n        for(auto x:stones){\\n            // inserting values of stones into the map\\n            mp[x];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1274516,
                "title": "java-memo",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,Boolean> map;\\n    int[] arr;\\n    HashMap<String,Boolean> dp;\\n    public boolean canCross(int[] stones) {\\n        map = new HashMap<>();\\n        arr = stones;\\n        dp = new HashMap<>();\\n        for(int val:stones){\\n            map.put(val,true);\\n        }\\n        return helper(1,0);\\n    }\\n    public boolean helper(int jump,int curPos){\\n        if(curPos == arr[arr.length-1]){\\n            return true;\\n        }\\n        if(jump<1 || !map.containsKey(curPos)){\\n            return false;\\n        }\\n        if(dp.containsKey(jump+\"#\"+curPos)){\\n            return dp.get(jump+\"#\"+curPos);\\n        }\\n        boolean res = helper(jump-1,curPos+jump) ||  helper(jump,curPos+jump) ||  helper(jump+1,curPos+jump);\\n        dp.put(jump+\"#\"+curPos,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,Boolean> map;\\n    int[] arr;\\n    HashMap<String,Boolean> dp;\\n    public boolean canCross(int[] stones) {\\n        map = new HashMap<>();\\n        arr = stones;\\n        dp = new HashMap<>();\\n        for(int val:stones){\\n            map.put(val,true);\\n        }\\n        return helper(1,0);\\n    }\\n    public boolean helper(int jump,int curPos){\\n        if(curPos == arr[arr.length-1]){\\n            return true;\\n        }\\n        if(jump<1 || !map.containsKey(curPos)){\\n            return false;\\n        }\\n        if(dp.containsKey(jump+\"#\"+curPos)){\\n            return dp.get(jump+\"#\"+curPos);\\n        }\\n        boolean res = helper(jump-1,curPos+jump) ||  helper(jump,curPos+jump) ||  helper(jump+1,curPos+jump);\\n        dp.put(jump+\"#\"+curPos,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519465,
                "title": "java-simple-bfs-o-n-2",
                "content": "```java\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        boolean[][] seen = new boolean[1100][1100];\\n        seen[0][0] = true;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < stones.length; i++) map.put(stones[i], i);\\n        while (!q.isEmpty()) {\\n            int[] top = q.poll();\\n            int k = top[1];\\n            int index = top[0];\\n            if (index == stones.length - 1) return true;\\n            for (int i = -1; i <= 1; i++) {\\n                int newK = k + i;\\n                int newPos = stones[index] + newK;\\n                int newIndex = map.getOrDefault(newPos, -1);\\n                if (newIndex > index && !seen[newIndex][newK]) {\\n                    seen[newIndex][newK] = true;\\n                    q.offer(new int[]{newIndex, newK});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        boolean[][] seen = new boolean[1100][1100];\\n        seen[0][0] = true;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < stones.length; i++) map.put(stones[i], i);\\n        while (!q.isEmpty()) {\\n            int[] top = q.poll();\\n            int k = top[1];\\n            int index = top[0];\\n            if (index == stones.length - 1) return true;\\n            for (int i = -1; i <= 1; i++) {\\n                int newK = k + i;\\n                int newPos = stones[index] + newK;\\n                int newIndex = map.getOrDefault(newPos, -1);\\n                if (newIndex > index && !seen[newIndex][newK]) {\\n                    seen[newIndex][newK] = true;\\n                    q.offer(new int[]{newIndex, newK});\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139554,
                "title": "javascript-dp-solution",
                "content": "```js\\nfunction canCross(stones) {\\n  let dp = [[0]];\\n  \\n  for (let i = 1; i < stones.length; i++) {\\n    dp[i] = [];\\n    for (let j = 0; j < i; j++) {\\n      for (let step of dp[j]) {\\n        if (Math.abs(stones[j]+step-stones[i]) <= 1) {\\n          dp[i].push(stones[i]-stones[j]);\\n          break;\\n        }\\n      }\\n    }\\n  }\\n  \\n  return dp[stones.length-1].length > 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction canCross(stones) {\\n  let dp = [[0]];\\n  \\n  for (let i = 1; i < stones.length; i++) {\\n    dp[i] = [];\\n    for (let j = 0; j < i; j++) {\\n      for (let step of dp[j]) {\\n        if (Math.abs(stones[j]+step-stones[i]) <= 1) {\\n          dp[i].push(stones[i]-stones[j]);\\n          break;\\n        }\\n      }\\n    }\\n  }\\n  \\n  return dp[stones.length-1].length > 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88799,
                "title": "c-dfs-using-memo",
                "content": "```\\nclass Solution {\\n  public:\\n    bool canCross(vector<int> &stones) {\\n        unordered_map<int, unordered_map<int, bool>> dir;\\n        return helper(stones, 0, 0, dir);\\n    }\\n    bool helper(vector<int> &stones, int start, int k,\\n                unordered_map<int, unordered_map<int, bool>> &dir) {\\n        if (start == stones.size() - 1) {\\n            return true;\\n        }\\n        if (dir.count(start) && dir[start].count(k)) {\\n            return dir[start][k];\\n        }\\n        for (int step = max(k - 1, 1); step <= k + 1; step++) {\\n            for (int i = start + 1; i < stones.size(); i++) {\\n                    if (stones[start] + step == stones[i] &&\\n                        helper(stones, i, step, dir)) {\\n                        dir[start][k] = true;\\n                        return true;\\n                    }\\n            }\\n        }\\n        dir[start][k] = false;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n    bool canCross(vector<int> &stones) {\\n        unordered_map<int, unordered_map<int, bool>> dir;\\n        return helper(stones, 0, 0, dir);\\n    }\\n    bool helper(vector<int> &stones, int start, int k,\\n                unordered_map<int, unordered_map<int, bool>> &dir) {\\n        if (start == stones.size() - 1) {\\n            return true;\\n        }\\n        if (dir.count(start) && dir[start].count(k)) {\\n            return dir[start][k];\\n        }\\n        for (int step = max(k - 1, 1); step <= k + 1; step++) {\\n            for (int i = start + 1; i < stones.size(); i++) {\\n                    if (stones[start] + step == stones[i] &&\\n                        helper(stones, i, step, dir)) {\\n                        dir[start][k] = true;\\n                        return true;\\n                    }\\n            }\\n        }\\n        dir[start][k] = false;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88896,
                "title": "simple-and-easy-understand-java-solution",
                "content": "```\\npublic boolean canCross(int[] stones) {\\n        if (stones == null || stones.length == 0) {\\n            return false;\\n        }\\n        if (stones[1] > 1) {\\n            return false;\\n        }\\n\\n        Set[] lastJump = new Set[stones.length];\\n        for (int i = 1; i < stones.length; i++) {\\n            lastJump[i] = new HashSet<Integer>();\\n        }\\n        lastJump[1].add(1);\\n        \\n        for (int i = 2; i < stones.length; i++) {\\n            for (int j = 1; j < i; j++) {\\n                //cell j can be reached\\n                if (lastJump[j].size() > 0) {\\n                    int currJump = stones[i] - stones[j];\\n                    if (lastJump[j].contains(currJump) || \\n                        lastJump[j].contains(currJump + 1) ||\\n                        lastJump[j].contains(currJump - 1)) {\\n                        lastJump[i].add(currJump);\\n                    }\\n                }\\n            }\\n        }\\n        return lastJump[stones.length - 1].size() > 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canCross(int[] stones) {\\n        if (stones == null || stones.length == 0) {\\n            return false;\\n        }\\n        if (stones[1] > 1) {\\n            return false;\\n        }\\n\\n        Set[] lastJump = new Set[stones.length];\\n        for (int i = 1; i < stones.length; i++) {\\n            lastJump[i] = new HashSet<Integer>();\\n        }\\n        lastJump[1].add(1);\\n        \\n        for (int i = 2; i < stones.length; i++) {\\n            for (int j = 1; j < i; j++) {\\n                //cell j can be reached\\n                if (lastJump[j].size() > 0) {\\n                    int currJump = stones[i] - stones[j];\\n                    if (lastJump[j].contains(currJump) || \\n                        lastJump[j].contains(currJump + 1) ||\\n                        lastJump[j].contains(currJump - 1)) {\\n                        lastJump[i].add(currJump);\\n                    }\\n                }\\n            }\\n        }\\n        return lastJump[stones.length - 1].size() > 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88939,
                "title": "simple-easy-to-understand-java-solution",
                "content": "```\\npublic static boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> stoneMap = new HashMap<>();\\n        for (int i = 1; i < stones.length; i++) {\\n            stoneMap.put(stones[i], new HashSet<Integer>());\\n        }\\n        if(stones[0]+1 == stones[1]) {\\n            stoneMap.get(stones[1]).add(1);\\n        }\\n        for(int i = 1; i < stones.length; i++) {\\n            int eachStone = stones[i];\\n            for(Integer K: stoneMap.get(eachStone)) {\\n                if(K != 1 &&  stoneMap.containsKey(eachStone + K - 1)) {\\n                    stoneMap.get(eachStone + K - 1).add(K - 1);\\n                }\\n                if(stoneMap.containsKey(eachStone + K)) {\\n                    stoneMap.get(eachStone + K).add(K);\\n                }\\n                if(stoneMap.containsKey(eachStone + K + 1)) {\\n                    stoneMap.get(eachStone + K + 1).add(K + 1);\\n                }\\n            }\\n        }\\n        return stoneMap.get(stones[stones.length - 1]).size() >= 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> stoneMap = new HashMap<>();\\n        for (int i = 1; i < stones.length; i++) {\\n            stoneMap.put(stones[i], new HashSet<Integer>());\\n        }\\n        if(stones[0]+1 == stones[1]) {\\n            stoneMap.get(stones[1]).add(1);\\n        }\\n        for(int i = 1; i < stones.length; i++) {\\n            int eachStone = stones[i];\\n            for(Integer K: stoneMap.get(eachStone)) {\\n                if(K != 1 &&  stoneMap.containsKey(eachStone + K - 1)) {\\n                    stoneMap.get(eachStone + K - 1).add(K - 1);\\n                }\\n                if(stoneMap.containsKey(eachStone + K)) {\\n                    stoneMap.get(eachStone + K).add(K);\\n                }\\n                if(stoneMap.containsKey(eachStone + K + 1)) {\\n                    stoneMap.get(eachStone + K + 1).add(K + 1);\\n                }\\n            }\\n        }\\n        return stoneMap.get(stones[stones.length - 1]).size() >= 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3969104,
                "title": "easy-dp-solution",
                "content": "\\n# Approach\\nThe frog starts at the first stone and wants to reach the last stone. The frog can jump forward to the next stone if and only if its jump length is equal to the distance between the current stone and the next stone. The frog\\'s jump length can increase or decrease by 1 unit.\\n\\nThe dp array is used for dynamic programming to memoize the results of subproblems. The dimensions of dp are [2001][2001], which are used to store whether it\\'s possible for the frog to cross from stone i to stone j with a particular jump length. The value -1 indicates that the subproblem hasn\\'t been solved yet.\\n\\nThe find function is a recursive function that checks whether the frog can reach the last stone starting from stone i with a jump length of k. The base cases for the recursion are when the frog is already at the last stone or beyond it, in which case it returns true or false accordingly.\\n\\nThe function then iterates through possible jump lengths (increasing or decreasing by 1) and checks if the frog can make a valid jump to the next stone. It does this by finding the index (in) of the next stone that would be reached with the jump length. If such a stone exists and is at the expected position, the function makes a recursive call to find for that stone and jump length. If the recursive call returns true, it means the frog can reach the last stone, and the result is updated to true.\\n\\nFinally, the result is memoized in the dp array for the current stone and jump length, and the result is returned.\\n\\nThe canCross function initializes the dp array using memset and then calls the find function starting from the first stone with a jump length of 0. The overall result of whether the frog can cross the river is returned.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool find(vector<int> &stones, int i, int k){\\n      if(i==stones.size()-1)\\n          return true;\\n\\n      if(i>=stones.size()) \\n          return false;\\n\\n      if(dp[i][k]!=-1) \\n          return dp[i][k]; \\n\\n      bool res = false;\\n      for(int j=-1;j<=1;j++){\\n          int next_jump=k+j;\\n          if(next_jump>0){\\n                int in= lower_bound(stones.begin(),stones.end(),stones[i]+next_jump)-stones.begin();\\n                if(in == stones.size() || stones[in]!=stones[i]+next_jump) \\n                  continue;\\n\\n                res=res||find(stones,in,next_jump);\\n          }\\n      }\\n\\n      return dp[i][k]=res;\\n\\n  }\\n  \\n  bool canCross(vector<int>& stones) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(stones, 0, 0);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    bool find(vector<int> &stones, int i, int k){\\n      if(i==stones.size()-1)\\n          return true;\\n\\n      if(i>=stones.size()) \\n          return false;\\n\\n      if(dp[i][k]!=-1) \\n          return dp[i][k]; \\n\\n      bool res = false;\\n      for(int j=-1;j<=1;j++){\\n          int next_jump=k+j;\\n          if(next_jump>0){\\n                int in= lower_bound(stones.begin(),stones.end(),stones[i]+next_jump)-stones.begin();\\n                if(in == stones.size() || stones[in]!=stones[i]+next_jump) \\n                  continue;\\n\\n                res=res||find(stones,in,next_jump);\\n          }\\n      }\\n\\n      return dp[i][k]=res;\\n\\n  }\\n  \\n  bool canCross(vector<int>& stones) {\\n        memset(dp,-1,sizeof(dp));\\n        return find(stones, 0, 0);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968277,
                "title": "first-discussion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**O(**N*N**)**\\n\\n- Space complexity:\\n **O(N*N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int>mp;\\n    vector<int>s;\\n    vector<vector<int>>dp;\\n    bool fun(int ind,int k)\\n    {\\n        if(k<=0)return 0;\\n        if(ind==s.size()-1)return 1;\\n        if(!mp[s[ind]+k])return 0;\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        return dp[ind][k]=(fun(mp[s[ind]+k]-1,k)||fun(mp[s[ind]+k]-1,k-1)||fun(mp[s[ind]+k]-1,k+1));\\n    }\\n    bool canCross(vector<int>& stones) \\n    {\\n        dp.resize(2001,vector<int>(2001,-1));\\n        int n=stones.size();\\n        s=stones;\\n        for(int i=0;i<n;i++)mp[stones[i]]=i+1;\\n        return fun(0,1);    \\n    }\\n};\\n```\\n# **\"This is my first discussion on LeetCode. Let me know how to improve my explanation skills through LeetCode.\"**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>mp;\\n    vector<int>s;\\n    vector<vector<int>>dp;\\n    bool fun(int ind,int k)\\n    {\\n        if(k<=0)return 0;\\n        if(ind==s.size()-1)return 1;\\n        if(!mp[s[ind]+k])return 0;\\n        if(dp[ind][k]!=-1)return dp[ind][k];\\n        return dp[ind][k]=(fun(mp[s[ind]+k]-1,k)||fun(mp[s[ind]+k]-1,k-1)||fun(mp[s[ind]+k]-1,k+1));\\n    }\\n    bool canCross(vector<int>& stones) \\n    {\\n        dp.resize(2001,vector<int>(2001,-1));\\n        int n=stones.size();\\n        s=stones;\\n        for(int i=0;i<n;i++)mp[stones[i]]=i+1;\\n        return fun(0,1);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965676,
                "title": "simple-resurrsion-memoisation-c-beginner-friendly-solution-fast-than-80",
                "content": "# Code\\n\\n```\\n /*  recurrsion TLE\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& stones, int index, int jumpSize) {\\n        if (index == stones.size() - 1) {\\n            return true;\\n        }\\n\\n        for (int i = index + 1; i < stones.size(); ++i) \\n        {\\n            int gap = stones[i] - stones[index];\\n            if (gap >= jumpSize - 1 && gap <= jumpSize + 1) \\n            {\\n                if (solve(stones, i, gap)) {\\n                    return true;  \\n                }\\n            }\\n        }\\n\\n        return false; \\n    }\\n    bool canCross(vector<int>& stones) {\\n\\n        return solve(stones, 0, 0);\\n    }\\n\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& stones, int index, int jumpSize,vector<vector<int>> &dp) \\n    {\\n        if (index == stones.size() - 1) {\\n            return true;\\n        }\\n        if(dp[index][jumpSize]!=-1)\\n        return dp[index][jumpSize];\\n        for (int i = index + 1; i < stones.size(); ++i) \\n        {\\n            int gap = stones[i] - stones[index];\\n            if (gap >= jumpSize - 1 && gap <= jumpSize + 1) \\n            {\\n                if (solve(stones, i, gap,dp)) {\\n                    return dp[index][jumpSize]=true;  \\n                }\\n            }\\n        }\\n\\n        return dp[index][jumpSize]= false; \\n    }\\n    bool canCross(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size()+1,vector<int> (stones.size()+1,-1));\\n        return solve(stones, 0, 0 ,dp);\\n    }\\n\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n /*  recurrsion TLE\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& stones, int index, int jumpSize) {\\n        if (index == stones.size() - 1) {\\n            return true;\\n        }\\n\\n        for (int i = index + 1; i < stones.size(); ++i) \\n        {\\n            int gap = stones[i] - stones[index];\\n            if (gap >= jumpSize - 1 && gap <= jumpSize + 1) \\n            {\\n                if (solve(stones, i, gap)) {\\n                    return true;  \\n                }\\n            }\\n        }\\n\\n        return false; \\n    }\\n    bool canCross(vector<int>& stones) {\\n\\n        return solve(stones, 0, 0);\\n    }\\n\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& stones, int index, int jumpSize,vector<vector<int>> &dp) \\n    {\\n        if (index == stones.size() - 1) {\\n            return true;\\n        }\\n        if(dp[index][jumpSize]!=-1)\\n        return dp[index][jumpSize];\\n        for (int i = index + 1; i < stones.size(); ++i) \\n        {\\n            int gap = stones[i] - stones[index];\\n            if (gap >= jumpSize - 1 && gap <= jumpSize + 1) \\n            {\\n                if (solve(stones, i, gap,dp)) {\\n                    return dp[index][jumpSize]=true;  \\n                }\\n            }\\n        }\\n\\n        return dp[index][jumpSize]= false; \\n    }\\n    bool canCross(vector<int>& stones) {\\n        vector<vector<int>> dp(stones.size()+1,vector<int> (stones.size()+1,-1));\\n        return solve(stones, 0, 0 ,dp);\\n    }\\n\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964983,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} stones\\n * @return {boolean}\\n */\\nvar canCross = function(stones) {\\n    const n = stones.length;\\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(false));\\n    dp[0][0] = true; \\n    for (let i = 1; i < n; i++) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            const diff = stones[i] - stones[j];\\n            if (diff > j + 1) {\\n                break;\\n            }\\n            dp[i][diff] = dp[j][diff - 1] || dp[j][diff] || dp[j][diff + 1];\\n                if (i === n - 1 && dp[i][diff]) {\\n                    return true;\\n                }\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} stones\\n * @return {boolean}\\n */\\nvar canCross = function(stones) {\\n    const n = stones.length;\\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(false));\\n    dp[0][0] = true; \\n    for (let i = 1; i < n; i++) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            const diff = stones[i] - stones[j];\\n            if (diff > j + 1) {\\n                break;\\n            }\\n            dp[i][diff] = dp[j][diff - 1] || dp[j][diff] || dp[j][diff + 1];\\n                if (i === n - 1 && dp[i][diff]) {\\n                    return true;\\n                }\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964785,
                "title": "simple-brute-force-without-dp-that-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n**2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if not stones:\\n            return False\\n        n = len(stones)\\n        stack = [(0, 0)]\\n        visited = set()\\n        while stack:\\n            stone, jump = stack.pop()\\n            for j in [jump-1, jump, jump+1]:\\n                if j <= 0:\\n                    continue\\n                next_stone = stone + j\\n                if next_stone == stones[-1]:\\n                    return True\\n                if next_stone in stones:\\n                    if (next_stone, j) not in visited:\\n                        stack.append((next_stone, j))\\n                        visited.add((next_stone, j))\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if not stones:\\n            return False\\n        n = len(stones)\\n        stack = [(0, 0)]\\n        visited = set()\\n        while stack:\\n            stone, jump = stack.pop()\\n            for j in [jump-1, jump, jump+1]:\\n                if j <= 0:\\n                    continue\\n                next_stone = stone + j\\n                if next_stone == stones[-1]:\\n                    return True\\n                if next_stone in stones:\\n                    if (next_stone, j) not in visited:\\n                        stack.append((next_stone, j))\\n                        visited.add((next_stone, j))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964755,
                "title": "without-binary-search-using-map-set-simple-intution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:ta\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        // Creating haspmap for storing differnt positions where frog can go\\n        unordered_map<int,unordered_set<int>> mp;\\n        // Initialising map\\n        mp[stones[0]+1]={1};\\n        for(int i=1;i<stones.size();i++)\\n        {\\n            for(auto jump: mp[stones[i]])\\n            {\\n                // jump to k\\n                mp[stones[i]+jump].insert(jump);\\n                // jump to k-1\\n                mp[stones[i]+jump-1].insert(jump-1);\\n                // jump to k+1\\n                mp[stones[i]+jump+1].insert(jump+1);\\n            }\\n        }\\n        // checking and returning of last index whether frog reached or not\\n        return mp[stones[stones.size()-1]].size()!=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        // Creating haspmap for storing differnt positions where frog can go\\n        unordered_map<int,unordered_set<int>> mp;\\n        // Initialising map\\n        mp[stones[0]+1]={1};\\n        for(int i=1;i<stones.size();i++)\\n        {\\n            for(auto jump: mp[stones[i]])\\n            {\\n                // jump to k\\n                mp[stones[i]+jump].insert(jump);\\n                // jump to k-1\\n                mp[stones[i]+jump-1].insert(jump-1);\\n                // jump to k+1\\n                mp[stones[i]+jump+1].insert(jump+1);\\n            }\\n        }\\n        // checking and returning of last index whether frog reached or not\\n        return mp[stones[stones.size()-1]].size()!=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770565,
                "title": "solution-for-frog-jump-leetcode-problem-403",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWe use a HashMap to store the positions of the stones as keys and a HashSet as the corresponding value to store the possible jump lengths from that stone.\\nWe initialize the first stone with a jump length of 0 since the frog is already on the first stone.\\nWe iterate through each stone in the input array and for each stone, we iterate through the possible jump lengths stored in the HashSet for that stone.\\nFor each jump length, we check if the frog can jump to the next stones by looking for the presence of the next stone\\'s position in the HashMap.\\nIf the next stone\\'s position is found, we update its HashSet of jump lengths by adding the current jump length and its neighboring jump lengths (current length - 1, current length, current length + 1).\\nFinally, we check if the last stone\\'s HashSet of jump lengths is non-empty. If it is non-empty, it means the frog can reach the last stone, so we return true. Otherwise, we return false.\\nThe intuition of the approach is to build a map of stone positions and their corresponding possible jump lengths, and then iteratively update the jump lengths based on the available stones. By doing so, we keep track of the valid jump lengths at each stone position, allowing us to determine if the frog can reach the last stone.\\n\\nThe time complexity is quadratic because, in the worst case, for each stone, we iterate through all the possible jump lengths stored in the HashSet, resulting in O(n^2). The space complexity is linear, O(n), as we store the stone positions in a HashMap and the possible jump lengths in a HashSet for each stone.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a HashMap to store the positions of the stones as keys and a HashSet as the corresponding value to store the possible jump lengths from that stone.\\nInitialize the first stone\\'s position in the HashMap with a jump length of 0 since the frog is already on the first stone.\\nIterate through each stone in the input array.\\nFor each stone, iterate through the possible jump lengths stored in the HashSet for that stone.\\nFor each jump length, check if the frog can jump to the next stone by looking for the presence of the next stone\\'s position in the HashMap.\\nIf the next stone\\'s position is found in the HashMap, update its HashSet of jump lengths by adding the current jump length and its neighboring jump lengths (current length - 1, current length, current length + 1).\\nRepeat steps 4-6 until all stones have been processed.\\nAfter processing all stones, check if the last stone\\'s HashSet of jump lengths is non-empty.\\nIf the HashSet is non-empty, it means the frog can reach the last stone, so return true. Otherwise, return false.\\nThe idea behind this approach is to build a map of stone positions and their corresponding possible jump lengths. By iteratively updating the jump lengths at each stone based on the available stones, we can keep track of the valid jump lengths and determine if the frog can reach the last stone.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n^2), where n is the number of stones. This is because we have two nested loops. The outer loop iterates through each stone, and the inner loop iterates through each jump length in the set of the current stone. In the worst case, the inner loop can iterate up to n times, resulting in a quadratic time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) in the worst case. We are using a HashMap to store the positions of the stones, which requires O(n) space. Additionally, for each stone, we store a set of possible jump lengths. In the worst case, if each stone has all possible jump lengths, the total number of elements in all the sets would be O(n^2). However, since the maximum number of jump lengths is limited by the number of stones, the space complexity can be considered as O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) \\n    {\\n        HashMap<Integer,HashSet<Integer>> map=new HashMap();\\n        int n=stones.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(stones[i],new HashSet<Integer>());\\n        }\\n        map.get(stones[0]).add(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int stone=stones[i];\\n            HashSet<Integer> set=map.get(stone);\\n            for(int val:set)\\n            {\\n                if(val-1>0 && map.containsKey(stone+val-1))\\n                {\\n                    map.get(stone+val-1).add(val-1);\\n                }\\n                if (val>0 && map.containsKey(stone+val))\\n                {\\n                        map.get(stone+val).add(val);\\n                    \\n                }\\n                if(map.containsKey(stone+val+1))\\n                {\\n                        map.get(stone+val+1).add(val+1);\\n                }\\n            }\\n        }\\n        if(map.get(stones[n-1]).size()>0)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) \\n    {\\n        HashMap<Integer,HashSet<Integer>> map=new HashMap();\\n        int n=stones.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            map.put(stones[i],new HashSet<Integer>());\\n        }\\n        map.get(stones[0]).add(0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int stone=stones[i];\\n            HashSet<Integer> set=map.get(stone);\\n            for(int val:set)\\n            {\\n                if(val-1>0 && map.containsKey(stone+val-1))\\n                {\\n                    map.get(stone+val-1).add(val-1);\\n                }\\n                if (val>0 && map.containsKey(stone+val))\\n                {\\n                        map.get(stone+val).add(val);\\n                    \\n                }\\n                if(map.containsKey(stone+val+1))\\n                {\\n                        map.get(stone+val+1).add(val+1);\\n                }\\n            }\\n        }\\n        if(map.get(stones[n-1]).size()>0)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512836,
                "title": "easy-to-understand-c-90-beats-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck for every possible step from each stone , If <b>any of them</b> reaches last index return true , do memoization using map to avoid repeating sub-problems.\\nsmall trick - as map initializes any key with 0 add 1 while inserting and remove 1 while retrieving\\n\\n# Complexity\\n- Time complexity:  Less than O(3^N)\\nAs we are using Memoization\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(3xN) + O(N)\\nFor dp map and recursion auxillary stack space \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int pos(int ind,vector<int>&stones,int steps){\\n        for(int i=ind+1;i<stones.size();i++){\\n            if(stones[i]-stones[ind]==steps){\\n                return i;\\n            }\\n            if(stones[i]-stones[ind]>steps)return -1;\\n        }\\n        return -1;\\n    }\\n    bool solve(int ind,vector<int>&stones,int prev,map<pair<int,int>,int>&dp){\\n        if(ind>=stones.size()-1){\\n            if(ind==stones.size()-1){\\n                dp[{ind,prev}]=2;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[{ind,prev}]!=0)return dp[{ind,prev}]-1;\\n        int s1=prev-1,s2=prev,s3=prev+1;\\n        if(s1>0){\\n            int i=pos(ind,stones,s1);\\n            if(i!=-1){\\n                if(solve(i,stones,s1,dp)){\\n                    dp[{ind,prev}]=2;\\n                    return 1;\\n                }\\n            }\\n        }\\n        if(s2>0){\\n            int i=pos(ind,stones,s2);\\n            if(i!=-1){\\n                if(solve(i,stones,s2,dp)){\\n                    dp[{ind,prev}]=2;\\n                    return 1;\\n                }\\n            }\\n        }\\n        if(s3>0){\\n            int i=pos(ind,stones,s3);\\n            if(i!=-1){\\n                if(solve(i,stones,s3,dp)){\\n                    dp[{ind,prev}]=2;\\n                    return 1;\\n                }\\n            }\\n        }\\n        dp[{ind,prev}]=1;\\n        return 0;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        map<pair<int,int>,int>dp;\\n        return solve(0,stones,0,dp);\\n    }\\n};\\n```\\n:D ThankYou",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int pos(int ind,vector<int>&stones,int steps){\\n        for(int i=ind+1;i<stones.size();i++){\\n            if(stones[i]-stones[ind]==steps){\\n                return i;\\n            }\\n            if(stones[i]-stones[ind]>steps)return -1;\\n        }\\n        return -1;\\n    }\\n    bool solve(int ind,vector<int>&stones,int prev,map<pair<int,int>,int>&dp){\\n        if(ind>=stones.size()-1){\\n            if(ind==stones.size()-1){\\n                dp[{ind,prev}]=2;\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        if(dp[{ind,prev}]!=0)return dp[{ind,prev}]-1;\\n        int s1=prev-1,s2=prev,s3=prev+1;\\n        if(s1>0){\\n            int i=pos(ind,stones,s1);\\n            if(i!=-1){\\n                if(solve(i,stones,s1,dp)){\\n                    dp[{ind,prev}]=2;\\n                    return 1;\\n                }\\n            }\\n        }\\n        if(s2>0){\\n            int i=pos(ind,stones,s2);\\n            if(i!=-1){\\n                if(solve(i,stones,s2,dp)){\\n                    dp[{ind,prev}]=2;\\n                    return 1;\\n                }\\n            }\\n        }\\n        if(s3>0){\\n            int i=pos(ind,stones,s3);\\n            if(i!=-1){\\n                if(solve(i,stones,s3,dp)){\\n                    dp[{ind,prev}]=2;\\n                    return 1;\\n                }\\n            }\\n        }\\n        dp[{ind,prev}]=1;\\n        return 0;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        map<pair<int,int>,int>dp;\\n        return solve(0,stones,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602868,
                "title": "c-dp-faster-than-100-memoization",
                "content": "\\n\\n```cpp\\n#include<bits/stdc++.h>\\nstruct hashFunction\\n{\\n  size_t operator()(const pair<int , \\n                    int> &x) const\\n  {\\n    return x.first ^ x.second;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    bool helper(int currJump , int currStone, unordered_set<pair<int, int>,hashFunction>& dp , unordered_set<int>&elements , int ans ){\\n\\n        if(currStone == ans) return true;\\n        if(currJump==0)return false;\\n        if(elements.find(currStone) == elements.end()) return false;\\n        if(dp.find({currStone , currJump}) != dp.end()) return false;\\n        if(helper(currJump+1 , currStone+currJump+1 , dp , elements , ans)) return true;\\n        if(helper(currJump-1 , currStone+currJump-1 , dp , elements , ans)) return true;\\n        if(helper(currJump , currStone+currJump , dp , elements , ans)) return true;\\n        dp.insert({currStone , currJump});\\n        return false;\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] != 1) return false;\\n          unordered_set<pair<int, int>,hashFunction> dp;\\n        unordered_set<int> elements;\\n        for(auto a : stones)elements.insert(a);\\n\\n        return helper(1 , 1 , dp , elements, stones[stones.size()-1]);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization",
                    "Ordered Set"
                ],
                "code": "```cpp\\n#include<bits/stdc++.h>\\nstruct hashFunction\\n{\\n  size_t operator()(const pair<int , \\n                    int> &x) const\\n  {\\n    return x.first ^ x.second;\\n  }\\n};\\n\\nclass Solution {\\npublic:\\n    bool helper(int currJump , int currStone, unordered_set<pair<int, int>,hashFunction>& dp , unordered_set<int>&elements , int ans ){\\n\\n        if(currStone == ans) return true;\\n        if(currJump==0)return false;\\n        if(elements.find(currStone) == elements.end()) return false;\\n        if(dp.find({currStone , currJump}) != dp.end()) return false;\\n        if(helper(currJump+1 , currStone+currJump+1 , dp , elements , ans)) return true;\\n        if(helper(currJump-1 , currStone+currJump-1 , dp , elements , ans)) return true;\\n        if(helper(currJump , currStone+currJump , dp , elements , ans)) return true;\\n        dp.insert({currStone , currJump});\\n        return false;\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] != 1) return false;\\n          unordered_set<pair<int, int>,hashFunction> dp;\\n        unordered_set<int> elements;\\n        for(auto a : stones)elements.insert(a);\\n\\n        return helper(1 , 1 , dp , elements, stones[stones.size()-1]);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2440933,
                "title": "c-hashmap-easy-solution",
                "content": "\\n**Approach**\\n\\n1. Make a hashmap of each stone, which would contain a set. That set would store the viable jump sizes that could be used to reach at that stone. E.g.: Initially 2nd stone, it would be 1 only.\\n2. Initially setting 1 jump for stone[0], since we can jump only 1 unit at first.\\n3. Traverse the stone array from 0th index (1st stone). That can be the next position of frog.\\n4. Populate the sets of stones that can be reached from current position using a viable jump size (that is k - 1 or k or k + 1). Next Viable jump size can be calculated from previous jump size, and this previous jump size would be found in set of current position.\\n5. Return true if we reaches to the last stone, that means we can reach to the destinition, otherwise false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) \\n    {\\n        map<int, set<int>>mp;\\n        \\n        for(int i = 0 ; i<stones.size() ; i++)\\n        {\\n            mp[stones[i]] = {};  //Initially providing empty set (no jumps).\\n        }\\n        \\n        mp[stones[0]].insert(1) ;  //Initially we can take only 1 unit of jump to reach at next stone.\\n       \\n        \\n        for(int i = 0 ; i<stones.size() ; i++)\\n        {\\n            int currentStone = stones[i] ; \\n            set<int>jumps = mp[currentStone];\\n            for(auto j : jumps)\\n            {\\n                \\n                int pos = j + currentStone ; \\n                \\n                if(pos == stones[stones.size() - 1])    //let\\'s check if we have reached to the last stone or not if yes then congratulations return true.\\n                {\\n                    return true;\\n                }\\n                else if(mp.find(pos) != mp.end())    //think if the taken jump allow us to stand at the next stone if yes then do set the jumps to travel for next stone.\\n                {\\n                    if(j - 1 > 0)\\n                    {\\n                        mp[pos].insert(j-1);\\n                    }\\n                    mp[pos].insert(j);\\n                    mp[pos].insert(j+1);\\n                }\\n            }\\n        }\\n        \\n        return false;    //return false if we haven\\'t reached to the last stone.\\n    }\\n};\\n```\\n\\n**If you understood the approach then please do upvote!!\\nHappy learning! \\u2764\\uFE0F\\uD83D\\uDE01**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) \\n    {\\n        map<int, set<int>>mp;\\n        \\n        for(int i = 0 ; i<stones.size() ; i++)\\n        {\\n            mp[stones[i]] = {};  //Initially providing empty set (no jumps).\\n        }\\n        \\n        mp[stones[0]].insert(1) ;  //Initially we can take only 1 unit of jump to reach at next stone.\\n       \\n        \\n        for(int i = 0 ; i<stones.size() ; i++)\\n        {\\n            int currentStone = stones[i] ; \\n            set<int>jumps = mp[currentStone];\\n            for(auto j : jumps)\\n            {\\n                \\n                int pos = j + currentStone ; \\n                \\n                if(pos == stones[stones.size() - 1])    //let\\'s check if we have reached to the last stone or not if yes then congratulations return true.\\n                {\\n                    return true;\\n                }\\n                else if(mp.find(pos) != mp.end())    //think if the taken jump allow us to stand at the next stone if yes then do set the jumps to travel for next stone.\\n                {\\n                    if(j - 1 > 0)\\n                    {\\n                        mp[pos].insert(j-1);\\n                    }\\n                    mp[pos].insert(j);\\n                    mp[pos].insert(j+1);\\n                }\\n            }\\n        }\\n        \\n        return false;    //return false if we haven\\'t reached to the last stone.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305797,
                "title": "c-easy-explanation-hashmap-dp",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    unordered_map<int, int> h;\\n    bool solve(vector<int> &stones, int stoneIndex, int k) {\\n        int n = stones.size();\\n        // case where frog reaches the last stoneIndex\\n        if (stoneIndex == n - 1) return true;\\n\\n        // cases where frog jumps out of boundary\\n        if (stoneIndex >= n) return false;\\n\\n        // cases that we have already visited\\n        if (dp[stoneIndex][k] != -1) return dp[stoneIndex][k];\\n\\n        // curr stone position\\n        int currStone = stones[stoneIndex];\\n\\n        // from here we can go either jump k, k-1 or k+1 unit\\n        bool ans = false;\\n        for (int step = -1; step <= 1; step++) {\\n            int nextJump = k + step;\\n            if (nextJump > 0) {\\n                // next stone where we may jump\\n                int nextStone = currStone + nextJump;\\n                // checking whether the position or stone exist in the array or not\\n                if (h.count(nextStone) != 0) {\\n                    // next stone index\\n                    int nextJumpIndex = h[nextStone];\\n\\n                    // now jumping to the next stone\\n                    ans = ans || solve(stones, nextJumpIndex, nextJump);\\n                }\\n            }\\n        }\\n        dp[stoneIndex][k] = ans;\\n        return ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        for (int i = 0; i < stones.size(); i++) {\\n            h.insert({stones[i], i});\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(stones, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int dp[2001][2001];\\n    unordered_map<int, int> h;\\n    bool solve(vector<int> &stones, int stoneIndex, int k) {\\n        int n = stones.size();\\n        // case where frog reaches the last stoneIndex\\n        if (stoneIndex == n - 1) return true;\\n\\n        // cases where frog jumps out of boundary\\n        if (stoneIndex >= n) return false;\\n\\n        // cases that we have already visited\\n        if (dp[stoneIndex][k] != -1) return dp[stoneIndex][k];\\n\\n        // curr stone position\\n        int currStone = stones[stoneIndex];\\n\\n        // from here we can go either jump k, k-1 or k+1 unit\\n        bool ans = false;\\n        for (int step = -1; step <= 1; step++) {\\n            int nextJump = k + step;\\n            if (nextJump > 0) {\\n                // next stone where we may jump\\n                int nextStone = currStone + nextJump;\\n                // checking whether the position or stone exist in the array or not\\n                if (h.count(nextStone) != 0) {\\n                    // next stone index\\n                    int nextJumpIndex = h[nextStone];\\n\\n                    // now jumping to the next stone\\n                    ans = ans || solve(stones, nextJumpIndex, nextJump);\\n                }\\n            }\\n        }\\n        dp[stoneIndex][k] = ans;\\n        return ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        for (int i = 0; i < stones.size(); i++) {\\n            h.insert({stones[i], i});\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(stones, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305163,
                "title": "c-simple-c-code-89-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    bool dfs(vector<int>& stones, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i == stones.size()-1)\\n            return true;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        bool val = false;\\n        if(i == 0)\\n        {\\n            if(um.count(stones[i]+k+1))\\n            {\\n                val = val || dfs(stones, um[stones[i]+k+1], k+1, dp);\\n            }\\n        }\\n        else\\n        {\\n            if(um.count(stones[i]+k))\\n            {\\n                val = val || dfs(stones, um[stones[i]+k], k, dp);\\n            }\\n            if(um.count(stones[i]+k+1))\\n            {\\n                val = val || dfs(stones, um[stones[i]+k+1], k+1, dp);\\n            }\\n            if(um.count(stones[i]+k-1) && um[stones[i]+k-1] > i)\\n            {\\n                val = val || dfs(stones, um[stones[i]+k-1], k-1, dp);\\n            }   \\n        }\\n        return dp[i][k] = val;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        for(int i = 0; i < n; i++)\\n            um[stones[i]] = i;\\n        return dfs(stones, 0, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> um;\\n    bool dfs(vector<int>& stones, int i, int k, vector<vector<int>> &dp)\\n    {\\n        if(i == stones.size()-1)\\n            return true;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        bool val = false;\\n        if(i == 0)\\n        {\\n            if(um.count(stones[i]+k+1))\\n            {\\n                val = val || dfs(stones, um[stones[i]+k+1], k+1, dp);\\n            }\\n        }\\n        else\\n        {\\n            if(um.count(stones[i]+k))\\n            {\\n                val = val || dfs(stones, um[stones[i]+k], k, dp);\\n            }\\n            if(um.count(stones[i]+k+1))\\n            {\\n                val = val || dfs(stones, um[stones[i]+k+1], k+1, dp);\\n            }\\n            if(um.count(stones[i]+k-1) && um[stones[i]+k-1] > i)\\n            {\\n                val = val || dfs(stones, um[stones[i]+k-1], k-1, dp);\\n            }   \\n        }\\n        return dp[i][k] = val;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        vector<vector<int>> dp(n, vector<int> (n, -1));\\n        for(int i = 0; i < n; i++)\\n            um[stones[i]] = i;\\n        return dfs(stones, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258853,
                "title": "c-dp-using-map-and-set-easy-to-understand-commented-code",
                "content": "Explanation is in the code .\\n```\\n bool canCross(vector<int>& stones) {\\n        \\n        // the basic logic here is that we will create a map of stones location and the different number of jumps\\n        // by which we reached that ith stone.\\n        // now those jump will be used to calculte the place we can reach from that ith stone\\n        int i,n=stones.size(),x,jump,j1,j2,j3,y1,y2,y3;\\n        unordered_map<int,set<int> > m;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==0)\\n            {\\n                m[stones[i]].insert(0);\\n                \\n            }\\n            else{\\n                m[stones[i]];\\n            }\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            x = stones[i];                      //current stone \\n            if(i==0)\\n            { \\n                j3 = 1;                         //at first base case only a jump of 1 is possible;\\n                y3 = x + j3;                    //position after jump\\n                if(m.find(y3)!=m.end())         //check if that position is a stone or not\\n                {\\n                    m[stones[y3]].insert(j3);   //If yes then insert the j3 jump in position y3 for future jumps\\n                                                // from that location\\n                }\\n                continue;\\n            }\\n            for(auto j=m[stones[i]].begin();j!=m[stones[i]].end();j++) //we will iterate through all the jumps we cando\\n            {\\n                jump = *j;\\n                j1 = jump - 1;    //we can jump previous jump -1\\n                j2 = jump ;       //we can jump previous jump \\n                j3 = jump + 1;    //we can jump previous jump +1\\n                y1 = x + j1;      //position to which we will jump after j1 jump\\n                y2 = x + j2;      //position to which we will jump after j2 jump\\n                y3 = x + j3;      //position to which we will jump after j3 jump\\n                \\n                \\n                if(m.find(y1)!=m.end() && j1>0)   //we will check if y1 position is a stone or not & make sure j1>0 \\n                {                                 // to avoid any infinite loop because if j1==0 it will keep on jumping \\n                    m[y1].insert(j1);             // to its current position only.\\n                                                  //if y1 is a stone we will store this j1 jump in it for future jumps;\\n                }\\n                \\n                if(m.find(y2)!=m.end() && j2>0)  //we will check if y2 position is a stone or not & make sure j2>0 \\n                {                                // to avoid any infinite loop because if j1==0 it will keep on jumping\\n                    m[y2].insert(j2);            // to its current position only.\\n                }                                //if y1 is a stone we will store this j1 jump in it for future jumps;\\n                \\n                \\n                if(m.find(y3)!=m.end() && j3>0)  //similary logic for j3 :) \\n                {\\n                    m[y3].insert(j3);\\n                }\\n                  \\n            }\\n        }\\n        if(m[stones[n-1]].size()>0)  //check if the size of set m[stones[n-1]]>0 \\n        {\\n            return 1;                // if it is true that means there is 1 or more than 1 jumps by which we can\\n                                     // reach there.\\n        }\\n        else{\\n            return 0;                //else we cant reach\\n        }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Ordered Set"
                ],
                "code": "Explanation is in the code .\\n```\\n bool canCross(vector<int>& stones) {\\n        \\n        // the basic logic here is that we will create a map of stones location and the different number of jumps\\n        // by which we reached that ith stone.\\n        // now those jump will be used to calculte the place we can reach from that ith stone\\n        int i,n=stones.size(),x,jump,j1,j2,j3,y1,y2,y3;\\n        unordered_map<int,set<int> > m;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==0)\\n            {\\n                m[stones[i]].insert(0);\\n                \\n            }\\n            else{\\n                m[stones[i]];\\n            }\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            x = stones[i];                      //current stone \\n            if(i==0)\\n            { \\n                j3 = 1;                         //at first base case only a jump of 1 is possible;\\n                y3 = x + j3;                    //position after jump\\n                if(m.find(y3)!=m.end())         //check if that position is a stone or not\\n                {\\n                    m[stones[y3]].insert(j3);   //If yes then insert the j3 jump in position y3 for future jumps\\n                                                // from that location\\n                }\\n                continue;\\n            }\\n            for(auto j=m[stones[i]].begin();j!=m[stones[i]].end();j++) //we will iterate through all the jumps we cando\\n            {\\n                jump = *j;\\n                j1 = jump - 1;    //we can jump previous jump -1\\n                j2 = jump ;       //we can jump previous jump \\n                j3 = jump + 1;    //we can jump previous jump +1\\n                y1 = x + j1;      //position to which we will jump after j1 jump\\n                y2 = x + j2;      //position to which we will jump after j2 jump\\n                y3 = x + j3;      //position to which we will jump after j3 jump\\n                \\n                \\n                if(m.find(y1)!=m.end() && j1>0)   //we will check if y1 position is a stone or not & make sure j1>0 \\n                {                                 // to avoid any infinite loop because if j1==0 it will keep on jumping \\n                    m[y1].insert(j1);             // to its current position only.\\n                                                  //if y1 is a stone we will store this j1 jump in it for future jumps;\\n                }\\n                \\n                if(m.find(y2)!=m.end() && j2>0)  //we will check if y2 position is a stone or not & make sure j2>0 \\n                {                                // to avoid any infinite loop because if j1==0 it will keep on jumping\\n                    m[y2].insert(j2);            // to its current position only.\\n                }                                //if y1 is a stone we will store this j1 jump in it for future jumps;\\n                \\n                \\n                if(m.find(y3)!=m.end() && j3>0)  //similary logic for j3 :) \\n                {\\n                    m[y3].insert(j3);\\n                }\\n                  \\n            }\\n        }\\n        if(m[stones[n-1]].size()>0)  //check if the size of set m[stones[n-1]]>0 \\n        {\\n            return 1;                // if it is true that means there is 1 or more than 1 jumps by which we can\\n                                     // reach there.\\n        }\\n        else{\\n            return 0;                //else we cant reach\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1798336,
                "title": "java-o-n-k-memoization-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        return frogJump(stones, 0, 0, stones[0], new Boolean[stones.length][stones.length - 1]);\\n    }\\n    \\n    private boolean frogJump(int[] arr, int index, int curr, int k, Boolean[][] dp) {\\n\\t   // Catching up with the expected stone (arr[i])\\n\\t   // If the current position is ahead of the position on the current index stone (arr[i]), increment the index\\n        while(index < arr.length && curr > arr[index]) {\\n            index++;   \\n        }\\n        if(curr == arr[arr.length - 1]) return true;\\n        else if(index >= arr.length || curr != arr[index]) return false;       \\n        \\n        if(dp[index][k] != null) return dp[index][k];\\n        \\n\\t\\t// All three possibilities\\n        return dp[index][k] = frogJump(arr, index + 1, curr + k + 1, k + 1, dp) ||\\n               frogJump(arr, index + 1, curr + k, k, dp) ||\\n               frogJump(arr, index + 1, curr + k - 1, k - 1, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        return frogJump(stones, 0, 0, stones[0], new Boolean[stones.length][stones.length - 1]);\\n    }\\n    \\n    private boolean frogJump(int[] arr, int index, int curr, int k, Boolean[][] dp) {\\n\\t   // Catching up with the expected stone (arr[i])\\n\\t   // If the current position is ahead of the position on the current index stone (arr[i]), increment the index\\n        while(index < arr.length && curr > arr[index]) {\\n            index++;   \\n        }\\n        if(curr == arr[arr.length - 1]) return true;\\n        else if(index >= arr.length || curr != arr[index]) return false;       \\n        \\n        if(dp[index][k] != null) return dp[index][k];\\n        \\n\\t\\t// All three possibilities\\n        return dp[index][k] = frogJump(arr, index + 1, curr + k + 1, k + 1, dp) ||\\n               frogJump(arr, index + 1, curr + k, k, dp) ||\\n               frogJump(arr, index + 1, curr + k - 1, k - 1, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649472,
                "title": "java-dfs-dp-memoization-easy-to-undestand",
                "content": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        // If the difference of the first 2 stones are not 1 then we return false;\\n        if(stones[1] - stones[0] > 1)\\n            return false;\\n        \\n        // We store all the stone positions in a Set\\n        Set<Integer> positions = new HashSet<>();\\n        for(int stone : stones)\\n            positions.add(stone);\\n        \\n        // We explore all the possible paths\\n        return canCross(stones, positions, new HashMap<>(), stones[1], 1);\\n    }\\n    \\n    boolean canCross(int[] stones, Set<Integer> positions, Map<String, Boolean> dp, int currPos, int jump){\\n        \\n        // If we have reached the last stone return true\\n        int lastStone = stones[stones.length - 1];        \\n        if(currPos == lastStone)\\n            return true;\\n        \\n        // If we have landed at a position which is not there in the original list then return false\\n        if(!positions.contains(currPos))\\n            return false;\\n        \\n        // Else we have landed in a position which is there in the stones[] and we would want to check\\n        // if we have already explored this path with the current jump\\n        String key = new StringBuilder()\\n            .append(currPos)\\n            .append(\"-\")\\n            .append(jump)\\n            .toString();\\n        \\n        // If this is the first time we are exploring then we explore the all the possible paths\\n        if(!dp.containsKey(key)) {\\n            // With jump = k\\n            if(canCross(stones, positions, dp, currPos + jump, jump))\\n                dp.put(key, true);\\n            // With jump = k - 1, only if jump > 1\\n            else if(jump > 1 && canCross(stones, positions, dp, currPos + jump-1, jump-1))\\n                dp.put(key, true);\\n            // With jump = k + 1\\n            else\\n                dp.put(key, canCross(stones, positions, dp, currPos + jump+1, jump+1));\\n        }\\n        return dp.get(key);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        // If the difference of the first 2 stones are not 1 then we return false;\\n        if(stones[1] - stones[0] > 1)\\n            return false;\\n        \\n        // We store all the stone positions in a Set\\n        Set<Integer> positions = new HashSet<>();\\n        for(int stone : stones)\\n            positions.add(stone);\\n        \\n        // We explore all the possible paths\\n        return canCross(stones, positions, new HashMap<>(), stones[1], 1);\\n    }\\n    \\n    boolean canCross(int[] stones, Set<Integer> positions, Map<String, Boolean> dp, int currPos, int jump){\\n        \\n        // If we have reached the last stone return true\\n        int lastStone = stones[stones.length - 1];        \\n        if(currPos == lastStone)\\n            return true;\\n        \\n        // If we have landed at a position which is not there in the original list then return false\\n        if(!positions.contains(currPos))\\n            return false;\\n        \\n        // Else we have landed in a position which is there in the stones[] and we would want to check\\n        // if we have already explored this path with the current jump\\n        String key = new StringBuilder()\\n            .append(currPos)\\n            .append(\"-\")\\n            .append(jump)\\n            .toString();\\n        \\n        // If this is the first time we are exploring then we explore the all the possible paths\\n        if(!dp.containsKey(key)) {\\n            // With jump = k\\n            if(canCross(stones, positions, dp, currPos + jump, jump))\\n                dp.put(key, true);\\n            // With jump = k - 1, only if jump > 1\\n            else if(jump > 1 && canCross(stones, positions, dp, currPos + jump-1, jump-1))\\n                dp.put(key, true);\\n            // With jump = k + 1\\n            else\\n                dp.put(key, canCross(stones, positions, dp, currPos + jump+1, jump+1));\\n        }\\n        return dp.get(key);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1547585,
                "title": "easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map<int, set<int>> mp;\\n        mp[1].insert(1);\\n        \\n        for(int i = 1; i < n - 1; i++) {\\n            for(auto &jump : mp[stones[i]]) {\\n                mp[stones[i] + jump].insert(jump);\\n                mp[stones[i] + jump - 1].insert(jump - 1);\\n                mp[stones[i] + jump + 1].insert(jump + 1);\\n            }\\n        }\\n        \\n        return !mp[stones[n - 1]].empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map<int, set<int>> mp;\\n        mp[1].insert(1);\\n        \\n        for(int i = 1; i < n - 1; i++) {\\n            for(auto &jump : mp[stones[i]]) {\\n                mp[stones[i] + jump].insert(jump);\\n                mp[stones[i] + jump - 1].insert(jump - 1);\\n                mp[stones[i] + jump + 1].insert(jump + 1);\\n            }\\n        }\\n        \\n        return !mp[stones[n - 1]].empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1098909,
                "title": "dp-c-easy-algorithm-description",
                "content": "```\\n// APPROACH\\n//      core concept here is using DP and unordered_map+unordered_set.\\n//      Given this input: \\n//      [0,1,3,5,6,8,12,17]\\n//      at the end, the map will be populated as:\\n//      {0: [0]}\\n//      {1: [1]}    1+1 (1 current position, 1 because k); 1+2 (1 current position, 2 because k+1)\\n//                  1+1 = 2 we put at the key = 2 the step 1.\\n//                  1+2 = 3 we put at the key = 3 the step 2.\\n//      {3: [1]}    3+1; 3+2\\n//      {5: [2]}    5+1; 5+2; 5+3\\n//      {6: [1]}    6+1; 6+2\\n//      {8: [3, 2]} 8+2; 8+3; 8+4 - 8+1; 8+2; 8+3\\n//      {12: [4]}   12+3; 12+4; 12+5\\n//      {17: [5]}\\n//      we are able to reach the last stone in 5 jump!\\n\\n//      Remember: at eack i-th we can jump forward of k-1; k or k+1 where \\n//      k is the previous jump.\\n\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int, unordered_set<int>> jumpsMap;\\n        for (auto s: stones)\\n            jumpsMap[s] = {};\\n\\n        jumpsMap[0].insert(0);\\n\\n        for (int i = 0; i < stones.size(); ++i) {\\n            for (auto k: jumpsMap[stones[i]]) {\\n                for (int step = k - 1; step <= k + 1; ++step) {\\n                    auto it = jumpsMap.find(stones[i] + step);\\n                    if (step > 0 && it != jumpsMap.end())\\n                        jumpsMap[stones[i] + step].insert(step);\\n                }\\n            }\\n        }\\n        return didWeGetToTheLastStone (jumpsMap, stones);\\n    }\\n\\nprivate:\\n    bool didWeGetToTheLastStone(unordered_map<int, unordered_set<int>>& jumpsMap, vector<int>& stones) {\\n        // if the last item is not empty means we were able to get to the last stone.\\n        return jumpsMap[stones[stones.size() - 1]].size() > 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n// APPROACH\\n//      core concept here is using DP and unordered_map+unordered_set.\\n//      Given this input: \\n//      [0,1,3,5,6,8,12,17]\\n//      at the end, the map will be populated as:\\n//      {0: [0]}\\n//      {1: [1]}    1+1 (1 current position, 1 because k); 1+2 (1 current position, 2 because k+1)\\n//                  1+1 = 2 we put at the key = 2 the step 1.\\n//                  1+2 = 3 we put at the key = 3 the step 2.\\n//      {3: [1]}    3+1; 3+2\\n//      {5: [2]}    5+1; 5+2; 5+3\\n//      {6: [1]}    6+1; 6+2\\n//      {8: [3, 2]} 8+2; 8+3; 8+4 - 8+1; 8+2; 8+3\\n//      {12: [4]}   12+3; 12+4; 12+5\\n//      {17: [5]}\\n//      we are able to reach the last stone in 5 jump!\\n\\n//      Remember: at eack i-th we can jump forward of k-1; k or k+1 where \\n//      k is the previous jump.\\n\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        unordered_map<int, unordered_set<int>> jumpsMap;\\n        for (auto s: stones)\\n            jumpsMap[s] = {};\\n\\n        jumpsMap[0].insert(0);\\n\\n        for (int i = 0; i < stones.size(); ++i) {\\n            for (auto k: jumpsMap[stones[i]]) {\\n                for (int step = k - 1; step <= k + 1; ++step) {\\n                    auto it = jumpsMap.find(stones[i] + step);\\n                    if (step > 0 && it != jumpsMap.end())\\n                        jumpsMap[stones[i] + step].insert(step);\\n                }\\n            }\\n        }\\n        return didWeGetToTheLastStone (jumpsMap, stones);\\n    }\\n\\nprivate:\\n    bool didWeGetToTheLastStone(unordered_map<int, unordered_set<int>>& jumpsMap, vector<int>& stones) {\\n        // if the last item is not empty means we were able to get to the last stone.\\n        return jumpsMap[stones[stones.size() - 1]].size() > 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801493,
                "title": "python3-recursion-with-memo-beats-87-need-help",
                "content": "Hello, \\n\\nThis is my python solution for the problem. \\nCould some one explain me the time complexity I am very confused.\\n\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        \\n        # will store valid stone positions\\n        stoneSet = set(stones)\\n        \\n        # will store (stone, jumpsize) which will not lead to the last stone\\n        stoneReach = set()\\n        \\n        # set target\\n        self.last = stones[-1]\\n        # stoneReach[self.last] = True\\n        \\n        def help(curStone, lastJump):\\n            \\n            #check if target\\n            if curStone==self.last:\\n                return True\\n            \\n            #check if valid stone\\n            if curStone not in stoneSet:\\n                return False\\n            \\n            # for all possible jumps\\n            for jump in (lastJump-1, lastJump, lastJump+1):\\n                \\n                nextStone = curStone+jump\\n                # if jumpsize>0 and if (stone, jumpsize) already encounterd \\n                # and does not lead to target\\n                if jump and (nextStone, jump) not in stoneReach:    \\n                    if self.last==nextStone:\\n                        return True\\n                    else:\\n                        if help(nextStone, jump):\\n                            return True\\n                        # add (stone, jumpsize) if the function returns False\\n                        stoneReach.add((nextStone, jump))                \\n            return False\\n                        \\n        # Check if stone at position 1\\n        if 1 not in stoneSet:\\n            return False\\n        \\n        return help(1, 1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        \\n        # will store valid stone positions\\n        stoneSet = set(stones)\\n        \\n        # will store (stone, jumpsize) which will not lead to the last stone\\n        stoneReach = set()\\n        \\n        # set target\\n        self.last = stones[-1]\\n        # stoneReach[self.last] = True\\n        \\n        def help(curStone, lastJump):\\n            \\n            #check if target\\n            if curStone==self.last:\\n                return True\\n            \\n            #check if valid stone\\n            if curStone not in stoneSet:\\n                return False\\n            \\n            # for all possible jumps\\n            for jump in (lastJump-1, lastJump, lastJump+1):\\n                \\n                nextStone = curStone+jump\\n                # if jumpsize>0 and if (stone, jumpsize) already encounterd \\n                # and does not lead to target\\n                if jump and (nextStone, jump) not in stoneReach:    \\n                    if self.last==nextStone:\\n                        return True\\n                    else:\\n                        if help(nextStone, jump):\\n                            return True\\n                        # add (stone, jumpsize) if the function returns False\\n                        stoneReach.add((nextStone, jump))                \\n            return False\\n                        \\n        # Check if stone at position 1\\n        if 1 not in stoneSet:\\n            return False\\n        \\n        return help(1, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692925,
                "title": "swift-bfs",
                "content": "```\\nfunc canCross(_ stones: [Int]) -> Bool {\\n        var queue = [[Int]]()  \\n        var visited = Set<[Int]>()\\n        var set = Set<Int>(stones)\\n        queue.append([0, 0])\\n        visited.insert([0, 0])\\n        while queue.count > 0 {\\n            var cur = queue.removeFirst()\\n            var position = cur[0]\\n            var lastJump = cur[1]\\n            \\n            if position == stones[stones.count - 1] {\\n                return true\\n            }\\n            \\n            for i in lastJump-1...lastJump+1 {\\n                if i < 0 {\\n                    continue\\n                }\\n                var right = position + i\\n                if set.contains(right) && !visited.contains([right, i]) {\\n                    queue.append([right, i])\\n                    visited.insert([right, i])\\n                }\\n                \\n            }\\n        }\\n        return false\\n    }",
                "solutionTags": [],
                "code": "```\\nfunc canCross(_ stones: [Int]) -> Bool {\\n        var queue = [[Int]]()  \\n        var visited = Set<[Int]>()\\n        var set = Set<Int>(stones)\\n        queue.append([0, 0])\\n        visited.insert([0, 0])\\n        while queue.count > 0 {\\n            var cur = queue.removeFirst()\\n            var position = cur[0]\\n            var lastJump = cur[1]\\n            \\n            if position == stones[stones.count - 1] {\\n                return true\\n            }\\n            \\n            for i in lastJump-1...lastJump+1 {\\n                if i < 0 {\\n                    continue\\n                }\\n                var right = position + i\\n                if set.contains(right) && !visited.contains([right, i]) {\\n                    queue.append([right, i])\\n                    visited.insert([right, i])\\n                }\\n                \\n            }\\n        }\\n        return false\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 422378,
                "title": "python-dynamic-programming",
                "content": "```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # DP dynamic programming, DP table pi = dict()\\n        # pi[i] = {distance of last jump when frog at stone pos i}\\n        # Let n be the input size (size of stones)\\n        # T(n) = O(n^2)\\n        # S(n) = O(n^2)\\n\\n\\n        # init data struct\\n        # Time: O(n)\\n        pi = dict()\\n        for stone in stones:\\n            pi[stone] = set()\\n        \\n        # init state\\n        # Time: O(1)\\n        pi[0].add(0)\\n        \\n        # fill DP table pi\\n        # Time: O(n) * O(n) * O(1) = O(n^2)\\n        for stone in stones:\\n            for k in pi[stone]:\\n                for jump in [k-1, k, k+1]:\\n                    if jump > 0 and stone + jump in pi:\\n                        pi[stone+jump].add(jump)\\n        \\n        # return bool result\\n        return len(pi[stones[-1]]) > 0\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # DP dynamic programming, DP table pi = dict()\\n        # pi[i] = {distance of last jump when frog at stone pos i}\\n        # Let n be the input size (size of stones)\\n        # T(n) = O(n^2)\\n        # S(n) = O(n^2)\\n\\n\\n        # init data struct\\n        # Time: O(n)\\n        pi = dict()\\n        for stone in stones:\\n            pi[stone] = set()\\n        \\n        # init state\\n        # Time: O(1)\\n        pi[0].add(0)\\n        \\n        # fill DP table pi\\n        # Time: O(n) * O(n) * O(1) = O(n^2)\\n        for stone in stones:\\n            for k in pi[stone]:\\n                for jump in [k-1, k, k+1]:\\n                    if jump > 0 and stone + jump in pi:\\n                        pi[stone+jump].add(jump)\\n        \\n        # return bool result\\n        return len(pi[stones[-1]]) > 0\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 186994,
                "title": "memo-recursion-python-java",
                "content": "Java Version:\\n\\n```\\npublic class Solution {\\n    public boolean canCross(int[] stones) {\\n\\n        Set<Integer> stoneSet = new HashSet<>();\\n        for (int i = 0; i < stones.length; i++) {\\n            stoneSet.add(stones[i]);\\n        }\\n\\n        Set<String> memo = new HashSet<>();\\n\\n        return helper(stoneSet, memo, 1, 1, stones[stones.length - 1]);\\n    }\\n\\n    private boolean helper(Set<Integer> stoneSet, Set<String> memo, int curunit, int curspeed, int target) {\\n\\n        String key = curunit + \", \" + curspeed;\\n\\n        if (memo.contains(key)) {\\n            return false;\\n        }\\n\\n        if (curunit == target) {\\n            return true;\\n        }\\n\\n        if (curspeed <= 0 || curunit > target || curunit < 0 || !stoneSet.contains(curunit)) {\\n            return false;\\n        }\\n\\n        int[] speed = {-1, 0, 1};\\n\\n        for (int i = 0; i < 3; i++) {\\n            int nextSpeed = curspeed + speed[i];\\n            int nextUnit = curunit + nextSpeed;\\n            if (helper(stoneSet, memo, nextUnit, nextSpeed, target)) {\\n                return true;\\n            }\\n        }\\n\\n        memo.add(key);\\n        return false;\\n    }\\n\\n}\\n```\\n\\nPython version:\\n```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        target = stones[-1]\\n        stones = set(stones)\\n        curunit = 1\\n        curspeed = 1\\n        memo = set()\\n        return self.helper(stones, curunit, curspeed, memo, target)\\n    \\n    def helper(self, stones, curunit, curspeed, memo, target):\\n        if (curunit, curspeed) in memo:\\n            return False\\n        \\n        if curunit == target:\\n            return True\\n        \\n        if curspeed <= 0 or curunit > target or curunit < 0 or curunit not in stones:\\n            return False\\n        \\n        for speed in [curspeed - 1, curspeed, curspeed + 1]:\\n            nextunit = curunit + speed\\n            if self.helper(stones, nextunit, speed, memo, target):\\n                return True\\n        \\n        memo.add((curunit, curspeed))\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean canCross(int[] stones) {\\n\\n        Set<Integer> stoneSet = new HashSet<>();\\n        for (int i = 0; i < stones.length; i++) {\\n            stoneSet.add(stones[i]);\\n        }\\n\\n        Set<String> memo = new HashSet<>();\\n\\n        return helper(stoneSet, memo, 1, 1, stones[stones.length - 1]);\\n    }\\n\\n    private boolean helper(Set<Integer> stoneSet, Set<String> memo, int curunit, int curspeed, int target) {\\n\\n        String key = curunit + \", \" + curspeed;\\n\\n        if (memo.contains(key)) {\\n            return false;\\n        }\\n\\n        if (curunit == target) {\\n            return true;\\n        }\\n\\n        if (curspeed <= 0 || curunit > target || curunit < 0 || !stoneSet.contains(curunit)) {\\n            return false;\\n        }\\n\\n        int[] speed = {-1, 0, 1};\\n\\n        for (int i = 0; i < 3; i++) {\\n            int nextSpeed = curspeed + speed[i];\\n            int nextUnit = curunit + nextSpeed;\\n            if (helper(stoneSet, memo, nextUnit, nextSpeed, target)) {\\n                return true;\\n            }\\n        }\\n\\n        memo.add(key);\\n        return false;\\n    }\\n\\n}\\n```\n```\\nclass Solution(object):\\n    def canCross(self, stones):\\n        \"\"\"\\n        :type stones: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        target = stones[-1]\\n        stones = set(stones)\\n        curunit = 1\\n        curspeed = 1\\n        memo = set()\\n        return self.helper(stones, curunit, curspeed, memo, target)\\n    \\n    def helper(self, stones, curunit, curspeed, memo, target):\\n        if (curunit, curspeed) in memo:\\n            return False\\n        \\n        if curunit == target:\\n            return True\\n        \\n        if curspeed <= 0 or curunit > target or curunit < 0 or curunit not in stones:\\n            return False\\n        \\n        for speed in [curspeed - 1, curspeed, curspeed + 1]:\\n            nextunit = curunit + speed\\n            if self.helper(stones, nextunit, speed, memo, target):\\n                return True\\n        \\n        memo.add((curunit, curspeed))\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 88827,
                "title": "simple-javascript-solution-using-dp-recursion-memoization",
                "content": "```\\nvar canCross = function(stones) {\\n    const pos = new Set(stones);\\n    return helper(pos, stones[stones.length - 1]);\\n};\\n\\nfunction helper(pos, end, curr = 0, jump = 1, memo = new Map()) {\\n    if (!pos.has(curr)) return false;\\n    let key = curr + \\',\\' + jump;\\n    if (memo.has(key)) return memo.get(key);\\n    if (curr === end) return true;\\n    let less = jump > 1 ? helper(pos, end, curr + jump, jump - 1, memo) : false;\\n    memo.set(key, less || helper(pos, end, curr + jump, jump, memo) || helper(pos, end, curr + jump, jump + 1, memo));\\n    return memo.get(key);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canCross = function(stones) {\\n    const pos = new Set(stones);\\n    return helper(pos, stones[stones.length - 1]);\\n};\\n\\nfunction helper(pos, end, curr = 0, jump = 1, memo = new Map()) {\\n    if (!pos.has(curr)) return false;\\n    let key = curr + \\',\\' + jump;\\n    if (memo.has(key)) return memo.get(key);\\n    if (curr === end) return true;\\n    let less = jump > 1 ? helper(pos, end, curr + jump, jump - 1, memo) : false;\\n    memo.set(key, less || helper(pos, end, curr + jump, jump, memo) || helper(pos, end, curr + jump, jump + 1, memo));\\n    return memo.get(key);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 88905,
                "title": "java-solution-using-hashmap",
                "content": "For each stone, we write down a set of jump distances taken from previous stones to reach this stone (for example, if the stones were 3, 5, 7, then for stone 7 we write down 7 - 3 = 4 and 7 - 5 = 2, assuming they're both valid moves). From the distance set we can find a set of \"imaginary\" stones reachable from this stone, so all we have to do is to figure out (through hash table) which of those target stones actually exists, and propagate the distance to their distance sets.\\n\\nFinally, we check if the last stone was reachable by checking if its distance set wasn't empty.\\n\\n```\\npublic class Solution {\\n    public boolean canCross(int[] stones) {\\n        final int l = stones != null ? stones.length : 0;\\n        if (l < 1 || stones[0] != 0) return false;\\n        final Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int s : stones) map.put(s, new HashSet<Integer>());\\n        for (int s : stones) {\\n            Set<Integer> jSet = map.get(s);\\n            // Initial condition\\n            if (s == 0) {\\n                jSet.add(0);\\n                if (map.containsKey(1)) map.get(1).add(1);\\n                continue;\\n            }\\n            // For other stones\\n            for (int j : jSet) {\\n                int jj = j - 1;\\n                int ss = s + jj;\\n                // Previous jump - 1\\n                if (ss != s && map.containsKey(ss)) map.get(ss).add(jj);\\n                // Previous jump\\n                jj++; ss++;\\n                if (ss != s && map.containsKey(ss)) map.get(ss).add(jj);\\n                // Previous jump + 1\\n                jj++; ss++;\\n                if (ss != s && map.containsKey(ss)) map.get(ss).add(jj);\\n            }\\n        }\\n        return !map.get(stones[l - 1]).isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public boolean canCross(int[] stones) {\\n        final int l = stones != null ? stones.length : 0;\\n        if (l < 1 || stones[0] != 0) return false;\\n        final Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int s : stones) map.put(s, new HashSet<Integer>());\\n        for (int s : stones) {\\n            Set<Integer> jSet = map.get(s);\\n            // Initial condition\\n            if (s == 0) {\\n                jSet.add(0);\\n                if (map.containsKey(1)) map.get(1).add(1);\\n                continue;\\n            }\\n            // For other stones\\n            for (int j : jSet) {\\n                int jj = j - 1;\\n                int ss = s + jj;\\n                // Previous jump - 1\\n                if (ss != s && map.containsKey(ss)) map.get(ss).add(jj);\\n                // Previous jump\\n                jj++; ss++;\\n                if (ss != s && map.containsKey(ss)) map.get(ss).add(jj);\\n                // Previous jump + 1\\n                jj++; ss++;\\n                if (ss != s && map.containsKey(ss)) map.get(ss).add(jj);\\n            }\\n        }\\n        return !map.get(stones[l - 1]).isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022038,
                "title": "frog-jump-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(int idx,int curr_jump,vector<int>& stones,vector<vector<int>>&dp)\\n    {\\n\\n        if(idx==stones.size()-1)\\n        {\\n            return true;\\n        }\\n\\n\\n        if(dp[idx][curr_jump]!=-1)\\n        {\\n            if(dp[idx][curr_jump]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        for(int i=curr_jump-1; i<=curr_jump+1; i++)\\n        {\\n            if(i>0)\\n            {\\n                int ele = stones[idx]+i;\\n                int a = lower_bound(stones.begin()+idx,stones.end(),ele)-stones.begin();\\n\\n                if(a==stones.size())\\n                {\\n                    continue;\\n                }\\n                else if(stones[a]!=ele)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bool z = solve(a,i,stones,dp);\\n                    if(z==true)\\n                    {\\n                        dp[idx][curr_jump]=1;\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[idx][curr_jump]=0;\\n        return false;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        \\n\\n        int idx = 0;\\n        int curr_jump = 0;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(2001,-1));\\n        bool ans  = solve(idx,curr_jump,stones,dp);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool solve(int idx,int curr_jump,vector<int>& stones,vector<vector<int>>&dp)\\n    {\\n\\n        if(idx==stones.size()-1)\\n        {\\n            return true;\\n        }\\n\\n\\n        if(dp[idx][curr_jump]!=-1)\\n        {\\n            if(dp[idx][curr_jump]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        for(int i=curr_jump-1; i<=curr_jump+1; i++)\\n        {\\n            if(i>0)\\n            {\\n                int ele = stones[idx]+i;\\n                int a = lower_bound(stones.begin()+idx,stones.end(),ele)-stones.begin();\\n\\n                if(a==stones.size())\\n                {\\n                    continue;\\n                }\\n                else if(stones[a]!=ele)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bool z = solve(a,i,stones,dp);\\n                    if(z==true)\\n                    {\\n                        dp[idx][curr_jump]=1;\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[idx][curr_jump]=0;\\n        return false;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        \\n\\n        int idx = 0;\\n        int curr_jump = 0;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(2001,-1));\\n        bool ans  = solve(idx,curr_jump,stones,dp);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968851,
                "title": "simple-solution-explained-with-examples-in-detail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1)  Let us say you are standing at some stone, for every stone..**There are three options**\\n\\n**1) From that stone you can jump k-1 steps**\\n**2) From that stone you can jump k steps**\\n**3) From that stone you can jump k+1 steps...**\\n\\n\\nNow, let us say your array is stones = [0,1,3,5,6,8,12,17]\\n\\nNow, In the question it is mentioned that **we need to jump a unit of \"1\", in the beginning** \\n\\n\\nso you will reach index 1 , that has value \"1\"...Now from here you can jump **(1-1),1,(1+1) units**....so basically you can jump **0,1,or 2 units...**\\n\\n\\nNow, is there any **sense of jumping 0 unit**s..The ans is \"No\"..so if your **jumping units <=0**, we **won\\'t perform** any calculation..\\n\\nCurrently we were at stone 1..Now , if we jump 1 unit from here..we **would reach at unit 2**..Now, we need to check that the array contains a**ny stone at unit 2**...\\n\\nHow do we check it..**THE ANS IS SIMPLE...BINARY SEARCH..**\\n\\nwe will just check in the stone array that **\"2\" is present or not...**\\n\\nWe will just do a **lower_bound to check whether the element is presnt or not..**\\n\\nCODE FOR THIS \\n\\n```\\n            if(i>0)\\n            {\\n                int ele = stones[idx]+i;\\n                int a = lower_bound(stones.begin()+idx,stones.end(),ele)-stones.begin();\\n            \\n                if(a==stones.size())\\n                {\\n                    continue;\\n                }\\n                else if(stones[a]!=ele)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bool z = solve(a,i,stones,dp);\\n                    if(z==true)\\n                    {\\n                        return true;\\n                    }\\n                }\\n```\\n\\nNow, if you find a particular unit is present in the stone array ...so..just make sure to call the function by updating the c**urrent index and current jump YOU DID TO REACH THAT INDEX...**\\n\\nIf you reach the last index..then just return a true...\\n\\n\\n**How do we memoize it...**\\n\\n There are 2 parameters changing \\n\\n**1) The index i**\\n\\n**2) The jump..**\\n\\nso we will just make a 2-d dp array of size **dp[stones.size()][2001]**,\\n\\nWHy did we choose 2001 here, because the max jump could go to 2000..I t won\\'t go beyond that...**because there are only 2000 elements in the stone array ...**\\n\\nNow just store the values in this array and you have your ans...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe made a 2-d dp array, so at the worst the time complexity could be **O(N* N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe made a 2-d dp array so **O(N * N)** WHERE N = 2001\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(int idx,int curr_jump,vector<int>& stones,vector<vector<int>>&dp)\\n    {\\n\\n        if(idx==stones.size()-1)\\n        {\\n            return true;\\n        }\\n\\n\\n        if(dp[idx][curr_jump]!=-1)\\n        {\\n            if(dp[idx][curr_jump]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        for(int i=curr_jump-1; i<=curr_jump+1; i++)\\n        {\\n            if(i>0)\\n            {\\n                int ele = stones[idx]+i;\\n                int a = lower_bound(stones.begin()+idx,stones.end(),ele)-stones.begin();\\n\\n                if(a==stones.size())\\n                {\\n                    continue;\\n                }\\n                else if(stones[a]!=ele)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bool z = solve(a,i,stones,dp);\\n                    if(z==true)\\n                    {\\n                        dp[idx][curr_jump]=1;\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[idx][curr_jump]=0;\\n        return false;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        \\n\\n        int idx = 0;\\n        int curr_jump = 0;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(2001,-1));\\n        bool ans  = solve(idx,curr_jump,stones,dp);\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW** \\n![WhatsApp Image 2023-08-28 at 00.03.17.jpeg](https://assets.leetcode.com/users/images/5e434ec7-0e2f-4775-a121-6a4b6808cd2b_1693161327.1018555.jpeg)\\n\\n\\n\\n# **IF YOU LIKE MY SOLUTION, PLEASE UPVOTE..**",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n            if(i>0)\\n            {\\n                int ele = stones[idx]+i;\\n                int a = lower_bound(stones.begin()+idx,stones.end(),ele)-stones.begin();\\n            \\n                if(a==stones.size())\\n                {\\n                    continue;\\n                }\\n                else if(stones[a]!=ele)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bool z = solve(a,i,stones,dp);\\n                    if(z==true)\\n                    {\\n                        return true;\\n                    }\\n                }\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool solve(int idx,int curr_jump,vector<int>& stones,vector<vector<int>>&dp)\\n    {\\n\\n        if(idx==stones.size()-1)\\n        {\\n            return true;\\n        }\\n\\n\\n        if(dp[idx][curr_jump]!=-1)\\n        {\\n            if(dp[idx][curr_jump]==1)\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        \\n        for(int i=curr_jump-1; i<=curr_jump+1; i++)\\n        {\\n            if(i>0)\\n            {\\n                int ele = stones[idx]+i;\\n                int a = lower_bound(stones.begin()+idx,stones.end(),ele)-stones.begin();\\n\\n                if(a==stones.size())\\n                {\\n                    continue;\\n                }\\n                else if(stones[a]!=ele)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    bool z = solve(a,i,stones,dp);\\n                    if(z==true)\\n                    {\\n                        dp[idx][curr_jump]=1;\\n                        return true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        dp[idx][curr_jump]=0;\\n        return false;\\n    }\\n\\n    bool canCross(vector<int>& stones) {\\n        \\n\\n        int idx = 0;\\n        int curr_jump = 0;\\n        vector<vector<int>>dp(stones.size()+1,vector<int>(2001,-1));\\n        bool ans  = solve(idx,curr_jump,stones,dp);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968058,
                "title": "easy-c-solution-beats-90-submissions-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,bool> t;\\n    unordered_set<int> s;\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]-stones[0]!=1)\\n            return false;\\n        int last_stone=stones[stones.size()-1];\\n        for(int i:stones)\\n        {\\n            s.insert(i);\\n        }\\n        return func(last_stone,stones[1],1);\\n    }\\n    bool func(int last_stone, int curr_stone, int k)\\n    {\\n        if(curr_stone==last_stone)\\n            return true;\\n        if(t.find(make_pair(curr_stone,k))!=t.end())\\n            return t[make_pair(curr_stone,k)];\\n        bool ans=false;\\n        if(k-1>0&&s.find(curr_stone+k-1)!=s.end())\\n        {\\n            ans=ans||func(last_stone,curr_stone+k-1,k-1);\\n        }\\n        if(s.find(curr_stone+k)!=s.end())\\n        {\\n            ans=ans||func(last_stone,curr_stone+k,k);\\n        }\\n        if(s.find(curr_stone+k+1)!=s.end())\\n        {\\n            ans=ans||func(last_stone,curr_stone+k+1,k+1);\\n        }\\n        t[make_pair(curr_stone,k)]=ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,bool> t;\\n    unordered_set<int> s;\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]-stones[0]!=1)\\n            return false;\\n        int last_stone=stones[stones.size()-1];\\n        for(int i:stones)\\n        {\\n            s.insert(i);\\n        }\\n        return func(last_stone,stones[1],1);\\n    }\\n    bool func(int last_stone, int curr_stone, int k)\\n    {\\n        if(curr_stone==last_stone)\\n            return true;\\n        if(t.find(make_pair(curr_stone,k))!=t.end())\\n            return t[make_pair(curr_stone,k)];\\n        bool ans=false;\\n        if(k-1>0&&s.find(curr_stone+k-1)!=s.end())\\n        {\\n            ans=ans||func(last_stone,curr_stone+k-1,k-1);\\n        }\\n        if(s.find(curr_stone+k)!=s.end())\\n        {\\n            ans=ans||func(last_stone,curr_stone+k,k);\\n        }\\n        if(s.find(curr_stone+k+1)!=s.end())\\n        {\\n            ans=ans||func(last_stone,curr_stone+k+1,k+1);\\n        }\\n        t[make_pair(curr_stone,k)]=ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967004,
                "title": "recursion-and-memo-1",
                "content": "int arr[2000][2001];\\n    int n;\\n    unordered_map<int,int>m;\\n    bool go(int i,int k,vector<int>& stones)\\n    {\\n        if(i==n-1)\\n            return true;\\n        if(arr[i][k]!=-1)\\n            return arr[i][k];\\n        int k1=0,k2=0,k3=0;\\n        int val=stones[i];\\n        if(k!=1)\\n        {\\n           if(m.find(val+k-1)!=m.end())\\n               k1=go(m[val+k-1],k-1,stones);\\n        }\\n         if(m.find(val+k)!=m.end())\\n               k2=go(m[val+k],k,stones);\\n         if(m.find(val+k+1)!=m.end())\\n               k3=go(m[val+k+1],k+1,stones);\\n            return  arr[i][k]=k1||k2||k3;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]!=1)\\n            return false;\\n        memset(arr,-1,sizeof(arr));\\n        n=stones.size();\\n       for(int i=0;i<n;i++)\\n           m[stones[i]]=i;\\n       return go(1,1,stones);",
                "solutionTags": [],
                "code": "int arr[2000][2001];\\n    int n;\\n    unordered_map<int,int>m;\\n    bool go(int i,int k,vector<int>& stones)\\n    {\\n        if(i==n-1)\\n            return true;\\n        if(arr[i][k]!=-1)\\n            return arr[i][k];\\n        int k1=0,k2=0,k3=0;\\n        int val=stones[i];\\n        if(k!=1)\\n        {\\n           if(m.find(val+k-1)!=m.end())\\n               k1=go(m[val+k-1],k-1,stones);\\n        }\\n         if(m.find(val+k)!=m.end())\\n               k2=go(m[val+k],k,stones);\\n         if(m.find(val+k+1)!=m.end())\\n               k3=go(m[val+k+1],k+1,stones);\\n            return  arr[i][k]=k1||k2||k3;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1]!=1)\\n            return false;\\n        memset(arr,-1,sizeof(arr));\\n        n=stones.size();\\n       for(int i=0;i<n;i++)\\n           m[stones[i]]=i;\\n       return go(1,1,stones);",
                "codeTag": "Unknown"
            },
            {
                "id": 3966318,
                "title": "beats-100-2ms-only-dp-self-explained-code-java",
                "content": "![image.png](https://assets.leetcode.com/users/images/d58229d9-c040-4640-ade4-904e9762bbc1_1693119860.1054668.png)\\nI haven\\'t seen any faster solution so far, so I post my solution here for those who want a really fast algorithm.\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\n\\nBy reading the problem description, we can easily see that every jump is dependent on the last jump, such that `|currJump - lastJump| <= 1`.\\nIn other words, for every last jump, there are three possible next jump, respectively `lastJump - 1`, `lastJump` and `lastJump + 1`.\\nOne of the most important techniques in computer sicience to solve a problem is to break it down to smaller problems and deal with one small problem each time.\\nThe key here is to look at only one jump each time, so that we don\\'t get confused.\\n# Approach : Top-Down Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\nConsider the case where the frog jumps into `stone` with `lastJump`, where `stone` denotes the index of the current stone in the array `stones`.\\nIf `stone` is already the last stone in the `stones` array, it means we\\'ve cross the river. Therefore we return `ture`.\\n```\\nif (stone >= stones.length - 1) return true;\\n```\\nIf `stone` is not the last stone, we set `nextStone` to be `stone + 1`. By doing so, we do not allow jumping over and over again to `stone` with zero distance.\\n```\\nint nextStone = stone + 1;\\n```\\nSince the least units we can jump is `lastJump - 1`, we can skip all the stones that are less than `stones[stone] + lastJump - 1`.\\n```\\nwhile (nextStone < stones.length \\n        && stones[nextStone] < stones[stone] + lastJump - 1)\\n    nextStone++;\\n```\\nNow we have `stones[nextStone] >= stones[stone] + lastJump - 1`. It\\'s time to consider three different jumps `{lastJump - 1, lastJump, lastJump + 1}`.\\n- **Consider `jump - 1`**\\nIf `stones[nextStone] == stones[stone] + lastJump - 1`, then we jump to `nextStone` and skip one stone. Now we have `stones[nextStone] >= stones[stone] + lastJump`.\\nElse, `stones[nextStone] > stones[stone] + lastJump - 1`, it is the same as `stones[nextStone] >= stones[stone] + lastJump`. We do nothing.\\n    ```\\n    if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump - 1)\\n        if (canCross(nextStone, lastJump - 1))\\n            return true;\\n        nextStone++;\\n    ```\\n    \\n- **Consider `jump`**\\nIf `stones[nextStone] == stones[stone] + lastJump`, then we jump to `nextStone` and skip one stone. Now we have `stones[nextStone] >= stones[stone] + lastJump + 1`.\\nElse, `stones[nextStone] > stones[stone] + lastJump`, it is the same as `stones[nextStone] >= stones[stone] + lastJump + 1`. We do nothing.\\n    ```\\n    if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump)\\n        if (canCross(nextStone, lastJump))\\n            return true;\\n        nextStone++;\\n    ```\\n- **Consider `jump + 1`**\\nIf `stones[nextStone] == stones[stone] + lastJump + 1`, then we jump to `nextStone`.\\n    ```\\n    if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump + 1)\\n        if (canCross(nextStone, lastJump + 1))\\n            return true;\\n    ```\\nIf none of the three jumps can make it, we return false.\\n\\n---\\n\\n> The approach above can logically solve the problem already, but the complexity will be O(3<sup>n</sup>) since in worse case we recursively look at three different jumps each time. If one submit the approach above, the result will be TLE.\\nThat\\'s why introduce memorization, aka DP.\\n\\nSince there can potantially be many overlaps in recursive calls for (`stone`, `lastJump`).\\nWe keep track of all the visited compinations of (`stone`, `lastJump`) by using a two-dimensional boolean array `boolean[][] visited`.\\nWhen we first visit a combination of (`stone`, `lastJump`), we set `visited[stone][lastJump]` to `true`.\\nIf we ever visit a combination that we\\'ve visited before, it means this very combination can not cross, otherwise we would\\'ve return `true` already;\\n```\\nif (visited[stone][lastJump]) return false;\\nvisited[stone][lastJump] = true;\\n```\\n\\n# Complexity\\n- Time complexity: O(n<sup>2</sup>)\\nIn worse case senario, we make recursive calls for all the possible combination of (`stone`, `lastJump`) and fill up `visited`. Hence O(n<sup>2</sup>).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n<sup>2</sup>)\\nWe need O(n<sup>2</sup>) space for the two-dimensional boolean array `visited`.\\nIn worse case senario, the maximum depth for recursive calls is O(n). Hence we need O(n) for recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[] stones;\\n    boolean[][] visited;\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] != 1 || stones[stones.length - 1] > 2001000)\\n            return false;\\n        this.stones = stones;\\n        visited = new boolean[stones.length][stones.length];\\n        return canCross(1, 1);\\n    }\\n    public boolean canCross(int stone, int lastJump) {\\n        // River Crossed!\\n        if (stone >= stones.length - 1) return true;\\n\\n        if (visited[stone][lastJump]) return false;\\n        visited[stone][lastJump] = true;\\n\\n        int nextStone = stone + 1;\\n        while (nextStone < stones.length && stones[nextStone] < stones[stone] + lastJump - 1)\\n            nextStone++;\\n\\n        // Consider lastJump - 1\\n        if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump - 1 \\n                && canCross(nextStone++, lastJump - 1))\\n            return true;\\n        // Consider lastJump\\n        if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump \\n                && canCross(nextStone++, lastJump))\\n            return true;\\n        // Consider lastJump + 1\\n        return nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump + 1\\n                && canCross(nextStone, lastJump + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nif (stone >= stones.length - 1) return true;\\n```\n```\\nint nextStone = stone + 1;\\n```\n```\\nwhile (nextStone < stones.length \\n        && stones[nextStone] < stones[stone] + lastJump - 1)\\n    nextStone++;\\n```\n```\\n    if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump - 1)\\n        if (canCross(nextStone, lastJump - 1))\\n            return true;\\n        nextStone++;\\n    ```\n```\\n    if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump)\\n        if (canCross(nextStone, lastJump))\\n            return true;\\n        nextStone++;\\n    ```\n```\\n    if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump + 1)\\n        if (canCross(nextStone, lastJump + 1))\\n            return true;\\n    ```\n```\\nif (visited[stone][lastJump]) return false;\\nvisited[stone][lastJump] = true;\\n```\n```\\nclass Solution {\\n    int[] stones;\\n    boolean[][] visited;\\n    public boolean canCross(int[] stones) {\\n        if (stones[1] != 1 || stones[stones.length - 1] > 2001000)\\n            return false;\\n        this.stones = stones;\\n        visited = new boolean[stones.length][stones.length];\\n        return canCross(1, 1);\\n    }\\n    public boolean canCross(int stone, int lastJump) {\\n        // River Crossed!\\n        if (stone >= stones.length - 1) return true;\\n\\n        if (visited[stone][lastJump]) return false;\\n        visited[stone][lastJump] = true;\\n\\n        int nextStone = stone + 1;\\n        while (nextStone < stones.length && stones[nextStone] < stones[stone] + lastJump - 1)\\n            nextStone++;\\n\\n        // Consider lastJump - 1\\n        if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump - 1 \\n                && canCross(nextStone++, lastJump - 1))\\n            return true;\\n        // Consider lastJump\\n        if (nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump \\n                && canCross(nextStone++, lastJump))\\n            return true;\\n        // Consider lastJump + 1\\n        return nextStone < stones.length && stones[nextStone] == stones[stone] + lastJump + 1\\n                && canCross(nextStone, lastJump + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965961,
                "title": "using-hashmaps-and-memoization-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse hashmaps to store the indices of stones. and accordingly decide the jump.Just remember the jump should be forward.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    unordered_map<int,int> mp;\\n    bool f(int i,vector<int>& stones,int k){\\n         if(i==stones.size()-1){\\n             return true;\\n         }\\n         if(i>=stones.size())return false;\\n         if(dp[i][k]!=-1)return dp[i][k];\\n         bool p1=false;\\n         bool p2=false;\\n         bool p3=false;\\n        //  cout<<i<<endl;\\n         if(i==0){\\n           if(mp.find(i+1)!=mp.end()){\\n               int in=mp[i+1];\\n               p1=f(in,stones,1);\\n           }\\n         }else{\\n             \\n             int i1=stones[i]+k+1;\\n             int i2=stones[i]+k;\\n             int i3=stones[i]+k-1;\\n             int in;\\n             if(mp.find(i1)!=mp.end() && mp[i1]>i){\\n                   in=mp[i1];\\n                  p1=f(in,stones,k+1);\\n             }\\n             if(p1)return dp[i][k]=p1;\\n             if(mp.find(i2)!=mp.end() && mp[i2]>i){\\n                   \\n                   in=mp[i2];\\n                  p2=f(in,stones,k);\\n             }\\n             if(p2)return dp[i][k]=p2;\\n             if(mp.find(i3)!=mp.end() && mp[i3]>i){\\n                   in=mp[i3];\\n                  p3=f(in,stones,k-1);\\n             }\\n             if(p3)return dp[i][k]=p3;\\n         }\\n         return dp[i][k]=p1 || p2 || p3;\\n\\n     }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        for(int i=0;i<n;i++){\\n            mp[stones[i]]=i;\\n        }\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        return f(0,stones,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    unordered_map<int,int> mp;\\n    bool f(int i,vector<int>& stones,int k){\\n         if(i==stones.size()-1){\\n             return true;\\n         }\\n         if(i>=stones.size())return false;\\n         if(dp[i][k]!=-1)return dp[i][k];\\n         bool p1=false;\\n         bool p2=false;\\n         bool p3=false;\\n        //  cout<<i<<endl;\\n         if(i==0){\\n           if(mp.find(i+1)!=mp.end()){\\n               int in=mp[i+1];\\n               p1=f(in,stones,1);\\n           }\\n         }else{\\n             \\n             int i1=stones[i]+k+1;\\n             int i2=stones[i]+k;\\n             int i3=stones[i]+k-1;\\n             int in;\\n             if(mp.find(i1)!=mp.end() && mp[i1]>i){\\n                   in=mp[i1];\\n                  p1=f(in,stones,k+1);\\n             }\\n             if(p1)return dp[i][k]=p1;\\n             if(mp.find(i2)!=mp.end() && mp[i2]>i){\\n                   \\n                   in=mp[i2];\\n                  p2=f(in,stones,k);\\n             }\\n             if(p2)return dp[i][k]=p2;\\n             if(mp.find(i3)!=mp.end() && mp[i3]>i){\\n                   in=mp[i3];\\n                  p3=f(in,stones,k-1);\\n             }\\n             if(p3)return dp[i][k]=p3;\\n         }\\n         return dp[i][k]=p1 || p2 || p3;\\n\\n     }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        for(int i=0;i<n;i++){\\n            mp[stones[i]]=i;\\n        }\\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        return f(0,stones,1);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3965597,
                "title": "dp-hash-table-clean-code-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nfrog can jump on three positions:\\n\\ncurrent_position + previous_jump + 1\\ncurrent_position + previous_jump\\ncurrent_position + previous_jump-1\\n\\nbut frog will jump on the positon that have a stone.\\n\\n\\n# Complexity\\n- Time complexity:(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<string,int> dp;\\n    bool solve(vector<int> &arr,int i,int jp)\\n    {\\n        if(i==arr.size()-1) return true;\\n\\n        string str = to_string(i)+\",\"+to_string(jp);\\n        if(dp.find(str)!=dp.end()) return dp[str];\\n\\n        bool a = false,b = false,c = false;\\n        int jp1 = arr[i]+jp;\\n        int jp2 = arr[i]+jp+1;\\n        int jp3 = arr[i]+jp-1;\\n\\n        if(mp.find(jp1)!=mp.end() && mp[jp1]!=i) a = solve(arr,mp[jp1],abs(arr[mp[jp1]]-arr[i]));\\n        if(mp.find(jp2)!=mp.end() && mp[jp2]!=i) b = solve(arr,mp[jp2],abs(arr[mp[jp2]]-arr[i]));\\n        if(mp.find(jp3)!=mp.end() && mp[jp3]!=i) c = solve(arr,mp[jp3],abs(arr[mp[jp3]]-arr[i]));\\n\\n        return dp[str] = a | b | c;   \\n    }\\n    bool canCross(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0;i<n;i++) mp[arr[i]] = i;\\n        return solve(arr,0,0);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e568e4d1-a0e2-46fd-8ff2-45a24d0a91e9_1693114149.3527155.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> mp;\\n    unordered_map<string,int> dp;\\n    bool solve(vector<int> &arr,int i,int jp)\\n    {\\n        if(i==arr.size()-1) return true;\\n\\n        string str = to_string(i)+\",\"+to_string(jp);\\n        if(dp.find(str)!=dp.end()) return dp[str];\\n\\n        bool a = false,b = false,c = false;\\n        int jp1 = arr[i]+jp;\\n        int jp2 = arr[i]+jp+1;\\n        int jp3 = arr[i]+jp-1;\\n\\n        if(mp.find(jp1)!=mp.end() && mp[jp1]!=i) a = solve(arr,mp[jp1],abs(arr[mp[jp1]]-arr[i]));\\n        if(mp.find(jp2)!=mp.end() && mp[jp2]!=i) b = solve(arr,mp[jp2],abs(arr[mp[jp2]]-arr[i]));\\n        if(mp.find(jp3)!=mp.end() && mp[jp3]!=i) c = solve(arr,mp[jp3],abs(arr[mp[jp3]]-arr[i]));\\n\\n        return dp[str] = a | b | c;   \\n    }\\n    bool canCross(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0;i<n;i++) mp[arr[i]] = i;\\n        return solve(arr,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965075,
                "title": "simple-memoization-dp-beginner-friendly",
                "content": "\\n> Time complexity: $$O(n^2)$$\\n> Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Boolean memo[][];\\n    HashMap<Integer, Integer> map;\\n    int dest;\\n    public boolean canCross(int[] stones) {\\n        int n=stones.length;\\n        memo=new Boolean[n][n+1];\\n        map=new HashMap<>(n);\\n        for(int i=0;i<n;i++) map.put(stones[i], i);\\n        dest=stones[n-1];\\n        return f(0,0);\\n    }\\n    private boolean f(int curr, int k) {\\n        if(curr==dest) return true;\\n        if(map.containsKey(curr)) {\\n            int ind=map.get(curr);\\n            if(memo[ind][k]!=null) return memo[ind][k];\\n            return memo[ind][k]=f(curr+k+1, k+1) || (k>1 && f(curr+k-1,k-1)) || (k>0 && f(curr+k,k));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Boolean memo[][];\\n    HashMap<Integer, Integer> map;\\n    int dest;\\n    public boolean canCross(int[] stones) {\\n        int n=stones.length;\\n        memo=new Boolean[n][n+1];\\n        map=new HashMap<>(n);\\n        for(int i=0;i<n;i++) map.put(stones[i], i);\\n        dest=stones[n-1];\\n        return f(0,0);\\n    }\\n    private boolean f(int curr, int k) {\\n        if(curr==dest) return true;\\n        if(map.containsKey(curr)) {\\n            int ind=map.get(curr);\\n            if(memo[ind][k]!=null) return memo[ind][k];\\n            return memo[ind][k]=f(curr+k+1, k+1) || (k>1 && f(curr+k-1,k-1)) || (k>0 && f(curr+k,k));\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964781,
                "title": "beats-100-js-ts-java-c-c-python-python3-kotlin",
                "content": "---\\n![header_.png](https://assets.leetcode.com/users/images/ab4510d5-90e7-4616-b1e1-aac91ec90eea_1692159981.2067795.png)\\n\\n---\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        // Create a hashmap to store possible jump sizes for each stone position\\n        // Key: Stone position, Value: Set of valid jump sizes from that position\\n        unordered_map<int, unordered_set<int>> hashMap;\\n\\n        // Initialize the first stone\\'s jump sizes. Since the frog starts at position 0,\\n        // it can only jump 1 unit to reach the first stone.\\n        hashMap[stones[0] + 1] = {1};\\n\\n        // Iterate through the stones starting from the second stone\\n        for (int i = 1; i < stones.size(); ++i) {\\n            int position = stones[i]; // Current stone\\'s position\\n\\n            // Iterate through the possible jump sizes for the current stone\\'s position\\n            for (auto it : hashMap[position]) {\\n                // For each valid jump size \\'it\\', update the jump sizes for the next stones\\n                \\n                // Jump to the next stone with the same jump size \\'it\\'\\n                hashMap[position + it].insert(it);\\n\\n                // Jump to the next stone with jump size \\'it + 1\\'\\n                hashMap[position + it + 1].insert(it + 1);\\n\\n                // Jump to the next stone with jump size \\'it - 1\\'\\n                hashMap[position + it - 1].insert(it - 1);\\n            }\\n        }\\n        \\n        // If the last stone\\'s position has any valid jump sizes, it means the frog can cross\\n        // the river and reach the last stone\\n        return hashMap[stones.back()].size() != 0;\\n    }\\n};\\n```\\n```Typescript []\\nfunction canCross(stones: number[]): boolean {\\n    const jumpMap: Map<number, Set<number>> = new Map();\\n\\n    // Initialize the jumpMap with stone positions\\n    for (const stone of stones) {\\n        jumpMap.set(stone, new Set());\\n    }\\n    jumpMap.get(0).add(0); // The frog starts at position 0 with jump size 0\\n\\n    for (const stone of stones) {\\n        const jumpSizes = jumpMap.get(stone);\\n        \\n        for (const jumpSize of jumpSizes) {\\n            for (let nextJumpSize = jumpSize - 1; nextJumpSize <= jumpSize + 1; nextJumpSize++) {\\n                if (nextJumpSize > 0 && jumpMap.has(stone + nextJumpSize)) {\\n                    jumpMap.get(stone + nextJumpSize).add(nextJumpSize);\\n                }\\n            }\\n        }\\n    }\\n\\n    return jumpMap.get(stones[stones.length - 1]).size > 0;\\n}\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        // Create a hashmap to store jump distances for each stone position\\n        HashMap<Integer, HashSet<Integer>> jumpMap = new HashMap<>();\\n        \\n        // Initialize the hashmap with the first stone\\n        jumpMap.put(0, new HashSet<>());\\n        jumpMap.get(0).add(1); // Frog can jump 1 unit from the first stone\\n        \\n        // Populate the jumpMap for each stone\\n        for (int i = 1; i < stones.length; i++) {\\n            jumpMap.put(stones[i], new HashSet<>());\\n        }\\n        \\n        // Iterate through stones and update jump distances\\n        for (int i = 0; i < stones.length - 1; i++) {\\n            int stonePos = stones[i];\\n            HashSet<Integer> jumpDistances = jumpMap.get(stonePos);\\n            \\n            for (int jumpDistance : jumpDistances) {\\n                int nextPos = stonePos + jumpDistance;\\n                if (nextPos == stones[stones.length - 1]) {\\n                    return true; // Frog can reach the last stone\\n                }\\n                \\n                HashSet<Integer> nextJumpDistances = jumpMap.get(nextPos);\\n                if (nextJumpDistances != null) {\\n                    nextJumpDistances.add(jumpDistance);\\n                    if (jumpDistance > 1) {\\n                        nextJumpDistances.add(jumpDistance - 1);\\n                    }\\n                    nextJumpDistances.add(jumpDistance + 1);\\n                }\\n            }\\n        }\\n        \\n        return false; // Frog cannot reach the last stone\\n    }\\n}\\n```\\n```Python []\\nclass Solution(object):\\n    def canCross(self, stones):\\n        n = len(stones)\\n        # Create a dictionary to store the possible jump sizes at each stone.\\n        dp = {stone: set() for stone in stones}\\n        dp[0].add(0)  # The frog starts at the first stone with a jump size of 0.\\n\\n        for stone in stones:\\n            # Iterate through all possible jump sizes at the current stone.\\n            for jump_size in dp[stone]:\\n                # Try the next possible jump sizes for the next stone.\\n                for step in range(jump_size - 1, jump_size + 2):\\n                    if step > 0 and stone + step in dp:\\n                        dp[stone + step].add(step)\\n\\n        # If the last stone has any valid jump sizes, then the frog can cross the river.\\n        return len(dp[stones[-1]]) > 0\\n```\\n```Python3 []\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n = len(stones)\\n        \\n        # Create a dictionary to store possible jump lengths at each stone.\\n        # The key is the stone position, and the value is a set of possible jump lengths.\\n        jump_lengths = {stone: set() for stone in stones}\\n        jump_lengths[0].add(0)  # Initial jump\\n        \\n        for stone in stones:\\n            for jump in jump_lengths[stone]:\\n                for next_jump in [jump - 1, jump, jump + 1]:\\n                    if next_jump > 0 and stone + next_jump in jump_lengths:\\n                        jump_lengths[stone + next_jump].add(next_jump)\\n        \\n        # If the last stone has any possible jump lengths, then the frog can cross.\\n        return len(jump_lengths[stones[-1]]) > 0\\n```\\n```C# []\\npublic class Solution {\\n    HashSet<int> lookup; // HashSet to quickly check if a stone exists at a certain unit\\n    Dictionary<string, bool> dp; // Memoization dictionary to store computed results\\n\\n    public bool CanCross(int[] stones) {\\n        if (stones[1] != 1)\\n            return false; // If the second stone is not at position 1, the frog can\\'t jump to it\\n\\n        lookup = new HashSet<int>();\\n        dp = new Dictionary<string, bool>();\\n\\n        // Adding stone positions to the lookup HashSet for quick lookup\\n        for (int i = 0; i < stones.Length; i++)\\n            lookup.Add(stones[i]);\\n\\n        // Start the recursive process from the first stone (position 1) with a step of 1\\n        return DetermineCanCross(1, 1, stones[stones.Length - 1]);\\n    }\\n\\n    private bool DetermineCanCross(int reachedUnits, int lastStep, int destination) {\\n        if (!lookup.Contains(reachedUnits))\\n            return false; // If the frog can\\'t land at the reachedUnits, return false\\n\\n        if (reachedUnits == destination)\\n            return true; // If the frog reaches the destination, return true\\n\\n        string localLookup = reachedUnits + \"~\" + lastStep;\\n        if (dp.ContainsKey(localLookup))\\n            return dp[localLookup]; // If the result for this combination of reachedUnits and lastStep is already computed, return it from the memoization dictionary\\n\\n        if (lastStep == 0) {\\n            // The frog can only jump to the next stone with a step of 1\\n            bool computedResult = DetermineCanCross(reachedUnits + 1, 1, destination);\\n            dp.Add(localLookup, computedResult); // Store the computed result in the memoization dictionary\\n            return computedResult;\\n        } else if (lastStep == 1) {\\n            // The frog can jump to the next stone with a step of 1 or 2\\n            bool computedResult = DetermineCanCross(reachedUnits + 1, 1, destination) ||\\n                                  DetermineCanCross(reachedUnits + 2, 2, destination);\\n            dp.Add(localLookup, computedResult);\\n            return computedResult;\\n        } else {\\n            // The frog can jump to the next stone with a step of lastStep - 1, lastStep, or lastStep + 1\\n            bool computedResult = DetermineCanCross(reachedUnits + lastStep - 1, lastStep - 1, destination) ||\\n                                  DetermineCanCross(reachedUnits + lastStep, lastStep, destination) ||\\n                                  DetermineCanCross(reachedUnits + lastStep + 1, lastStep + 1, destination);\\n            dp.Add(localLookup, computedResult);\\n            return computedResult;\\n        }\\n    }\\n}\\n```\\n```Javascript []\\nvar canCross = function(stones) {\\n    const n = stones.length;\\n    \\n    // Create a map to store possible jump lengths at each stone\\n    const jumpMap = new Map();\\n    for (const stone of stones) {\\n        jumpMap.set(stone, new Set());\\n    }\\n    jumpMap.get(0).add(0); // The frog starts at the first stone\\n    \\n    // Iterate through each stone and update possible jump lengths\\n    for (let i = 0; i < n; i++) {\\n        const stone = stones[i];\\n        for (const jumpLength of jumpMap.get(stone)) {\\n            for (let k = jumpLength - 1; k <= jumpLength + 1; k++) {\\n                if (k > 0 && jumpMap.has(stone + k)) {\\n                    jumpMap.get(stone + k).add(k);\\n                }\\n            }\\n        }\\n    }\\n    \\n    // Check if the last stone has any valid jump lengths\\n    return jumpMap.get(stones[n - 1]).size > 0;\\n};\\n```\\n```Kotlin []\\nclass Solution {\\n    fun canCross(stones: IntArray): Boolean {\\n        val jumpMap = mutableMapOf<Int, HashSet<Int>>()\\n        \\n        for (stone in stones) {\\n            jumpMap[stone] = HashSet()\\n        }\\n        \\n        jumpMap[0]?.add(0) // The frog starts at position 0 with a jump of size 0\\n        \\n        for (i in stones.indices) {\\n            val currentStone = stones[i]\\n            for (jumpSize in jumpMap[currentStone]!!) {\\n                for (step in -1..1) {\\n                    val nextJumpSize = jumpSize + step\\n                    if (nextJumpSize > 0 && jumpMap.containsKey(currentStone + nextJumpSize)) {\\n                        jumpMap[currentStone + nextJumpSize]?.add(nextJumpSize)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return jumpMap[stones.last()]?.isNotEmpty() ?: false\\n    }\\n}\\n```\\n\\n\\n---\\n![download.jpg](https://assets.leetcode.com/users/images/5196fec2-1dd4-4b82-9700-36c5a0e72623_1692159956.9446952.jpeg)\\n\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Kotlin",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        // Create a hashmap to store possible jump sizes for each stone position\\n        // Key: Stone position, Value: Set of valid jump sizes from that position\\n        unordered_map<int, unordered_set<int>> hashMap;\\n\\n        // Initialize the first stone\\'s jump sizes. Since the frog starts at position 0,\\n        // it can only jump 1 unit to reach the first stone.\\n        hashMap[stones[0] + 1] = {1};\\n\\n        // Iterate through the stones starting from the second stone\\n        for (int i = 1; i < stones.size(); ++i) {\\n            int position = stones[i]; // Current stone\\'s position\\n\\n            // Iterate through the possible jump sizes for the current stone\\'s position\\n            for (auto it : hashMap[position]) {\\n                // For each valid jump size \\'it\\', update the jump sizes for the next stones\\n                \\n                // Jump to the next stone with the same jump size \\'it\\'\\n                hashMap[position + it].insert(it);\\n\\n                // Jump to the next stone with jump size \\'it + 1\\'\\n                hashMap[position + it + 1].insert(it + 1);\\n\\n                // Jump to the next stone with jump size \\'it - 1\\'\\n                hashMap[position + it - 1].insert(it - 1);\\n            }\\n        }\\n        \\n        // If the last stone\\'s position has any valid jump sizes, it means the frog can cross\\n        // the river and reach the last stone\\n        return hashMap[stones.back()].size() != 0;\\n    }\\n};\\n```\n```Typescript []\\nfunction canCross(stones: number[]): boolean {\\n    const jumpMap: Map<number, Set<number>> = new Map();\\n\\n    // Initialize the jumpMap with stone positions\\n    for (const stone of stones) {\\n        jumpMap.set(stone, new Set());\\n    }\\n    jumpMap.get(0).add(0); // The frog starts at position 0 with jump size 0\\n\\n    for (const stone of stones) {\\n        const jumpSizes = jumpMap.get(stone);\\n        \\n        for (const jumpSize of jumpSizes) {\\n            for (let nextJumpSize = jumpSize - 1; nextJumpSize <= jumpSize + 1; nextJumpSize++) {\\n                if (nextJumpSize > 0 && jumpMap.has(stone + nextJumpSize)) {\\n                    jumpMap.get(stone + nextJumpSize).add(nextJumpSize);\\n                }\\n            }\\n        }\\n    }\\n\\n    return jumpMap.get(stones[stones.length - 1]).size > 0;\\n}\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        // Create a hashmap to store jump distances for each stone position\\n        HashMap<Integer, HashSet<Integer>> jumpMap = new HashMap<>();\\n        \\n        // Initialize the hashmap with the first stone\\n        jumpMap.put(0, new HashSet<>());\\n        jumpMap.get(0).add(1); // Frog can jump 1 unit from the first stone\\n        \\n        // Populate the jumpMap for each stone\\n        for (int i = 1; i < stones.length; i++) {\\n            jumpMap.put(stones[i], new HashSet<>());\\n        }\\n        \\n        // Iterate through stones and update jump distances\\n        for (int i = 0; i < stones.length - 1; i++) {\\n            int stonePos = stones[i];\\n            HashSet<Integer> jumpDistances = jumpMap.get(stonePos);\\n            \\n            for (int jumpDistance : jumpDistances) {\\n                int nextPos = stonePos + jumpDistance;\\n                if (nextPos == stones[stones.length - 1]) {\\n                    return true; // Frog can reach the last stone\\n                }\\n                \\n                HashSet<Integer> nextJumpDistances = jumpMap.get(nextPos);\\n                if (nextJumpDistances != null) {\\n                    nextJumpDistances.add(jumpDistance);\\n                    if (jumpDistance > 1) {\\n                        nextJumpDistances.add(jumpDistance - 1);\\n                    }\\n                    nextJumpDistances.add(jumpDistance + 1);\\n                }\\n            }\\n        }\\n        \\n        return false; // Frog cannot reach the last stone\\n    }\\n}\\n```\n```Python []\\nclass Solution(object):\\n    def canCross(self, stones):\\n        n = len(stones)\\n        # Create a dictionary to store the possible jump sizes at each stone.\\n        dp = {stone: set() for stone in stones}\\n        dp[0].add(0)  # The frog starts at the first stone with a jump size of 0.\\n\\n        for stone in stones:\\n            # Iterate through all possible jump sizes at the current stone.\\n            for jump_size in dp[stone]:\\n                # Try the next possible jump sizes for the next stone.\\n                for step in range(jump_size - 1, jump_size + 2):\\n                    if step > 0 and stone + step in dp:\\n                        dp[stone + step].add(step)\\n\\n        # If the last stone has any valid jump sizes, then the frog can cross the river.\\n        return len(dp[stones[-1]]) > 0\\n```\n```Python3 []\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n = len(stones)\\n        \\n        # Create a dictionary to store possible jump lengths at each stone.\\n        # The key is the stone position, and the value is a set of possible jump lengths.\\n        jump_lengths = {stone: set() for stone in stones}\\n        jump_lengths[0].add(0)  # Initial jump\\n        \\n        for stone in stones:\\n            for jump in jump_lengths[stone]:\\n                for next_jump in [jump - 1, jump, jump + 1]:\\n                    if next_jump > 0 and stone + next_jump in jump_lengths:\\n                        jump_lengths[stone + next_jump].add(next_jump)\\n        \\n        # If the last stone has any possible jump lengths, then the frog can cross.\\n        return len(jump_lengths[stones[-1]]) > 0\\n```\n```C# []\\npublic class Solution {\\n    HashSet<int> lookup; // HashSet to quickly check if a stone exists at a certain unit\\n    Dictionary<string, bool> dp; // Memoization dictionary to store computed results\\n\\n    public bool CanCross(int[] stones) {\\n        if (stones[1] != 1)\\n            return false; // If the second stone is not at position 1, the frog can\\'t jump to it\\n\\n        lookup = new HashSet<int>();\\n        dp = new Dictionary<string, bool>();\\n\\n        // Adding stone positions to the lookup HashSet for quick lookup\\n        for (int i = 0; i < stones.Length; i++)\\n            lookup.Add(stones[i]);\\n\\n        // Start the recursive process from the first stone (position 1) with a step of 1\\n        return DetermineCanCross(1, 1, stones[stones.Length - 1]);\\n    }\\n\\n    private bool DetermineCanCross(int reachedUnits, int lastStep, int destination) {\\n        if (!lookup.Contains(reachedUnits))\\n            return false; // If the frog can\\'t land at the reachedUnits, return false\\n\\n        if (reachedUnits == destination)\\n            return true; // If the frog reaches the destination, return true\\n\\n        string localLookup = reachedUnits + \"~\" + lastStep;\\n        if (dp.ContainsKey(localLookup))\\n            return dp[localLookup]; // If the result for this combination of reachedUnits and lastStep is already computed, return it from the memoization dictionary\\n\\n        if (lastStep == 0) {\\n            // The frog can only jump to the next stone with a step of 1\\n            bool computedResult = DetermineCanCross(reachedUnits + 1, 1, destination);\\n            dp.Add(localLookup, computedResult); // Store the computed result in the memoization dictionary\\n            return computedResult;\\n        } else if (lastStep == 1) {\\n            // The frog can jump to the next stone with a step of 1 or 2\\n            bool computedResult = DetermineCanCross(reachedUnits + 1, 1, destination) ||\\n                                  DetermineCanCross(reachedUnits + 2, 2, destination);\\n            dp.Add(localLookup, computedResult);\\n            return computedResult;\\n        } else {\\n            // The frog can jump to the next stone with a step of lastStep - 1, lastStep, or lastStep + 1\\n            bool computedResult = DetermineCanCross(reachedUnits + lastStep - 1, lastStep - 1, destination) ||\\n                                  DetermineCanCross(reachedUnits + lastStep, lastStep, destination) ||\\n                                  DetermineCanCross(reachedUnits + lastStep + 1, lastStep + 1, destination);\\n            dp.Add(localLookup, computedResult);\\n            return computedResult;\\n        }\\n    }\\n}\\n```\n```Javascript []\\nvar canCross = function(stones) {\\n    const n = stones.length;\\n    \\n    // Create a map to store possible jump lengths at each stone\\n    const jumpMap = new Map();\\n    for (const stone of stones) {\\n        jumpMap.set(stone, new Set());\\n    }\\n    jumpMap.get(0).add(0); // The frog starts at the first stone\\n    \\n    // Iterate through each stone and update possible jump lengths\\n    for (let i = 0; i < n; i++) {\\n        const stone = stones[i];\\n        for (const jumpLength of jumpMap.get(stone)) {\\n            for (let k = jumpLength - 1; k <= jumpLength + 1; k++) {\\n                if (k > 0 && jumpMap.has(stone + k)) {\\n                    jumpMap.get(stone + k).add(k);\\n                }\\n            }\\n        }\\n    }\\n    \\n    // Check if the last stone has any valid jump lengths\\n    return jumpMap.get(stones[n - 1]).size > 0;\\n};\\n```\n```Kotlin []\\nclass Solution {\\n    fun canCross(stones: IntArray): Boolean {\\n        val jumpMap = mutableMapOf<Int, HashSet<Int>>()\\n        \\n        for (stone in stones) {\\n            jumpMap[stone] = HashSet()\\n        }\\n        \\n        jumpMap[0]?.add(0) // The frog starts at position 0 with a jump of size 0\\n        \\n        for (i in stones.indices) {\\n            val currentStone = stones[i]\\n            for (jumpSize in jumpMap[currentStone]!!) {\\n                for (step in -1..1) {\\n                    val nextJumpSize = jumpSize + step\\n                    if (nextJumpSize > 0 && jumpMap.containsKey(currentStone + nextJumpSize)) {\\n                        jumpMap[currentStone + nextJumpSize]?.add(nextJumpSize)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return jumpMap[stones.last()]?.isNotEmpty() ?: false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964711,
                "title": "daily-leetcoding-challenge-august-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/frog-jump/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-Down Dynamic Programming\n\n  \n**Approach 2:** Bottom-up Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/frog-jump/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3686569,
                "title": "striver-method-easy-c-heavily-commented-explaination-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\non each stone we have the chance to choose the power by which we can jump and which possible stone to jump to.\\nAnd if we have choices to select, why not try to think in a Recursive way?\\nRemember the N-Queens problem?\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfrom each stone we will try to jump with power = {power -1 or power or power + 1} as per the question stated, and try to reach any of the next stones\\npower here means \\'k\\' from the question\\nwe do this repeatedly untill the last index is found. \\nIf it cannot reach last index and is stuck at a stone, we go back and check from the previously stepped stone with a greater power\\n\\n\\ngo through the comments and understand the code for better understanding\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O( 3 X n X n ) = O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(n^2)\\n\\n# Recursive Code (TLE)\\n```\\nclass Solution {\\npublic:\\n    bool rec(int from, int power, vector<int>& stones){\\n        // if last index of the stone is reached, we got our solution\\n        if(from == stones.size()-1)    return true;\\n\\n        //from our \\'from\\' pointer with val = power-1 or power or power +1  (loop 1),   \\n        //we loop and check for any possible stones on which we can jump    (loop 2)\\n        for(int val = power-1;val<=power+1;val++){\\n            for(int to = from+1;to<stones.size();to++){\\n\\n                // the difference stones[to] - stones[from] gives the calculated value\\n                // if the calculated values is more than the power permitted, there is no need\\n                // to check for further stones while holding the current power\\n                // increase power and check for other stones\\n                if(stones[to] - stones[from] > val)   \\n                    break;\\n\\n                // if a suitable stone is found \\n                if(stones[to]-stones[from] == val){\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"from step \"<<stones[ind]<<\" jumped to  \"<<stones[k]<<\" with power \"<<val<<endl;\\n\\n                    // check for next stones, if answer found, return true\\n                    if(rec(to, val, stones))   return true;\\n\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"going back to \"<<stones[k]<<\" cause ans not found\\\\n\";\\n                 \\n                }           \\n            }\\n        }\\n        return   false;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        return rec(0, 0, stones);   //(from, initial power, stones)\\n    }\\n};\\n```\\n\\n# Applying Memorization (ACCEPTED)\\n## dont get bothered by the long code, just go through the comments and surely, u will get the idea ;-)\\ndp[from][power] tells whether it is possible to to reach the ending stone with jump_power = power from stone at index = from\\n.\\n\\n```\\nclass Solution {\\npublic:\\n    bool rec(int from, int power, vector<int>& stones, vector<vector<int>>&dp){\\n        // if last index of the stone is reached, we got our solution\\n        if(from == stones.size()-1)    return true;\\n\\n        if(dp[from][power] != -1)  //if previously visited, return its val\\n            return dp[from][power];\\n\\n        //from our \\'from\\' pointer with val = power-1 or power or power +1  (loop 1),   \\n        //we loop and check for any possible stones on which we can jump    (loop 2)\\n        for(int val = power-1;val<=power+1;val++){\\n            for(int to = from+1;to<stones.size();to++){\\n\\n                // the difference stones[to] - stones[from] gives the calculated value\\n                // if the calculated values is more than the power permitted, there is no need\\n                // to check for further stones while holding the current power\\n                // increase power and check for other stones\\n                if(stones[to] - stones[from] > val)   \\n                    break;\\n\\n                // if a suitable stone is found \\n                if(stones[to]-stones[from] == val){\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"from step \"<<stones[ind]<<\" jumped to  \"<<stones[k]<<\" with power \"<<val<<endl;\\n\\n                    // check for next stones, if answer found, return true\\n                    if(rec(to, val, stones, dp))   return dp[from][power] = true;\\n\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"going back to \"<<stones[k]<<\" cause ans not found\\\\n\";\\n                 \\n                }           \\n            }\\n        }\\n        return  dp[from][power] =  false;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return rec(0, 0, stones, dp);   //(from, initial power, stones, dp)\\n    }\\n};\\n```\\n\\n# Upvote if it helped ;)\\n.\\n.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(int from, int power, vector<int>& stones){\\n        // if last index of the stone is reached, we got our solution\\n        if(from == stones.size()-1)    return true;\\n\\n        //from our \\'from\\' pointer with val = power-1 or power or power +1  (loop 1),   \\n        //we loop and check for any possible stones on which we can jump    (loop 2)\\n        for(int val = power-1;val<=power+1;val++){\\n            for(int to = from+1;to<stones.size();to++){\\n\\n                // the difference stones[to] - stones[from] gives the calculated value\\n                // if the calculated values is more than the power permitted, there is no need\\n                // to check for further stones while holding the current power\\n                // increase power and check for other stones\\n                if(stones[to] - stones[from] > val)   \\n                    break;\\n\\n                // if a suitable stone is found \\n                if(stones[to]-stones[from] == val){\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"from step \"<<stones[ind]<<\" jumped to  \"<<stones[k]<<\" with power \"<<val<<endl;\\n\\n                    // check for next stones, if answer found, return true\\n                    if(rec(to, val, stones))   return true;\\n\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"going back to \"<<stones[k]<<\" cause ans not found\\\\n\";\\n                 \\n                }           \\n            }\\n        }\\n        return   false;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        return rec(0, 0, stones);   //(from, initial power, stones)\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool rec(int from, int power, vector<int>& stones, vector<vector<int>>&dp){\\n        // if last index of the stone is reached, we got our solution\\n        if(from == stones.size()-1)    return true;\\n\\n        if(dp[from][power] != -1)  //if previously visited, return its val\\n            return dp[from][power];\\n\\n        //from our \\'from\\' pointer with val = power-1 or power or power +1  (loop 1),   \\n        //we loop and check for any possible stones on which we can jump    (loop 2)\\n        for(int val = power-1;val<=power+1;val++){\\n            for(int to = from+1;to<stones.size();to++){\\n\\n                // the difference stones[to] - stones[from] gives the calculated value\\n                // if the calculated values is more than the power permitted, there is no need\\n                // to check for further stones while holding the current power\\n                // increase power and check for other stones\\n                if(stones[to] - stones[from] > val)   \\n                    break;\\n\\n                // if a suitable stone is found \\n                if(stones[to]-stones[from] == val){\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"from step \"<<stones[ind]<<\" jumped to  \"<<stones[k]<<\" with power \"<<val<<endl;\\n\\n                    // check for next stones, if answer found, return true\\n                    if(rec(to, val, stones, dp))   return dp[from][power] = true;\\n\\n                    // uncomment the below comment to understand the jump flow fromt stone\\n                    // cout<<\"going back to \"<<stones[k]<<\" cause ans not found\\\\n\";\\n                 \\n                }           \\n            }\\n        }\\n        return  dp[from][power] =  false;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return rec(0, 0, stones, dp);   //(from, initial power, stones, dp)\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3677093,
                "title": "simple-top-down-and-bottom-up-dp-solutions",
                "content": "# Top Down (memoization with recursion)\\n```\\n# python\\n```\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if(stones[1]-stones[0]!=1):\\n            return False\\n        if(len(stones)==2):\\n            if stones[0]==0 and stones[1]==1:\\n                return True\\n        dp={}\\n        def cross(stones,curr,k,i):\\n            if curr>stones[len(stones)-1]:\\n                return False\\n            if curr==stones[len(stones)-1]:\\n                return True\\n            if (curr,k) in dp:\\n                return dp[(curr,k)]\\n            if curr in stones[i:]:\\n                dp[(curr+k-1,k-1)]=cross(stones,curr+k-1,k-1,i+1)\\n                dp[(curr+k,k)]=cross(stones,curr+k,k,i+1)\\n                dp[(curr+k+1,k+1)]=cross(stones,curr+k+1,k+1,i+1)\\n            else:\\n                return False\\n        cross(stones,stones[1],1,1)\\n        return any(value for value in dp.values())\\n```\\n# Bottom Up (tabulation)\\n```\\n# python\\n```\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1] - stones[0] != 1:\\n            return False\\n        if len(stones) == 2:\\n            if stones[0] == 0 and stones[1] == 1:\\n                return True\\n        dp={}\\n        for stone in stones:\\n            dp[stone]=set()\\n        dp[0].add(0)\\n        for stone in stones:\\n            for k in dp[stone]:\\n                if k-1>0 and stone+k-1 in dp:\\n                    dp[stone+k-1].add(k-1)\\n                if stone+k in dp:\\n                    dp[stone+k].add(k)\\n                if stone+k+1 in dp:\\n                    dp[stone+k+1].add(k+1)\\n        return len(dp[stones[-1]])>0\\n        \\n```\\n```\\n# java\\n```\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        if(stones[1]-stones[0]!=1) return false;\\n        if(stones.length==1){\\n            if(stones[1]-stones[0]==1) return true;\\n        }\\n        HashMap<Integer,HashSet<Integer>> dp=new HashMap<>();\\n        for(int x:stones){\\n            dp.put(x,new HashSet<>());\\n        }\\n        dp.get(0).add(0);\\n        for(int x:stones){\\n            for(int k:dp.get(x)){\\n                if(k-1>0&&dp.containsKey(x+k-1)){\\n                    dp.get(x+k-1).add(k-1);\\n                }\\n                if(dp.containsKey(x+k)){\\n                    dp.get(x+k).add(k);\\n                }\\n                if(dp.containsKey(x+k+1)){\\n                    dp.get(x+k+1).add(k+1);\\n                }\\n            }\\n        }\\n        return dp.get(stones[stones.length-1]).size()>0;\\n    }\\n}\\n```\\n### let me know if you were able to get a solution in java without tle using top-down approach",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n# python\\n```\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if(stones[1]-stones[0]!=1):\\n            return False\\n        if(len(stones)==2):\\n            if stones[0]==0 and stones[1]==1:\\n                return True\\n        dp={}\\n        def cross(stones,curr,k,i):\\n            if curr>stones[len(stones)-1]:\\n                return False\\n            if curr==stones[len(stones)-1]:\\n                return True\\n            if (curr,k) in dp:\\n                return dp[(curr,k)]\\n            if curr in stones[i:]:\\n                dp[(curr+k-1,k-1)]=cross(stones,curr+k-1,k-1,i+1)\\n                dp[(curr+k,k)]=cross(stones,curr+k,k,i+1)\\n                dp[(curr+k+1,k+1)]=cross(stones,curr+k+1,k+1,i+1)\\n            else:\\n                return False\\n        cross(stones,stones[1],1,1)\\n        return any(value for value in dp.values())\\n```\n```\\n# python\\n```\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1] - stones[0] != 1:\\n            return False\\n        if len(stones) == 2:\\n            if stones[0] == 0 and stones[1] == 1:\\n                return True\\n        dp={}\\n        for stone in stones:\\n            dp[stone]=set()\\n        dp[0].add(0)\\n        for stone in stones:\\n            for k in dp[stone]:\\n                if k-1>0 and stone+k-1 in dp:\\n                    dp[stone+k-1].add(k-1)\\n                if stone+k in dp:\\n                    dp[stone+k].add(k)\\n                if stone+k+1 in dp:\\n                    dp[stone+k+1].add(k+1)\\n        return len(dp[stones[-1]])>0\\n        \\n```\n```\\n# java\\n```\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        if(stones[1]-stones[0]!=1) return false;\\n        if(stones.length==1){\\n            if(stones[1]-stones[0]==1) return true;\\n        }\\n        HashMap<Integer,HashSet<Integer>> dp=new HashMap<>();\\n        for(int x:stones){\\n            dp.put(x,new HashSet<>());\\n        }\\n        dp.get(0).add(0);\\n        for(int x:stones){\\n            for(int k:dp.get(x)){\\n                if(k-1>0&&dp.containsKey(x+k-1)){\\n                    dp.get(x+k-1).add(k-1);\\n                }\\n                if(dp.containsKey(x+k)){\\n                    dp.get(x+k).add(k);\\n                }\\n                if(dp.containsKey(x+k+1)){\\n                    dp.get(x+k+1).add(k+1);\\n                }\\n            }\\n        }\\n        return dp.get(stones[stones.length-1]).size()>0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355903,
                "title": "memoization-using-hashmap-dp-c",
                "content": "```\\nclass Solution {\\n    bool dfs(int i, int k, int n, vector<int> &stones, unordered_map<int, int> &m, map<pair<int, int>, bool> &dp) {\\n        if(i >= n - 1) return true;\\n        if(dp.find({i, k}) != dp.end()) return dp[{i, k}];\\n\\n        if(k - 1 > 0 && m.find(stones[i] + k - 1) != m.end()) {\\n            if(dfs(m[stones[i] + k - 1], k - 1, n, stones, m, dp)) return dp[{i, k}] = 1;\\n        }\\n        if(k > 0 && m.find(stones[i] + k) != m.end()) {\\n            if(dfs(m[stones[i] + k], k, n, stones, m, dp)) return dp[{i, k}] = 1;\\n        }\\n        if(m.find(stones[i] + k + 1) != m.end()) {\\n            if(dfs(m[stones[i] + k + 1], k + 1, n, stones, m, dp)) return dp[{i, k}] = 1;\\n        }\\n        return dp[{i, k}] = 0;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++) m[stones[i]] = i;\\n        \\n        map<pair<int, int>, bool> dp;\\n        return dfs(0, 0, n, stones, m, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    bool dfs(int i, int k, int n, vector<int> &stones, unordered_map<int, int> &m, map<pair<int, int>, bool> &dp) {\\n        if(i >= n - 1) return true;\\n        if(dp.find({i, k}) != dp.end()) return dp[{i, k}];\\n\\n        if(k - 1 > 0 && m.find(stones[i] + k - 1) != m.end()) {\\n            if(dfs(m[stones[i] + k - 1], k - 1, n, stones, m, dp)) return dp[{i, k}] = 1;\\n        }\\n        if(k > 0 && m.find(stones[i] + k) != m.end()) {\\n            if(dfs(m[stones[i] + k], k, n, stones, m, dp)) return dp[{i, k}] = 1;\\n        }\\n        if(m.find(stones[i] + k + 1) != m.end()) {\\n            if(dfs(m[stones[i] + k + 1], k + 1, n, stones, m, dp)) return dp[{i, k}] = 1;\\n        }\\n        return dp[{i, k}] = 0;\\n    }\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map<int, int> m;\\n        for(int i=0; i<n; i++) m[stones[i]] = i;\\n        \\n        map<pair<int, int>, bool> dp;\\n        return dfs(0, 0, n, stones, m, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306645,
                "title": "c-easy-to-undersatnd-dp-solution-memoization-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[2001][2005];\\n    bool f(vector<int>& nums,int i ,int jump)\\n    {\\n        if(i==nums.size())return false;\\n        if(i==nums.size()-1)return true;\\n        if(dp[i][jump]!=-1)return dp[i][jump];\\n        bool x=false,y=false,z=false;\\n        for(int j=i+1;j<nums.size();j++)\\n        {\\n            if(nums[j]-nums[i]==jump)\\n            {\\n                x|=f(nums,j,jump);\\n            }\\n            if(nums[j]-nums[i]==jump+1)\\n            {\\n                y|=f(nums,j,jump+1);\\n            }\\n            if(nums[j]-nums[i]==jump-1)\\n            {\\n                z|=f(nums,j,jump-1);\\n            }\\n        }\\n        return  dp[i][jump] =  x||y||z;\\n\\n    }\\n    bool canCross(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n       return f(nums,0,0); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[2001][2005];\\n    bool f(vector<int>& nums,int i ,int jump)\\n    {\\n        if(i==nums.size())return false;\\n        if(i==nums.size()-1)return true;\\n        if(dp[i][jump]!=-1)return dp[i][jump];\\n        bool x=false,y=false,z=false;\\n        for(int j=i+1;j<nums.size();j++)\\n        {\\n            if(nums[j]-nums[i]==jump)\\n            {\\n                x|=f(nums,j,jump);\\n            }\\n            if(nums[j]-nums[i]==jump+1)\\n            {\\n                y|=f(nums,j,jump+1);\\n            }\\n            if(nums[j]-nums[i]==jump-1)\\n            {\\n                z|=f(nums,j,jump-1);\\n            }\\n        }\\n        return  dp[i][jump] =  x||y||z;\\n\\n    }\\n    bool canCross(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n       return f(nums,0,0); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187730,
                "title": "very-simple-memoization",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nWe need is solve recursively All states where states contain {index and k} \\nso for this index if we have solved for k units then we do not need \\nto solve this so we return dp[{ind,k}] \\nFor every index we have to find if there is stone at st[ind] + k units\\nor k + 1 units or k-1 units . and if it is present then jump on it.\\n```\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,bool> dp;\\n    bool sol(vector<int>& st, int ind, int k){\\n        if(ind == st.size()-1) return 1;\\n        if(dp.find({ind,k}) != dp.end()) return dp[{ind,k}];\\n        // Now we can either jump to k-1, k , k+1\\n        int i = lower_bound(st.begin(),st.end(),st[ind]+k) - st.begin(); // if we jump k units\\n        bool ans = 0;\\n        if(i != st.size() && st[i] == st[ind]+k) ans = sol(st,i,k);\\n        if(ans) return dp[{ind,k}] = 1;\\n        if(k-1 != 0){  // as this can create loops\\n            i = lower_bound(st.begin(),st.end(),st[ind]+k-1) - st.begin();\\n            if(i != st.size() && st[i] == st[ind]+k-1) ans = sol(st,i,k-1);\\n            if(ans) return dp[{ind,k}] = 1;\\n        }\\n        i = lower_bound(st.begin(),st.end(),st[ind]+k+1) - st.begin();\\n        if(i != st.size() && st[i] == st[ind]+k+1) ans = sol(st,i,k+1);\\n        return dp[{ind,k}] = ans;\\n    }\\n\\n    bool canCross(vector<int>& st){\\n        if(st[1] != 1) return 0;\\n        return sol(st,1,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nWe need is solve recursively All states where states contain {index and k} \\nso for this index if we have solved for k units then we do not need \\nto solve this so we return dp[{ind,k}] \\nFor every index we have to find if there is stone at st[ind] + k units\\nor k + 1 units or k-1 units . and if it is present then jump on it.\\n```\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,bool> dp;\\n    bool sol(vector<int>& st, int ind, int k){\\n        if(ind == st.size()-1) return 1;\\n        if(dp.find({ind,k}) != dp.end()) return dp[{ind,k}];\\n        // Now we can either jump to k-1, k , k+1\\n        int i = lower_bound(st.begin(),st.end(),st[ind]+k) - st.begin(); // if we jump k units\\n        bool ans = 0;\\n        if(i != st.size() && st[i] == st[ind]+k) ans = sol(st,i,k);\\n        if(ans) return dp[{ind,k}] = 1;\\n        if(k-1 != 0){  // as this can create loops\\n            i = lower_bound(st.begin(),st.end(),st[ind]+k-1) - st.begin();\\n            if(i != st.size() && st[i] == st[ind]+k-1) ans = sol(st,i,k-1);\\n            if(ans) return dp[{ind,k}] = 1;\\n        }\\n        i = lower_bound(st.begin(),st.end(),st[ind]+k+1) - st.begin();\\n        if(i != st.size() && st[i] == st[ind]+k+1) ans = sol(st,i,k+1);\\n        return dp[{ind,k}] = ans;\\n    }\\n\\n    bool canCross(vector<int>& st){\\n        if(st[1] != 1) return 0;\\n        return sol(st,1,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034306,
                "title": "recursion-memoization-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    map<int,int> m;\\n    int dp[2011][2011];\\n    bool f(vector<int>& stones, int i, int k, int n)\\n    {\\n        if(i==n-1) return true;\\n        if(k==0 || i>=n) return false;\\n        if(m.find(stones[i]+k)==m.end()) return false;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        return dp[i][k]=(f(stones,m[stones[i]+k],k,n) || f(stones,m[stones[i]+k],k+1,n) || f(stones,m[stones[i]+k],k-1,n));\\n    }\\n    bool canCross(vector<int>& stones) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=stones.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            m[stones[x]]=x;\\n        }\\n        return f(stones,0,1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    map<int,int> m;\\n    int dp[2011][2011];\\n    bool f(vector<int>& stones, int i, int k, int n)\\n    {\\n        if(i==n-1) return true;\\n        if(k==0 || i>=n) return false;\\n        if(m.find(stones[i]+k)==m.end()) return false;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        return dp[i][k]=(f(stones,m[stones[i]+k],k,n) || f(stones,m[stones[i]+k],k+1,n) || f(stones,m[stones[i]+k],k-1,n));\\n    }\\n    bool canCross(vector<int>& stones) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        int n=stones.size();\\n        for(int x=0; x<n; x++)\\n        {\\n            m[stones[x]]=x;\\n        }\\n        return f(stones,0,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796550,
                "title": "my-own-java-code-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canCross(int[] a) {\\n            if(a[1] != 1) return false;\\n            if(a.length == 2) return true;\\n            int last_stone = a[a.length-1];\\n            int length = a.length;\\n            Map<Integer , Integer> map = new HashMap<>();\\n            for(int i=0;i<length;i++) map.put(a[i] , i);\\n            boolean dp[][] = new boolean [length][length];\\n            dp[0][1] = true;\\n            for(int i=0;i<length;i++){\\n                for(int j=i;j<length;j++){\\n                    if(dp[i][j]){\\n                        int jump = a[j]-a[i];\\n                        for(int next_step = jump-1;next_step<=jump+1;next_step++){\\n                            if(next_step<=0) continue;\\n                            int next_stone = a[j] + next_step;\\n                            if(a[j] != next_stone && map.containsKey(next_stone)){\\n                                dp[j][map.get(next_stone)] = true;\\n                                if(next_stone == last_stone) return true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] a) {\\n            if(a[1] != 1) return false;\\n            if(a.length == 2) return true;\\n            int last_stone = a[a.length-1];\\n            int length = a.length;\\n            Map<Integer , Integer> map = new HashMap<>();\\n            for(int i=0;i<length;i++) map.put(a[i] , i);\\n            boolean dp[][] = new boolean [length][length];\\n            dp[0][1] = true;\\n            for(int i=0;i<length;i++){\\n                for(int j=i;j<length;j++){\\n                    if(dp[i][j]){\\n                        int jump = a[j]-a[i];\\n                        for(int next_step = jump-1;next_step<=jump+1;next_step++){\\n                            if(next_step<=0) continue;\\n                            int next_stone = a[j] + next_step;\\n                            if(a[j] != next_stone && map.containsKey(next_stone)){\\n                                dp[j][map.get(next_stone)] = true;\\n                                if(next_stone == last_stone) return true;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641374,
                "title": "python3-dp-memoization-solution-bgg",
                "content": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n\\n        def solve(i,k):\\n            if i >= len(stones)-1:\\n                return True\\n            if (i,k) in memo:\\n                return memo[(i,k)]\\n            else:\\n                x = stones[i] + k\\n                a,b,c = False,False,False\\n                if x in dic:\\n                    a = solve(dic[x],k)\\n                if k > 1 and x-1 in dic:\\n                    b = solve(dic[x-1],k-1)\\n                if x+1 in dic:\\n                    c = solve(dic[x+1],k+1)\\n            memo[(i,k)] = a or b or c\\n            return a or b or c\\n        if stones[1] != 1:\\n            return False\\n        dic = {}\\n        for i in range(len(stones)):\\n            dic[stones[i]] = i\\n        memo ={}\\n        return solve(1,1)\\n# Please upvote if you understand the solution",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n\\n        def solve(i,k):\\n            if i >= len(stones)-1:\\n                return True\\n            if (i,k) in memo:\\n                return memo[(i,k)]\\n            else:\\n                x = stones[i] + k\\n                a,b,c = False,False,False\\n                if x in dic:\\n                    a = solve(dic[x],k)\\n                if k > 1 and x-1 in dic:\\n                    b = solve(dic[x-1],k-1)\\n                if x+1 in dic:\\n                    c = solve(dic[x+1],k+1)\\n            memo[(i,k)] = a or b or c\\n            return a or b or c\\n        if stones[1] != 1:\\n            return False\\n        dic = {}",
                "codeTag": "Java"
            },
            {
                "id": 2545268,
                "title": "c-dp-memoization-easy-explanation",
                "content": "/*\\n    Intuition:\\n    \\n    Memoization:\\n    \\n    Step 1:\\n    Put everything in terms of indexes\\n    So, here we basically have 2 variables:\\n    Position index of stones vector -> ind\\n    Number of hops made -> k\\n    \\n    So, basically we are going to need a 2D vector for memoization for we have two variables\\n    \\n    Step 2: \\n    Set the boundary/base condition\\n    \\n    So, basically we need to return the moment we land on to the last stone\\n    Here, we need to make sure that while exploring we should only make possible hops\\n    \\n    Step 3:\\n    Explore all possibilities\\n    Here, we need to understand that the array is sorted\\n    So, if all are 0s still we will be able to move to the last index as we are starting with K = 0\\n    \\n    Possibility 1: We can move with K - 1\\n    check if we can move to any stone with (K - 1) hop then move to that stone and check if we can reach end from there\\n    \\n    Possibility 2: We can move with K\\n    check if we can move to any stone with (K) hop then move to that stone and check if we can reach end from there\\n    \\n    Possibility 3: We can move with K + 1\\n    check if we can move to any stone with (K + 1) hop then move to that stone and check if we can reach end from there\\n    \\n    Now,\\n    we\\'ll be needing a loop to explore these 3 possibilities while at any index\\n    \\n    Step 4:\\n    Return if it is possible, while making sure to update the combination of Position index (ind) and Hop (K)\\n    in our dp matrix\\n    \\n    PS:\\n    Tabulation solutions are already present in discussions\\n    at the same time, will be uploading the Tabulation solution as well soon\\n    \\n*/\\n\\n\\nclass Solution {\\n\\npublic:\\n    \\n    bool checkLast(int ind, int k, int n, vector<int>& stones, vector<vector<int>> &dp)\\n    {\\n        if(ind == n-1)\\n            return true;\\n        \\n        if(dp[ind][k] != -1)\\n            return dp[ind][k];            \\n\\n        bool out = false;\\n        for(int fInd = ind + 1; fInd < n; fInd++)\\n        {\\n            if(stones[fInd] == stones[ind] + k - 1)\\n                out = out | checkLast(fInd, k - 1, n, stones, dp);\\n            else if(stones[fInd] == stones[ind] + k)\\n                out = out | checkLast(fInd, k, n, stones, dp);\\n            else if(stones[fInd] == stones[ind] + k + 1)\\n                out = out | checkLast(fInd, k + 1, n, stones, dp);\\n            if(out)\\n                return dp[ind][k] = 1;\\n        }\\n                \\n        return dp[ind][k] = 0;\\n    }\\n    \\n    bool canCross(vector<int>& stones) \\n    {\\n        int n = stones.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return checkLast(0, 0, n, stones, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\npublic:\\n    \\n    bool checkLast(int ind, int k, int n, vector<int>& stones, vector<vector<int>> &dp)\\n    {\\n        if(ind == n-1)\\n            return true;\\n        \\n        if(dp[ind][k] != -1)\\n            return dp[ind][k];            \\n\\n        bool out = false;\\n        for(int fInd = ind + 1; fInd < n; fInd++)\\n        {\\n            if(stones[fInd] == stones[ind] + k - 1)\\n                out = out | checkLast(fInd, k - 1, n, stones, dp);\\n            else if(stones[fInd] == stones[ind] + k)\\n                out = out | checkLast(fInd, k, n, stones, dp);\\n            else if(stones[fInd] == stones[ind] + k + 1)\\n                out = out | checkLast(fInd, k + 1, n, stones, dp);\\n            if(out)\\n                return dp[ind][k] = 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2478611,
                "title": "easy-c-solution-proper-naming",
                "content": "````\\nclass Solution {\\npublic:\\n    \\n    bool helper(int idx,int prev,vector<int>&stones,unordered_map<int,int>&m,vector<vector<int>>&dp)\\n    {\\n        if(idx>=stones.size())return false;\\n        if(idx==stones.size()-1)return true;\\n        \\n        if(dp[idx][prev]!=-1)return dp[idx][prev];\\n        \\n        for(int i=-1;i<=1;i++)\\n        {\\n            int next_jump_size=i+prev;\\n            int cur_pos=stones[idx];\\n            \\n            int next_pos=cur_pos+next_jump_size;\\n            \\n            if(m.find(next_pos)!=m.end() && m[next_pos]>idx)\\n            {\\n                if(helper(m[next_pos],next_jump_size,stones,m,dp))return dp[idx][prev]=true;\\n            }\\n            \\n        }\\n        \\n        return dp[idx][prev]=false;\\n    }\\n    \\n    \\n    bool canCross(vector<int>& stones) {\\n        \\n        int n=stones.size();\\n        long long int sum=0;\\n        unordered_map<int,int>m;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=stones[i];\\n            m[stones[i]]=i;\\n        }\\n        \\n        if(n>1 && stones [1]!=1)return false;\\n    \\n        \\n        vector<vector<int>>dp(2000,vector<int>(2000,-1));\\n        return helper(1,1,stones,m,dp);\\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool helper(int idx,int prev,vector<int>&stones,unordered_map<int,int>&m,vector<vector<int>>&dp)\\n    {\\n        if(idx>=stones.size())return false;\\n        if(idx==stones.size()-1)return true;\\n        \\n        if(dp[idx][prev]!=-1)return dp[idx][prev];\\n        \\n        for(int i=-1;i<=1;i++)\\n        {\\n            int next_jump_size=i+prev;\\n            int cur_pos=stones[idx];\\n            \\n            int next_pos=cur_pos+next_jump_size;\\n            \\n            if(m.find(next_pos)!=m.end() && m[next_pos]>idx)\\n            {\\n                if(helper(m[next_pos],next_jump_size,stones,m,dp))return dp[idx][prev]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2399354,
                "title": "c-recursive-memoized-code-easy-to-understand-commented",
                "content": "class Solution {\\npublic:\\n*     bool canCross(vector<int>& stones) {\\n        if(stones[1] > 1)  // If stones[i] is greater than 1 then we won\\'t be able to make the first jump so we return false\\n        {\\n            return false;\\n        }\\n        set<int>st;  // Set to store values where the stones are \\n        for(int i = 0;i < stones.size(); i++)\\n        {\\n            st.insert(stones[i]);\\n        }\\n        map<pair<int,int>,int>dp;\\n        return solve(stones, 1, 1, st, dp);\\n    }\\n    \\n*     bool solve(vector<int>& stones, int curr, int lastjump, set<int>& st, map<pair<int,int>,int>& dp){\\n        if(curr > stones[stones.size()-1])  // If we reach ahead the last stone we return false\\n        {\\n            return false;\\n        }\\n        if(curr == stones[stones.size()-1])  // If we reach the last stone we return true\\n        {\\n            return true;\\n        }\\n        if(dp.find({curr,lastjump}) != dp.end())\\n        {\\n            return dp[{curr,lastjump}];\\n        }\\n        // Standing at any stone we have 3 possiblities. To take k-1 jump, k jump or k+1 jump to next stone so we\\'ll try all the possiblities and if any of them returns true we return a true or else we return false. Make sure you don\\'t take 0 jump so check that while taking k-1 jumps\\n        if(lastjump-1 != 0 && st.find(curr+(lastjump-1)) != st.end())\\n        {\\n            if(solve(stones, curr+(lastjump-1), lastjump-1, st, dp))\\n            {\\n                return dp[{curr,lastjump}] = true;\\n            }\\n        }\\n        if(st.find(curr+lastjump) != st.end())\\n        {\\n            if(solve(stones, curr+lastjump, lastjump, st, dp))\\n            {\\n                return dp[{curr, lastjump}] = true;\\n            }\\n        }\\n        if(st.find(curr+lastjump+1) != st.end())\\n        {\\n            if(solve(stones, curr+lastjump+1, lastjump+1, st, dp))\\n            {\\n                return dp[{curr, lastjump}] = true;\\n            }\\n        }\\n        return dp[{curr, lastjump}] = false;\\n    }\\n};\\n**Do upvote if you understood it !**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n*     bool canCross(vector<int>& stones) {\\n        if(stones[1] > 1)  // If stones[i] is greater than 1 then we won\\'t be able to make the first jump so we return false\\n        {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2373673,
                "title": "c-solution-time-o-n-memory-o-n-beats-100-recursion-memoization",
                "content": "```C#\\npublic class Solution {\\n    private static readonly int[] _jumpAdditives = new [] { -1, 0, 1 };\\n    \\n    public bool CanCross(int[] stones) {\\n        HashSet<int> stonesSet = new HashSet<int>(stones);\\n        HashSet<(int Stone, int Jump)> memo = new HashSet<(int Stone, int Jump)>(); // Store the unsuccessful jump attempts.\\n        int end = stones[^1];\\n        \\n        return Solve(0, 1);\\n        \\n        bool Solve(int stoneVal, int jumpLength) {\\n            int destination = stoneVal + jumpLength;\\n            if (jumpLength == 0 || !stonesSet.Contains(destination)) return false;\\n            if (destination == end) return true;\\n            \\n            var memoKey = (destination, jumpLength);\\n            if (memo.Contains(memoKey)) return false;\\n            \\n            for (int i = 0; i < _jumpAdditives.Length; i++) {\\n                int nextJumpLength = jumpLength + _jumpAdditives[i];\\n                if (Solve(destination, nextJumpLength)) return true;\\n            }\\n            \\n            memo.Add(memoKey);\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```C#\\npublic class Solution {\\n    private static readonly int[] _jumpAdditives = new [] { -1, 0, 1 };\\n    \\n    public bool CanCross(int[] stones) {\\n        HashSet<int> stonesSet = new HashSet<int>(stones);\\n        HashSet<(int Stone, int Jump)> memo = new HashSet<(int Stone, int Jump)>(); // Store the unsuccessful jump attempts.\\n        int end = stones[^1];\\n        \\n        return Solve(0, 1);\\n        \\n        bool Solve(int stoneVal, int jumpLength) {\\n            int destination = stoneVal + jumpLength;\\n            if (jumpLength == 0 || !stonesSet.Contains(destination)) return false;\\n            if (destination == end) return true;\\n            \\n            var memoKey = (destination, jumpLength);\\n            if (memo.Contains(memoKey)) return false;\\n            \\n            for (int i = 0; i < _jumpAdditives.Length; i++) {\\n                int nextJumpLength = jumpLength + _jumpAdditives[i];\\n                if (Solve(destination, nextJumpLength)) return true;\\n            }\\n            \\n            memo.Add(memoKey);\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368357,
                "title": "c-easy-approach-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n       unordered_map<int,bool>mp;  //to see the position where stone is present\\n       for(int i=0;i<stones.size();i++)\\n       {\\n           mp[stones[i]]=true;\\n       }\\n       int stone=1; //current stone\\n       int jump=1;  //jump made\\n       int last_stone=stones[stones.size()-1]; //last stone on which frog will land to cross river\\n       map<pair<int,int>,bool>dp;\\n       return fun(mp,stone,jump,dp,last_stone);\\n    }\\n    bool fun( unordered_map<int,bool>&mp,int stone,int jump,map<pair<int,int>,bool>&dp,int &ls)\\n    {\\n        if(stone==ls)  //reached last stone\\n        {\\n            return true;\\n        }\\n        if(mp.find(stone)==mp.end()) //stone is not present \\n        {\\n            return false;\\n        }\\n        if(dp.find({stone,jump})!=dp.end())\\n        {\\n            return dp[{stone,jump}];\\n        }\\n        bool jump1=false;\\n        bool jump2=false;\\n        bool jump3=false;\\n        if((stone+jump-1)>stone)  //can take jump of k-1 units\\n        {\\n            jump1=fun(mp,stone+jump-1,jump-1,dp,ls);\\n        }\\n        if((stone+jump)>stone)  //can take jump of k units\\n        {\\n            jump2=fun(mp,stone+jump,jump,dp,ls);\\n        }\\n        if((stone+jump+1)>stone)   //can take jump of k+1 units\\n        {\\n            jump3=fun(mp,stone+jump+1,jump+1,dp,ls);\\n        }\\n        dp[{stone,jump}]=jump1 or jump2 or jump3;\\n        return dp[{stone,jump}];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n       unordered_map<int,bool>mp;  //to see the position where stone is present\\n       for(int i=0;i<stones.size();i++)\\n       {\\n           mp[stones[i]]=true;\\n       }\\n       int stone=1; //current stone\\n       int jump=1;  //jump made\\n       int last_stone=stones[stones.size()-1]; //last stone on which frog will land to cross river\\n       map<pair<int,int>,bool>dp;\\n       return fun(mp,stone,jump,dp,last_stone);\\n    }\\n    bool fun( unordered_map<int,bool>&mp,int stone,int jump,map<pair<int,int>,bool>&dp,int &ls)\\n    {\\n        if(stone==ls)  //reached last stone\\n        {\\n            return true;\\n        }\\n        if(mp.find(stone)==mp.end()) //stone is not present \\n        {\\n            return false;\\n        }\\n        if(dp.find({stone,jump})!=dp.end())\\n        {\\n            return dp[{stone,jump}];\\n        }\\n        bool jump1=false;\\n        bool jump2=false;\\n        bool jump3=false;\\n        if((stone+jump-1)>stone)  //can take jump of k-1 units\\n        {\\n            jump1=fun(mp,stone+jump-1,jump-1,dp,ls);\\n        }\\n        if((stone+jump)>stone)  //can take jump of k units\\n        {\\n            jump2=fun(mp,stone+jump,jump,dp,ls);\\n        }\\n        if((stone+jump+1)>stone)   //can take jump of k+1 units\\n        {\\n            jump3=fun(mp,stone+jump+1,jump+1,dp,ls);\\n        }\\n        dp[{stone,jump}]=jump1 or jump2 or jump3;\\n        return dp[{stone,jump}];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202924,
                "title": "simple-c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;\\n    vector<vector<int>> dp;\\n    bool solve(vector<int>& stones,int i,int k){\\n        if(k<=0)\\n            return false;\\n        if(i<0 or i>=stones.size())\\n            return false;\\n        \\n        if(i==stones.size()-1) \\n            return true;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        bool ans = false;\\n        if(m.count(stones[i]+k))\\n            ans = ans | solve(stones,m[stones[i]+k],k);\\n        if(i>0 and m.count(stones[i]+k+1))\\n            ans = ans | solve(stones,m[stones[i]+k+1],k+1);\\n        if(i>0 and m.count(stones[i]+k-1))\\n            ans = ans | solve(stones,m[stones[i]+k-1],k-1);\\n        \\n        return dp[i][k] = ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        dp.resize(n,vector<int>(n,-1));\\n        int k = 1; \\n        for(int i=0;i<n;i++) \\n            m[stones[i]] = i;\\n        return solve(stones,0,k);\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int>m;\\n    vector<vector<int>> dp;\\n    bool solve(vector<int>& stones,int i,int k){\\n        if(k<=0)\\n            return false;\\n        if(i<0 or i>=stones.size())\\n            return false;\\n        \\n        if(i==stones.size()-1) \\n            return true;\\n        \\n        if(dp[i][k]!=-1)\\n            return dp[i][k];\\n        \\n        bool ans = false;\\n        if(m.count(stones[i]+k))\\n            ans = ans | solve(stones,m[stones[i]+k],k);\\n        if(i>0 and m.count(stones[i]+k+1))\\n            ans = ans | solve(stones,m[stones[i]+k+1],k+1);\\n        if(i>0 and m.count(stones[i]+k-1))\\n            ans = ans | solve(stones,m[stones[i]+k-1],k-1);\\n        \\n        return dp[i][k] = ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        dp.resize(n,vector<int>(n,-1));\\n        int k = 1; \\n        for(int i=0;i<n;i++) \\n            m[stones[i]] = i;\\n        return solve(stones,0,k);\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199364,
                "title": "python-3-memoization",
                "content": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1] != 1:\\n            return False\\n        lastStone = stones[-1]\\n        stones = set(stones)\\n        \\n        @lru_cache(None)\\n        def helper(stone, k):\\n            if stone == lastStone:\\n                return True\\n            \\n            return ((k != 1 and stone + k - 1 in stones and helper(stone + k - 1, k - 1)) or\\n                    (stone + k in stones and helper(stone + k, k)) or\\n                    (stone + k + 1 in stones and helper(stone + k + 1, k + 1)))\\n        \\n        return helper(1, 1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1] != 1:\\n            return False\\n        lastStone = stones[-1]\\n        stones = set(stones)\\n        \\n        @lru_cache(None)\\n        def helper(stone, k):\\n            if stone == lastStone:\\n                return True\\n            \\n            return ((k != 1 and stone + k - 1 in stones and helper(stone + k - 1, k - 1)) or\\n                    (stone + k in stones and helper(stone + k, k)) or\\n                    (stone + k + 1 in stones and helper(stone + k + 1, k + 1)))\\n        \\n        return helper(1, 1)",
                "codeTag": "Java"
            },
            {
                "id": 2190413,
                "title": "c-map-dp-memorization-92-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,bool> mp;\\n    int last;\\n    map<pair<int,int>,bool> ump;\\n    bool solve(int pos,int k){\\n        if(pos==last) return true;\\n        if(k<=0||pos>last) return false;\\n        if(ump.find({pos,k})!=ump.end()){\\n               return ump[{pos,k}];\\n        }\\n        \\n        if(mp[pos]==1){\\n            return ump[{pos,k}] = solve(pos+k,k)||solve(pos+k-1,k-1)||solve(pos+k+1,k+1);\\n        }\\n        else {\\n          return ump[{pos,k}] = false;  \\n        }\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        last = stones[n-1];\\n        for(int it : stones){\\n            mp[it]=1;\\n        }\\n        if(stones[1]==1)\\n            return solve(1,1);\\n       \\n      return  false;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,bool> mp;\\n    int last;\\n    map<pair<int,int>,bool> ump;\\n    bool solve(int pos,int k){\\n        if(pos==last) return true;\\n        if(k<=0||pos>last) return false;\\n        if(ump.find({pos,k})!=ump.end()){\\n               return ump[{pos,k}];\\n        }\\n        \\n        if(mp[pos]==1){\\n            return ump[{pos,k}] = solve(pos+k,k)||solve(pos+k-1,k-1)||solve(pos+k+1,k+1);\\n        }\\n        else {\\n          return ump[{pos,k}] = false;  \\n        }\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        last = stones[n-1];\\n        for(int it : stones){\\n            mp[it]=1;\\n        }\\n        if(stones[1]==1)\\n            return solve(1,1);\\n       \\n      return  false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010046,
                "title": "6-lines-cpp-memoization-easiest-possible",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(int i, int last, vector<int> &stones, map<int, int> &m, vector<vector<int>> &dp){\\n        if(i==stones.size()-1) return true;\\n        if(dp[i][last]!=-1) return dp[i][last];\\n        int ans= false;\\n        for(int di=-1; di<=1; di++)\\n            if(m[stones[i]+(last+di)] && last+di>0 && solve(m[stones[i]+(last+di)], last+di, stones, m, dp)) return dp[i][last]= true;\\n        \\n        return dp[i][last]=false;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n= stones.size();\\n        map<int, int> m;\\n        for(int i=0; i<n; i++) m[stones[i]]=i;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return solve(0, 0, stones, m, dp);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    bool solve(int i, int last, vector<int> &stones, map<int, int> &m, vector<vector<int>> &dp){\\n        if(i==stones.size()-1) return true;\\n        if(dp[i][last]!=-1) return dp[i][last];\\n        int ans= false;\\n        for(int di=-1; di<=1; di++)\\n            if(m[stones[i]+(last+di)] && last+di>0 && solve(m[stones[i]+(last+di)], last+di, stones, m, dp)) return dp[i][last]= true;\\n        \\n        return dp[i][last]=false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1959348,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "\\n\\tclass Solution {\\n\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap();\\n        \\n        for(int val: stones) dp.put(val, new HashSet());\\n        dp.get(stones[0]).add(1);\\n        \\n        for(int val: stones){\\n            for(int jump: dp.get(val)){\\n                if(jump!= 0 && dp.containsKey(val+jump)){\\n                    dp.get(val+jump).add(jump-1);\\n                    dp.get(val+jump).add(jump);\\n                    dp.get(val+jump).add(jump+1);\\n                }\\n            }\\n        }\\n        \\n        return !dp.get(stones[stones.length-1]).isEmpty();\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap();\\n        \\n        for(int val: stones) dp.put(val, new HashSet());\\n        dp.get(stones[0]).add(1);\\n        \\n        for(int val: stones){\\n            for(int jump: dp.get(val)){\\n                if(jump!= 0 && dp.containsKey(val+jump)){\\n                    dp.get(val+jump).add(jump-1);\\n                    dp.get(val+jump).add(jump);\\n                    dp.get(val+jump).add(jump+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1843119,
                "title": "dynamic-programming-memoization-c-solution",
                "content": "```\\n bool solve(int i, int last, vector<int> &stones, map<int, int> &m, vector<vector<int>> &dp){\\n        if(i==stones.size()-1) return true;\\n        \\n        if(dp[i][last]!=-1) return dp[i][last];\\n        \\n        int ans= false;\\n        for(int di=-1; di<=1; di++){\\n            if(m[stones[i]+(last+di)] && last+di>0){\\n                ans = ans | solve(m[stones[i]+(last+di)], last+di, stones, m, dp);\\n            }\\n        }\\n        \\n        return dp[i][last]=ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n= stones.size();\\n        map<int, int> m;\\n        for(int i=0; i<n; i++) m[stones[i]]=i;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return solve(0, 0, stones, m, dp);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n bool solve(int i, int last, vector<int> &stones, map<int, int> &m, vector<vector<int>> &dp){\\n        if(i==stones.size()-1) return true;\\n        \\n        if(dp[i][last]!=-1) return dp[i][last];\\n        \\n        int ans= false;\\n        for(int di=-1; di<=1; di++){\\n            if(m[stones[i]+(last+di)] && last+di>0){\\n                ans = ans | solve(m[stones[i]+(last+di)], last+di, stones, m, dp);\\n            }\\n        }\\n        \\n        return dp[i][last]=ans;\\n    }\\n    bool canCross(vector<int>& stones) {\\n        int n= stones.size();\\n        map<int, int> m;\\n        for(int i=0; i<n; i++) m[stones[i]]=i;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        return solve(0, 0, stones, m, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783485,
                "title": "c-solution-recursion-solution-then-converting-it-to-dp-solution",
                "content": "**Recursive Soltion**\\n* First we start from stone 1(0 based index)(as we will be give atleast 2 stones with positions 0,1) and to reach stone 1 we have only one option k = 1.\\n*  **In recursive function**  ***frogCross( parameters => currentPosition, JumpToReachCurr, stones, stonesLen)***\\n* \\t\\tfirst we deal with base cases\\n\\t\\t\\t\\t =>  if(currentPosition == stones[stonesLen - 1]) return true; \\n\\t\\t\\t\\t => if( currentPosition > stones[stonesLen - 1]) return false;\\n*  Then we check wehther **currentPosition is stone or water**\\n* \\t\\t\\t\\t\\t\\t=> if(binary_search(stones.begin(), stones.end(), currentPosition) == false) return false;\\n* \\tIf **currentPosition is stone** we can move forward, here we have **3 options i.e, making jumps k+1 or k or k-1**.\\n* \\t        => we will recursively call function  \\n\\t\\t\\t\\t\\t=> if ( frogCross (currentPosition +  JumpToReachCurr + 1,   JumpToReachCurr+1, stones, stonesLen) ) return true; \\n\\t\\t\\t\\t\\t=> if ( frogCross (currentPosition +  JumpToReachCurr,   JumpToReachCurr, stones, stonesLen) ) return true; \\n\\t\\t\\t\\t\\t=> if ( JumpToReachCurr  > 1 && frogCross (currentPosition +  JumpToReachCurr - 1,   JumpToReachCurr - 1, stones, stonesLen) ) return true; \\n*  if we can\\'t return true in any of 3 cases, we simply return false.\\n\\n\\nhere i = currentPosition\\nk = JumpToReachCurr\\nstones - vector given in problem\\nn = stonesLen (=stones.size() )\\n\\n```\\nbool frogCross(int i, int k, vector<int>& stones, int n) {\\n        if(i == stones[n-1]) return true; // if we have reached last stone i.e, currentPosition == last stone\\n        \\n        if(i > stones[n-1]) return false; // if currentPosition croses last stone \\n        \\n        if(binary_search(stones.begin(), stones.end(), i) == false) return false; //currentPosition is stone or water\\n        \\n\\t\\t// the 3 choices we have at every step\\n        if(frogCross(i+k+1, k+1, stones, n)) return true;\\n        \\n        if(frogCross(i+k, k, stones, n)) return true;\\n        \\n        if(k>1 && frogCross(i+k-1, k-1, stones, n)) return true;\\n        \\n        return false;\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        return frogCross(1, 1, stones, n);\\n    }\\n\\n\\n```\\n\\n\\n\\n**Now Converting the recursive solution to dp**\\n\\n* Here we simply store whether we have visited the stone or not, if we have visited a stone we will add with what jump we have reached to stone if we can\\'t move further.\\n\\t\\t*Suppose there is a stone at position 9 and we have have visited the stone by jumps 3,2,1\\n\\t\\t\\t\\t[9] -> {3,2,1}\\n```\\nclass Solution {\\npublic:\\n    \\n    bool frogCross(int i, int k, vector<int>& stones, int n, unordered_map<int, unordered_set<int>>& visit) {\\n        if(i == stones[n-1]) return true;\\n        \\n        if(i > stones[n-1]) return false;\\n        \\n        if(visit[i].size()>0 && visit[i].find(k) != visit[i].end()) return false; // extra line added to convert to dp\\n        \\n        if(binary_search(stones.begin(), stones.end(), i) == false) return false;\\n        \\n        if(frogCross(i+k+1, k+1, stones, n, visit)) return true;\\n        \\n        if(frogCross(i+k, k, stones, n, visit)) return true;\\n        \\n        if(k>1 && frogCross(i+k-1, k-1, stones, n, visit)) return true;\\n        \\n        visit[i].insert(k); // extra line added to convert to dp\\n        \\n        return false;\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map<int, unordered_set<int> > visit; // extra line added to convert to dp\\n        return frogCross(1, 1, stones, n, visit);\\n    }\\n};\\n\\n```\\n\\t\\t",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nbool frogCross(int i, int k, vector<int>& stones, int n) {\\n        if(i == stones[n-1]) return true; // if we have reached last stone i.e, currentPosition == last stone\\n        \\n        if(i > stones[n-1]) return false; // if currentPosition croses last stone \\n        \\n        if(binary_search(stones.begin(), stones.end(), i) == false) return false; //currentPosition is stone or water\\n        \\n\\t\\t// the 3 choices we have at every step\\n        if(frogCross(i+k+1, k+1, stones, n)) return true;\\n        \\n        if(frogCross(i+k, k, stones, n)) return true;\\n        \\n        if(k>1 && frogCross(i+k-1, k-1, stones, n)) return true;\\n        \\n        return false;\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        return frogCross(1, 1, stones, n);\\n    }\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool frogCross(int i, int k, vector<int>& stones, int n, unordered_map<int, unordered_set<int>>& visit) {\\n        if(i == stones[n-1]) return true;\\n        \\n        if(i > stones[n-1]) return false;\\n        \\n        if(visit[i].size()>0 && visit[i].find(k) != visit[i].end()) return false; // extra line added to convert to dp\\n        \\n        if(binary_search(stones.begin(), stones.end(), i) == false) return false;\\n        \\n        if(frogCross(i+k+1, k+1, stones, n, visit)) return true;\\n        \\n        if(frogCross(i+k, k, stones, n, visit)) return true;\\n        \\n        if(k>1 && frogCross(i+k-1, k-1, stones, n, visit)) return true;\\n        \\n        visit[i].insert(k); // extra line added to convert to dp\\n        \\n        return false;\\n    }\\n    \\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map<int, unordered_set<int> > visit; // extra line added to convert to dp\\n        return frogCross(1, 1, stones, n, visit);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774139,
                "title": "c-recursion-memoization-dynamic-programming",
                "content": "I first went for a recurssive approach where I dealt with all the choices I had to take and handled all the out of bounds exceptions. Then i used a 2-D dp array to optimize the time since 2 variables were getting changed in every stack. Thereby came up with the solution. Used dp[2002][2002] because stones.length <= 2000 and the k-jump can be a maximum of 2000.\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        if(stones[1]!=1) return false;\\n        int dp[2002][2002];\\n        memset(dp,-1,sizeof dp);\\n        return solve(1,1,n-1,stones,dp);\\n    }\\n    bool solve(int i, int k, int n, vector<int>& stones, int dp[2002][2002]) {\\n        if(i==n) return true;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        bool jumpOne=false,jumpTwo=false,jumpThree=false;\\n        auto x=find(stones.begin()+i,stones.end(),stones[i]+k);\\n        if(x!=stones.end()) jumpOne = true & solve(i+(x-(stones.begin()+i)),k,n,stones,dp);\\n        x=find(stones.begin()+i,stones.end(),stones[i]+k+1);\\n        if(x!=stones.end()) jumpTwo = true & solve(i+(x-(stones.begin()+i)),k+1,n,stones,dp);\\n        if(k-1>0) {\\n            x=find(stones.begin()+i,stones.end(),stones[i]+k-1);\\n            if(x!=stones.end()) jumpThree = true & solve(i+(x-(stones.begin()+i)),k-1,n,stones,dp);\\n        }\\n        return dp[i][k] = jumpOne | jumpTwo | jumpThree;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int n=stones.size();\\n        if(stones[1]!=1) return false;\\n        int dp[2002][2002];\\n        memset(dp,-1,sizeof dp);\\n        return solve(1,1,n-1,stones,dp);\\n    }\\n    bool solve(int i, int k, int n, vector<int>& stones, int dp[2002][2002]) {\\n        if(i==n) return true;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        bool jumpOne=false,jumpTwo=false,jumpThree=false;\\n        auto x=find(stones.begin()+i,stones.end(),stones[i]+k);\\n        if(x!=stones.end()) jumpOne = true & solve(i+(x-(stones.begin()+i)),k,n,stones,dp);\\n        x=find(stones.begin()+i,stones.end(),stones[i]+k+1);\\n        if(x!=stones.end()) jumpTwo = true & solve(i+(x-(stones.begin()+i)),k+1,n,stones,dp);\\n        if(k-1>0) {\\n            x=find(stones.begin()+i,stones.end(),stones[i]+k-1);\\n            if(x!=stones.end()) jumpThree = true & solve(i+(x-(stones.begin()+i)),k-1,n,stones,dp);\\n        }\\n        return dp[i][k] = jumpOne | jumpTwo | jumpThree;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760227,
                "title": "frog-jump-solution-java",
                "content": "class Solution {\\n  public boolean canCross(int[] stones) {\\n    final int n = stones.length;\\n    // dp[i][j] := 1 if a frog can make a size j jump to stones[i]\\n    int[][] dp = new int[n][n + 1];\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i < n; ++i)\\n      for (int j = 0; j < i; ++j) {\\n        final int k = stones[i] - stones[j];\\n        if (k > n)\\n          continue;\\n        for (final int x : new int[] {k - 1, k, k + 1})\\n          if (0 <= x && x <= n)\\n            dp[i][k] |= dp[j][x];\\n      }\\n\\n    return Arrays.stream(dp[n - 1]).anyMatch(a -> a == 1);\\n  }\\n}\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\n  public boolean canCross(int[] stones) {\\n    final int n = stones.length;\\n    // dp[i][j] := 1 if a frog can make a size j jump to stones[i]\\n    int[][] dp = new int[n][n + 1];\\n    dp[0][0] = 1;\\n\\n    for (int i = 1; i < n; ++i)\\n      for (int j = 0; j < i; ++j) {\\n        final int k = stones[i] - stones[j];\\n        if (k > n)\\n          continue;\\n        for (final int x : new int[] {k - 1, k, k + 1}",
                "codeTag": "Java"
            },
            {
                "id": 1737109,
                "title": "python-424ms-38-07-bfs-solution-even-possible-to-calculate-minimum-steps-to-reach-last-stone",
                "content": "The idea is to use BFS and record visited states along the way. If this question has a follow up like how to calculate minimum steps to reach the last stone, this solution can solve it with some simple modification.\\n\\nTime and Space complexity is O(n^2), because stone[i] can only have maximum i - 1 different states (jump from every stone in its front)\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        target = stones[-1]\\n        stone_set, visited = set(stones), set()\\n        queue = deque([(0, 0)])\\n        \\n        while queue:\\n            curr_stone, prev_step = queue.popleft()\\n            for step in [prev_step - 1, prev_step, prev_step + 1]:\\n                if step <= 0:\\n                    continue\\n                    \\n                next_stone = curr_stone + step\\n                if next_stone == target:\\n                    return True\\n                if next_stone in stone_set and (next_stone, step) not in visited:\\n                    visited.add((next_stone, step))\\n                    queue.append((next_stone, step))\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        target = stones[-1]\\n        stone_set, visited = set(stones), set()\\n        queue = deque([(0, 0)])\\n        \\n        while queue:\\n            curr_stone, prev_step = queue.popleft()\\n            for step in [prev_step - 1, prev_step, prev_step + 1]:\\n                if step <= 0:\\n                    continue\\n                    \\n                next_stone = curr_stone + step\\n                if next_stone == target:\\n                    return True\\n                if next_stone in stone_set and (next_stone, step) not in visited:\\n                    visited.add((next_stone, step))\\n                    queue.append((next_stone, step))\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622144,
                "title": "python-dp",
                "content": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        stoneSet = set(stones)\\n        \\n        @cache\\n        def dp(i, k) -> bool:\\n            nonlocal stoneSet\\n            nonlocal stones\\n            if i not in stoneSet:\\n                return False\\n            if i == stones[-1]:\\n                return True\\n\\n            return dp(i+k, k) or dp(i+k+1, k+1) or (False if k-1 == 0 else dp(i+k-1, k-1))\\n        \\n        return dp(1,1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        stoneSet = set(stones)\\n        \\n        @cache\\n        def dp(i, k) -> bool:\\n            nonlocal stoneSet\\n            nonlocal stones\\n            if i not in stoneSet:\\n                return False\\n            if i == stones[-1]:\\n                return True\\n\\n            return dp(i+k, k) or dp(i+k+1, k+1) or (False if k-1 == 0 else dp(i+k-1, k-1))\\n        \\n        return dp(1,1)",
                "codeTag": "Java"
            },
            {
                "id": 1458805,
                "title": "js-naive-memoization-easy-to-understand",
                "content": "```\\n\\nconst canCross = (stones) => {\\n    const dp = Array.from({ length: stones.length }, _ => [] )\\n    if(stones.length == 1) return true;\\n    if(stones[1]-stones[0] != 1) return false;\\n    return solve(1,1,stones,dp);\\n};\\nconst solve = (index,jump,stones,dp) => {\\n    if(index==stones.length-1) return true;\\n    if(\\'undefined\\' !== typeof dp[index][jump])    \\n        return dp[index][jump];\\n    let res = false;\\n    for(let i=index+1;i<stones.length;i++){\\n        if(stones[i]-stones[index] == jump-1)\\n            res = res || solve(i,jump-1,stones,dp);\\n        else if(stones[i]-stones[index] == jump)\\n            res = res || solve(i,jump,stones,dp);\\n        else if(stones[i]-stones[index] == jump+1)\\n            res = res || solve(i,jump+1,stones,dp);\\n    }\\n    dp[index][jump] = res;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nconst canCross = (stones) => {\\n    const dp = Array.from({ length: stones.length }, _ => [] )\\n    if(stones.length == 1) return true;\\n    if(stones[1]-stones[0] != 1) return false;\\n    return solve(1,1,stones,dp);\\n};\\nconst solve = (index,jump,stones,dp) => {\\n    if(index==stones.length-1) return true;\\n    if(\\'undefined\\' !== typeof dp[index][jump])    \\n        return dp[index][jump];\\n    let res = false;\\n    for(let i=index+1;i<stones.length;i++){\\n        if(stones[i]-stones[index] == jump-1)\\n            res = res || solve(i,jump-1,stones,dp);\\n        else if(stones[i]-stones[index] == jump)\\n            res = res || solve(i,jump,stones,dp);\\n        else if(stones[i]-stones[index] == jump+1)\\n            res = res || solve(i,jump+1,stones,dp);\\n    }\\n    dp[index][jump] = res;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441021,
                "title": "c-10-lines",
                "content": "```\\n\\n```public:\\n    bool canCross(vector<int>& stones) {\\n        set<int>s(stones.begin(),stones.end());\\n        map<int,set<int>>mp;\\n        mp[stones[0]].insert(1);\\n        for(int i=0;i<stones.size();i++)\\n        {\\n            set<int>temp=mp[stones[i]];\\n            for(auto jump:temp)\\n            {\\n                int pos=stones[i]+jump;\\n                if(s.find(pos)!=s.end())\\n                {\\n                    if(pos==stones.back())\\n                    {\\n                        return true;\\n                    }\\n                    mp[pos].insert(jump);\\n                    mp[pos].insert(jump+1);\\n                    mp[pos].insert(jump-1);\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385273,
                "title": "very-easy-and-intuitive-bfs-approach",
                "content": "Although its not that efficient, but very intuitive. The idea is:\\n\\n**For every stone, you have 3 possible choices:**\\n**1. Jump to next stone at \"step_size - 1\" distance from it if stone at that position exists. (Note: Here \"step_size\" is the length of jump taken to reach the stone from where you wish to jump now).**\\n\\n**2. Jump to next stone at \"step_size\" distance from it if stone at that position exists.**\\n\\n**3. Jump to next stone at \"step_size + 1\" distance from it if stone at that position exists.**\\n\\nSo just do BFS, as for any stone you have only these many choices. Some key points to note here is:\\n1. You cannot apply \\'step_size - 1\\' for step_size == 1.\\n2. Memorize the {stone, step_size} so that you will not end up at same stone with same step_size again and again, which will end up in TLE.\\n\\nBelow is the code for the same. **Please upvote if helpful** :)\\n\\n```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int size = stones.size();\\n        // base cases\\n        if(size < 2) return true;\\n        if(stones[1] != 1) return false;\\n        if(stones[size-1] == 1) return true;\\n        // general case\\n        unordered_map<int,int> positions;\\n        for(auto x:stones){\\n            positions[x] = 1;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({1,1});\\n        pair<int,int> temp;\\n        int target = stones[size-1],position, step_size;\\n        unordered_map<string,int> visited; visited[\"1,1\"] = 1;\\n        string str;\\n        while(!q.empty()){\\n            temp = q.front(); q.pop();\\n            position = temp.first; step_size = temp.second;\\n            // 1. if step size is 1\\n            if(step_size == 1){\\n                if(positions[position+1]){\\n                    str = \"\"; str += to_string(position+1) + \\',\\' + \\'1\\';\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+1,1});\\n                        if(position+1 == target) return true;\\n                    }\\n                }\\n                if(positions[position+2]){\\n                    str = \"\"; str += to_string(position+2) + \\',\\' + \\'2\\';\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+2,2});\\n                        if(position+2 == target) return true;\\n                    }\\n                }\\n            }\\n            // 2. in general case\\n            else{\\n                if(positions[position+step_size-1]){\\n                    str = \"\"; str += to_string(position+step_size-1) + \\',\\' + to_string(step_size-1);\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+step_size-1,step_size-1});\\n                        if(position+step_size-1 == target) return true;\\n                    }\\n                }\\n                if(positions[position+step_size]){\\n                    str = \"\"; str += to_string(position+step_size) + \\',\\' + to_string(step_size);\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+step_size,step_size});\\n                        if(position+step_size == target) return true; \\n                    }\\n                }\\n                if(positions[position+step_size+1]){\\n                    str = \"\"; str += to_string(position+step_size+1) + \\',\\' + to_string(step_size+1);\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+step_size+1,step_size+1});\\n                        if(position+step_size+1 == target) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        int size = stones.size();\\n        // base cases\\n        if(size < 2) return true;\\n        if(stones[1] != 1) return false;\\n        if(stones[size-1] == 1) return true;\\n        // general case\\n        unordered_map<int,int> positions;\\n        for(auto x:stones){\\n            positions[x] = 1;\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({1,1});\\n        pair<int,int> temp;\\n        int target = stones[size-1],position, step_size;\\n        unordered_map<string,int> visited; visited[\"1,1\"] = 1;\\n        string str;\\n        while(!q.empty()){\\n            temp = q.front(); q.pop();\\n            position = temp.first; step_size = temp.second;\\n            // 1. if step size is 1\\n            if(step_size == 1){\\n                if(positions[position+1]){\\n                    str = \"\"; str += to_string(position+1) + \\',\\' + \\'1\\';\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+1,1});\\n                        if(position+1 == target) return true;\\n                    }\\n                }\\n                if(positions[position+2]){\\n                    str = \"\"; str += to_string(position+2) + \\',\\' + \\'2\\';\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+2,2});\\n                        if(position+2 == target) return true;\\n                    }\\n                }\\n            }\\n            // 2. in general case\\n            else{\\n                if(positions[position+step_size-1]){\\n                    str = \"\"; str += to_string(position+step_size-1) + \\',\\' + to_string(step_size-1);\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+step_size-1,step_size-1});\\n                        if(position+step_size-1 == target) return true;\\n                    }\\n                }\\n                if(positions[position+step_size]){\\n                    str = \"\"; str += to_string(position+step_size) + \\',\\' + to_string(step_size);\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+step_size,step_size});\\n                        if(position+step_size == target) return true; \\n                    }\\n                }\\n                if(positions[position+step_size+1]){\\n                    str = \"\"; str += to_string(position+step_size+1) + \\',\\' + to_string(step_size+1);\\n                    if(visited[str] == 0){\\n                        visited[str] = 1;\\n                        q.push({position+step_size+1,step_size+1});\\n                        if(position+step_size+1 == target) return true;\\n                    }\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292173,
                "title": "goalng-dp-solution",
                "content": "```go\\nfunc canCross(stones []int) bool {\\n\\tn := len(stones)\\n\\tdp := make([][]bool, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]bool, n)\\n\\t}\\n\\tdp[0][0] = true\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif stones[i]-stones[i-1] > i {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\tk := stones[i] - stones[j]\\n\\t\\t\\tif k > j+1 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1]\\n\\t\\t\\tif i == n-1 && dp[i][k] {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```go\\nfunc canCross(stones []int) bool {\\n\\tn := len(stones)\\n\\tdp := make([][]bool, n)\\n\\tfor i := range dp {\\n\\t\\tdp[i] = make([]bool, n)\\n\\t}\\n\\tdp[0][0] = true\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tif stones[i]-stones[i-1] > i {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tfor j := i - 1; j >= 0; j-- {\\n\\t\\t\\tk := stones[i] - stones[j]\\n\\t\\t\\tif k > j+1 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tdp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1]\\n\\t\\t\\tif i == n-1 && dp[i][k] {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1278608,
                "title": "c-runtime-76ms-faster-than-85-77-memory-usage-28-4-mb-less-than-71-55-memoization",
                "content": "Please Upvote if you like it and also give review about solution\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,bool> dp;\\n    int last;\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] != 1){\\n            return false;\\n        }\\n        unordered_set<int> st(stones.begin(),stones.end());\\n        last = stones.back();\\n        return cross(st,1,1);\\n    }\\n    bool cross(unordered_set<int> &st,int pos,int jump){\\n        if(pos == last){\\n            return true;\\n        }\\n        if(st.find(pos) == st.end()){\\n            return false;\\n        }\\n        if(dp.find({pos,jump}) != dp.end()){\\n            return dp[{pos,jump}];\\n        }\\n        bool x = false, y = false,z = false;\\n        if(jump-1 > 0){\\n            x = cross(st,pos+jump-1,jump-1);\\n        }\\n        if(!x){\\n            y = cross(st,pos+jump,jump);\\n        }\\n        if(!x and !y){\\n            z = cross(st,pos + jump + 1,jump+1);\\n        }\\n        return dp[{pos,jump}] = x | y | z;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,bool> dp;\\n    int last;\\n    bool canCross(vector<int>& stones) {\\n        if(stones[1] != 1){\\n            return false;\\n        }\\n        unordered_set<int> st(stones.begin(),stones.end());\\n        last = stones.back();\\n        return cross(st,1,1);\\n    }\\n    bool cross(unordered_set<int> &st,int pos,int jump){\\n        if(pos == last){\\n            return true;\\n        }\\n        if(st.find(pos) == st.end()){\\n            return false;\\n        }\\n        if(dp.find({pos,jump}) != dp.end()){\\n            return dp[{pos,jump}];\\n        }\\n        bool x = false, y = false,z = false;\\n        if(jump-1 > 0){\\n            x = cross(st,pos+jump-1,jump-1);\\n        }\\n        if(!x){\\n            y = cross(st,pos+jump,jump);\\n        }\\n        if(!x and !y){\\n            z = cross(st,pos + jump + 1,jump+1);\\n        }\\n        return dp[{pos,jump}] = x | y | z;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1270760,
                "title": "c-using-hash-map-of-hash-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        // First jump must be 1.\\n        if(stones[1] - stones[0] != 1) return false;\\n        // Use a map since stone position is sparse.\\n        // Map from stone pos to a set of stone pos frog jumps from.\\n        unordered_map<int, unordered_set<int>> dp;\\n        // Init so only stones in the list is acceptable.\\n        for(auto s : stones) dp[s];\\n        // frog can jump from stones[0]->stones[1]\\n        dp[stones[1]].emplace(stones[0]);\\n        \\n        for(int i = 1; i < stones.size(); ++i){\\n            int stone = stones[i];\\n            // For each stone the frog jump from\\n            for(auto prev_stone : dp[stone]){\\n                // caculate distance k.\\n                int64_t k = stone - prev_stone;\\n                // frog can jump from stone to {stone+k-1, stone+k, stone+k+1}\\n                for(int64_t l = k-1; l<=k+1; ++l){\\n                    if(l < 0) continue;\\n                    int64_t m = l + stone;\\n                    if(m > stones.back()) continue;\\n                    auto it = dp.find(m); \\n                    // if the frog jump into river, ignore.\\n                    if(it == dp.end()) continue;\\n                    // If the frog jump to the last stone, it succeeded.\\n                    if(it->first == stones.back()) return true;\\n                    it->second.emplace(stone);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        // First jump must be 1.\\n        if(stones[1] - stones[0] != 1) return false;\\n        // Use a map since stone position is sparse.\\n        // Map from stone pos to a set of stone pos frog jumps from.\\n        unordered_map<int, unordered_set<int>> dp;\\n        // Init so only stones in the list is acceptable.\\n        for(auto s : stones) dp[s];\\n        // frog can jump from stones[0]->stones[1]\\n        dp[stones[1]].emplace(stones[0]);\\n        \\n        for(int i = 1; i < stones.size(); ++i){\\n            int stone = stones[i];\\n            // For each stone the frog jump from\\n            for(auto prev_stone : dp[stone]){\\n                // caculate distance k.\\n                int64_t k = stone - prev_stone;\\n                // frog can jump from stone to {stone+k-1, stone+k, stone+k+1}\\n                for(int64_t l = k-1; l<=k+1; ++l){\\n                    if(l < 0) continue;\\n                    int64_t m = l + stone;\\n                    if(m > stones.back()) continue;\\n                    auto it = dp.find(m); \\n                    // if the frog jump into river, ignore.\\n                    if(it == dp.end()) continue;\\n                    // If the frog jump to the last stone, it succeeded.\\n                    if(it->first == stones.back()) return true;\\n                    it->second.emplace(stone);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1157182,
                "title": "java-dp-straight-forward-solution-using-hashmap-very-easy-to-understand-solution-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        // first jump = 1 unit\\n        // last jump = k unit, next jump = k-1 / k / k+1 units\\n        // dynamic programming\\n        \\n\\t\\t// key: the position of the stone\\n\\t\\t// value: last jump size from previous stone to the current position\\n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < stones.length; i++) {\\n            map.put(stones[i], new HashSet<Integer>());\\n        }\\n        map.get(0).add(0);\\n        \\n        for (int i = 0; i < stones.length; i++) {\\n            for (int k : map.get(stones[i])) {\\n                for (int step = k - 1; step <= k + 1; step++) {\\n                    if (step > 0 && map.containsKey(stones[i] + step)) {\\n                        map.get(stones[i] + step).add(step);\\n                    }\\n                }\\n            }\\n        }\\n        return map.get(stones[stones.length - 1]).size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        // first jump = 1 unit\\n        // last jump = k unit, next jump = k-1 / k / k+1 units\\n        // dynamic programming\\n        \\n\\t\\t// key: the position of the stone\\n\\t\\t// value: last jump size from previous stone to the current position\\n        HashMap<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < stones.length; i++) {\\n            map.put(stones[i], new HashSet<Integer>());\\n        }\\n        map.get(0).add(0);\\n        \\n        for (int i = 0; i < stones.length; i++) {\\n            for (int k : map.get(stones[i])) {\\n                for (int step = k - 1; step <= k + 1; step++) {\\n                    if (step > 0 && map.containsKey(stones[i] + step)) {\\n                        map.get(stones[i] + step).add(step);\\n                    }\\n                }\\n            }\\n        }\\n        return map.get(stones[stones.length - 1]).size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127092,
                "title": "python3-simple-top-down-2d-dp-solution",
                "content": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n = len(stones)\\n        pos = set(stones)\\n        seen = set()\\n        @lru_cache(None)\\n        def dfs(cur, k):\\n            if cur == stones[n - 1]:\\n                return True\\n            if not cur in pos:\\n                return False\\n            if (cur, k) in seen:\\n                return False\\n            seen.add((cur, k))\\n            return dfs(cur + k - 1, k - 1) or dfs(cur + k, k) or dfs(cur + k + 1, k + 1)\\n        return dfs(stones[0] + 1, 1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        n = len(stones)\\n        pos = set(stones)\\n        seen = set()\\n        @lru_cache(None)\\n        def dfs(cur, k):\\n            if cur == stones[n - 1]:\\n                return True\\n            if not cur in pos:\\n                return False\\n            if (cur, k) in seen:\\n                return False\\n            seen.add((cur, k))\\n            return dfs(cur + k - 1, k - 1) or dfs(cur + k, k) or dfs(cur + k + 1, k + 1)\\n        return dfs(stones[0] + 1, 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1088783,
                "title": "java-faster-than-83-03-memorization",
                "content": "```\\n    public boolean canCross(int[] stones) {\\n        Set<Integer> indexes = new HashSet();\\n        for(int stone :stones){\\n            indexes.add(stone);\\n        }\\n        \\n        return solve(indexes, 1, 1, stones[stones.length - 1], new HashMap());\\n    }\\n    \\n    private boolean solve(Set<Integer> indexes, int i, int k, int lastIndex, Map<Integer, Boolean> cache){\\n        if(i == lastIndex){\\n            return true;\\n        }\\n        if(i >= lastIndex || !indexes.contains(i)){\\n            return false;\\n        }\\n        \\n        int key = i * lastIndex + k;\\n        if(cache.containsKey(key)){\\n            return cache.get(key);\\n        }\\n        \\n        cache.put(key, false);\\n        for(int steps = Math.max(k - 1, 1); steps <= k + 1; steps++){\\n            if(solve(indexes, i + steps, steps, lastIndex, cache)){\\n                cache.put(key, true);\\n                break;\\n            }\\n        }\\n        return cache.get(key);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canCross(int[] stones) {\\n        Set<Integer> indexes = new HashSet();\\n        for(int stone :stones){\\n            indexes.add(stone);\\n        }\\n        \\n        return solve(indexes, 1, 1, stones[stones.length - 1], new HashMap());\\n    }\\n    \\n    private boolean solve(Set<Integer> indexes, int i, int k, int lastIndex, Map<Integer, Boolean> cache){\\n        if(i == lastIndex){\\n            return true;\\n        }\\n        if(i >= lastIndex || !indexes.contains(i)){\\n            return false;\\n        }\\n        \\n        int key = i * lastIndex + k;\\n        if(cache.containsKey(key)){\\n            return cache.get(key);\\n        }\\n        \\n        cache.put(key, false);\\n        for(int steps = Math.max(k - 1, 1); steps <= k + 1; steps++){\\n            if(solve(indexes, i + steps, steps, lastIndex, cache)){\\n                cache.put(key, true);\\n                break;\\n            }\\n        }\\n        return cache.get(key);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1085586,
                "title": "python-dp-backtracking-solution-using-memoization",
                "content": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n\\t\\t# Naive approach\\n\\t\\t# def bt(pos, stones, k):\\n        #     if pos == stones[-1]:\\n        #         return True\\n        #     else:\\n        #         return any(bt(pos+hop, stones, hop) for hop in range(k-1, k+2) if pos+hop in stones and hop != 0)\\n        # return bt(1, stones, 1)\\n\\t\\t\\n\\t\\t# Same backtracking algorithm but making use of memoization\\n        memo = {}\\n        if 1 not in stones:\\n            return False\\n        def bt(pos, stones, k, memo):\\n            if pos == stones[-1]:\\n                return True\\n            if (pos, k) in memo:\\n                return memo[(pos, k)]\\n            else:\\n                memo[(pos, k)] = any(bt(pos+hop, stones, hop, memo) for hop in range(k-1, k+2) if pos+hop in stones and hop != 0)\\n                return memo[(pos, k)]\\n        return bt(1, stones, 1, memo)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n\\t\\t# Naive approach\\n\\t\\t# def bt(pos, stones, k):\\n        #     if pos == stones[-1]:\\n        #         return True\\n        #     else:\\n        #         return any(bt(pos+hop, stones, hop) for hop in range(k-1, k+2) if pos+hop in stones and hop != 0)\\n        # return bt(1, stones, 1)\\n\\t\\t\\n\\t\\t# Same backtracking algorithm but making use of memoization\\n        memo = {}\\n        if 1 not in stones:\\n            return False\\n        def bt(pos, stones, k, memo):\\n            if pos == stones[-1]:\\n                return True\\n            if (pos, k) in memo:\\n                return memo[(pos, k)]\\n            else:\\n                memo[(pos, k)] = any(bt(pos+hop, stones, hop, memo) for hop in range(k-1, k+2) if pos+hop in stones and hop != 0)\\n                return memo[(pos, k)]\\n        return bt(1, stones, 1, memo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1058925,
                "title": "java-iterative-solution",
                "content": "JAVA CODE IS: \\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n=stones.length;\\n      Set<Integer> dp [] =new Set[n];\\n        for(int i=0;i<n;i++)\\n            dp[i]=new HashSet<>();\\n        dp[0].add(0);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                int t=stones[i]-stones[j];\\n                if(dp[j].contains(t)||dp[j].contains(t-1)||dp[j].contains(t+1))\\n                    dp[i].add(t);\\n            }\\n        }\\n        return dp[n-1].size()>0;\\n    }\\n}\\n```\\nTime : O(n)\\nSpace : O(n^2)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int n=stones.length;\\n      Set<Integer> dp [] =new Set[n];\\n        for(int i=0;i<n;i++)\\n            dp[i]=new HashSet<>();\\n        dp[0].add(0);\\n        for(int i=1;i<n;i++){\\n            for(int j=0;j<i;j++){\\n                int t=stones[i]-stones[j];\\n                if(dp[j].contains(t)||dp[j].contains(t-1)||dp[j].contains(t+1))\\n                    dp[i].add(t);\\n            }\\n        }\\n        return dp[n-1].size()>0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044573,
                "title": "invalid-test-case-0-1-3-6-10-15-16-21",
                "content": "Found an invalid test-case for this question : \\n[0,1,3,6,10,15,16,21]\\nExpected output = true\\n\\nI don\\'t think there is a way to reach 16 or 21 in this array. I had written following dp (bottom-up) solution for this problem:\\n```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        if (stones == null) {\\n            return false;\\n        }\\n        if (stones.length == 0 || stones.length == 1) {\\n            return true;\\n        }\\n        \\n        ArrayList<HashSet<Integer>> kUnits = new ArrayList<HashSet<Integer>>();\\n        \\n        // Base Case\\n        HashSet<Integer> ksForZero = new HashSet<Integer>();\\n        ksForZero.add(0);\\n        kUnits.add(ksForZero);\\n        \\n        for (int i = 1; i < stones.length; i++) {\\n            HashSet<Integer> ksForI = new HashSet<Integer>();\\n            for (int j = i - 1; j >= 0; j--) {\\n                int diff = stones[i] - stones[j];\\n                HashSet<Integer> ksForJ = kUnits.get(j);\\n                for (Integer kValue : ksForJ) {\\n                    if (kValue - 1 == diff || kValue == diff || kValue + 1 == diff) {\\n                        ksForI.add(diff);\\n                        break;\\n                    }\\n                }\\n            }\\n            if (ksForI.size() == 0) {\\n                return false;\\n            }\\n            kUnits.add(ksForI);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        if (stones == null) {\\n            return false;\\n        }\\n        if (stones.length == 0 || stones.length == 1) {\\n            return true;\\n        }\\n        \\n        ArrayList<HashSet<Integer>> kUnits = new ArrayList<HashSet<Integer>>();\\n        \\n        // Base Case\\n        HashSet<Integer> ksForZero = new HashSet<Integer>();\\n        ksForZero.add(0);\\n        kUnits.add(ksForZero);\\n        \\n        for (int i = 1; i < stones.length; i++) {\\n            HashSet<Integer> ksForI = new HashSet<Integer>();\\n            for (int j = i - 1; j >= 0; j--) {\\n                int diff = stones[i] - stones[j];\\n                HashSet<Integer> ksForJ = kUnits.get(j);\\n                for (Integer kValue : ksForJ) {\\n                    if (kValue - 1 == diff || kValue == diff || kValue + 1 == diff) {\\n                        ksForI.add(diff);\\n                        break;\\n                    }\\n                }\\n            }\\n            if (ksForI.size() == 0) {\\n                return false;\\n            }\\n            kUnits.add(ksForI);\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039941,
                "title": "evolve-from-brute-force-to-dp",
                "content": "1. Brute force O(3^n)\\n```\\n\\tSet<Integer> set;\\n    int last;\\n    public boolean canCross(int[] stones) {\\n        last = stones[stones.length-1];\\n        set = new HashSet<>();\\n        for(int i:stones) {\\n            set.add(i);\\n        }\\n        return canCross(stones[0], 1);\\n    }\\n    private boolean canCross(int p, int speed) {\\n        if(!set.contains(p)) {\\n            return false;\\n        }\\n        if(p == last) {\\n            return true;\\n        }\\n        if(speed==0) {\\n            return false;\\n        }\\n        p+=speed;     \\n        return canCross(p, speed-1) || canCross(p,speed) || canCross(p,speed+1);\\n    }\\n```\\n2. Memoization O(n^2)\\n```\\n\\tSet<Integer> set;\\n    int last;\\n    Map<Integer, Map<Integer,Boolean>> mem;\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        last = stones[n-1];\\n        mem = new HashMap<>();\\n        set = new HashSet<>();\\n        for(int i:stones) {\\n            set.add(i);\\n        }\\n        return canCross(stones[0], 1);\\n    }\\n    private boolean canCross(int p, int speed) {\\n        if(!set.contains(p)) {\\n            return false;\\n        }\\n        if(p == last) {\\n            return true;\\n        }\\n        if(speed==0) {\\n            return false;\\n        }\\n        mem.putIfAbsent(p, new HashMap<>());\\n        Map<Integer,Boolean>  map = mem.get(p);\\n        Boolean cc = map.get(speed);\\n        if(cc!=null) {\\n            return cc;\\n        } \\n        p+=speed;     \\n        boolean ret = canCross(p, speed-1) || canCross(p,speed) || canCross(p,speed+1);\\n        map.put(speed, ret);\\n        return ret;\\n    }\\n```\\n3. dp O(n^2)\\n```\\n\\tpublic boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for(int p:stones) {\\n            dp.put(p,new HashSet<>());    \\n        }\\n        dp.get(stones[0]).add(1);\\n        for(int p:stones) {\\n            for(int speed:dp.get(p)) {\\n                int nextStone = p+speed;\\n                Set<Integer> nextSpeeds = dp.get(nextStone);\\n                if(nextSpeeds == null) {\\n                    continue;\\n                }\\n                if(speed > 1) {\\n                    nextSpeeds.add(speed-1);\\n                }\\n                nextSpeeds.add(speed);\\n                nextSpeeds.add(speed+1);\\n            }\\n        }\\n        return !dp.get(stones[stones.length-1]).isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tSet<Integer> set;\\n    int last;\\n    public boolean canCross(int[] stones) {\\n        last = stones[stones.length-1];\\n        set = new HashSet<>();\\n        for(int i:stones) {\\n            set.add(i);\\n        }\\n        return canCross(stones[0], 1);\\n    }\\n    private boolean canCross(int p, int speed) {\\n        if(!set.contains(p)) {\\n            return false;\\n        }\\n        if(p == last) {\\n            return true;\\n        }\\n        if(speed==0) {\\n            return false;\\n        }\\n        p+=speed;     \\n        return canCross(p, speed-1) || canCross(p,speed) || canCross(p,speed+1);\\n    }\\n```\n```\\n\\tSet<Integer> set;\\n    int last;\\n    Map<Integer, Map<Integer,Boolean>> mem;\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length;\\n        last = stones[n-1];\\n        mem = new HashMap<>();\\n        set = new HashSet<>();\\n        for(int i:stones) {\\n            set.add(i);\\n        }\\n        return canCross(stones[0], 1);\\n    }\\n    private boolean canCross(int p, int speed) {\\n        if(!set.contains(p)) {\\n            return false;\\n        }\\n        if(p == last) {\\n            return true;\\n        }\\n        if(speed==0) {\\n            return false;\\n        }\\n        mem.putIfAbsent(p, new HashMap<>());\\n        Map<Integer,Boolean>  map = mem.get(p);\\n        Boolean cc = map.get(speed);\\n        if(cc!=null) {\\n            return cc;\\n        } \\n        p+=speed;     \\n        boolean ret = canCross(p, speed-1) || canCross(p,speed) || canCross(p,speed+1);\\n        map.put(speed, ret);\\n        return ret;\\n    }\\n```\n```\\n\\tpublic boolean canCross(int[] stones) {\\n        Map<Integer, Set<Integer>> dp = new HashMap<>();\\n        for(int p:stones) {\\n            dp.put(p,new HashSet<>());    \\n        }\\n        dp.get(stones[0]).add(1);\\n        for(int p:stones) {\\n            for(int speed:dp.get(p)) {\\n                int nextStone = p+speed;\\n                Set<Integer> nextSpeeds = dp.get(nextStone);\\n                if(nextSpeeds == null) {\\n                    continue;\\n                }\\n                if(speed > 1) {\\n                    nextSpeeds.add(speed-1);\\n                }\\n                nextSpeeds.add(speed);\\n                nextSpeeds.add(speed+1);\\n            }\\n        }\\n        return !dp.get(stones[stones.length-1]).isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011149,
                "title": "python-solution-bottom-up-dynamic-programming",
                "content": "bottom-up dynamic programming\\nlet dp[x] be the set of possible last steps that the frog reaches x,\\ndp[x] == set() means there is no way to reach x.\\n\\n```\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1] != 1:\\n            return False\\n        n = len(stones)\\n        dp = {x: set() for x in stones}\\n        dp[1] = {1}\\n        for x in stones[1:]:\\n            for prev_step in dp[x]:\\n                for d in [-1, 0, 1]:\\n                    next_step = prev_step + d\\n                    if next_step > 0:\\n                        x1 = x + next_step\\n                        if x1 in dp:\\n                            dp[x1].add(next_step)\\n        return dp[stones[-1]] != set()\\n```",
                "solutionTags": [],
                "code": "```\\n    def canCross(self, stones: List[int]) -> bool:\\n        if stones[1] != 1:\\n            return False\\n        n = len(stones)\\n        dp = {x: set() for x in stones}\\n        dp[1] = {1}\\n        for x in stones[1:]:\\n            for prev_step in dp[x]:\\n                for d in [-1, 0, 1]:\\n                    next_step = prev_step + d\\n                    if next_step > 0:\\n                        x1 = x + next_step\\n                        if x1 in dp:\\n                            dp[x1].add(next_step)\\n        return dp[stones[-1]] != set()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 906895,
                "title": "easy-java-dfs-solution-no-set-or-map-5ms",
                "content": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int last = stones[stones.length - 1]; //we start from last\\n        for(int i = stones.length - 2; i >= 0; i--) {\\n            if (dfs(stones, i, last-stones[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean dfs(int[] stones, int i, int k) {\\n        if(i == 0 && k == 1) {\\n            return true;\\n        }\\n        for(int j = i-1; j >= 0; j--) {\\n            if(stones[i] - stones[j] > k+1) return false;\\n            if(stones[i] - stones[j] < k-1) continue;\\n            if(dfs(stones, j, stones[i]-stones[j])) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canCross(int[] stones) {\\n        int last = stones[stones.length - 1]; //we start from last\\n        for(int i = stones.length - 2; i >= 0; i--) {\\n            if (dfs(stones, i, last-stones[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean dfs(int[] stones, int i, int k) {\\n        if(i == 0 && k == 1) {\\n            return true;\\n        }\\n        for(int j = i-1; j >= 0; j--) {\\n            if(stones[i] - stones[j] > k+1) return false;\\n            if(stones[i] - stones[j] < k-1) continue;\\n            if(dfs(stones, j, stones[i]-stones[j])) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870671,
                "title": "no-dp-beat-100-faster-than-all-dp-posts-with-explanation-recursion-and-iteration",
                "content": "One reason for no extra DP matrix or memo in this task is \\n***final goal of this task is finding out whether there\\'s a way from start to the end, \\nnot checking all search space of all steps(levels) are valid or not.***  \\nIf one step is valid, based on this step, next step is also valid until the end. That\\'s all. \\nIn other words, we don\\'t need to check every k-1, k, k+1, or every index(stones) can be arrived.\\n\\nAnother reason is \\n***there\\'s rarely a duplicate case during search***, \\nso you will find out using seen, visited, memo, DP or Lru_cache or something \\nrecording any previous path or state in this task is almost no help. \\nIf you don\\'t believe, you can remove them. \\nWe also can get the answer and become faster.\\n\\nAnd they can slow down performance. \\nTherefore, we don\\'t need store any failed route or visited step in every index \\nbecause dumping it is easy. It\\'s possible that we arrive the end but don\\'t need to pass by some indexes.\\n\\nI was thinking about the reasons in some time. \\nI suppose that\\'s because the constraint of this task is very strict and the search space is quite narrow. \\nIf broadening the range to k-2, k-1, k, k+1 and k+2 or moving backwards, DP is useful.\\n\\nIn short, \\nthe ***key point is checking whether any jump can arrive any possible forward position(index) .***\\n\\nSolution by recursion and iteration with clear comments as below.\\n[Another great backward recursive solution](https://leetcode.com/problems/frog-jump/discuss/423430/Dead-simple-JS-solution:-work-backwards.-100100/714964)\\n\\n```\\nclass Solution: # recursion\\n    def canCross(self, s):\\n        # check if any difference between indexes is \\n        # over the maximal possible jump at each index first \\n        for i in range(len(s)-1):\\n            if s[i+1] - s[i] > i+1: return False\\n\\n        stones = set(s)    \\n        def f(start, step):\\n            # arrive the end\\n            if start == s[-1]: return True\\n            # can\\'t arrive any index\\n            if start not in stones: return False\\n            # if arrive, new start is previous start + previous step\\n            ss = start + step\\n\\t\\t\\t# as long as any one route is true, done\\n            return (f(ss + 1, step + 1) or  \\n                    f(ss, step) or \\n                    step > 1 and f(ss - 1, step - 1))\\n        # As index 0 is initialized and included in recursive func,\\n        # we can start from index 1\\n        return f(1, 1)\\n```\\n\\n```\\nclass Solution: # iteration\\n    def canCross(self, s):\\n        # check if any difference between indexes is \\n        # over the maximal possible jump at each index first \\n        for i in range(len(s)-1):\\n            if s[i+1] - s[i] > i+1: return False\\n                       \\n        stones = set(s)\\n        # start at index 0\\n        states = [(0, 0)]\\n        \\n        while(states):\\n            start, step = states.pop()\\n            for i in [step-1, step, step+1]:\\n                if i > 0:\\n                    # arrive the end\\n                    if start + i == s[-1]:\\n                        return True\\n                    # only store the successful steps until now and\\n                    # start from there later\\n                    elif start + i in stones:\\n                        states.append((start+i, i))\\n                    \\n        return False\\n```\\n\\nWelcome any suggestion, question, comments.\\n***If helpful, please upvote!!  Thanks a lot!!***",
                "solutionTags": [],
                "code": "```\\nclass Solution: # recursion\\n    def canCross(self, s):\\n        # check if any difference between indexes is \\n        # over the maximal possible jump at each index first \\n        for i in range(len(s)-1):\\n            if s[i+1] - s[i] > i+1: return False\\n\\n        stones = set(s)    \\n        def f(start, step):\\n            # arrive the end\\n            if start == s[-1]: return True\\n            # can\\'t arrive any index\\n            if start not in stones: return False\\n            # if arrive, new start is previous start + previous step\\n            ss = start + step\\n\\t\\t\\t# as long as any one route is true, done\\n            return (f(ss + 1, step + 1) or  \\n                    f(ss, step) or \\n                    step > 1 and f(ss - 1, step - 1))\\n        # As index 0 is initialized and included in recursive func,\\n        # we can start from index 1\\n        return f(1, 1)\\n```\n```\\nclass Solution: # iteration\\n    def canCross(self, s):\\n        # check if any difference between indexes is \\n        # over the maximal possible jump at each index first \\n        for i in range(len(s)-1):\\n            if s[i+1] - s[i] > i+1: return False\\n                       \\n        stones = set(s)\\n        # start at index 0\\n        states = [(0, 0)]\\n        \\n        while(states):\\n            start, step = states.pop()\\n            for i in [step-1, step, step+1]:\\n                if i > 0:\\n                    # arrive the end\\n                    if start + i == s[-1]:\\n                        return True\\n                    # only store the successful steps until now and\\n                    # start from there later\\n                    elif start + i in stones:\\n                        states.append((start+i, i))\\n                    \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861116,
                "title": "c-solution-using-unordered-set-and-hash-map-straight-forward",
                "content": "So the first thing that pops into our heads is to some how store at each position, what are the possible  jumps steps at that location. And this set can be build by all the previous values that we iterated on. So suppose the 6th stone can be reached from 4th stone using a jump of n1, and it can also be reached from 2nd stone using the jump size of n2. \\n\\nNow, the possible jump sizes available at the 6th stone are { n1,n1-1,n1+1, n2,n2-1,n2+1 }. And we can proceed forward. Using this concept, we can sovle it accordingly. \\n\\n```\\nclass Solution {\\npublic:\\n\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map <int, unordered_set<int>> mp ; \\n        for(auto x:stones) mp[x] ; \\n        mp[stones[0]].insert(1); \\n        for(int i=0; i<n; i++){\\n            unordered_set<int> temp = mp[stones[i]]; \\n            for(auto steps: temp){\\n                if(mp.find(stones[i] +steps) != mp.end()){\\n                    mp[stones[i]+steps].insert(steps); \\n                    mp[stones[i]+steps].insert(steps+1);\\n                    if(steps-1!=0) mp[stones[i]+steps].insert(steps-1);\\n                }\\n            }\\n        }\\n        return mp[stones[n-1]].size()!= 0 ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool canCross(vector<int>& stones) {\\n        int n = stones.size();\\n        unordered_map <int, unordered_set<int>> mp ; \\n        for(auto x:stones) mp[x] ; \\n        mp[stones[0]].insert(1); \\n        for(int i=0; i<n; i++){\\n            unordered_set<int> temp = mp[stones[i]]; \\n            for(auto steps: temp){\\n                if(mp.find(stones[i] +steps) != mp.end()){\\n                    mp[stones[i]+steps].insert(steps); \\n                    mp[stones[i]+steps].insert(steps+1);\\n                    if(steps-1!=0) mp[stones[i]+steps].insert(steps-1);\\n                }\\n            }\\n        }\\n        return mp[stones[n-1]].size()!= 0 ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813979,
                "title": "c-dfs-memorization-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, unordered_map<int, int>> mp;\\n    unordered_set<int> stset;\\n    int goalst = -1;\\n    \\n    bool jump(int pos, int k) {\\n        if (k == 0) return false;\\n        if (stset.count(pos) == 0 || pos > goalst) return false; \\n        if (goalst == pos) return true;  \\n        \\n        if (mp.count(pos) && mp[pos].count(k)) return mp[pos][k];\\n        bool success = jump(pos + k - 1, k - 1) || jump(pos + k, k) || jump(pos + k + 1, k + 1);\\n\\n        return mp[pos][k] = success;\\n    }\\n\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        for (auto& stone:stones) stset.insert(stone);\\n        goalst = stones.back();\\n\\n        if (stones.at(0) + 1 != stones.at(1)) return false;\\n\\n        return jump(stones.at(1), 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, unordered_map<int, int>> mp;\\n    unordered_set<int> stset;\\n    int goalst = -1;\\n    \\n    bool jump(int pos, int k) {\\n        if (k == 0) return false;\\n        if (stset.count(pos) == 0 || pos > goalst) return false; \\n        if (goalst == pos) return true;  \\n        \\n        if (mp.count(pos) && mp[pos].count(k)) return mp[pos][k];\\n        bool success = jump(pos + k - 1, k - 1) || jump(pos + k, k) || jump(pos + k + 1, k + 1);\\n\\n        return mp[pos][k] = success;\\n    }\\n\\npublic:\\n    bool canCross(vector<int>& stones) {\\n        for (auto& stone:stones) stset.insert(stone);\\n        goalst = stones.back();\\n\\n        if (stones.at(0) + 1 != stones.at(1)) return false;\\n\\n        return jump(stones.at(1), 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798312,
                "title": "standard-java-solution",
                "content": "### Theory\\nI was asked this during my amazon onsite - I utterly and hopelessly bombed it :(\\nNow that I have been leetcoding for a while, I want to go over how one could potentially derive a solution to this problem.\\n\\nThis problem at first is a recursive problem. At any given iteration we have 3 choices on how we can move forward, which is dependent on what our **previous** choice was. So we need to be very careful when selecting what parameters we want to pass down in our recursive stack. If we pass the wrong ones down we may see that we don\\'t have enough information that we need, versus if we had just passed down the right information.\\n\\nThe main idea is that the stones represent positions of where we are, so we don\\'t need to keep track of indexing or what index we are at, we can simply keep track of our currPos. Once we have found a brute force recursive solution, we can derive a caching/memoization solution.\\n\\n### Solution (Brute Force)\\n```\\n    public boolean canCross(int[] stones) {\\n        Set<Integer> set = new HashSet<>(stones.length);\\n        for (int i : stones) set.add(i);\\n        \\n        return helper(0, 0, stones[stones.length - 1], set);\\n    }\\n    \\n    private boolean helper(int currPos, int prevJump, int lastStone, Set<Integer> set) {\\n        if (!set.contains(currPos)) return false;\\n        if (currPos == lastStone) return true;\\n        \\n        \\n        for (int i = -1; i <= 1; i++) {\\n            int newPos = prevJump + i + currPos;\\n            if (newPos <= currPos) continue; // no point jumping behind or in place\\n            int jumpDist = newPos - currPos;\\n\\n            if (helper(newPos, jumpDist, lastStone, set))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\n### Solution (Caching/Memoization)\\n```\\n    public boolean canCross(int[] stones) {\\n        Set<Integer> set = new HashSet<>(stones.length);\\n        for (int i : stones) set.add(i);\\n        \\n        return helper(0, 0, stones[stones.length - 1], set, new HashMap<String, Boolean>());\\n    }\\n    \\n    private boolean helper(int currPos, int prevJump, int lastStone, Set<Integer> set, Map<String, Boolean> cache) {\\n        if (!set.contains(currPos)) return false;\\n        if (currPos == lastStone) return true;\\n        \\n        String key = currPos + \"-\" + prevJump;\\n        if (cache.containsKey(key)) return cache.get(key);\\n        \\n        \\n        for (int i = -1; i <= 1; i++) {\\n            int newPos = prevJump + i + currPos;\\n            if (newPos <= currPos) continue; // no point jumping behind or in place\\n            int jumpDist = newPos - currPos;\\n\\n            if (helper(newPos, jumpDist, lastStone, set, cache)) {\\n                cache.put(key, true);\\n                return true;\\n            }\\n                \\n        }\\n        \\n        cache.put(key, false);\\n        return false;\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    public boolean canCross(int[] stones) {\\n        Set<Integer> set = new HashSet<>(stones.length);\\n        for (int i : stones) set.add(i);\\n        \\n        return helper(0, 0, stones[stones.length - 1], set);\\n    }\\n    \\n    private boolean helper(int currPos, int prevJump, int lastStone, Set<Integer> set) {\\n        if (!set.contains(currPos)) return false;\\n        if (currPos == lastStone) return true;\\n        \\n        \\n        for (int i = -1; i <= 1; i++) {\\n            int newPos = prevJump + i + currPos;\\n            if (newPos <= currPos) continue; // no point jumping behind or in place\\n            int jumpDist = newPos - currPos;\\n\\n            if (helper(newPos, jumpDist, lastStone, set))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n```\n```\\n    public boolean canCross(int[] stones) {\\n        Set<Integer> set = new HashSet<>(stones.length);\\n        for (int i : stones) set.add(i);\\n        \\n        return helper(0, 0, stones[stones.length - 1], set, new HashMap<String, Boolean>());\\n    }\\n    \\n    private boolean helper(int currPos, int prevJump, int lastStone, Set<Integer> set, Map<String, Boolean> cache) {\\n        if (!set.contains(currPos)) return false;\\n        if (currPos == lastStone) return true;\\n        \\n        String key = currPos + \"-\" + prevJump;\\n        if (cache.containsKey(key)) return cache.get(key);\\n        \\n        \\n        for (int i = -1; i <= 1; i++) {\\n            int newPos = prevJump + i + currPos;\\n            if (newPos <= currPos) continue; // no point jumping behind or in place\\n            int jumpDist = newPos - currPos;\\n\\n            if (helper(newPos, jumpDist, lastStone, set, cache)) {\\n                cache.put(key, true);\\n                return true;\\n            }\\n                \\n        }\\n        \\n        cache.put(key, false);\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 761992,
                "title": "explained-java-index-based-dp-solution",
                "content": "\\n\\t\\t public boolean canCross(int[] a) {\\n         \\n            int n=a.length;\\n\\t\\t\\t\\n\\t        if(n<=1) return true;\\n\\t\\t\\t// linkedlist to store the previous jumps to reach at ith jump\\n\\t       LinkedList<Integer>[] al=new LinkedList[n];\\n\\t      \\n\\t\\t  for(int i=0;i<n;i++){\\n\\t            al[i]=new LinkedList<Integer>();\\n\\t        }\\n\\t     // 0 jump before first stone\\n\\t\\t al[0].add(0);\\n\\t        for(int i=1;i<n;i++){\\n\\t            for(int j=0;j<i;j++){\\n\\t                LinkedList<Integer> l=al[j];\\n                    // number of jumps required to reach ith stone from jth stone\\n\\t                int jump=a[i]-a[j];\\n\\t\\t\\t\\t\\t// we can reach at ith stone if jth stone contains jump, jump+1 or jump-1\\n\\t            if(l.contains(jump)||l.contains(jump+1)||l.contains(jump-1)) al[i].add(jump);\\n\\t       }\\n         }\\n\\t\\t   // return true if we can reach at last stone\\n\\t        return al[n-1].size()!=0;\\n\\t        }\\n\\n\\t",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "\\n\\t\\t public boolean canCross(int[] a) {\\n         \\n            int n=a.length;\\n\\t\\t\\t\\n\\t        if(n<=1) return true;\\n\\t\\t\\t// linkedlist to store the previous jumps to reach at ith jump\\n\\t       LinkedList<Integer>[] al=new LinkedList[n];\\n\\t      \\n\\t\\t  for(int i=0;i<n;i++){\\n\\t            al[i]=new LinkedList<Integer>();\\n\\t        }\\n\\t     // 0 jump before first stone\\n\\t\\t al[0].add(0);\\n\\t        for(int i=1;i<n;i++){\\n\\t            for(int j=0;j<i;j++){\\n\\t                LinkedList<Integer> l=al[j];\\n                    // number of jumps required to reach ith stone from jth stone\\n\\t                int jump=a[i]-a[j];\\n\\t\\t\\t\\t\\t// we can reach at ith stone if jth stone contains jump, jump+1 or jump-1\\n\\t            if(l.contains(jump)||l.contains(jump+1)||l.contains(jump-1)) al[i].add(jump);\\n\\t       }\\n         }\\n\\t\\t   // return true if we can reach at last stone\\n\\t        return al[n-1].size()!=0;\\n\\t        }\\n\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 741511,
                "title": "c-dfs-with-memorization",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        vector<vector<char>> dp(stones.size(), vector<char>(stones.size(), -1));\\n        \\n        return canCross(stones, dp, 0, 0);\\n    }\\n    \\n    bool canCross(vector<int>& stones, vector<vector<char>>& dp, int start=0, int jump=0) {\\n        \\n        if(start==stones.size()-1) \\n            return true;\\n        \\n        if(dp[start][jump]!=-1) \\n            return dp[start][jump];\\n        \\n        bool can=false;\\n        int cur=stones[start];\\n        for(int i=start+1; i<stones.size() && !can; i++){\\n            int need = stones[i]-cur;\\n            if(need-jump>1) \\n                break;\\n            if(need-jump<=1 && need-jump>=-1)\\n                can = canCross(stones, dp, i, need);\\n        }\\n        \\n        return dp[start][jump]=can;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool canCross(vector<int>& stones) {\\n        \\n        vector<vector<char>> dp(stones.size(), vector<char>(stones.size(), -1));\\n        \\n        return canCross(stones, dp, 0, 0);\\n    }\\n    \\n    bool canCross(vector<int>& stones, vector<vector<char>>& dp, int start=0, int jump=0) {\\n        \\n        if(start==stones.size()-1) \\n            return true;\\n        \\n        if(dp[start][jump]!=-1) \\n            return dp[start][jump];\\n        \\n        bool can=false;\\n        int cur=stones[start];\\n        for(int i=start+1; i<stones.size() && !can; i++){\\n            int need = stones[i]-cur;\\n            if(need-jump>1) \\n                break;\\n            if(need-jump<=1 && need-jump>=-1)\\n                can = canCross(stones, dp, i, need);\\n        }\\n        \\n        return dp[start][jump]=can;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729087,
                "title": "c-dynamic-programming-similar-to-bfs-timeout-issue",
                "content": "July 10, 2020\\n**Introduction**\\n\\nIt was my mock interview algorithm as an interviewee. I learned from the interviewer - An Amazon engineer in Seattle who showed me how to solve the code efficiently through interview. \\n\\n**Case study**\\nThe code has TLE bug and it could not pass one of the test cases.\\nI will look into the issue. Stay tuned. \\n\\nFor example, [0, 1, 2, 3, 4, 5]\\nstoneStop 0: 0\\nstoneStop 1: 1\\nstoneStop 2: 1\\nstoneStop 3: 2, 1\\nstoneStop 4: 2, 1, 1\\nstoneStop 5: \\nBecause stopStop 4\\'s choice of jump has two copies of 1, it will time out for test case [0, 1, 2, 3, ..., 999]. 15 / 39 test cases passed. Time limit exceeded. \\n\\n```\\npublic class Solution {\\n    public bool CanCross(int[] stones) {\\n        if(stones == null || stones.Length == 0) \\n            {\\n                return false; \\n            }\\n        \\n            var length = stones.Length; //8       \\n        \\n            var dp = new Dictionary<int, List<int>>();        \\n        \\n            // tip 1: put those stones into hashmap\\n            for(int i = 0; i < length; i++)\\n            {           \\n                dp.Add(stones[i], new List<int>()); \\n            }\\n        \\n            // dynamic programming from bottom up\\n            // [0,1,3,5,6,8,12,17]\\n            //         dp[0].Add(0); // [0]\\n            //         // dp[17]\\n            //         {\\n            //             0 , 1, 2, 3 .. length\\n            //         }\\n        \\n            //         hash table? \\n            //         {\\n            //             0 : list\\n            //             1 : list\\n            //             3 : list\\n            //                 ...\\n            //             17: list.length > 0\\n            //         }              \\n        \\n            // [0, 1, 3, ..., 17\\n            dp[0].Add(0);\\n        \\n            for(int i = 0; i < length; i++) // tip 2: Do not mix index with stones[index]\\n            {\\n                // stones are in the river, so we give a good name called stoneStop\\n                var stoneStop = stones[i]; \\n            \\n                var list = dp[stoneStop].ToList(); // make a copy\\n                foreach(var jump in list)  // tip 3: list of jumps\\n                {\\n                    // same, +1, -1 jump                 \\n                    var sameStep = jump;\\n                    var plusOne  = jump + 1; \\n                    var minusOne = jump - 1; \\n                \\n                    var choices = new int[]{sameStep, plusOne, minusOne};\\n                \\n                    /// tip 4: make the code flat - so remove nested if statement using negative checking, \\n                    /// call continue statement\\n                    foreach(var item in choices)\\n                    {\\n                        // item are the available k units\\n                        // You want to make sure the item are forward                                       \\n                        if( item < 0)\\n                        {\\n                            continue; \\n                        }\\n                    \\n                        var target = stoneStop + item;\\n                        \\n                        if(!dp.ContainsKey(target))\\n                        {\\n                            continue; \\n                        }                                                                                                                            \\n                        // stone number = not index\\n                        dp[stoneStop + item].Add(item);                                             \\n                        // return early - TLE concern\\n                        if (dp[stones[length - 1]].Count > 0)\\n                            return true; \\n                    }                                \\n                }            \\n            }\\n        \\n            return dp[stones[length - 1]].Count > 0;      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CanCross(int[] stones) {\\n        if(stones == null || stones.Length == 0) \\n            {\\n                return false; \\n            }\\n        \\n            var length = stones.Length; //8       \\n        \\n            var dp = new Dictionary<int, List<int>>();        \\n        \\n            // tip 1: put those stones into hashmap\\n            for(int i = 0; i < length; i++)\\n            {           \\n                dp.Add(stones[i], new List<int>()); \\n            }\\n        \\n            // dynamic programming from bottom up\\n            // [0,1,3,5,6,8,12,17]\\n            //         dp[0].Add(0); // [0]\\n            //         // dp[17]\\n            //         {\\n            //             0 , 1, 2, 3 .. length\\n            //         }\\n        \\n            //         hash table? \\n            //         {\\n            //             0 : list\\n            //             1 : list\\n            //             3 : list\\n            //                 ...\\n            //             17: list.length > 0\\n            //         }              \\n        \\n            // [0, 1, 3, ..., 17\\n            dp[0].Add(0);\\n        \\n            for(int i = 0; i < length; i++) // tip 2: Do not mix index with stones[index]\\n            {\\n                // stones are in the river, so we give a good name called stoneStop\\n                var stoneStop = stones[i]; \\n            \\n                var list = dp[stoneStop].ToList(); // make a copy\\n                foreach(var jump in list)  // tip 3: list of jumps\\n                {\\n                    // same, +1, -1 jump                 \\n                    var sameStep = jump;\\n                    var plusOne  = jump + 1; \\n                    var minusOne = jump - 1; \\n                \\n                    var choices = new int[]{sameStep, plusOne, minusOne};\\n                \\n                    /// tip 4: make the code flat - so remove nested if statement using negative checking, \\n                    /// call continue statement\\n                    foreach(var item in choices)\\n                    {\\n                        // item are the available k units\\n                        // You want to make sure the item are forward                                       \\n                        if( item < 0)\\n                        {\\n                            continue; \\n                        }\\n                    \\n                        var target = stoneStop + item;\\n                        \\n                        if(!dp.ContainsKey(target))\\n                        {\\n                            continue; \\n                        }                                                                                                                            \\n                        // stone number = not index\\n                        dp[stoneStop + item].Add(item);                                             \\n                        // return early - TLE concern\\n                        if (dp[stones[length - 1]].Count > 0)\\n                            return true; \\n                    }                                \\n                }            \\n            }\\n        \\n            return dp[stones[length - 1]].Count > 0;      \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2032237,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1569627,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2010491,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2031784,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032301,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1565483,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032150,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2031776,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1573131,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032382,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032237,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1569627,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2010491,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2031784,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032301,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1565483,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032150,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2031776,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1573131,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 2032382,
                "content": [
                    {
                        "username": "souvikmkhrj",
                        "content": "When you try to jump between stones but the gap is too large:\\n\\n<a href=\"https://imgur.com/5tgGDW4\"><img src=\"https://i.imgur.com/5tgGDW4.gif\" title=\"source: imgur.com\"  Width=\"350px\"/></a>"
                    },
                    {
                        "username": "harshitisback",
                        "content": "then you need a dp algorithm solution"
                    },
                    {
                        "username": "silpo",
                        "content": "How can the frog jump from 6th stone (at 8 position) to 7th stone (at 12 position)?\\nThe previous jump was 6 position to 8 position =2 units,\\nAnd now it has to be 12-8=4 units!\\n\\nThanks\\n"
                    },
                    {
                        "username": "pa1kalyanmudhiraj",
                        "content": "There is another possibility, jump from 5th position to 8th position = 3 units, after this possible jumps are 2,3 & 4 units, now we make jump of length 4 from 8th position to reach 12th position."
                    },
                    {
                        "username": "Divyanshuagarwal23",
                        "content": "very easy should be marked medium"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Or even easy. "
                    },
                    {
                        "username": "charonme",
                        "content": "agree, this is classic straightforward typical dp easier than many medium dp problems. There are just a couple of interesting edge cases, but they\\'re also easily handled. Even then there are many much harder medium problems here."
                    },
                    {
                        "username": "borjaf696",
                        "content": "Not agree for users that hard problems are indeed hard this is a relief, since we are able to do it after a couple of failures. Probably for more expert users not..."
                    },
                    {
                        "username": "DuckyShine04",
                        "content": "[@user5400vw](/user5400vw) Agreed as well, this was my very first hard DP problem without any external outside help. The decision tree and state transitions were not that difficult to come up with. There are definitely harder medium difficulty DP problems."
                    },
                    {
                        "username": "user5400vw",
                        "content": "agree, not sure why this is harder than the hundreds of similar medium dp problems"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Again a DP problem. Since the array stones is ascending, one can use binary search to find the next jump"
                    },
                    {
                        "username": "charonme",
                        "content": "[@anwendeng](/anwendeng) hash tables are faster asymptotically, but when you have a small number of items the fixed cost of hash tables takes over. There are many problems exhibiting this on leetcode because the test case sizes are restricted"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@Shubham_Raj22](/Shubham_Raj22) Thanks for your comment. I did implementation using hash tables  & compared their speed behaviors. The  implementation using hash tables is supposed to be faster, but it is not. Strange!"
                    },
                    {
                        "username": "manifest_repeat",
                        "content": "I think this is not the place to discuss solution\\n"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "or one can store it in a map and use that only, instead of searching again and again in O(logn) you can once iterate throught the array then search in O(1)"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "This question was pretty straight forward and simple but I was not\nable make my code submit in my first attempt.*(so embarrassing sometimes it's not your day)*\nBut you can here is some tips might help you out:\n\n**Dynamic Programming and Memorization:** ->$$O(N^2)$$\n While the problem appears simple, using dynamic programming or recursion with memorization can be key to solving it optimally. With these approaches, you can efficiently store and retrieve solutions to subproblems, avoiding redundant calculations and making the algorithm blazing fast.\n\n**Memorization Approach:** To start, set up a 2D array for memorization, where **arr[curr_stone][jump]** will store whether it's possible to reach the end from a specific stone with a certain jump count. The range for both parameters should be within the size of the stones array, as we can increase or decrease the jump at each stone.\n\n**Skipping Stones and Binary Search:** You might have noticed that you can skip certain stones if your jump is large enough. To handle this efficiently, consider using binary search to find the stone index that matches the frog's next position after a jump. This way, you can focus on relevant stones and optimize the algorithm.\n\n**Maps:** Using a map to associate an index with the stone's position can significantly speed up your algorithm. It reduces the time needed for searching and improves overall efficiency, as you can quickly access the stone's position instead of iterating through the array.\n\n**Additional Perspective:** Remember, sometimes it's the smaller optimizations that can make a big difference. Dive deep into the problem, consider edge cases, and explore different scenarios to fine-tune your solution.\n\n**Let's Collaborate:** Feel free to share your thoughts and experiences as you work on this problem. If you encounter any roadblocks or have creative ideas, don't hesitate to discuss them. We're all here to learn and grow together.\n\nHappy coding, and may your frog leap to success effortlessly! "
                    },
                    {
                        "username": "thrillobit",
                        "content": "One may use queues and hash.\\nNo DP, no memo.\\n[link](https://leetcode.com/problems/frog-jump/solutions/3968813/solution-based-on-queues-with-optimized-memory/)"
                    },
                    {
                        "username": "synckey",
                        "content": "[0,1,3,5,6,8,12,17]\\n\\nThere are a total of 8 stones.\\nThe first stone at the 0th unit, second stone at the 1st unit,\\nthird stone at the 3rd unit, and so on...\\nThe last stone at the 17th unit.\\n\\nReturn true. The frog can jump to the last stone by jumping \\n1 unit to the 2nd stone, then 2 units to the 3rd stone, `then \\n2 units` to the 4th stone, then 3 units to the 6th stone, \\n4 units to the 7th stone, and 5 units to the 8th stone.\\n\\nthe question describes `If the frog's last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. `, but in the demo ,the frog dump 2 units followed by another 2 units, is that jump valid?"
                    },
                    {
                        "username": "Shivam1202",
                        "content": "Its last jump was 2 units, so now it can jump (2-1), (2) or (2+1) units. Hope that helps."
                    },
                    {
                        "username": "yoyoyougesh978",
                        "content": "its clearly written it can either jump k+1,k,or k-1\\n"
                    },
                    {
                        "username": "yinhslin",
                        "content": "This is medium, not hard"
                    },
                    {
                        "username": "idnedvryaasnein",
                        "content": "Some additional test cases(2):\n\n[0,2147483647]\n[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999]"
                    },
                    {
                        "username": "jiazheng",
                        "content": "I am using the n^2 dp solution and i still cannot pass. The same solution passed easily using java."
                    },
                    {
                        "username": "niharika412",
                        "content": "For [0,2], frog jumps 2 units from stone 0 and reaches stone 1. Should Output not be true in that case?\\n"
                    },
                    {
                        "username": "Ahmad_2002",
                        "content": "having the same doubt. Can someone give a correct response to this"
                    },
                    {
                        "username": "Hussain_14",
                        "content": "At the first place the frog dint jump thats why the previous jump value at i=0 is 0. So at max k+1 would be 1 and not 2."
                    },
                    {
                        "username": "Vld_55",
                        "content": "hi. I had this problem too. It happens because of the constraints: \"assumes the first jump must be 1 unit.\"  So I checked it with: if stones[1] - stones[0] > 1: return False. Then I started the algorithm with stone number 2."
                    }
                ]
            },
            {
                "id": 1573740,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 1567401,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 1572160,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 2033365,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 2032339,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 2031791,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 2031785,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 1574153,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 1569362,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 2033998,
                "content": [
                    {
                        "username": "davidseek",
                        "content": "![image](https://assets.leetcode.com/users/davidseek/image_1589319494.png)\\n\\nWe have `[0,1,3,6,10]`\\nThere is literally no other way to reach those stones but in the way described in my log.\\n\\nThat means at stone `10` we have `4` as the current jump distance\\nNow we can jump `3` to stone `13` or `5` to stone `15`.\\n\\nBut in neither cases we can each stone 18 as:\\n`15 -> 18 is 3` but our only options are `[4,5,6]`\\nand `13 -> 18 is 5` but the only options are `[2,3,4]`\\n\\nSo why is the expected output `true`? What am I missing?\\nHelp is very appreciated."
                    },
                    {
                        "username": "nekoaoi",
                        "content": "We can jump from 10 -> 13 and now we have the following options [2, 3, 4]\\nNow we can jump to 13 -> 15 and we have the following options [1, 2, 3]\\nAt last, we can jump from 15 -> 18 by jumping 3 units. "
                    },
                    {
                        "username": "saran007",
                        "content": "[@daonguyen3197](/daonguyen3197)  you can reach 13 to 15 by 2 stones as there is also a k-1 constraint so as your previous jump is 3 units 3-1 and jump 2 units to reach 15 then 2+1 3 units to reach 18 that\\'s it.\\n"
                    },
                    {
                        "username": "daonguyen3197",
                        "content": "Same issue. I dont understand\nHere my solution:\nclass Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        jump = [0] * len(stones)\n        jump[0] = 1\n        track = [0] * len(stones)\n        for i in range(1, len(stones)):\n            for j in range(i-1, -1, -1):\n                if jump[j] != 0:\n                    if stones[j]+jump[j]-1 <= stones[i] <= stones[j]+jump[j]+1:\n                        track[i] = j\n                        jump[i] = stones[i] - stones[j]\n        return True if track[len(stones)-1] != 0 else False\n                \n"
                    },
                    {
                        "username": "neerajjain92",
                        "content": "IMO it should be true, initially i have k = 1, i can jump k+1 units to get to 2. So the output should be true."
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "[@Dxuian](/Dxuian) If you read the problem carefully, it is mentioned that your first jump must be of 1 unit so that means if there\\'s no stone at position = 1, you can straight away return false. I don\\'t know if the problem description was different earlier but the testcase is correct according to current problem statement."
                    },
                    {
                        "username": "Dxuian",
                        "content": "thats what i think too "
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I wasted time looking for a n solution, cause n^2 is trivial for this question since it is a hard..."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "hard doesn\\'t mean n^2  constriants:)"
                    },
                    {
                        "username": "abaranov25",
                        "content": "I believe there\\'s an n log n solution that you can try finding"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "advice for all the beginners (for dp problems), stick to concepts and understand how dp problems work, just not submit the soln for the sake of it.!!!!!!!!\\nalways try to draw a little recursion tree, these are some tips I would like share, after learning from my past mistakes and experiences. "
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Holy cow! I don\\'t believe myself that I did this question completely on my own."
                    },
                    {
                        "username": "bhati25",
                        "content": "<h2>DP !! DP !! DP !! I love DP. \\uD83D\\uDE2D </h2>\\nWhy am I not able to solve this,  trying for the last 1 hour haha \\uD83D\\uDE2D "
                    },
                    {
                        "username": "jswang00037",
                        "content": "not so HARD actually"
                    },
                    {
                        "username": "shubh121",
                        "content": "[0,1,3,5,6,8,12,17] in this 6 to 8 --jump is of 2 units and then in next 8 to 12 that is 4 unit jump..\\n"
                    },
                    {
                        "username": "toberich",
                        "content": "So \\n1->3(2)->6(3)->10(4) which is bigger value than 7. why this is a false?"
                    },
                    {
                        "username": "falgunitagadkar",
                        "content": "Initially, the frog is on the first stone and assumes the first jump must be 1 unit."
                    },
                    {
                        "username": "Parzival18s",
                        "content": "Frog needs to cross river by landing on the last stone"
                    },
                    {
                        "username": "thrillobit",
                        "content": "I did this task without DP and/or memo.\\nLol :)"
                    }
                ]
            },
            {
                "id": 2033347,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2033114,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2032674,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2032647,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2032512,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2032199,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2031758,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 1575464,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 1572061,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2064862,
                "content": [
                    {
                        "username": "patelharish953",
                        "content": "[0,1,3,5,6,8,12,17]\\nin this ,on index 4 and k is 2,for 8 to 12 ,last min k is needed is 3. then how ?\\nans is true i don\\'t get it"
                    },
                    {
                        "username": "user786_",
                        "content": "It jumped from 5 to 8 then 8 to 12. 6 was skipped"
                    },
                    {
                        "username": "jebbe",
                        "content": "For memorization in JS, what data structure is best for a cache?  I started with an object then switched to a map. This way I can check cache.has(`${pos}_${k}`).\\nEveryone seems to be using arrays. What are the differences between each approach? "
                    },
                    {
                        "username": "yjian012",
                        "content": "Need new test cases coz [wrong solutions pass all test](\\nhttps://leetcode.com/problems/frog-jump/solutions/3966415/counter-example-to-the-top-submissions-beats-100/)."
                    },
                    {
                        "username": "codez93",
                        "content": "Again medium disguised as hard."
                    },
                    {
                        "username": "PolYarik",
                        "content": "Why did the frog cross the river?\\n-To make programmers\\' lives hard \\uD83D\\uDC38"
                    },
                    {
                        "username": "ajitesh_k_k",
                        "content": "Why the tabulation is giving TLE in this problem !?"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Not hard, medium at best"
                    },
                    {
                        "username": "CodingEncoded",
                        "content": "Testcase 44 - [0, 1, 3, 5, 6, 8, 12, 17] says true and I\\'m not sure that right. As far as I know\\n\\n0 - 1 - 3 - 6 - 8 - ?????? I mean the jump now is either 1 or 3 you can\\'t get twelve?\\n\\nPls help."
                    },
                    {
                        "username": "chiragsharma399",
                        "content": "what if the path will be 0 - 1- 3 - 5 - 8 .... ? at 3 it has 2 options either 5 or 6"
                    },
                    {
                        "username": "queenleet",
                        "content": "Hello,\\n\\nI got [0,1,3,5,6,8,12,17] should return true. But from 6 to 8, frog jumps 2. but from 8 to12, it needs to jump 4. but 2-1=1, 2, 2+1=3, there is no way it can reach 12. Did I misunderstand the question?\\n\\nThanks,"
                    },
                    {
                        "username": "rambosalad",
                        "content": "[@hariharankh2](/hariharankh2) how can you jump from 3 to 5? the previous jump from 1 to 3 is a distance of 2 units and the description says the next jump must be either k-1 or k+1 units, which means we can only land on 4 or 6, not 5."
                    },
                    {
                        "username": "hariharankh2",
                        "content": "0 to 1 then jump = 1\\n1 to 3 then jump = 2\\n3 to 5 then jump = 2\\n5 to 8 then jump = 3\\n8 to 12 then jump = 4\\n12 to 17 then jump = 5"
                    },
                    {
                        "username": "RuiyangDai",
                        "content": "this should be marked as easy"
                    }
                ]
            },
            {
                "id": 2053196,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2036811,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2036541,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2033441,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2033379,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2033319,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2033237,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2033155,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2033144,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2032944,
                "content": [
                    {
                        "username": "satendra_04",
                        "content": "if the frog can jump in forward direction only then why k-1 ?"
                    },
                    {
                        "username": "jnl000",
                        "content": "This is probably the weirdest task I have ever made. Even the solution is weird, because it\\'s the same as reusing money that you have already used. I wonder how this applies to the real world!"
                    },
                    {
                        "username": "ramcharan131000",
                        "content": "O(n^2) solution written in python gets TLE. (50/52)"
                    },
                    {
                        "username": "antang06211",
                        "content": "\"52/52 testcases passed\" but still \"Time Limit Exceeded\", and the last expected input is empty. I\\'m so confused."
                    },
                    {
                        "username": "layyy",
                        "content": "insert all the jumps possible for a given index in an unordered set (vector of unordered sets) and check if the last unordered set of vector is empty or not"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "This happened first time, i have solved some dp problems, and somehow i have memorized the problems(ig not exactly) ,i knew recursive approach to this problem ,quite similar to last contest . but did not gave much thought about the dp approach ,and i did what could arbitrary felt right. and guess what it ticked. I am just don\\'t what to take from this."
                    },
                    {
                        "username": "engixLC",
                        "content": "For usecase 1: [0,1,3,5,6,8,12,17]\\n\\nHow does the code decides to jump from 5 to 8?\\nI understand using k = 2; k+1 satisfies the logic but in that sense, the code should have jumped from 3 to 6 as well. Or am I missing anything?\\n\\n\\nMy approach to the problem was as follows: assuming k starts with 1\\n0 --> 1 [k=1]; satisfies k = k\\n1 --> 3 [k=2]; satisfies k = k+1\\n3 --> 5 [k=2]; satisfies k = k\\n5 --> 6 [k=1]; satisfies k = k-1\\n6 --> 8 [k=2]; satisfies k = k+1\\nbut as 8 --> 12 is larger than k+1; I return false"
                    },
                    {
                        "username": "chenon",
                        "content": "<b>Input:</b> stones = [0,1,3,5,6,8,12,17]\nOn the  6th stone ( stones[5] ) , I don't get the `3 units`  but `2 units` (  8-6 = stones[5]-stones[4] ).\n\nFor the rest, the numbers check.\n`4 units` to the 7th stone . 4 =  12 - 8 = stones[6] - stones[5]\nand `5 units` to the 8th stone. 5 = 17 - 12 = stones[7] - stones[7] \n\nCan someone explain ? 3 units to the 6th stone\n\nPS : Answer Before jumping on the 6th stone, the frog was on the 4th stone. \nstones[5] - stones[3] = 8 - 5 = 3.\nSo the frog skipped the 5th stone ."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "What\\'s wrong in my approach?\\n\\n`class Solution {\\n    public boolean canCross(int[] stones) {\\n        int n = stones.length - 1;\\n        int currJump = stones[n] - stones[n - 1];\\n        return jump(n-1, currJump, stones);\\n    }\\n\\n    public boolean jump(int idx, int currJump, int[] stones) {\\n        if (idx == 0) {\\n            return true;\\n        }\\n        int nextJump = stones[idx] - stones[idx - 1];\\n\\n        if (nextJump == currJump || nextJump == currJump - 1 || nextJump == currJump + 1) {\\n            return jump(idx - 1, nextJump, stones);\\n        }\\n        return false;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Please explain why this is true?\\n\\n[0,1,3,6,10,13,14]"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->6 = 3 (k + 1)\\n6->10 = 4 (k + 1)\\n10->14 = 4 (k)\\nIts not necessary for the frog to go through all the stones, the objective is to reach the last stone however it may be. And if it can reach the last stone in some way, output is true. "
                    }
                ]
            },
            {
                "id": 2032901,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032892,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032891,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032858,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032799,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032714,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032712,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032688,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032601,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032556,
                "content": [
                    {
                        "username": "thomaszwinger",
                        "content": "I saw that it was a hard and missed the part about the frog only being able to jump in the forward direction. It is very important to read closely because I spent a half hour trying to make a mask that would incorporate the last jump distance so I\\'d only have to run 2D DP and not hit a TLE."
                    },
                    {
                        "username": "ladiaadrian",
                        "content": "Input: stones = [0,1,3,5,6,8,12,17]\\nOutput: true\\n\\nfirst jump from 0 to 1= 1 k\\nsecond jump from 1 to 3 = 2 k\\nthird jump from 3 to 5 = 2 k but the options that the frog can do is only 1k or 3k since k +1 or k -1 is allowed so it should be false???"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "It\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nIt can be k also"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "For 1st test case (stones = [0,1,3,5,6,8,12,17]) , how this will be True!\\nIt\\'s clearly mentioned that If the frog\\'s last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\\nthen for 6th position to 7th position it have to jump 4 unit but the previous jump unit is 2 , so it should be 1,2 and 3.\\n"
                    },
                    {
                        "username": "engixLC",
                        "content": "[@iamsuteerth](/iamsuteerth) \\n\\nbut 3 -> 6 (k+1) would have also been possible"
                    },
                    {
                        "username": "barikshouvik",
                        "content": "[@iamsuteerth](/iamsuteerth)  thanks"
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "0->1 = 1 (k + 1)\\n1->3 = 2 (k + 1)\\n3->5 = 2 (k)\\n5->8 = 3 (k + 1)\\n8->12 = 4 (k + 1)\\n12->17 = 5 (k + 1)\\n\\nThis is how the frog will jump."
                    },
                    {
                        "username": "iamsuteerth",
                        "content": "I think this problem is not that difficult considering the hard problems I\\'ve solved so far. Could have been a medium. Just have to be careful when calculating next jump indices and positions from stones array.\\nStandard Recursion+Memoization DP problem"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "A very interesting problem that can be solved with a DP and a Map<Integer, Boolean>[] array to keep track of possibilities to build the chain of jumps if you have arrived on index[x] AND have multiple options to jump/intervals.\\nEG: [0,1,2,3,5,6,8,12,17].\\nDP[1] has two entries: jump of interval 1 (to stone2) and interval 2 (to stone 3).\\nDP[3] has 3 entries: jump of interval 1 (coming from 2) which can land on stones (4,5)\\n    jump of interval 2 (coming from 1) which can land on stones (4,5,6).\\nCache these in a Map<Integer, Boolean> as intervals can get pretty high."
                    },
                    {
                        "username": "Mridul2003",
                        "content": "For testcase - [0,2]\\ncheck the condition : if(stones[1]-stones[0]>1)return false;"
                    },
                    {
                        "username": "BogdanJava",
                        "content": "yeah it doesn\\'t seem like a very hard DP question. Could easily be a medium one"
                    },
                    {
                        "username": "vinnie17",
                        "content": "if we get true from the 1st or 2nd jump then why are we checking for other jumps? should not we just return true?"
                    },
                    {
                        "username": "ashurockzz",
                        "content": "What should be the size of the dp array, can someone pls tell a generalised approach, I face problem always when declaring a dp array..."
                    },
                    {
                        "username": "sam_cee",
                        "content": "In test case 51, how does the frog jump from 998 to 1035 when every previous jump has only been 1 unit??\\n"
                    }
                ]
            },
            {
                "id": 2032465,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2032414,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2032401,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2032283,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2032123,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2031848,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2031822,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2031775,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2031756,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            },
            {
                "id": 2031750,
                "content": [
                    {
                        "username": "parthdharmale008",
                        "content": "https://leetcode.com/problems/frog-jump/solutions/3965803/using-hashmap-with-example-explanation/"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Why Would I like to solve How a Frog jumps ."
                    },
                    {
                        "username": "web_master_01",
                        "content": "GETTING WRONG ANSWER PLEASE ANYONE HELP\nclass Solution {\npublic:\nunordered_map<int,int>mp;\nbool solve(int n,int i,vector<int>&stones,int jump,vector<vector<int>>&dp){\n    if(i==n-1){\n        return true;\n    }\n    if(i>=n){\n        return false;\n    }\n    if(dp[i][jump]!=-1){\n        return dp[i][jump];\n    }\n    bool ans1=0,ans2=0,ans3=0;\n    if(mp.find(stones[i] + jump) != mp.end()){\n        ans1=solve(n,i+jump,stones,jump,dp);\n    }\n    if(mp.find(stones[i] + jump+1) != mp.end()){\n        ans2=solve(n,i+jump+1,stones,jump+1,dp);\n    }\n    if(jump >1 && mp.find(stones[i] + jump-1) != mp.end()){\n        ans3=solve(n,i+jump-1,stones,jump-1,dp);\n    }\n     cout<<stones[i]<<\" \";\n     return dp[i][jump]=ans1||ans2||ans3;\n\n}\n    bool canCross(vector<int>& stones) {\n        int n=stones.size();\n        int jump=1;\n        if(n==0){\n            return false;\n        }\n         if (stones[1] != 1) {\n            return false;\n        }\n        for(auto num:stones){\n            mp[num]++;\n        }\n        vector<vector<int>>dp(n+1,vector<int>(n+2,-1));\n        return solve(n,1,stones,jump,dp);\n        }\n};   \nAnyOne Please Tell me where am i doing wrong?\n"
                    },
                    {
                        "username": "Ninja_Ani",
                        "content": "Example 1 is incorrect , it should be 9 instead of 8."
                    },
                    {
                        "username": "kar-kar",
                        "content": "not Hard at all"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Contest + HARD on sunday, *dumb way to ruin your day*"
                    },
                    {
                        "username": "sentenzo",
                        "content": "It\\'s not so bad, your day is far from being ruined. This one is a relatively easy \"hard\" task. Consider it a regular \"medium\". Just try it out: you\\'ll be surprised how easily it gives in."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Don\\'t get scared by the Hard tag, it\\'s a normal medium dp problem, you can solve it!"
                    },
                    {
                        "username": "Husoski",
                        "content": "I have two questions, actually.  Why is this \"Hard\"? Why is \"Dynamic Programming\" the only approach hinted in \"Related Topics\"?\\n\\nI took this as a straightforward depth-first search problem and passed all test with \"Beats 80% time, beats 70% space\" comparison.  Seems like a pretty good memory-space tradeoff for an unrefactored Python solution.  [Search space was 2D: (array index, last jump length), if you want to take a stab at it.]"
                    },
                    {
                        "username": "Braderbell",
                        "content": "trivial with top-down DP, not so simple with bottom-up"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "If you want to make a visited data structure, make sure that you store the current stone with the current k. Being on the same stone with different k values has potentially differing results."
                    }
                ]
            }
        ]
    }
]