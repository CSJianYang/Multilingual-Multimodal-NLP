[
    {
        "title": "Print in Order",
        "question_content": "Suppose we have a class:\n\npublic class Foo {\n  public void first() { print(\"first\"); }\n  public void second() { print(\"second\"); }\n  public void third() { print(\"third\"); }\n}\n\nThe same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().\nNote:\nWe do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests' comprehensiveness.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: \"firstsecondthird\"\nExplanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output.\n\nExample 2:\n\nInput: nums = [1,3,2]\nOutput: \"firstsecondthird\"\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output.\n\n&nbsp;\nConstraints:\n\n\tnums is a permutation of [1, 2, 3].",
        "solutions": [
            {
                "id": 335939,
                "title": "5-python-threading-solutions-barrier-lock-event-semaphore-condition-with-explanation",
                "content": "\\nRaise two barriers. Both wait for two threads to reach them.\\n\\nFirst thread can print before reaching the first barrier. Second thread can print before reaching the second barrier. Third thread can print after the second barrier.\\n\\n```\\nfrom threading import Barrier\\n\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n            \\n    def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n        \\n    def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n            \\n    def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n ```\\n \\nStart with two locked locks. First thread unlocks the first lock that the second thread is waiting on. Second thread unlocks the second lock that the third thread is waiting on.\\n\\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```        \\nSet events from first and second threads when they are done. Have the second thread wait for first one to set its event. Have the third thread wait on the second thread to raise its event.\\n\\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.done = (Event(),Event())\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.done[0].set()\\n        \\n    def second(self, printSecond):\\n        self.done[0].wait()\\n        printSecond()\\n        self.done[1].set()\\n            \\n    def third(self, printThird):\\n        self.done[1].wait()\\n        printThird()\\n\\n```        \\nStart with two closed gates represented by 0-value semaphores. Second and third thread are waiting behind these gates. When the first thread prints, it opens the gate for the second thread. When the second thread prints, it opens the gate for the third thread.\\n\\n```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n            \\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n\\n ```        \\n\\nHave all three threads attempt to acquire an RLock via Condition. The first thread can always acquire a lock, while the other two have to wait for the `order` to be set to the right value. First thread sets the order after printing which signals for the second thread to run. Second thread does the same for the third.\\n\\n```\\nfrom threading import Condition\\n\\nclass Foo:\\n    def __init__(self):\\n        self.exec_condition = Condition()\\n        self.order = 0\\n        self.first_finish = lambda: self.order == 1\\n        self.second_finish = lambda: self.order == 2\\n\\n    def first(self, printFirst):\\n        with self.exec_condition:\\n            printFirst()\\n            self.order = 1\\n            self.exec_condition.notify(2)\\n\\n    def second(self, printSecond):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.first_finish)\\n            printSecond()\\n            self.order = 2\\n            self.exec_condition.notify()\\n\\n    def third(self, printThird):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.second_finish)\\n            printThird()\\n```\\n            \\n",
                "solutionTags": [],
                "code": "```\\nfrom threading import Barrier\\n\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n            \\n    def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n        \\n    def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n            \\n    def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n ```\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.done = (Event(),Event())\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.done[0].set()\\n        \\n    def second(self, printSecond):\\n        self.done[0].wait()\\n        printSecond()\\n        self.done[1].set()\\n            \\n    def third(self, printThird):\\n        self.done[1].wait()\\n        printThird()\\n\\n```\n```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n        \\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n            \\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n\\n ```\n```\\nfrom threading import Condition\\n\\nclass Foo:\\n    def __init__(self):\\n        self.exec_condition = Condition()\\n        self.order = 0\\n        self.first_finish = lambda: self.order == 1\\n        self.second_finish = lambda: self.order == 2\\n\\n    def first(self, printFirst):\\n        with self.exec_condition:\\n            printFirst()\\n            self.order = 1\\n            self.exec_condition.notify(2)\\n\\n    def second(self, printSecond):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.first_finish)\\n            printSecond()\\n            self.order = 2\\n            self.exec_condition.notify()\\n\\n    def third(self, printThird):\\n        with self.exec_condition:\\n            self.exec_condition.wait_for(self.second_finish)\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332890,
                "title": "java-basic-semaphore-solution-8ms-36mb",
                "content": "\"Semaphore is a bowl of marbles\" - Professor Stark\\n\\n1. Semaphore is a bowl of marbles (or locks in this case). If you need a marble, and there are none, you wait. You wait until there is one marble and then you take it. If you release(), you will add one marble to the bowl (from thin air). If you release(100), you will add 100 marbles to the bowl. **run2.release();** will add one **\"run2\"** marble to the **\"run2 bowl\"**.\\n2. The thread calling **third()** will wait until the end of **second()** when it releases a **\\'run3\\'** marble. The **second()** will wait until the end of **first() **when it releases a **\\'run2\\'** marble. Since **first()** never acquires anything, it will never wait. There is a forced wait ordering.\\n3. With semaphores, you can start out with 1 marble or 0 marbles or 100 marbles. A thread can take marbles (up until it\\'s empty) or put many marbles at a time.\\n\\nYou can solve this using other solutions (check bottom), but if you wake up a thread and make it spin in a loop and wait for some condition, it is a waste of CPU. You can make the thread go to sleep and wait for someone to notify it to wake up.\\n\\nUpvote and check out my other concurrency solutions.\\n```\\nimport java.util.concurrent.*;\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        run2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire(); \\n        printThird.run();\\n    }\\n}\\n```\\n\\n---\\n\\nSide note:\\n**ruzveld83** has pointed something out.\\n\"According to JMM there\\'s no guarantee that a thread will see values assigned during construction of an object in another thread. There is no guarantee that some thread can\\'t see version of Foo that is not fully constructed. It\\'s possible to see Foo.run2 or Foo.run3 as nulls. And thread-safety of Semaphore class does not make any difference. The final keyword should fix this. See https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.5\"\\n\\nI could argue that *maybe* Foo is being synchronized to allow for proper value visibility. But we can\\'t see the entire program so... \\xAF\\\\\\\\_(\\u30C4)_/\\xAF\\n\\n---\\n\\nHere\\'s another solution that requires 1 semaphore. It is 19ms. There is some \"waking and waiting\" due to the loops, so that causes some CPU waste. I should also note that we need **tryAcquire(number)** because it will try to get \"all or nothing.\" So if you **tryAcquire(3)**, it will try to \"get all 3 if all present and return true\" or \"grab nothing and return false.\" If you use **acquire(3)**, if there isn\\'t enough, it will grab 1 or 2 and then wait for the remainder. You may expect it to \"get 3 or wait for 3\" but it doesn\\'t do this and you may be in for a surprise.\\n```\\nclass Foo {\\n\\n    Semaphore semaphore1;\\n    public Foo() {\\n        semaphore1 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(1));\\n        \\n        printSecond.run();\\n        semaphore1.release(2);\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(2));\\n        \\n        printThird.run();\\n    }\\n}\\n```\\n---\\nFor new learners, you can also solve this using:\\n- **volatile** keyword.\\n- locks\\n- conditions (they are like sub-locks)\\n- atomic variables\\n- java\\'s concurrent data structures\\n\\nUse what works and is simple.",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        run2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire(); \\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n\\n    Semaphore semaphore1;\\n    public Foo() {\\n        semaphore1 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(1));\\n        \\n        printSecond.run();\\n        semaphore1.release(2);\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!semaphore1.tryAcquire(2));\\n        \\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343384,
                "title": "c-why-most-of-the-solutions-using-mutex-are-wrong-solution",
                "content": "I actually started learning about threads recently only and even my first attempt was to take 2 mutex and lock/unlock them in order desired by us. That solution is actually accepted in leetcode.\\n\\nHowever, while researching for difference between mutex and conditional_variable usage, i realised that the way mutex are being used here are totally wrong.\\n\\nSome points that must be taken note of are: \\n* **Mutex** are used for **mutual exclusion** i.e to safe gaurd the critical sections of a code.\\n* **Semaphone/condition_variable** are used for **thread synchronisation**(which is what we want to achieve here).\\n* **Mutex have ownership assigned with them**, that is to say, *the thread that locks a mutex must only unlock it.* Also, we must not unlock a mutex that has not been locked **(This is what most programs have got wrong)**.\\n* If the mutex is not used as said above, **the behavior is undefined**, which however in our case produces the required result.\\n\\nReferences:\\n1. [If the mutex is not currently locked by the calling thread, it causes undefined behavior.](http://www.cplusplus.com/reference/mutex/mutex/unlock/)\\n2. [The precondition for calling unlock is holding an ownership of the mutex, according to (std)30.4.1.2](https://stackoverflow.com/questions/43487357/how-stdmutex-got-unlocked-in-different-thread)\\n\\nI did read few more places the same thing, but i think these do put the point across :)\\n\\nNow my solution using a condition_variable:\\n\\n```\\nclass Foo {\\npublic:\\n    int count = 0;\\n    mutex mtx;\\n    condition_variable cv;\\n    Foo() {\\n        count = 1;\\n        //cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        unique_lock<mutex> lck(mtx);\\n\\t\\t// No point of this wait as on start count will be 1, we need to make the other threads wait.\\n        // while(count != 1){\\n        //     cv.wait(lck);\\n        // }\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n\\n        printFirst();\\n        count = 2;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 2){\\n            cv.wait(lck);\\n        }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count = 3;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 3){\\n            cv.wait(lck);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**Disclaimer**:  I am still learning :P. So, please do enlighten me if you think my understanding of this topic is wrong/misleading.\\nThanks for reading :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    int count = 0;\\n    mutex mtx;\\n    condition_variable cv;\\n    Foo() {\\n        count = 1;\\n        //cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        unique_lock<mutex> lck(mtx);\\n\\t\\t// No point of this wait as on start count will be 1, we need to make the other threads wait.\\n        // while(count != 1){\\n        //     cv.wait(lck);\\n        // }\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n\\n        printFirst();\\n        count = 2;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 2){\\n            cv.wait(lck);\\n        }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count = 3;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lck(mtx);\\n        while(count != 3){\\n            cv.wait(lck);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 893827,
                "title": "java-synchronized-lock-semaphore-condition-variable",
                "content": "Synchronized Method:\\n```\\nclass Foo {\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        oneDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while (!oneDone) {\\n            wait();\\n        }\\n        printSecond.run();\\n        twoDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while (!twoDone) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```\\n\\nSynchronized on Object:\\n```\\nclass Foo {\\n    private Object lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!oneDone) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!twoDone) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\\nSynchronized on Two Objects (not needed for this question, just put it here in case someone wants to use one object to protect one variable):\\n```\\nclass Foo {\\n    private Object lock1;\\n    private Object lock2;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock1 = new Object();\\n        lock2 = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock1) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock1.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock1) {\\n            synchronized (lock2) {\\n                while (!oneDone) {\\n                    lock1.wait();\\n                }\\n                printSecond.run();\\n                twoDone = true;\\n                lock2.notifyAll();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock2) {\\n            while (!twoDone) {\\n                lock2.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\\nSemaphore:\\n```\\nclass Foo {\\n    private Semaphore s2;\\n    private Semaphore s3;\\n    \\n    public Foo() {\\n        s2 = new Semaphore(0);\\n        s3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        printThird.run();\\n    }\\n}\\n```\\nCondition Variable:\\n```\\nclass Foo {\\n    private Lock lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    private Condition one;\\n    private Condition two;\\n    \\n    public Foo() {\\n        lock = new ReentrantLock();\\n        one = lock.newCondition();\\n        two = lock.newCondition();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            oneDone = true;\\n            one.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!oneDone) {\\n                one.await();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            two.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!twoDone) {\\n                two.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        oneDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while (!oneDone) {\\n            wait();\\n        }\\n        printSecond.run();\\n        twoDone = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while (!twoDone) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Object lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!oneDone) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (!twoDone) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Object lock1;\\n    private Object lock2;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    \\n    public Foo() {\\n        lock1 = new Object();\\n        lock2 = new Object();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock1) {\\n            printFirst.run();\\n            oneDone = true;\\n            lock1.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock1) {\\n            synchronized (lock2) {\\n                while (!oneDone) {\\n                    lock1.wait();\\n                }\\n                printSecond.run();\\n                twoDone = true;\\n                lock2.notifyAll();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock2) {\\n            while (!twoDone) {\\n                lock2.wait();\\n            }\\n            printThird.run();\\n        }\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Semaphore s2;\\n    private Semaphore s3;\\n    \\n    public Foo() {\\n        s2 = new Semaphore(0);\\n        s3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private Lock lock;\\n    private boolean oneDone;\\n    private boolean twoDone;\\n    private Condition one;\\n    private Condition two;\\n    \\n    public Foo() {\\n        lock = new ReentrantLock();\\n        one = lock.newCondition();\\n        two = lock.newCondition();\\n        oneDone = false;\\n        twoDone = false;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            oneDone = true;\\n            one.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!oneDone) {\\n                one.await();\\n            }\\n            printSecond.run();\\n            twoDone = true;\\n            two.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!twoDone) {\\n                two.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333513,
                "title": "c-using-std-promise",
                "content": "```C++\\nclass Foo {\\nprivate:\\n  std::promise<void> p1;\\n  std::promise<void> p2;\\n\\npublic:\\n  void first(function<void()> printFirst) {\\n    printFirst();\\n    p1.set_value();\\n  }\\n\\n  void second(function<void()> printSecond) {\\n    p1.get_future().wait();\\n    printSecond();\\n    p2.set_value();\\n  }\\n\\n  void third(function<void()> printThird) {\\n    p2.get_future().wait();\\n    printThird();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Foo {\\nprivate:\\n  std::promise<void> p1;\\n  std::promise<void> p2;\\n\\npublic:\\n  void first(function<void()> printFirst) {\\n    printFirst();\\n    p1.set_value();\\n  }\\n\\n  void second(function<void()> printSecond) {\\n    p1.get_future().wait();\\n    printSecond();\\n    p2.set_value();\\n  }\\n\\n  void third(function<void()> printThird) {\\n    p2.get_future().wait();\\n    printThird();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333562,
                "title": "python-3-semaphore",
                "content": "```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.two = Semaphore(0)\\n        self.three = Semaphore(0)\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.two.release()\\n\\n    def second(self, printSecond):\\n        with self.two:\\n            printSecond()\\n            self.three.release()\\n\\n    def third(self, printThird):\\n        with self.three:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Semaphore\\n\\nclass Foo:\\n    def __init__(self):\\n        self.two = Semaphore(0)\\n        self.three = Semaphore(0)\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.two.release()\\n\\n    def second(self, printSecond):\\n        with self.two:\\n            printSecond()\\n            self.three.release()\\n\\n    def third(self, printThird):\\n        with self.three:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394392,
                "title": "python-3-56ms-lock-vs-event",
                "content": "The fastest solution for the problem is to use Lock mechanism. See the following code with comments:\\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# create lock to control sequence between first and second functions\\n        self.lock1 = threading.Lock()\\n\\t\\tself.lock1.acquire()\\n\\t\\t\\n\\t\\t# create another lock to control sequence between second and third functions\\n        self.lock2 = threading.Lock()\\n        self.lock2.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t\\n\\t\\t# since second function is waiting for the lock1, let\\'s release it\\n        self.lock1.release()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for first funtion to finish\\n        self.lock1.acquire()\\n        \\n\\t\\tprintSecond()\\n\\t\\t\\n\\t\\t# let\\'s release lock2, so third function can run\\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for second funtion to finish\\n        self.lock2.acquire()\\n\\t\\t\\n        printThird()\\n```\\nNow, when I was solving the problem the result was showing only 76 ms, which is far from the fastest. If you encounter similar issue take into account that you are working with threading and the timing is very unpredictable when CPU decides to switch threads. This can cause different timing results.\\n\\nAs an alternative you can use other synchronization mechanisms, such as Semaphore or Event. If you peek into CPython code you will see both Event and Semaphore are using Lock inside. That means that technically Lock solution is the fastest.\\n\\nBut for the reference here is solution with Event synchronization. In my opinion it looks little better:\\n\\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1 = threading.Event()\\n        self.event2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# create lock to control sequence between first and second functions\\n        self.lock1 = threading.Lock()\\n\\t\\tself.lock1.acquire()\\n\\t\\t\\n\\t\\t# create another lock to control sequence between second and third functions\\n        self.lock2 = threading.Lock()\\n        self.lock2.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t\\n\\t\\t# since second function is waiting for the lock1, let\\'s release it\\n        self.lock1.release()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for first funtion to finish\\n        self.lock1.acquire()\\n        \\n\\t\\tprintSecond()\\n\\t\\t\\n\\t\\t# let\\'s release lock2, so third function can run\\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t# wait for second funtion to finish\\n        self.lock2.acquire()\\n\\t\\t\\n        printThird()\\n```\n```python3\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1 = threading.Event()\\n        self.event2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333446,
                "title": "java-solution-beats-100-in-both-time-and-space",
                "content": "```\\nclass Foo {\\n    \\n    private volatile boolean onePrinted;\\n    private volatile boolean twoPrinted;\\n\\n    public Foo() {\\n        onePrinted = false;\\n        twoPrinted = false;        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        onePrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(!onePrinted) {\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        twoPrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(!twoPrinted) {\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private volatile boolean onePrinted;\\n    private volatile boolean twoPrinted;\\n\\n    public Foo() {\\n        onePrinted = false;\\n        twoPrinted = false;        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        onePrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(!onePrinted) {\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        twoPrinted = true;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(!twoPrinted) {\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342306,
                "title": "java-simple-countdownlatch-solution",
                "content": "CountDownLatch seems a good fit for this, from java doc \" A synchronization aid that allows one or more threads to wait until, a set of operations being performed in other threads completes. \"\\n\\n```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    \\n    private final CountDownLatch l2;\\n    private final CountDownLatch l3;\\n    \\n    public Foo() {\\n        l2 = new CountDownLatch(1);\\n        l3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        l2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        l2.await();\\n        printSecond.run();\\n        l3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        l3.await();\\n        printThird.run();\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    \\n    private final CountDownLatch l2;\\n    private final CountDownLatch l3;\\n    \\n    public Foo() {\\n        l2 = new CountDownLatch(1);\\n        l3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        l2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        l2.await();\\n        printSecond.run();\\n        l3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        l3.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343487,
                "title": "python-simple-working-solution",
                "content": "```python\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        \\n        self.lock1.acquire()\\n        self.lock2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        \\n        self.lock1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lock1.acquire() # Wait unti first finishes\\n        \\n        printSecond()\\n        \\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lock2.acquire() # Wait unti second finishes\\n        \\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        \\n        self.lock1.acquire()\\n        self.lock2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        \\n        self.lock1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lock1.acquire() # Wait unti first finishes\\n        \\n        printSecond()\\n        \\n        self.lock2.release()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lock2.acquire() # Wait unti second finishes\\n        \\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332979,
                "title": "c-2-mutex",
                "content": "Idea is grab and release locks in order.\\n```\\nclass Foo {   \\n    mutex m1, m2;\\npublic:\\n    Foo() {\\n        m1.lock(), m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {   \\n    mutex m1, m2;\\npublic:\\n    Foo() {\\n        m1.lock(), m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856697,
                "title": "c-semaphore-based-solution",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly Semaphore first = new Semaphore(1, 1);\\n    private readonly Semaphore second = new Semaphore(0, 1);\\n    private readonly Semaphore third = new Semaphore(0, 1);\\n\\n    public void First(Action printFirst) {\\n        first.WaitOne();\\n        printFirst();\\n        second.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        second.WaitOne();\\n        printSecond();\\n        third.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        third.WaitOne();\\n        printThird();\\n        first.Release();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly Semaphore first = new Semaphore(1, 1);\\n    private readonly Semaphore second = new Semaphore(0, 1);\\n    private readonly Semaphore third = new Semaphore(0, 1);\\n\\n    public void First(Action printFirst) {\\n        first.WaitOne();\\n        printFirst();\\n        second.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        second.WaitOne();\\n        printSecond();\\n        third.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        third.WaitOne();\\n        printThird();\\n        first.Release();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333253,
                "title": "clean-and-easy-java-solution",
                "content": "```\\nimport java.util.concurrent.Semaphore;\\n\\nclass Foo {\\n\\n    final Semaphore hasFirstRun = new Semaphore(0);\\n    final Semaphore hasSecondRun = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        hasFirstRun.release(); // Allows second() to run, and wakes it if it\\'s sleeping.\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        /*\\n            hasFirstRun is initialized to 0. This means that if second() is executed\\n            before first(), it can\\'t get the lock and goes to sleep. In this case, it\\n            will be waked up by first().\\n            \\n            If second() is executed after first(), then it can acquire the semaphore immediately\\n            and execute its code.\\n        */\\n        hasFirstRun.acquire(); \\n        printSecond.run();\\n        hasSecondRun.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        hasSecondRun.acquire(); // same logic as second()\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.concurrent.Semaphore;\\n\\nclass Foo {\\n\\n    final Semaphore hasFirstRun = new Semaphore(0);\\n    final Semaphore hasSecondRun = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        hasFirstRun.release(); // Allows second() to run, and wakes it if it\\'s sleeping.\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        /*\\n            hasFirstRun is initialized to 0. This means that if second() is executed\\n            before first(), it can\\'t get the lock and goes to sleep. In this case, it\\n            will be waked up by first().\\n            \\n            If second() is executed after first(), then it can acquire the semaphore immediately\\n            and execute its code.\\n        */\\n        hasFirstRun.acquire(); \\n        printSecond.run();\\n        hasSecondRun.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        hasSecondRun.acquire(); // same logic as second()\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846704,
                "title": "easiest-solution-c-plus-plus-easy-to-understand-without-using-mutex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\n    promise<void> p1,p2;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        p1.get_future().wait();\\n        printSecond();\\n        p2.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        p2.get_future().wait();\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    promise<void> p1,p2;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        p1.get_future().wait();\\n        printSecond();\\n        p2.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        p2.get_future().wait();\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340233,
                "title": "java-two-methods-cas-ans-synchronized",
                "content": "**1. CAS**\\n```\\nimport java.util.concurrent.atomic.AtomicInteger;\\n\\nclass Foo {\\n\\n\\tAtomicInteger count = new AtomicInteger();\\n\\n\\tpublic Foo() {\\n\\t\\tcount.set(0);\\n\\t}\\n\\n\\tpublic void first(Runnable printFirst) throws InterruptedException {\\n\\n\\t\\twhile (!count.compareAndSet(0, 4)) {\\n\\t\\t\\t// printFirst.run() outputs \"first\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintFirst.run();\\n\\t\\tcount.set(1);\\n\\t}\\n\\n\\tpublic void second(Runnable printSecond) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(1, 4)) {\\n\\t\\t\\t// printSecond.run() outputs \"second\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintSecond.run();\\n\\t\\tcount.set(2);\\n\\n\\t}\\n\\n\\tpublic void third(Runnable printThird) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(2, 4)) {\\n\\t\\t\\t// printThird.run() outputs \"third\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintThird.run();\\n\\t\\tcount.set(3);\\n\\t}\\n}\\n```\\n\\n\\n**2. Synchronized**\\n```\\nimport java.util.concurrent.locks.*;\\n\\nclass Foo {\\n\\n    int count = 0;\\n    \\n    public Foo() {\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        \\n        printFirst.run();\\n        count++;\\n        this.notifyAll();\\n\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(count != 1){\\n           this.wait();\\n        }\\n        printSecond.run();\\n        count++;\\n        this.notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n\\n        while(count != 2){\\n          this.wait();\\n        }\\n        printThird.run();\\n        count++;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.atomic.AtomicInteger;\\n\\nclass Foo {\\n\\n\\tAtomicInteger count = new AtomicInteger();\\n\\n\\tpublic Foo() {\\n\\t\\tcount.set(0);\\n\\t}\\n\\n\\tpublic void first(Runnable printFirst) throws InterruptedException {\\n\\n\\t\\twhile (!count.compareAndSet(0, 4)) {\\n\\t\\t\\t// printFirst.run() outputs \"first\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintFirst.run();\\n\\t\\tcount.set(1);\\n\\t}\\n\\n\\tpublic void second(Runnable printSecond) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(1, 4)) {\\n\\t\\t\\t// printSecond.run() outputs \"second\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintSecond.run();\\n\\t\\tcount.set(2);\\n\\n\\t}\\n\\n\\tpublic void third(Runnable printThird) throws InterruptedException {\\n\\t\\twhile (!count.compareAndSet(2, 4)) {\\n\\t\\t\\t// printThird.run() outputs \"third\". Do not change or remove this line.\\n\\t\\t}\\n\\t\\tprintThird.run();\\n\\t\\tcount.set(3);\\n\\t}\\n}\\n```\n```\\nimport java.util.concurrent.locks.*;\\n\\nclass Foo {\\n\\n    int count = 0;\\n    \\n    public Foo() {\\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        \\n        \\n        printFirst.run();\\n        count++;\\n        this.notifyAll();\\n\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(count != 1){\\n           this.wait();\\n        }\\n        printSecond.run();\\n        count++;\\n        this.notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n\\n        while(count != 2){\\n          this.wait();\\n        }\\n        printThird.run();\\n        count++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1786578,
                "title": "c-minimal-code",
                "content": "```\\ntypedef struct {\\n    // User defined data is declared here.\\n    // using \\'volatile\\' to prevent compiler from playing god and optimize out this critical variable\\n    // this is mutex variable, duh \\n    volatile int turn;\\n} Foo;\\n\\nvoid wait(Foo* obj, int my_turn) {\\n    // blocking this thread till my turn\\n    while(obj->turn != my_turn) pthread_yield(NULL); // Nope Gotta wait \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n    \\n    // Aha!! free at last guess I will return now\\n}\\n\\nvoid signal(Foo* obj) {\\n    ++obj->turn; // pass it to next in line (psst: for the future generations)\\n}\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    obj->turn = 1; // first will be executed first, lol \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid second(Foo* obj) {\\n    wait(obj, 2); // Ok I will wait till my (2) turn (\\u2565\\uFE4F\\u2565)\\n    printSecond();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid third(Foo* obj) {\\n    wait(obj, 3); // Ok I will wait till my (3) turn (\\u2565\\uFE4F\\u2565)\\n    printThird(); \\n    // Oh! no one else left to signal, I guess this ends with me now, *sigh* \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // I am a resposible citizen I clean up after me \\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    // User defined data is declared here.\\n    // using \\'volatile\\' to prevent compiler from playing god and optimize out this critical variable\\n    // this is mutex variable, duh \\n    volatile int turn;\\n} Foo;\\n\\nvoid wait(Foo* obj, int my_turn) {\\n    // blocking this thread till my turn\\n    while(obj->turn != my_turn) pthread_yield(NULL); // Nope Gotta wait \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n    \\n    // Aha!! free at last guess I will return now\\n}\\n\\nvoid signal(Foo* obj) {\\n    ++obj->turn; // pass it to next in line (psst: for the future generations)\\n}\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    obj->turn = 1; // first will be executed first, lol \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid second(Foo* obj) {\\n    wait(obj, 2); // Ok I will wait till my (2) turn (\\u2565\\uFE4F\\u2565)\\n    printSecond();\\n    signal(obj); // I am done please pass ownership of mutex to next in line ( \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0) \\n}\\n\\nvoid third(Foo* obj) {\\n    wait(obj, 3); // Ok I will wait till my (3) turn (\\u2565\\uFE4F\\u2565)\\n    printThird(); \\n    // Oh! no one else left to signal, I guess this ends with me now, *sigh* \\uFF08\\u25DE\\u2038\\u25DF\\uFF09\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // I am a resposible citizen I clean up after me \\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1028030,
                "title": "4-python-solutions",
                "content": "**Solution 1:**\\n```\\nfrom threading import Event\\nclass Foo:\\ndef __init__(self):\\n\\tself.done = (Event(),Event())\\n\\ndef first(self, printFirst):\\n\\tprintFirst()\\n\\tself.done[0].set()\\n\\ndef second(self, printSecond):\\n\\tself.done[0].wait()\\n\\tprintSecond()\\n\\tself.done[1].set()\\n\\ndef third(self, printThird):\\n\\tself.done[1].wait()\\n\\tprintThird()\\n```\\n\\n**Solution 2:**\\n```\\nfrom threading import Barrier\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n     def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n     def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n     def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n```\\n\\n**Solution 3:**\\n```\\nfrom threading import Lock\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n     def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n     def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\\n\\n**Solution 4:**\\n```\\nfrom threading import Semaphore\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Event\\nclass Foo:\\ndef __init__(self):\\n\\tself.done = (Event(),Event())\\n\\ndef first(self, printFirst):\\n\\tprintFirst()\\n\\tself.done[0].set()\\n\\ndef second(self, printSecond):\\n\\tself.done[0].wait()\\n\\tprintSecond()\\n\\tself.done[1].set()\\n\\ndef third(self, printThird):\\n\\tself.done[1].wait()\\n\\tprintThird()\\n```\n```\\nfrom threading import Barrier\\nclass Foo:\\n    def __init__(self):\\n        self.first_barrier = Barrier(2)\\n        self.second_barrier = Barrier(2)\\n     def first(self, printFirst):\\n        printFirst()\\n        self.first_barrier.wait()\\n     def second(self, printSecond):\\n        self.first_barrier.wait()\\n        printSecond()\\n        self.second_barrier.wait()\\n     def third(self, printThird):\\n        self.second_barrier.wait()\\n        printThird()\\n```\n```\\nfrom threading import Lock\\nclass Foo:\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n     def first(self, printFirst):\\n        printFirst()\\n        self.locks[0].release()\\n     def second(self, printSecond):\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n    def third(self, printThird):\\n        with self.locks[1]:\\n            printThird()\\n```\n```\\nfrom threading import Semaphore\\nclass Foo:\\n    def __init__(self):\\n        self.gates = (Semaphore(0),Semaphore(0))\\n    def first(self, printFirst):\\n        printFirst()\\n        self.gates[0].release()\\n    def second(self, printSecond):\\n        with self.gates[0]:\\n            printSecond()\\n            self.gates[1].release()\\n    def third(self, printThird):\\n        with self.gates[1]:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926614,
                "title": "python3-solution-using-5-primitives-lock-semaphore-condition-event-barrier",
                "content": "# Approach \\\\#1. Lock\\n- `RLock` is not suitable in this case. \\n\\n<iframe src=\"https://leetcode.com/playground/mgRcT2DB/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#2. Semaphore\\n- `Semaphore(1)` is equivalent to `Lock()`\\n<iframe src=\"https://leetcode.com/playground/c4bkiTBr/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#3. Condition\\n<iframe src=\"https://leetcode.com/playground/Z2up2An3/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>\\n\\n# Approach \\\\#4. Event \\n<iframe src=\"https://leetcode.com/playground/hTnE2h6z/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#5. Barrier\\n<iframe src=\"https://leetcode.com/playground/RxQpksKT/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n",
                "solutionTags": [
                    "Python3",
                    "Concurrency"
                ],
                "code": "# Approach \\\\#1. Lock\\n- `RLock` is not suitable in this case. \\n\\n<iframe src=\"https://leetcode.com/playground/mgRcT2DB/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#2. Semaphore\\n- `Semaphore(1)` is equivalent to `Lock()`\\n<iframe src=\"https://leetcode.com/playground/c4bkiTBr/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#3. Condition\\n<iframe src=\"https://leetcode.com/playground/Z2up2An3/shared\" frameBorder=\"0\" width=\"600\" height=\"500\"></iframe>\\n\\n# Approach \\\\#4. Event \\n<iframe src=\"https://leetcode.com/playground/hTnE2h6z/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n\\n# Approach \\\\#5. Barrier\\n<iframe src=\"https://leetcode.com/playground/RxQpksKT/shared\" frameBorder=\"0\" width=\"600\" height=\"400\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 339055,
                "title": "c-three-versions-condition-variables-semaphores-simple-bools-fastest-124ms",
                "content": "Version 1: One mutex lock + two condition variables\\n* 124 ms\\n* faster than 89.41%\\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_cond_t cv1 = PTHREAD_COND_INITIALIZER;\\n    pthread_cond_t cv2 = PTHREAD_COND_INITIALIZER;\\n\\t\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        pthread_mutex_lock(&m);\\n        firstRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) { \\n            pthread_cond_wait(&cv1, &m);\\n        }\\n\\t\\t\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        secondRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) {\\n             pthread_cond_wait(&cv1, &m);\\n        }\\n        while (!secondRan) {\\n             pthread_cond_wait(&cv2, &m);\\n        }\\n\\t\\t\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        pthread_mutex_unlock(&m);\\n    }\\n};\\n```\\n\\nVersion 2: Two semaphores\\n* 132 ms\\n* Faster than 82.37%\\n```\\n#include <semaphore.h>\\n\\nclass Foo {\\npublic:\\n    sem_t s1;\\n    sem_t s2;\\n    Foo() {\\n        sem_init(&s1, 0, 0);\\n        sem_init(&s2, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&s1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&s1);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&s2);\\n        \\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&s2);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\nVersion 3: Simple bools\\n* 1400 ms\\n* Faster than 8.13%\\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        firstRan = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!firstRan) { }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondRan = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (!(firstRan && secondRan))  { }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\nLet me know if anyone finds better ways to do what I did!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_cond_t cv1 = PTHREAD_COND_INITIALIZER;\\n    pthread_cond_t cv2 = PTHREAD_COND_INITIALIZER;\\n\\t\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        pthread_mutex_lock(&m);\\n        firstRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) { \\n            pthread_cond_wait(&cv1, &m);\\n        }\\n\\t\\t\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        secondRan = true;\\n        pthread_mutex_unlock(&m);\\n        pthread_cond_broadcast(&cv2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        pthread_mutex_lock(&m);\\n\\t\\t\\n        while (!firstRan) {\\n             pthread_cond_wait(&cv1, &m);\\n        }\\n        while (!secondRan) {\\n             pthread_cond_wait(&cv2, &m);\\n        }\\n\\t\\t\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        pthread_mutex_unlock(&m);\\n    }\\n};\\n```\n```\\n#include <semaphore.h>\\n\\nclass Foo {\\npublic:\\n    sem_t s1;\\n    sem_t s2;\\n    Foo() {\\n        sem_init(&s1, 0, 0);\\n        sem_init(&s2, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&s1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&s1);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&s2);\\n        \\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&s2);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\npublic:\\n    bool firstRan = false;\\n    bool secondRan = false;\\n    Foo() { }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        firstRan = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!firstRan) { }\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondRan = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (!(firstRan && secondRan))  { }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 620623,
                "title": "c-using-autoreset",
                "content": "```csharp\\nusing System.Threading;    \\n\\npublic class Foo \\n{\\n    private EventWaitHandle waitFirst;\\n    private EventWaitHandle waitSecond;\\n\\n    public Foo() \\n    {\\n        waitFirst = new AutoResetEvent(initialState: false);\\n        waitSecond = new AutoResetEvent(initialState: false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {   \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        waitFirst.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        waitFirst.WaitOne();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        waitSecond.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        waitSecond.WaitOne();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\nusing System.Threading;    \\n\\npublic class Foo \\n{\\n    private EventWaitHandle waitFirst;\\n    private EventWaitHandle waitSecond;\\n\\n    public Foo() \\n    {\\n        waitFirst = new AutoResetEvent(initialState: false);\\n        waitSecond = new AutoResetEvent(initialState: false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {   \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        waitFirst.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        waitFirst.WaitOne();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        waitSecond.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        waitSecond.WaitOne();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062271,
                "title": "3-c-solutions-promises-condition-variables-atomic-bools",
                "content": "If you liked it please upvote!\\n\\n**C++ promise/future:**\\n1 of the 2 fastest (second one is the condition_variable)\\n```\\nclass Foo {\\nprivate:\\n    std::promise<void> prom_first;\\n    std::promise<void> prom_second;\\n    std::future<void> fut_first;\\n    std::future<void> fut_second;\\npublic:\\n    Foo() {\\n        fut_first = prom_first.get_future();\\n        fut_second = prom_second.get_future();\\n    }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        prom_first.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        fut_first.wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        prom_second.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        fut_second.wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**C++ condition variable**\\n1 of the 2 fastest (second one is the promises/futures)\\n```\\nclass Foo {\\nprivate:\\n    std::mutex mutex1, mutex2, mutex3;\\n    std::condition_variable cv2, cv3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        {\\n            std::lock_guard lock(mutex1);\\n            second_unlocked = true;\\n        }\\n        cv2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock lock(mutex2);\\n        cv2.wait(lock, [this] { return second_unlocked; });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n        lock.unlock();\\n        cv3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock lock(mutex3);\\n        cv3.wait(lock, [this] { return third_unlocked; });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n**C++ atomic bools**\\nSimplest but obviously the slowest solution\\n```\\nclass Foo {\\nprivate:\\n    std::atomic<bool> second_unlocked = false, third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        second_unlocked = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!second_unlocked)\\n            ;\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        while(!third_unlocked)\\n            ;\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\nprivate:\\n    std::promise<void> prom_first;\\n    std::promise<void> prom_second;\\n    std::future<void> fut_first;\\n    std::future<void> fut_second;\\npublic:\\n    Foo() {\\n        fut_first = prom_first.get_future();\\n        fut_second = prom_second.get_future();\\n    }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        prom_first.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        fut_first.wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        prom_second.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        fut_second.wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\nprivate:\\n    std::mutex mutex1, mutex2, mutex3;\\n    std::condition_variable cv2, cv3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        {\\n            std::lock_guard lock(mutex1);\\n            second_unlocked = true;\\n        }\\n        cv2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock lock(mutex2);\\n        cv2.wait(lock, [this] { return second_unlocked; });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n        lock.unlock();\\n        cv3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock lock(mutex3);\\n        cv3.wait(lock, [this] { return third_unlocked; });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\nprivate:\\n    std::atomic<bool> second_unlocked = false, third_unlocked = false;\\npublic:\\n    Foo() { }\\n    \\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        second_unlocked = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!second_unlocked)\\n            ;\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        third_unlocked = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        while(!third_unlocked)\\n            ;\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425597,
                "title": "c-the-most-correct-solution",
                "content": "``` csharp\\nusing System.Threading.Tasks;\\n\\npublic class Foo\\n{\\n    private TaskCompletionSource<bool> semaphore1 = new TaskCompletionSource<bool>();\\n    private TaskCompletionSource<bool> semaphore2 = new TaskCompletionSource<bool>();\\n\\n    public Foo()\\n    {\\n\\n    }\\n\\n    public void First(Action printFirst)\\n    {\\n        printFirst();\\n        semaphore1.SetResult(true);\\n    }\\n\\n    public void Second(Action printSecond)\\n    {\\n        semaphore1.Task.Wait();\\n        printSecond();\\n        semaphore2.SetResult(true);\\n    }\\n\\n    public void Third(Action printThird)\\n    {\\n        semaphore2.Task.Wait();\\n        printThird();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "``` csharp\\nusing System.Threading.Tasks;\\n\\npublic class Foo\\n{\\n    private TaskCompletionSource<bool> semaphore1 = new TaskCompletionSource<bool>();\\n    private TaskCompletionSource<bool> semaphore2 = new TaskCompletionSource<bool>();\\n\\n    public Foo()\\n    {\\n\\n    }\\n\\n    public void First(Action printFirst)\\n    {\\n        printFirst();\\n        semaphore1.SetResult(true);\\n    }\\n\\n    public void Second(Action printSecond)\\n    {\\n        semaphore1.Task.Wait();\\n        printSecond();\\n        semaphore2.SetResult(true);\\n    }\\n\\n    public void Third(Action printThird)\\n    {\\n        semaphore2.Task.Wait();\\n        printThird();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878544,
                "title": "python-simple-and-elegant-event-based",
                "content": "**Solution**:\\n```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1, self.event2 = Event(), Event()\\n\\n    def first(self, f):\\n        f()\\n        self.event1.set()\\n\\n    def second(self, f):\\n        self.event1.wait()\\n        f()\\n        self.event2.set()\\n\\n    def third(self, f):\\n        self.event2.wait()\\n        f()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom threading import Event\\n\\nclass Foo:\\n    def __init__(self):\\n        self.event1, self.event2 = Event(), Event()\\n\\n    def first(self, f):\\n        f()\\n        self.event1.set()\\n\\n    def second(self, f):\\n        self.event1.wait()\\n        f()\\n        self.event2.set()\\n\\n    def third(self, f):\\n        self.event2.wait()\\n        f()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212596,
                "title": "java-with-two-semaphores",
                "content": "```\\nclass Foo {\\n\\n    private Semaphore second;\\n    private Semaphore third;\\n\\n    public Foo() {\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private Semaphore second;\\n    private Semaphore third;\\n\\n    public Foo() {\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760743,
                "title": "java-4-different-solutions-w-explanation",
                "content": "## 0. Analysis\\nHere we have 3 threads and all we want to achieve is to make sure the 3 threads run in a specific order. To achieve this, we need coordination among the threads, which means accessing and managing some common objects/resources. I think the most important point to achieve is about **visibility**: the other threads should be able to know the state change of some commonly accessed objects/values used for the coordination.\\n\\nTo achieve this, we can either use some ready-to-use utility classes in `java.util.concurrent` package, or managing the visibility and status with some Java language features. \\n\\nBelow are a few possible solutions:\\n\\n## 1.  The volatile keyword\\nIn summary, the Java `volatile` keyword **guarantees visibility of changes** to variables across threads (from [this article](http://tutorials.jenkov.com/java-concurrency/volatile.html)), and that\\'s literally all we need here so that when` first()` and `second()` increment the `flag` value, the next methods (in other threads) are able to capture the updated value so that the execution condition can be met (i.e., the `while` loop will exit).\\n\\nSo we have the solution like below:\\n```\\nclass Foo {\\n    private static volatile int flag;\\n    \\n    public Foo() {\\n        flag = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag++; // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag != 2){} // wait until the flag turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag++; // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag != 3){} // wait until the flag turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 2. AtomicInteger\\nThe `AtomicXXX` classes are located in `java.util.concurrent` package. The main feature for those classes is that they ensure ***atomic actions*** on the instances, which in simple terms means that only a single thread will be able to access the object at a time, and the updated value will be visible to other threads. It\\'s achieved using CAS (compare and swap) strategy.\\n\\nSo the solution is like below:\\n```\\nclass Foo {\\n    private static AtomicInteger flag;\\n    \\n    public Foo() {\\n        flag = new AtomicInteger(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag.incrementAndGet(); // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag.get() != 2){} // wait until the flag value turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag.incrementAndGet();  // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag.get() != 3){} // wait until the flag value turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 3. Semaphore\\nA `Semaphore` manages a set of  virtual  permits; the  initial number of permits  is passed to the Semaphore constructor. Activities can `acquire` permits (as long as some remain) and `release` permits when they are done with them. If no permit is available, acquire blocks until one is (or until interrupted or the operation times out). The `release` method returns a permit to the semaphore. (from the book [Java Concurrency in Practice](https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601))\\n\\nSo we use 2 Semaphore objects, one to control when the` second()` method can proceed, the other to control when the `third()` method can proceed. Solution is like below:\\n\\n```\\nclass Foo {\\n    private static Semaphore sem2;\\n    private static Semaphore sem3;\\n    \\n    public Foo() {\\n        sem2 = new Semaphore(0);\\n        sem3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        sem2.release(); // release a sem2 permit so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        sem2.acquire();  // will block until any Semaphore permit is available\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        sem3.release(); // release a sem3 permit so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       sem3.acquire(); // will block until any Semaphore permit is available\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\n## 4. CountDownLatch\\n`CountDownLatch` is another type of synchronizer. It can delay the progress of threads until it reaches its terminal state, i.e., when it counts down to 0. \\n\\nMuch like solution 3 with `Semaphore`, we use 2 `CountDownLatch` instances. One to control when the` second()` method can proceed, the other to control when the `third()` method can proceed. Solution is like below:\\n\\n```\\nclass Foo {\\n    private static CountDownLatch latch2;\\n    private static CountDownLatch latch3;\\n    \\n    public Foo() {\\n        latch2 = new CountDownLatch(1);\\n        latch3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown(); // count down latch2 to 0 so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await(); // wait until latch2 counts down to 0\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown(); // count down latche to 0 so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       latch3.await(); // wait until latch3 counts down to 0\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\\n\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private static volatile int flag;\\n    \\n    public Foo() {\\n        flag = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag++; // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag != 2){} // wait until the flag turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag++; // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag != 3){} // wait until the flag turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static AtomicInteger flag;\\n    \\n    public Foo() {\\n        flag = new AtomicInteger(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        flag.incrementAndGet(); // flag that it\\'s ready for second() to run\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(flag.get() != 2){} // wait until the flag value turns 2\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        flag.incrementAndGet();  // flag that it\\'s ready for third() to run\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(flag.get() != 3){} // wait until the flag value turns 3\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static Semaphore sem2;\\n    private static Semaphore sem3;\\n    \\n    public Foo() {\\n        sem2 = new Semaphore(0);\\n        sem3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        sem2.release(); // release a sem2 permit so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        sem2.acquire();  // will block until any Semaphore permit is available\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        sem3.release(); // release a sem3 permit so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       sem3.acquire(); // will block until any Semaphore permit is available\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```\n```\\nclass Foo {\\n    private static CountDownLatch latch2;\\n    private static CountDownLatch latch3;\\n    \\n    public Foo() {\\n        latch2 = new CountDownLatch(1);\\n        latch3 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown(); // count down latch2 to 0 so that second() can proceed\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await(); // wait until latch2 counts down to 0\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown(); // count down latche to 0 so that third() can proceed\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n       latch3.await(); // wait until latch3 counts down to 0\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520552,
                "title": "c-future-promise",
                "content": "Using C++ 11 feature and locking the object automatically with future-promise idiom. \\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n    std::promise<void> one, two;\\n    \\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        one.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        one.get_future().get();\\n        printSecond();\\n        two.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        two.get_future().get();\\n        printThird();\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n    std::promise<void> one, two;\\n    \\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        one.set_value();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        one.get_future().get();\\n        printSecond();\\n        two.set_value();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        two.get_future().get();\\n        printThird();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 430388,
                "title": "c-condition-variable-96-also-explaining-how-condition-variable-works",
                "content": "How `condition_variable` works:\\n1. First, you need to acquire a `mutex` using `unique_lock`. We need a unique_lock because before putting the thread to sleep, condition_variable will need to release the mutex and unique_lock provides that flexibility.\\n2. Next, you call the `wait` function of condition_variable with the above lock and optionally a `predicate`. It causes the current thread to block (sleep). The thread is unblocked when `notify_all` or `notify_one` is executed on some other thread. \\n4. It might also be unblocked *spuriously* that\\'s where the predicate comes handy. So, whenever there are spurious wake-ups, condition_variable will acquire the mutex and check the predicate. **If** the predicate returns true, thread will proceed further and mutex will stay acquired, **otherwise** it will release the mutex and sleep again.\\n5. When the thread has completed its work, it\\'s *generally* a better idea to release the lock before notifying other threads, if need be.\\n\\n```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst) {\\n        // first doesn\\'t have to wait for anyone and it doesn\\'t acquire any lock either\\n        printFirst();  \\n        // firstPrinted is atomic because second might be trying to read while this thread is modifying it.\\n        firstPrinted = true;\\n        // notify waiting threads\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // acquire lock, C++17 way\\n        unique_lock guard(m);\\n        // condition to wait for is => first should have printed.\\n        cv.wait(guard, [this] { return this->firstPrinted == true; });\\n        // now print\\n        printSecond();\\n        // secondPrinted need not be atomic, because its access is already protected by mutex in both second and third. \\n        secondPrinted = true;\\n        // release mutex before notifying\\n        guard.unlock();\\n        // notify\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // acquire lock\\n        unique_lock guard(m);\\n        // condition to wait for is => second should have printed. \\n        cv.wait(guard, [this] { return secondPrinted == true; });\\n        // now print\\n        printThird();\\n    }\\n    \\nprivate:\\n    condition_variable cv;\\n    mutex m;\\n    atomic_bool firstPrinted = false;\\n    bool secondPrinted = false;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst) {\\n        // first doesn\\'t have to wait for anyone and it doesn\\'t acquire any lock either\\n        printFirst();  \\n        // firstPrinted is atomic because second might be trying to read while this thread is modifying it.\\n        firstPrinted = true;\\n        // notify waiting threads\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // acquire lock, C++17 way\\n        unique_lock guard(m);\\n        // condition to wait for is => first should have printed.\\n        cv.wait(guard, [this] { return this->firstPrinted == true; });\\n        // now print\\n        printSecond();\\n        // secondPrinted need not be atomic, because its access is already protected by mutex in both second and third. \\n        secondPrinted = true;\\n        // release mutex before notifying\\n        guard.unlock();\\n        // notify\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // acquire lock\\n        unique_lock guard(m);\\n        // condition to wait for is => second should have printed. \\n        cv.wait(guard, [this] { return secondPrinted == true; });\\n        // now print\\n        printThird();\\n    }\\n    \\nprivate:\\n    condition_variable cv;\\n    mutex m;\\n    atomic_bool firstPrinted = false;\\n    bool secondPrinted = false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333018,
                "title": "naive-solution-without-using-built-in-libraries",
                "content": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.called = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        while self.called != 0:\\n            continue\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.called = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.called != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.called = 2\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.called != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```\\n\\nNot sure if it meets the goal of this problem, but it passed..",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.called = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        while self.called != 0:\\n            continue\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.called = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.called != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.called = 2\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.called != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961766,
                "title": "java-94-runtime-efficiency-using-synchronized-wait-and-notify-explained",
                "content": "Although I consider myself proficient in Java, this was a great refresher on synchronized, wait, and notify.  I did some research.  Based on Sonar, any wait() call should check a condition in a while loop, so I have two booleans to indicate if the first and second have been printed.  I declared two objects, firstObject and secondObject to use for synchronization.  Method first synchronizes on firstObject and can then run printFirst(), and does a notify on firstObject to signal completion of the first method.  Method second is synchronized on firstObject, has a while loop on !first, and waits for the notify on firstObject.  When the while loop is exited, it synchronizes on secondObject, prints second, sets second to true, and does a notify on secondObject to signal completion of the second method.  Method third does the same things, synchronizing on secondObject, looping while !second, and waits for the notify on secondObject.  When the loop is exited, printThird can be run. \\n\\nIf you like this post, please upvote!\\n```\\nclass Foo {\\n\\n    public Foo() {\\n        first = false;\\n        second = false;\\n    }\\n\\n    Object firstObject = new Object();\\n    Object secondObject = new Object();\\n    \\n    boolean first = false;\\n    boolean second = false;\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(firstObject) {\\n\\t\\t    // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            first = true;\\n            firstObject.notify();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(firstObject) {\\n            while (!first) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    firstObject.wait();\\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n            synchronized(secondObject) {\\n                // printSecond.run() outputs \"second\". Do not change or remove this line.\\n                printSecond.run();\\n                second = true;\\n                secondObject.notify();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(secondObject) {\\n            while (!second) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    secondObject.wait();  \\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line\\n        printThird.run();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "Although I consider myself proficient in Java, this was a great refresher on synchronized, wait, and notify.  I did some research.  Based on Sonar, any wait() call should check a condition in a while loop, so I have two booleans to indicate if the first and second have been printed.  I declared two objects, firstObject and secondObject to use for synchronization.  Method first synchronizes on firstObject and can then run printFirst(), and does a notify on firstObject to signal completion of the first method.  Method second is synchronized on firstObject, has a while loop on !first, and waits for the notify on firstObject.  When the while loop is exited, it synchronizes on secondObject, prints second, sets second to true, and does a notify on secondObject to signal completion of the second method.  Method third does the same things, synchronizing on secondObject, looping while !second, and waits for the notify on secondObject.  When the loop is exited, printThird can be run. \\n\\nIf you like this post, please upvote!\\n```\\nclass Foo {\\n\\n    public Foo() {\\n        first = false;\\n        second = false;\\n    }\\n\\n    Object firstObject = new Object();\\n    Object secondObject = new Object();\\n    \\n    boolean first = false;\\n    boolean second = false;\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(firstObject) {\\n\\t\\t    // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            first = true;\\n            firstObject.notify();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(firstObject) {\\n            while (!first) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    firstObject.wait();\\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n            synchronized(secondObject) {\\n                // printSecond.run() outputs \"second\". Do not change or remove this line.\\n                printSecond.run();\\n                second = true;\\n                secondObject.notify();\\n            }\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(secondObject) {\\n            while (!second) {\\n                try {\\n                    // Calling wait() will block this thread until another thread calls notify() on the object.\\n                    secondObject.wait();  \\n                } catch (InterruptedException e) {\\n                    // Happens if someone interrupts your thread.\\n                }\\n            }\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line\\n        printThird.run();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 762759,
                "title": "boring-c-mutex-solution",
                "content": "```\\nclass Foo {\\n    mutex m1;\\n    mutex m2;\\npublic:\\n    Foo() {\\n        m1.lock();\\n        m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    mutex m1;\\n    mutex m2;\\npublic:\\n    Foo() {\\n        m1.lock();\\n        m2.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        m1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        m1.lock();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        m1.unlock();\\n        m2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        m2.lock();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        m2.unlock();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 516472,
                "title": "semaphore",
                "content": "```\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        run2.release();\\n\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    Semaphore run2, run3;\\n\\n    public Foo() {\\n        run2 = new Semaphore(0);\\n        run3 = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        run2.release();\\n\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        run2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        run3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        run3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440979,
                "title": "python3-solution-via-threading-event-36-ms-13-mb",
                "content": "```\\nfrom threading import Event\\n\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# Initialize events for threads\\n        self.event1 = Event()\\n        self.event2 = Event()\\n        \\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t# set flag\\n        self.event1.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event1.wait()\\n        printSecond()\\n\\t\\t# set flag\\n        self.event2.set()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event2.wait()\\n        printThird()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom threading import Event\\n\\n\\nclass Foo:\\n    def __init__(self):\\n\\t\\t# Initialize events for threads\\n        self.event1 = Event()\\n        self.event2 = Event()\\n        \\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n\\t\\t# set flag\\n        self.event1.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event1.wait()\\n        printSecond()\\n\\t\\t# set flag\\n        self.event2.set()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        # wait for flag\\n\\t\\tself.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428095,
                "title": "c-autoresetevent-beats-100",
                "content": "```\\n    public class Foo\\n    {\\n        private static AutoResetEvent event_1 = new AutoResetEvent(false);\\n        private static AutoResetEvent event_2 = new AutoResetEvent(false);\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            event_1.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            event_1.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            event_2.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            event_2.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Foo\\n    {\\n        private static AutoResetEvent event_1 = new AutoResetEvent(false);\\n        private static AutoResetEvent event_2 = new AutoResetEvent(false);\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            event_1.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            event_1.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            event_2.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            event_2.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347706,
                "title": "c-2-solutions-with-or-without-thread",
                "content": "#1 with thead\\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) System.Threading.Thread.Sleep(1);\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) System.Threading.Thread.Sleep(1);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```\\n\\n#2 without thread\\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) continue;\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) continue;\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) System.Threading.Thread.Sleep(1);\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) System.Threading.Thread.Sleep(1);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```\n```\\npublic class Foo {\\n\\n    int count;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void First(Action printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        count++;\\n    }\\n\\n    public void Second(Action printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        while(count < 1) continue;\\n        printSecond();\\n        count++;\\n    }\\n\\n    public void Third(Action printThird) {\\n        while(count < 2) continue;\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693063,
                "title": "easy-java-solution",
                "content": "```\\nclass Foo {\\n\\n        private final CountDownLatch firstLatch;\\n        private final CountDownLatch secondLatch;\\n\\n        public Foo() {\\n            firstLatch = new CountDownLatch(1);\\n            secondLatch = new CountDownLatch(1);\\n        }\\n\\n        public void first(Runnable printFirst) throws InterruptedException {\\n            printFirst.run();\\n            firstLatch.countDown();\\n        }\\n\\n        public void second(Runnable printSecond) throws InterruptedException {\\n            firstLatch.await();\\n            printSecond.run();\\n            secondLatch.countDown();\\n        }\\n\\n        public void third(Runnable printThird) throws InterruptedException {\\n            secondLatch.await();\\n            printThird.run();\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n        private final CountDownLatch firstLatch;\\n        private final CountDownLatch secondLatch;\\n\\n        public Foo() {\\n            firstLatch = new CountDownLatch(1);\\n            secondLatch = new CountDownLatch(1);\\n        }\\n\\n        public void first(Runnable printFirst) throws InterruptedException {\\n            printFirst.run();\\n            firstLatch.countDown();\\n        }\\n\\n        public void second(Runnable printSecond) throws InterruptedException {\\n            firstLatch.await();\\n            printSecond.run();\\n            secondLatch.countDown();\\n        }\\n\\n        public void third(Runnable printThird) throws InterruptedException {\\n            secondLatch.await();\\n            printThird.run();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825386,
                "title": "c-shortest-code-using-promise-class",
                "content": "```\\nclass Foo {\\n    \\nprivate:    \\n    promise<void> p1, p2;    \\n    \\npublic:\\n    Foo() {}\\n    void first(function<void()> printFirst)         {\\n        printFirst()                                ;\\n        p1.set_value()                              ;\\n                                                    }\\n    void second(function<void()> printSecond)       {\\n        p1.get_future().wait()                      ;\\n        printSecond()                               ;\\n        p2.set_value()                              ;}\\n\\n    void third(function<void()> printThird)         {\\n        p2.get_future().wait()                      ;\\n        printThird()                                ;}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    \\nprivate:    \\n    promise<void> p1, p2;    \\n    \\npublic:\\n    Foo() {}\\n    void first(function<void()> printFirst)         {\\n        printFirst()                                ;\\n        p1.set_value()                              ;\\n                                                    }\\n    void second(function<void()> printSecond)       {\\n        p1.get_future().wait()                      ;\\n        printSecond()                               ;\\n        p2.set_value()                              ;}\\n\\n    void third(function<void()> printThird)         {\\n        p2.get_future().wait()                      ;\\n        printThird()                                ;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140864,
                "title": "simple-python-solution",
                "content": "```\\nclass Foo(object):\\n    def __init__(self):\\n        self.x = 0\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.x += 1\\n\\n    def second(self, printSecond):\\n        while self.x < 1:\\n            pass\\n        printSecond()\\n        self.x += 1\\n            \\n    def third(self, printThird):\\n        while self.x < 2:\\n            pass\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo(object):\\n    def __init__(self):\\n        self.x = 0\\n        \\n    def first(self, printFirst):\\n        printFirst()\\n        self.x += 1\\n\\n    def second(self, printSecond):\\n        while self.x < 1:\\n            pass\\n        printSecond()\\n        self.x += 1\\n            \\n    def third(self, printThird):\\n        while self.x < 2:\\n            pass\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997508,
                "title": "python-using-events",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.first_event = threading.Event()\\n        self.second_event = threading.Event()\\n       \\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.first_event.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.first_event.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.second_event.set()\\n            \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.second_event.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.first_event = threading.Event()\\n        self.second_event = threading.Event()\\n       \\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.first_event.set()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.first_event.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.second_event.set()\\n            \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.second_event.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751895,
                "title": "java-simple-solution",
                "content": "```\\nclass Foo {\\n    \\n    CountDownLatch latchForSecond = new CountDownLatch(1);\\n    CountDownLatch latchForThird = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchForSecond.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchForSecond.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchForThird.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchForThird.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    CountDownLatch latchForSecond = new CountDownLatch(1);\\n    CountDownLatch latchForThird = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchForSecond.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchForSecond.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchForThird.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchForThird.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541307,
                "title": "c-semaphore-based-simple-and-short",
                "content": "```\\ntypedef struct {\\n    sem_t sem_a;\\n    sem_t sem_b;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = malloc(sizeof (Foo));\\n    sem_init(&obj->sem_a, 0, 0);\\n    sem_init(&obj->sem_b, 0, 0);\\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    sem_post(&obj->sem_a);\\n}\\n\\nvoid second(Foo* obj) {\\n    sem_wait(&obj->sem_a);\\n    printSecond();\\n    sem_post(&obj->sem_b);\\n}\\n\\nvoid third(Foo* obj) {\\n    sem_wait(&obj->sem_b);\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    free(obj);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    sem_t sem_a;\\n    sem_t sem_b;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = malloc(sizeof (Foo));\\n    sem_init(&obj->sem_a, 0, 0);\\n    sem_init(&obj->sem_b, 0, 0);\\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    printFirst();\\n    sem_post(&obj->sem_a);\\n}\\n\\nvoid second(Foo* obj) {\\n    sem_wait(&obj->sem_a);\\n    printSecond();\\n    sem_post(&obj->sem_b);\\n}\\n\\nvoid third(Foo* obj) {\\n    sem_wait(&obj->sem_b);\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 402339,
                "title": "accepted-c-using-autoresetevent",
                "content": "```\\nusing System.Threading;    \\n\\npublic class Foo\\n    {\\n        private EventWaitHandle _waitFirst;\\n        private EventWaitHandle _waitSecond;\\n\\n        public Foo()\\n        {\\n            _waitFirst = new AutoResetEvent(false);\\n            _waitSecond = new AutoResetEvent(false);\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            _waitFirst.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            _waitFirst.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            _waitSecond.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            _waitSecond.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;    \\n\\npublic class Foo\\n    {\\n        private EventWaitHandle _waitFirst;\\n        private EventWaitHandle _waitSecond;\\n\\n        public Foo()\\n        {\\n            _waitFirst = new AutoResetEvent(false);\\n            _waitSecond = new AutoResetEvent(false);\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n\\n            // printFirst() outputs \"first\". Do not change or remove this line.\\n            printFirst();\\n            _waitFirst.Set();\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            _waitFirst.WaitOne();\\n            // printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond();\\n            _waitSecond.Set();\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            _waitSecond.WaitOne();\\n            // printThird() outputs \"third\". Do not change or remove this line.\\n            printThird();\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 376571,
                "title": "simple-java-solution-using-booleans-for-locking",
                "content": "class Foo {\\n    \\n        private volatile boolean executedFirst,executedSecond;\\n        public Foo() {}\\n    \\n        public void first(Runnable printFirst) throws InterruptedException {\\n            executedFirst = true;\\n            printFirst.run();\\n        }\\n    \\n        public void second(Runnable printSecond) throws InterruptedException {\\n    \\n            while (!executedFirst);\\n            executedSecond = true;\\n            printSecond.run();\\n        }\\n    \\n        public void third(Runnable printThird) throws InterruptedException {\\n            while (!executedSecond);\\n            printThird.run();\\n        }",
                "solutionTags": [],
                "code": "class Foo {\\n    \\n        private volatile boolean executedFirst,executedSecond;\\n        public Foo() {}\\n    \\n        public void first(Runnable printFirst) throws InterruptedException {\\n            executedFirst = true;\\n            printFirst.run();\\n        }\\n    \\n        public void second(Runnable printSecond) throws InterruptedException {\\n    \\n            while (!executedFirst);\\n            executedSecond = true;\\n            printSecond.run();\\n        }\\n    \\n        public void third(Runnable printThird) throws InterruptedException {\\n            while (!executedSecond);\\n            printThird.run();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 370780,
                "title": "java-solution-using-wait-and-notifyall",
                "content": "A lot of solutions on here are using busy waits or sleeps - which are only slightly better. That is essentially a \\'fail\\' w.r.t. this question on threads. Here\\'s the solution I believe an interviewer would be looking for that uses wait() and notifyAll() with a liveness check inside a synchronized block. The locking object instance used in this code is the instance of Foo. I.e. \\'this\\'. Using wait() and notifyAll() means that the processors aren\\'t spinning and unnecessarily burning through compute power! \\n\\nAlso - notice that the thread coordination logic happens inside a synchronized block. Without that, there is no guarantee that the JVM memory model will communicate the state of the variables between threads. Always, put this kind of thread-coordination logic inside synchronized blocks. \\n\\nAlso - the Java seed code for this question is incorrectly using the Runnable interface. You never call run() on a runnable! That is for the JVM to call in a new thread when it is started. \\n\\n```\\nclass Foo {\\n    private boolean firstDone = false;\\n    private boolean secondDone = false;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this) {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            firstDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this) {\\n            while (!firstDone) {\\n                this.wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            this.secondDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this) {\\n            while (!secondDone) {\\n                this.wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private boolean firstDone = false;\\n    private boolean secondDone = false;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this) {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            firstDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this) {\\n            while (!firstDone) {\\n                this.wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            this.secondDone = true;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this) {\\n            while (!secondDone) {\\n                this.wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281277,
                "title": "c-use-mutex",
                "content": "# Intuition\\nUse condition variable and count variable and based on the count value , the desigenated thread will be running accordingly \\n\\n\\n```\\nclass Foo {\\npublic:\\n\\n    std::mutex m; \\n    std::condition_variable cv;\\n    int count; \\n \\n    Foo():count{0} {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        std::unique_lock<std::mutex> lock(m);\\n\\n        count++;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 1 ? true : false;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count++;\\n        lock.unlock(); \\n        cv.notify_all();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 2 ? true : false;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n\\n    std::mutex m; \\n    std::condition_variable cv;\\n    int count; \\n \\n    Foo():count{0} {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        std::unique_lock<std::mutex> lock(m);\\n\\n        count++;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 1 ? true : false;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        count++;\\n        lock.unlock(); \\n        cv.notify_all();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        std::unique_lock<std::mutex> lock(m);\\n        cv.wait(lock , [this](){return count == 2 ? true : false;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock(); \\n        cv.notify_all();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988841,
                "title": "using-manual-reset-event-set-wait-methods",
                "content": "# Intuition\\nWe need to synchronize the method execution in multi threaded environment so same can be achived using ManualResetEventslim class.  \\n\\n# Approach\\nWe can have two slim events, one to synchronize the call for first and second method to ensure that first always executed before second method. \\nAnd second slim event is to make sure that second method gets executed before the third method. \\nSo, we can intialize these instance in the constructions with disabled state. Till the time we enable them by calling Set method. The thread will wait on Wait method. \\nAfter priting first, we can set the first slim event. If a thread is waiting at Wait method in second method will get notified about its status change and now will resume its work. Same will happen for second slim event. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System.Threading;\\n\\npublic class Foo {\\n\\n     public ManualResetEventSlim slimEvent { get; set; }\\n     public ManualResetEventSlim secondslimEvent { get; set; }\\n\\n    public Foo() \\n    {\\n        slimEvent = new ManualResetEventSlim(false);\\n        secondslimEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        slimEvent.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        slimEvent.Wait();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondslimEvent.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        secondslimEvent.Wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n\\n     public ManualResetEventSlim slimEvent { get; set; }\\n     public ManualResetEventSlim secondslimEvent { get; set; }\\n\\n    public Foo() \\n    {\\n        slimEvent = new ManualResetEventSlim(false);\\n        secondslimEvent = new ManualResetEventSlim(false);\\n    }\\n\\n    public void First(Action printFirst) \\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        slimEvent.Set();\\n    }\\n\\n    public void Second(Action printSecond) \\n    {\\n        slimEvent.Wait();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        secondslimEvent.Set();\\n    }\\n\\n    public void Third(Action printThird) \\n    {\\n        secondslimEvent.Wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028788,
                "title": "simple-c-solution-with-mutex",
                "content": "```\\nclass Foo {\\npublic:\\n    mutex a, b;\\n    Foo() {\\n        a.lock();\\n        b.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        a.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        a.lock();\\n        printSecond();\\n        b.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        b.lock();\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    mutex a, b;\\n    Foo() {\\n        a.lock();\\n        b.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        a.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        a.lock();\\n        printSecond();\\n        b.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        b.lock();\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987717,
                "title": "java-simplest-solution-using-volatile-variable",
                "content": "Here, `volatile` keyword makes the variable threadsafe and making it visible to all threads works.\\n\\n```Java\\nclass Foo {\\n\\n    volatile int methodCompleted;\\n    \\n    public Foo() {\\n        methodCompleted = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        methodCompleted =  1;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (methodCompleted != 1) ;\\n        printSecond.run();\\n        methodCompleted =  2;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (methodCompleted != 2) ;\\n        printThird.run();\\n        methodCompleted =  3;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Foo {\\n\\n    volatile int methodCompleted;\\n    \\n    public Foo() {\\n        methodCompleted = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        methodCompleted =  1;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (methodCompleted != 1) ;\\n        printSecond.run();\\n        methodCompleted =  2;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (methodCompleted != 2) ;\\n        printThird.run();\\n        methodCompleted =  3;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894371,
                "title": "java-countdownlatch-simple-solution",
                "content": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n\\n    private final CountDownLatch firstLatch = new CountDownLatch(1);\\n    private final CountDownLatch secondLatch = new CountDownLatch(1);\\n\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n\\n    private final CountDownLatch firstLatch = new CountDownLatch(1);\\n    private final CountDownLatch secondLatch = new CountDownLatch(1);\\n\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844607,
                "title": "java-semaphore-solution",
                "content": "```\\nclass Foo {\\n    \\n    private final Semaphore second = new Semaphore(0);\\n    private final Semaphore third = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    private final Semaphore second = new Semaphore(0);\\n    private final Semaphore third = new Semaphore(0);\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        \\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631053,
                "title": "python-simple-solution-without-any-lib",
                "content": "\\tclass Foo:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.seq = 0\\n\\n\\t\\tdef first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\tprintFirst()\\n\\t\\t\\tself.seq = 1\\n\\n\\t\\tdef second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintSecond()\\n\\t\\t\\tself.seq = 2\\n\\n\\t\\tdef third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintThird()",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Foo:\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.seq = 0\\n\\n\\t\\tdef first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\tprintFirst()\\n\\t\\t\\tself.seq = 1\\n\\n\\t\\tdef second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 1:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintSecond()\\n\\t\\t\\tself.seq = 2\\n\\n\\t\\tdef third(self, printThird: \\'Callable[[], None]\\') -> None:\\n\\t\\t\\twhile self.seq < 2:\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\tprintThird()",
                "codeTag": "Java"
            },
            {
                "id": 907002,
                "title": "py3-runtime-32-ms-faster-than-93-93",
                "content": "Using thread lock and lock `first` and `second` first at the begining, then release `first` when `printFirst` being called, and release `second` when `printSecond` being called. After all `printThird` will be called.\\n\\n```class Foo:\\n    def __init__(self):\\n        self.tl1 = threading.Lock()\\n        self.tl2 = threading.Lock()\\n        self.tl1.acquire()\\n        self.tl2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.tl1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.tl1.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.tl2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.tl2.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        ```\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Foo:\\n    def __init__(self):\\n        self.tl1 = threading.Lock()\\n        self.tl2 = threading.Lock()\\n        self.tl1.acquire()\\n        self.tl2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.tl1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.tl1.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.tl2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.tl2.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 809116,
                "title": "java-solution-with-synchronized-methods",
                "content": "Code with a runtime of 10ms :\\n\\n```\\nclass Foo {\\n    public int count;\\n    \\n    public Foo() {\\n        this.count = 1;\\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        while(count != 1) wait();\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while(this.count != 2) wait();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while(this.count != 3) wait();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    public int count;\\n    \\n    public Foo() {\\n        this.count = 1;\\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        while(count != 1) wait();\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while(this.count != 2) wait();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while(this.count != 3) wait();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        this.count++;\\n        notifyAll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777380,
                "title": "python-loop-and-flag",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.f = True\\n        self.s = False\\n        self.t = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.s = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        while 1:\\n          if self.s:\\n            break\\n        printSecond()\\n        self.t = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        while 1:\\n          if self.t:\\n            break\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.f = True\\n        self.s = False\\n        self.t = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.s = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        while 1:\\n          if self.s:\\n            break\\n        printSecond()\\n        self.t = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        while 1:\\n          if self.t:\\n            break\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769363,
                "title": "java-simple-solution-using-volatile-97-faster",
                "content": "```\\nclass Foo {\\n\\n    public volatile int order;\\n    public Foo() {\\n        order= 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        order++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(order!=1);\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        order++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(order!=2);\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    public volatile int order;\\n    public Foo() {\\n        order= 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        order++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(order!=1);\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        order++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(order!=2);\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706604,
                "title": "python-use-2-queue-to-synchronize",
                "content": "```\\nfrom Queue import Queue\\n\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.q1.put(1)\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.q1.get()\\n        printSecond()\\n        self.q2.put(1)\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.q2.get()\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom Queue import Queue\\n\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.q1 = Queue()\\n        self.q2 = Queue()\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.q1.put(1)\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.q1.get()\\n        printSecond()\\n        self.q2.put(1)\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.q2.get()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640143,
                "title": "simple-6-lines-java-explained-solution",
                "content": "Intutuion\\n1. Use volatile variable which will update variable \\'a\\' in different caches of multi core system. Note - It is only required if this code runs on multi core environment.\\n2. Run printFirst.run only when a=1;\\n3. Run printSecond.run only when a=2; \\n4. Similarly printThird.run only when a=3l\\n```\\nclass Foo {\\n    volatile int a;\\n    public Foo() {\\n        a=1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        while(a!=1);\\n        printFirst.run();\\n        a=2;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(a!=2);\\n        printSecond.run();\\n        a=3;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        while(a!=3);\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    volatile int a;\\n    public Foo() {\\n        a=1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        while(a!=1);\\n        printFirst.run();\\n        a=2;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(a!=2);\\n        printSecond.run();\\n        a=3;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        while(a!=3);\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485268,
                "title": "c-w-promise-124ms-92-14-9-4mb-100",
                "content": "* Runtime: 124 ms, faster than 92.14% of C++ online submissions for Print in Order.\\n* Memory Usage: 9.4 MB, less than 100.00% of C++ online submissions for Print in Order.\\n\\nThis is a simple task. I did try writing one solution with a condition_variable and one using future/promise.\\nThe performance was fairly close, with promise performing slightly better.\\n\\nIf the task was larger in some dimension, I could walk through the program to show where time is being wasted.  This is as simple as it gets and there ought to be a tight cluster of results, where relative performance is honestly random.\\n\\nMy reason for using promise is that it avoids synchronizing mutex locks between many threads, but there isn\\'t much tradeoff between memory or performance no matter what you choose.\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {}\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    promise<bool> p1;\\n    promise<bool> p2;\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {}\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    promise<bool> p1;\\n    promise<bool> p2;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 355038,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nUse `Guarded Block`\\nhttps://docs.oracle.com/javase/tutorial/essential/concurrency/guardmeth.html\\n\\nBasically, adding `synchronized` keyword to all the methods will require any thread to acquire intrisic lock of the object of `Foo` (which is used by all the three thread below).\\nNow on this lock, we can conditionally block the threads based on current `counter` value. Only unblock the thread for which the condition that it was waiting for is met and rest of the threads will be blocked (their execution is suspended by the `wait()` call). \\n\\n```\\nclass Foo {\\n    int counter = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(counter != 1){\\n            wait();\\n        }\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(counter != 2){\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(counter != 3){\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    int counter = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(counter != 1){\\n            wait();\\n        }\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(counter != 2){\\n            wait();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(counter != 3){\\n            wait();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        ++counter;\\n        notifyAll();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 348334,
                "title": "c-autoresetevent-116ms",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    EventWaitHandle evnt1 = null;\\n    EventWaitHandle evnt2 = null;\\n    public Foo() {\\n        evnt1 = new AutoResetEvent(false);\\n        evnt2 = new AutoResetEvent(false);\\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        evnt1.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        evnt1.WaitOne();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        evnt2.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        evnt2.WaitOne();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        evnt2.Set();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    EventWaitHandle evnt1 = null;\\n    EventWaitHandle evnt2 = null;\\n    public Foo() {\\n        evnt1 = new AutoResetEvent(false);\\n        evnt2 = new AutoResetEvent(false);\\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        evnt1.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        evnt1.WaitOne();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        evnt2.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        evnt2.WaitOne();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        evnt2.Set();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339796,
                "title": "java-using-semaphores",
                "content": "```\\nimport java.util.concurrent.Semaphore;\\nclass Foo {\\n\\n    private final Semaphore second;\\n    private final Semaphore third;\\n    \\n    public Foo() {        \\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.Semaphore;\\nclass Foo {\\n\\n    private final Semaphore second;\\n    private final Semaphore third;\\n    \\n    public Foo() {        \\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333235,
                "title": "python-3-submission-with-threading-condition-beats-100-100",
                "content": "```\\nimport threading\\n\\n\\nclass Foo:\\n    def __init__(self):\\n        self.condition = threading.Condition()\\n        self.first_was_printed = False\\n        self.second_was_printed = False\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            printFirst()            \\n            self.first_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.first_was_printed\\n            )\\n            printSecond()\\n            self.second_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.second_was_printed\\n            )\\n            printThird()\\n            self.condition.notifyAll()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\n\\n\\nclass Foo:\\n    def __init__(self):\\n        self.condition = threading.Condition()\\n        self.first_was_printed = False\\n        self.second_was_printed = False\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            printFirst()            \\n            self.first_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.first_was_printed\\n            )\\n            printSecond()\\n            self.second_was_printed = True\\n            self.condition.notifyAll()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.condition:\\n            self.condition.wait_for(\\n                lambda: self.second_was_printed\\n            )\\n            printThird()\\n            self.condition.notifyAll()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511261,
                "title": "c-one-line-solution-with-std-atomic",
                "content": "# Intuition\\nWe use a variable (`turn`) to keep track of turns.\\n\\n# Approach\\nWe use `std::atomic` to prevent data race. Plus, we use `yield` to prevent busy waiting.\\n\\n# Code\\n```\\nclass Foo {\\n    std::atomic<int> turn = 1;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        while(turn!=1)\\n            this_thread::yield();\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn++;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(turn!=2)\\n            this_thread::yield();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn++;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(turn!=3)\\n            this_thread::yield();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    std::atomic<int> turn = 1;\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        while(turn!=1)\\n            this_thread::yield();\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn++;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(turn!=2)\\n            this_thread::yield();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn++;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(turn!=3)\\n            this_thread::yield();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454807,
                "title": "semaphore-solution-simple-java-code",
                "content": "```\\nclass Foo {\\n\\n    private Semaphore forTwo;\\n    private Semaphore forThree;\\n    \\n    public Foo() {\\n        forTwo = new Semaphore(0);\\n        forThree = new Semaphore(0);\\n    }\\n\\n\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        forTwo.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        forTwo.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        forThree.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        \\n        forThree.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private Semaphore forTwo;\\n    private Semaphore forThree;\\n    \\n    public Foo() {\\n        forTwo = new Semaphore(0);\\n        forThree = new Semaphore(0);\\n    }\\n\\n\\n    \\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        forTwo.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        forTwo.acquire();\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        \\n        forThree.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        \\n        forThree.acquire();\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147615,
                "title": "a-simple-solution-in-java",
                "content": "```\\nclass Foo {\\n    \\n    CountDownLatch second;\\n    CountDownLatch third;\\n\\n    public Foo() {\\n        second = new CountDownLatch(1);\\n        third = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    \\n    CountDownLatch second;\\n    CountDownLatch third;\\n\\n    public Foo() {\\n        second = new CountDownLatch(1);\\n        third = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013481,
                "title": "brainless-solution-using-time-sleep",
                "content": "Here is my simplest and brainless solution using time.sleep. Why and How did I think of it? People use this approach in automation where I work.\\n\\n```Python3\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        sleep(0.05)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        sleep(0.1)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```Python3\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        sleep(0.05)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        sleep(0.1)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856298,
                "title": "2-lines-python-solution-75-faster-memory-less-than-95",
                "content": "```\\nclass Foo:\\n    is_first_executed=False\\n    is_second_executed=False\\n    def __init__(self):\\n        pass\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.is_first_executed=True\\n\\n    def second(self, printSecond):\\n        while not self.is_first_executed: continue     \\n        printSecond()\\n        self.is_second_executed=True\\n                      \\n    def third(self, printThird):\\n        while not self.is_second_executed: continue\\n        printThird()\\n```\\n\\n-----------------\\n### ***Another Solution***\\n```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.event1=Event()\\n        self.event2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    is_first_executed=False\\n    is_second_executed=False\\n    def __init__(self):\\n        pass\\n\\n    def first(self, printFirst):\\n        printFirst()\\n        self.is_first_executed=True\\n\\n    def second(self, printSecond):\\n        while not self.is_first_executed: continue     \\n        printSecond()\\n        self.is_second_executed=True\\n                      \\n    def third(self, printThird):\\n        while not self.is_second_executed: continue\\n        printThird()\\n```\n```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.event1=Event()\\n        self.event2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self.event1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.event1.wait()\\n        printSecond()\\n        self.event2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.event2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719686,
                "title": "c-zero-semaphore-with-comments",
                "content": "```\\n#include<semaphore.h>\\nclass Foo {\\npublic:\\n    sem_t sem1;\\n    sem_t sem2;\\n    Foo() {\\n        sem_init(&sem1,0,0);\\n        sem_init(&sem2,0,0);\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        printFirst();\\n        sem_post(&sem1);// increased the value to 1 so now two can be executed\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        sem_wait(&sem1);//see  if the value of the semaphore is > 0 or not if it is then one already was printed\\n        printSecond();\\n        sem_post(&sem2);// printed two so now increased the value of the semaphore sem2\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        sem_wait(&sem2);// if the value of the sem2 > 0 them two was already printed \\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<semaphore.h>\\nclass Foo {\\npublic:\\n    sem_t sem1;\\n    sem_t sem2;\\n    Foo() {\\n        sem_init(&sem1,0,0);\\n        sem_init(&sem2,0,0);\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        printFirst();\\n        sem_post(&sem1);// increased the value to 1 so now two can be executed\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        sem_wait(&sem1);//see  if the value of the semaphore is > 0 or not if it is then one already was printed\\n        printSecond();\\n        sem_post(&sem2);// printed two so now increased the value of the semaphore sem2\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        sem_wait(&sem2);// if the value of the sem2 > 0 them two was already printed \\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1548013,
                "title": "explanation-of-the-solution-in-java",
                "content": "You can use a countdownlatch, semaphore, regular mutex or lock object. I noticed a solution that relied upon volatile only but that is not right. A solution without wait/notify will cause CPU churns and spinning so you must introduce that if you are serious about MT safe programming. If you choose to go with CountDownLatch or Semaphores, you can create 2 indepent ones and there is an ordering one after another. I chose to use a lock object to demonstrate in detail how we enforce the ordering. Note that you must have a while loop to protect against the spurious wakeups. \\n\\n```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    private final Lock lock = new ReentrantLock();\\n    private final Condition secondThread = lock.newCondition();\\n    private final Condition thirdThread = lock.newCondition();\\n    private int step = 1;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();  \\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            // signal 2nd.\\n            step = 2;\\n            secondThread.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step != 2) {\\n                // protect against spurious wakeups.\\n                secondThread.await();        \\n            }\\n            printSecond.run();\\n            thirdThread.signal();\\n            step = 3;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step !=3) {\\n                // protect against spurious wakeups.\\n                thirdThread.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    private final Lock lock = new ReentrantLock();\\n    private final Condition secondThread = lock.newCondition();\\n    private final Condition thirdThread = lock.newCondition();\\n    private int step = 1;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();  \\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            // signal 2nd.\\n            step = 2;\\n            secondThread.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step != 2) {\\n                // protect against spurious wakeups.\\n                secondThread.await();        \\n            }\\n            printSecond.run();\\n            thirdThread.signal();\\n            step = 3;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        lock.lock();\\n        try {\\n            while (step !=3) {\\n                // protect against spurious wakeups.\\n                thirdThread.await();\\n            }\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182618,
                "title": "simple-java-solution",
                "content": "Using wait and notifyAll to print in order. \\n``` \\nvolatile int loc = 0;\\n    public Foo() {\\n      loc = 0;   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            while(loc != 0){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 1){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printSecond.run();\\n         }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 2){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printThird.run();\\n         }\\n    }",
                "solutionTags": [],
                "code": "Using wait and notifyAll to print in order. \\n``` \\nvolatile int loc = 0;\\n    public Foo() {\\n      loc = 0;   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            while(loc != 0){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 1){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printSecond.run();\\n         }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n         synchronized(this){\\n            while(loc != 2){\\n                this.wait();\\n            }\\n            loc = (loc + 1) % 3;\\n            this.notifyAll();\\n            printThird.run();\\n         }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1152634,
                "title": "c-mutex-and-condition-variable-12ms",
                "content": "```\\nclass Foo {\\n    mutex m;\\n    condition_variable firstCond;\\n    condition_variable secondCond;\\n    condition_variable thirdCond;\\n    int chance;\\npublic:\\n    Foo() {\\n        chance=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> locker(m);\\n        \\n        firstCond.wait(locker,[&](){\\n            return chance==1;\\n        });\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        chance=2;\\n        secondCond.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> locker(m);\\n        \\n        secondCond.wait(locker,[&](){\\n            return chance==2;\\n        });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        chance=3;\\n        thirdCond.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> locker(m);\\n        \\n        thirdCond.wait(locker,[&](){\\n            return chance==3;\\n        });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    mutex m;\\n    condition_variable firstCond;\\n    condition_variable secondCond;\\n    condition_variable thirdCond;\\n    int chance;\\npublic:\\n    Foo() {\\n        chance=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> locker(m);\\n        \\n        firstCond.wait(locker,[&](){\\n            return chance==1;\\n        });\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        chance=2;\\n        secondCond.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> locker(m);\\n        \\n        secondCond.wait(locker,[&](){\\n            return chance==2;\\n        });\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        chance=3;\\n        thirdCond.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> locker(m);\\n        \\n        thirdCond.wait(locker,[&](){\\n            return chance==3;\\n        });\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122967,
                "title": "c-simple-atomics-with-memory-order",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a1.store(true, memory_order_release);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!a1.load(std::memory_order_acquire)) this_thread::yield();\\n        printSecond();\\n        a2.store(true, memory_order_release);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(!a2.load(std::memory_order_acquire)) this_thread::yield();\\n        printThird();\\n    }\\nprivate:\\n    atomic<bool> a1{false};\\n    atomic<bool> a2{false};\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a1.store(true, memory_order_release);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(!a1.load(std::memory_order_acquire)) this_thread::yield();\\n        printSecond();\\n        a2.store(true, memory_order_release);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(!a2.load(std::memory_order_acquire)) this_thread::yield();\\n        printThird();\\n    }\\nprivate:\\n    atomic<bool> a1{false};\\n    atomic<bool> a2{false};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055949,
                "title": "c-using-semaphores-short-with-comments",
                "content": "```\\n#include <semaphore.h>\\nclass Foo {\\n    sem_t firstSem;\\n    sem_t secondSem;\\npublic:\\n    Foo() {\\n\\t//init two semaphores with counter = 0\\n        sem_init(&firstSem, 0, 0);\\n        sem_init(&secondSem, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&firstSem); //increase firstSem counter to one to indicate printFirst() was finish \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&firstSem); //wait for printFirst() to finish\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&secondSem);  //increase secondSem counter to one to indicate printSecond() was finish \\n    }\\n\\n    void third(function<void()> printThird) {\\n         sem_wait(&secondSem); //wait for printSecond() to finish\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <semaphore.h>\\nclass Foo {\\n    sem_t firstSem;\\n    sem_t secondSem;\\npublic:\\n    Foo() {\\n\\t//init two semaphores with counter = 0\\n        sem_init(&firstSem, 0, 0);\\n        sem_init(&secondSem, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&firstSem); //increase firstSem counter to one to indicate printFirst() was finish \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&firstSem); //wait for printFirst() to finish\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&secondSem);  //increase secondSem counter to one to indicate printSecond() was finish \\n    }\\n\\n    void third(function<void()> printThird) {\\n         sem_wait(&secondSem); //wait for printSecond() to finish\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1033792,
                "title": "c-condition-variable-clean-code-easy-to-understand",
                "content": "```C++\\nclass Foo {\\n    atomic<int> cur;\\n    mutex mtx;\\n    condition_variable cv;\\nprotected:\\n    void do_work(function<void()> printS, function<bool()> check) {\\n        std::unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return check();});\\n        \\n        cur = (cur+1)%4;\\n        printS();\\n        cv.notify_all();\\n    }\\n    \\npublic:\\n    Foo() {\\n       this->cur = 1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        do_work(printFirst, [&]{return cur == 1;});\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        do_work(printSecond, [&]{return cur == 2;});\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n       do_work(printThird, [&]{return cur == 3;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\nclass Foo {\\n    atomic<int> cur;\\n    mutex mtx;\\n    condition_variable cv;\\nprotected:\\n    void do_work(function<void()> printS, function<bool()> check) {\\n        std::unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return check();});\\n        \\n        cur = (cur+1)%4;\\n        printS();\\n        cv.notify_all();\\n    }\\n    \\npublic:\\n    Foo() {\\n       this->cur = 1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        do_work(printFirst, [&]{return cur == 1;});\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        do_work(printSecond, [&]{return cur == 2;});\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n       do_work(printThird, [&]{return cur == 3;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008159,
                "title": "java-fastest-using-volatile-boolean-and-while-poll",
                "content": "```\\nclass Foo {\\n    volatile boolean waitTwo = true;\\n    volatile boolean waitThree = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        waitTwo = false;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(waitTwo){}\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        waitThree = false;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        while(waitThree){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    volatile boolean waitTwo = true;\\n    volatile boolean waitThree = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        waitTwo = false;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        while(waitTwo){}\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        waitThree = false;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        while(waitThree){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961280,
                "title": "python-solution-without-using-additional-libraries",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self._first = False\\n        self._second = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self._first = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while not self._first:\\n            pass\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self._second = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while not self._second:\\n            pass\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self._first = False\\n        self._second = False\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self._first = True\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while not self._first:\\n            pass\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self._second = True\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while not self._second:\\n            pass\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941730,
                "title": "countdownlatch-java",
                "content": "```\\nclass Foo {\\n\\n    private CountDownLatch latch1 = new CountDownLatch(1);\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n  \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n       \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        latch2.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private CountDownLatch latch1 = new CountDownLatch(1);\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n  \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n       \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        latch2.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940759,
                "title": "c-solution-using-2-mutexes",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        pthread_mutex_lock(&m_second);\\n        pthread_mutex_lock(&m_third);\\n    }\\n    \\n    ~Foo() {\\n        pthread_mutex_destroy(&m_second);\\n        pthread_mutex_destroy(&m_third);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        pthread_mutex_unlock(&m_second);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_second);\\n        printSecond();\\n        pthread_mutex_unlock(&m_third);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_third);\\n        printThird();\\n    }\\nprivate:\\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        pthread_mutex_lock(&m_second);\\n        pthread_mutex_lock(&m_third);\\n    }\\n    \\n    ~Foo() {\\n        pthread_mutex_destroy(&m_second);\\n        pthread_mutex_destroy(&m_third);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        pthread_mutex_unlock(&m_second);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_second);\\n        printSecond();\\n        pthread_mutex_unlock(&m_third);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        pthread_mutex_lock(&m_third);\\n        printThird();\\n    }\\nprivate:\\n    pthread_mutex_t m_second = PTHREAD_MUTEX_INITIALIZER;\\n    pthread_mutex_t m_third = PTHREAD_MUTEX_INITIALIZER;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850599,
                "title": "java-semaphore-simple-implementation",
                "content": "```\\nclass Foo {\\n    \\n    Semaphore second = new Semaphore(0);\\n    Semaphore third = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    Semaphore second = new Semaphore(0);\\n    Semaphore third = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757587,
                "title": "c-132ms-7-2mb-using-std-condition-variable-in-a-proper-way",
                "content": "Example with test cases\\nhttps://github.com/jimmy-park/leetcode-cpp-solution/blob/master/Concurrency/1114-Print-in-Order.h\\n\\n```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst)\\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n        {\\n            // prevent lost wakeup and spurious wakeup\\n            // and with CTAD (since C++17), you don\\'t need to type std::mutex as template argument\\n            std::lock_guard lock { mutex_ };\\n            done_first_ = true;\\n        }\\n\\n        cv_.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_first_; });\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        {\\n            std::lock_guard lock { mutex_ };\\n            done_second_ = true;\\n        }\\n        \\n        cv_.notify_one();\\n    }\\n\\n    void third(function<void()> printThird)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_second_; });\\n        }\\n\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    bool done_first_ { false };\\n    bool done_second_ { false };\\n    mutable std::mutex mutex_;\\n    std::condition_variable cv_;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    void first(function<void()> printFirst)\\n    {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n        {\\n            // prevent lost wakeup and spurious wakeup\\n            // and with CTAD (since C++17), you don\\'t need to type std::mutex as template argument\\n            std::lock_guard lock { mutex_ };\\n            done_first_ = true;\\n        }\\n\\n        cv_.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_first_; });\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        {\\n            std::lock_guard lock { mutex_ };\\n            done_second_ = true;\\n        }\\n        \\n        cv_.notify_one();\\n    }\\n\\n    void third(function<void()> printThird)\\n    {\\n        {\\n            std::unique_lock lock { mutex_ };\\n            cv_.wait(lock, [this] { return done_second_; });\\n        }\\n\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    bool done_first_ { false };\\n    bool done_second_ { false };\\n    mutable std::mutex mutex_;\\n    std::condition_variable cv_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567213,
                "title": "java-countdownlatch-solution",
                "content": "```\\nclass Foo {\\n\\n    CountDownLatch first = new CountDownLatch(1);\\n    CountDownLatch second = new CountDownLatch(1);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    CountDownLatch first = new CountDownLatch(1);\\n    CountDownLatch second = new CountDownLatch(1);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512327,
                "title": "python3-threading-using-lock",
                "content": "Algorithm:\\nUse two locks `self.lock1` and `self.lock2` to maintain the order of executions of 3 methods. \\n\\nImplementation (32ms, 90%): \\n```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        self.lock1.acquire() #lock\\n        self.lock2.acquire() #lock\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.lock1.release() #unlocked\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.lock1:\\n            # printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond()\\n            self.lock2.release() #unlocked\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.lock2:\\n            # printThird() outputs \"third\". Do not change or remove this line.\\n            printThird()\\n```\\n\\nThere is a very nice summary by @mereck in this [thread](https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation) of Python synchronization primitives.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom threading import Lock\\n\\nclass Foo:\\n    def __init__(self):\\n        self.lock1 = Lock()\\n        self.lock2 = Lock()\\n        self.lock1.acquire() #lock\\n        self.lock2.acquire() #lock\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.lock1.release() #unlocked\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        with self.lock1:\\n            # printSecond() outputs \"second\". Do not change or remove this line.\\n            printSecond()\\n            self.lock2.release() #unlocked\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        with self.lock2:\\n            # printThird() outputs \"third\". Do not change or remove this line.\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477201,
                "title": "countdownlatch-java-100-100",
                "content": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    CountDownLatch latch1;\\n    CountDownLatch latch2;\\n    \\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.CountDownLatch;\\n\\nclass Foo {\\n    CountDownLatch latch1;\\n    CountDownLatch latch2;\\n    \\n    public Foo() {\\n        latch1 = new CountDownLatch(1);\\n        latch2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch2.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476741,
                "title": "java-using-lock-synchronized-wait-notifyall-solution",
                "content": "```java\\nclass Foo {\\n    private final AtomicInteger i = new AtomicInteger();\\n    private final Object lock = new Object();\\n\\n    public Foo() {\\n        i.set(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 0) {\\n                lock.wait();\\n            }\\n            printFirst.run();\\n            i.set(1);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 1) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            i.set(2);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 2) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n            i.set(3);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    private final AtomicInteger i = new AtomicInteger();\\n    private final Object lock = new Object();\\n\\n    public Foo() {\\n        i.set(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 0) {\\n                lock.wait();\\n            }\\n            printFirst.run();\\n            i.set(1);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 1) {\\n                lock.wait();\\n            }\\n            printSecond.run();\\n            i.set(2);\\n            lock.notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (lock) {\\n            while (i.get() != 2) {\\n                lock.wait();\\n            }\\n            printThird.run();\\n            i.set(3);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456220,
                "title": "c-with-spinwait",
                "content": "```\\nusing System.Threading;\\npublic class Foo {\\n    private int _state = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        _state = 2; \\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==2);\\n        printSecond();\\n        _state=3;\\n    }\\n\\n    public void Third(Action printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==3);\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\npublic class Foo {\\n    private int _state = 1;\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        _state = 2; \\n    }\\n\\n    public void Second(Action printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==2);\\n        printSecond();\\n        _state=3;\\n    }\\n\\n    public void Third(Action printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        SpinWait.SpinUntil(()=>_state==3);\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447099,
                "title": "simple-java-solution",
                "content": "```\\nclass Foo {\\n    CountDownLatch lock1;\\n    CountDownLatch lock2;\\n    public Foo() {\\n        lock1 = new CountDownLatch(1);\\n        lock2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        lock1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        lock2.countDown();\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock1.await();\\n        lock2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    CountDownLatch lock1;\\n    CountDownLatch lock2;\\n    public Foo() {\\n        lock1 = new CountDownLatch(1);\\n        lock2 = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        lock1.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock1.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        lock2.countDown();\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock1.await();\\n        lock2.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440715,
                "title": "why-sem-t-is-unknown-for-c",
                "content": "When I include semaphore.h in C code and use sem_t sem, it gives unknown data type sem_t?\\nerror:\\nLine 10: Char 5: error: unknown type name \\'sem_t\\'\\n     sem_t sem;\\n\\n#include <semaphore.h>\\n#include <pthread.h>\\n#include <unistd.h> \\n#include <sys/types.h>\\n\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int data;\\n    sem_t sem;\\n} Foo;\\n",
                "solutionTags": [],
                "code": "When I include semaphore.h in C code and use sem_t sem, it gives unknown data type sem_t?\\nerror:\\nLine 10: Char 5: error: unknown type name \\'sem_t\\'\\n     sem_t sem;\\n\\n#include <semaphore.h>\\n#include <pthread.h>\\n#include <unistd.h> \\n#include <sys/types.h>\\n\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int data;\\n    sem_t sem;\\n} Foo;\\n",
                "codeTag": "C++"
            },
            {
                "id": 436919,
                "title": "c-solution-no-need-a-lock",
                "content": "```\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int val;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    \\n    // Initialize user defined data here.\\n    obj->val = 0;\\n    \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    \\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    \\n    obj->val++;\\n}\\n\\nvoid second(Foo* obj) {\\n    while (obj->val < 1) {\\n       sched_yield();\\n    }\\n    \\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    \\n    obj->val++;\\n}\\n\\nvoid third(Foo* obj) {\\n    while (obj->val < 2) {\\n       sched_yield();\\n    }\\n    \\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // User defined data may be cleaned up here.\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    // User defined data may be declared here.\\n    int val;\\n} Foo;\\n\\nFoo* fooCreate() {\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    \\n    // Initialize user defined data here.\\n    obj->val = 0;\\n    \\n    return obj;\\n}\\n\\nvoid first(Foo* obj) {\\n    \\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    \\n    obj->val++;\\n}\\n\\nvoid second(Foo* obj) {\\n    while (obj->val < 1) {\\n       sched_yield();\\n    }\\n    \\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    \\n    obj->val++;\\n}\\n\\nvoid third(Foo* obj) {\\n    while (obj->val < 2) {\\n       sched_yield();\\n    }\\n    \\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n}\\n\\nvoid fooFree(Foo* obj) {\\n    // User defined data may be cleaned up here.\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 360882,
                "title": "c-super-simple-implementation-90",
                "content": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    int state;\\n    condition_variable cv;\\npublic:\\n    Foo(): state{0}{}\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==0;});\\n        state=1;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==1;});\\n        state=2;\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==2;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    int state;\\n    condition_variable cv;\\npublic:\\n    Foo(): state{0}{}\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==0;});\\n        state=1;\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==1;});\\n        state=2;\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock,[&]{return state==2;});\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lock.unlock();\\n        cv.notify_all();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 356791,
                "title": "c-future-promise-or-mutex-condition-variable",
                "content": "Solution 1: \\nfuture + promise.\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    std::promise<int> p1;\\n    std::promise<int> p2;\\n};\\n```\\n\\nsolution 2:\\nmutex + condition_variable\\n```\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        b1 = false;\\n        b2 = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        b1 = true;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b1;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        b2 = true;\\n        lk.unlock();\\n        cv.notify_one();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b2; });\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lk.unlock();\\n    }\\nprivate:    \\n    std::mutex mtx;\\n    bool b1, b2;\\n    condition_variable cv;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        p1.set_value(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        p1.get_future().wait();\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        p2.set_value(2);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        p2.get_future().wait();\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n    \\n    std::promise<int> p1;\\n    std::promise<int> p2;\\n};\\n```\n```\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        b1 = false;\\n        b2 = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        b1 = true;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b1;});\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        b2 = true;\\n        lk.unlock();\\n        cv.notify_one();\\n\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lk(mtx);\\n        cv.wait(lk, [&]{return b2; });\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        lk.unlock();\\n    }\\nprivate:    \\n    std::mutex mtx;\\n    bool b1, b2;\\n    condition_variable cv;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353129,
                "title": "java-solution-with-single-semaphore",
                "content": "```\\nclass Foo {\\n\\n    java.util.concurrent.Semaphore semaphore = new java.util.concurrent.Semaphore(2);\\n    \\n    public Foo() {\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(semaphore.availablePermits() != 2){}\\n        \\n        printFirst.run();\\n\\n        semaphore.acquire();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(semaphore.availablePermits() != 1){}\\n        \\n        printSecond.run();        \\n\\n        semaphore.acquire();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(semaphore.availablePermits() != 0){}\\n        \\n        printThird.run();\\n\\n        semaphore.release(2);\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    java.util.concurrent.Semaphore semaphore = new java.util.concurrent.Semaphore(2);\\n    \\n    public Foo() {\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(semaphore.availablePermits() != 2){}\\n        \\n        printFirst.run();\\n\\n        semaphore.acquire();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(semaphore.availablePermits() != 1){}\\n        \\n        printSecond.run();        \\n\\n        semaphore.acquire();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(semaphore.availablePermits() != 0){}\\n        \\n        printThird.run();\\n\\n        semaphore.release(2);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 347584,
                "title": "java-compareandset",
                "content": "```java\\nimport java.util.concurrent.atomic.AtomicInteger;\\nclass Foo {\\n\\n    private AtomicInteger integer;\\n    \\n    public Foo() {\\n        integer = new AtomicInteger();    \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(!integer.compareAndSet(0, 1));\\n        printFirst.run();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!integer.compareAndSet(1, 2));\\n        printSecond.run();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!integer.compareAndSet(2, 3));\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nimport java.util.concurrent.atomic.AtomicInteger;\\nclass Foo {\\n\\n    private AtomicInteger integer;\\n    \\n    public Foo() {\\n        integer = new AtomicInteger();    \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(!integer.compareAndSet(0, 1));\\n        printFirst.run();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(!integer.compareAndSet(1, 2));\\n        printSecond.run();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(!integer.compareAndSet(2, 3));\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336394,
                "title": "java-volatile-9ms",
                "content": "```\\nclass Foo {\\n    private  volatile Integer a;\\n    public Foo() {\\n        a = 0;\\n    }\\n    public void first(Runnable printFirst) throws InterruptedException {\\n         printFirst.run();\\n         a++;\\n    }\\n    public void second(Runnable printSecond) throws InterruptedException {\\n         while(a%3 != 1){}\\n         printSecond.run();\\n         a++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n          while(a%3 != 2){}\\n          printThird.run();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private  volatile Integer a;\\n    public Foo() {\\n        a = 0;\\n    }\\n    public void first(Runnable printFirst) throws InterruptedException {\\n         printFirst.run();\\n         a++;\\n    }\\n    public void second(Runnable printSecond) throws InterruptedException {\\n         while(a%3 != 1){}\\n         printSecond.run();\\n         a++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n          while(a%3 != 2){}\\n          printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332954,
                "title": "java-go-implements",
                "content": "Interesting, wish leetcode provide Go lang soon.\\n\\n**Java**\\n```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    Semaphore semaphore1 = new Semaphore(0);\\n    Semaphore semaphore2 = new Semaphore(0);\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        semaphore1.acquire();\\n        printSecond.run();\\n        semaphore2.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        semaphore2.acquire();        \\n        printThird.run();\\n    }\\n}\\n```\\n\\n**Go**\\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nvar oneDone = make(chan bool)\\nvar twoDone = make(chan bool)\\n\\nfunc first() {\\n\\tfmt.Println(\"one\")\\n\\toneDone <- true\\n}\\n\\nfunc second() {\\n\\t<-oneDone\\n\\tfmt.Println(\"two\")\\n\\ttwoDone <- true\\n}\\n\\nfunc third() {\\n\\t<-twoDone\\n\\tfmt.Println(\"three\")\\n}\\n\\nfunc main() {\\n\\tgo second()\\n\\tgo third()\\n\\tgo first()\\n\\n\\tfmt.Scanln()\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.concurrent.*;\\n\\nclass Foo {\\n    Semaphore semaphore1 = new Semaphore(0);\\n    Semaphore semaphore2 = new Semaphore(0);\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        semaphore1.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        semaphore1.acquire();\\n        printSecond.run();\\n        semaphore2.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        semaphore2.acquire();        \\n        printThird.run();\\n    }\\n}\\n```\n```\\npackage main\\n\\nimport \"fmt\"\\n\\nvar oneDone = make(chan bool)\\nvar twoDone = make(chan bool)\\n\\nfunc first() {\\n\\tfmt.Println(\"one\")\\n\\toneDone <- true\\n}\\n\\nfunc second() {\\n\\t<-oneDone\\n\\tfmt.Println(\"two\")\\n\\ttwoDone <- true\\n}\\n\\nfunc third() {\\n\\t<-twoDone\\n\\tfmt.Println(\"three\")\\n}\\n\\nfunc main() {\\n\\tgo second()\\n\\tgo third()\\n\\tgo first()\\n\\n\\tfmt.Scanln()\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022323,
                "title": "c-mutex-condition-variable-simple-code",
                "content": "# Note\\n\\n* We don\\'t need any wait for printing 1. Hence, no condition variable wait\\n* We don\\'t need to notify anyone after printing 3. Hence, no notify after printing 3.\\n* My code doesn\\'t work when I do \\n`if(currentPrint!=2) cv.wait(lock)`\\nbut works only when I do \\n`cv.wait(lock,[&](){return currentPrint==2;});`\\n\\nIt is best to pass the boolean expression as part of wait. Otherwise, there is a timeout.\\n\\n\\n# Code\\n```\\nclass Foo {\\n    condition_variable cv;\\n    mutex mtx;\\n    int currentPrint;\\npublic:\\n    Foo() {\\n        currentPrint=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex>lock(mtx);\\n        currentPrint=2;\\n        printFirst();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==2;});\\n        currentPrint=3;\\n        printSecond();\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==3;});\\n        printThird();\\n    }\\n};\\n```\\n\\n\\nPlease let me know if there are any feedbacks on this. Happy coding (^-^)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\n    condition_variable cv;\\n    mutex mtx;\\n    int currentPrint;\\npublic:\\n    Foo() {\\n        currentPrint=1;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex>lock(mtx);\\n        currentPrint=2;\\n        printFirst();\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==2;});\\n        currentPrint=3;\\n        printSecond();\\n        cv.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(mtx);\\n        cv.wait(lock,[&](){return currentPrint==3;});\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3475728,
                "title": "only-used-vector-no-lock-semaphore-low-level-objects",
                "content": "# Approach\\nNot a fan of low level stuff (even for easy questions), so here\\'s a solution using nothing but a vector.\\n\\nI made the class have a vector, printed, which contains bool values of whether any given print function executed. Since the same instance will be passed to each thread, all threads can update this vector so that other threads can see.\\n\\nAdditonally, since each thread calls a different function (Thread A calls first(), Thread B second(), Thread C third()), they will all manipulate a different section of the Foo object (Thread A printed[0], Thread B printed[1], Thread C printed[2]), so race conditions are taken into account in this solution.\\n\\nThis solution has a high run time (beats 9.36% of solutions), and is not anything remotely like any reasonable expected solution. This solution is for the software engineers that ventured into the land of concurrency out of curiosity, like me.\\n\\n\\n# Code\\n```\\nclass Foo {\\nprivate:\\n    vector<bool> printed; // keeps track of which print funcs executed\\npublic:\\n    Foo() : printed(3, false) {}\\n\\n    void first(function<void()> printFirst) {\\n        printFirst(); // this should always print first\\n        printed[0] = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (!printed[0]) {} // second will never print first, wait for first\\n        printSecond();\\n        printed[1] = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // no need to explicitly wait for first, since second should never execute before first\\n        // besides, waiting for first and second creates a race condition, since two threads are reading the same piece of data\\n        while (!printed[1]) {} // wait for second\\n        printThird();\\n        printed[2] = true;\\n    }\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Concurrency"
                ],
                "code": "```\\nclass Foo {\\nprivate:\\n    vector<bool> printed; // keeps track of which print funcs executed\\npublic:\\n    Foo() : printed(3, false) {}\\n\\n    void first(function<void()> printFirst) {\\n        printFirst(); // this should always print first\\n        printed[0] = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (!printed[0]) {} // second will never print first, wait for first\\n        printSecond();\\n        printed[1] = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // no need to explicitly wait for first, since second should never execute before first\\n        // besides, waiting for first and second creates a race condition, since two threads are reading the same piece of data\\n        while (!printed[1]) {} // wait for second\\n        printThird();\\n        printed[2] = true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203351,
                "title": "c-simple-solution-using-only-this-thread-yield",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    int order = 1;\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n       if (order == 1) {\\n         order = 2;\\n       } \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (order != 2) {\\n          std::this_thread::yield();\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        if (order == 2) {\\n          order = 3;\\n        } \\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (order != 3) {\\n          std::this_thread::yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        \\n    }\\n\\n    int order = 1;\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\n       if (order == 1) {\\n         order = 2;\\n       } \\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while (order != 2) {\\n          std::this_thread::yield();\\n        }\\n\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\n        if (order == 2) {\\n          order = 3;\\n        } \\n    }\\n\\n    void third(function<void()> printThird) {\\n        while (order != 3) {\\n          std::this_thread::yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3135932,
                "title": "java-reentrant-lock",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Foo {\\n\\n    private final ReentrantLock lock = new ReentrantLock();\\n\\n    private final Condition condition1 = lock.newCondition();\\n\\n    private final Condition condition2 = lock.newCondition();\\n\\n    private boolean waitOne = true;\\n\\n    private boolean waitTwo = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            waitOne = false;\\n            condition1.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitOne) {\\n                condition1.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            waitTwo = false;\\n            condition2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitTwo) {\\n                condition2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printThird.run();\\n            waitOne = true;\\n            waitTwo = true;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n    private final ReentrantLock lock = new ReentrantLock();\\n\\n    private final Condition condition1 = lock.newCondition();\\n\\n    private final Condition condition2 = lock.newCondition();\\n\\n    private boolean waitOne = true;\\n\\n    private boolean waitTwo = true;\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            printFirst.run();\\n            waitOne = false;\\n            condition1.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitOne) {\\n                condition1.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            waitTwo = false;\\n            condition2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        lock.lock();\\n        try {\\n            while(waitTwo) {\\n                condition2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printThird.run();\\n            waitOne = true;\\n            waitTwo = true;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086543,
                "title": "java-solution-approach-1-using-object-lock-approach-2-using-countdown-latch",
                "content": "# Intuition\\nWe need to suspend the thread printing second until first completes, and third until second completes.\\n\\n# Approach 1 - Using Object lock\\nUse `synchronsed` block to guard the block of code, and suspend the thread using `buzy waiting` method until `first`, `second` is not printed in order.\\n\\n\\n# Code\\n```java\\nclass Foo {\\n    private int currentNum;\\n\\n    public Foo() {\\n        this.currentNum = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 1) {\\n                wait();\\n            }\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 2) {\\n                wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n         synchronized (this) {\\n            while (currentNum != 3) {\\n                wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n}\\n```\\n\\n\\n# Approach 2 - Using CountDownLatch\\nHere we make use of two countdown latches, \\nthe second thread waits on first latch to countDown to 0, and third thread waits on second latch to countDown to 0.\\n<br>\\nThe code is self explanatory.\\n\\n# Code\\n```java\\nclass Foo {\\n    private CountDownLatch firstLatch;\\n    private CountDownLatch secondLatch;\\n\\n    public Foo() {\\n        this.firstLatch = new CountDownLatch(1);\\n        this.secondLatch = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) {\\n        printFirst.run();\\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        printSecond.run();\\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Foo {\\n    private int currentNum;\\n\\n    public Foo() {\\n        this.currentNum = 1;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 1) {\\n                wait();\\n            }\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (this) {\\n            while (currentNum != 2) {\\n                wait();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n         synchronized (this) {\\n            while (currentNum != 3) {\\n                wait();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            currentNum++;\\n            notifyAll();\\n        }\\n    }\\n}\\n```\n```java\\nclass Foo {\\n    private CountDownLatch firstLatch;\\n    private CountDownLatch secondLatch;\\n\\n    public Foo() {\\n        this.firstLatch = new CountDownLatch(1);\\n        this.secondLatch = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) {\\n        printFirst.run();\\n        firstLatch.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstLatch.await();\\n        printSecond.run();\\n        secondLatch.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondLatch.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823042,
                "title": "java-solution-using-semaphore",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Foo {\\n\\n    Semaphore first;\\n    Semaphore second;\\n    Semaphore third;\\n    public Foo() {\\n        first = new Semaphore(1);\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        first.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        first.release();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n\\n    Semaphore first;\\n    Semaphore second;\\n    Semaphore third;\\n    public Foo() {\\n        first = new Semaphore(1);\\n        second = new Semaphore(0);\\n        third = new Semaphore(0);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        first.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        second.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        second.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        third.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        third.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        first.release();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2790990,
                "title": "java-phaser",
                "content": "# Code\\n```\\nclass Foo {\\n    private Phaser phaser = new Phaser(3);\\n\\n    public Foo() { }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (phaser.getPhase() != 1) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (phaser.getPhase() != 2) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private Phaser phaser = new Phaser(3);\\n\\n    public Foo() { }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while (phaser.getPhase() != 1) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        phaser.arriveAndDeregister();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while (phaser.getPhase() != 2) {\\n          phaser.arriveAndAwaitAdvance();\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755956,
                "title": "c-blocking-threads-with-autoresetevent-primitives",
                "content": "# Intuition\\nFirst thing that came to my mind was to block second, then third method until prefious will be completed\\n\\n# Approach\\nI decided to block set blockers in second and third methods. We create 2 blockers in nonsignal state, that means the method WaitOne() will block threads. \\n\\nMethod First() without blockers, after running printFirst() we transfer _secondBlocker in signal state by running method Set(), so _secondBlocker unblocks blocked threads. The same with method Third()\\n\\n# Code\\n```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly AutoResetEvent _secondBlocker = new AutoResetEvent(false);\\n    private readonly AutoResetEvent _thirdBlocker = new AutoResetEvent(false);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _secondBlocker.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _secondBlocker.WaitOne();\\n        printSecond();\\n        _thirdBlocker.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _thirdBlocker.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    private readonly AutoResetEvent _secondBlocker = new AutoResetEvent(false);\\n    private readonly AutoResetEvent _thirdBlocker = new AutoResetEvent(false);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _secondBlocker.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _secondBlocker.WaitOne();\\n        printSecond();\\n        _thirdBlocker.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _thirdBlocker.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716544,
                "title": "c-0ms-100",
                "content": "![image](https://assets.leetcode.com/users/images/65577e65-fc51-4d55-a6ff-ad0c635d4717_1666065469.4353917.png)\\n```\\ntypedef struct\\n{\\n    // User defined data may be declared here.\\n    int turn;\\n    pthread_mutex_t lock;\\n    pthread_cond_t cond;\\n} Foo;\\n\\nFoo* fooCreate()\\n{\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    // init mutex and cond\\n    pthread_mutex_init(&(obj->lock), NULL);\\n    pthread_cond_init(&(obj->cond), NULL);\\n    obj->turn = 1;\\n    return obj;\\n}\\n\\nvoid first(Foo* obj)\\n{\\n    // take lock\\n    pthread_mutex_lock(&(obj->lock));\\n    // while not my turn\\n    while(obj->turn != 1)\\n    {\\n        // wait and unlock\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    obj->turn = 2;\\n    // unlock\\n    pthread_mutex_unlock(&(obj->lock));\\n    // broadcast\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid second(Foo* obj)\\n{\\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 2)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock));\\n    }\\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    obj->turn = 3;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid third(Foo* obj)\\n{    \\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 3)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n    obj->turn = 1;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid fooFree(Foo* obj)\\n{\\n    // User defined data may be cleaned up here.\\n    free(obj);\\n}\\n```\\n\\u2B06\\uFE0Fplease upvote if helpful :)\\u2B06\\uFE0F",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct\\n{\\n    // User defined data may be declared here.\\n    int turn;\\n    pthread_mutex_t lock;\\n    pthread_cond_t cond;\\n} Foo;\\n\\nFoo* fooCreate()\\n{\\n    Foo* obj = (Foo*) malloc(sizeof(Foo));\\n    // Initialize user defined data here.\\n    // init mutex and cond\\n    pthread_mutex_init(&(obj->lock), NULL);\\n    pthread_cond_init(&(obj->cond), NULL);\\n    obj->turn = 1;\\n    return obj;\\n}\\n\\nvoid first(Foo* obj)\\n{\\n    // take lock\\n    pthread_mutex_lock(&(obj->lock));\\n    // while not my turn\\n    while(obj->turn != 1)\\n    {\\n        // wait and unlock\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printFirst() outputs \"first\". Do not change or remove this line.\\n    printFirst();\\n    obj->turn = 2;\\n    // unlock\\n    pthread_mutex_unlock(&(obj->lock));\\n    // broadcast\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid second(Foo* obj)\\n{\\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 2)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock));\\n    }\\n    // printSecond() outputs \"second\". Do not change or remove this line.\\n    printSecond();\\n    obj->turn = 3;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid third(Foo* obj)\\n{    \\n    pthread_mutex_lock(&(obj->lock)); \\n    while(obj->turn != 3)\\n    {\\n        pthread_cond_wait(&(obj->cond), &(obj->lock)); \\n    }\\n    // printThird() outputs \"third\". Do not change or remove this line.\\n    printThird();\\n    obj->turn = 1;\\n    pthread_mutex_unlock(&(obj->lock));\\n    pthread_cond_broadcast(&(obj->cond));\\n}\\n\\nvoid fooFree(Foo* obj)\\n{\\n    // User defined data may be cleaned up here.\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2533398,
                "title": "java-real-simple-solution",
                "content": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403054,
                "title": "python-easy-solution",
                "content": "```\\nimport time\\nclass Foo:\\n    def __init__(self):\\n        self.state = [False,False,False]\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.state[0] = True\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.state[0]==False: time.sleep(0.001)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.state[1] = True\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.state[1]==False: time.sleep(0.001)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.state[2] = True\\n```",
                "solutionTags": [],
                "code": "```\\nimport time\\nclass Foo:\\n    def __init__(self):\\n        self.state = [False,False,False]\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.state[0] = True\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.state[0]==False: time.sleep(0.001)\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.state[1] = True\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.state[1]==False: time.sleep(0.001)\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.state[2] = True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356900,
                "title": "using-event",
                "content": "```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.t1=Event()\\n        self.t2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        printFirst()\\n        self.t1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.t1.wait()\\n        printSecond()\\n        self.t2.set()\\n        \\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.t2.wait()\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Event\\nclass Foo:\\n    def __init__(self):\\n        self.t1=Event()\\n        self.t2=Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        printFirst()\\n        self.t1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.t1.wait()\\n        printSecond()\\n        self.t2.set()\\n        \\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.t2.wait()\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313189,
                "title": "java-easy-solution",
                "content": "```\\nclass Foo {\\n    CountDownLatch c;\\n    CountDownLatch b;\\n\\n    public Foo() {\\n        b = new CountDownLatch(1);\\n        c = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        b.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        b.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        c.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        c.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    CountDownLatch c;\\n    CountDownLatch b;\\n\\n    public Foo() {\\n        b = new CountDownLatch(1);\\n        c = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        b.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        b.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        c.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        c.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265427,
                "title": "c-using-mutex-and-conditional-variable",
                "content": "In this solution I have used mutex and conditional variable. Also used an additional variable turn which will keep in track of which thread\\'s turn it is.\\n\\n```\\n// All the three threads got CPU and are running parallely. We don\\'t know which will run 1st, 2nd ...\\n\\n// Object of class Foo will be created. Foo --> foo1\\n// T1 = foo1.first\\n// T2 = foo1.second\\n// T3 = foo1.third\\n\\n// T2 will be waiting on some condition, which will become true when T1 has been executed\\n// T1 will make it true after printing first\\n\\n// Will use mutex and condition variable, and a variable turn to know who\\'s turn it is\\n// All the threads will shoot parallely. First turn = 0\\n\\nclass Foo {\\n    int turn;\\n    condition_variable(cv);\\n    mutex m;\\npublic:\\n    Foo() { // constructor\\n        turn = 0;\\n    }\\n\\n    void first(function<void()> printFirst) { // No condition on this as T1 will come first and execute it\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn = 1; // next turn is of T2\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(m);\\n        while(turn != 1){\\n            cv.wait(lock); // If it\\'s not turn of T2, thread will wait\\n        }\\n        // when signalled by T1, will go in while loop and check if turn == 1, if not then again wait.\\n        // else print second\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn = 2; // next turn is of T3\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(m);\\n        // When T1 will signal, CPU will come and check T3 also but due to condition of while loop it will again wait\\n        while(turn != 2){\\n            cv.wait(lock);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// All the three threads got CPU and are running parallely. We don\\'t know which will run 1st, 2nd ...\\n\\n// Object of class Foo will be created. Foo --> foo1\\n// T1 = foo1.first\\n// T2 = foo1.second\\n// T3 = foo1.third\\n\\n// T2 will be waiting on some condition, which will become true when T1 has been executed\\n// T1 will make it true after printing first\\n\\n// Will use mutex and condition variable, and a variable turn to know who\\'s turn it is\\n// All the threads will shoot parallely. First turn = 0\\n\\nclass Foo {\\n    int turn;\\n    condition_variable(cv);\\n    mutex m;\\npublic:\\n    Foo() { // constructor\\n        turn = 0;\\n    }\\n\\n    void first(function<void()> printFirst) { // No condition on this as T1 will come first and execute it\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        turn = 1; // next turn is of T2\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex>lock(m);\\n        while(turn != 1){\\n            cv.wait(lock); // If it\\'s not turn of T2, thread will wait\\n        }\\n        // when signalled by T1, will go in while loop and check if turn == 1, if not then again wait.\\n        // else print second\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        turn = 2; // next turn is of T3\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex>lock(m);\\n        // When T1 will signal, CPU will come and check T3 also but due to condition of while loop it will again wait\\n        while(turn != 2){\\n            cv.wait(lock);\\n        }\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064377,
                "title": "c-unique-lock-and-condition-variable-concurrency-in-c-notes",
                "content": "Tracking the last executed function using an integer. Then used a `condition_variable::wait` with a lambda expression to wait for the integer to change.\\n\\nConcurrency in C++ notes: https://github.com/akormous/dsa/tree/master/9_Concurrency\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        lastExecutedFunction = 0;   // initially\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);  // acquire lock\\n        cv.wait(lock, [&]{return lastExecutedFunction == 0;});  // wait until last executed function is 0, initial condition\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        lastExecutedFunction = 1;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 1;});  // wait until last exec function is first()\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        lastExecutedFunction = 2;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 2;});  // wait until last exec function is second()\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        lastExecutedFunction = 0;\\n        cv.notify_all();\\n    }\\nprivate:\\n    mutex mtx;\\n    condition_variable cv;\\n    int lastExecutedFunction;   // 0 (initial), 1, 2, or 3\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        lastExecutedFunction = 0;   // initially\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<mutex> lock(mtx);  // acquire lock\\n        cv.wait(lock, [&]{return lastExecutedFunction == 0;});  // wait until last executed function is 0, initial condition\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        lastExecutedFunction = 1;\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 1;});  // wait until last exec function is first()\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        lastExecutedFunction = 2;\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<mutex> lock(mtx);\\n        cv.wait(lock, [&]{return lastExecutedFunction == 2;});  // wait until last exec function is second()\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        lastExecutedFunction = 0;\\n        cv.notify_all();\\n    }\\nprivate:\\n    mutex mtx;\\n    condition_variable cv;\\n    int lastExecutedFunction;   // 0 (initial), 1, 2, or 3\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908213,
                "title": "pthread-h-mutex-cond",
                "content": "```c\\ntypedef struct {\\n        int flag;\\n        pthread_mutex_t mtx;\\n        pthread_cond_t cnd;\\n} Foo;\\n\\nFoo *\\nfooCreate()\\n{\\n        Foo *foo;\\n        foo = malloc(sizeof(*foo));\\n        foo->flag = 0;\\n        pthread_mutex_init(&foo->mtx, NULL);\\n        pthread_cond_init(&foo->cnd, NULL);\\n        return foo;\\n}\\n\\nvoid\\nsignal(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        foo->flag = val;\\n        pthread_cond_broadcast(&foo->cnd);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nwait(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        while (foo->flag != val)\\n                pthread_cond_wait(&foo->cnd, &foo->mtx);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nfirst(Foo *foo)\\n{\\n        printFirst();\\n        signal(foo, 1);\\n}\\n\\nvoid\\nsecond(Foo *foo)\\n{\\n        wait(foo, 1);\\n        printSecond();\\n        signal(foo, 2);\\n}\\n\\nvoid\\nthird(Foo *foo)\\n{\\n        wait(foo, 2);\\n        printThird();\\n}\\n\\nvoid\\nfooFree(Foo *foo)\\n{\\n        pthread_mutex_destroy(&foo->mtx);\\n        pthread_cond_destroy(&foo->cnd);\\n        free(foo);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\ntypedef struct {\\n        int flag;\\n        pthread_mutex_t mtx;\\n        pthread_cond_t cnd;\\n} Foo;\\n\\nFoo *\\nfooCreate()\\n{\\n        Foo *foo;\\n        foo = malloc(sizeof(*foo));\\n        foo->flag = 0;\\n        pthread_mutex_init(&foo->mtx, NULL);\\n        pthread_cond_init(&foo->cnd, NULL);\\n        return foo;\\n}\\n\\nvoid\\nsignal(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        foo->flag = val;\\n        pthread_cond_broadcast(&foo->cnd);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nwait(Foo *foo, int val)\\n{\\n        pthread_mutex_lock(&foo->mtx);\\n        while (foo->flag != val)\\n                pthread_cond_wait(&foo->cnd, &foo->mtx);\\n        pthread_mutex_unlock(&foo->mtx);\\n}\\n\\nvoid\\nfirst(Foo *foo)\\n{\\n        printFirst();\\n        signal(foo, 1);\\n}\\n\\nvoid\\nsecond(Foo *foo)\\n{\\n        wait(foo, 1);\\n        printSecond();\\n        signal(foo, 2);\\n}\\n\\nvoid\\nthird(Foo *foo)\\n{\\n        wait(foo, 2);\\n        printThird();\\n}\\n\\nvoid\\nfooFree(Foo *foo)\\n{\\n        pthread_mutex_destroy(&foo->mtx);\\n        pthread_cond_destroy(&foo->cnd);\\n        free(foo);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1896980,
                "title": "java-object-wait-notify-solution",
                "content": "As the same Foo instance passed to all threads, we can use the instance as a lock and use an index as identifier to arrange the correct order for printing.\\n```\\nclass Foo {\\n    private int index;\\n    public Foo() {\\n        index = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 0)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printFirst.run();\\n            index++;\\n            this.notifyAll();\\n            \\n        }\\n       \\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 1)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printSecond.run();\\n            index++;\\n            this.notifyAll();\\n       }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 2)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            index++;\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private int index;\\n    public Foo() {\\n        index = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 0)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printFirst.run();\\n            index++;\\n            this.notifyAll();\\n            \\n        }\\n       \\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 1)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printSecond.run();\\n            index++;\\n            this.notifyAll();\\n       }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized(this)\\n        {\\n            while(index %3 != 2)\\n            {\\n                this.wait();\\n            }\\n           \\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n            index++;\\n            this.notifyAll();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839215,
                "title": "python3-using-3-locks-60ms",
                "content": "from threading import Thread, Lock\\n\\n```\\nclass Foo:\\n    def __init__(self):\\n        self.lockFirst = Lock()\\n        self.lockSecond = Lock()\\n        self.lockThird = Lock()\\n        self.lockSecond.acquire()\\n        self.lockThird.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.lockFirst.acquire()\\n        printFirst()\\n        self.lockSecond.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lockSecond.acquire()\\n        printSecond()\\n        self.lockThird.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lockThird.acquire()\\n        printThird()\\n        self.lockFirst.release()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.lockFirst = Lock()\\n        self.lockSecond = Lock()\\n        self.lockThird = Lock()\\n        self.lockSecond.acquire()\\n        self.lockThird.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.lockFirst.acquire()\\n        printFirst()\\n        self.lockSecond.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.lockSecond.acquire()\\n        printSecond()\\n        self.lockThird.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.lockThird.acquire()\\n        printThird()\\n        self.lockFirst.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748867,
                "title": "python-solution",
                "content": "```\\nfrom threading import Lock\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.locks[0].release()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.locks[1]:\\n            printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Lock\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.locks = (Lock(),Lock())\\n        self.locks[0].acquire()\\n        self.locks[1].acquire()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.locks[0].release()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.locks[0]:\\n            printSecond()\\n            self.locks[1].release()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.locks[1]:\\n            printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606754,
                "title": "java-synchronized-on-the-foo-object",
                "content": "I\\'ve seen some more exotic solutions posted here. Is this standard or in any way problematic?\\n```class Foo {\\n    private static enum PrintState {\\n        ZERO, DID1, DID2\\n    }\\n    private PrintState printState = PrintState.ZERO;\\n    \\n    public Foo() {}\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(printState != PrintState.ZERO) wait();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        printState = PrintState.DID1;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(printState != PrintState.DID1) wait();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        printState = PrintState.DID2;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(printState != PrintState.DID2) wait();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        printState = PrintState.ZERO;\\n        notifyAll();\\n    }\\n}",
                "solutionTags": [],
                "code": "I\\'ve seen some more exotic solutions posted here. Is this standard or in any way problematic?\\n```class Foo {\\n    private static enum PrintState {\\n        ZERO, DID1, DID2\\n    }\\n    private PrintState printState = PrintState.ZERO;\\n    \\n    public Foo() {}\\n\\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\\n        while(printState != PrintState.ZERO) wait();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        printState = PrintState.DID1;\\n        notifyAll();\\n    }\\n\\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\\n        while(printState != PrintState.DID1) wait();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        printState = PrintState.DID2;\\n        notifyAll();\\n    }\\n\\n    public synchronized void third(Runnable printThird) throws InterruptedException {\\n        while(printState != PrintState.DID2) wait();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        printState = PrintState.ZERO;\\n        notifyAll();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1569063,
                "title": "python-mutex",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        from threading import Lock\\n\\n        self._mutex1 = Lock()\\n        self._mutex2 = Lock()\\n        self._mutex1.acquire()\\n        self._mutex2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self._mutex1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self._mutex1.acquire()\\n        printSecond()\\n        self._mutex1.release()\\n        self._mutex2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:        \\n        self._mutex2.acquire()\\n        printThird()\\n        self._mutex2.release()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        from threading import Lock\\n\\n        self._mutex1 = Lock()\\n        self._mutex2 = Lock()\\n        self._mutex1.acquire()\\n        self._mutex2.acquire()\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        printFirst()\\n        self._mutex1.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self._mutex1.acquire()\\n        printSecond()\\n        self._mutex1.release()\\n        self._mutex2.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:        \\n        self._mutex2.acquire()\\n        printThird()\\n        self._mutex2.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1405854,
                "title": "scalable-c-solution-without-mutexes-and-convars",
                "content": "Scalable c++ solution without mutexes and convars. We just wait untill n is equal 1,2,...\\n\\n```\\nclass Foo {\\npublic:\\n    std::atomic<std::size_t> n{0};\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        n.fetch_add(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(n.load() != 1) {\\n            std::this_thread::yield();\\n        }\\n        printSecond();\\n        n.fetch_add(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(n.load() != 2) {\\n            std::this_thread::yield();\\n        }\\n        printThird();\\n    }\\n};",
                "solutionTags": [],
                "code": "Scalable c++ solution without mutexes and convars. We just wait untill n is equal 1,2,...\\n\\n```\\nclass Foo {\\npublic:\\n    std::atomic<std::size_t> n{0};\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        n.fetch_add(1);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(n.load() != 1) {\\n            std::this_thread::yield();\\n        }\\n        printSecond();\\n        n.fetch_add(1);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(n.load() != 2) {\\n            std::this_thread::yield();\\n        }\\n        printThird();\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1335161,
                "title": "java-java-lang-concurrency-synchronized-without-active-waiting",
                "content": "```\\nclass Foo {\\n    private boolean isFirstDone = false;\\n    private boolean isSecondDone = false;\\n    \\n    private Object firstMonitor = new Object();\\n    private Object secondMonitor = new Object();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            isFirstDone = true;\\n            firstMonitor.notify();\\n            \\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            while (!isFirstDone) {\\n                firstMonitor.wait();\\n            }\\n        }\\n        \\n        synchronized (secondMonitor) {\\n            isSecondDone = true;\\n            secondMonitor.notify();\\n            \\n            printSecond.run();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (secondMonitor) {\\n            while (!isSecondDone) {\\n                secondMonitor.wait();\\n            }\\n        }\\n\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    private boolean isFirstDone = false;\\n    private boolean isSecondDone = false;\\n    \\n    private Object firstMonitor = new Object();\\n    private Object secondMonitor = new Object();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            isFirstDone = true;\\n            firstMonitor.notify();\\n            \\n            printFirst.run();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        synchronized (firstMonitor) {\\n            while (!isFirstDone) {\\n                firstMonitor.wait();\\n            }\\n        }\\n        \\n        synchronized (secondMonitor) {\\n            isSecondDone = true;\\n            secondMonitor.notify();\\n            \\n            printSecond.run();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        synchronized (secondMonitor) {\\n            while (!isSecondDone) {\\n                secondMonitor.wait();\\n            }\\n        }\\n\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314293,
                "title": "c-solution",
                "content": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    ManualResetEvent _second = new ManualResetEvent(false);\\n    ManualResetEvent _third = new ManualResetEvent(false);\\n    \\n    public Foo() {\\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _second.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _second.WaitOne();\\n        printSecond();\\n        _third.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _third.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading;\\n\\npublic class Foo {\\n    ManualResetEvent _second = new ManualResetEvent(false);\\n    ManualResetEvent _third = new ManualResetEvent(false);\\n    \\n    public Foo() {\\n    }\\n\\n    public void First(Action printFirst) {\\n        printFirst();\\n        _second.Set();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _second.WaitOne();\\n        printSecond();\\n        _third.Set();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _third.WaitOne();\\n        printThird();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100106,
                "title": "c-linux-semaphores",
                "content": "```\\n#include <semaphore.h>\\n \\nclass Foo {\\npublic:\\n    Foo() {\\n        sem_init(&_first_job_done, 0, 0);\\n        sem_init(&_second_job_done, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&_first_job_done);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&_first_job_done);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&_second_job_done);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&_second_job_done);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    sem_t _first_job_done{0};\\n    sem_t _second_job_done{0};\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <semaphore.h>\\n \\nclass Foo {\\npublic:\\n    Foo() {\\n        sem_init(&_first_job_done, 0, 0);\\n        sem_init(&_second_job_done, 0, 0);\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        sem_post(&_first_job_done);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        sem_wait(&_first_job_done);\\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        sem_post(&_second_job_done);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        sem_wait(&_second_job_done);\\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n\\nprivate:\\n    sem_t _first_job_done{0};\\n    sem_t _second_job_done{0};\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1078156,
                "title": "c-solution-with-condition-variable-and-mutex",
                "content": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    condition_variable produce2, produce3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    \\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<std::mutex> lck(mtx);\\n        printFirst();\\n        second_unlocked = true;\\n        produce2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce2.wait(lck, [this] {return second_unlocked;});\\n        printSecond();\\n        third_unlocked = true;\\n        produce3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce3.wait(lck, [this] {return third_unlocked;});\\n        printThird();\\n        lck.unlock();\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\nprivate:\\n    mutex mtx;\\n    condition_variable produce2, produce3;\\n    bool second_unlocked = false;\\n    bool third_unlocked = false;\\npublic:\\n    \\n    Foo() {\\n        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        unique_lock<std::mutex> lck(mtx);\\n        printFirst();\\n        second_unlocked = true;\\n        produce2.notify_one();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce2.wait(lck, [this] {return second_unlocked;});\\n        printSecond();\\n        third_unlocked = true;\\n        produce3.notify_one();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        unique_lock<std::mutex> lck(mtx);\\n        produce3.wait(lck, [this] {return third_unlocked;});\\n        printThird();\\n        lck.unlock();\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1066739,
                "title": "java-just-volatile",
                "content": "```\\nclass Foo {\\n    \\n    private volatile int i = 0;\\n\\n    public Foo() {   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        i = 1;\\n        Thread.yield();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(i!=1){\\n            Thread.yield();\\n        }\\n        printSecond.run();\\n        i = 2;\\n        Thread.yield();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(i!=2){\\n            Thread.yield();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private volatile int i = 0;\\n\\n    public Foo() {   \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        i = 1;\\n        Thread.yield();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(i!=1){\\n            Thread.yield();\\n        }\\n        printSecond.run();\\n        i = 2;\\n        Thread.yield();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(i!=2){\\n            Thread.yield();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1020495,
                "title": "java-leverage-countdownlatch",
                "content": "```java\\nclass Foo {\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n    private CountDownLatch latch3 = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch3.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    private CountDownLatch latch2 = new CountDownLatch(1);\\n    private CountDownLatch latch3 = new CountDownLatch(1);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latch2.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latch2.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latch3.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latch3.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009752,
                "title": "c-monitor-wait-pulseall",
                "content": "```\\nusing System.Threading; \\n\\npublic class Foo\\n    {\\n        class Lock\\n        {\\n           public int Step;\\n        }\\n\\n        static Lock _Lock = new Lock(){ Step = 0 };\\n\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            lock (_Lock)\\n            {\\n                // printFirst() outputs \"first\". Do not change or remove this line.\\n                printFirst();\\n                _Lock.Step = 1;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            lock (_Lock)\\n            {\\n                while (_Lock.Step!= 1)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printSecond() outputs \"second\". Do not change or remove this line.\\n                printSecond();\\n                _Lock.Step = 2;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            lock (_Lock)\\n            {\\n                while(_Lock.Step!=2)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printThird() outputs \"third\". Do not change or remove this line.                \\n                printThird();\\n                _Lock.Step = 3;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nusing System.Threading; \\n\\npublic class Foo\\n    {\\n        class Lock\\n        {\\n           public int Step;\\n        }\\n\\n        static Lock _Lock = new Lock(){ Step = 0 };\\n\\n        public Foo()\\n        {\\n\\n        }\\n\\n        public void First(Action printFirst)\\n        {\\n            lock (_Lock)\\n            {\\n                // printFirst() outputs \"first\". Do not change or remove this line.\\n                printFirst();\\n                _Lock.Step = 1;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Second(Action printSecond)\\n        {\\n            lock (_Lock)\\n            {\\n                while (_Lock.Step!= 1)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printSecond() outputs \"second\". Do not change or remove this line.\\n                printSecond();\\n                _Lock.Step = 2;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n\\n        public void Third(Action printThird)\\n        {\\n            lock (_Lock)\\n            {\\n                while(_Lock.Step!=2)\\n                {\\n                    Monitor.Wait(_Lock);\\n                }\\n                // printThird() outputs \"third\". Do not change or remove this line.                \\n                printThird();\\n                _Lock.Step = 3;\\n                Monitor.PulseAll(_Lock);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006405,
                "title": "faster-then-100-java-countdownlatch",
                "content": "```\\nclass Foo {\\n    \\n    private final CountDownLatch first;\\n    private final CountDownLatch second;\\n\\n    public Foo() {\\n        first = new CountDownLatch(1);\\n        second = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private final CountDownLatch first;\\n    private final CountDownLatch second;\\n\\n    public Foo() {\\n        first = new CountDownLatch(1);\\n        second = new CountDownLatch(1);\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        first.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        first.await();\\n        printSecond.run();\\n        second.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        second.await();\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968990,
                "title": "c-1-mutex-1-condition-variable-simple-solution",
                "content": "Just check if the counter is equal to itself, if not then release lock and wait.\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        now = 0;        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 0;\\n            });\\n            ++now;\\n            printFirst();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 1;\\n            });\\n            ++now;\\n            printSecond();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 2;\\n            });\\n            ++now;\\n            printThird();\\n        }\\n        cv.notify_all();\\n    }\\n    condition_variable cv;\\n    mutex mtx;\\n    int now;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        now = 0;        \\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 0;\\n            });\\n            ++now;\\n            printFirst();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 1;\\n            });\\n            ++now;\\n            printSecond();\\n        }\\n        cv.notify_all();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        {\\n            unique_lock<mutex> lock(mtx);\\n            cv.wait(lock, [this](){\\n                return now == 2;\\n            });\\n            ++now;\\n            printThird();\\n        }\\n        cv.notify_all();\\n    }\\n    condition_variable cv;\\n    mutex mtx;\\n    int now;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960489,
                "title": "c-using-semaphore",
                "content": "```\\n\\n    private static Semaphore _First = new Semaphore(0,1);\\n    private static Semaphore _Second = new Semaphore(0,1);\\n    \\n    public void First(Action printFirst) {\\n        printFirst();\\n        _First.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _First.WaitOne();\\n        printSecond();\\n        _Second.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _Second.WaitOne();\\n        printThird();\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\n    private static Semaphore _First = new Semaphore(0,1);\\n    private static Semaphore _Second = new Semaphore(0,1);\\n    \\n    public void First(Action printFirst) {\\n        printFirst();\\n        _First.Release();\\n    }\\n\\n    public void Second(Action printSecond) {\\n        _First.WaitOne();\\n        printSecond();\\n        _Second.Release();\\n    }\\n\\n    public void Third(Action printThird) {\\n        _Second.WaitOne();\\n        printThird();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 943530,
                "title": "simple-and-does-the-work-for-beginners",
                "content": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.call = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.   \\n        printFirst()\\n        self.call = 1\\n        \\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.call != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.call = 2\\n            \\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.call != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Foo:\\n    def __init__(self):\\n        self.call = 0\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        # printFirst() outputs \"first\". Do not change or remove this line.   \\n        printFirst()\\n        self.call = 1\\n        \\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.call != 1:\\n            continue\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.call = 2\\n            \\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.call != 2:\\n            continue\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 899019,
                "title": "java-3-semaphore-solution",
                "content": "```java\\nclass Foo {\\n    \\n    private Semaphore s1 = new Semaphore(1);\\n    private Semaphore s2 = new Semaphore(0);\\n    private Semaphore s3 = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        s1.acquire();\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        s3.acquire();\\n        printThird.run();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "```java\\nclass Foo {\\n    \\n    private Semaphore s1 = new Semaphore(1);\\n    private Semaphore s2 = new Semaphore(0);\\n    private Semaphore s3 = new Semaphore(0);\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        s1.acquire();\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        s2.acquire();\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        s3.acquire();\\n        printThird.run();\\n        \\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 808148,
                "title": "java-solution-using-atomic-integer",
                "content": "```\\nclass Foo {\\n\\n    private AtomicInteger firstJobDone = new AtomicInteger(0);\\n    private AtomicInteger secondJobDone = new AtomicInteger(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstJobDone.incrementAndGet();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(firstJobDone.get()!=1){}\\n        printSecond.run();\\n        secondJobDone.incrementAndGet();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(secondJobDone.get() != 1){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private AtomicInteger firstJobDone = new AtomicInteger(0);\\n    private AtomicInteger secondJobDone = new AtomicInteger(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstJobDone.incrementAndGet();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        while(firstJobDone.get()!=1){}\\n        printSecond.run();\\n        secondJobDone.incrementAndGet();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(secondJobDone.get() != 1){}\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798189,
                "title": "python3-fastest-and-simplest-solution",
                "content": "```\\nclass Foo:\\n    def __init__(self):\\n        self.firstlock = threading.Lock()\\n        self.secondlock = threading.Lock()\\n        self.thirdlock = threading.Lock()\\n        \\n        self.firstlock.acquire()\\n        self.secondlock.acquire()\\n        self.thirdlock.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.firstlock.release()\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.secondlock.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.secondlock.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.thirdlock.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.thirdlock.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.thirdlock.release()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo:\\n    def __init__(self):\\n        self.firstlock = threading.Lock()\\n        self.secondlock = threading.Lock()\\n        self.thirdlock = threading.Lock()\\n        \\n        self.firstlock.acquire()\\n        self.secondlock.acquire()\\n        self.thirdlock.acquire()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        self.firstlock.release()\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.secondlock.release()\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        self.secondlock.acquire()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.thirdlock.release()\\n\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        self.thirdlock.acquire()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n        self.thirdlock.release()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744073,
                "title": "py-soln-using-sleep-simple-and-fast",
                "content": "This simple solution was faster than 95.4% solutiions (32ms runtime)\\n```\\n\\n\\nclass Foo:\\n#flag variables \\n    calledFirst = 0\\n    calledSecond = 0\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        #print and set flag\\n        printFirst()\\n        self.calledFirst = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t#wait for 0.01s and then check for the condition again \\n        while(not self.calledFirst):\\n            time.sleep(0.01)\\n        printSecond()\\n\\t\\t#flag for second function\\n        self.calledSecond = 1\\n      \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n       \\n        while(not self.calledSecond):        \\n            time.sleep(0.01)\\n        printThird()\\n        \\n      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n\\nclass Foo:\\n#flag variables \\n    calledFirst = 0\\n    calledSecond = 0\\n    def __init__(self):\\n        pass\\n\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        #print and set flag\\n        printFirst()\\n        self.calledFirst = 1\\n\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n\\t#wait for 0.01s and then check for the condition again \\n        while(not self.calledFirst):\\n            time.sleep(0.01)\\n        printSecond()\\n\\t\\t#flag for second function\\n        self.calledSecond = 1\\n      \\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n       \\n        while(not self.calledSecond):        \\n            time.sleep(0.01)\\n        printThird()\\n        \\n      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 671719,
                "title": "java-locks-conditional",
                "content": "```\\nclass Foo {\\n    \\n    private int currentThreadNum = 1;\\n    private ReentrantLock locker = new ReentrantLock();\\n    private Condition condition = locker.newCondition();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            printFirst.run();\\n            currentThreadNum = 2;\\n            condition.signalAll();\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 2) {\\n                condition.await();\\n            }\\n            printSecond.run();\\n            currentThreadNum = 3;\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 3) {\\n                condition.await();\\n            }\\n            printThird.run();\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private int currentThreadNum = 1;\\n    private ReentrantLock locker = new ReentrantLock();\\n    private Condition condition = locker.newCondition();\\n\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            printFirst.run();\\n            currentThreadNum = 2;\\n            condition.signalAll();\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 2) {\\n                condition.await();\\n            }\\n            printSecond.run();\\n            currentThreadNum = 3;\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        locker.lock();\\n        try {\\n            while(currentThreadNum < 3) {\\n                condition.await();\\n            }\\n            printThird.run();\\n            condition.signalAll();\\n        } catch (InterruptedException e){\\n          System.out.println(e.getMessage());\\n        }\\n        finally{\\n          locker.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632100,
                "title": "java-with-countdown-latch",
                "content": "```\\nclass Foo {\\n\\n    private CountDownLatch firstFinished = new CountDownLatch(1);\\n    private CountDownLatch secondFinished = new CountDownLatch(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstFinished.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstFinished.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        secondFinished.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondFinished.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private CountDownLatch firstFinished = new CountDownLatch(1);\\n    private CountDownLatch secondFinished = new CountDownLatch(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        firstFinished.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        firstFinished.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        secondFinished.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        secondFinished.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601183,
                "title": "volatile-counter-java",
                "content": "```\\nclass Foo {\\n    volatile int count ;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        count++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(count!=1) {}\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        count++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(count!=2) {}\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    volatile int count ;\\n    public Foo() {\\n        count = 0;\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        count++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(count!=1) {}\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        count++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(count!=2) {}\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598546,
                "title": "java-lock-condition",
                "content": "```\\nclass Foo {\\n\\n    private final Lock lock;\\n    private final Condition c2;\\n    private final Condition c3;\\n    private boolean printed1 = false;\\n    private boolean printed2 = false;\\n\\n    public Foo() {\\n        lock = new ReentrantLock();\\n        c2 = lock.newCondition();\\n        c3 = lock.newCondition();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            printed1 = true;\\n            c2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed1) {\\n                c2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            printed2 = true;\\n            c3.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed2) {\\n                c3.await();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private final Lock lock;\\n    private final Condition c2;\\n    private final Condition c3;\\n    private boolean printed1 = false;\\n    private boolean printed2 = false;\\n\\n    public Foo() {\\n        lock = new ReentrantLock();\\n        c2 = lock.newCondition();\\n        c3 = lock.newCondition();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            // printFirst.run() outputs \"first\". Do not change or remove this line.\\n            printFirst.run();\\n            printed1 = true;\\n            c2.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed1) {\\n                c2.await();\\n            }\\n            // printSecond.run() outputs \"second\". Do not change or remove this line.\\n            printSecond.run();\\n            printed2 = true;\\n            c3.signal();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        lock.lock();\\n        try {\\n            while (!printed2) {\\n                c3.await();\\n            }\\n            // printThird.run() outputs \"third\". Do not change or remove this line.\\n            printThird.run();\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561105,
                "title": "java-most-efficient",
                "content": "```\\nclass Foo {\\n\\n    private int x = 0;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        x = x + 1;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while (x < 1) {\\n            wait();\\n        }\\n        printSecond.run();\\n        x = x + 1;                \\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while (x < 2) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    private int x = 0;\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    synchronized public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        x = x + 1;\\n        notifyAll();\\n    }\\n\\n    synchronized public void second(Runnable printSecond) throws InterruptedException {\\n        while (x < 1) {\\n            wait();\\n        }\\n        printSecond.run();\\n        x = x + 1;                \\n        notifyAll();\\n    }\\n\\n    synchronized public void third(Runnable printThird) throws InterruptedException {\\n        while (x < 2) {\\n            wait();\\n        }\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499799,
                "title": "python-solution-with-driver-code",
                "content": "Here\\'s the solution with driver code, so you can run it on your own machine.\\n```\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.second_lock = threading.Lock()\\n        self.second_lock.acquire()\\n        self.third_lock = threading.Lock()\\n        self.third_lock.acquire()\\n\\n    def first(self):\\n\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        print(\\'first\\')\\n        self.second_lock.release()\\n\\n    def second(self):\\n\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.second_lock:\\n            print(\\'second_lock\\')\\n            self.third_lock.release()\\n\\n    def third(self):\\n\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.third_lock:\\n            print(\\'third_lock\\')\\n\\na = Foo()\\nt1 = threading.Thread(target=a.third)\\nt2 = threading.Thread(target=a.second)\\nt3 = threading.Thread(target=a.first)\\n\\nt1.start()\\nt2.start()\\nt3.start()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport threading\\n\\nclass Foo:\\n    def __init__(self):\\n        self.second_lock = threading.Lock()\\n        self.second_lock.acquire()\\n        self.third_lock = threading.Lock()\\n        self.third_lock.acquire()\\n\\n    def first(self):\\n\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        print(\\'first\\')\\n        self.second_lock.release()\\n\\n    def second(self):\\n\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        with self.second_lock:\\n            print(\\'second_lock\\')\\n            self.third_lock.release()\\n\\n    def third(self):\\n\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        with self.third_lock:\\n            print(\\'third_lock\\')\\n\\na = Foo()\\nt1 = threading.Thread(target=a.third)\\nt2 = threading.Thread(target=a.second)\\nt3 = threading.Thread(target=a.first)\\n\\nt1.start()\\nt2.start()\\nt3.start()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493520,
                "title": "non-blocking-solution-9ms",
                "content": "```\\nclass Foo {\\n    private volatile boolean firstCompleted;\\n    private volatile boolean secondCompleted;\\n\\t\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n      printFirst.run();\\n      firstCompleted = true;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n      while (!firstCompleted) {\\n        \\n      }\\n      printSecond.run();\\n      secondCompleted = true;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n      while (!secondCompleted) {\\n\\n      }\\n      printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Foo {\\n    private volatile boolean firstCompleted;\\n    private volatile boolean secondCompleted;\\n\\t\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n      printFirst.run();\\n      firstCompleted = true;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n      while (!firstCompleted) {\\n        \\n      }\\n      printSecond.run();\\n      secondCompleted = true;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n      while (!secondCompleted) {\\n\\n      }\\n      printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474102,
                "title": "simple-java-solution-using-wait-and-notify",
                "content": "```\\nclass Foo {\\n    \\n\\n    int count = 1;\\n    public Foo() {   \\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            printFirst.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        synchronized(this){\\n            while(count != 2){\\n                this.wait();\\n            }\\n            printSecond.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n\\n        synchronized(this){\\n            while(count != 3){\\n                this.wait();\\n            }\\n            printThird.run();\\n        }\\n   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n\\n    int count = 1;\\n    public Foo() {   \\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        synchronized(this){\\n            printFirst.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        \\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        synchronized(this){\\n            while(count != 2){\\n                this.wait();\\n            }\\n            printSecond.run();\\n            count++;\\n            this.notifyAll();\\n        }\\n        \\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        \\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n\\n        synchronized(this){\\n            while(count != 3){\\n                this.wait();\\n            }\\n            printThird.run();\\n        }\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472228,
                "title": "c-same-pattern-for-all-3-functions-using-condition-variable",
                "content": "Extracted a run_step function that can be called by all three original functions. This can be easily extended to more steps.\\n\\n\\n```\\nclass Foo {\\npublic:\\n    Foo() {\\n        cur_step = 0;\\n    }\\n    \\n    void run_step(int step, function<void()> func) {\\n        std::unique_lock<std::mutex> lk(mtx);\\n        cv.wait(lk, [&]{return cur_step == step;}); // keep waiting until cur_step == step.\\n        func();\\n        cur_step++; // safely increasing cur_step.\\n        cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        run_step(0, printFirst);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        run_step(1, printSecond);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        run_step(2, printThird);\\n    }\\n\\nprivate:\\n    std::condition_variable cv;\\n    std::mutex mtx;\\n    volatile int cur_step;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        cur_step = 0;\\n    }\\n    \\n    void run_step(int step, function<void()> func) {\\n        std::unique_lock<std::mutex> lk(mtx);\\n        cv.wait(lk, [&]{return cur_step == step;}); // keep waiting until cur_step == step.\\n        func();\\n        cur_step++; // safely increasing cur_step.\\n        cv.notify_all();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        \\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        run_step(0, printFirst);\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        run_step(1, printSecond);\\n    }\\n\\n    void third(function<void()> printThird) {\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        run_step(2, printThird);\\n    }\\n\\nprivate:\\n    std::condition_variable cv;\\n    std::mutex mtx;\\n    volatile int cur_step;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 467281,
                "title": "python-condition-readable-code",
                "content": "```\\nfrom threading import Condition\\nclass FooBar:\\n    def __init__(self, n):\\n        self.n = n\\n        self.condition = Condition()\\n        self.order = 1\\n        self.output_foo = lambda: self.order == 1\\n        self.output_bar = lambda: self.order == 2\\n\\n\\n    def foo(self, printFoo: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_foo)\\n                # printFoo() outputs \"foo\". Do not change or remove this line.\\n                printFoo()\\n                self.order += 1\\n                self.condition.notify()\\n\\n\\n    def bar(self, printBar: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_bar)\\n                # printBar() outputs \"bar\". Do not change or remove this line.\\n                printBar()\\n                self.order -= 1\\n                self.condition.notify()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom threading import Condition\\nclass FooBar:\\n    def __init__(self, n):\\n        self.n = n\\n        self.condition = Condition()\\n        self.order = 1\\n        self.output_foo = lambda: self.order == 1\\n        self.output_bar = lambda: self.order == 2\\n\\n\\n    def foo(self, printFoo: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_foo)\\n                # printFoo() outputs \"foo\". Do not change or remove this line.\\n                printFoo()\\n                self.order += 1\\n                self.condition.notify()\\n\\n\\n    def bar(self, printBar: \\'Callable[[], None]\\') -> None:\\n        \\n        for i in range(self.n):\\n            with self.condition:\\n                self.condition.wait_for(self.output_bar)\\n                # printBar() outputs \"bar\". Do not change or remove this line.\\n                printBar()\\n                self.order -= 1\\n                self.condition.notify()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 459232,
                "title": "java-simple-version-with-two-semaphores",
                "content": "```\\nclass Foo {\\n    \\n    private Semaphore firstSem;\\n    \\n    private Semaphore secondSem;\\n\\n    public Foo() {\\n        this.firstSem = new Semaphore(0);\\n        this.secondSem = new Semaphore(0); \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.firstSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        this.firstSem.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.secondSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        this.secondSem.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n    \\n    private Semaphore firstSem;\\n    \\n    private Semaphore secondSem;\\n\\n    public Foo() {\\n        this.firstSem = new Semaphore(0);\\n        this.secondSem = new Semaphore(0); \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        this.firstSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        this.firstSem.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        this.secondSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        this.secondSem.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457292,
                "title": "python-without-mutex-and-semaphore-only-1-counter",
                "content": "All threads are independent! We can create counter, which will show actual threads. It\\'s safe, therefore all threads modified counter only after printing + GIL makes operaion += atomary.\\n\\n```\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        self.counter = 0\\n\\n\\t# first thread will be called automaticly, without any conditions\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        \\n\\t\\t# open way for second thread\\n        self.counter += 1\\n\\n\\n\\t# second thread firstly wait finishing of 1st thread, and after printing text it can incriment counter for 3rd thread\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 1:\\n            sleep(0.01)\\n            \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        \\n        self.counter += 1\\n\\n\\n\\t# 3rd thread wait finish of 2nd, and doesn\\'t incerement counter, therefore it\\'s redundent.\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 2:\\n            sleep(0.01)\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nfrom time import sleep\\n\\nclass Foo:\\n    def __init__(self):\\n        self.counter = 0\\n\\n\\t# first thread will be called automaticly, without any conditions\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None:\\n        \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        \\n\\t\\t# open way for second thread\\n        self.counter += 1\\n\\n\\n\\t# second thread firstly wait finishing of 1st thread, and after printing text it can incriment counter for 3rd thread\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 1:\\n            sleep(0.01)\\n            \\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        \\n        self.counter += 1\\n\\n\\n\\t# 3rd thread wait finish of 2nd, and doesn\\'t incerement counter, therefore it\\'s redundent.\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:\\n        while self.counter < 2:\\n            sleep(0.01)\\n        \\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452975,
                "title": "simple-python-with-two-events",
                "content": "```\\nimport threading\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.second_cv = threading.Event() \\n        self.third_cv = threading.Event()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.second_cv.set()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.second_cv.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.third_cv.set()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.third_cv.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\n\\nclass Foo(object):\\n    def __init__(self):\\n        self.second_cv = threading.Event() \\n        self.third_cv = threading.Event()\\n\\n\\n    def first(self, printFirst):\\n        \"\"\"\\n        :type printFirst: method\\n        :rtype: void\\n        \"\"\"\\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.second_cv.set()\\n\\n\\n    def second(self, printSecond):\\n        \"\"\"\\n        :type printSecond: method\\n        :rtype: void\\n        \"\"\"\\n        self.second_cv.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.third_cv.set()\\n            \\n            \\n    def third(self, printThird):\\n        \"\"\"\\n        :type printThird: method\\n        :rtype: void\\n        \"\"\"\\n        self.third_cv.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452783,
                "title": "2-c-solution-lock-2-mutex-lock-free-sched-yield",
                "content": "***Lock version - 2 mutex lock***\\nmtx1 is the lock indicating **first()** should be exec before **second()**.\\nmtx2 is the lock indicating **second()** should be exec before **third()**.\\n\\nUse **sched_yield()** to release the processor, when **second()** and **third()** does not have the lock.\\n**usleep(0)** would have the same effect, but it would be a little bit slower than **sched_yield()**.\\n```\\nclass Foo {\\n    mutex mtx1, mtx2;\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        mtx1.lock();\\n\\t\\t\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n        mtx1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        mtx2.lock();\\n        \\n        // try until runSecond set to true\\n        mtx1.lock();\\n        while (!runSecond) {\\n            mtx1.unlock();\\n            sched_yield();\\n            mtx1.lock();\\n        }\\n        mtx1.unlock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n        mtx2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        mtx2.lock();\\n        while (!runThird) {\\n            mtx2.unlock();\\n            sched_yield();\\n            mtx2.lock();\\n        }\\n        mtx2.unlock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\\n\\n***Lock-free version***\\nWithout using lock, I thought it would be faster than previous version at first, but it seems not.\\nI\\'m still wondering why...\\n```\\nclass Foo {\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // try until runSecond set to true\\n        while (!runSecond) {\\n            sched_yield();\\n        }\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        while (!runThird) {\\n            sched_yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Foo {\\n    mutex mtx1, mtx2;\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        mtx1.lock();\\n\\t\\t\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n        mtx1.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        mtx2.lock();\\n        \\n        // try until runSecond set to true\\n        mtx1.lock();\\n        while (!runSecond) {\\n            mtx1.unlock();\\n            sched_yield();\\n            mtx1.lock();\\n        }\\n        mtx1.unlock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n        mtx2.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        mtx2.lock();\\n        while (!runThird) {\\n            mtx2.unlock();\\n            sched_yield();\\n            mtx2.lock();\\n        }\\n        mtx2.unlock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```\n```\\nclass Foo {\\n    bool runSecond, runThird;\\npublic:\\n    Foo() {\\n        runSecond = runThird = false;\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n\\t\\t\\n        runSecond = true;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // try until runSecond set to true\\n        while (!runSecond) {\\n            sched_yield();\\n        }\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n\\t\\t\\n        runThird = true;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        // try until runThird set to true\\n        while (!runThird) {\\n            sched_yield();\\n        }\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432171,
                "title": "c-super-simple-solution-with-only-mutex",
                "content": "```\\n#include <mutex>\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        this->mtx_second.lock();\\n        this->mtx_third.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        this->mtx_second.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // std::cout << \"first: waiting...\" << std::endl;\\n        \\n        this->mtx_second.lock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        this->mtx_second.unlock();\\n        this->mtx_third.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        this->mtx_third.lock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        this->mtx_third.unlock();\\n    }\\n    \\nprivate:\\n    std::mutex mtx_second;\\n    std::mutex mtx_third;\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <mutex>\\n\\nclass Foo {\\npublic:\\n    Foo() {\\n        this->mtx_second.lock();\\n        this->mtx_third.lock();\\n    }\\n\\n    void first(function<void()> printFirst) {\\n        // printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst();\\n        \\n        this->mtx_second.unlock();\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        // std::cout << \"first: waiting...\" << std::endl;\\n        \\n        this->mtx_second.lock();\\n        \\n        // printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond();\\n        \\n        this->mtx_second.unlock();\\n        this->mtx_third.unlock();\\n    }\\n\\n    void third(function<void()> printThird) {\\n        this->mtx_third.lock();\\n        \\n        // printThird() outputs \"third\". Do not change or remove this line.\\n        printThird();\\n        \\n        this->mtx_third.unlock();\\n    }\\n    \\nprivate:\\n    std::mutex mtx_second;\\n    std::mutex mtx_third;\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 431477,
                "title": "java-using-semaphores-runtime-10-ms-memory-usage-35-6-mb",
                "content": "class Foo {\\n    \\n    private final Semaphore bSem = new Semaphore(1);\\n    private final Semaphore cSem = new Semaphore(1);\\n\\n    public Foo() {\\n        bSem.drainPermits();\\n        cSem.drainPermits();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        bSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        bSem.acquire();\\n        printSecond.run();\\n        cSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        cSem.acquire();\\n        printThird.run();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Foo {\\n    \\n    private final Semaphore bSem = new Semaphore(1);\\n    private final Semaphore cSem = new Semaphore(1);\\n\\n    public Foo() {\\n        bSem.drainPermits();\\n        cSem.drainPermits();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        printFirst.run();\\n        bSem.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        bSem.acquire();\\n        printSecond.run();\\n        cSem.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        cSem.acquire();\\n        printThird.run();\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 413239,
                "title": "python-threading-event-implementation",
                "content": "```\\nimport threading\\nclass Foo:\\n    def __init__(self):\\n        self.ev1 = threading.Event()\\n        self.ev2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None: \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.ev1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:      \\n        self.ev1.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.ev2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:      \\n        self.ev2.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "solutionTags": [],
                "code": "```\\nimport threading\\nclass Foo:\\n    def __init__(self):\\n        self.ev1 = threading.Event()\\n        self.ev2 = threading.Event()\\n\\n    def first(self, printFirst: \\'Callable[[], None]\\') -> None: \\n        # printFirst() outputs \"first\". Do not change or remove this line.\\n        printFirst()\\n        self.ev1.set()\\n\\n    def second(self, printSecond: \\'Callable[[], None]\\') -> None:      \\n        self.ev1.wait()\\n        # printSecond() outputs \"second\". Do not change or remove this line.\\n        printSecond()\\n        self.ev2.set()\\n\\n    def third(self, printThird: \\'Callable[[], None]\\') -> None:      \\n        self.ev2.wait()\\n        # printThird() outputs \"third\". Do not change or remove this line.\\n        printThird()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404181,
                "title": "java-very-simple-and-straight-solution-based-on-semaphore",
                "content": "```\\nclass Foo {\\n\\n    Semaphore s1= new Semaphore(1);\\n    Semaphore s2= new Semaphore(0);\\n    Semaphore s3= new Semaphore(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        s1.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\n\\n    Semaphore s1= new Semaphore(1);\\n    Semaphore s2= new Semaphore(0);\\n    Semaphore s3= new Semaphore(0);\\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        s1.acquire();\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        s2.release();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        s2.acquire();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        s3.release();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        s3.acquire();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393279,
                "title": "without-lock-related-function-simple-c-solution",
                "content": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        a[0] = a[1] = 0;\\n    }\\n    \\n    int a[2];\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a[0] = 1;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(a[0] == 0);\\n        printSecond();\\n        a[1] = 1;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(a[1] == 0);\\n        printThird();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Foo {\\npublic:\\n    Foo() {\\n        a[0] = a[1] = 0;\\n    }\\n    \\n    int a[2];\\n\\n    void first(function<void()> printFirst) {\\n        printFirst();\\n        a[0] = 1;\\n    }\\n\\n    void second(function<void()> printSecond) {\\n        while(a[0] == 0);\\n        printSecond();\\n        a[1] = 1;\\n    }\\n\\n    void third(function<void()> printThird) {\\n        while(a[1] == 0);\\n        printThird();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378965,
                "title": "java-solution-using-blockingqueue",
                "content": "- Second always runs after first because blockingQueue1.take() waits for blockingQueue1.add(\"done\");\\n- Third always runs after second using the same machenism with blockingQueue2.\\n\\n\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.LinkedBlockingDeque;\\nclass Foo {\\n\\n    BlockingQueue<String> blockingQueue1 = new LinkedBlockingDeque<>(1);\\n    BlockingQueue<String> blockingQueue2 = new LinkedBlockingDeque<>(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        \\n        printFirst.run();\\n        blockingQueue1.add(\"done\");\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        String done = blockingQueue1.take();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        blockingQueue2.add(\"done\");\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        String done = blockingQueue2.take();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "- Second always runs after first because blockingQueue1.take() waits for blockingQueue1.add(\"done\");\\n- Third always runs after second using the same machenism with blockingQueue2.\\n\\n\\nimport java.util.concurrent.BlockingQueue;\\nimport java.util.concurrent.LinkedBlockingDeque;\\nclass Foo {\\n\\n    BlockingQueue<String> blockingQueue1 = new LinkedBlockingDeque<>(1);\\n    BlockingQueue<String> blockingQueue2 = new LinkedBlockingDeque<>(1);\\n    \\n    public Foo() {\\n        \\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        \\n        printFirst.run();\\n        blockingQueue1.add(\"done\");\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        String done = blockingQueue1.take();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        blockingQueue2.add(\"done\");\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        String done = blockingQueue2.take();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        \\n    }\\n}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565694,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565769,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568225,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566312,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569719,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568188,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1703405,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569562,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1806869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565694,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1565769,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568225,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566312,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1566869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569719,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1568188,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1703405,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1569562,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            },
            {
                "id": 1806869,
                "content": [
                    {
                        "username": "PS123",
                        "content": "I am little curious about the number of TCs(36/38).\\nFrom what we can see there can only be 6 possible combinations in which 3 threads are scheduled. So I was hoping there will be only 6 TCs.\\nBut When my solution passed there were 36 test cases it ran.\\nI was wondering if they are testing all the possible scenarios , e.g idle system, heavy workload  etc. OR they are simulating it ?\\n**In general, I wanted to know how test cases for \\'Concurrency\\' type problems are created**. It would be great to have a discussion on that. since this is the beginning of this type."
                    },
                    {
                        "username": "nimeral",
                        "content": "I think they might simply put some sleeps into threads (e.g. the thread that is supposed to print \"first\" sleeps for a few seconds before printing it). This is a way to make sure (well, almost) that the program makes an incorrect output in case the solution is not correct. I got this idea from this solution (solution spoiler alert!) https://leetcode.com/problems/print-in-order/solutions/1329943/c-posix-synchronization-primitives-approach/"
                    },
                    {
                        "username": "vkasci",
                        "content": "Please add support of Swift and Objective-C"
                    },
                    {
                        "username": "ayumilee",
                        "content": "Could we support golang for concurrency problems?"
                    },
                    {
                        "username": "liuzuocai",
                        "content": "waitgroup can be used for this kind of basic tasks."
                    },
                    {
                        "username": "qzhang1",
                        "content": "The thread functions first(), second() and third() are not given or defined in the Python cases, making it impossible to work with the problem. When I was browsing through the problem three days before, I noticed that the thread functions were defined as printFirst(), printSecond(), etc. Now these aren\\'t defined either. Is the submission mechanism broken, or is it because I haven\\'t found the right way to invoke these functions?"
                    },
                    {
                        "username": "junk618",
                        "content": "Example 2:\\n\\nInput: [1,3,2]\\nOutput: \"firstsecondthird\"\\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
                    },
                    {
                        "username": "leefyi",
                        "content": "I resolve this topic locally and I know the logic. But I can not submit the solution, only \"Run Code\" button, no \"Submit\" button. By the way, my account is on(I have already logged in).  I tried for 3~4 times by closing and opening brower again and again.\\n\\nCould anyone help me?"
                    },
                    {
                        "username": "MinnDev",
                        "content": "Please add support for Rust."
                    },
                    {
                        "username": "jysui",
                        "content": "Seems the there is no \"submit solution\" button in old version UI?"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "CountDown Latch not working ? \\n ```java\\nclass Foo {\\n    private CountDownLatch latchAfterFirst ;\\n    private CountDownLatch latchAfterSecond;\\n    public Foo() {\\n        latchAfterFirst = new CountDownLatch();\\n        latchAfterSecond = new CountDownLatch();\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        \\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        latchAfterFirst.countDown();\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        latchAfterFirst.await();\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        latchAfterSecond.countDown();\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        latchAfterSecond.await();\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "jarius327",
                        "content": "This Is similar to my solution. You have to put a 1 in both the first and second CountDownLatch(1); as that is the number of times it calls the countDown() method until it reaches 0."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Cost to Connect Two Groups of Points",
        "question_content": "<p>You are given two groups of points where the first group has <code>size<sub>1</sub></code> points, the second group has <code>size<sub>2</sub></code> points, and <code>size<sub>1</sub> &gt;= size<sub>2</sub></code>.</p>\n\n<p>The <code>cost</code> of the connection between any two points are given in an <code>size<sub>1</sub> x size<sub>2</sub></code> matrix where <code>cost[i][j]</code> is the cost of connecting point <code>i</code> of the first group and point <code>j</code> of the second group. The groups are connected if <strong>each point in both groups is connected to one or more points in the opposite group</strong>. In other words, each point in the first group must be connected to at least one point in the second group, and each point in the second group must be connected to at least one point in the first group.</p>\n\n<p>Return <em>the minimum cost it takes to connect the two groups</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/ex1.jpg\" style=\"width: 322px; height: 243px;\" />\n<pre>\n<strong>Input:</strong> cost = [[15, 96], [36, 2]]\n<strong>Output:</strong> 17\n<strong>Explanation</strong>: The optimal way of connecting the groups is:\n1--A\n2--B\nThis results in a total cost of 17.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/09/03/ex2.jpg\" style=\"width: 322px; height: 403px;\" />\n<pre>\n<strong>Input:</strong> cost = [[1, 3, 5], [4, 1, 1], [1, 5, 3]]\n<strong>Output:</strong> 4\n<strong>Explanation</strong>: The optimal way of connecting the groups is:\n1--A\n2--B\n2--C\n3--A\nThis results in a total cost of 4.\nNote that there are multiple points connected to point 2 in the first group and point A in the second group. This does not matter as there is no limit to the number of points that can be connected. We only care about the minimum total cost.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\n<strong>Output:</strong> 10\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>size<sub>1</sub> == cost.length</code></li>\n\t<li><code>size<sub>2</sub> == cost[i].length</code></li>\n\t<li><code>1 &lt;= size<sub>1</sub>, size<sub>2</sub> &lt;= 12</code></li>\n\t<li><code>size<sub>1</sub> &gt;= size<sub>2</sub></code></li>\n\t<li><code>0 &lt;= cost[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 855041,
                "title": "c-python-dp-using-mask",
                "content": "#### Intuition\\nAs usual, it pays to analyze problem constraints. Since we only have up to 12 points, we can track which ones are connected using a bit mask.\\n\\n#### Solution\\nStaightforward top-down DP for the first group. At the same time, we track which elements from the second group were connected in `mask`.\\n\\nAfter finishing with the first group, we detect elements in group 2 that are still disconnected, and connect them with the \"cheapest\" node in the first group.\\n\\n**Python**\\n```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n    sz1, sz2 = len(cost), len(cost[0])\\n    min_sz2 = [min([cost[i][j] for i in range(sz1)]) for j in range(sz2)]\\n    @lru_cache(None)\\n    def dfs(i: int, mask: int):\\n        res = 0 if i >= sz1 else float(\\'inf\\')\\n        if i >= sz1:\\n            for j in range(sz2):\\n                if mask & (1 << j) == 0:\\n                    res += min_sz2[j]\\n        else:\\n            for j in range(sz2):\\n                res = min(res, cost[i][j] + dfs(i + 1, mask | (1 << j)))\\n        return res\\n    return dfs(0, 0)\\n```\\n**C++**\\n```cpp\\nint dp[13][4096] = {};\\nint dfs(vector<vector<int>>& cost, vector<int> &min_sz2, int i, int mask) {\\n    if (dp[i][mask])\\n        return dp[i][mask] - 1;    \\n    int res = i >= cost.size() ? 0 : INT_MAX;\\n    if (i >= cost.size())\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res += min_sz2[j] * ((mask & (1 << j)) == 0);\\n    else\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res = min(res, cost[i][j] + dfs(cost, min_sz2, i + 1, mask | (1 << j)));\\n    dp[i][mask] = res + 1;\\n    return res;\\n}\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n    vector<int> min_sz2(cost[0].size(), INT_MAX);\\n    for (int j = 0; j < min_sz2.size(); ++j)\\n        for (int i = 0; i < cost.size(); ++i)\\n            min_sz2[j] = min(min_sz2[j], cost[i][j]);\\n    return dfs(cost, min_sz2, 0, 0);\\n}\\n```\\n**Complexity Analysis**\\n- Time:  O((n * 2 ^ m) * m) - it takes `m` to compute one state.\\n- Memory: O(n * 2 ^ m) states to compute",
                "solutionTags": [],
                "code": "```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n    sz1, sz2 = len(cost), len(cost[0])\\n    min_sz2 = [min([cost[i][j] for i in range(sz1)]) for j in range(sz2)]\\n    @lru_cache(None)\\n    def dfs(i: int, mask: int):\\n        res = 0 if i >= sz1 else float(\\'inf\\')\\n        if i >= sz1:\\n            for j in range(sz2):\\n                if mask & (1 << j) == 0:\\n                    res += min_sz2[j]\\n        else:\\n            for j in range(sz2):\\n                res = min(res, cost[i][j] + dfs(i + 1, mask | (1 << j)))\\n        return res\\n    return dfs(0, 0)\\n```\n```cpp\\nint dp[13][4096] = {};\\nint dfs(vector<vector<int>>& cost, vector<int> &min_sz2, int i, int mask) {\\n    if (dp[i][mask])\\n        return dp[i][mask] - 1;    \\n    int res = i >= cost.size() ? 0 : INT_MAX;\\n    if (i >= cost.size())\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res += min_sz2[j] * ((mask & (1 << j)) == 0);\\n    else\\n        for (auto j = 0; j < cost[0].size(); ++j)\\n            res = min(res, cost[i][j] + dfs(cost, min_sz2, i + 1, mask | (1 << j)));\\n    dp[i][mask] = res + 1;\\n    return res;\\n}\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n    vector<int> min_sz2(cost[0].size(), INT_MAX);\\n    for (int j = 0; j < min_sz2.size(); ++j)\\n        for (int i = 0; i < cost.size(); ++i)\\n            min_sz2[j] = min(min_sz2[j], cost[i][j]);\\n    return dfs(cost, min_sz2, 0, 0);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855686,
                "title": "c-4ms-beats-100-bipartite-graph-maximum-weight-matching",
                "content": "I just found most people solve this problem via bit mask DP, which runs in *expoential* time. Here, I give a *polynomial* time solution.\\n\\n**Explanation**:\\nThis problem is called *minimum-cost edge cover* for bipartite graph. We show how to reduce this to a matching problem.\\nWe note that some edge will cover both of endpoints, and some edge will only cover of their endpoints. If the edge only covers one of their endpoints, then this edge must be the edge with minimum weight incident to that particular endpoint. Let c_v be the cost of the minimum weight edge incident to vertex v, and w_(u,v) be the weight of edge (u,v), then the cost of a solution is \\n![image](https://assets.leetcode.com/users/images/e04f65c8-0d40-4262-81ce-3ff85efd75e9_1600669162.3114378.png)\\n\\n\\nWe note that the first sum is fixed, and the second we want maximum the second sum. Hence, the problem becomes find a maximum weight matching with edge weight c_v+c_u-w_(u,v). Using Hungarian algorithm, we can find such matching for bipartite graph in O(n^3).\\n\\n**Implementation**:\\n```\\nclass Solution {\\npublic:\\n   #define getL(x) (x+2)\\n   #define getR(x) (2+Lmin.size()+x) \\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        vector<int> Lmin(cost.size());\\n        vector<int> Rmin(cost[0].size());\\n        int ans = 0;\\n        for(int i = 0; i < cost.size();++i) {\\n            Lmin[i] = INT_MAX;\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                Lmin[i] = min(Lmin[i], cost[i][j]);\\n            }\\n            ans += Lmin[i];\\n        }\\n        for(int j = 0; j < Rmin.size();++j) {\\n            Rmin[j] = INT_MAX;\\n            for(int i = 0; i < Lmin.size(); ++i) {\\n                Rmin[j] = min(Rmin[j],cost[i][j]);\\n            }\\n            ans += Rmin[j];\\n        }\\n        hungarian<int> H(Lmin.size(),Rmin.size());\\n        for(int i = 0; i < Lmin.size(); ++i) {\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                H.addEdge(i,j,-1*(cost[i][j]-Lmin[i]-Rmin[j]));\\n            }\\n        }\\n        int ret = H.solve();\\n        ans = ans - ret;\\n        return ans;\\n    }\\n};\\n```\\n\\nTemplate for Hungarian Algorithm (Kuhn\\u2013Munkres algorithm):\\n```\\ntemplate <typename T>\\nstruct hungarian\\n{ // km\\n    int n;\\n    vector<int> matchx;\\n    vector<int> matchy;\\n    vector<int> pre;\\n    vector<bool> visx;\\n    vector<bool> visy;\\n    vector<T> lx;\\n    vector<T> ly;\\n    vector<vector<T>> g;\\n    vector<T> slack;\\n    T inf;\\n    T res;\\n    queue<int> q;\\n    int org_n;\\n    int org_m;\\n\\n    hungarian(int _n, int _m)\\n    {\\n        org_n = _n;\\n        org_m = _m;\\n        n = max(_n, _m);\\n        inf = numeric_limits<T>::max();\\n        res = 0;\\n        g = vector<vector<T>>(n, vector<T>(n));\\n        matchx = vector<int>(n, -1);\\n        matchy = vector<int>(n, -1);\\n        pre = vector<int>(n);\\n        visx = vector<bool>(n);\\n        visy = vector<bool>(n);\\n        lx = vector<T>(n, -inf);\\n        ly = vector<T>(n);\\n        slack = vector<T>(n);\\n    }\\n\\n    void addEdge(int u, int v, int w)\\n    {\\n        g[u][v] = max(w, 0); \\n    }\\n\\n    bool check(int v)\\n    {\\n        visy[v] = true;\\n        if (matchy[v] != -1)\\n        {\\n            q.push(matchy[v]);\\n            visx[matchy[v]] = true;\\n            return false;\\n        }\\n        while (v != -1)\\n        {\\n            matchy[v] = pre[v];\\n            swap(v, matchx[pre[v]]);\\n        }\\n        return true;\\n    }\\n\\n    void bfs(int i)\\n    {\\n        while (!q.empty())\\n        {\\n            q.pop();\\n        }\\n        q.push(i);\\n        visx[i] = true;\\n        while (true)\\n        {\\n            while (!q.empty())\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for (int v = 0; v < n; v++)\\n                {\\n                    if (!visy[v])\\n                    {\\n                        T delta = lx[u] + ly[v] - g[u][v];\\n                        if (slack[v] >= delta)\\n                        {\\n                            pre[v] = u;\\n                            if (delta)\\n                            {\\n                                slack[v] = delta;\\n                            }\\n                            else if (check(v))\\n                            {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            T a = inf;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j])\\n                {\\n                    a = min(a, slack[j]);\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (visx[j])\\n                { // S\\n                    lx[j] -= a;\\n                }\\n                if (visy[j])\\n                { // T\\n                    ly[j] += a;\\n                }\\n                else\\n                { // T\\'\\n                    slack[j] -= a;\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j] && slack[j] == 0 && check(j))\\n                {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    int solve()\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                lx[i] = max(lx[i], g[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            fill(slack.begin(), slack.end(), inf);\\n            fill(visx.begin(), visx.end(), false);\\n            fill(visy.begin(), visy.end(), false);\\n            bfs(i);\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (g[i][matchx[i]] > 0)\\n            {\\n                res += g[i][matchx[i]];\\n            }\\n            else\\n            {\\n                matchx[i] = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   #define getL(x) (x+2)\\n   #define getR(x) (2+Lmin.size()+x) \\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        vector<int> Lmin(cost.size());\\n        vector<int> Rmin(cost[0].size());\\n        int ans = 0;\\n        for(int i = 0; i < cost.size();++i) {\\n            Lmin[i] = INT_MAX;\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                Lmin[i] = min(Lmin[i], cost[i][j]);\\n            }\\n            ans += Lmin[i];\\n        }\\n        for(int j = 0; j < Rmin.size();++j) {\\n            Rmin[j] = INT_MAX;\\n            for(int i = 0; i < Lmin.size(); ++i) {\\n                Rmin[j] = min(Rmin[j],cost[i][j]);\\n            }\\n            ans += Rmin[j];\\n        }\\n        hungarian<int> H(Lmin.size(),Rmin.size());\\n        for(int i = 0; i < Lmin.size(); ++i) {\\n            for(int j = 0; j < Rmin.size(); ++j) {\\n                H.addEdge(i,j,-1*(cost[i][j]-Lmin[i]-Rmin[j]));\\n            }\\n        }\\n        int ret = H.solve();\\n        ans = ans - ret;\\n        return ans;\\n    }\\n};\\n```\n```\\ntemplate <typename T>\\nstruct hungarian\\n{ // km\\n    int n;\\n    vector<int> matchx;\\n    vector<int> matchy;\\n    vector<int> pre;\\n    vector<bool> visx;\\n    vector<bool> visy;\\n    vector<T> lx;\\n    vector<T> ly;\\n    vector<vector<T>> g;\\n    vector<T> slack;\\n    T inf;\\n    T res;\\n    queue<int> q;\\n    int org_n;\\n    int org_m;\\n\\n    hungarian(int _n, int _m)\\n    {\\n        org_n = _n;\\n        org_m = _m;\\n        n = max(_n, _m);\\n        inf = numeric_limits<T>::max();\\n        res = 0;\\n        g = vector<vector<T>>(n, vector<T>(n));\\n        matchx = vector<int>(n, -1);\\n        matchy = vector<int>(n, -1);\\n        pre = vector<int>(n);\\n        visx = vector<bool>(n);\\n        visy = vector<bool>(n);\\n        lx = vector<T>(n, -inf);\\n        ly = vector<T>(n);\\n        slack = vector<T>(n);\\n    }\\n\\n    void addEdge(int u, int v, int w)\\n    {\\n        g[u][v] = max(w, 0); \\n    }\\n\\n    bool check(int v)\\n    {\\n        visy[v] = true;\\n        if (matchy[v] != -1)\\n        {\\n            q.push(matchy[v]);\\n            visx[matchy[v]] = true;\\n            return false;\\n        }\\n        while (v != -1)\\n        {\\n            matchy[v] = pre[v];\\n            swap(v, matchx[pre[v]]);\\n        }\\n        return true;\\n    }\\n\\n    void bfs(int i)\\n    {\\n        while (!q.empty())\\n        {\\n            q.pop();\\n        }\\n        q.push(i);\\n        visx[i] = true;\\n        while (true)\\n        {\\n            while (!q.empty())\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for (int v = 0; v < n; v++)\\n                {\\n                    if (!visy[v])\\n                    {\\n                        T delta = lx[u] + ly[v] - g[u][v];\\n                        if (slack[v] >= delta)\\n                        {\\n                            pre[v] = u;\\n                            if (delta)\\n                            {\\n                                slack[v] = delta;\\n                            }\\n                            else if (check(v))\\n                            {\\n                                return;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            T a = inf;\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j])\\n                {\\n                    a = min(a, slack[j]);\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (visx[j])\\n                { // S\\n                    lx[j] -= a;\\n                }\\n                if (visy[j])\\n                { // T\\n                    ly[j] += a;\\n                }\\n                else\\n                { // T\\'\\n                    slack[j] -= a;\\n                }\\n            }\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (!visy[j] && slack[j] == 0 && check(j))\\n                {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    int solve()\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                lx[i] = max(lx[i], g[i][j]);\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            fill(slack.begin(), slack.end(), inf);\\n            fill(visx.begin(), visx.end(), false);\\n            fill(visy.begin(), visy.end(), false);\\n            bfs(i);\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (g[i][matchx[i]] > 0)\\n            {\\n                res += g[i][matchx[i]];\\n            }\\n            else\\n            {\\n                matchx[i] = -1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855188,
                "title": "python-clean-dp-bitmask-solution-with-explaination",
                "content": "**Idea**\\n\\nThere are basically two steps:\\n1. Connect all group1 nodes to group2. Each group1 node only sends out 1 edge.\\n2. For all the unconnected nodes in group2, connect them with their min-cost counterparty in group1.\\n\\nWe use DP + Bitmask to achieve this. The step 1 above is the DP transition step and the step 2 above is the DP base case.\\n\\n<br />\\n\\n**Python**\\n```Python\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        min_arr = [min(x) for x in zip(*cost)]\\n        \\n        @lru_cache(None)\\n        def dp(i, mask):\\n            if i == m:\\n                ans = 0\\n                for j in range(n):\\n                    if not mask & (1 << j):\\n                        ans += min_arr[j]\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(n):\\n                ans = min(ans, cost[i][j] + dp(i + 1, mask | (1 << j)))\\n            return ans\\n        \\n        return dp(0, 0)\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        min_arr = [min(x) for x in zip(*cost)]\\n        \\n        @lru_cache(None)\\n        def dp(i, mask):\\n            if i == m:\\n                ans = 0\\n                for j in range(n):\\n                    if not mask & (1 << j):\\n                        ans += min_arr[j]\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(n):\\n                ans = min(ans, cost[i][j] + dp(i + 1, mask | (1 << j)))\\n            return ans\\n        \\n        return dp(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855425,
                "title": "java-bottom-up-dp-with-bit-mask",
                "content": "1, to make groups connect, we just need to make the cost[][] mattrix has 1 or more connection for each row and each column;\\n2, take a look at size1 and size2 both < 12, then we can use bit mask to memorize the intermidiate status, to avoid duplicate calculation.\\n3, Suppose cnt of Cols > cnt > rows. We count from the left most col, to the most right col, for each previous mask, we just try to add each of the new value in the new col to make new mask, and save the min cost to achieve mask to dp;\\n```\\n    public int connectTwoGroups(List<List<Integer>> cs) {\\n        int m = cs.size(), n = cs.get(0).size(), msk = 1 << m, dp[] = new int[msk];\\n        for (int i = 0; i < msk; i++) dp[i] = Integer.MAX_VALUE;\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            int[] tmp = new int[msk];\\n            for (int l = 0; l < msk; l++) tmp[l] = Integer.MAX_VALUE;\\n            // tmp[0] = 0; // you can not leave the previous lines without connections.\\n            for (int k = 0; k < msk; k++) {\\n                for (int j = 0; j < m; j++) {\\n                    int mask = k | (1 << j);\\n                    if (dp[k] != Integer.MAX_VALUE) tmp[mask] = Math.min(tmp[mask], dp[k] + cs.get(j).get(i));\\n                    if ((k & (1 << j)) == 0) {\\n                        if (tmp[k] != Integer.MAX_VALUE)  tmp[mask] = Math.min(tmp[mask], tmp[k] + cs.get(j).get(i));\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        return dp[msk - 1];\\n    }\\n```\\n\\nFor readers to be curious of looping orders, see @venkim\\'s [solution](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/855425/Java-bottom-up-DP-with-bit-mask/704737) in comments.",
                "solutionTags": [],
                "code": "```\\n    public int connectTwoGroups(List<List<Integer>> cs) {\\n        int m = cs.size(), n = cs.get(0).size(), msk = 1 << m, dp[] = new int[msk];\\n        for (int i = 0; i < msk; i++) dp[i] = Integer.MAX_VALUE;\\n        dp[0] = 0;\\n        for (int i = 0; i < n; i++) {\\n            int[] tmp = new int[msk];\\n            for (int l = 0; l < msk; l++) tmp[l] = Integer.MAX_VALUE;\\n            // tmp[0] = 0; // you can not leave the previous lines without connections.\\n            for (int k = 0; k < msk; k++) {\\n                for (int j = 0; j < m; j++) {\\n                    int mask = k | (1 << j);\\n                    if (dp[k] != Integer.MAX_VALUE) tmp[mask] = Math.min(tmp[mask], dp[k] + cs.get(j).get(i));\\n                    if ((k & (1 << j)) == 0) {\\n                        if (tmp[k] != Integer.MAX_VALUE)  tmp[mask] = Math.min(tmp[mask], tmp[k] + cs.get(j).get(i));\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        return dp[msk - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855509,
                "title": "why-minimum-spanning-tree-algorithm-dosen-t-work-here",
                "content": "I tried using Kruskal\\u2019s Minimum Spanning Tree Algorithm\\n\\n```\\nstruct Connection{\\n    int source;\\n    int destination;\\n    int cost;\\n    Connection(int s,int d,int c){\\n        source=s;\\n        destination=d;\\n        cost = c;\\n    }\\n};\\n\\nstruct cmpConnection{\\n    bool operator()(Connection const& c1, Connection const& c2) \\n    { \\n        return c1.cost>c2.cost; \\n    } \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        priority_queue<Connection,vector<Connection>,cmpConnection> costHeap;\\n        for(int i=0;i<cost.size();i++){\\n            for(int j=0;j<cost[i].size();j++){\\n                Connection conn(i,j,cost[i][j]);\\n                costHeap.push(conn);\\n            }\\n        }\\n        vector<bool> visitedS(cost.size());\\n        vector<bool> visitedT(cost[0].size());\\n        fill(visitedS.begin(),visitedS.end(),false);\\n        fill(visitedT.begin(),visitedT.end(),false);\\n        int SLeft = visitedS.size();\\n        int TLeft = visitedT.size();\\n        \\n        int costIncur = 0;\\n        while(SLeft>0 || TLeft>0){ //Until all the nodes are visited\\n            \\n            Connection conn = costHeap.top();\\n            costHeap.pop();\\n            if(!visitedS[conn.source] || !visitedT[conn.destination]){\\n                //Mark visited and add in cost\\n                cout<<\"Adding in:\"<<conn.source+1<<\",\"<<conn.destination+1<<\",cost:\"<<conn.cost<<endl;\\n                if(!visitedS[conn.source])\\n                    SLeft--;\\n                if(!visitedT[conn.destination])\\n                    TLeft--;\\n                \\n                costIncur+=conn.cost;\\n                visitedS[conn.source]=true;\\n                visitedT[conn.destination]=true;\\n            }\\n        }\\n        \\n        \\n        return costIncur;\\n    }\\n};\\n```\\n\\nBut it failed on 3rd Sample Test Case:\\nInput: cost = [[2, 5, 1], [3, 4, 7], [8, 1, 2], [6, 2, 4], [3, 8, 8]]\\nOutput: 10\\nMy Output: 12\\n\\nI am unable to get output of 10 by hand . can anyone explain why this dosen\\'t work?",
                "solutionTags": [],
                "code": "```\\nstruct Connection{\\n    int source;\\n    int destination;\\n    int cost;\\n    Connection(int s,int d,int c){\\n        source=s;\\n        destination=d;\\n        cost = c;\\n    }\\n};\\n\\nstruct cmpConnection{\\n    bool operator()(Connection const& c1, Connection const& c2) \\n    { \\n        return c1.cost>c2.cost; \\n    } \\n};\\n\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        priority_queue<Connection,vector<Connection>,cmpConnection> costHeap;\\n        for(int i=0;i<cost.size();i++){\\n            for(int j=0;j<cost[i].size();j++){\\n                Connection conn(i,j,cost[i][j]);\\n                costHeap.push(conn);\\n            }\\n        }\\n        vector<bool> visitedS(cost.size());\\n        vector<bool> visitedT(cost[0].size());\\n        fill(visitedS.begin(),visitedS.end(),false);\\n        fill(visitedT.begin(),visitedT.end(),false);\\n        int SLeft = visitedS.size();\\n        int TLeft = visitedT.size();\\n        \\n        int costIncur = 0;\\n        while(SLeft>0 || TLeft>0){ //Until all the nodes are visited\\n            \\n            Connection conn = costHeap.top();\\n            costHeap.pop();\\n            if(!visitedS[conn.source] || !visitedT[conn.destination]){\\n                //Mark visited and add in cost\\n                cout<<\"Adding in:\"<<conn.source+1<<\",\"<<conn.destination+1<<\",cost:\"<<conn.cost<<endl;\\n                if(!visitedS[conn.source])\\n                    SLeft--;\\n                if(!visitedT[conn.destination])\\n                    TLeft--;\\n                \\n                costIncur+=conn.cost;\\n                visitedS[conn.source]=true;\\n                visitedT[conn.destination]=true;\\n            }\\n        }\\n        \\n        \\n        return costIncur;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 855035,
                "title": "c-dp-bit-manipulation-solution-with-detailed-explanation",
                "content": "### C++ DP + bit manipulation solution with detailed explanation\\n\\nSince `size1 >= size2`, We can iterater through all `index1` (count: `O(size1)`) in the first group and use `state2`(count: `O(2 ^ size2)`) to represent whether an element in the second group is selected.\\n\\nOne Optimization: We can pre-calculate the cost for `index1` in the first group, and it select `the combination of elements in the second group` (represented in binary bit).\\n\\nThis is a solution, however it got `TLE`, we will try to optimize it.\\n\\n```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= m2; j++) {\\n                f[i][j] = -1;\\n            }\\n        }\\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 1; i <= m2; i++) {\\n            int curcost = pre[a][i];\\n            ans = min(ans, curcost + dfs(a + 1, state2 | i));\\n        }\\n        return val = ans;\\n    }\\n};\\n```\\n\\nWe can rethink this problem.\\n\\nOne observation: \\n\\n1. If an element in the first group select a used element in the second group, it can only select one, otherwise, the cost is not minium\\n\\n2. Otherwise, the element in the first group should select a subset of the complement set of the state2\\n\\nWe can apply this observation into codes and pass all the test cases.\\n\\n```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        memset(f, 0xff, sizeof f);\\n        \\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 0; i < m; i++) {\\n            if (state2 & (1 << i)) ans = min(ans, pre[a][1 << i] + dfs(a + 1, state2));\\n        }\\n        \\n        const int sub = (~state2) & m2;\\n        for (int i = sub; i > 0; i = (i - 1) & sub) {\\n            ans = min(ans, pre[a][i] + dfs(a + 1, state2 | i));\\n        }\\n        \\n        return val = ans;\\n    }\\n    \\n    int lowbit(int x) {\\n        return x&(-x);\\n    }\\n};\\n```\\n\\n\\nSpace complexity: `O(N * 2^N)`\\n\\nTime complexity: `O(N * 2^N * 2^N)`, however, by applying the second optimization, the upper bound of the time complexity of my solution is not very tight",
                "solutionTags": [],
                "code": "```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j <= m2; j++) {\\n                f[i][j] = -1;\\n            }\\n        }\\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 1; i <= m2; i++) {\\n            int curcost = pre[a][i];\\n            ans = min(ans, curcost + dfs(a + 1, state2 | i));\\n        }\\n        return val = ans;\\n    }\\n};\\n```\n```cpp\\nint f[14][4100];\\nint pre[14][4100];\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        this->c = cost;\\n        this->n = cost.size(), this->m = cost[0].size();\\n        this->m1 = (1 << n) - 1, this->m2 = (1 << m) - 1;\\n        \\n        memset(pre, 0, sizeof pre);\\n        memset(f, 0xff, sizeof f);\\n        \\n        for (int k = 0; k < n; k++) {\\n            for (int i = 0; i <= m2; i++) {\\n                int cur = 0;\\n                for (int j = 0; j < m; j++) {\\n                    if (i & (1 << j)) cur += cost[k][j];\\n                }\\n                pre[k][i] = cur;\\n            }\\n        }\\n        \\n        return dfs(0, 0);\\n    }\\nprivate:\\n    vector<vector<int>> c;\\n    \\n    int n, m;\\n    int m1, m2;\\n    int dfs(int a, int state2) {\\n        if (a == n) {\\n            if (state2 == m2) return 0;\\n            else return 9999999;\\n        }\\n        int& val = f[a][state2];\\n        if (val != -1) return val;\\n        \\n        int ans = 9999999;\\n        for (int i = 0; i < m; i++) {\\n            if (state2 & (1 << i)) ans = min(ans, pre[a][1 << i] + dfs(a + 1, state2));\\n        }\\n        \\n        const int sub = (~state2) & m2;\\n        for (int i = sub; i > 0; i = (i - 1) & sub) {\\n            ans = min(ans, pre[a][i] + dfs(a + 1, state2 | i));\\n        }\\n        \\n        return val = ans;\\n    }\\n    \\n    int lowbit(int x) {\\n        return x&(-x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860779,
                "title": "c-dp-with-bitmasking",
                "content": "Thinking of a recursive solution :  lets say we are on the point i from the first set then we can pair it with any other point of the second set and mark that point as visited and recursively do the same untill all the points from the first set are exhausted. Lets say at the end we have some points from the second set that are not paired yet so how can we pair them? we can simply pair each point to that point is set 1 such that the corresponding cost is minimum. Now to improve the time complexity we can save our states i.e the index we are at and the mask (track of point visited in second set) in a dp table.\\nTIME REQUIRED : O(n * 2^m * m)\\n\\n```\\n    int we_can[13];\\n    int rec(int i,int mask,vector<vector<int> >&cost,vector<vector<int> >&dp){\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        if(i == cost.size()){\\n            int take = 0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1 << j)) == 0){\\n                    take += we_can[j];\\n                \\n                }\\n            }\\n            \\n            return take;\\n        }\\n        if(dp[i][mask] != -1){\\n            return dp[i][mask];\\n        }\\n        int ans = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans = min(ans,cost[i][j] + rec(i+1,mask | (1 << j),cost,dp));\\n        }\\n        dp[i][mask] = ans;\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        int n = cost.size();\\n        int m = cost[0].size();\\n        for(int j=0;j<m;j++){\\n            we_can[j] = 500;\\n        }\\n        vector<vector<int> >dp(n,vector<int>((1 << m)+1,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n              //  cout << cost[i][j] << endl;\\n                we_can[j] = min(we_can[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int we_can[13];\\n    int rec(int i,int mask,vector<vector<int> >&cost,vector<vector<int> >&dp){\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        if(i == cost.size()){\\n            int take = 0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1 << j)) == 0){\\n                    take += we_can[j];\\n                \\n                }\\n            }\\n            \\n            return take;\\n        }\\n        if(dp[i][mask] != -1){\\n            return dp[i][mask];\\n        }\\n        int ans = INT_MAX;\\n        for(int j=0;j<m;j++){\\n            ans = min(ans,cost[i][j] + rec(i+1,mask | (1 << j),cost,dp));\\n        }\\n        dp[i][mask] = ans;\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        int n = cost.size();\\n        int m = cost[0].size();\\n        for(int j=0;j<m;j++){\\n            we_can[j] = 500;\\n        }\\n        vector<vector<int> >dp(n,vector<int>((1 << m)+1,-1));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n              //  cout << cost[i][j] << endl;\\n                we_can[j] = min(we_can[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp);\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 855352,
                "title": "the-idea-is-brute-force-dfs",
                "content": "**Explanation:**\\n\\nI got stuck while thinking it hard, my mind leads me to Heap or Floyd-Warshall Algorithm. However, this problem is actually solved by brute force DFS(). \\n\\nSince the left-group always longer than right-group, we keep a dp of right-group, just remember the closest distance for each point in right-group. \\n\\nBrute force dfs() with left-group, each time increment left-count for 1, for each round, just try all the point in right-group, with the help of bit-mask, we will know each point in right-group being connected or not(if not, in the end, we needs to connect them!). \\n\\nDon\\'t forgot to use a lru_cache, it works like a advanced memory for avoiding repeat.\\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m, dp = len(cost), len(cost[0]), {}\\n        for j in range(m): dp[j] = min(cost[i][j] for i in range(n)) \\n\\n        @lru_cache(maxsize = None)\\n        def dfs(left, right):\\n            if left == n: return sum(dp[j] for j in range(m) if right & 1<<j == 0)\\n            return min(cost[left][j] + dfs(left+1, right | 1<<j) for j in range(m))\\n\\n        return dfs(0, 0)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m, dp = len(cost), len(cost[0]), {}\\n        for j in range(m): dp[j] = min(cost[i][j] for i in range(n)) \\n\\n        @lru_cache(maxsize = None)\\n        def dfs(left, right):\\n            if left == n: return sum(dp[j] for j in range(m) if right & 1<<j == 0)\\n            return min(cost[left][j] + dfs(left+1, right | 1<<j) for j in range(m))\\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855316,
                "title": "c-short-iterative-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int sz1 = cost.size();\\n        int sz2 = cost[0].size();\\n        vector<vector<int>> dp(sz1 + 1, vector<int>(1 << sz2, 1e9));\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for(int i = sz1 - 1; i >= 0; --i) {\\n            for(int mask = (1 << sz2) - 1; mask >= 0; --mask) {\\n                for(int j = 0; j < sz2; ++j) {\\n                    dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if(!(mask & (1 << j))) {\\n                        dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int sz1 = cost.size();\\n        int sz2 = cost[0].size();\\n        vector<vector<int>> dp(sz1 + 1, vector<int>(1 << sz2, 1e9));\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for(int i = sz1 - 1; i >= 0; --i) {\\n            for(int mask = (1 << sz2) - 1; mask >= 0; --mask) {\\n                for(int j = 0; j < sz2; ++j) {\\n                    dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if(!(mask & (1 << j))) {\\n                        dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855222,
                "title": "java-brute-force",
                "content": "We know 1 <= size1, size2 <= 12, so it is possible to brute force it, \\nEach time hanlde one point, util complete process all points.\\nInclude two part:\\nIf current point is in group1, just try dfs connect to every group2 situation.\\nIf current point is in group2, just find the min cost connect to group1.\\n\\n```\\nclass Solution {\\n\\tprivate int minCost;\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tminCost = Integer.MAX_VALUE;\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n\\t\\tboolean[] connected = new boolean[gp1Size + gp2Size];\\n\\t\\tdfs(0, 0, cost, connected);\\n\\t\\treturn minCost;\\n\\t}\\n\\tprivate void dfs(int idx, int sum, List<List<Integer>> cost, boolean[] connected){\\n\\t\\tif (idx == gp1Size + gp2Size) { \\n\\t\\t\\tminCost = Math.min(minCost, sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        //pruning\\n\\t\\tif (sum >= minCost) {\\n            return; \\n        }\\n\\t\\tif (idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n\\t\\t\\tconnected[idx] = true; \\n            //brute force try connect to every point in group 2\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                boolean oldVal = connected[i+gp1Size];\\n\\t\\t\\t\\tconnected[i+gp1Size] = true;\\n\\t\\t\\t\\tdfs(idx+1, sum + cost.get(idx).get(i), cost, connected);\\n                connected[i+gp1Size] = oldVal;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif (!connected[idx]) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t\\tmin = Math.min(min, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdfs(idx+1, sum + min, cost, connected);\\n\\t\\t\\t} else {\\n                //if already connect, no need to connect to group 1 again\\n\\t\\t\\t\\tdfs(idx+1, sum, cost, connected);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nTime spend is about 397ms, since it is brute force probably not very fast.\\nTo improve is using the bit mask just as other discuss mentioned, then it will be able to cache the minCost for all the connected status.\\n```\\nclass Solution {\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n    private Map<Integer, Integer> cache;\\n    private int[] right;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n        cache = new HashMap<>();\\n\\t\\tint mask = 0;\\n\\t\\treturn dfs(0, cost, mask);\\n\\t}\\n\\tprivate int dfs(int idx, List<List<Integer>> cost, int mask){\\n\\t\\tif(idx == gp1Size + gp2Size) { \\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        int key = mask;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\t\\tif(idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n            mask = mask | (1 << idx);\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                int newMask = mask | (1 << (i + gp1Size));\\n\\t\\t\\t    min = Math.min(min, dfs(idx+1, cost, newMask) + cost.get(idx).get(i));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif((mask & (1 << idx)) == 0){\\n\\t\\t\\t\\tint minVal = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t    minVal = Math.min(minVal, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n                min = dfs(idx+1, cost, mask) + minVal;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmin = dfs(idx+1, cost, mask);\\n\\t\\t\\t}\\n\\t\\t}\\n        cache.put(key, min);\\n        return min;\\n\\t}\\n}\\n```\\nAfter cache, time cost is reduce to 75ms",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\tprivate int minCost;\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tminCost = Integer.MAX_VALUE;\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n\\t\\tboolean[] connected = new boolean[gp1Size + gp2Size];\\n\\t\\tdfs(0, 0, cost, connected);\\n\\t\\treturn minCost;\\n\\t}\\n\\tprivate void dfs(int idx, int sum, List<List<Integer>> cost, boolean[] connected){\\n\\t\\tif (idx == gp1Size + gp2Size) { \\n\\t\\t\\tminCost = Math.min(minCost, sum);\\n\\t\\t\\treturn;\\n\\t\\t}\\n        //pruning\\n\\t\\tif (sum >= minCost) {\\n            return; \\n        }\\n\\t\\tif (idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n\\t\\t\\tconnected[idx] = true; \\n            //brute force try connect to every point in group 2\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                boolean oldVal = connected[i+gp1Size];\\n\\t\\t\\t\\tconnected[i+gp1Size] = true;\\n\\t\\t\\t\\tdfs(idx+1, sum + cost.get(idx).get(i), cost, connected);\\n                connected[i+gp1Size] = oldVal;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif (!connected[idx]) {\\n\\t\\t\\t\\tint min = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t\\tmin = Math.min(min, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdfs(idx+1, sum + min, cost, connected);\\n\\t\\t\\t} else {\\n                //if already connect, no need to connect to group 1 again\\n\\t\\t\\t\\tdfs(idx+1, sum, cost, connected);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tprivate int gp1Size;\\n\\tprivate int gp2Size;\\n    private Map<Integer, Integer> cache;\\n    private int[] right;\\n\\tpublic int connectTwoGroups(List<List<Integer>> cost) {\\n\\t\\tgp1Size = cost.size();\\n\\t\\tgp2Size = cost.get(0).size();\\n        cache = new HashMap<>();\\n\\t\\tint mask = 0;\\n\\t\\treturn dfs(0, cost, mask);\\n\\t}\\n\\tprivate int dfs(int idx, List<List<Integer>> cost, int mask){\\n\\t\\tif(idx == gp1Size + gp2Size) { \\n\\t\\t\\treturn 0;\\n\\t\\t}\\n        int key = mask;\\n        if(cache.containsKey(key)) {\\n            return cache.get(key);\\n        }\\n        int min = Integer.MAX_VALUE;\\n\\t\\tif(idx < gp1Size) {\\n\\t\\t\\t//in group 1\\n            mask = mask | (1 << idx);\\n\\t\\t\\tfor(int i = 0; i < gp2Size; i++){\\n                int newMask = mask | (1 << (i + gp1Size));\\n\\t\\t\\t    min = Math.min(min, dfs(idx+1, cost, newMask) + cost.get(idx).get(i));\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t//in group 2\\n\\t\\t\\tif((mask & (1 << idx)) == 0){\\n\\t\\t\\t\\tint minVal = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int i = 0; i < gp1Size; i++){\\n\\t\\t\\t\\t    minVal = Math.min(minVal, cost.get(i).get(idx-gp1Size));\\n\\t\\t\\t\\t}\\n                min = dfs(idx+1, cost, mask) + minVal;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmin = dfs(idx+1, cost, mask);\\n\\t\\t\\t}\\n\\t\\t}\\n        cache.put(key, min);\\n        return min;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075430,
                "title": "c-python-legit-dp-bitmask-explanation-bottom-up-and-top-down",
                "content": "Since we can multiply connect nodes, this is NOT an MST (minimal spanning tree) solution. For example suppose on the left, it cost [0,100,100] to connect any right node, and the same for the left. We would get a solution where L!->R1, L2->R1, L3->R1 and on the right R1->L1, R2->L1, R3->L1. We have more than the minimal 3 required, but it is much much cheaper to be redundant here (zero cost vs 200 cost).\\n\\nThe DP bitmask solution is very tricky. The optimal subproblems are actually not well defined subproblems! They only make sense at the very end.\\n\\nWe do the following: first solve a different problem. Suppose we have hooked up all *m* left nodes to some node on the right. Further assume that that procedure was __zero cost__. Now, what would be the cost to connect the right nodes?\\n\\nSince the left nodes are fixed, we just assign the *remaining* right nodes to their lowest costs. This is the base case of the recursion. We have to hard compute these minimal costs once and for all up front. They are just the minimum values in each column.\\n\\nThere are _2^n_ possible base cases. One for each possible configuration of \"already hooked up\" right nodes (the left nodes were zero cost, so we don\\'t care about that, hence _2^n_ and not _2^(mn)_).The DP matrix is thus of size _(m,2^n)_.\\n\\nNow we peel off the last connection on the left. There are now (m-1) zero cost connections on the left, leading to, again, any of _2^n_ possibilities on the right. To reconnect this final left node, it is the sum of two costs:\\n\\n1. `cost[i][j]``. Simply the cost of the left node\\'s connection\\n2. d[i+1][constrained mask]. The minimal cost for the right nodes to connect (our base case), but with an added constraint. We only allow states on the right where whatever right node that the left node connected to is marked as NOT free. This is redundantly imposed by turning on its bit `mask | 1<<k` for the _k_th right node.\\n\\nThe final cost is the sum over all _n_ possible costs, one for each possible right node that the final left node may connect to.\\n\\nWe can now state the final problem. We want to wittle the DP matrix down to the value `d[0][0]`. This means that we have attached __0__ nodes on the left, and there are currently __0__ blocked nodes on the right. By including the cost in item 2, our DP algorithm insures that we appropriately build up the costs of connecting each left nodes!\\n\\nThe tricky part of this solution was having faith that our optimal subproblems would suddenly blossom into a well-defined optimal problem.\\n\\nHere\\'s the bottoms-up C++ code\\n\\n```cpp\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n\\n    int m=cost.size(), n=cost[0].size();\\n\\n    vector <int> rc(n, numeric_limits<int>::max());\\n    for (int i=0; i<m; ++i)\\n        for (int j=0; j<n; ++j)\\n            rc[j] = min(rc[j], cost[i][j]);\\n\\n    int d[13][1<<12]{};\\n    for (int i=m; i>=0; --i) {\\n        for (int j=0; j<1<<12; ++j) {\\n            if (i==m)\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] += !(j&1<<k) ? rc[k] : 0;\\n            else {\\n                d[i][j] = numeric_limits<int>::max();\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] = min(d[i][j], d[i+1][j|1<<k] + cost[i][k]);\\n            }\\n        }\\n    }\\n    return d[0][0];\\n}\\n```\\n\\nSince there was a redundancy in the bitmask constraint as we discussed, the top-down DP solution will actually be faster. It only queries the dictionary as needed. Here\\'s a python implemenation.\\n\\n```python\\ndef connectTwoGroups(cost) {\\n  m, n = len(cost), len(cost[0])\\n  rc = [min(x) for x in zip(*cost)] # right costs\\n\\n  # The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n  @lru_cache(maxsize=None)\\n  def aux(i, states):\\n      if i == m:\\n          return sum(rc[x] for x in range(n) if states & 1<<x == 0)\\n      return min(cost[i][j] + aux(i+1, states | 1<<j) for j in range(n))\\n\\n  # return the cost for 0 initial left connections and 0 intial right connections\\n  return aux(0,0)\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint connectTwoGroups(vector<vector<int>>& cost) {\\n\\n    int m=cost.size(), n=cost[0].size();\\n\\n    vector <int> rc(n, numeric_limits<int>::max());\\n    for (int i=0; i<m; ++i)\\n        for (int j=0; j<n; ++j)\\n            rc[j] = min(rc[j], cost[i][j]);\\n\\n    int d[13][1<<12]{};\\n    for (int i=m; i>=0; --i) {\\n        for (int j=0; j<1<<12; ++j) {\\n            if (i==m)\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] += !(j&1<<k) ? rc[k] : 0;\\n            else {\\n                d[i][j] = numeric_limits<int>::max();\\n                for (int k=0; k<n; ++k)\\n                    d[i][j] = min(d[i][j], d[i+1][j|1<<k] + cost[i][k]);\\n            }\\n        }\\n    }\\n    return d[0][0];\\n}\\n```\n```python\\ndef connectTwoGroups(cost) {\\n  m, n = len(cost), len(cost[0])\\n  rc = [min(x) for x in zip(*cost)] # right costs\\n\\n  # The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n  @lru_cache(maxsize=None)\\n  def aux(i, states):\\n      if i == m:\\n          return sum(rc[x] for x in range(n) if states & 1<<x == 0)\\n      return min(cost[i][j] + aux(i+1, states | 1<<j) for j in range(n))\\n\\n  # return the cost for 0 initial left connections and 0 intial right connections\\n  return aux(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 855275,
                "title": "why-is-this-approach-not-working-add-all-costs-sort-them-and-then-remove-one-by-one",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int[] groupACounts = new int[cost.get(0).size()];\\n        int[] groupBCounts = new int[cost.size()];\\n        Arrays.fill(groupACounts, cost.size());\\n        Arrays.fill(groupBCounts, cost.get(0).size());\\n        TreeMap<Integer, List<List<Integer>>> tm = new TreeMap<>(Collections.reverseOrder());\\n        for (int i = 0; i < cost.size(); i++) {\\n            for (int j = 0; j < cost.get(i).size(); j++) {\\n                int currCost = cost.get(i).get(j);\\n                if (!tm.containsKey(currCost)) {\\n                    tm.put(currCost, new ArrayList<List<Integer>>());\\n                } \\n                tm.get(currCost).add(new ArrayList<Integer>(List.of(i, j)));\\n            }\\n        }\\n        int costt = 0;\\n        for(Map.Entry<Integer,List<List<Integer>>> entry : tm.entrySet()) {\\n            Integer key = entry.getKey();\\n            List<List<Integer>> pairs = entry.getValue();\\n            if (pairs.size() > 1) {\\n                List<Integer> temp = pairs.get(0);\\n                pairs.set(0, pairs.get(1));\\n                pairs.set(1, temp);\\n            }\\n            for (List<Integer> pair : pairs) {\\n                if (groupACounts[pair.get(1)] > 1 && groupBCounts[pair.get(0)] > 1) {\\n                    groupACounts[pair.get(1)]--;\\n                    groupBCounts[pair.get(0)]--;\\n                } else {\\n                    costt += cost.get(pair.get(0)).get(pair.get(1));\\n                }\\n            }\\n        }\\n        return costt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int[] groupACounts = new int[cost.get(0).size()];\\n        int[] groupBCounts = new int[cost.size()];\\n        Arrays.fill(groupACounts, cost.size());\\n        Arrays.fill(groupBCounts, cost.get(0).size());\\n        TreeMap<Integer, List<List<Integer>>> tm = new TreeMap<>(Collections.reverseOrder());\\n        for (int i = 0; i < cost.size(); i++) {\\n            for (int j = 0; j < cost.get(i).size(); j++) {\\n                int currCost = cost.get(i).get(j);\\n                if (!tm.containsKey(currCost)) {\\n                    tm.put(currCost, new ArrayList<List<Integer>>());\\n                } \\n                tm.get(currCost).add(new ArrayList<Integer>(List.of(i, j)));\\n            }\\n        }\\n        int costt = 0;\\n        for(Map.Entry<Integer,List<List<Integer>>> entry : tm.entrySet()) {\\n            Integer key = entry.getKey();\\n            List<List<Integer>> pairs = entry.getValue();\\n            if (pairs.size() > 1) {\\n                List<Integer> temp = pairs.get(0);\\n                pairs.set(0, pairs.get(1));\\n                pairs.set(1, temp);\\n            }\\n            for (List<Integer> pair : pairs) {\\n                if (groupACounts[pair.get(1)] > 1 && groupBCounts[pair.get(0)] > 1) {\\n                    groupACounts[pair.get(1)]--;\\n                    groupBCounts[pair.get(0)]--;\\n                } else {\\n                    costt += cost.get(pair.get(0)).get(pair.get(1));\\n                }\\n            }\\n        }\\n        return costt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855104,
                "title": "python-bitmask-dfs",
                "content": "Use bitmask to record the status of group 2. \\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        dic = {}\\n        for i in range(n):\\n            dic[i] = min(cost[j][i] for j in range(m))\\n        \\n        @lru_cache(None)\\n        def dfs(left, right):\\n            b = bin(right)[2:]\\n            delta = n - len(b)\\n            b = delta * \\'0\\' + b\\n            cur = 0\\n            if left == m:\\n                for i in range(n):\\n                    if b[i] == \\'0\\':\\n                        cur += dic[i]\\n                return cur\\n            ret = float(\\'inf\\')\\n            for i in range(n):\\n                right |= (1 << (n - 1 - i))\\n                nxt = dfs(left + 1, right)\\n                cur = cost[left][i] + nxt\\n                ret = min(ret, cur)\\n                if b[i] == \\'0\\':\\n                    right &= ~(1 << (n - 1 - i))\\n            return ret\\n\\n        return dfs(0, 0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        dic = {}\\n        for i in range(n):\\n            dic[i] = min(cost[j][i] for j in range(m))\\n        \\n        @lru_cache(None)\\n        def dfs(left, right):\\n            b = bin(right)[2:]\\n            delta = n - len(b)\\n            b = delta * \\'0\\' + b\\n            cur = 0\\n            if left == m:\\n                for i in range(n):\\n                    if b[i] == \\'0\\':\\n                        cur += dic[i]\\n                return cur\\n            ret = float(\\'inf\\')\\n            for i in range(n):\\n                right |= (1 << (n - 1 - i))\\n                nxt = dfs(left + 1, right)\\n                cur = cost[left][i] + nxt\\n                ret = min(ret, cur)\\n                if b[i] == \\'0\\':\\n                    right &= ~(1 << (n - 1 - i))\\n            return ret\\n\\n        return dfs(0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855233,
                "title": "python-dp-with-explanation",
                "content": "Finished after contest -o-\\nThe dp equation is the following.\\nDefine dp(i,S) as the min cost to let the first up to i-th elements in group 1 and a subset S of group 2 to be connnected. Then, we have\\ndp(i,S)=min_k (dp(i-1,s\\\\k)+cost(i,k))\\nHere i is incremented from 0 to len(cost)-1\\nS denotes a subset of the second group\\nThe really tricky part for me is to get what dp(i,S) really means. The initial condition dp(-1,S) is tricky.\\nIt is easy to think dp(-1,S)=0 as no point in group needs to be connected. Yet, by definition, S in group 2 needs to be connected, and each point can connect to any point in group 1. It takes me some time to realize this. Interesting!!\\n\\nTime complexity: O(n*m*2^m), where n=len(group 1) and m=len(group2)\\n\\n\\n\\n```\\nINF=float(\\'inf\\')\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        def get_set(size):\\n            \\n            if size==1:\\n                return [tuple([0]),tuple([1])]        \\n            else:\\n                \\n                L=get_set(size-1)\\n                \\n                res=[]\\n                \\n                for status in L:\\n                    \\n                    res.append(status+tuple([0]))\\n                    res.append(status+tuple([1]))\\n                \\n                return res   \\n        \\n        dp={}\\n        \\n        \\n        L=get_set(len(cost[0]))\\n        \\n        for status in L:\\n            tem=0\\n            for j in range(len(status)):\\n                if status[j]==1:\\n                    min_tem=INF\\n                    for i in range(len(cost)):\\n                        min_tem=min(min_tem,cost[i][j])\\n                    tem+=min_tem\\n            \\n            dp[(-1,status)]=tem\\n       \\n        for i in range(0,len(cost)):\\n            \\n            for status in L:\\n                \\n                cur_min=INF\\n                for k in range(len(cost[0])):\\n                    \\n\\n                    new_stats=status[:k]+tuple([0])+status[k+1:]\\n                    \\n                    cur_min=min(cur_min,dp[(i-1,new_stats)]+cost[i][k])\\n                \\n                dp[(i,status)]=cur_min\\n        \\n        return dp[(len(cost)-1,tuple([1 for i in range(len(cost[0]))]))]\\n```",
                "solutionTags": [],
                "code": "```\\nINF=float(\\'inf\\')\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        def get_set(size):\\n            \\n            if size==1:\\n                return [tuple([0]),tuple([1])]        \\n            else:\\n                \\n                L=get_set(size-1)\\n                \\n                res=[]\\n                \\n                for status in L:\\n                    \\n                    res.append(status+tuple([0]))\\n                    res.append(status+tuple([1]))\\n                \\n                return res   \\n        \\n        dp={}\\n        \\n        \\n        L=get_set(len(cost[0]))\\n        \\n        for status in L:\\n            tem=0\\n            for j in range(len(status)):\\n                if status[j]==1:\\n                    min_tem=INF\\n                    for i in range(len(cost)):\\n                        min_tem=min(min_tem,cost[i][j])\\n                    tem+=min_tem\\n            \\n            dp[(-1,status)]=tem\\n       \\n        for i in range(0,len(cost)):\\n            \\n            for status in L:\\n                \\n                cur_min=INF\\n                for k in range(len(cost[0])):\\n                    \\n\\n                    new_stats=status[:k]+tuple([0])+status[k+1:]\\n                    \\n                    cur_min=min(cur_min,dp[(i-1,new_stats)]+cost[i][k])\\n                \\n                dp[(i,status)]=cur_min\\n        \\n        return dp[(len(cost)-1,tuple([1 for i in range(len(cost[0]))]))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260447,
                "title": "java-with-dp-bitmask-recursion",
                "content": "```\\nclass Solution {\\n    int Asize=0;\\n    int[][][] map;\\n    int resultMask=0;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        Asize=cost.get(0).size();\\n        resultMask=(1<<(Asize))-1;\\n        map=new int[cost.get(0).size()][cost.size()][resultMask+1];\\n        return helper(cost,0,0,0);\\n    }\\n    \\n    int helper(List<List<Integer>> cost,int i,int j,int mask){\\n    \\n        if(i==cost.size() && mask==resultMask){\\n            return 0;\\n        }\\n        int ans=150000;\\n        if(j==Asize || i==cost.size()){\\n            return ans;\\n        }\\n       \\n        if(map[j][i][mask]!=0){\\n            return map[j][i][mask];\\n        }\\n        int temp1=cost.get(i).get(j)+helper(cost,i+1,0,getMask(mask,j));\\n        int temp2=helper(cost,i,j+1,mask);\\n        int temp3=cost.get(i).get(j)+helper(cost,i,j+1,getMask(mask,j));\\n     \\n        ans=Math.min(temp3,Math.min(temp1,temp2));\\n        map[j][i][mask]=ans;\\n        return ans;\\n    }\\n    \\n    int getMask(int mask,int j){\\n        int temp=1<<j;\\n        mask=mask|temp;\\n        return mask;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int Asize=0;\\n    int[][][] map;\\n    int resultMask=0;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        Asize=cost.get(0).size();\\n        resultMask=(1<<(Asize))-1;\\n        map=new int[cost.get(0).size()][cost.size()][resultMask+1];\\n        return helper(cost,0,0,0);\\n    }\\n    \\n    int helper(List<List<Integer>> cost,int i,int j,int mask){\\n    \\n        if(i==cost.size() && mask==resultMask){\\n            return 0;\\n        }\\n        int ans=150000;\\n        if(j==Asize || i==cost.size()){\\n            return ans;\\n        }\\n       \\n        if(map[j][i][mask]!=0){\\n            return map[j][i][mask];\\n        }\\n        int temp1=cost.get(i).get(j)+helper(cost,i+1,0,getMask(mask,j));\\n        int temp2=helper(cost,i,j+1,mask);\\n        int temp3=cost.get(i).get(j)+helper(cost,i,j+1,getMask(mask,j));\\n     \\n        ans=Math.min(temp3,Math.min(temp1,temp2));\\n        map[j][i][mask]=ans;\\n        return ans;\\n    }\\n    \\n    int getMask(int mask,int j){\\n        int temp=1<<j;\\n        mask=mask|temp;\\n        return mask;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046425,
                "title": "short-python-dp",
                "content": "```python\\nfrom functools import lru_cache\\n\\n\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        @lru_cache(None)\\n        def f(n, msk):\\n            if n == 0:\\n                return msk and float(\\'inf\\')\\n            res = f(n-1, msk) + min(cost[n-1])\\n            for i  in range(m):\\n                if (msk>>i) & 1 :\\n                    res = min(res, min(f(n-1, msk ^(1<<i)), f(n, msk^(1<<i))) + cost[n-1][i])\\n            return res\\n        return f(n, (1<<m)-1)\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nfrom functools import lru_cache\\n\\n\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        @lru_cache(None)\\n        def f(n, msk):\\n            if n == 0:\\n                return msk and float(\\'inf\\')\\n            res = f(n-1, msk) + min(cost[n-1])\\n            for i  in range(m):\\n                if (msk>>i) & 1 :\\n                    res = min(res, min(f(n-1, msk ^(1<<i)), f(n, msk^(1<<i))) + cost[n-1][i])\\n            return res\\n        return f(n, (1<<m)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972844,
                "title": "c-solution-following-the-hints",
                "content": "Following the hints, let dp[i][j] denote the minimum cost when first i left nodes are connected to the right nodes represented by mask j; then the DP relations is:\\n```\\ndp[i][j] = min {\\n\\t\\t\\tdp[i-1][j] + (min cost between node i and a node within j),\\n\\t\\t\\tdp[i-1][k] + (sum of cost between node i and nodes in j ^ k) for different subsets k of j\\n\\t\\t\\t}\\n```\\nIn another word, the general idea is: iterate the left nodes one by one; for new left node, there can be 2 cases:\\n1) its degree can be 1, which means it will follow some other right side node, which is the first term in the above relation;\\n2) its degree is greater than 1, which means it\\'s a leader and have a subset of right nodes uniquely belonging to it, which is the second term in the above relation.\\n\\n```\\nclass Solution {\\n    \\n    int m,n;\\n    int dp[12][1<<12]{};\\n    int withinmin[12][1<<12]{};\\n    int withinsum[12][1<<12]{};\\n    \\npublic:\\n    \\n    void prepare(vector<vector<int>>& co) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                withinsum[i][1<<j] = dp[i][1<<j] = co[i][j];\\n            }\\n            \\n            for(int j = 3; j < (1 << n); j++) {\\n                if(withinsum[i][j]) continue;\\n                withinsum[i][j] = withinsum[i][j&-j] + withinsum[i][j-(j&-j)];\\n            }\\n            \\n            vector<int> x(n);\\n            iota(x.begin(), x.end(), 0);\\n            auto f=[&co, &i](int j, int k){return co[i][j] < co[i][k];};\\n            std::sort(x.begin(), x.end(), f);\\n            \\n            int ind = (1 << n) - 1, inc;\\n            for(int j : x) {\\n                inc = 1 << j;\\n                ind ^= inc;\\n                for(int k = ind;;k = (k - 1)&ind) {\\n                    withinmin[i][k|inc] = co[i][j];\\n                    if(!k)break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        \\n        prepare(cost);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < (1<<n); j++) {\\n                if(i == 0) dp[i][j] = dp[i][j&-j] + dp[i][j-(j&-j)];\\n                else {\\n                    dp[i][j] = dp[i-1][j] + withinmin[i][j]; // case 1)\\n                    for(int k = j-1; k; k = (k-1)&j) { // case 2)\\n                        dp[i][j] = min(dp[i][j], withinsum[i][k] + dp[i-1][j^k]); \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][(1<<n)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[i][j] = min {\\n\\t\\t\\tdp[i-1][j] + (min cost between node i and a node within j),\\n\\t\\t\\tdp[i-1][k] + (sum of cost between node i and nodes in j ^ k) for different subsets k of j\\n\\t\\t\\t}\\n```\n```\\nclass Solution {\\n    \\n    int m,n;\\n    int dp[12][1<<12]{};\\n    int withinmin[12][1<<12]{};\\n    int withinsum[12][1<<12]{};\\n    \\npublic:\\n    \\n    void prepare(vector<vector<int>>& co) {\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                withinsum[i][1<<j] = dp[i][1<<j] = co[i][j];\\n            }\\n            \\n            for(int j = 3; j < (1 << n); j++) {\\n                if(withinsum[i][j]) continue;\\n                withinsum[i][j] = withinsum[i][j&-j] + withinsum[i][j-(j&-j)];\\n            }\\n            \\n            vector<int> x(n);\\n            iota(x.begin(), x.end(), 0);\\n            auto f=[&co, &i](int j, int k){return co[i][j] < co[i][k];};\\n            std::sort(x.begin(), x.end(), f);\\n            \\n            int ind = (1 << n) - 1, inc;\\n            for(int j : x) {\\n                inc = 1 << j;\\n                ind ^= inc;\\n                for(int k = ind;;k = (k - 1)&ind) {\\n                    withinmin[i][k|inc] = co[i][j];\\n                    if(!k)break;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        \\n        prepare(cost);\\n        \\n        for(int i = 0; i < m; i++) {\\n            for(int j = 1; j < (1<<n); j++) {\\n                if(i == 0) dp[i][j] = dp[i][j&-j] + dp[i][j-(j&-j)];\\n                else {\\n                    dp[i][j] = dp[i-1][j] + withinmin[i][j]; // case 1)\\n                    for(int k = j-1; k; k = (k-1)&j) { // case 2)\\n                        dp[i][j] = min(dp[i][j], withinsum[i][k] + dp[i-1][j^k]); \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[m-1][(1<<n)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959516,
                "title": "dp-bitmask-faster-than-98-94-space-less-than-65-85-o-n-m-2-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int mn_cost[13];\\n    int cache[(1 << 12) + 1];\\n    int dp[13][(1 << 12) + 1];\\n    int n, m;\\n    int suff[13];\\n    const int inf = 1e9;\\n    vector<vector<int>>cst;\\n    int solve(int ind, int mask){\\n        if(mask == (1 << m) - 1){\\n            return suff[ind];\\n        }\\n        if(ind == n){\\n            return cache[mask];\\n        }\\n        if(dp[ind][mask] != -1)return dp[ind][mask];\\n        int ret = inf;\\n        for(int i = 0; i < m; ++i){\\n            ret = min(ret, cst[ind][i] + solve(ind + 1, mask | (1 << i)));\\n        }\\n        return dp[ind][mask] = ret;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        cst.assign(cost.begin(), cost.end());\\n        n = (int)cost.size();\\n        m = (int)cost[0].size();\\n        for(int i = 0; i < 13; ++i)mn_cost[i] = inf;\\n        for(int j = 0; j < m; ++j){\\n            for(int i = 0; i < n; ++i){\\n                mn_cost[j] = min(mn_cost[j], cost[i][j]);\\n            }\\n        }\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(!((i >> j) & 1))cache[i] += mn_cost[j];\\n            }\\n        }\\n        for(int i = n - 1; i >= 0; --i){\\n            if(i < n - 1)suff[i] = suff[i + 1];\\n            suff[i] += *min_element(cost[i].begin(), cost[i].end());\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mn_cost[13];\\n    int cache[(1 << 12) + 1];\\n    int dp[13][(1 << 12) + 1];\\n    int n, m;\\n    int suff[13];\\n    const int inf = 1e9;\\n    vector<vector<int>>cst;\\n    int solve(int ind, int mask){\\n        if(mask == (1 << m) - 1){\\n            return suff[ind];\\n        }\\n        if(ind == n){\\n            return cache[mask];\\n        }\\n        if(dp[ind][mask] != -1)return dp[ind][mask];\\n        int ret = inf;\\n        for(int i = 0; i < m; ++i){\\n            ret = min(ret, cst[ind][i] + solve(ind + 1, mask | (1 << i)));\\n        }\\n        return dp[ind][mask] = ret;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        cst.assign(cost.begin(), cost.end());\\n        n = (int)cost.size();\\n        m = (int)cost[0].size();\\n        for(int i = 0; i < 13; ++i)mn_cost[i] = inf;\\n        for(int j = 0; j < m; ++j){\\n            for(int i = 0; i < n; ++i){\\n                mn_cost[j] = min(mn_cost[j], cost[i][j]);\\n            }\\n        }\\n        for(int i = 0; i < (1 << m); ++i){\\n            for(int j = 0; j < m; ++j){\\n                if(!((i >> j) & 1))cache[i] += mn_cost[j];\\n            }\\n        }\\n        for(int i = n - 1; i >= 0; --i){\\n            if(i < n - 1)suff[i] = suff[i + 1];\\n            suff[i] += *min_element(cost[i].begin(), cost[i].end());\\n        }\\n        memset(dp, -1, sizeof(dp));\\n        return solve(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862980,
                "title": "dp-with-bitmask-in-c",
                "content": "LEETCODE-1595\\n$$\\u7528dp[i][j]\\u6765\\u8868\\u793A\\u5DE6\\u8FB9\\u524Di\\u4E2A\\u70B9\\u548C\\u53F3\\u8FB9\\u524Dj\\u4E2A\\u70B9\\u6765\\u8868\\u793A\\u5F53\\u524D\\u94FE\\u63A5\\u7684\\u6700\\u5C0Fcost\\u5E76\\u4E0D\\u5408\\u9002\\uFF0C\\u56E0\\u4E3A\\u53EF\\u80FD\\u51FA\\u73B0\\u4EA4\\u53C9\\u7684\\u60C5\\u51B5\\uFF0C\\u6BD4\\u5982\\u6700\\u4F18\\u7684\\u60C5\\u51B5\\u5982\\u4E0B\\uFF1A\\n1\\u2014\\u2014a\\n2\\tb\\n3\\tc\\n\\u5176\\u4E2D1-a,2-c,3-b\\uFF0C\\u8FD9\\u6837\\u5C31\\u4F1A\\u51FA\\u73B0\\u4EA4\\u53C9\\uFF0C\\u5728dp[i][j]\\u7684\\u8FED\\u4EE3\\u8FC7\\u7A0B\\u4E2D\\uFF0C\\u5E76\\u4E0D\\u80FD\\u4ECEdp[2][2]\\u5230\\u8FBEdp[3][3]\\u5E76\\u4E0D\\u7B26\\u5408\\u60C5\\u51B5\\uFF0C\\u56E0\\u4E3A\\u6CA1\\u529E\\u6CD5\\u5220\\u9664dp[2][2]\\u4E2D\\u7684\\u8FDE\\u7EBF\\u3002\\n$$\\u8003\\u8651\\u53E6\\u5916\\u4E00\\u79CD\\u65B9\\u6CD5\\uFF1A\\n\\u7528dp[i][s]\\u6765\\u8868\\u793A\\u5DE6\\u8FB9\\u524Di\\u4E2A\\u70B9\\uFF0C\\u53F3\\u8FB9\\u662F\\u4E00\\u4E2As\\u5BF9\\u5E94\\u4E00\\u4E2Abitmask\\uFF0Cs\\u53EF\\u4EE5\\u8868\\u793A\\u53F3\\u8FB9\\u94FE\\u63A5\\u7684\\u70B9\\u7684\\u6240\\u6709\\u60C5\\u51B5\\u3002\\n\\u6BD4\\u5982\\u53F3\\u8FB9\\u6709 a b\\u4E24\\u4E2A\\u70B9\\uFF0C\\u90A3\\u4E48\\u53EF\\u4EE5\\u8868\\u793A\\u4E3A\\u56DB\\u79CD\\u60C5\\u51B5\\uFF1A01 10 11 00\\uFF1B\\n\\u72B6\\u6001\\u8F6C\\u79FB\\u65B9\\u7A0B\\uFF1Adp[i+1][s | 1<<j]=min(dp[i+1][s | 1<<j] ,\\n\\t\\t\\t\\t\\tdp[i][s]\\uFF0C  //\\u524Di\\u4E2A\\u70B9\\u6709\\u4E9B\\u70B9\\u88AB\\u91CD\\u590D\\u4F7F\\u7528\\uFF1B\\n\\t\\t\\t\\t\\tdp[i+1][s]);  //\\u589E\\u52A0\\u4E86\\u4E00\\u4E2A\\u65B0\\u7684\\u70B9\\uFF1B\\n\\u5176\\u4E2Di\\u8868\\u793A\\u5DE6\\u8FB9\\u524Di\\u4E2A\\u70B9\\u3002s | 1<<j \\u8868\\u793A\\u7B2Cj\\u4E2A\\u70B9\\u88AB\\u8FDE\\u63A5\\u7684\\u65F6\\u5019\\uFF0C\\u53BB\\u7528\\u6240\\u6709s\\u66F4\\u65B0\\u6240\\u6709\\u7684s | i<<j\\u3002\\n\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        constexpr int kinf=1e9;\\n        const int m = cost.size();\\n        const int n = cost[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(1<<n,kinf));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                for(int s=0;s< 1<<n;++s){\\n                    dp[i+1][s|1<<j]=min({dp[i+1][s|1<<j],\\n                               dp[i][s]+cost[i][j],\\n                               dp[i+1][s]+cost[i][j]});\\n                }\\n            }\\n        }\\n        \\n        \\n        return dp[m].back();\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        constexpr int kinf=1e9;\\n        const int m = cost.size();\\n        const int n = cost[0].size();\\n        \\n        vector<vector<int>> dp(m+1, vector<int>(1<<n,kinf));\\n        \\n        dp[0][0]=0;\\n        \\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                for(int s=0;s< 1<<n;++s){\\n                    dp[i+1][s|1<<j]=min({dp[i+1][s|1<<j],\\n                               dp[i][s]+cost[i][j],\\n                               dp[i+1][s]+cost[i][j]}",
                "codeTag": "Java"
            },
            {
                "id": 858187,
                "title": "python3-top-down-dp",
                "content": "\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group \\n        \\n        @lru_cache(None)\\n        def fn(i, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if i == m: return sum(mn[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))\\n                \\n        return fn(0, 0)\\n```\\n\\nor symmetrically \\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in cost] # min cost of connecting points in 1st group \\n        \\n        @lru_cache(None)\\n        def fn(j, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if j == n: return sum(mn[i] for i in range(m) if not (mask & (1<<i)))\\n            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))\\n                \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in zip(*cost)] # min cost of connecting points in 2nd group \\n        \\n        @lru_cache(None)\\n        def fn(i, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if i == m: return sum(mn[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + fn(i+1, mask | 1<<j) for j in range(n))\\n                \\n        return fn(0, 0)\\n```\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m, n = len(cost), len(cost[0])\\n        mn = [min(x) for x in cost] # min cost of connecting points in 1st group \\n        \\n        @lru_cache(None)\\n        def fn(j, mask):\\n            \"\"\"Return min cost of connecting group1[i:] and group2 represented as mask.\"\"\"\\n            if j == n: return sum(mn[i] for i in range(m) if not (mask & (1<<i)))\\n            return min(cost[i][j] + fn(j+1, mask | 1<<i) for i in range(m))\\n                \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857089,
                "title": "java-top-down-dp-with-bit-mask",
                "content": "use mask to track which element is group2 (or b) is connected\\n1 calculate min cost from group2 to group1 for each node in group2\\n2 dfs + mem on each possible group1 node connection to group2 node\\n3 for the remaining unconnected nodes in group2, connect back to group1 with their minimal costs\\n```\\nInteger[][] mem;\\n    int aLen, bLen;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        mem = new Integer[13][1 << 12];\\n        aLen = cost.size();\\n        bLen = cost.get(0).size();\\n        int[] minCostFromBtoA = new int[bLen];\\n        Arrays.fill(minCostFromBtoA, Integer.MAX_VALUE);\\n        int res = 0;\\n        for (int b = 0; b < bLen; b++) {\\n            for (int a = 0; a < aLen; a++) {\\n                minCostFromBtoA[b] = Math.min(minCostFromBtoA[b], cost.get(a).get(b));\\n            }\\n        }\\n        return dfs(cost, minCostFromBtoA, 0, 0);\\n    }\\n\\n    private int dfs(List<List<Integer>> cost, int[] minCostFromBtoA, int a, int mask) {\\n        if (a == aLen) {\\n            int res = 0;\\n            for (int b = 0; b < bLen; b++) {\\n                if ((mask & (1 << b)) == 0) {\\n                    res += minCostFromBtoA[b];\\n                }\\n            }\\n            return mem[a][mask] = res;\\n        }\\n        if (mem[a][mask] != null) {\\n            return mem[a][mask];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int b = 0; b < bLen; b++) {\\n            res = Math.min(res, cost.get(a).get(b) + dfs(cost, minCostFromBtoA, a + 1, mask | (1 << b)));\\n        }\\n        return mem[a][mask] = res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nInteger[][] mem;\\n    int aLen, bLen;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        mem = new Integer[13][1 << 12];\\n        aLen = cost.size();\\n        bLen = cost.get(0).size();\\n        int[] minCostFromBtoA = new int[bLen];\\n        Arrays.fill(minCostFromBtoA, Integer.MAX_VALUE);\\n        int res = 0;\\n        for (int b = 0; b < bLen; b++) {\\n            for (int a = 0; a < aLen; a++) {\\n                minCostFromBtoA[b] = Math.min(minCostFromBtoA[b], cost.get(a).get(b));\\n            }\\n        }\\n        return dfs(cost, minCostFromBtoA, 0, 0);\\n    }\\n\\n    private int dfs(List<List<Integer>> cost, int[] minCostFromBtoA, int a, int mask) {\\n        if (a == aLen) {\\n            int res = 0;\\n            for (int b = 0; b < bLen; b++) {\\n                if ((mask & (1 << b)) == 0) {\\n                    res += minCostFromBtoA[b];\\n                }\\n            }\\n            return mem[a][mask] = res;\\n        }\\n        if (mem[a][mask] != null) {\\n            return mem[a][mask];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int b = 0; b < bLen; b++) {\\n            res = Math.min(res, cost.get(a).get(b) + dfs(cost, minCostFromBtoA, a + 1, mask | (1 << b)));\\n        }\\n        return mem[a][mask] = res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855055,
                "title": "dp-bitmasks-c",
                "content": "# **DP BITMASKS**\\nwe have in `mask_a` and `mask_b` the the numbers which haven\\u2019t been paired yet\\nso we find a number and find the best pairing with other set\\n\\nif `i`th bit is set in `mask` means `i`th number is not paired yet \\n\\n## **TRANSITIONS**\\n`dp[mask_a][mask_b] -> cost[i][j] + dp[unset i th bit in mask_a][unset j th bit in mask_b]`\\n\\n## **BASE CASE**\\n`dp[0][0] = 0`\\n\\n## **TIME COMPLEXITY**\\n`O(2^n * 2^m)`\\n\\n## **SPACE COMPLEXITY**\\n`O(2^n * 2^m)`\\n\\n## **CODE**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int go(vector<vector<int>> &cost, int mask_a, int mask_b)\\n    {\\n        if (mask_a == 0 and mask_b == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[mask_a][mask_b] != -1)\\n            return dp[mask_a][mask_b];\\n\\n        int ans = 1e9;\\n        if (mask_a != 0) {\\n\\t\\t\\t// last set bit in a\\n            int last_a = mask_a & - mask_a;\\n            int i = log2(last_a);\\n            for (int j = 0; j < cost[0].size(); j++) {\\n                if ((mask_a & last_a) != 0 or (mask_b & (1 << j)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ last_a);\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        if (mask_b != 0) {\\n\\t\\t\\t// last set bit in mask_b\\n            int last_b = mask_b & - mask_b;\\n            int j = log2(last_b);\\n            for (int i = 0; i < cost.size(); i++) {\\n                if ((mask_b & last_b) != 0 or (mask_a & (1 << i)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ (1<<i));\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        return dp[mask_a][mask_b] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        dp = vector<vector<int>> (1<<n, vector<int> (1<<m, -1));\\n        \\n        return go(cost, (1<<n) - 1, (1<<m) - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int go(vector<vector<int>> &cost, int mask_a, int mask_b)\\n    {\\n        if (mask_a == 0 and mask_b == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[mask_a][mask_b] != -1)\\n            return dp[mask_a][mask_b];\\n\\n        int ans = 1e9;\\n        if (mask_a != 0) {\\n\\t\\t\\t// last set bit in a\\n            int last_a = mask_a & - mask_a;\\n            int i = log2(last_a);\\n            for (int j = 0; j < cost[0].size(); j++) {\\n                if ((mask_a & last_a) != 0 or (mask_b & (1 << j)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ last_a);\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        if (mask_b != 0) {\\n\\t\\t\\t// last set bit in mask_b\\n            int last_b = mask_b & - mask_b;\\n            int j = log2(last_b);\\n            for (int i = 0; i < cost.size(); i++) {\\n                if ((mask_b & last_b) != 0 or (mask_a & (1 << i)) != 0) {\\n                    int new_mask_a = mask_a & (((1 << 30) - 1) ^ (1<<i));\\n                    int new_mask_b = mask_b & (((1 << 30) - 1) ^ (1 << j));\\n                    ans = min(ans, cost[i][j] + go(cost, new_mask_a, new_mask_b));\\n                }\\n            }\\n        }\\n        return dp[mask_a][mask_b] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        dp = vector<vector<int>> (1<<n, vector<int> (1<<m, -1));\\n        \\n        return go(cost, (1<<n) - 1, (1<<m) - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861834,
                "title": "java-dp-with-bitmask",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(); // size of set1\\n        int n = cost.get(0).size(); // size of set 2;\\n        \\n        int mask = 1 << m;\\n        int[] record = new int[mask]; // min cost to connect nodes in set 1 (of different states);\\n        Arrays.fill(record, Integer.MAX_VALUE);\\n        // since we use record to get the min cost of connecting nodes in set 1\\n        // we shall go through nodes in set 2 one by one, to make sure they are connected\\n        \\n        // base case:\\n        record[0] = 0;\\n        for (int col = 0; col < n; col ++){\\n            int[] tmpRecord = new int[mask];\\n            Arrays.fill(tmpRecord, Integer.MAX_VALUE);\\n            // try connection with each of the node in set 1 \\n            for (int row = 0; row < m; row++){           \\n                for (int msk = 0; msk < mask; msk++){\\n                    // the new min cost should be based on the cost record of connecting previous node in set 2;\\n                    int newMask =  msk | (1 << row);\\n                \\n                    if (record[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], record[msk] + cost.get(row).get(col));\\n                    }\\n                    \\n                    // if row nodes in this state has not been connected yet, and the msk is achievable by connecting the current node\\n                    // then check whether connect the current node multiple times will benefit the cost\\n                    if ((msk & (1 << row)) == 0 && tmpRecord[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], tmpRecord[msk] + cost.get(row).get(col));\\n                    }\\n                }\\n            }\\n            // use tmpRecord to update record\\n            record = tmpRecord;\\n        \\n        }\\n        \\n        return record[(1 << m) - 1];\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(); // size of set1\\n        int n = cost.get(0).size(); // size of set 2;\\n        \\n        int mask = 1 << m;\\n        int[] record = new int[mask]; // min cost to connect nodes in set 1 (of different states);\\n        Arrays.fill(record, Integer.MAX_VALUE);\\n        // since we use record to get the min cost of connecting nodes in set 1\\n        // we shall go through nodes in set 2 one by one, to make sure they are connected\\n        \\n        // base case:\\n        record[0] = 0;\\n        for (int col = 0; col < n; col ++){\\n            int[] tmpRecord = new int[mask];\\n            Arrays.fill(tmpRecord, Integer.MAX_VALUE);\\n            // try connection with each of the node in set 1 \\n            for (int row = 0; row < m; row++){           \\n                for (int msk = 0; msk < mask; msk++){\\n                    // the new min cost should be based on the cost record of connecting previous node in set 2;\\n                    int newMask =  msk | (1 << row);\\n                \\n                    if (record[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], record[msk] + cost.get(row).get(col));\\n                    }\\n                    \\n                    // if row nodes in this state has not been connected yet, and the msk is achievable by connecting the current node\\n                    // then check whether connect the current node multiple times will benefit the cost\\n                    if ((msk & (1 << row)) == 0 && tmpRecord[msk] != Integer.MAX_VALUE){\\n                        tmpRecord[newMask] = Math.min(tmpRecord[newMask], tmpRecord[msk] + cost.get(row).get(col));\\n                    }\\n                }\\n            }\\n            // use tmpRecord to update record\\n            record = tmpRecord;\\n        \\n        }\\n        \\n        return record[(1 << m) - 1];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538737,
                "title": "bitmask-dp-java-easy-to-understand-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    /*\\n        Idea :  For each point in first group:\\n                    try all possibilities to connect this point to some point in the second group.\\n                \\n                Now since \"each point in the second group must be connected to at least one point in the first group\", \\n                for each of points in second group which are not yet connected to any of the point in first group,\\n                connect it greedily (whose cost is minimum).\\n    \\n        Complexity : \\n        \\n        Let N be the size of first group.\\n        Let M be the size of second group.\\n        \\n        Time  : O(N * 2^M * M + M) ==> O(N * M * 2^M).\\n        Space : O(N * 2^M + M) ==> O(N * 2^M).\\n    */\\n    \\n    \\n    // map(j, cost) -> stores the min cost to connect jth point in the second group, to any of the point in first group.\\n    static Map<Integer, Integer> map = new HashMap<>(); \\n    static int[][] memo = new int[15][5000];\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        int m = cost.get(0).size();\\n        for (int j = 0; j < m; j++) {\\n            int min = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                min = Math.min(min, cost.get(i).get(j));\\n            }\\n            map.put(j, min);\\n        }\\n        for (int i = 0; i < 15; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return dp(cost, n, m, 0, 0);\\n    }\\n    private static int dp(List<List<Integer>> cost, int n, int m, int index, int mask) {\\n        if (memo[index][mask] != -1) {\\n            return memo[index][mask];\\n        }\\n        if (index == n) {\\n            // We have connected all points from the first group to some points in second group.\\n            // now, if some point in second group is not connected to any point in first group, we can connect it greedily.\\n            int costToConnectRemaining = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((mask & (1 << j)) == 0) {\\n                    costToConnectRemaining += map.get(j);\\n                }\\n            }\\n            return memo[index][mask] = costToConnectRemaining;\\n        }\\n        int minCost = Integer.MAX_VALUE;\\n        // try to connect ith point from first group to any of the point in second group, such that cost is minimized.\\n        for (int j = 0; j < m; j++) {\\n            int newMask = mask | (1 << j);\\n            int tempCost = dp(cost, n, m, index + 1, newMask) + cost.get(index).get(j);\\n            minCost = Math.min(minCost, tempCost);\\n        }\\n        return memo[index][mask] = minCost;\\n    }\\n}\\n```\\n\\nIf you like the solution, please Upvote \\uD83D\\uDC4D!!\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n        Idea :  For each point in first group:\\n                    try all possibilities to connect this point to some point in the second group.\\n                \\n                Now since \"each point in the second group must be connected to at least one point in the first group\", \\n                for each of points in second group which are not yet connected to any of the point in first group,\\n                connect it greedily (whose cost is minimum).\\n    \\n        Complexity : \\n        \\n        Let N be the size of first group.\\n        Let M be the size of second group.\\n        \\n        Time  : O(N * 2^M * M + M) ==> O(N * M * 2^M).\\n        Space : O(N * 2^M + M) ==> O(N * 2^M).\\n    */\\n    \\n    \\n    // map(j, cost) -> stores the min cost to connect jth point in the second group, to any of the point in first group.\\n    static Map<Integer, Integer> map = new HashMap<>(); \\n    static int[][] memo = new int[15][5000];\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        int m = cost.get(0).size();\\n        for (int j = 0; j < m; j++) {\\n            int min = Integer.MAX_VALUE;\\n            for (int i = 0; i < n; i++) {\\n                min = Math.min(min, cost.get(i).get(j));\\n            }\\n            map.put(j, min);\\n        }\\n        for (int i = 0; i < 15; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return dp(cost, n, m, 0, 0);\\n    }\\n    private static int dp(List<List<Integer>> cost, int n, int m, int index, int mask) {\\n        if (memo[index][mask] != -1) {\\n            return memo[index][mask];\\n        }\\n        if (index == n) {\\n            // We have connected all points from the first group to some points in second group.\\n            // now, if some point in second group is not connected to any point in first group, we can connect it greedily.\\n            int costToConnectRemaining = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((mask & (1 << j)) == 0) {\\n                    costToConnectRemaining += map.get(j);\\n                }\\n            }\\n            return memo[index][mask] = costToConnectRemaining;\\n        }\\n        int minCost = Integer.MAX_VALUE;\\n        // try to connect ith point from first group to any of the point in second group, such that cost is minimized.\\n        for (int j = 0; j < m; j++) {\\n            int newMask = mask | (1 << j);\\n            int tempCost = dp(cost, n, m, index + 1, newMask) + cost.get(index).get(j);\\n            minCost = Math.min(minCost, tempCost);\\n        }\\n        return memo[index][mask] = minCost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379410,
                "title": "c-recursion-memoization-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<int>>dp;\\n    \\n    \\n    int recurs(vector<vector<int>>& cost,vector<int>&v,int i,int mask)\\n    {\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        if(i<cost.size())\\n        {\\n            int res=INT_MAX;\\n            for(int j=0;j<cost[0].size();j++)\\n                res=min(res,recurs(cost,v,i+1,(mask|(1<<j)))+cost[i][j]);\\n            return dp[i][mask]=res;\\n        }\\n        else\\n        {\\n            int res=0;\\n            for(int  j=0;j<cost[0].size();j++)\\n                res+=v[j]*(!(mask&(1<<j)));\\n            return dp[i][mask]=res;   \\n        }\\n    }\\n    \\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        \\n        dp.resize(cost.size()+1,vector<int>(5000,-1));\\n        \\n        vector<int>v(cost[0].size(),0);\\n        \\n        for(int j=0;j<cost[0].size();j++)\\n        {\\n            int m=INT_MAX;\\n            for(int i=0;i<cost.size();i++)\\n                 m=min(m,cost[i][j]);\\n            v[j]=m;\\n        }\\n        \\n        \\n        return recurs(cost,v,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<int>>dp;\\n    \\n    \\n    int recurs(vector<vector<int>>& cost,vector<int>&v,int i,int mask)\\n    {\\n        \\n        if(dp[i][mask]!=-1)\\n            return dp[i][mask];\\n        \\n        if(i<cost.size())\\n        {\\n            int res=INT_MAX;\\n            for(int j=0;j<cost[0].size();j++)\\n                res=min(res,recurs(cost,v,i+1,(mask|(1<<j)))+cost[i][j]);\\n            return dp[i][mask]=res;\\n        }\\n        else\\n        {\\n            int res=0;\\n            for(int  j=0;j<cost[0].size();j++)\\n                res+=v[j]*(!(mask&(1<<j)));\\n            return dp[i][mask]=res;   \\n        }\\n    }\\n    \\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        \\n        \\n        dp.resize(cost.size()+1,vector<int>(5000,-1));\\n        \\n        vector<int>v(cost[0].size(),0);\\n        \\n        for(int j=0;j<cost[0].size();j++)\\n        {\\n            int m=INT_MAX;\\n            for(int i=0;i<cost.size();i++)\\n                 m=min(m,cost[i][j]);\\n            v[j]=m;\\n        }\\n        \\n        \\n        return recurs(cost,v,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114805,
                "title": "python-bfs-with-heapq-and-bit-tricks-90ms-beats-100",
                "content": "The special size handling at the top makes things a bit faster; taking all the zero-cost edges before BFS gives about 50% speed boost as well, although the code still beats 100% without those.\\n\\nThere are 3 optimizations over other BFS or DFS solutions that are big:\\n1. ```if first_mask != mask_i: ``` splits the case where the first group is matched, so we can greedily take the minimum cost edge for each second group vertex and add a \\'fully matched\\' entry to the queue.\\n2. ```i = ((first_mask + 1) & (-first_mask - 1)) ``` looks crazy if you\\'ve never seen it. This sets i to the least significant zero bit of first_mask. I highly suggest checking out Fenwick trees, since their implementation uses this trick. This works because: (x & -x) gives you the least significant bit of x, AND the LSB of x+1 is the first zero bit of x.\\n3. There are two types of edges we consider adding if we\\'ve chosen a vertex i in the first group: Edges (i, j) where j is also unmatched, or edges (i, j) where cost[i][j] is the smallest cost in row cost[i]\\n\\nFull code:\\n\\n```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tsize_i, size_j = len(cost), len(cost[0])\\n\\n\\t# Optimizations if we have <=2 columns\\n\\tif size_j == 1:\\n\\t\\treturn sum(row[0] for row in cost)\\n\\tif size_j == 2:\\n\\t\\ttot = min(cost[0])\\n\\t\\tused = (1 if tot==cost[0][0] else 2)  # bitmask for which column we\\'ve used\\n\\t\\tmin_extra = max(cost[0]) - tot  # extra cost to use the max value in this row\\n\\n\\t\\tfor j in range(1, size_i):\\n\\t\\t\\tmin_in_row = min(cost[j])\\n\\t\\t\\ttot += min_in_row\\n\\t\\t\\tmin_extra = min(min_in_row, max(cost[j])-min_in_row)\\n\\t\\t\\tused |= (1 if min_in_row == cost[j][0] else 2)\\n\\n\\t\\tif used == 3:  # used both cols already\\n\\t\\t\\treturn tot\\n\\t\\telse:  # One row needs to use a non-min element\\n\\t\\t\\treturn tot+min_extra\\n\\n\\tmask_i = (1 << size_i) - 1\\n\\tmask_j = (1 << size_j) - 1\\n\\tfully_connected = (mask_i, mask_j)\\n\\n\\tstart_row, start_col = 0, 0\\n\\tmin_by_col = [min([cost[i][col] for i in range(size_i)]) for col in range(size_j)] # Min value by column\\n\\n\\t# Always take any cost 0 edges\\n\\tfor j in range(size_j):\\n\\t\\tif min_by_col[j] == 0:\\n\\t\\t\\tstart_col += (1 << j)\\n\\tmin_by_row = [min(row) for row in cost]\\n\\tfor i in range(size_i):\\n\\t\\tif min_by_row[i] == 0:\\n\\t\\t\\tstart_row += (1 << i)\\n\\n\\tvisited = set()\\n\\tQ = [(0, start_row, start_col)]\\n\\n\\theapqpop = heapq.heappop\\n\\theapqpush = heapq.heappush\\n\\twhile True:\\n\\t\\ttotal_cost, first_mask, second_mask = heapqpop(Q)\\n\\n\\t\\tif (first_mask, second_mask) == fully_connected:\\n\\t\\t\\treturn total_cost\\n\\n\\t\\tif (first_mask, second_mask) in visited:\\n\\t\\t\\tcontinue\\n\\n\\t\\tvisited.add((first_mask, second_mask))\\n\\n\\t\\tif first_mask != mask_i:\\n\\t\\t\\ti = ((first_mask + 1) & (-first_mask - 1)) # Get the smallest unset bit of first_mask\\n\\t\\t\\tfirst_mask += i\\n\\t\\t\\ti = i.bit_length() - 1  # Convert bit to index\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:  # If jth col is currently edgeless\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + cost[i][j], first_mask, second_mask + shifted))\\n\\t\\t\\t\\telif cost[i][j] == min_by_row[i]:  # Or else (i,j) is i\\'s minimum weight edge\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + min_by_row[i], first_mask, second_mask))\\n\\t\\t\\t\\tshifted += shifted\\n\\n\\t\\telse:  # group 1 all matched, find cost to fill rest of the graph\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:\\n\\t\\t\\t\\t\\ttotal_cost += min_by_col[j]\\n\\t\\t\\t\\tshifted += shifted\\n\\t\\t\\theapqpush(Q, (total_cost, mask_i, mask_j))\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```if first_mask != mask_i: ```\n```i = ((first_mask + 1) & (-first_mask - 1)) ```\n```python\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tsize_i, size_j = len(cost), len(cost[0])\\n\\n\\t# Optimizations if we have <=2 columns\\n\\tif size_j == 1:\\n\\t\\treturn sum(row[0] for row in cost)\\n\\tif size_j == 2:\\n\\t\\ttot = min(cost[0])\\n\\t\\tused = (1 if tot==cost[0][0] else 2)  # bitmask for which column we\\'ve used\\n\\t\\tmin_extra = max(cost[0]) - tot  # extra cost to use the max value in this row\\n\\n\\t\\tfor j in range(1, size_i):\\n\\t\\t\\tmin_in_row = min(cost[j])\\n\\t\\t\\ttot += min_in_row\\n\\t\\t\\tmin_extra = min(min_in_row, max(cost[j])-min_in_row)\\n\\t\\t\\tused |= (1 if min_in_row == cost[j][0] else 2)\\n\\n\\t\\tif used == 3:  # used both cols already\\n\\t\\t\\treturn tot\\n\\t\\telse:  # One row needs to use a non-min element\\n\\t\\t\\treturn tot+min_extra\\n\\n\\tmask_i = (1 << size_i) - 1\\n\\tmask_j = (1 << size_j) - 1\\n\\tfully_connected = (mask_i, mask_j)\\n\\n\\tstart_row, start_col = 0, 0\\n\\tmin_by_col = [min([cost[i][col] for i in range(size_i)]) for col in range(size_j)] # Min value by column\\n\\n\\t# Always take any cost 0 edges\\n\\tfor j in range(size_j):\\n\\t\\tif min_by_col[j] == 0:\\n\\t\\t\\tstart_col += (1 << j)\\n\\tmin_by_row = [min(row) for row in cost]\\n\\tfor i in range(size_i):\\n\\t\\tif min_by_row[i] == 0:\\n\\t\\t\\tstart_row += (1 << i)\\n\\n\\tvisited = set()\\n\\tQ = [(0, start_row, start_col)]\\n\\n\\theapqpop = heapq.heappop\\n\\theapqpush = heapq.heappush\\n\\twhile True:\\n\\t\\ttotal_cost, first_mask, second_mask = heapqpop(Q)\\n\\n\\t\\tif (first_mask, second_mask) == fully_connected:\\n\\t\\t\\treturn total_cost\\n\\n\\t\\tif (first_mask, second_mask) in visited:\\n\\t\\t\\tcontinue\\n\\n\\t\\tvisited.add((first_mask, second_mask))\\n\\n\\t\\tif first_mask != mask_i:\\n\\t\\t\\ti = ((first_mask + 1) & (-first_mask - 1)) # Get the smallest unset bit of first_mask\\n\\t\\t\\tfirst_mask += i\\n\\t\\t\\ti = i.bit_length() - 1  # Convert bit to index\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:  # If jth col is currently edgeless\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + cost[i][j], first_mask, second_mask + shifted))\\n\\t\\t\\t\\telif cost[i][j] == min_by_row[i]:  # Or else (i,j) is i\\'s minimum weight edge\\n\\t\\t\\t\\t\\theapqpush(Q, (total_cost + min_by_row[i], first_mask, second_mask))\\n\\t\\t\\t\\tshifted += shifted\\n\\n\\t\\telse:  # group 1 all matched, find cost to fill rest of the graph\\n\\t\\t\\tshifted = 1\\n\\t\\t\\tfor j in range(size_j):\\n\\t\\t\\t\\tif (second_mask & shifted) == 0:\\n\\t\\t\\t\\t\\ttotal_cost += min_by_col[j]\\n\\t\\t\\t\\tshifted += shifted\\n\\t\\t\\theapqpush(Q, (total_cost, mask_i, mask_j))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1057230,
                "title": "simple-bitmask",
                "content": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        \\n        min_j = [1e9]*len(cost[0])\\n        \\n        for i in range (0, len(cost)):\\n            for j in range (0, len(cost[0])):\\n                min_j[j] = min(min_j[j], cost[i][j])\\n        \\n                \\n        @lru_cache(None )\\n        def recurse (i, mask):\\n            \\n            if i >= len(cost):\\n                total = 0 \\n                for j in range (0, len(cost[0])):\\n                    if mask & (1 << j) == 0: \\n                        total += min_j[j]\\n                return total\\n            \\n            \\n            total = 1e9\\n            for j in range (0, len(cost[0])):\\n                mask_ = mask | (1 << j) \\n                total = min(total, cost[i][j] + recurse(i+1, mask_))\\n            \\n            return total\\n        \\n        return recurse (0, 0)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        \\n        \\n        min_j = [1e9]*len(cost[0])\\n        \\n        for i in range (0, len(cost)):\\n            for j in range (0, len(cost[0])):\\n                min_j[j] = min(min_j[j], cost[i][j])\\n        \\n                \\n        @lru_cache(None )\\n        def recurse (i, mask):\\n            \\n            if i >= len(cost):\\n                total = 0 \\n                for j in range (0, len(cost[0])):\\n                    if mask & (1 << j) == 0: \\n                        total += min_j[j]\\n                return total\\n            \\n            \\n            total = 1e9\\n            for j in range (0, len(cost[0])):\\n                mask_ = mask | (1 << j) \\n                total = min(total, cost[i][j] + recurse(i+1, mask_))\\n            \\n            return total\\n        \\n        return recurse (0, 0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 932796,
                "title": "java-solution-dp-bitmask",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int[][] f = new int[m + 1][1 << n];\\n        for (int i = 0; i <= m; i++) {\\n            Arrays.fill(f[i], Integer.MAX_VALUE / 2);\\n        }\\n        f[0][0] = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int s = 0; s < 1 << n; s++) {\\n                for (int j = 0; j < n; j++) {\\n                    f[i + 1][s | 1 << j] = Math.min(\\n                        f[i + 1][s | 1 << j], \\n                        Math.min(\\n                            f[i + 1][s] + cost.get(i).get(j), \\n                            f[i][s] + cost.get(i).get(j)\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        return f[m][(1 << n) - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int[][] f = new int[m + 1][1 << n];\\n        for (int i = 0; i <= m; i++) {\\n            Arrays.fill(f[i], Integer.MAX_VALUE / 2);\\n        }\\n        f[0][0] = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int s = 0; s < 1 << n; s++) {\\n                for (int j = 0; j < n; j++) {\\n                    f[i + 1][s | 1 << j] = Math.min(\\n                        f[i + 1][s | 1 << j], \\n                        Math.min(\\n                            f[i + 1][s] + cost.get(i).get(j), \\n                            f[i][s] + cost.get(i).get(j)\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n        return f[m][(1 << n) - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880518,
                "title": "o-s1-3-s2-s2-using-bitmask-and-submask-trick",
                "content": "Quite astonished by people who managed to give O(2^{s2}*s1*s2) solutions. That\\'s worth reading.\\n\\nBut, here is one solution which requires less thinking, though I have to use submask trick introduced https://cp-algorithms.com/algebra/all-submasks.html. It can enumerate the submasks of all masks in O(3^n) time, not O(2^n*2^n)=O(4^n).\\n\\nThe idea is we maintain the min cost to cover each subset of S2. Initially, it\\'s {0,INF,INF,...}.\\nOnce we have the answer for first i elements of S1, we compute the answer for first i + 1 elements. We basically need to cover the diff of the new larger subset and the old smaller subset. Hence, for each new mask, we need to enumerate all submasks, this is where the submask enumeration trick comes in.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int s1 = cost.size(), s2 = cost[0].size();\\n        int INF=1E9;\\n        vector<int> mask_dp((1<<s2),INF);\\n        mask_dp[0] = 0;\\n        for (int i = 0; i < s1; ++i) {\\n            vector<int> new_mask_dp((1<<s2),INF);\\n            for (int new_mask = 0; new_mask < (1 << s2); ++new_mask) {\\n                for(int mask = new_mask;;mask=(mask-1)&new_mask){\\n                    int totcost = 0;\\n                    if (new_mask == mask) {\\n                        totcost = INF;\\n                        for (int j = 0; j < s2; ++j) {\\n                            if (mask & (1<<j)){\\n                                totcost = min(totcost, cost[i][j]);\\n                            }\\n                        }\\n                    }else{\\n                    for (int j = 0; j < s2; ++j) {\\n                        if (mask & (1 << j)) {\\n                            if ((new_mask & (1 << j)) == 0) {\\n                                totcost = INF;\\n                                break;\\n                            }\\n                        } else if (new_mask & (1 << j)) {\\n                            totcost += cost[i][j];\\n                        }\\n                    }\\n                    }\\n                    new_mask_dp[new_mask] = min(new_mask_dp[new_mask], mask_dp[mask] + totcost);\\n                    if(mask==0)break;\\n                }\\n            }\\n            mask_dp=new_mask_dp;\\n        }\\n        return mask_dp[(1<<s2)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int s1 = cost.size(), s2 = cost[0].size();\\n        int INF=1E9;\\n        vector<int> mask_dp((1<<s2),INF);\\n        mask_dp[0] = 0;\\n        for (int i = 0; i < s1; ++i) {\\n            vector<int> new_mask_dp((1<<s2),INF);\\n            for (int new_mask = 0; new_mask < (1 << s2); ++new_mask) {\\n                for(int mask = new_mask;;mask=(mask-1)&new_mask){\\n                    int totcost = 0;\\n                    if (new_mask == mask) {\\n                        totcost = INF;\\n                        for (int j = 0; j < s2; ++j) {\\n                            if (mask & (1<<j)){\\n                                totcost = min(totcost, cost[i][j]);\\n                            }\\n                        }\\n                    }else{\\n                    for (int j = 0; j < s2; ++j) {\\n                        if (mask & (1 << j)) {\\n                            if ((new_mask & (1 << j)) == 0) {\\n                                totcost = INF;\\n                                break;\\n                            }\\n                        } else if (new_mask & (1 << j)) {\\n                            totcost += cost[i][j];\\n                        }\\n                    }\\n                    }\\n                    new_mask_dp[new_mask] = min(new_mask_dp[new_mask], mask_dp[mask] + totcost);\\n                    if(mask==0)break;\\n                }\\n            }\\n            mask_dp=new_mask_dp;\\n        }\\n        return mask_dp[(1<<s2)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857938,
                "title": "c-dp-using-bit-masking-easy-to-understand",
                "content": "the idea is same as https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/855041/C%2B%2BPython-DP-using-mask\\n\\n\\n```\\nconst int INF = 1e9;\\n\\ntemplate <typename T>\\ninline void change_min(T& a, T b) {\\n  if (a > b) {\\n    a = b;\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  int connectTwoGroups(vector<vector<int>>& cost) {\\n    int N1 = cost.size();\\n    int N2 = cost[0].size();\\n\\n    vector<int> min_cost_from_two(N2, INF);\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        change_min(min_cost_from_two[i2], cost[i1][i2]);\\n      }\\n    }\\n\\n    vector<int> dp(1 << N2, INF);\\n    dp[0] = 0;\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      vector<int> next_dp(1 << N2, INF);\\n\\n      for (int bit = 0; bit < 1 << N2; ++bit) {\\n        for (int i2 = 0; i2 < N2; ++i2) {\\n          change_min(next_dp[bit | (1 << i2)], dp[bit] + cost[i1][i2]);\\n        }\\n      }\\n\\n      swap(dp, next_dp);\\n    }\\n\\n    int res = INF;\\n\\n    for (int bit = 0; bit < 1 << N2; ++bit) {\\n      int r = dp[bit];\\n\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        if ((bit & (1 << i2)) == 0) {\\n          r += min_cost_from_two[i2];\\n        }\\n      }\\n\\n      change_min(res, r);\\n    }\\n\\n    return res;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nconst int INF = 1e9;\\n\\ntemplate <typename T>\\ninline void change_min(T& a, T b) {\\n  if (a > b) {\\n    a = b;\\n  }\\n}\\n\\nclass Solution {\\n public:\\n  int connectTwoGroups(vector<vector<int>>& cost) {\\n    int N1 = cost.size();\\n    int N2 = cost[0].size();\\n\\n    vector<int> min_cost_from_two(N2, INF);\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        change_min(min_cost_from_two[i2], cost[i1][i2]);\\n      }\\n    }\\n\\n    vector<int> dp(1 << N2, INF);\\n    dp[0] = 0;\\n\\n    for (int i1 = 0; i1 < N1; ++i1) {\\n      vector<int> next_dp(1 << N2, INF);\\n\\n      for (int bit = 0; bit < 1 << N2; ++bit) {\\n        for (int i2 = 0; i2 < N2; ++i2) {\\n          change_min(next_dp[bit | (1 << i2)], dp[bit] + cost[i1][i2]);\\n        }\\n      }\\n\\n      swap(dp, next_dp);\\n    }\\n\\n    int res = INF;\\n\\n    for (int bit = 0; bit < 1 << N2; ++bit) {\\n      int r = dp[bit];\\n\\n      for (int i2 = 0; i2 < N2; ++i2) {\\n        if ((bit & (1 << i2)) == 0) {\\n          r += min_cost_from_two[i2];\\n        }\\n      }\\n\\n      change_min(res, r);\\n    }\\n\\n    return res;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855333,
                "title": "python-dp-top-down",
                "content": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        import functools\\n        \\n        src_size = len(cost)\\n        tgt_size = len(cost[0])\\n        tgt_mask = (1 << tgt_size) - 1\\n        INFTY = 1e19\\n        \\n        @functools.lru_cache(None)\\n        def find(n: int, taken: bool, idx: int, mask: int) -> int:\\n            if n == src_size:\\n                return INFTY if (mask & tgt_mask) != tgt_mask else 0\\n            if idx == tgt_size:\\n                return INFTY if not taken else find(n + 1, False, 0, mask)\\n            \\n            curr = find(n, taken, idx + 1, mask)\\n            sub_cost = find(n, True, idx + 1, (mask | (1 << idx)))\\n            if sub_cost < INFTY:\\n                curr = min(cost[n][idx] + sub_cost, curr)\\n            return curr\\n        \\n        return find(0, False, 0, 0)\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        import functools\\n        \\n        src_size = len(cost)\\n        tgt_size = len(cost[0])\\n        tgt_mask = (1 << tgt_size) - 1\\n        INFTY = 1e19\\n        \\n        @functools.lru_cache(None)\\n        def find(n: int, taken: bool, idx: int, mask: int) -> int:\\n            if n == src_size:\\n                return INFTY if (mask & tgt_mask) != tgt_mask else 0\\n            if idx == tgt_size:\\n                return INFTY if not taken else find(n + 1, False, 0, mask)\\n            \\n            curr = find(n, taken, idx + 1, mask)\\n            sub_cost = find(n, True, idx + 1, (mask | (1 << idx)))\\n            if sub_cost < INFTY:\\n                curr = min(cost[n][idx] + sub_cost, curr)\\n            return curr\\n        \\n        return find(0, False, 0, 0)\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 855173,
                "title": "simple-c-dp-solution",
                "content": "```\\n public class Solution\\n    {\\n        private void Helper(IList<IList<int>> cost, int?[,] dp, int idx, int maskRight)\\n        {\\n            checked\\n            {\\n\\n                if (dp[idx, maskRight].HasValue)\\n                {\\n                    return;\\n                }\\n\\n                int n = cost.Count;\\n                int m = cost[0].Count;\\n\\n                int powM = 1 << m;\\n\\n                if (idx == n && maskRight == powM - 1)\\n                {\\n                    dp[idx, maskRight] = 0;\\n                    return;\\n                }\\n\\n                if (idx == n && maskRight != powM - 1)\\n                {\\n                    dp[idx, maskRight] = int.MaxValue;\\n                    return;\\n                }\\n\\n                int res = int.MaxValue;\\n\\n                for (int j = 0; j < m; j++)\\n                {\\n                    var newRightMask = maskRight | (1 << j);\\n                    var costThis = cost[idx][j];\\n                    Helper(cost, dp, idx + 1, newRightMask);\\n\\n                    var inner = dp[idx + 1, newRightMask].Value;\\n                    if (inner != int.MaxValue)\\n                    {\\n                        res = Math.Min(res, costThis + inner);\\n                    }\\n\\n                    if (newRightMask != maskRight)\\n                    {\\n                        Helper(cost, dp, idx, newRightMask);\\n                        var cand = dp[idx, newRightMask].Value;\\n                        if (cand != int.MaxValue)\\n                        {\\n                            res = Math.Min(res, costThis + cand);\\n                        }\\n                    }\\n                }\\n\\n\\n                dp[idx, maskRight] = res;\\n            }\\n        }\\n\\n        public int ConnectTwoGroups(IList<IList<int>> cost)\\n        {\\n            int n = cost.Count;\\n            int m = cost[0].Count;\\n\\n            int powM = 1 << m;\\n\\n            int?[,] dp = new int?[n + 1,powM];\\n            Helper(cost, dp, 0, 0);\\n            return dp[0, 0].Value;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n public class Solution\\n    {\\n        private void Helper(IList<IList<int>> cost, int?[,] dp, int idx, int maskRight)\\n        {\\n            checked\\n            {\\n\\n                if (dp[idx, maskRight].HasValue)\\n                {\\n                    return;\\n                }\\n\\n                int n = cost.Count;\\n                int m = cost[0].Count;\\n\\n                int powM = 1 << m;\\n\\n                if (idx == n && maskRight == powM - 1)\\n                {\\n                    dp[idx, maskRight] = 0;\\n                    return;\\n                }\\n\\n                if (idx == n && maskRight != powM - 1)\\n                {\\n                    dp[idx, maskRight] = int.MaxValue;\\n                    return;\\n                }\\n\\n                int res = int.MaxValue;\\n\\n                for (int j = 0; j < m; j++)\\n                {\\n                    var newRightMask = maskRight | (1 << j);\\n                    var costThis = cost[idx][j];\\n                    Helper(cost, dp, idx + 1, newRightMask);\\n\\n                    var inner = dp[idx + 1, newRightMask].Value;\\n                    if (inner != int.MaxValue)\\n                    {\\n                        res = Math.Min(res, costThis + inner);\\n                    }\\n\\n                    if (newRightMask != maskRight)\\n                    {\\n                        Helper(cost, dp, idx, newRightMask);\\n                        var cand = dp[idx, newRightMask].Value;\\n                        if (cand != int.MaxValue)\\n                        {\\n                            res = Math.Min(res, costThis + cand);\\n                        }\\n                    }\\n                }\\n\\n\\n                dp[idx, maskRight] = res;\\n            }\\n        }\\n\\n        public int ConnectTwoGroups(IList<IList<int>> cost)\\n        {\\n            int n = cost.Count;\\n            int m = cost[0].Count;\\n\\n            int powM = 1 << m;\\n\\n            int?[,] dp = new int?[n + 1,powM];\\n            Helper(cost, dp, 0, 0);\\n            return dp[0, 0].Value;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855079,
                "title": "dp-bitmasking-top-down-approach",
                "content": "```\\n\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n    \\n        \\n        @lru_cache(None)\\n        def helper(i, rem):   # rem represents cols which we have not matched yet, i represents current index (row)\\n            if i==rows:\\n                ans = 0\\n                for j in range(cols):\\n                    if not rem & 1<<j:          # check colums whose bits are not set\\n                        m = float(\\'inf\\')\\n                        for r in range(0, rows):\\n                            m = min(m, cost[r][int(j)])\\n                        ans += m\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(0, cols):       # try matching ith row with any col\\n                nrem = rem | 1<<j           # when a column is matched, set its bit\\n                ans = min(ans, cost[i][j]+helper(i+1, nrem))\\n            \\n            return ans\\n        \\n        \\n        return helper(0, 0)",
                "solutionTags": [],
                "code": "```\\n\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n    \\n        \\n        @lru_cache(None)\\n        def helper(i, rem):   # rem represents cols which we have not matched yet, i represents current index (row)\\n            if i==rows:\\n                ans = 0\\n                for j in range(cols):\\n                    if not rem & 1<<j:          # check colums whose bits are not set\\n                        m = float(\\'inf\\')\\n                        for r in range(0, rows):\\n                            m = min(m, cost[r][int(j)])\\n                        ans += m\\n                return ans\\n            \\n            ans = float(\\'inf\\')\\n            for j in range(0, cols):       # try matching ith row with any col\\n                nrem = rem | 1<<j           # when a column is matched, set its bit\\n                ans = min(ans, cost[i][j]+helper(i+1, nrem))\\n            \\n            return ans\\n        \\n        \\n        return helper(0, 0)",
                "codeTag": "Python3"
            },
            {
                "id": 4050908,
                "title": "bitsmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int size1 = cost.size();\\n        int size2 = cost[0].size();\\n        \\n        vector<vector<int>> dp(size1, vector<int>(1 << size2, -1));\\n        \\n        function<int(int, int)> dfs = [&](int p1, int mask) -> int {\\n            if (p1 == size1) {\\n                int total_cost = 0;\\n                for (int p2 = 0; p2 < size2; ++p2) {\\n                    if (!(mask & (1 << p2))) {\\n                        int min_cost = INT_MAX;\\n                        for (int p1 = 0; p1 < size1; ++p1) {\\n                            min_cost = min(min_cost, cost[p1][p2]);\\n                        }\\n                        total_cost += min_cost;\\n                    }\\n                }\\n                cout<<mask<<\" \"<<total_cost<<endl;\\n                return total_cost;\\n            }\\n            \\n            if (dp[p1][mask] != -1) {\\n                return dp[p1][mask];\\n            }\\n            \\n            int result = INT_MAX;\\n            for (int p2 = 0; p2 < size2; ++p2) {\\n                result = min(result, cost[p1][p2] + dfs(p1 + 1, mask | (1 << p2)));\\n            }\\n            \\n            dp[p1][mask] = result;\\n            return result;\\n        };\\n        \\n        return dfs(0, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int size1 = cost.size();\\n        int size2 = cost[0].size();\\n        \\n        vector<vector<int>> dp(size1, vector<int>(1 << size2, -1));\\n        \\n        function<int(int, int)> dfs = [&](int p1, int mask) -> int {\\n            if (p1 == size1) {\\n                int total_cost = 0;\\n                for (int p2 = 0; p2 < size2; ++p2) {\\n                    if (!(mask & (1 << p2))) {\\n                        int min_cost = INT_MAX;\\n                        for (int p1 = 0; p1 < size1; ++p1) {\\n                            min_cost = min(min_cost, cost[p1][p2]);\\n                        }\\n                        total_cost += min_cost;\\n                    }\\n                }\\n                cout<<mask<<\" \"<<total_cost<<endl;\\n                return total_cost;\\n            }\\n            \\n            if (dp[p1][mask] != -1) {\\n                return dp[p1][mask];\\n            }\\n            \\n            int result = INT_MAX;\\n            for (int p2 = 0; p2 < size2; ++p2) {\\n                result = min(result, cost[p1][p2] + dfs(p1 + 1, mask | (1 << p2)));\\n            }\\n            \\n            dp[p1][mask] = result;\\n            return result;\\n        };\\n        \\n        return dfs(0, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4038898,
                "title": "easy-to-understand-c-bitmask-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int g1ind,int mask,vector<vector<int>>& cost,vector<int> &g2cost,int n,int m,vector<vector<int>> &dp){\\n        if(g1ind==n){\\n            int s=0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1<<j))==0){\\n                    s+=g2cost[j];\\n\\n                }\\n            }\\n            return s;\\n        }\\n        if(dp[g1ind][mask]!=-1)return dp[g1ind][mask];\\n\\n        int sumcost=INT_MAX;\\n        for(int j=0;j<m;j++){\\n                int pick=cost[g1ind][j];\\n                sumcost=min(sumcost,pick+dfs(g1ind+1,mask | (1<<j),cost,g2cost,n,m,dp));\\n        }\\n        return dp[g1ind][mask]=sumcost;\\n\\n    }\\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<int> g2cost(m,500);\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<n;i++){\\n                g2cost[j]=min(g2cost[j],cost[i][j]);\\n            }\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>((1<<m),-1));\\n    //    dfs(0,0,cost,g2cost,n,m);\\n   //     for(auto it:g2cost)cout<<it<<\" \";\\n        return dfs(0,0,cost,g2cost,n,m,dp);;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int g1ind,int mask,vector<vector<int>>& cost,vector<int> &g2cost,int n,int m,vector<vector<int>> &dp){\\n        if(g1ind==n){\\n            int s=0;\\n            for(int j=0;j<m;j++){\\n                if((mask & (1<<j))==0){\\n                    s+=g2cost[j];\\n\\n                }\\n            }\\n            return s;\\n        }\\n        if(dp[g1ind][mask]!=-1)return dp[g1ind][mask];\\n\\n        int sumcost=INT_MAX;\\n        for(int j=0;j<m;j++){\\n                int pick=cost[g1ind][j];\\n                sumcost=min(sumcost,pick+dfs(g1ind+1,mask | (1<<j),cost,g2cost,n,m,dp));\\n        }\\n        return dp[g1ind][mask]=sumcost;\\n\\n    }\\n\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<int> g2cost(m,500);\\n        for(int j=0;j<m;j++){\\n            for(int i=0;i<n;i++){\\n                g2cost[j]=min(g2cost[j],cost[i][j]);\\n            }\\n        }\\n        vector<vector<int>> dp(n+1,vector<int>((1<<m),-1));\\n    //    dfs(0,0,cost,g2cost,n,m);\\n   //     for(auto it:g2cost)cout<<it<<\" \";\\n        return dfs(0,0,cost,g2cost,n,m,dp);;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4035650,
                "title": "c-python-bitmask-dp-solution-with-explanation",
                "content": "\\n### bitmask dp\\ndp[i][mask] is min cost when first i element of group n (row) and bitmask of group m (column) have matched, a bit of 1 means a element is matched.\\n\\nWe can use i-th element to match a element in the other group.\\n\\nWe have 3 choice,\\n\\nif i-th element have matched, we can match it again with a element is not matched, \\ndp[i][mask ^ (1 << j)] + cost[i][j] where mask ^ (1 << j) is to remove a matched element.\\n\\nif i-th element is not matched, we can match it with a element is not matched, \\ndp[i-1][mask ^ (1 << j)] + cost[i][j] where mask ^ (1 << j) is to remove a matched element.\\n\\nor, match it with a element have matched, \\ndp[i-1][mask] + cost[i][j].\\n\\nAnd choose min cost.\\n\\nWe can use 2 1-d arrays to indicate dp[i] and dp[i-1].\\n\\ntc is O(n * m * 2^m), sc is O(2^m)\\ndp[-1][0] = 0, dp[-1][.] = inf.\\ndp[i][.] = inf.\\n### python\\n```python\\ninf = int(1e9+7)\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m = len(cost), len(cost[0])\\n        dp_0 = [inf] * (1 << m)\\n        dp_1 = [inf] * (1 << m)\\n        dp_0[0] = 0\\n        for i in range(n):\\n            for mask in range(1, 1 << m):\\n                for j in range(m):\\n                    if mask >> j & 1:\\n                        dp_1[mask] = min(dp_1[mask], dp_0[mask ^ (1 << j)] + cost[i][j], dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])\\n            dp_0, dp_1 = dp_1, dp_0\\n            for mask in range(1 << m): dp_1[mask] = inf\\n        return dp_0[(1 << m) - 1]\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        vector<int> dp_0 (1 << m, 1e9+7), dp_1 (1 << m, 1e9+7);\\n        dp_0[0] = 0;\\n        for (int i = 0; i < n; i+=1) {\\n            for (int mask = 1; mask < 1 << m; mask+=1) {\\n                for (int j = 0; j < m; j+=1) {\\n                    if (mask >> j & 1)\\n                        dp_1[mask] = min(dp_1[mask], min(dp_0[mask ^ (1 << j)] + cost[i][j], min(dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])));\\n                }\\n            }\\n            swap(dp_0, dp_1);\\n            for (int j = 0; j < 1 << m; j+=1) dp_1[j] = 1e9+7;\\n        }\\n        return dp_0[(1 << m) - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```python\\ninf = int(1e9+7)\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        n, m = len(cost), len(cost[0])\\n        dp_0 = [inf] * (1 << m)\\n        dp_1 = [inf] * (1 << m)\\n        dp_0[0] = 0\\n        for i in range(n):\\n            for mask in range(1, 1 << m):\\n                for j in range(m):\\n                    if mask >> j & 1:\\n                        dp_1[mask] = min(dp_1[mask], dp_0[mask ^ (1 << j)] + cost[i][j], dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])\\n            dp_0, dp_1 = dp_1, dp_0\\n            for mask in range(1 << m): dp_1[mask] = inf\\n        return dp_0[(1 << m) - 1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        vector<int> dp_0 (1 << m, 1e9+7), dp_1 (1 << m, 1e9+7);\\n        dp_0[0] = 0;\\n        for (int i = 0; i < n; i+=1) {\\n            for (int mask = 1; mask < 1 << m; mask+=1) {\\n                for (int j = 0; j < m; j+=1) {\\n                    if (mask >> j & 1)\\n                        dp_1[mask] = min(dp_1[mask], min(dp_0[mask ^ (1 << j)] + cost[i][j], min(dp_1[mask ^ (1 << j)] + cost[i][j], dp_0[mask] + cost[i][j])));\\n                }\\n            }\\n            swap(dp_0, dp_1);\\n            for (int j = 0; j < 1 << m; j+=1) dp_1[j] = 1e9+7;\\n        }\\n        return dp_0[(1 << m) - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031976,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec (int ind,int mask,vector<vector<int>>& cost,vector<vector<int>>&dp,vector<int>&mini)\\n    {\\n       if (dp[ind][mask]!=-1) return dp[ind][mask];\\n       int res=ind>=cost.size()?0:1e8;\\n       if (ind>=cost.size())\\n       {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               if ((mask&(1<<j))==0)\\n               {\\n                   res+=mini[j];\\n               }\\n           }\\n       }\\n       else {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               res=min(res,cost[ind][j]+rec(ind+1,mask | (1<<j),cost,dp,mini));\\n           }\\n       }\\n       return dp[ind][mask]=res;\\n\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        vector<vector<int>>dp(13,vector<int>(4096,-1));\\n        vector<int>mini(cost[0].size(),INT_MAX);\\n        for (int j=0;j<cost[0].size();j++)\\n        {\\n            for (int i=0;i<cost.size();i++)\\n            {\\n                mini[j]=min(mini[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp,mini);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec (int ind,int mask,vector<vector<int>>& cost,vector<vector<int>>&dp,vector<int>&mini)\\n    {\\n       if (dp[ind][mask]!=-1) return dp[ind][mask];\\n       int res=ind>=cost.size()?0:1e8;\\n       if (ind>=cost.size())\\n       {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               if ((mask&(1<<j))==0)\\n               {\\n                   res+=mini[j];\\n               }\\n           }\\n       }\\n       else {\\n           for (int j=0;j<cost[0].size();j++)\\n           {\\n               res=min(res,cost[ind][j]+rec(ind+1,mask | (1<<j),cost,dp,mini));\\n           }\\n       }\\n       return dp[ind][mask]=res;\\n\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        vector<vector<int>>dp(13,vector<int>(4096,-1));\\n        vector<int>mini(cost[0].size(),INT_MAX);\\n        for (int j=0;j<cost[0].size();j++)\\n        {\\n            for (int i=0;i<cost.size();i++)\\n            {\\n                mini[j]=min(mini[j],cost[i][j]);\\n            }\\n        }\\n        return rec(0,0,cost,dp,mini);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848233,
                "title": "lru-cache-for-speed-memo-if-memory-pick-your-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA recursive solution can work well if you start to break down what the problem asks in concrete steps \\n\\nFor any graph of costs, there exists a min cost per column \\nIf we know the min cost per column, then we can map out our cheapest connection via graph exploration \\n\\nThis is an iterative depth first based approach, and so needs memoization \\n\\nIf you have memory to spare, deepen as needed and use the lru cache. This will optimize time. If you don\\'t have memory to spare, deepen while storing results in a memo. This will optimize space. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet dimension of graphical space in rows and cols. \\nGet min value in column using zip and * to unpack cost into a min list\\nMake a memo \\n\\nUse lru cache if speed is important \\n\\ndfs takes a row index and bitmask \\n- if (rowindex, bitmask) in memo return that \\n- elif row index is rows, calc as described in approach and memoize\\n    - return memoized value  \\n- else calc min of cost at row index, col index + dfs(row index + 1, bitmask | (1 << col_index)) for col index in range cols and memoize \\n    - return memoized value \\n\\nTo solve, do dfs based approach from root of 0, 0 \\n\\n\\n# Complexity\\n- Time complexity : O(N log N)\\n    - We end up exploring subtrees of size N log N due to memoization \\n\\n\\n- Space complexity : O(N log N)\\n    - As above but for storage of results  \\n\\nOne interesting takeaway is that various memo values at the end of one of the top runs could have union find done on them to speed up valuations later on. This may be of interest to some. \\n\\nDetailed walkthrough of example 3 in the code. \\n\\n# Code\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        # set result as min cost in each cost set -> histogram intersection style \\n        min_value_in_column = [min(costs_i) for costs_i in zip(*cost)]\\n        self.memo = dict()\\n\\n        @lru_cache(None)\\n        def dfs(row_index, bitmask) : \\n            if (row_index, bitmask) in self.memo :\\n                return self.memo[(row_index, bitmask)] \\n            elif row_index == rows : \\n                # return sum of min values in column for col index not in bitmask  \\n                # bitmask & 1 << col_index == 0 -> least significant bit is 0 \\n                # this means that bitmask & (1 << col_i) match up -> this means we have this col index \\n                self.memo[(row_index, bitmask)] = sum(min_value_in_column[col_i] for col_i in range(cols) if not (bitmask & (1 << col_i)))\\n                return self.memo[(row_index, bitmask)]\\n            else : \\n                # otherwise, return minimum of cost at row index and col index + dfs(row_index + 1, mask union with (1 << col_index)) \\n                # which means, return cost found at row and col + dfs result of next row index if we join this col index to our bitmask (adds if not present) \\n                # which is done for col index in range cols \\n                # this means we take value at row and col and add to it the recursive value of the next row if we take the col index into the bitmask\\n                # this is done for each col index in range cols -> this finds the minimum then of this row item values plus next row items values recursively   \\n                self.memo[(row_index, bitmask)] = min(cost[row_index][col_index] + dfs(row_index + 1, bitmask | (1 << col_index)) for col_index in range(cols))\\n                return self.memo[(row_index, bitmask)]\\n        # from the first row index with an empty mask \\n        # go until the last row index where \\n            # along the way to the last row index \\n            # for each row index consider each col index elements value with each next row index to rows \\n                # where upon reaching the last row in this manner you return the sum of the minimal items \\n                    # for which you have selected such a mask as you go along \\n        \\'\\'\\'\\n            Example 3 \\n            result -> [2, 1, 1]\\n\\n            2   5   1       0 row index, 0 bitmask goes in, must find following \\n            3   4   7       find min of (2 + dfs(1, 1), 5 + dfs(1, 2), 1 + dfs(1, 4))\\n            8   1   2   ->  dfs(1, 1) -> find min (3 + dfs(2, 1), 4 + dfs(2, 3), 7 + dfs(2, 5))\\n            6   2   4           dfs(2, 1) -> find min (8 + dfs(3, 1), 1 + dfs(3, 3), 2 + dfs(3, 5))\\n            3   8   8               dfs(3, 1) -> find min (6 + dfs(4, 1), 2 + dfs(4, 3), 4 + dfs(4, 5))\\n                                        dfs(4, 1) -> find min (3 + 2, 8 + 2, 8 + 4)\\n                                            dfs(5, 1) -> for col 0, 1 has a value in col 0, so bitmask & (1 << col_i) is 1 -> so we skip this value. But other two we would get 0, so we add them for 2. \\n                                            dfs(5, 3) -> for col 1, b1 does not have value in col 1 which is like saying it does not have the second column -> add this value  -> result is 2 \\n                                            dfs(5, 5) -> as above for col 2 -> total is now 2 for the first, and 2 for the other two, total is 4\\n                                            dfs(5, 7) -> 0 \\n                                        dfs(4, 1) -> so our first result is 3 + 2 is 5 \\n                                        dfs(4, 2) -> min(3 + 2, 8 + dfs(5, 2), 8 + dfs(5, 6)) -> 5 \\n                                        dfs(4, 3) -> min(3 + dfs(5, 3), 8 + dfs(5, 3), 8 + dfs(5, 7)) -> min (3 + 2, 8 + 2, 8 + 0) -> result is 5\\n                                        dfs(4, 4) -> min(3 + dfs(5, 5), 8 + dfs(5, 4), 8 + dfs(5, 6)) -> 7\\n                                        dfs(4, 6) -> min(3 + dfs(5, 7), 8 + dfs(5, 6), 8 + dfs(5, 6)) -> result is 3\\n                                        dfs(4, 5) -> min(3 + dfs(5, 5), 8 + dfs(5, 7), 8 + dfs(5, 5)) -> min (3 + 4, 8 + 0, 8 + 4) -> result is 7\\n                                        dfs(4, 7) -> min(3 + dfs(5, 7),  8 + dfs(5, 7), 8 + dfs(5, 7)) -> min (3, 8, 8) -> 3 \\n                                    dfs(3, 1) -> min (6 + 5, 2 + 5, 4 + 7) -> 7 \\n                                    dfs(3, 2) -> min (6 + 5, 2 + 5, 4+3) -> 7\\n                                    dfs(3, 3) -> min (6 + dfs(4, 3), 2 + dfs(4, 3), 4 + dfs(4, 7))\\n                                              -> min (6 + 5, 2 + 5, 4 + 3) -> 7\\n                                    dfs(3, 4) -> min (6 + 7, 2 + 7, 4+3) -> 7 \\n                                    dfs(3, 5) -> min(6 + dfs(4, 5), 2 + dfs(4, 7), 4 + dfs(4, 5))\\n                                              -> min(6 + 7, 2 + 3, 4 + 7) -> 5\\n                                    dfs(3, 6) -> min(6 + 3, 2 + 3, 4 + 3) -> 5\\n                                    dfs(3, 7) -> min(6 + dfs(4, 7), 2 + dfs(4, 7), 4+dfs(4, 7))\\n                                              -> min(6 + 3, 2 + 3, 4 + 3) -> 5  \\n                                dfs(2, 1) -> (8 + 7, 1 + 7, 2 + 5) -> 7 \\n                                dfs(2, 3) -> find min (8 + dfs(3, 3), 1 + dfs(3, 3), 2 + dfs(3, 7))\\n                                          ->      min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 4) -> (8 + 5, 1 + 5, 2 + 7) -> 6\\n                                dfs(2, 5) -> find min (8 + dfs(3, 5), 1 + dfs(3, 7), 2 + dfs(3, 5))\\n                                          ->      min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 2)         min (8 + dfs(3, 3), 1 + dfs(3, 2), 2 + dfs(3, 6))\\n                                                  min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 6) ->      min (8 + dfs(3, 7), 1 + dfs(3, 6), 2 + dfs(3, 6))\\n                                                  min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 7) ->      min (8 + dfs(3, 7), 1 + dfs(3, 7), 2 + dfs(3, 7)) -> 6\\n                            dfs(1, 1) -> min(3 + 7, 4 + 7, 7 + 6) -> 10 \\n                        dfs(0, 0) -> min(2 + 10, 5 + dfs(1, 2), 1 + dfs(1, 4))\\n                            dfs(1, 2) -> min(3 + dfs(2, 3), 4 + dfs(2, 2), 7+ dfs(2, 6))\\n                                      -> min(3 + 7, 4 + 7, 7 + 6) -> 10\\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + dfs(1, 4)) \\n                            dfs(1, 4) -> min(3 + 6, 4 + 6, 7 +  6) -> 9 \\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + 9) -> 10\\n        \\'\\'\\'        \\n\\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        # set result as min cost in each cost set -> histogram intersection style \\n        min_value_in_column = [min(costs_i) for costs_i in zip(*cost)]\\n        self.memo = dict()\\n\\n        @lru_cache(None)\\n        def dfs(row_index, bitmask) : \\n            if (row_index, bitmask) in self.memo :\\n                return self.memo[(row_index, bitmask)] \\n            elif row_index == rows : \\n                # return sum of min values in column for col index not in bitmask  \\n                # bitmask & 1 << col_index == 0 -> least significant bit is 0 \\n                # this means that bitmask & (1 << col_i) match up -> this means we have this col index \\n                self.memo[(row_index, bitmask)] = sum(min_value_in_column[col_i] for col_i in range(cols) if not (bitmask & (1 << col_i)))\\n                return self.memo[(row_index, bitmask)]\\n            else : \\n                # otherwise, return minimum of cost at row index and col index + dfs(row_index + 1, mask union with (1 << col_index)) \\n                # which means, return cost found at row and col + dfs result of next row index if we join this col index to our bitmask (adds if not present) \\n                # which is done for col index in range cols \\n                # this means we take value at row and col and add to it the recursive value of the next row if we take the col index into the bitmask\\n                # this is done for each col index in range cols -> this finds the minimum then of this row item values plus next row items values recursively   \\n                self.memo[(row_index, bitmask)] = min(cost[row_index][col_index] + dfs(row_index + 1, bitmask | (1 << col_index)) for col_index in range(cols))\\n                return self.memo[(row_index, bitmask)]\\n        # from the first row index with an empty mask \\n        # go until the last row index where \\n            # along the way to the last row index \\n            # for each row index consider each col index elements value with each next row index to rows \\n                # where upon reaching the last row in this manner you return the sum of the minimal items \\n                    # for which you have selected such a mask as you go along \\n        \\'\\'\\'\\n            Example 3 \\n            result -> [2, 1, 1]\\n\\n            2   5   1       0 row index, 0 bitmask goes in, must find following \\n            3   4   7       find min of (2 + dfs(1, 1), 5 + dfs(1, 2), 1 + dfs(1, 4))\\n            8   1   2   ->  dfs(1, 1) -> find min (3 + dfs(2, 1), 4 + dfs(2, 3), 7 + dfs(2, 5))\\n            6   2   4           dfs(2, 1) -> find min (8 + dfs(3, 1), 1 + dfs(3, 3), 2 + dfs(3, 5))\\n            3   8   8               dfs(3, 1) -> find min (6 + dfs(4, 1), 2 + dfs(4, 3), 4 + dfs(4, 5))\\n                                        dfs(4, 1) -> find min (3 + 2, 8 + 2, 8 + 4)\\n                                            dfs(5, 1) -> for col 0, 1 has a value in col 0, so bitmask & (1 << col_i) is 1 -> so we skip this value. But other two we would get 0, so we add them for 2. \\n                                            dfs(5, 3) -> for col 1, b1 does not have value in col 1 which is like saying it does not have the second column -> add this value  -> result is 2 \\n                                            dfs(5, 5) -> as above for col 2 -> total is now 2 for the first, and 2 for the other two, total is 4\\n                                            dfs(5, 7) -> 0 \\n                                        dfs(4, 1) -> so our first result is 3 + 2 is 5 \\n                                        dfs(4, 2) -> min(3 + 2, 8 + dfs(5, 2), 8 + dfs(5, 6)) -> 5 \\n                                        dfs(4, 3) -> min(3 + dfs(5, 3), 8 + dfs(5, 3), 8 + dfs(5, 7)) -> min (3 + 2, 8 + 2, 8 + 0) -> result is 5\\n                                        dfs(4, 4) -> min(3 + dfs(5, 5), 8 + dfs(5, 4), 8 + dfs(5, 6)) -> 7\\n                                        dfs(4, 6) -> min(3 + dfs(5, 7), 8 + dfs(5, 6), 8 + dfs(5, 6)) -> result is 3\\n                                        dfs(4, 5) -> min(3 + dfs(5, 5), 8 + dfs(5, 7), 8 + dfs(5, 5)) -> min (3 + 4, 8 + 0, 8 + 4) -> result is 7\\n                                        dfs(4, 7) -> min(3 + dfs(5, 7),  8 + dfs(5, 7), 8 + dfs(5, 7)) -> min (3, 8, 8) -> 3 \\n                                    dfs(3, 1) -> min (6 + 5, 2 + 5, 4 + 7) -> 7 \\n                                    dfs(3, 2) -> min (6 + 5, 2 + 5, 4+3) -> 7\\n                                    dfs(3, 3) -> min (6 + dfs(4, 3), 2 + dfs(4, 3), 4 + dfs(4, 7))\\n                                              -> min (6 + 5, 2 + 5, 4 + 3) -> 7\\n                                    dfs(3, 4) -> min (6 + 7, 2 + 7, 4+3) -> 7 \\n                                    dfs(3, 5) -> min(6 + dfs(4, 5), 2 + dfs(4, 7), 4 + dfs(4, 5))\\n                                              -> min(6 + 7, 2 + 3, 4 + 7) -> 5\\n                                    dfs(3, 6) -> min(6 + 3, 2 + 3, 4 + 3) -> 5\\n                                    dfs(3, 7) -> min(6 + dfs(4, 7), 2 + dfs(4, 7), 4+dfs(4, 7))\\n                                              -> min(6 + 3, 2 + 3, 4 + 3) -> 5  \\n                                dfs(2, 1) -> (8 + 7, 1 + 7, 2 + 5) -> 7 \\n                                dfs(2, 3) -> find min (8 + dfs(3, 3), 1 + dfs(3, 3), 2 + dfs(3, 7))\\n                                          ->      min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 4) -> (8 + 5, 1 + 5, 2 + 7) -> 6\\n                                dfs(2, 5) -> find min (8 + dfs(3, 5), 1 + dfs(3, 7), 2 + dfs(3, 5))\\n                                          ->      min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 2)         min (8 + dfs(3, 3), 1 + dfs(3, 2), 2 + dfs(3, 6))\\n                                                  min (8 + 7, 1 + 7, 2 + 5) -> 7\\n                                dfs(2, 6) ->      min (8 + dfs(3, 7), 1 + dfs(3, 6), 2 + dfs(3, 6))\\n                                                  min (8 + 5, 1 + 5, 2 + 5) -> 6\\n                                dfs(2, 7) ->      min (8 + dfs(3, 7), 1 + dfs(3, 7), 2 + dfs(3, 7)) -> 6\\n                            dfs(1, 1) -> min(3 + 7, 4 + 7, 7 + 6) -> 10 \\n                        dfs(0, 0) -> min(2 + 10, 5 + dfs(1, 2), 1 + dfs(1, 4))\\n                            dfs(1, 2) -> min(3 + dfs(2, 3), 4 + dfs(2, 2), 7+ dfs(2, 6))\\n                                      -> min(3 + 7, 4 + 7, 7 + 6) -> 10\\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + dfs(1, 4)) \\n                            dfs(1, 4) -> min(3 + 6, 4 + 6, 7 +  6) -> 9 \\n                        dfs(0, 0) -> min(2 + 10, 5 + 10, 1 + 9) -> 10\\n        \\'\\'\\'        \\n\\n        return dfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763960,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int i,int j,int si,int size,int val,vector<vector<int>>& cost,vector<vector<vector<vector<int>>>>& dp,int ct)\\n    {\\n        if(i==si && val==((1<<size)-1))\\n        return 0;\\n        if(i==si)\\n        return 1e9;\\n        if(j==size)\\n        {\\n            if(ct>0)\\n            return find(i+1,0,si,size,val,cost,dp,0);\\n            else\\n            return 1e9;\\n        }\\n        if(dp[i][j][val][ct]!=-1)\\n        return dp[i][j][val][ct];\\n        int a=find(i,j+1,si,size,val | (1<<j),cost,dp,ct+1)+cost[i][j];\\n        int b=find(i,j+1,si,size,val,cost,dp,ct);\\n        return dp[i][j][val][ct]=min(a,b);\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int si=cost.size(),size=cost[0].size();\\n        vector<vector<vector<vector<int>>>> dp(si,vector<vector<vector<int>>>(size,vector<vector<int>>((1<<size),vector<int>(size+1,-1))));\\n        return find(0,0,si,size,0,cost,dp,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i,int j,int si,int size,int val,vector<vector<int>>& cost,vector<vector<vector<vector<int>>>>& dp,int ct)\\n    {\\n        if(i==si && val==((1<<size)-1))\\n        return 0;\\n        if(i==si)\\n        return 1e9;\\n        if(j==size)\\n        {\\n            if(ct>0)\\n            return find(i+1,0,si,size,val,cost,dp,0);\\n            else\\n            return 1e9;\\n        }\\n        if(dp[i][j][val][ct]!=-1)\\n        return dp[i][j][val][ct];\\n        int a=find(i,j+1,si,size,val | (1<<j),cost,dp,ct+1)+cost[i][j];\\n        int b=find(i,j+1,si,size,val,cost,dp,ct);\\n        return dp[i][j][val][ct]=min(a,b);\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int si=cost.size(),size=cost[0].size();\\n        vector<vector<vector<vector<int>>>> dp(si,vector<vector<vector<int>>>(size,vector<vector<int>>((1<<size),vector<int>(size+1,-1))));\\n        return find(0,0,si,size,0,cost,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731847,
                "title": "dp-with-bitmask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // group1[i...] with group2 points occupied in mask\\n    int solve(int ith, int mask, vector<vector<int>>& cost,\\n              vector<int>& min2, vector<vector<int>>& mem) {\\n        if (mem[ith][mask] != -1) {\\n            return mem[ith][mask];\\n        }\\n\\n        int m = cost.size(), n = cost[0].size(), ans;\\n        if (ith == m) {\\n            // connect each unoccupied group2 point\\n            ans = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (!(mask & (1 << j))) {\\n                    ans += min2[j];\\n                }\\n            }\\n        } else {\\n            ans = INT_MAX;\\n            // connect group1[ith] to each point in group2\\n            for (int j = 0; j < n; j++) {\\n                int val = cost[ith][j] + solve(ith + 1, mask | (1 << j), cost, min2, mem);\\n                ans = min(ans, val);\\n            }\\n        }\\n\\n        return mem[ith][mask] = ans;\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. group1 and group2 has different number of points,\\n       suppose their size m and n, we know m >= n.\\n    2. A point in group1 can connect to any point in group2.\\n       All points in group1 can connect to 1/2/.../n points\\n       in group2. Let\\'s say dp[i][mask] denote the min cost\\n       to connect group1[i...m-1] to group2, with mask denote\\n       unused group2 points as 0 and used as 1. We have:\\n\\n       dp[i][mask] = min(cost[i][j] + dp[i+1][mask | (1 << j)]), j in [0, n-1]\\n\\n       Basically group1[i] can connect to any point in group2,\\n       regardless of whether this point has been used before.\\n    3. In the end some group2 points might be 0 in mask,\\n       connect such point to its lowest cost connection in\\n       group1, and sum up the cost for all such points.\\n\\n       bitmask dp;\\n       O(m * 2^n * n) time O(m * 2^n) space, can be optimized to O(2^n) space;\\n    */\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int m = cost.size(), n = cost[0].size();\\n        // minimum cost for each group2 point\\n        vector<int> min2(n, 101);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                min2[j] = min(min2[j], cost[i][j]);\\n            }\\n        }\\n\\n        int N = 1 << n;\\n        // mem[m] is used in the end, to handle unoccupied points in group2\\n        vector<vector<int>> mem(m + 1, vector<int>(N, -1));\\n        return solve(0, 0, cost, min2, mem);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    // group1[i...] with group2 points occupied in mask\\n    int solve(int ith, int mask, vector<vector<int>>& cost,\\n              vector<int>& min2, vector<vector<int>>& mem) {\\n        if (mem[ith][mask] != -1) {\\n            return mem[ith][mask];\\n        }\\n\\n        int m = cost.size(), n = cost[0].size(), ans;\\n        if (ith == m) {\\n            // connect each unoccupied group2 point\\n            ans = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (!(mask & (1 << j))) {\\n                    ans += min2[j];\\n                }\\n            }\\n        } else {\\n            ans = INT_MAX;\\n            // connect group1[ith] to each point in group2\\n            for (int j = 0; j < n; j++) {\\n                int val = cost[ith][j] + solve(ith + 1, mask | (1 << j), cost, min2, mem);\\n                ans = min(ans, val);\\n            }\\n        }\\n\\n        return mem[ith][mask] = ans;\\n    }\\npublic:\\n    /*\\n    Observations:\\n    1. group1 and group2 has different number of points,\\n       suppose their size m and n, we know m >= n.\\n    2. A point in group1 can connect to any point in group2.\\n       All points in group1 can connect to 1/2/.../n points\\n       in group2. Let\\'s say dp[i][mask] denote the min cost\\n       to connect group1[i...m-1] to group2, with mask denote\\n       unused group2 points as 0 and used as 1. We have:\\n\\n       dp[i][mask] = min(cost[i][j] + dp[i+1][mask | (1 << j)]), j in [0, n-1]\\n\\n       Basically group1[i] can connect to any point in group2,\\n       regardless of whether this point has been used before.\\n    3. In the end some group2 points might be 0 in mask,\\n       connect such point to its lowest cost connection in\\n       group1, and sum up the cost for all such points.\\n\\n       bitmask dp;\\n       O(m * 2^n * n) time O(m * 2^n) space, can be optimized to O(2^n) space;\\n    */\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int m = cost.size(), n = cost[0].size();\\n        // minimum cost for each group2 point\\n        vector<int> min2(n, 101);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                min2[j] = min(min2[j], cost[i][j]);\\n            }\\n        }\\n\\n        int N = 1 << n;\\n        // mem[m] is used in the end, to handle unoccupied points in group2\\n        vector<vector<int>> mem(m + 1, vector<int>(N, -1));\\n        return solve(0, 0, cost, min2, mem);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698523,
                "title": "java-bitmask-dp",
                "content": "1. states: i-th bit represents that has the i-th number in second group been chosen\\n2. dp[i][s]: the minimum cost for the first i number in first group, with chosen pattern in s for the second group\\n3. dp[i][s] = Min(dp[i][s], dp[i - 1][s] + cost, dp[i -1][s - subset] + cost) for subset in range [0, s]\\n\\nWhy?   \\nThe first goal is to fill states of the second group to all 1-bit, but it is likely that the costs of current number in first group with any 0-bit number in second group are greater than the costs of current number in first group with already 1-bit number in second group.\\n\\nIn other words, if i-th number in second group is already chosen, but for the j-th number in first group, it costs less to get them connect than connect to any numbers that have not chosen in second group.\\n```\\nclass Solution {\\n    int m;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        this.m = cost.get(0).size();\\n        int nState = 1 << m;\\n        int[][] dp = new int[n + 1][nState];\\n        int[][] costsOfNSecondGroupForOneFirstGroup = new int[n][nState];\\n        for (int i = 0; i < n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                costsOfNSecondGroupForOneFirstGroup[i][state] = getCostsForOneToN(cost, i, state);\\n            }\\n        }\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    dp[i][state] = Math.min(dp[i][state], Math.min(dp[i - 1][state], dp[i - 1][state - subset]) + costsOfNSecondGroupForOneFirstGroup[i - 1][subset]);\\n                }\\n            }\\n        }\\n        return dp[n][nState - 1];\\n    }\\n\\n    private int getCostsForOneToN(List<List<Integer>> cost, int first_group_index, int state) {\\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            if (state % 2 == 1) {\\n                count += cost.get(first_group_index).get(i);\\n            }\\n            state /= 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    int m;\\n\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int n = cost.size();\\n        this.m = cost.get(0).size();\\n        int nState = 1 << m;\\n        int[][] dp = new int[n + 1][nState];\\n        int[][] costsOfNSecondGroupForOneFirstGroup = new int[n][nState];\\n        for (int i = 0; i < n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                costsOfNSecondGroupForOneFirstGroup[i][state] = getCostsForOneToN(cost, i, state);\\n            }\\n        }\\n        for (int i = 0; i <= n; i++) {\\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\\n        }\\n        dp[0][0] = 0;\\n        for (int i = 1; i <= n; i++) {\\n            for (int state = 0; state < nState; state++) {\\n                for (int subset = state; subset > 0; subset = (subset - 1) & state) {\\n                    dp[i][state] = Math.min(dp[i][state], Math.min(dp[i - 1][state], dp[i - 1][state - subset]) + costsOfNSecondGroupForOneFirstGroup[i - 1][subset]);\\n                }\\n            }\\n        }\\n        return dp[n][nState - 1];\\n    }\\n\\n    private int getCostsForOneToN(List<List<Integer>> cost, int first_group_index, int state) {\\n        int count = 0;\\n        for (int i = 0; i < m; i++) {\\n            if (state % 2 == 1) {\\n                count += cost.get(first_group_index).get(i);\\n            }\\n            state /= 2;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391178,
                "title": "javascript-memoization-with-bitmask",
                "content": "```\\n// Helper function\\nconst memoize = (fn) => {\\n  \\n  const memo = new Map();\\n  return (...args) => {\\n\\n    const key = args.map(JSON.stringify).join(\",\");\\n    if (memo.has(key)) return memo.get(key);\\n\\n    const result = fn(...args);\\n    memo.set(key, result);\\n\\n    return result;\\n  }\\n}\\n\\nvar connectTwoGroups = function(cost) {\\n\\n  const n = cost.length;\\n  const m = cost[0].length;\\n\\n  const baseNumber = 2 ** m - 1;\\n\\n  const setBit = (num, index) => {\\n    const mask = 1 << index;\\n    return num | mask;\\n  }\\n\\n  const f = memoize((i, usedLeft, j, bitMask) => {\\n\\n    if (i === n) return bitMask === baseNumber ? 0 : Infinity;\\n    if (j === m) return usedLeft ? f(i + 1, false, 0, bitMask) : Infinity;\\n  \\n    const connect = f(i, true, j + 1, setBit(bitMask, j)) + cost[i][j];\\n    const noConnect = f(i, usedLeft, j + 1, bitMask);\\n\\n    return Math.min(connect, noConnect);\\n  });\\n\\n  return f(0, false, 0, 0);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Helper function\\nconst memoize = (fn) => {\\n  \\n  const memo = new Map();\\n  return (...args) => {\\n\\n    const key = args.map(JSON.stringify).join(\",\");\\n    if (memo.has(key)) return memo.get(key);\\n\\n    const result = fn(...args);\\n    memo.set(key, result);\\n\\n    return result;\\n  }\\n}\\n\\nvar connectTwoGroups = function(cost) {\\n\\n  const n = cost.length;\\n  const m = cost[0].length;\\n\\n  const baseNumber = 2 ** m - 1;\\n\\n  const setBit = (num, index) => {\\n    const mask = 1 << index;\\n    return num | mask;\\n  }\\n\\n  const f = memoize((i, usedLeft, j, bitMask) => {\\n\\n    if (i === n) return bitMask === baseNumber ? 0 : Infinity;\\n    if (j === m) return usedLeft ? f(i + 1, false, 0, bitMask) : Infinity;\\n  \\n    const connect = f(i, true, j + 1, setBit(bitMask, j)) + cost[i][j];\\n    const noConnect = f(i, usedLeft, j + 1, bitMask);\\n\\n    return Math.min(connect, noConnect);\\n  });\\n\\n  return f(0, false, 0, 0);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230238,
                "title": "python-simple-dp-bitmasking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        m, n = len(cost), len(cost[0])\\n\\n        ans = [min(i) for i in zip(*cost)]\\n\\n        @lru_cache(None)\\n        def dfs(i,mask):\\n            if i == m: return sum(ans[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + dfs(i+1,mask|(1<<j)) for j in range(n))\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        m, n = len(cost), len(cost[0])\\n\\n        ans = [min(i) for i in zip(*cost)]\\n\\n        @lru_cache(None)\\n        def dfs(i,mask):\\n            if i == m: return sum(ans[j] for j in range(n) if not (mask & (1<<j)))\\n            return min(cost[i][j] + dfs(i+1,mask|(1<<j)) for j in range(n))\\n\\n        return dfs(0,0)\\n\\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175220,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\\n        let cost: Vec<Vec<_>> = cost.iter().map(|v| v.iter().map(|&x| x as i64).collect()).collect();\\n        let (sz1, sz2) = (cost.len(), cost[0].len());\\n        let mut dp = vec![vec![1_000_000_007; 1 << sz2]; sz1 + 1];\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for i in (0..sz1).rev() {\\n            for mask in (0..(1 << sz2)).rev() {\\n                for j in 0..sz2 {\\n                    dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if mask & (1 << j) == 0 {\\n                        dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][0] as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\\n        let cost: Vec<Vec<_>> = cost.iter().map(|v| v.iter().map(|&x| x as i64).collect()).collect();\\n        let (sz1, sz2) = (cost.len(), cost[0].len());\\n        let mut dp = vec![vec![1_000_000_007; 1 << sz2]; sz1 + 1];\\n        dp[sz1][(1 << sz2) - 1] = 0;\\n        for i in (0..sz1).rev() {\\n            for mask in (0..(1 << sz2)).rev() {\\n                for j in 0..sz2 {\\n                    dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i + 1][mask | (1 << j)]);\\n                    if mask & (1 << j) == 0 {\\n                        dp[i][mask] = dp[i][mask].min(cost[i][j] + dp[i][mask | (1 << j)]);\\n                    }\\n                }\\n            }\\n        }\\n        dp[0][0] as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172467,
                "title": "c-super-short-dfs-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& C) {\\n         int m = C.size(), n = C[0].size(), dp[13][4097]{}, min2[13] = {[0 ... 12] = INT_MAX};\\n         for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) min2[j] = min(min2[j], C[i][j]);\\n         function<int(int, int)> dfs = [&] (int i, int mask) {\\n             if(dp[i][mask]) return dp[i][mask];\\n             int res = (i >= m ? 0 : INT_MAX);\\n             for(int j = 0; j < n; j++) {\\n                 if(i >= m) res += min2[j]*(!(mask&(1 << j)));\\n                 else res = min(res, C[i][j]+ dfs(i+1, mask | (1 << j)));\\n             }\\n             return dp[i][mask] = res;\\n         };\\n         return dfs(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& C) {\\n         int m = C.size(), n = C[0].size(), dp[13][4097]{}, min2[13] = {[0 ... 12] = INT_MAX};\\n         for(int i = 0; i < m; i++) for(int j = 0; j < n; j++) min2[j] = min(min2[j], C[i][j]);\\n         function<int(int, int)> dfs = [&] (int i, int mask) {\\n             if(dp[i][mask]) return dp[i][mask];\\n             int res = (i >= m ? 0 : INT_MAX);\\n             for(int j = 0; j < n; j++) {\\n                 if(i >= m) res += min2[j]*(!(mask&(1 << j)));\\n                 else res = min(res, C[i][j]+ dfs(i+1, mask | (1 << j)));\\n             }\\n             return dp[i][mask] = res;\\n         };\\n         return dfs(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915301,
                "title": "dfs-with-memo-bitmask-for-right-state",
                "content": "Big thanks to the @hjscoder [solution](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/solutions/855352/the-idea-is-brute-force-dfs/).\\n# Code\\n```\\npublic class Solution {\\n    private int[] _dp;\\n    private int[][] _memo;\\n    private IList<IList<int>> _cost;\\n\\n    public int ConnectTwoGroups(IList<IList<int>> cost) {\\n        _cost = cost;\\n        CalculateMinCostForEachRightComponent();\\n        InitCacheArray();\\n        return Recurse(0, 0);\\n    }\\n\\n    private void CalculateMinCostForEachRightComponent()\\n    {\\n        _dp = new int[_cost[0].Count];\\n        Array.Fill(_dp, int.MaxValue);\\n        for(var j = 0; j < _dp.Length; j++)\\n        {\\n            for (var i = 0; i < _cost.Count; i++)\\n            {\\n                _dp[j] = Math.Min(_dp[j], _cost[i][j]);\\n            }\\n        }\\n    }\\n\\n    private void InitCacheArray()\\n    {\\n        _memo = new int[_cost.Count + 1][];\\n\\n        var length = (1 << _cost[0].Count);\\n        for (var i = 0; i < _memo.Length; i++)\\n        {\\n            _memo[i] = new int[length];\\n            Array.Fill(_memo[i], -1);\\n        }\\n    }\\n\\n    private int Recurse(int left, int right)\\n    {\\n        if (_memo[left][right] != -1)\\n            return _memo[left][right];\\n\\n        if (left == _cost.Count)\\n        {\\n            // Here we state that all components from left are connected. \\n            // Then we need to sum all minimal costs of the right elements that have not been considered yet in the \"right\" state\\n            // That is why we check the states to be 0, not 1\\n            var sum = 0;\\n            for (var j = 0; j < _dp.Length; j++)\\n            {\\n                if (((1 << j) & right) == 0)\\n                    sum += _dp[j];\\n            }\\n            return _memo[left][right] = sum;\\n        }\\n        \\n        var result = int.MaxValue;\\n        // Traverse all states and try to include them in the final result\\n        for (var j = 0; j < _dp.Length; j++)\\n        {\\n            var newState = (1 << j) | right;\\n            result = Math.Min(result, _cost[left][j] + Recurse(left + 1, newState));\\n        }\\n\\n        // Save the achieved result \\n        return _memo[left][right] = result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking",
                    "Depth-First Search",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] _dp;\\n    private int[][] _memo;\\n    private IList<IList<int>> _cost;\\n\\n    public int ConnectTwoGroups(IList<IList<int>> cost) {\\n        _cost = cost;\\n        CalculateMinCostForEachRightComponent();\\n        InitCacheArray();\\n        return Recurse(0, 0);\\n    }\\n\\n    private void CalculateMinCostForEachRightComponent()\\n    {\\n        _dp = new int[_cost[0].Count];\\n        Array.Fill(_dp, int.MaxValue);\\n        for(var j = 0; j < _dp.Length; j++)\\n        {\\n            for (var i = 0; i < _cost.Count; i++)\\n            {\\n                _dp[j] = Math.Min(_dp[j], _cost[i][j]);\\n            }\\n        }\\n    }\\n\\n    private void InitCacheArray()\\n    {\\n        _memo = new int[_cost.Count + 1][];\\n\\n        var length = (1 << _cost[0].Count);\\n        for (var i = 0; i < _memo.Length; i++)\\n        {\\n            _memo[i] = new int[length];\\n            Array.Fill(_memo[i], -1);\\n        }\\n    }\\n\\n    private int Recurse(int left, int right)\\n    {\\n        if (_memo[left][right] != -1)\\n            return _memo[left][right];\\n\\n        if (left == _cost.Count)\\n        {\\n            // Here we state that all components from left are connected. \\n            // Then we need to sum all minimal costs of the right elements that have not been considered yet in the \"right\" state\\n            // That is why we check the states to be 0, not 1\\n            var sum = 0;\\n            for (var j = 0; j < _dp.Length; j++)\\n            {\\n                if (((1 << j) & right) == 0)\\n                    sum += _dp[j];\\n            }\\n            return _memo[left][right] = sum;\\n        }\\n        \\n        var result = int.MaxValue;\\n        // Traverse all states and try to include them in the final result\\n        for (var j = 0; j < _dp.Length; j++)\\n        {\\n            var newState = (1 << j) | right;\\n            result = Math.Min(result, _cost[left][j] + Recurse(left + 1, newState));\\n        }\\n\\n        // Save the achieved result \\n        return _memo[left][right] = result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776570,
                "title": "python-beats-100-hungarian-algorithm",
                "content": "I wanted to use this problem to try and understand and implement Hungarian using python which is not a very common resource out there.\\n\\nThis explains the intuition behind the solution\\n- https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/855686/C%2B%2B-4ms-beats-100-Bipartite-graph-maximum-weight-matching\\n\\nHowever the Hungarian algorithm used is different and is adapted from this C++ source\\n- https://github.com/mpfeifer1/Kattis/blob/master/cordonbleu.cpp\\n\\n```py\\n\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        Lmin = [0 for _ in range(rows)]\\n        Rmin = [0 for _ in range(cols)]\\n\\n        ans = 0\\n        for i in range(rows):\\n            Lmin[i] = float(\\'inf\\')\\n            for j in range(cols):\\n                Lmin[i] = min(Lmin[i], cost[i][j])\\n            ans += Lmin[i]\\n        \\n        for j in range(cols):\\n            Rmin[j] = float(\\'inf\\')\\n            for i in range(rows):\\n                Rmin[j] = min(Rmin[j], cost[i][j])\\n            ans += Rmin[j]\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                cost[i][j] = max(-1*(cost[i][j] - Lmin[i] - Rmin[j]), 0)\\n                \\n\\n        res = hungarianMatch(cost, False)\\n        return ans - res\\n\\n\\n\\n# matrix[i][j] is cost of job i done by worker j\\ndef hungarianMatch(matrix, minimize=True):\\n    \\n    # ensure that rows always <= cols\\n    if len(matrix) > len(matrix[0]):\\n        matrix = list(map(list, zip(*matrix)))\\n    \\n    \\n    rows = len(matrix)\\n    cols = len(matrix[0])\\n    \\n    # flip weights if \\n    if not minimize:\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] *= -1\\n\\n    u = [0 for _ in range(rows+1)]\\n    v = [0 for _ in range(cols+1)]\\n    p = [0 for _ in range(cols+1)]\\n    way = [0 for _ in range(cols+1)]\\n    for i in range(1,rows+1):\\n        p[0] = i \\n\\n        minv = [float(\\'inf\\') for _ in range(cols+1)]\\n        used = [False for _ in range(cols+1)]\\n\\n        j0 = 0\\n\\n        while True:\\n            used[j0] = True\\n            \\n            i0 = p[j0]\\n            delta = float(\\'inf\\')\\n            j1 = None\\n\\n            for j in range(1,cols+1):\\n                if not used[j]:\\n                    cur = matrix[i0-1][j-1] - u[i0] - v[j]\\n                    if cur < minv[j]:\\n                        minv[j] = cur \\n                        way[j] = j0\\n                    if minv[j] < delta:\\n                        delta = minv[j]\\n                        j1 = j\\n            \\n            for j in range(cols+1):\\n                if used[j]:\\n                    u[p[j]] += delta \\n                    v[j] -= delta \\n                else:\\n                    minv[j] -= delta \\n            \\n            j0 = j1\\n\\n            if p[j0] == 0: break\\n\\n        while True:\\n            j1 = way[j0]\\n            p[j0] = p[j1]\\n            j0 = j1\\n            if not j0:\\n                break\\n    \\n    if not minimize: return v[0]\\n    return -v[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        rows = len(cost)\\n        cols = len(cost[0])\\n        Lmin = [0 for _ in range(rows)]\\n        Rmin = [0 for _ in range(cols)]\\n\\n        ans = 0\\n        for i in range(rows):\\n            Lmin[i] = float(\\'inf\\')\\n            for j in range(cols):\\n                Lmin[i] = min(Lmin[i], cost[i][j])\\n            ans += Lmin[i]\\n        \\n        for j in range(cols):\\n            Rmin[j] = float(\\'inf\\')\\n            for i in range(rows):\\n                Rmin[j] = min(Rmin[j], cost[i][j])\\n            ans += Rmin[j]\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                cost[i][j] = max(-1*(cost[i][j] - Lmin[i] - Rmin[j]), 0)\\n                \\n\\n        res = hungarianMatch(cost, False)\\n        return ans - res\\n\\n\\n\\n# matrix[i][j] is cost of job i done by worker j\\ndef hungarianMatch(matrix, minimize=True):\\n    \\n    # ensure that rows always <= cols\\n    if len(matrix) > len(matrix[0]):\\n        matrix = list(map(list, zip(*matrix)))\\n    \\n    \\n    rows = len(matrix)\\n    cols = len(matrix[0])\\n    \\n    # flip weights if \\n    if not minimize:\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix[i][j] *= -1\\n\\n    u = [0 for _ in range(rows+1)]\\n    v = [0 for _ in range(cols+1)]\\n    p = [0 for _ in range(cols+1)]\\n    way = [0 for _ in range(cols+1)]\\n    for i in range(1,rows+1):\\n        p[0] = i \\n\\n        minv = [float(\\'inf\\') for _ in range(cols+1)]\\n        used = [False for _ in range(cols+1)]\\n\\n        j0 = 0\\n\\n        while True:\\n            used[j0] = True\\n            \\n            i0 = p[j0]\\n            delta = float(\\'inf\\')\\n            j1 = None\\n\\n            for j in range(1,cols+1):\\n                if not used[j]:\\n                    cur = matrix[i0-1][j-1] - u[i0] - v[j]\\n                    if cur < minv[j]:\\n                        minv[j] = cur \\n                        way[j] = j0\\n                    if minv[j] < delta:\\n                        delta = minv[j]\\n                        j1 = j\\n            \\n            for j in range(cols+1):\\n                if used[j]:\\n                    u[p[j]] += delta \\n                    v[j] -= delta \\n                else:\\n                    minv[j] -= delta \\n            \\n            j0 = j1\\n\\n            if p[j0] == 0: break\\n\\n        while True:\\n            j1 = way[j0]\\n            p[j0] = p[j1]\\n            j0 = j1\\n            if not j0:\\n                break\\n    \\n    if not minimize: return v[0]\\n    return -v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732975,
                "title": "c-bottom-up",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<vector<ll int>>dp(n,vector<ll int>(1<<m,1e12));\\n        vector<vector<ll int>>pre(n,vector<ll int>(1<<m,1e12));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                ll int curr=0;\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mask&(1<<j))\\n                    {\\n                        curr+=cost[i][j];\\n                    }\\n                }\\n                pre[i][mask]=curr;\\n            }\\n        }\\n        for(int mask=1;mask<(1<<m);mask++)\\n        {\\n            dp[0][mask]=pre[0][mask];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                for(int s=mask;s;s=(s-1)&mask)\\n                {\\n                    int xmask=mask^s;\\n                    if(dp[i-1][xmask]!=1e12)\\n                        dp[i][mask]=min(dp[i][mask],dp[i-1][xmask]+pre[i][s]);\\n                    dp[i][mask]=min(dp[i][mask],dp[i-1][mask]+pre[i][s]);\\n                }\\n                    \\n            }\\n        }\\n        return dp[n-1][(1<<m)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        vector<vector<ll int>>dp(n,vector<ll int>(1<<m,1e12));\\n        vector<vector<ll int>>pre(n,vector<ll int>(1<<m,1e12));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                ll int curr=0;\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mask&(1<<j))\\n                    {\\n                        curr+=cost[i][j];\\n                    }\\n                }\\n                pre[i][mask]=curr;\\n            }\\n        }\\n        for(int mask=1;mask<(1<<m);mask++)\\n        {\\n            dp[0][mask]=pre[0][mask];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int mask=1;mask<(1<<m);mask++)\\n            {\\n                for(int s=mask;s;s=(s-1)&mask)\\n                {\\n                    int xmask=mask^s;\\n                    if(dp[i-1][xmask]!=1e12)\\n                        dp[i][mask]=min(dp[i][mask],dp[i-1][xmask]+pre[i][s]);\\n                    dp[i][mask]=min(dp[i][mask],dp[i-1][mask]+pre[i][s]);\\n                }\\n                    \\n            }\\n        }\\n        return dp[n-1][(1<<m)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720012,
                "title": "c-bit-mask-o-n-m-2-m",
                "content": "```\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int n = cost.size(), m = cost[0].size(), m2 = pow(2, m), Big = 1e9;\\n        vector<int> pre(m2, Big), cur(m2, Big);\\n        pre[0] = 0;\\n        for(int i=0;i<n;i++){            \\n            for(int j=0;j<m;j++){\\n                int cos = cost[i][j];\\n                for(int mask = 0; mask < m2; mask++){\\n                    if(pre[mask] == Big) continue;\\n                    int newMask = mask | (1<<j);\\n                    cur[newMask] = min(cur[newMask], pre[mask] + cos);\\n                }\\n            }\\n            pre = move(cur);\\n            cur = vector(m2, Big);\\n        }        \\n\\n        vector<int> vmin(m, Big);\\n        for(int j=0;j<m;j++) for(int i=0;i<n;i++)\\n            vmin[j] = min(vmin[j], cost[i][j]);\\n        \\n        // for all the mask, if b_i is not connected, add the min cost to conect b_i\\n        int res = pre[m2-1];        \\n        for(int i=0;i<m2-1;i++){\\n            bitset<12> mask(i);\\n            int sum = pre[i];\\n            for(int i=0;i<m;i++) if(!mask[i]) sum += vmin[i];\\n            res = min(res, sum);\\n        }       \\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int n = cost.size(), m = cost[0].size(), m2 = pow(2, m), Big = 1e9;\\n        vector<int> pre(m2, Big), cur(m2, Big);\\n        pre[0] = 0;\\n        for(int i=0;i<n;i++){            \\n            for(int j=0;j<m;j++){\\n                int cos = cost[i][j];\\n                for(int mask = 0; mask < m2; mask++){\\n                    if(pre[mask] == Big) continue;\\n                    int newMask = mask | (1<<j);\\n                    cur[newMask] = min(cur[newMask], pre[mask] + cos);\\n                }\\n            }\\n            pre = move(cur);\\n            cur = vector(m2, Big);\\n        }        \\n\\n        vector<int> vmin(m, Big);\\n        for(int j=0;j<m;j++) for(int i=0;i<n;i++)\\n            vmin[j] = min(vmin[j], cost[i][j]);\\n        \\n        // for all the mask, if b_i is not connected, add the min cost to conect b_i\\n        int res = pre[m2-1];        \\n        for(int i=0;i<m2-1;i++){\\n            bitset<12> mask(i);\\n            int sum = pre[i];\\n            for(int i=0;i<m;i++) if(!mask[i]) sum += vmin[i];\\n            res = min(res, sum);\\n        }       \\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2716071,
                "title": "python-short-dfs-solution-bitmask",
                "content": "```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tm, n = len(cost), len(cost[0])\\n\\tmin_cost = [min(col) for col in zip(*cost)]\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(i, mask):\\n\\t\\tif i==m:\\n\\t\\t\\treturn sum(min_cost[j] for j in range(n) if not mask&(1<<j))\\n\\t\\treturn min(cost[i][j]+dfs(i+1, mask|(1<<j)) for j in range(n))\\n\\n\\treturn dfs(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tm, n = len(cost), len(cost[0])\\n\\tmin_cost = [min(col) for col in zip(*cost)]\\n\\n\\t@lru_cache(None)\\n\\tdef dfs(i, mask):\\n\\t\\tif i==m:\\n\\t\\t\\treturn sum(min_cost[j] for j in range(n) if not mask&(1<<j))\\n\\t\\treturn min(cost[i][j]+dfs(i+1, mask|(1<<j)) for j in range(n))\\n\\n\\treturn dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2600213,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll m, n;\\n    vi(ll)cols;\\n    vi(vi(ll))dp;\\n    ll func(const vi(vi(int))& v, ll in, ll bm) {\\n        if (in == m) {\\n            ll ans = 0;\\n            for (ll c = 0;c < n;++c) { // for those columns (set2 elements), that remain disconnected, connect them with the least weighted rows, i.e. set1 elements (already prepared in prefix)\\n                if (!((bm >> c) & 1)) {\\n                    ans += cols[c];\\n                }\\n            }\\n            return ans;\\n        }\\n        ll& ans = dp[in][bm];\\n        if (ans == -1) {\\n            ans = LLONG_MAX;\\n            for (ll c = 0;c < n;++c) {\\n                ans = min(ans, v[in][c] + func(v, in + 1, bm | (1 << c)));\\n            }\\n        }\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& v) {\\n        m = v.size(), n = v[0].size();\\n        dp.assign(m, vi(ll)(1 << n, -1));\\n        cols.assign(n, LLONG_MAX); // cols[i] stores the min element among all rows in column i\\n        for (ll j = 0;j < n;++j) {\\n            for (ll i = 0;i < m;++i) {\\n                cols[j] = min(cols[j], ll(v[i][j]));\\n            }\\n        }\\n        return func(v, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll m, n;\\n    vi(ll)cols;\\n    vi(vi(ll))dp;\\n    ll func(const vi(vi(int))& v, ll in, ll bm) {\\n        if (in == m) {\\n            ll ans = 0;\\n            for (ll c = 0;c < n;++c) { // for those columns (set2 elements), that remain disconnected, connect them with the least weighted rows, i.e. set1 elements (already prepared in prefix)\\n                if (!((bm >> c) & 1)) {\\n                    ans += cols[c];\\n                }\\n            }\\n            return ans;\\n        }\\n        ll& ans = dp[in][bm];\\n        if (ans == -1) {\\n            ans = LLONG_MAX;\\n            for (ll c = 0;c < n;++c) {\\n                ans = min(ans, v[in][c] + func(v, in + 1, bm | (1 << c)));\\n            }\\n        }\\n        return ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& v) {\\n        m = v.size(), n = v[0].size();\\n        dp.assign(m, vi(ll)(1 << n, -1));\\n        cols.assign(n, LLONG_MAX); // cols[i] stores the min element among all rows in column i\\n        for (ll j = 0;j < n;++j) {\\n            for (ll i = 0;i < m;++i) {\\n                cols[j] = min(cols[j], ll(v[i][j]));\\n            }\\n        }\\n        return func(v, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593102,
                "title": "simple-dp-bitmask-w-explanation-python",
                "content": "```\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m = len(cost); n = len(cost[0])\\n        \\n        #this problem reminds me of N queens problem, where you have to place N queens on an N*N chess board\\n        #in each row, u consider every col as part of the solution, but as soon as u choose a col, go to the next row\\n        #because u need to choose only 1 from each row\\n        #after you are done with rows go to coulmns, if a column hasnt been connected, choose the min avail option\\n        #you can keep track of what cols havent been chosen by using a bit mask\\n\\n        #the solution would work even if u did cols first then rows, but there are more rows so doing rows first is faster\\n        \\n        minAvail = [min([cost[r][c] for r in range(m)]) for c in range(n)]\\n        @lru_cache(None)\\n        #Time -> (m*(2^n))*n, Space -> m*(2^n)\\n        def dfs(row, mask):\\n            res = math.inf if row < m else 0\\n            \\n            if row >= m:\\n                for c in range(n):\\n                    if mask&(1<<c) == 0:\\n                        res += minAvail[c]\\n            else:\\n                for c in range(n):\\n                    res = min(res, cost[row][c] + dfs(row+1, mask|(1<<c)))        \\n            return res\\n        \\n        return dfs(0, 0)\\n```",
                "solutionTags": [
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        m = len(cost); n = len(cost[0])\\n        \\n        #this problem reminds me of N queens problem, where you have to place N queens on an N*N chess board\\n        #in each row, u consider every col as part of the solution, but as soon as u choose a col, go to the next row\\n        #because u need to choose only 1 from each row\\n        #after you are done with rows go to coulmns, if a column hasnt been connected, choose the min avail option\\n        #you can keep track of what cols havent been chosen by using a bit mask\\n\\n        #the solution would work even if u did cols first then rows, but there are more rows so doing rows first is faster\\n        \\n        minAvail = [min([cost[r][c] for r in range(m)]) for c in range(n)]\\n        @lru_cache(None)\\n        #Time -> (m*(2^n))*n, Space -> m*(2^n)\\n        def dfs(row, mask):\\n            res = math.inf if row < m else 0\\n            \\n            if row >= m:\\n                for c in range(n):\\n                    if mask&(1<<c) == 0:\\n                        res += minAvail[c]\\n            else:\\n                for c in range(n):\\n                    res = min(res, cost[row][c] + dfs(row+1, mask|(1<<c)))        \\n            return res\\n        \\n        return dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2532608,
                "title": "javascript-dp-w-bitmasks",
                "content": "**Solution: DP w/ Bitmasks**\\n\\nMemoize each `dp(i, mask)`, where\\n  `i = index in group1`\\n  `mask = bitmask of points connected in group2`\\n\\nFirst, connect every point in group1 with a point in group2. Try every combination and record the best result.\\nThen, connect every unconnected point in group2 with the points in group1 with the cheapest connection cost.\\n\\n`n = size of group1`, `m = size of group2`\\nTime Complexity: `O(n * 2^m * m)` 161ms\\nSpace Complexity: `O(n * 2^m)` 44.5MB\\n```\\nvar connectTwoGroups = function(cost) {\\n  let n = cost.length, m = cost[0].length; // n = size of group1, m = size of group2\\n  let minCost = Array(m).fill(Infinity); // minCost[j] = minimum cost to connect point j (from group2) to a point in group1\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      minCost[j] = Math.min(minCost[j], cost[i][j]);\\n    }\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(1 << m).fill(-1));\\n  return dp(0, 0);\\n  \\n  function dp(i, mask) {\\n    if (i === n) {\\n      let cost = 0;\\n      for (let j = 0; j < m; j++) {\\n        if (((mask >> j) & 1) === 0) cost += minCost[j];\\n      }\\n      return cost;\\n    }\\n    if (memo[i][mask] !== -1) return memo[i][mask];\\n    \\n    let ans = Infinity;\\n    for (let j = 0; j < m; j++) {\\n      ans = Math.min(ans, dp(i + 1, mask | (1 << j)) + cost[i][j]);\\n    }\\n    return memo[i][mask] = ans;\\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar connectTwoGroups = function(cost) {\\n  let n = cost.length, m = cost[0].length; // n = size of group1, m = size of group2\\n  let minCost = Array(m).fill(Infinity); // minCost[j] = minimum cost to connect point j (from group2) to a point in group1\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      minCost[j] = Math.min(minCost[j], cost[i][j]);\\n    }\\n  }\\n  let memo = Array(n).fill(0).map(() => Array(1 << m).fill(-1));\\n  return dp(0, 0);\\n  \\n  function dp(i, mask) {\\n    if (i === n) {\\n      let cost = 0;\\n      for (let j = 0; j < m; j++) {\\n        if (((mask >> j) & 1) === 0) cost += minCost[j];\\n      }\\n      return cost;\\n    }\\n    if (memo[i][mask] !== -1) return memo[i][mask];\\n    \\n    let ans = Infinity;\\n    for (let j = 0; j < m; j++) {\\n      ans = Math.min(ans, dp(i + 1, mask | (1 << j)) + cost[i][j]);\\n    }\\n    return memo[i][mask] = ans;\\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2403921,
                "title": "python-3-dp-bitmask",
                "content": "\\tclass Solution:\\n\\t\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t\\t\\tn,m=len(cost),len(cost[0])\\n\\t\\t\\tmini=[min([cost[i][j] for i in range(n)]) for j in range(m)]\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef solve(i,mask2):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\t\\tif mask2&(1<<j):\\n\\t\\t\\t\\t\\t\\t\\ta+=mini[j]\\n\\t\\t\\t\\t\\treturn a \\n\\t\\t\\t\\tb=float(\\'inf\\')\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tb=min(b,cost[i][j]+solve(i+1,mask2&~(1<<j)))\\n\\t\\t\\t\\treturn b\\n\\t\\t\\treturn solve(0,2**m-1)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t\\t\\tn,m=len(cost),len(cost[0])\\n\\t\\t\\tmini=[min([cost[i][j] for i in range(n)]) for j in range(m)]\\n\\n\\t\\t\\t@cache\\n\\t\\t\\tdef solve(i,mask2):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\ta=0\\n\\t\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\t\\tif mask2&(1<<j):\\n\\t\\t\\t\\t\\t\\t\\ta+=mini[j]\\n\\t\\t\\t\\t\\treturn a \\n\\t\\t\\t\\tb=float(\\'inf\\')\\n\\t\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\t\\tb=min(b,cost[i][j]+solve(i+1,mask2&~(1<<j)))\\n\\t\\t\\t\\treturn b\\n\\t\\t\\treturn solve(0,2**m-1)",
                "codeTag": "Java"
            },
            {
                "id": 2351266,
                "title": "go-dp-top-down-100-fast-and-100-mem",
                "content": "![image](https://assets.leetcode.com/users/images/49042c88-175a-47b4-82a8-3f65e4bdaaf3_1659163097.5933464.png)\\n\\n```\\nfunc connectTwoGroups(cost [][]int) int {\\n\\trbm := 0\\n\\tfor i := range cost[0] {\\n\\t\\trbm |= 1 << i\\n\\t}\\n\\tMX := 1 << 62\\n\\tmem := make([][]int, len(cost))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, rbm+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tvar dp func(i, bmj int) int\\n\\tdp = func(i, bmj int) int {\\n\\t\\tif i >= len(cost) {\\n\\t\\t\\tif bmj == rbm {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\tif mem[i][bmj] != -1 {\\n\\t\\t\\treturn mem[i][bmj]\\n\\t\\t}\\n\\n\\t\\ta := MX\\n\\t\\tf := false\\n\\t\\tfor j := range cost[i] {\\n\\t\\t\\tx := 1 << j\\n\\t\\t\\tv1 := dp(i+1, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t\\tif (bmj & x) != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tv1 = dp(i, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tmem[i][bmj] = a\\n\\t\\tif !f {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\treturn dp(0, 0)\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc connectTwoGroups(cost [][]int) int {\\n\\trbm := 0\\n\\tfor i := range cost[0] {\\n\\t\\trbm |= 1 << i\\n\\t}\\n\\tMX := 1 << 62\\n\\tmem := make([][]int, len(cost))\\n\\tfor i := range mem {\\n\\t\\tmem[i] = make([]int, rbm+1)\\n\\t\\tfor j := range mem[i] {\\n\\t\\t\\tmem[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tvar dp func(i, bmj int) int\\n\\tdp = func(i, bmj int) int {\\n\\t\\tif i >= len(cost) {\\n\\t\\t\\tif bmj == rbm {\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t}\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\n\\t\\tif mem[i][bmj] != -1 {\\n\\t\\t\\treturn mem[i][bmj]\\n\\t\\t}\\n\\n\\t\\ta := MX\\n\\t\\tf := false\\n\\t\\tfor j := range cost[i] {\\n\\t\\t\\tx := 1 << j\\n\\t\\t\\tv1 := dp(i+1, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t\\tif (bmj & x) != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\n\\t\\t\\tv1 = dp(i, bmj|x)\\n\\t\\t\\tif v1 >= 0 {\\n\\t\\t\\t\\tra := v1 + cost[i][j]\\n\\t\\t\\t\\tif ra < a {\\n\\t\\t\\t\\t\\ta = ra\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tf = true\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tmem[i][bmj] = a\\n\\t\\tif !f {\\n\\t\\t\\treturn -1\\n\\t\\t}\\n\\t\\treturn a\\n\\t}\\n\\treturn dp(0, 0)\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329362,
                "title": "java-from-hints-submask",
                "content": "I had a really hard time visualizing this problem, but I was able to solve it after checking the hints. \\n\\n```\\nHint 1:\\nEach point on the left would either be connected to exactly point already connected to some left node, \\nor a subset of the nodes on the right which are not connected to any node\\n```\\nThe hint is vaguely worded, but I took it to mean that for every group A (left), we have 2 options:\\n1. Connect it to a subset of unconnected nodes\\n2. Connect it to the min cost node. \\n\\n1st option is easy to figure out: `dp[i][j] = min of all (dp[i-1][sub] + sum[j^sub]))`, but\\n\\nI struggled a ton with the 2nd option. Intuitively, I know it is like `dp[i][j] = min cost + dp[i-1][???]`, but it took me a while and multiple WAs to figure out what that `???` should be. It should be `j`. the min cost is the base cost that will incur for all masks. We must ensure that it is there. I was trying to set the bit according to the min cost index but it was incorrect.\\n\\nso then we have: `dp[i][j] = min(dp[i-1][j] + min cost, min of all (dp[i-1][sub] + sum[j^sub]))`\\n\\n#### Java\\n\\n```Java\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(), n = cost.get(0).size(), INF = (int)1e9;\\n        int[] dp = new int[1<<n];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0;\\n        for (int i = 0; i < m; i++){\\n            int[] ndp = new int[1<<n];\\n            int[] sum = new int[1<<n];\\n            int min = INF;\\n            for (int j = 0; j < n; j++){\\n                sum[1<<j]=cost.get(i).get(j);\\n                min = Math.min(sum[1<<j], min);\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                sum[j]=sum[j&-j]+sum[j&(j-1)];\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                ndp[j]=min+dp[j]; // option 2\\n                for (int sub = j-1; sub >= 0; sub=(sub-1)&j){ // option 1.\\n                    ndp[j]=Math.min(ndp[j], dp[sub]+sum[j^sub]);\\n                    if (sub == 0){\\n                        break;\\n                    }\\n                }\\n            }\\n            dp=ndp;\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n\\n// [1, 3, 5]\\n// [4, 1, 1]\\n// [1, 5, 3]\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nHint 1:\\nEach point on the left would either be connected to exactly point already connected to some left node, \\nor a subset of the nodes on the right which are not connected to any node\\n```\n```Java\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size(), n = cost.get(0).size(), INF = (int)1e9;\\n        int[] dp = new int[1<<n];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0;\\n        for (int i = 0; i < m; i++){\\n            int[] ndp = new int[1<<n];\\n            int[] sum = new int[1<<n];\\n            int min = INF;\\n            for (int j = 0; j < n; j++){\\n                sum[1<<j]=cost.get(i).get(j);\\n                min = Math.min(sum[1<<j], min);\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                sum[j]=sum[j&-j]+sum[j&(j-1)];\\n            }\\n            for (int j = 0; j < 1<<n; j++){\\n                ndp[j]=min+dp[j]; // option 2\\n                for (int sub = j-1; sub >= 0; sub=(sub-1)&j){ // option 1.\\n                    ndp[j]=Math.min(ndp[j], dp[sub]+sum[j^sub]);\\n                    if (sub == 0){\\n                        break;\\n                    }\\n                }\\n            }\\n            dp=ndp;\\n        }\\n        return dp[(1<<n)-1];\\n    }\\n}\\n\\n// [1, 3, 5]\\n// [4, 1, 1]\\n// [1, 5, 3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246033,
                "title": "c-dp-bitmask",
                "content": "* Solution Inspired By [This Post](https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/discuss/860779/C%2B%2B-DP-with-Bitmasking)\\n* Aim is to pick every element from `size1 or r` and `size2 or c` and finding minimum cost .\\n\\n* We try to pick only single element from each row and calculate the minimum cost of that configuration. This ensures that each element of `size1` or `r` has been dealt with. \\n\\n* But each element of `size2` or `c` **may not** have been dealt with.\\n\\n* `mask` tells us about the chosen configurations of elements from `size2` or  `c`. Eg-> if after `row >= r` , we have `mask == 0110` then this means `1,2` were picked but `0 , 3` still remain.\\n\\n* Now we add the remaining elements cost , By precomputing the best cost for each element from `size2` in `colMin` .\\n```\\nclass Solution {\\npublic:\\n    int r , c , dp[12][(1 << 12)] ; \\n    vector<int> colMin ; \\n    \\n    int solve(int row , int mask , vector<vector<int>> &cost){\\n        if(row >= r){\\n            int rem = 0 ;\\n            for(int j = 0 ; j < c ; ++j ){\\n                //take the remaining ones which were not in the mask \\n                if( !((1 << j) & mask)) rem += colMin[j] ;\\n            }\\n            return rem ;\\n        }\\n        if(dp[row][mask] != -1) return dp[row][mask] ;\\n        int ans = INT_MAX ;\\n        \\n        for(int j = 0 ; j < c; ++j ) ans = min(ans,cost[row][j] + solve(row + 1 , mask|(1 << j) , cost )) ;\\n        return dp[row][mask] = ans ;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        r = cost.size() , c = cost[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        colMin.resize(c,INT_MAX) ;\\n        \\n        for(int i = 0 ; i < r ; ++i )\\n            for(int j = 0 ; j < c ; ++j )\\n                colMin[j] = min(colMin[j] ,cost[i][j]) ;\\n        \\n        return solve(0,0,cost) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r , c , dp[12][(1 << 12)] ; \\n    vector<int> colMin ; \\n    \\n    int solve(int row , int mask , vector<vector<int>> &cost){\\n        if(row >= r){\\n            int rem = 0 ;\\n            for(int j = 0 ; j < c ; ++j ){\\n                //take the remaining ones which were not in the mask \\n                if( !((1 << j) & mask)) rem += colMin[j] ;\\n            }\\n            return rem ;\\n        }\\n        if(dp[row][mask] != -1) return dp[row][mask] ;\\n        int ans = INT_MAX ;\\n        \\n        for(int j = 0 ; j < c; ++j ) ans = min(ans,cost[row][j] + solve(row + 1 , mask|(1 << j) , cost )) ;\\n        return dp[row][mask] = ans ;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        r = cost.size() , c = cost[0].size() ;\\n        memset(dp,-1,sizeof(dp)) ;\\n        colMin.resize(c,INT_MAX) ;\\n        \\n        for(int i = 0 ; i < r ; ++i )\\n            for(int j = 0 ; j < c ; ++j )\\n                colMin[j] = min(colMin[j] ,cost[i][j]) ;\\n        \\n        return solve(0,0,cost) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204940,
                "title": "c-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\nprivate:\\n    //memoization table with two variables:-\\n    //index->defines a point in group 1\\n    //config->is a bitmask used to keep a track of the points in group 2 which have been paired\\n    vector<vector<int>>mem;\\n    //stores the minimum cost required to connect a point in group 2 to any point in group 1\\n    vector<int>minCostForColumn;\\n    int solve(vector<vector<int>>&cost,int index,int config){\\n        int size1=cost.size(),size2=cost[0].size();\\n        if(index==size1){\\n            //all the group one points have been connected, the group two points which remain\\n            //will be connected to those points which have the least cost\\n            int ans=0;\\n            for(int i=0;i<size2;i++){\\n                if(((config>>i)&1)==0){\\n                    ans+=minCostForColumn[i];\\n                }\\n            }\\n            return ans;\\n        } else if(mem[index][config]!=-1){\\n            return mem[index][config];\\n        } else {\\n            int ans=1e9;\\n            //every point in group 1 is connected to atleast one point in group 2. Here we \\n            //brute force all possible options\\n            for(int i=0;i<size2;i++){\\n                ans=min(ans,cost[index][i]+solve(cost,index+1,config|(1<<i)));\\n            }\\n            return mem[index][config]=ans;\\n        }\\n    }\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int size1=cost.size(),size2=cost[0].size();\\n        minCostForColumn=vector<int>(size2,1e9);\\n        mem=vector<vector<int>>(size1,vector<int>(1<<size2,-1));\\n        //storing the minimum cost for each element in the second group of points\\n        for(int j=0;j<size2;j++){\\n            for(int i=0;i<size1;i++){\\n                minCostForColumn[j]=min(minCostForColumn[j],cost[i][j]);\\n            }\\n        }\\n        return solve(cost,0,0);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    //memoization table with two variables:-\\n    //index->defines a point in group 1\\n    //config->is a bitmask used to keep a track of the points in group 2 which have been paired\\n    vector<vector<int>>mem;\\n    //stores the minimum cost required to connect a point in group 2 to any point in group 1\\n    vector<int>minCostForColumn;\\n    int solve(vector<vector<int>>&cost,int index,int config){\\n        int size1=cost.size(),size2=cost[0].size();\\n        if(index==size1){\\n            //all the group one points have been connected, the group two points which remain\\n            //will be connected to those points which have the least cost\\n            int ans=0;\\n            for(int i=0;i<size2;i++){\\n                if(((config>>i)&1)==0){\\n                    ans+=minCostForColumn[i];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2169235,
                "title": "python-recursion-bit-manipulation-lru-cache",
                "content": "```\\nclass Solution:\\n    def connectTwoGroups(self, x: List[List[int]]) -> int:\\n        m,n=len(x),len(x[0])\\n        @lru_cache(None)\\n        def f(i,v):\\n            if i==m:\\n                return 0 if v==2**n-1 else inf\\n            ans=inf\\n            for j in range(n):\\n                if v&(1<<j)==0:\\n                    ans=min(ans,x[i][j]+min(f(i+1,(v|(1<<j))),f(i,(v|(1<<j)))))\\n                else:\\n                    ans=min(ans,x[i][j]+f(i+1,v))\\n            return ans\\n        return f(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, x: List[List[int]]) -> int:\\n        m,n=len(x),len(x[0])\\n        @lru_cache(None)\\n        def f(i,v):\\n            if i==m:\\n                return 0 if v==2**n-1 else inf\\n            ans=inf\\n            for j in range(n):\\n                if v&(1<<j)==0:\\n                    ans=min(ans,x[i][j]+min(f(i+1,(v|(1<<j))),f(i,(v|(1<<j)))))\\n                else:\\n                    ans=min(ans,x[i][j]+f(i+1,v))\\n            return ans\\n        return f(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106264,
                "title": "recursive-with-memorization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m,dp[13][4096],mn[13];\\n    \\n    int sol(int i,int mask,vector<vector<int>>& cost)\\n    {\\n        if(i==n)\\n        {\\n            int extra=0;\\n            for(int j=0;j<m;j++)\\n                if((mask & (1<<j)) == 0)\\n                    extra+=mn[j];\\n            return extra;\\n        }\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        for(int j=0;j<m;j++)\\n            ans=min(ans,cost[i][j]+sol(i+1,mask|(1<<j),cost));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        n=cost.size(); m=cost[0].size();\\n        \\n        for(int j=0;j<13;j++) mn[j]=1e9;\\n        for(int j=0;j<m;j++)\\n            for(int i=0;i<n;i++)\\n                mn[j]=min(mn[j],cost[i][j]);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,cost);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,dp[13][4096],mn[13];\\n    \\n    int sol(int i,int mask,vector<vector<int>>& cost)\\n    {\\n        if(i==n)\\n        {\\n            int extra=0;\\n            for(int j=0;j<m;j++)\\n                if((mask & (1<<j)) == 0)\\n                    extra+=mn[j];\\n            return extra;\\n        }\\n        \\n        int ans=dp[i][mask];\\n        if(ans!=-1) return ans;\\n        ans=1e9;\\n        \\n        for(int j=0;j<m;j++)\\n            ans=min(ans,cost[i][j]+sol(i+1,mask|(1<<j),cost));\\n        \\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        n=cost.size(); m=cost[0].size();\\n        \\n        for(int j=0;j<13;j++) mn[j]=1e9;\\n        for(int j=0;j<m;j++)\\n            for(int i=0;i<n;i++)\\n                mn[j]=min(mn[j],cost[i][j]);\\n        \\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079486,
                "title": "c-dp-with-bitmask-this-was-kinda-hard-for-me-even-after-reading-the-solutions",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\t// let us set the unpaired guy to 1 (1 means that guy is not paired with anyone)\\n\\n\\t/*\\n\\t\\tfirst understand the information given by mask :\\n\\t\\tmask tells us which node from the 2nd group is paired and which node from the second group is not paired\\n\\n\\t\\tfor example, if mask is 1001010 it means that the 0, 2, 4, 5 nodes [in the second group] are paired\\n\\t\\twith someone or the other in first group, and those indices which are 1 are still unpaired\\n\\n\\t\\tdp[i][mask] : the minimum cost to pair every node in the first group, starting from the i\\'th node, such that\\n\\t\\tthe state of the second group is given by mask\\n\\n\\t\\tnow the base case is when all the nodes in the group 1 have been paired, so in this case, we will simply\\n\\t\\tpair the unpaired nodes of the second group using each node\\'s minimum weight (the minimum weight which is connected to every node)\\n\\n\\t*/\\n\\n\\n\\tvector<int> minCost;\\n\\tint dp[13][((1 << 12) + 1)] = {{ -1}};\\n\\n\\tint solve(vector<vector<int>>& cost, int i, int maskB) {\\n\\n\\t\\t// cout << i << \\'\\\\n\\';\\n\\t\\tif (i == cost.size()) {\\n\\t\\t\\tint baseAns = 0;\\n\\n\\t\\t\\twhile (maskB) {\\n\\t\\t\\t\\tint j = maskB & -maskB;\\n\\t\\t\\t\\tint idx = log2(j);\\n\\t\\t\\t\\tbaseAns += minCost[idx];\\n\\t\\t\\t\\tmaskB -= j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn baseAns;\\n\\t\\t}\\n\\n\\t\\tif (dp[i][maskB] != -1) return dp[i][maskB];\\n\\n\\t\\tint ans = 1e9;\\n\\t\\tfor (int j = 0; j < cost[0].size(); j++) {\\n\\n\\t\\t\\tans = min(ans, cost[i][j] + solve(cost, i + 1, (maskB & (~(1 << j)))));\\n\\t\\t}\\n\\n\\t\\treturn dp[i][maskB] = ans;\\n\\t}\\n\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint m = cost.size();\\n\\t\\tint n = cost[0].size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\n\\t\\tminCost.resize(n, INT_MAX);\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tminCost[j] = min(minCost[j], cost[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn solve(cost, 0, ((1 << n) - 1));\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\t// let us set the unpaired guy to 1 (1 means that guy is not paired with anyone)\\n\\n\\t/*\\n\\t\\tfirst understand the information given by mask :\\n\\t\\tmask tells us which node from the 2nd group is paired and which node from the second group is not paired\\n\\n\\t\\tfor example, if mask is 1001010 it means that the 0, 2, 4, 5 nodes [in the second group] are paired\\n\\t\\twith someone or the other in first group, and those indices which are 1 are still unpaired\\n\\n\\t\\tdp[i][mask] : the minimum cost to pair every node in the first group, starting from the i\\'th node, such that\\n\\t\\tthe state of the second group is given by mask\\n\\n\\t\\tnow the base case is when all the nodes in the group 1 have been paired, so in this case, we will simply\\n\\t\\tpair the unpaired nodes of the second group using each node\\'s minimum weight (the minimum weight which is connected to every node)\\n\\n\\t*/\\n\\n\\n\\tvector<int> minCost;\\n\\tint dp[13][((1 << 12) + 1)] = {{ -1}};\\n\\n\\tint solve(vector<vector<int>>& cost, int i, int maskB) {\\n\\n\\t\\t// cout << i << \\'\\\\n\\';\\n\\t\\tif (i == cost.size()) {\\n\\t\\t\\tint baseAns = 0;\\n\\n\\t\\t\\twhile (maskB) {\\n\\t\\t\\t\\tint j = maskB & -maskB;\\n\\t\\t\\t\\tint idx = log2(j);\\n\\t\\t\\t\\tbaseAns += minCost[idx];\\n\\t\\t\\t\\tmaskB -= j;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn baseAns;\\n\\t\\t}\\n\\n\\t\\tif (dp[i][maskB] != -1) return dp[i][maskB];\\n\\n\\t\\tint ans = 1e9;\\n\\t\\tfor (int j = 0; j < cost[0].size(); j++) {\\n\\n\\t\\t\\tans = min(ans, cost[i][j] + solve(cost, i + 1, (maskB & (~(1 << j)))));\\n\\t\\t}\\n\\n\\t\\treturn dp[i][maskB] = ans;\\n\\t}\\n\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint m = cost.size();\\n\\t\\tint n = cost[0].size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\n\\t\\tminCost.resize(n, INT_MAX);\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\t\\tminCost[j] = min(minCost[j], cost[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn solve(cost, 0, ((1 << n) - 1));\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1983370,
                "title": "dp-with-bitmask-100-memory",
                "content": "Since the dp transition only depends on last row, we can shrink the dp dimension to just 2. (Previous row and current row) And update after each loop.\\n```\\nclass Solution {\\n    int sz1, sz2;\\n    const static int upper = 1 << 12;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost)\\n    {\\n        sz1 = cost.size(), sz2 = cost[0].size(); \\n        const int mask_sz = 1 << sz2;\\n        int dp_pre[upper], dp_cur[upper];\\n        fill(dp_pre, dp_pre + mask_sz, 0);\\n        fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        for(int j = 1; j < mask_sz; j++) //compute result for connecting first node on left\\n            for(int k = 0; k < sz2; k++)\\n                if(j & (1<<k))\\n                    dp_pre[j] += cost[0][k];                               \\n        \\n        for(int i = 1; i < sz1; i++){\\n            for(int j = 1; j < mask_sz; j++) //start 1 since 0 is impossible. Some on the right must included already\\n                for(int e = 0; e < sz2; e++)\\n                    dp_cur[j | (1 << e)] = min(dp_cur[j|(1<<e)], cost[i][e] + min(dp_pre[j], dp_cur[j]);\\n                \\n            swap(dp_pre, dp_cur);\\n            fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        }\\n        \\n        return dp_pre[mask_sz - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int sz1, sz2;\\n    const static int upper = 1 << 12;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost)\\n    {\\n        sz1 = cost.size(), sz2 = cost[0].size(); \\n        const int mask_sz = 1 << sz2;\\n        int dp_pre[upper], dp_cur[upper];\\n        fill(dp_pre, dp_pre + mask_sz, 0);\\n        fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        for(int j = 1; j < mask_sz; j++) //compute result for connecting first node on left\\n            for(int k = 0; k < sz2; k++)\\n                if(j & (1<<k))\\n                    dp_pre[j] += cost[0][k];                               \\n        \\n        for(int i = 1; i < sz1; i++){\\n            for(int j = 1; j < mask_sz; j++) //start 1 since 0 is impossible. Some on the right must included already\\n                for(int e = 0; e < sz2; e++)\\n                    dp_cur[j | (1 << e)] = min(dp_cur[j|(1<<e)], cost[i][e] + min(dp_pre[j], dp_cur[j]);\\n                \\n            swap(dp_pre, dp_cur);\\n            fill(dp_cur, dp_cur + mask_sz, INT_MAX);\\n        }\\n        \\n        return dp_pre[mask_sz - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1784196,
                "title": "dp",
                "content": "```\\nconst int N = 13, M = 1 << N;\\n\\nclass Solution {\\n    int f[N][M];\\n    \\npublic:\\n    // time: O(nm*2^m)\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        memset(f, 0x3f, sizeof f);\\n        \\n        f[0][0] = 0;\\n        for (int i = 1; i <= n; ++ i) // n\\n        {\\n            for (int j = 0; j < (1 << m); ++ j) // 2^m\\n            {\\n                for (int k = 0; k < m; ++ k) // m\\n                {\\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i][j] + cost[i-1][k]);   // \\u53EF\\u4EE5\\u9009\\u62E9\\u7EE7\\u7EED\\u7528\\u5F53\\u524D\\u70B9match \\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i-1][j] + cost[i-1][k]); // \\u53EF\\u4EE5\\u9009\\u62E9\\u8F6C\\u79FB\\u5230\\u4E0B\\u4E00\\u4E2A\\u70B9\\u8FDB\\u884Cmatch\\n                }\\n            }\\n        }\\n        \\n        return f[n][(1<<m)-1];\\n    }\\n};\\n\\n\\n// \\u8BFB\\u9898\\uFF1A\\u6570\\u7EC4\\u957F\\u5EA6\\u4E0D\\u540C\\uFF0C\\u6570\\u636E\\u8303\\u56F4\\u53EF\\u4EE5\\u72B6\\u6001\\u538B\\u7F29\\uFF0C \\u4E00\\u4E2A\\u70B9\\u53EF\\u4EE5\\u5339\\u914D\\u591A\\u4E2A\\u70B9\\uFF0C\\u4FDD\\u8BC1\\u6BCF\\u4E2A\\u70B9\\u81F3\\u5C11\\u6709\\u4E00\\u4E2A\\u5339\\u914D\\uFF0C\\n\\n\\n// dp:\\n//     \\u72B6\\u6001\\uFF1Af[i][j]: \\u7B2C\\u4E8C\\u7EC4\\u7684\\u72B6\\u6001\\u662Fi\\uFF0C\\u53EF\\u4EE5\\u5339\\u914D\\u6240\\u6709\\u7B2C\\u4E00\\u7EC4\\u7684\\u524Dj\\u4E2A\\u6570\\uFF0C\\u6700\\u5C0F\\u7684\\u82B1\\u8D39\\n//     \\u8F6C\\u79FB\\uFF1A \\n        \\n        \\n// 12 * 2^12 = 49152\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 13, M = 1 << N;\\n\\nclass Solution {\\n    int f[N][M];\\n    \\npublic:\\n    // time: O(nm*2^m)\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size(), m = cost[0].size();\\n        memset(f, 0x3f, sizeof f);\\n        \\n        f[0][0] = 0;\\n        for (int i = 1; i <= n; ++ i) // n\\n        {\\n            for (int j = 0; j < (1 << m); ++ j) // 2^m\\n            {\\n                for (int k = 0; k < m; ++ k) // m\\n                {\\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i][j] + cost[i-1][k]);   // \\u53EF\\u4EE5\\u9009\\u62E9\\u7EE7\\u7EED\\u7528\\u5F53\\u524D\\u70B9match \\n                    f[i][j|(1<<k)] = min(f[i][j|(1<<k)], f[i-1][j] + cost[i-1][k]); // \\u53EF\\u4EE5\\u9009\\u62E9\\u8F6C\\u79FB\\u5230\\u4E0B\\u4E00\\u4E2A\\u70B9\\u8FDB\\u884Cmatch\\n                }\\n            }\\n        }\\n        \\n        return f[n][(1<<m)-1];\\n    }\\n};\\n\\n\\n// \\u8BFB\\u9898\\uFF1A\\u6570\\u7EC4\\u957F\\u5EA6\\u4E0D\\u540C\\uFF0C\\u6570\\u636E\\u8303\\u56F4\\u53EF\\u4EE5\\u72B6\\u6001\\u538B\\u7F29\\uFF0C \\u4E00\\u4E2A\\u70B9\\u53EF\\u4EE5\\u5339\\u914D\\u591A\\u4E2A\\u70B9\\uFF0C\\u4FDD\\u8BC1\\u6BCF\\u4E2A\\u70B9\\u81F3\\u5C11\\u6709\\u4E00\\u4E2A\\u5339\\u914D\\uFF0C\\n\\n\\n// dp:\\n//     \\u72B6\\u6001\\uFF1Af[i][j]: \\u7B2C\\u4E8C\\u7EC4\\u7684\\u72B6\\u6001\\u662Fi\\uFF0C\\u53EF\\u4EE5\\u5339\\u914D\\u6240\\u6709\\u7B2C\\u4E00\\u7EC4\\u7684\\u524Dj\\u4E2A\\u6570\\uFF0C\\u6700\\u5C0F\\u7684\\u82B1\\u8D39\\n//     \\u8F6C\\u79FB\\uFF1A \\n        \\n        \\n// 12 * 2^12 = 49152\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722206,
                "title": "easiest-solution-to-understand-with-explanation-comments-c",
                "content": "-> We traverse through points in Group 1(assume g1) one by one and try to connect that particular point to all possible subsets in Group 2.(assume g2)\\n\\n***-> 2 important observations in this question is that :\\n\\n1. We can either connect the current point in G1 to a subset of points in G2 which are not already visited by any previous point.\\n2. GREEDY POINT : We can connect the current point P1 in G1 to exactly one point P2 which is already visited by any previous point in G1 and only if distance P1-P2 has to be shortest amongst all edges starting from P1. *\\n\\n=> Why ? Because P2 does not need P1 , it\\'s already connected to group 1 , so if any other edge exists starting from P1 (let\\'s say to some point P3 in group 2) whose weight is lesser than edge from P1-P2, then it makes sense to connect P1 and P3 , as here we are able to connect 2 unvisited points P1 and P3, with lesser edge weight , but if we connect P1 and P2, we connect only 1 unvisited point which is P1 and that too with more weight. \\n\\n=> So the only case in which we join P1 and P2 is  if distance of edge P1-P2 is shortest amongst all edges starting from P1. \\n\\n ```\\n So, dp[i][bitmask] = min(\\n\\t\\tdp[i+1][bitmask] + cost[i][node with shortest distance from i] , \\n\\t\\tminimum over ALL (dp[i+1][s] + Sum Of distances from node number i to the new subset of nodes we visted from i ) for all possible submasks \\'s\\' of current bitmask)\\n\\t\\t);\\n ```\\n\\n=> Initially bitmask = All 1s , where 1 denoted a node in Group 2 to be \"yet not connected \" and 0 indicates \"already connected\".\\n=> So we can actually use \"Submask Enumeration\" to generate all submasks of current bitmask. A Submask means \"All 0s remain 0s(connected remains connected), a subset of 1s in bitmask gets flipped to 0\".\\n\\n**Time Complexity : O( n*(2^m) )**\\n**Space Complexity : O( n*(2^m) )**\\n\\n```\\nclass Solution {\\npublic:\\n    const int INF = 100000;\\n    \\n    int dp[12][1<<12];\\n    \\n    int helper(int cur, int bitmask, vector<vector<int>>& cost,vector<int>& minCostFrom, vector<vector<int>>& preCost, vector<int> &Friend, int n, int m){\\n        if(cur==n){ \\n            if(bitmask==0)\\n                return 0;\\n            else\\n                return INF;\\n        }\\n        \\n        if(dp[cur][bitmask] != -1)\\n            return dp[cur][bitmask];\\n        \\n        // If you are joining \\'cur\\' node in group one with exactly one node in group 2, it doesn\\'t matter, whether that node in group 2 is already visited or not. Don\\'t forget to FLIP THE BIT.\\n        int ans = minCostFrom[cur] + helper(cur+1,bitmask & (~(1<<Friend[cur])),cost,minCostFrom,preCost,Friend,n,m);\\n        \\n        //Given a bitmask , you want to efficiently iterate through all of its submasks, that is, masks  in which only bits that were included in mask  are set, which is basically \"SUBMASK ENUMERATION\".\\n        int tmp_bitmask = bitmask;\\n        \\n        while(tmp_bitmask){\\n            //(tmp_bitmask-1) sets rightmost set bit 0 and all bits after it become 1. ANDing it with bitmask will generate next submask in descending. Learn in detail on CP algorithms website.\\n            tmp_bitmask = (tmp_bitmask-1) & bitmask; \\n            // 0s will remain 0 in submask , but some 1s turn to 0, to find out which 1s turn to 0, we take the difference So only the bits which changed from 1 to 0 will be SET , rest all will be 0s, so now just flip the bits using XOR.\\n            int tmp_bitmask2 = (bitmask - tmp_bitmask) ^ ((1<<m)-1);\\n            \\n            ans = min(ans,preCost[cur][tmp_bitmask2] + helper(cur+1,tmp_bitmask,cost,minCostFrom,preCost,Friend,n,m));\\n        }\\n        \\n        return dp[cur][bitmask] = ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        \\n        vector<int> minCostFrom(n,INT_MAX);\\n        vector<int> Friend(n);\\n        \\n        // Pre-store the weight of the shortest edge from every node \\'i\\'.\\n        //Friend[i] means the node in group 2 with shortest edge weight from \\'i\\'.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(cost[i][j] < minCostFrom[i]){\\n                    minCostFrom[i] = cost[i][j];\\n                    Friend[i] = j;\\n                }\\n            }\\n        }\\n        \\n        // Precalculate the Sum of Edges from every node \\'i\\' to all possible subsets in group 2.\\n        // If the ith bit from LSB in the bitmask is 1, that means that the ith node in the 2nd group is still not visited.\\n        vector<vector<int>> preCost(n,vector<int>(1<<m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum = 0;\\n                for(int k=0; k<m;k++){\\n                    if(((1<<k) & j) == 0){\\n                        sum+=cost[i][k];\\n                    }\\n                }\\n                preCost[i][j] = sum;\\n            }\\n        }\\n        \\n        for(int i=0;i<12;i++){\\n            for(int j=0; j<(1<<12); j++){\\n                dp[i][j] = -1;\\n            }    \\n        }\\n\\n        return helper(0,(1<<m)-1,cost,minCostFrom,preCost,Friend,n,m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n So, dp[i][bitmask] = min(\\n\\t\\tdp[i+1][bitmask] + cost[i][node with shortest distance from i] , \\n\\t\\tminimum over ALL (dp[i+1][s] + Sum Of distances from node number i to the new subset of nodes we visted from i ) for all possible submasks \\'s\\' of current bitmask)\\n\\t\\t);\\n ```\n```\\nclass Solution {\\npublic:\\n    const int INF = 100000;\\n    \\n    int dp[12][1<<12];\\n    \\n    int helper(int cur, int bitmask, vector<vector<int>>& cost,vector<int>& minCostFrom, vector<vector<int>>& preCost, vector<int> &Friend, int n, int m){\\n        if(cur==n){ \\n            if(bitmask==0)\\n                return 0;\\n            else\\n                return INF;\\n        }\\n        \\n        if(dp[cur][bitmask] != -1)\\n            return dp[cur][bitmask];\\n        \\n        // If you are joining \\'cur\\' node in group one with exactly one node in group 2, it doesn\\'t matter, whether that node in group 2 is already visited or not. Don\\'t forget to FLIP THE BIT.\\n        int ans = minCostFrom[cur] + helper(cur+1,bitmask & (~(1<<Friend[cur])),cost,minCostFrom,preCost,Friend,n,m);\\n        \\n        //Given a bitmask , you want to efficiently iterate through all of its submasks, that is, masks  in which only bits that were included in mask  are set, which is basically \"SUBMASK ENUMERATION\".\\n        int tmp_bitmask = bitmask;\\n        \\n        while(tmp_bitmask){\\n            //(tmp_bitmask-1) sets rightmost set bit 0 and all bits after it become 1. ANDing it with bitmask will generate next submask in descending. Learn in detail on CP algorithms website.\\n            tmp_bitmask = (tmp_bitmask-1) & bitmask; \\n            // 0s will remain 0 in submask , but some 1s turn to 0, to find out which 1s turn to 0, we take the difference So only the bits which changed from 1 to 0 will be SET , rest all will be 0s, so now just flip the bits using XOR.\\n            int tmp_bitmask2 = (bitmask - tmp_bitmask) ^ ((1<<m)-1);\\n            \\n            ans = min(ans,preCost[cur][tmp_bitmask2] + helper(cur+1,tmp_bitmask,cost,minCostFrom,preCost,Friend,n,m));\\n        }\\n        \\n        return dp[cur][bitmask] = ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        \\n        vector<int> minCostFrom(n,INT_MAX);\\n        vector<int> Friend(n);\\n        \\n        // Pre-store the weight of the shortest edge from every node \\'i\\'.\\n        //Friend[i] means the node in group 2 with shortest edge weight from \\'i\\'.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(cost[i][j] < minCostFrom[i]){\\n                    minCostFrom[i] = cost[i][j];\\n                    Friend[i] = j;\\n                }\\n            }\\n        }\\n        \\n        // Precalculate the Sum of Edges from every node \\'i\\' to all possible subsets in group 2.\\n        // If the ith bit from LSB in the bitmask is 1, that means that the ith node in the 2nd group is still not visited.\\n        vector<vector<int>> preCost(n,vector<int>(1<<m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<(1<<m);j++){\\n                int sum = 0;\\n                for(int k=0; k<m;k++){\\n                    if(((1<<k) & j) == 0){\\n                        sum+=cost[i][k];\\n                    }\\n                }\\n                preCost[i][j] = sum;\\n            }\\n        }\\n        \\n        for(int i=0;i<12;i++){\\n            for(int j=0; j<(1<<12); j++){\\n                dp[i][j] = -1;\\n            }    \\n        }\\n\\n        return helper(0,(1<<m)-1,cost,minCostFrom,preCost,Friend,n,m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638973,
                "title": "golang-dp-w-bitmask",
                "content": "if we use a bitmask representation, can reduce to 12 * 2^12 space\\n\\nnumber of ways to represent the 12 bits = 2^12 = 4096\\n\\nidea is to just try out every combination of choosing an element in group 1 to connect to an element in group 2.\\n\\nthen when all elements in group 1 is connected to group 2, for all elements unconnected in group 2, connect it to group 1 with the min cost to connect to an element in group 1. \\n\\nbitmask is used to indicate which element in group 2 has been connected.\\n\\nnot my idea, read from other solutions, posting this as reference for golang implementation\\n\\n\\n```\\nfunc connectTwoGroups(cost [][]int) int {\\n    // dp problem, try out every possibility\\n    size1, size2 := len(cost), len(cost[0])\\n    \\n    cache := make([][]*int, size1)\\n    for i := range cache {\\n        cache[i] = make([]*int, 1 << size2)\\n    }\\n    \\n    minCost2To1 := make([]int, size2)\\n    for j := range cost[0] {\\n        m := math.MaxInt32\\n        for i := range cost {\\n            m = min(m, cost[i][j])\\n        }\\n        minCost2To1[j] = m\\n    }\\n    \\n    return dfs(&cache, minCost2To1, cost, 0, 0)\\n}\\n\\n// mask keeps track of which element in second group is not yet connected\\nfunc dfs(cache *[][]*int, minCost2To1 []int, cost [][]int, i, mask int) int {\\n    if i == len(cost) {  // all in group 1 is connected\\n        res := 0\\n        // connect all group 2 that are not yet connect\\n        for j := range cost[0] {\\n            if mask & (1 << j) == 0 {  // bit unset at index j means element j in group 2 not yet connected\\n                res += minCost2To1[j]  // add the min cost\\n            }\\n        }\\n        return res\\n    }\\n    \\n    if (*cache)[i][mask] != nil {\\n        return *(*cache)[i][mask]\\n    }\\n    \\n    res := math.MaxInt32\\n    for j := range cost[i] {  // try to connect i (an element in group 1) to 1 of the elements in group 2\\n        res = min(res, dfs(cache, minCost2To1, cost, i+1, mask | (1 << j)) + cost[i][j])\\n    }\\n    \\n    (*cache)[i][mask] = &res\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc connectTwoGroups(cost [][]int) int {\\n    // dp problem, try out every possibility\\n    size1, size2 := len(cost), len(cost[0])\\n    \\n    cache := make([][]*int, size1)\\n    for i := range cache {\\n        cache[i] = make([]*int, 1 << size2)\\n    }\\n    \\n    minCost2To1 := make([]int, size2)\\n    for j := range cost[0] {\\n        m := math.MaxInt32\\n        for i := range cost {\\n            m = min(m, cost[i][j])\\n        }\\n        minCost2To1[j] = m\\n    }\\n    \\n    return dfs(&cache, minCost2To1, cost, 0, 0)\\n}\\n\\n// mask keeps track of which element in second group is not yet connected\\nfunc dfs(cache *[][]*int, minCost2To1 []int, cost [][]int, i, mask int) int {\\n    if i == len(cost) {  // all in group 1 is connected\\n        res := 0\\n        // connect all group 2 that are not yet connect\\n        for j := range cost[0] {\\n            if mask & (1 << j) == 0 {  // bit unset at index j means element j in group 2 not yet connected\\n                res += minCost2To1[j]  // add the min cost\\n            }\\n        }\\n        return res\\n    }\\n    \\n    if (*cache)[i][mask] != nil {\\n        return *(*cache)[i][mask]\\n    }\\n    \\n    res := math.MaxInt32\\n    for j := range cost[i] {  // try to connect i (an element in group 1) to 1 of the elements in group 2\\n        res = min(res, dfs(cache, minCost2To1, cost, i+1, mask | (1 << j)) + cost[i][j])\\n    }\\n    \\n    (*cache)[i][mask] = &res\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1582370,
                "title": "python-o-n-3-m",
                "content": "Our state is, we are choosing connections for i-th node of the 1st group, while already picked connections for some subset of 2nd group represented in bits. We can pick one connection for i-th node from already picked ones, in this case our subset represented as bits doesn\\'t change. Or we pick some subset of node from complement of already picked, which are subsets of bits ^ (2 ** m - 1). Number of such subsets for each possible bits value in total is 3 ^ m. Thus our complexity. To speed up we precompute some sums and minimums, and also write dp non-recursively.\\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        p2m = 1 << m\\n        inf = 10 ** 9\\n\\n        pc_summs = [[0 for __ in range(p2m)] for _ in range(n)]\\n        pc_mins = [[inf for __ in range(p2m)] for _ in range(n)]\\n\\n        for i in range(n):\\n            for bits in range(p2m):\\n                for b in range(m):\\n                    if (1 << b) & bits:\\n                        pc_summs[i][bits] += cost[i][b]\\n                        pc_mins[i][bits] = min(pc_mins[i][bits], cost[i][b])\\n\\n        dp = [[inf for __ in range(p2m)] for _ in range(n + 1)]\\n        dp[n][p2m - 1] = 0\\n\\n        for i in range(n - 1, -1, -1):\\n            for bits in range(p2m):\\n                if i == 0 and bits > 0: break\\n                if bits != 0:\\n                    dp[i][bits] = pc_mins[i][bits] + dp[i + 1][bits]\\n\\n                mask = bits ^ (p2m - 1)\\n                x = mask\\n                while x != 0:\\n                    mn = pc_summs[i][x] + dp[i + 1][bits | x]\\n                    dp[i][bits] = min(dp[i][bits] , mn)\\n                    x = (x - 1) & mask\\n\\n        return dp[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost):\\n        n, m = len(cost), len(cost[0])\\n        p2m = 1 << m\\n        inf = 10 ** 9\\n\\n        pc_summs = [[0 for __ in range(p2m)] for _ in range(n)]\\n        pc_mins = [[inf for __ in range(p2m)] for _ in range(n)]\\n\\n        for i in range(n):\\n            for bits in range(p2m):\\n                for b in range(m):\\n                    if (1 << b) & bits:\\n                        pc_summs[i][bits] += cost[i][b]\\n                        pc_mins[i][bits] = min(pc_mins[i][bits], cost[i][b])\\n\\n        dp = [[inf for __ in range(p2m)] for _ in range(n + 1)]\\n        dp[n][p2m - 1] = 0\\n\\n        for i in range(n - 1, -1, -1):\\n            for bits in range(p2m):\\n                if i == 0 and bits > 0: break\\n                if bits != 0:\\n                    dp[i][bits] = pc_mins[i][bits] + dp[i + 1][bits]\\n\\n                mask = bits ^ (p2m - 1)\\n                x = mask\\n                while x != 0:\\n                    mn = pc_summs[i][x] + dp[i + 1][bits | x]\\n                    dp[i][bits] = min(dp[i][bits] , mn)\\n                    x = (x - 1) & mask\\n\\n        return dp[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529616,
                "title": "c-dp-bitmask-t-c-s-c-o-n-m-2-min-n-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[13][13][(1<<12)+1][2];\\n    long long go(int n1,int n2,int a,vector<vector<int>>& cost,bool f)\\n    {\\n        if(n2==cost[0].size())\\n        {\\n            if(f==0)  return INT_MAX;\\n            return go(n1+1,0,a,cost,0);\\n        }\\n        if(n1==cost.size())\\n        {\\n            if(a==(1<<cost[0].size())-1) return 0;\\n            return INT_MAX;\\n        }\\n        if(dp[n1][n2][a][f]!=-1) return dp[n1][n2][a][f];\\n        return dp[n1][n2][a][f]=min(go(n1,n2+1,a|(1<<n2),cost,1)+cost[n1][n2],go(n1,n2+1,a,cost,f));\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,0,0,cost,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[13][13][(1<<12)+1][2];\\n    long long go(int n1,int n2,int a,vector<vector<int>>& cost,bool f)\\n    {\\n        if(n2==cost[0].size())\\n        {\\n            if(f==0)  return INT_MAX;\\n            return go(n1+1,0,a,cost,0);\\n        }\\n        if(n1==cost.size())\\n        {\\n            if(a==(1<<cost[0].size())-1) return 0;\\n            return INT_MAX;\\n        }\\n        if(dp[n1][n2][a][f]!=-1) return dp[n1][n2][a][f];\\n        return dp[n1][n2][a][f]=min(go(n1,n2+1,a|(1<<n2),cost,1)+cost[n1][n2],go(n1,n2+1,a,cost,f));\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        memset(dp,-1,sizeof(dp));\\n        return go(0,0,0,cost,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465826,
                "title": "python-recursive-solutions-with-a-boolean-array-or-bitmask",
                "content": "__Solution 1__: First make all connection from group A (size1) to group B (size2). Finaly, we need to add the cost for the still unconnected nodes in group B. In order to solve this issue, we keep track of the connected nodes in group B with a boolean array. \\n```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tdef dfs(i, valid):\\n\\t\\tif i == size1: return sum([(not v)*d for v,d in zip(valid, dist)])        \\n\\t\\ttup = (i, tuple(valid)) # we need an immutable object for caching\\n\\t\\tif tup in memo: return memo[tup]\\n\\t\\t\\t   \\n\\t\\tans = float(\\'inf\\')\\n\\t\\t# loop over all possibilities\\n\\t\\tfor j in range(size2):\\n\\t\\t\\ttemp = valid[j]\\n\\t\\t\\tvalid[j]=True\\n\\t\\t\\tans = min(ans, cost[i][j] + dfs(i+1, valid))\\n\\t\\t\\tif not temp:\\n\\t\\t\\t\\tvalid[j]=False\\n\\t\\tmemo[tup] = ans\\n\\t\\treturn ans\\n\\t\\n\\t# declare\\n\\tsize1, size2 = len(cost), len(cost[0])\\n\\tvalid = [False]*size2 # to keep track which node in size2 is already assigned\\n\\tmemo = {}    \\n\\tdist = [0]*size2\\n\\t\\t\\n\\t# precomputed minimum sum to connect final points in size2. \\n\\tfor j in range(size2):\\n\\t\\tdist[j] = min(cost[i][j] for i in range(size1))\\n\\t\\t\\n\\treturn dfs(0, valid)\\n```\\n__Solution 2__: Now we will use a bitmask instead of an array. The principle is the same as before.\\n```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t @lru_cache(None)\\n\\t def dfs(i, mask):\\n\\t\\t if i == size1: return sum((not(mask & (1 << j)))*dist[j] for j in range(size2))\\n\\t\\t ans = float(\\'inf\\')\\n\\t\\t for j in range(size2):\\n\\t\\t\\t ans = min(ans, cost[i][j]+dfs(i+1, mask | (1<<j)))\\n\\t\\t return ans\\n\\t size1, size2 = len(cost), len(cost[0])\\n\\t dist = [0]*size2\\n\\t for j in range(size2):\\n\\t\\t dist[j] = min(cost[i][j] for i in range(size1))\\n\\t return dfs(0, 0)\\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:\\n\\tdef dfs(i, valid):\\n\\t\\tif i == size1: return sum([(not v)*d for v,d in zip(valid, dist)])        \\n\\t\\ttup = (i, tuple(valid)) # we need an immutable object for caching\\n\\t\\tif tup in memo: return memo[tup]\\n\\t\\t\\t   \\n\\t\\tans = float(\\'inf\\')\\n\\t\\t# loop over all possibilities\\n\\t\\tfor j in range(size2):\\n\\t\\t\\ttemp = valid[j]\\n\\t\\t\\tvalid[j]=True\\n\\t\\t\\tans = min(ans, cost[i][j] + dfs(i+1, valid))\\n\\t\\t\\tif not temp:\\n\\t\\t\\t\\tvalid[j]=False\\n\\t\\tmemo[tup] = ans\\n\\t\\treturn ans\\n\\t\\n\\t# declare\\n\\tsize1, size2 = len(cost), len(cost[0])\\n\\tvalid = [False]*size2 # to keep track which node in size2 is already assigned\\n\\tmemo = {}    \\n\\tdist = [0]*size2\\n\\t\\t\\n\\t# precomputed minimum sum to connect final points in size2. \\n\\tfor j in range(size2):\\n\\t\\tdist[j] = min(cost[i][j] for i in range(size1))\\n\\t\\t\\n\\treturn dfs(0, valid)\\n```\n```\\ndef connectTwoGroups(self, cost: List[List[int]]) -> int:        \\n\\t @lru_cache(None)\\n\\t def dfs(i, mask):\\n\\t\\t if i == size1: return sum((not(mask & (1 << j)))*dist[j] for j in range(size2))\\n\\t\\t ans = float(\\'inf\\')\\n\\t\\t for j in range(size2):\\n\\t\\t\\t ans = min(ans, cost[i][j]+dfs(i+1, mask | (1<<j)))\\n\\t\\t return ans\\n\\t size1, size2 = len(cost), len(cost[0])\\n\\t dist = [0]*size2\\n\\t for j in range(size2):\\n\\t\\t dist[j] = min(cost[i][j] for i in range(size1))\\n\\t return dfs(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1348758,
                "title": "c-dp-bitmask-o-n-2-m-m",
                "content": "```\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        int dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=0;\\n                    for(int k=0;k<m;k++){\\n                        if(!(j&(1<<k))){\\n                            int best=cost[0][k];\\n                            for(int l=1;l<n;l++){\\n                                best=min(best,cost[l][k]);\\n                            }\\n                            dp[i][j]+=best;\\n                        }\\n                    }\\n                }else{\\n                    dp[i][j]=INT_MAX;\\n                    for(int k=0;k<m;k++){\\n                        dp[i][j]=min(dp[i][j],cost[i][k]+dp[i+1][j|(1<<k)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n        int n=cost.size();\\n        int m=cost[0].size();\\n        int dp[n+1][1<<m];\\n        for(int i=n;i>=0;i--){\\n            for(int j=0;j<(1<<m);j++){\\n                if(i==n){\\n                    dp[i][j]=0;\\n                    for(int k=0;k<m;k++){\\n                        if(!(j&(1<<k))){\\n                            int best=cost[0][k];\\n                            for(int l=1;l<n;l++){\\n                                best=min(best,cost[l][k]);\\n                            }\\n                            dp[i][j]+=best;\\n                        }\\n                    }\\n                }else{\\n                    dp[i][j]=INT_MAX;\\n                    for(int k=0;k<m;k++){\\n                        dp[i][j]=min(dp[i][j],cost[i][k]+dp[i+1][j|(1<<k)]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333592,
                "title": "very-clean-code-by-memoization-dfs-with-bit-mask-scala",
                "content": "```scala\\n\\n  def connectTwoGroups(cost: List[List[Int]]): Int = {\\n    type int = Int\\n    val m  = cost.length\\n    val n  = cost(0).length\\n    var rm = 0\\n    (0 until n).foreach(x => rm = rm | (1 << x))\\n\\n    val tab = Array.ofDim[int](m, n, rm + 1)\\n\\n    def f(leftIdx: int, rightIdx: int, right: int): int = {\\n\\n      if (leftIdx == m && right == rm) return 0\\n      if (rightIdx == n || leftIdx == m) return Integer.MAX_VALUE\\n      if (tab(leftIdx)(rightIdx)(right) == 0) {\\n        var a = f(leftIdx, rightIdx + 1, right | (1 << rightIdx))\\n        var b = f(leftIdx + 1, 0, right | (1 << rightIdx))\\n        tab(leftIdx)(rightIdx)(right) = f(leftIdx, rightIdx + 1, right)\\n        if (a != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), a + cost(leftIdx)(rightIdx))\\n        if (b != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), b + cost(leftIdx)(rightIdx))\\n      }\\n      tab(leftIdx)(rightIdx)(right)\\n    }\\n\\n    f(0, 0, 0)\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n\\n  def connectTwoGroups(cost: List[List[Int]]): Int = {\\n    type int = Int\\n    val m  = cost.length\\n    val n  = cost(0).length\\n    var rm = 0\\n    (0 until n).foreach(x => rm = rm | (1 << x))\\n\\n    val tab = Array.ofDim[int](m, n, rm + 1)\\n\\n    def f(leftIdx: int, rightIdx: int, right: int): int = {\\n\\n      if (leftIdx == m && right == rm) return 0\\n      if (rightIdx == n || leftIdx == m) return Integer.MAX_VALUE\\n      if (tab(leftIdx)(rightIdx)(right) == 0) {\\n        var a = f(leftIdx, rightIdx + 1, right | (1 << rightIdx))\\n        var b = f(leftIdx + 1, 0, right | (1 << rightIdx))\\n        tab(leftIdx)(rightIdx)(right) = f(leftIdx, rightIdx + 1, right)\\n        if (a != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), a + cost(leftIdx)(rightIdx))\\n        if (b != Integer.MAX_VALUE)\\n          tab(leftIdx)(rightIdx)(right) =\\n            Math.min(tab(leftIdx)(rightIdx)(right), b + cost(leftIdx)(rightIdx))\\n      }\\n      tab(leftIdx)(rightIdx)(right)\\n    }\\n\\n    f(0, 0, 0)\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1109167,
                "title": "explanation-of-test-case",
                "content": "Can someone explain how the answer for this test case is 4.\\n[[1, 3, 5], [4, 1, 1], [1, 5, 3]]\\n\\nAccording to me the answer should be 5.\\n",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1077612,
                "title": "java-dp-using-bitmask-different-recursive-approach-time-o-n-m-2-m",
                "content": "```\\nclass Solution {\\n\\n    private static int FULL_BITMASK;\\n    \\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        FULL_BITMASK = (1 << cost.get(0).size()) - 1;        \\n        int[][][] memo = new int[cost.size()][FULL_BITMASK + 1][2];\\n        \\n        return find(memo, cost, 0, 0, -1, -1);\\n    }\\n    \\n    private int find(int[][][] memo, List<List<Integer>> cost, int posA, int usedB, int lastA, int lastB) {\\n        if(posA == cost.size())\\n            return usedB == FULL_BITMASK ? 0 : Integer.MAX_VALUE;\\n        \\n        // we have two state from each (posA, usedB)\\n        // first state is if we reached (posA, usedB) from a previous A point\\n        // second state is if we reached (posA, usedB) from the same A point\\n        int token = (posA == lastA) ? 0 : 1;\\n        \\n        if(memo[posA][usedB][token] != 0)\\n            return memo[posA][usedB][token];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < cost.get(posA).size(); i++) {            \\n            int mask = 1 << i;  \\n            int res;\\n            \\n            // Connection from current A point -> B point (i)\\n            // Continue to add edges from current A point to other B points\\n            if((usedB & mask) == 0 && (posA != lastA || lastB < i)) {\\n                res = find(memo, cost, posA, usedB | mask, posA, i);\\n                if(res != Integer.MAX_VALUE)\\n                    min = Math.min(min, res + cost.get(posA).get(i));\\n            }\\n            \\n            // Connection from current A point -> B point (i)\\n            // Do not add futher connections from current A point, go to next A point\\n            res = find(memo, cost, posA + 1, usedB | mask, posA, i);\\n            if(res != Integer.MAX_VALUE)\\n                min = Math.min(min, res + cost.get(posA).get(i));\\n        }\\n        \\n        memo[posA][usedB][token] = min;\\n        return min;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    private static int FULL_BITMASK;\\n    \\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        FULL_BITMASK = (1 << cost.get(0).size()) - 1;        \\n        int[][][] memo = new int[cost.size()][FULL_BITMASK + 1][2];\\n        \\n        return find(memo, cost, 0, 0, -1, -1);\\n    }\\n    \\n    private int find(int[][][] memo, List<List<Integer>> cost, int posA, int usedB, int lastA, int lastB) {\\n        if(posA == cost.size())\\n            return usedB == FULL_BITMASK ? 0 : Integer.MAX_VALUE;\\n        \\n        // we have two state from each (posA, usedB)\\n        // first state is if we reached (posA, usedB) from a previous A point\\n        // second state is if we reached (posA, usedB) from the same A point\\n        int token = (posA == lastA) ? 0 : 1;\\n        \\n        if(memo[posA][usedB][token] != 0)\\n            return memo[posA][usedB][token];\\n        \\n        int min = Integer.MAX_VALUE;\\n        for(int i = 0; i < cost.get(posA).size(); i++) {            \\n            int mask = 1 << i;  \\n            int res;\\n            \\n            // Connection from current A point -> B point (i)\\n            // Continue to add edges from current A point to other B points\\n            if((usedB & mask) == 0 && (posA != lastA || lastB < i)) {\\n                res = find(memo, cost, posA, usedB | mask, posA, i);\\n                if(res != Integer.MAX_VALUE)\\n                    min = Math.min(min, res + cost.get(posA).get(i));\\n            }\\n            \\n            // Connection from current A point -> B point (i)\\n            // Do not add futher connections from current A point, go to next A point\\n            res = find(memo, cost, posA + 1, usedB | mask, posA, i);\\n            if(res != Integer.MAX_VALUE)\\n                min = Math.min(min, res + cost.get(posA).get(i));\\n        }\\n        \\n        memo[posA][usedB][token] = min;\\n        return min;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061269,
                "title": "top-down-memorization",
                "content": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    Map<Integer, Integer> minCostForGroupB;\\n    int[][] mem;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        m = cost.size();\\n        n = cost.get(0).size();\\n        boolean[] visited = new boolean[n];\\n        minCostForGroupB = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0; j<m; j++){\\n                min = Math.min(min, cost.get(j).get(i));\\n            }\\n            minCostForGroupB.put(i, min);\\n        }\\n        mem = new int[13][4096];\\n        for(int[] val : mem){\\n            Arrays.fill(val, -1);\\n        }\\n        return dfs(cost, 0, visited);\\n    }\\n    \\n    private int dfs(List<List<Integer>> cost, int current, boolean[] visited){\\n        int mask = getMask(visited);\\n        if(mem[current][mask]!=-1){\\n            return mem[current][mask];\\n        }\\n        if(current==m){\\n            //search through all unvisited element in B, and pick smallest cost\\n            int sum = 0;\\n            for(int i=0; i<n; i++){\\n                if(visited[i]){\\n                    continue;\\n                }\\n                sum += minCostForGroupB.get(i);\\n            }\\n            mem[current][mask] = sum;\\n            return sum;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            boolean oldValue = visited[i];\\n            visited[i] = true;\\n            int temp = cost.get(current).get(i) + dfs(cost, current+1, visited);\\n            min = Math.min(min, temp);\\n            visited[i] = oldValue;\\n        }\\n        mem[current][mask] = min;\\n        return min;\\n    }\\n    \\n    private int getMask(boolean[] visited){\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum *= 2;\\n            if(visited[i]){\\n                sum += 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m;\\n    int n;\\n    Map<Integer, Integer> minCostForGroupB;\\n    int[][] mem;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        m = cost.size();\\n        n = cost.get(0).size();\\n        boolean[] visited = new boolean[n];\\n        minCostForGroupB = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            int min = Integer.MAX_VALUE;\\n            for(int j=0; j<m; j++){\\n                min = Math.min(min, cost.get(j).get(i));\\n            }\\n            minCostForGroupB.put(i, min);\\n        }\\n        mem = new int[13][4096];\\n        for(int[] val : mem){\\n            Arrays.fill(val, -1);\\n        }\\n        return dfs(cost, 0, visited);\\n    }\\n    \\n    private int dfs(List<List<Integer>> cost, int current, boolean[] visited){\\n        int mask = getMask(visited);\\n        if(mem[current][mask]!=-1){\\n            return mem[current][mask];\\n        }\\n        if(current==m){\\n            //search through all unvisited element in B, and pick smallest cost\\n            int sum = 0;\\n            for(int i=0; i<n; i++){\\n                if(visited[i]){\\n                    continue;\\n                }\\n                sum += minCostForGroupB.get(i);\\n            }\\n            mem[current][mask] = sum;\\n            return sum;\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<n; i++){\\n            boolean oldValue = visited[i];\\n            visited[i] = true;\\n            int temp = cost.get(current).get(i) + dfs(cost, current+1, visited);\\n            min = Math.min(min, temp);\\n            visited[i] = oldValue;\\n        }\\n        mem[current][mask] = min;\\n        return min;\\n    }\\n    \\n    private int getMask(boolean[] visited){\\n        int sum = 0;\\n        for(int i=0; i<n; i++){\\n            sum *= 2;\\n            if(visited[i]){\\n                sum += 1;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974882,
                "title": "p23-5",
                "content": "Hins\\nUse bitmask\\nFrom left we can go either to\\n1 - a node in right which is already assigned or\\n2 - subste of non-assigned nodes on right sid\\nFor all possible subsets on right which have not yet been assigned is\\nall x(from 1 to (1<<size2)-1) and also (x&(bm) == 0)",
                "solutionTags": [],
                "code": "Hins\\nUse bitmask\\nFrom left we can go either to\\n1 - a node in right which is already assigned or\\n2 - subste of non-assigned nodes on right sid\\nFor all possible subsets on right which have not yet been assigned is\\nall x(from 1 to (1<<size2)-1) and also (x&(bm) == 0)",
                "codeTag": "Unknown"
            },
            {
                "id": 924995,
                "title": "python-solution",
                "content": "idea : https://www.youtube.com/watch?v=hq0IVf1Falk\\n\\n```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def solve(index ,mask):\\n            if index == size1:\\n                ans2 = 0\\n                for j in range(size2):\\n                    if (mask & (1<<j)) == 0:\\n                        ans2+=mincost[j]\\n                return ans2\\n            ans = sys.maxsize\\n            for j in range(size2):\\n                ans = min(ans,cost[index][j] + solve(index+1 , mask | (1<<j)))\\n            return ans\\n        size1 = len(cost)\\n        size2 = len(cost[0])\\n        mincost = [sys.maxsize]*size2\\n        for j in range(size2):\\n            for i in range(size1):\\n                mincost[j] = min(mincost[j] , cost[i][j])\\n        return solve(0,0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\\n        @lru_cache(None)\\n        def solve(index ,mask):\\n            if index == size1:\\n                ans2 = 0\\n                for j in range(size2):\\n                    if (mask & (1<<j)) == 0:\\n                        ans2+=mincost[j]\\n                return ans2\\n            ans = sys.maxsize\\n            for j in range(size2):\\n                ans = min(ans,cost[index][j] + solve(index+1 , mask | (1<<j)))\\n            return ans\\n        size1 = len(cost)\\n        size2 = len(cost[0])\\n        mincost = [sys.maxsize]*size2\\n        for j in range(size2):\\n            for i in range(size1):\\n                mincost[j] = min(mincost[j] , cost[i][j])\\n        return solve(0,0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 920138,
                "title": "java-dp-bitmask-33-ms-faster-than-59-93-36-6-mb-less-than-5-11",
                "content": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int t = 1 << n;\\n        int[][] dp = new int[2][t];\\n        Arrays.fill(dp[0], Integer.MAX_VALUE);\\n        int old = 0;\\n        int now = 0;\\n        dp[now][0] = 0;\\n        for (int i = 0; i < m; ++i) {\\n            old = now;\\n            now = 1 - now;\\n            Arrays.fill(dp[now], Integer.MAX_VALUE);\\n            for (int j = 0; j < t; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    int mask = j | (1 << k);\\n                    if (dp[old][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[old][j] + cost.get(i).get(k));\\n                    }\\n                    if ((j & (1 << k)) == 0 && dp[now][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[now][j] + cost.get(i).get(k));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[now][t - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        int m = cost.size();\\n        int n = cost.get(0).size();\\n        int t = 1 << n;\\n        int[][] dp = new int[2][t];\\n        Arrays.fill(dp[0], Integer.MAX_VALUE);\\n        int old = 0;\\n        int now = 0;\\n        dp[now][0] = 0;\\n        for (int i = 0; i < m; ++i) {\\n            old = now;\\n            now = 1 - now;\\n            Arrays.fill(dp[now], Integer.MAX_VALUE);\\n            for (int j = 0; j < t; ++j) {\\n                for (int k = 0; k < n; ++k) {\\n                    int mask = j | (1 << k);\\n                    if (dp[old][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[old][j] + cost.get(i).get(k));\\n                    }\\n                    if ((j & (1 << k)) == 0 && dp[now][j] != Integer.MAX_VALUE) {\\n                        dp[now][mask] = Math.min(dp[now][mask], dp[now][j] + cost.get(i).get(k));\\n                    }\\n                }\\n            }\\n        }\\n        return dp[now][t - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900063,
                "title": "ruby-dfs-bitmask-beats-100",
                "content": "1. @hash[i][bits] means the cost for (0..i) left group matched with right group.\\n2. Initialy, @hash[i][bits] come from the @hash[i-1][bits].\\n3. @hash[i][bits1] come from @hash[i][bits] by add @cost[i][j], and the **bits1 = bits | (1 << j)**.\\n\\n```\\ndef dfs(i, cur, from)\\n  @cost[i].each_with_index do |tmp, j|\\n    state = cur | (1 << j)\\n    cost = @hash[from][cur] + @cost[i][j]\\n    next if @hash[i][state] && cost >= @hash[i][state] || @hash[i][@key] && cost > @hash[i][@key]\\n    @hash[i][state] = cost\\n    dfs(i, state, i)\\n  end\\nend\\n\\n# @param {Integer[][]} cost\\n# @return {Integer}\\ndef connect_two_groups(cost)\\n  @cost, @n, @m, @hash = cost, cost.size, cost[0].size, { -1 => {0 => 0} }\\n  @key = (1 << @m) - 1\\n\\n  (0..@n-1).each do |i|\\n    @hash[i] = {}\\n    @hash[i-1].each { |cur, total| dfs(i, cur, i-1) }\\n  end\\n  @hash[@n-1][@key]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef dfs(i, cur, from)\\n  @cost[i].each_with_index do |tmp, j|\\n    state = cur | (1 << j)\\n    cost = @hash[from][cur] + @cost[i][j]\\n    next if @hash[i][state] && cost >= @hash[i][state] || @hash[i][@key] && cost > @hash[i][@key]\\n    @hash[i][state] = cost\\n    dfs(i, state, i)\\n  end\\nend\\n\\n# @param {Integer[][]} cost\\n# @return {Integer}\\ndef connect_two_groups(cost)\\n  @cost, @n, @m, @hash = cost, cost.size, cost[0].size, { -1 => {0 => 0} }\\n  @key = (1 << @m) - 1\\n\\n  (0..@n-1).each do |i|\\n    @hash[i] = {}\\n    @hash[i-1].each { |cur, total| dfs(i, cur, i-1) }\\n  end\\n  @hash[@n-1][@key]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 875137,
                "title": "c-dp-bitmasking-comments-with-explaination",
                "content": "```\\nclass Solution {\\n#define inf 1e6\\npublic:\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint n = cost.size();\\n\\t\\tint m = cost[0].size();\\n\\t\\tint allDone = (1 << m) - 1;\\n\\t\\tint dp[n + 1][allDone + 2];\\n\\t\\tint score[allDone + 2];\\n\\t\\tint mi[m];\\n\\n\\t\\t// calculating the minimum incoming edge for each person in grp b\\n\\t\\t// This is handy in below loop\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tmi[i] = inf;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t\\tmi[i] = min(mi[i], cost[j][i]);\\n\\t\\t}\\n\\n\\t\\t// precomputing the scores of each leftover people mask\\n\\t\\t// This would come handy in the base case (again below loop :\\\\)\\n\\t\\tfor (int i = 0; i <= allDone + 1; i++) {\\n\\t\\t\\tint &ans = score[i];\\n\\t\\t\\tans = 0;\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (i & (1 << j)) ans += mi[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// actual bottom up dp\\n\\t\\tfor (int i = n;  i >= 0; i--) {\\n\\t\\t\\tfor (int mask = 0; mask <= allDone; mask++) {\\n\\t\\t\\t\\tif (i == n) { \\n                    // all people that are left over needs to be matched with the min cost edges (we calculated this above)\\n\\t\\t\\t\\t\\tint left = allDone ^ mask;\\n\\t\\t\\t\\t\\tdp[i][mask] = score[left];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][mask] = inf;\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tdp[i][mask] = min(dp[i + 1][mask | (1 << j)] + cost[i][j], dp[i][mask]); \\n                    // matching the ith person in grp a to a person in grp b\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define inf 1e6\\npublic:\\n\\tint connectTwoGroups(vector<vector<int>>& cost) {\\n\\t\\tint n = cost.size();\\n\\t\\tint m = cost[0].size();\\n\\t\\tint allDone = (1 << m) - 1;\\n\\t\\tint dp[n + 1][allDone + 2];\\n\\t\\tint score[allDone + 2];\\n\\t\\tint mi[m];\\n\\n\\t\\t// calculating the minimum incoming edge for each person in grp b\\n\\t\\t// This is handy in below loop\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tmi[i] = inf;\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t\\tmi[i] = min(mi[i], cost[j][i]);\\n\\t\\t}\\n\\n\\t\\t// precomputing the scores of each leftover people mask\\n\\t\\t// This would come handy in the base case (again below loop :\\\\)\\n\\t\\tfor (int i = 0; i <= allDone + 1; i++) {\\n\\t\\t\\tint &ans = score[i];\\n\\t\\t\\tans = 0;\\n\\t\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\t\\tif (i & (1 << j)) ans += mi[j];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// actual bottom up dp\\n\\t\\tfor (int i = n;  i >= 0; i--) {\\n\\t\\t\\tfor (int mask = 0; mask <= allDone; mask++) {\\n\\t\\t\\t\\tif (i == n) { \\n                    // all people that are left over needs to be matched with the min cost edges (we calculated this above)\\n\\t\\t\\t\\t\\tint left = allDone ^ mask;\\n\\t\\t\\t\\t\\tdp[i][mask] = score[left];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdp[i][mask] = inf;\\n\\t\\t\\t\\t\\tfor (int j = 0; j < m; j++)\\n\\t\\t\\t\\t\\t\\tdp[i][mask] = min(dp[i + 1][mask | (1 << j)] + cost[i][j], dp[i][mask]); \\n                    // matching the ith person in grp a to a person in grp b\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dp[0][0];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870494,
                "title": "c-detailed-explaination-good-dp-with-bit-masking",
                "content": "We need to try judisiously all possible combinations in one dimension (preferabily in horizontal as n >= m) then in other direction we will find and add the minimum value to fulfil the consition.\\n\\nwe will fill one value per row, in a manner so as to cover all the combinations of columns that can be covered (mask on columns). this means for every mask on column we calculate using DP the minimum value of the sum of elements in each row. than in rows left (111111...-mask) we will find the minimum values and add them to it.\\n\\nour DP will be something like coin change one :\\n\\ndp[index][mask] \\n= min (dp[index+1][mask] + minimum value in index row for all columns where mask is 1,\\n    for every column place where mask is 1 -> dp[index+1][mask ^ 1] + cost [index][i])\\n\\nnow for every mask value of this dp with index 0 add the minimum column wise value to get the answer candidate, minimum such candidate is the answer.\\n\\n\\nint dp[20][20000];\\n    int topDown (int ind, int mask, vector<vector<int>>& cost, int m, int n) {\\n        if (dp[ind][mask] != -1) return dp[ind][mask];\\n        if (ind == n-1) {\\n            int sum = 0;\\n            for (int i = 0; i < m; i++) {\\n                if ((mask & (1 << i)) != 0) {\\n                    sum += cost[ind][m-i-1];\\n                }\\n            }\\n            dp[ind][mask] = sum;\\n            return sum;\\n        }        \\n        int mini = 100000;\\n        int minis = 100000;\\n        for (int i = 0; i < m; i++) {\\n           if ((mask & (1 << i)) != 0) {\\n               mini = min(mini, cost[ind][m-i-1]);\\n               int y = mask;\\n               y = y ^ (1 << i);\\n               minis = min (minis, cost[ind][m-i-1] + topDown(ind+1,y,cost,m,n));\\n           }\\n        }\\n        int t = mini + topDown(ind+1,mask,cost,m,n);\\n        dp[ind][mask] = min(t,minis);\\n        return dp[ind][mask];\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        int mini[m+1];\\n        for (int i = 0; i < m; i++) {\\n            mini[i] = INT_MAX;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mini[i] = min(mini[i], cost[j][i]);\\n            }\\n        }\\n        int p = pow(2,m);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                if (j == 0) dp[i][j] = 100000;\\n                else\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int minis = INT_MAX;\\n        int sum = 0;\\n        for (int i = 1; i < p; i++) {\\n            sum = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((i & (1 << j)) == 0) {\\n                    sum += mini[m-j-1];\\n                }\\n            }\\n            int y = topDown(0,i,cost,m,n);\\n            minis = min(minis, sum + y);\\n        }\\n        return minis;\\n    }",
                "solutionTags": [],
                "code": "We need to try judisiously all possible combinations in one dimension (preferabily in horizontal as n >= m) then in other direction we will find and add the minimum value to fulfil the consition.\\n\\nwe will fill one value per row, in a manner so as to cover all the combinations of columns that can be covered (mask on columns). this means for every mask on column we calculate using DP the minimum value of the sum of elements in each row. than in rows left (111111...-mask) we will find the minimum values and add them to it.\\n\\nour DP will be something like coin change one :\\n\\ndp[index][mask] \\n= min (dp[index+1][mask] + minimum value in index row for all columns where mask is 1,\\n    for every column place where mask is 1 -> dp[index+1][mask ^ 1] + cost [index][i])\\n\\nnow for every mask value of this dp with index 0 add the minimum column wise value to get the answer candidate, minimum such candidate is the answer.\\n\\n\\nint dp[20][20000];\\n    int topDown (int ind, int mask, vector<vector<int>>& cost, int m, int n) {\\n        if (dp[ind][mask] != -1) return dp[ind][mask];\\n        if (ind == n-1) {\\n            int sum = 0;\\n            for (int i = 0; i < m; i++) {\\n                if ((mask & (1 << i)) != 0) {\\n                    sum += cost[ind][m-i-1];\\n                }\\n            }\\n            dp[ind][mask] = sum;\\n            return sum;\\n        }        \\n        int mini = 100000;\\n        int minis = 100000;\\n        for (int i = 0; i < m; i++) {\\n           if ((mask & (1 << i)) != 0) {\\n               mini = min(mini, cost[ind][m-i-1]);\\n               int y = mask;\\n               y = y ^ (1 << i);\\n               minis = min (minis, cost[ind][m-i-1] + topDown(ind+1,y,cost,m,n));\\n           }\\n        }\\n        int t = mini + topDown(ind+1,mask,cost,m,n);\\n        dp[ind][mask] = min(t,minis);\\n        return dp[ind][mask];\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        int n = cost.size();\\n        int m = cost[0].size();\\n        int mini[m+1];\\n        for (int i = 0; i < m; i++) {\\n            mini[i] = INT_MAX;\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mini[i] = min(mini[i], cost[j][i]);\\n            }\\n        }\\n        int p = pow(2,m);\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                if (j == 0) dp[i][j] = 100000;\\n                else\\n                dp[i][j] = -1;\\n            }\\n        }\\n        int minis = INT_MAX;\\n        int sum = 0;\\n        for (int i = 1; i < p; i++) {\\n            sum = 0;\\n            for (int j = 0; j < m; j++) {\\n                if ((i & (1 << j)) == 0) {\\n                    sum += mini[m-j-1];\\n                }\\n            }\\n            int y = topDown(0,i,cost,m,n);\\n            minis = min(minis, sum + y);\\n        }\\n        return minis;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 869024,
                "title": "c-dp-bitmasking-with-detailed-intuitive-explanation",
                "content": "First we need to understand the solution structure. \\nLet us say we have all nodes in first group connected and only a subset of nodes from the second group are connected. Then we can greedily assign each unconnected node from the second group with its minumum edge.\\n\\nLet dp[i][mask]  = minimum cost so that the first \\'i\\' nodes from the first group are connected and only 0 nodes (bit positions that are 0 in mask) from the second group are connected. \\nSince we want the first \\'i\\' in G1 to be connected , the ith node sould be connected to at least one node in G2. We can iterate over this node - let us call it j. There are two cases - \\n1) The jth node is already connected - dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i-1][mask])\\n2) The jth node is not connected - dp[i][mask] = min(dp[i][mask], cost[i][j] + dp[i-1][mask^(1<<j)] - here we set jth bit to 0 since we are connecing it to the ith node.\\n\\nThe tricky part (at least for me) here is that when we say for dp[i][mask] - the first i nodes are connected, we **do not** make the rest of the nodes from i+1...n **unavailable**. They may still be connected depending on whether some j in G2 has a minimum edge with one of them. It only means that the first i nodes are connected for sure, but the rest are still available.\\nThus the final answer is dp[n][0xfff..]\\n\\nFollowing is my code. Note that I use 0 indexing in the code.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& c) {\\n        int n = c.size(), m = c[0].size();\\n        vector<int> dp(4101,0), minc(m,INT_MAX);\\n        for (int j = 0; j < m; ++j){\\n            for (int i = 0; i < n; ++i){\\n                minc[j] = min(minc[j], c[i][j]);\\n            }\\n        }\\n        for (int mask = 0; mask < (1<<m); ++mask){\\n            for (int j = 0; j < m; ++j){\\n                if ((mask>>j)&1){\\n                    dp[mask] += minc[j];\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; ++i){\\n            vector<int> dp_nxt(4101,INT_MAX);\\n            for (int mask = 0; mask < (1<<m); ++mask){\\n                for (int j = 0; j < m; ++j){\\n                    if ((mask>>j)&1){\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask^(1<<j)]);\\n                    }\\n                    else{\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask]);\\n                    }\\n                }\\n            }\\n            dp = dp_nxt;\\n        }\\n        return dp[(1<<m)-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int connectTwoGroups(vector<vector<int>>& c) {\\n        int n = c.size(), m = c[0].size();\\n        vector<int> dp(4101,0), minc(m,INT_MAX);\\n        for (int j = 0; j < m; ++j){\\n            for (int i = 0; i < n; ++i){\\n                minc[j] = min(minc[j], c[i][j]);\\n            }\\n        }\\n        for (int mask = 0; mask < (1<<m); ++mask){\\n            for (int j = 0; j < m; ++j){\\n                if ((mask>>j)&1){\\n                    dp[mask] += minc[j];\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; ++i){\\n            vector<int> dp_nxt(4101,INT_MAX);\\n            for (int mask = 0; mask < (1<<m); ++mask){\\n                for (int j = 0; j < m; ++j){\\n                    if ((mask>>j)&1){\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask^(1<<j)]);\\n                    }\\n                    else{\\n                        dp_nxt[mask] = min(dp_nxt[mask], c[i][j] + dp[mask]);\\n                    }\\n                }\\n            }\\n            dp = dp_nxt;\\n        }\\n        return dp[(1<<m)-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863826,
                "title": "c-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    vector<int>price;\\n    int solve(int idx, int x, vector<vector<int>>& cost)\\n    {\\n        if(dp[idx][x] != -1)return dp[idx][x];\\n        int ans;\\n        if(idx == m)\\n        {\\n            ans = 0;\\n            for(int i = 0; i < n; i++)\\n                if((x & (1 << i)) == 0)\\n                    ans += price[i];\\n        }\\n        else\\n        {\\n            ans = INT_MAX;\\n            for(int i = 0; i < n; i++)\\n            {\\n                ans = min(ans, solve(idx + 1, (x | (1 << i)), cost) + cost[idx][i]);\\n            }\\n        }\\n        return dp[idx][x] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        dp.resize(m + 1, vector<int>((1 << n), -1));\\n        price.resize(n, INT_MAX);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                price[i] = min(price[i], cost[j][i]);\\n        return solve(0, 0, cost);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m, n;\\n    vector<vector<int>>dp;\\n    vector<int>price;\\n    int solve(int idx, int x, vector<vector<int>>& cost)\\n    {\\n        if(dp[idx][x] != -1)return dp[idx][x];\\n        int ans;\\n        if(idx == m)\\n        {\\n            ans = 0;\\n            for(int i = 0; i < n; i++)\\n                if((x & (1 << i)) == 0)\\n                    ans += price[i];\\n        }\\n        else\\n        {\\n            ans = INT_MAX;\\n            for(int i = 0; i < n; i++)\\n            {\\n                ans = min(ans, solve(idx + 1, (x | (1 << i)), cost) + cost[idx][i]);\\n            }\\n        }\\n        return dp[idx][x] = ans;\\n    }\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size();\\n        n = cost[0].size();\\n        dp.resize(m + 1, vector<int>((1 << n), -1));\\n        price.resize(n, INT_MAX);\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                price[i] = min(price[i], cost[j][i]);\\n        return solve(0, 0, cost);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863803,
                "title": "why-heap-based-solution-dijkstra-bitmasks-gives-tle",
                "content": "This is a basic set-cover problem. I can\\'t figure out why heap-based solution gives TLE?\\nWe treat this problem as graph problem, where we need to find the minimal path from state, where all bits set to one, to state, where all bits are set to zero.\\n\\n```\\nstruct state\\n{\\n\\tint left = 0;\\n\\tint right = 0;\\n\\tint cost = 0;\\n\\n\\tbool operator>(state s) const\\n\\t{\\n\\t\\treturn cost > s.cost;\\n\\t}\\n};\\n\\nint connectTwoGroups(vector<vector<int>>& cost) \\n{\\n\\tstate s;\\n\\n\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\ts.left |= 1 << i, s.right |= 1 << j;\\n\\n\\tpriority_queue<state, vector<state>, greater<state>> pq;\\n\\tpq.push(s);\\n\\n\\twhile (!pq.empty())\\n\\t{\\n\\t\\tauto cur = pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tif (!cur.left && !cur.right)\\n\\t\\t\\treturn cur.cost;\\n\\n\\t\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\t\\tif (cur.left & 1 << i || cur.right & 1 << j)\\n\\t\\t\\t\\t\\tpq.push({ cur.left & ~(1 << i), cur.right & ~(1 << j), cur.cost + cost[i][j] });\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct state\\n{\\n\\tint left = 0;\\n\\tint right = 0;\\n\\tint cost = 0;\\n\\n\\tbool operator>(state s) const\\n\\t{\\n\\t\\treturn cost > s.cost;\\n\\t}\\n};\\n\\nint connectTwoGroups(vector<vector<int>>& cost) \\n{\\n\\tstate s;\\n\\n\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\ts.left |= 1 << i, s.right |= 1 << j;\\n\\n\\tpriority_queue<state, vector<state>, greater<state>> pq;\\n\\tpq.push(s);\\n\\n\\twhile (!pq.empty())\\n\\t{\\n\\t\\tauto cur = pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tif (!cur.left && !cur.right)\\n\\t\\t\\treturn cur.cost;\\n\\n\\t\\tfor (int i = 0; i < cost.size(); ++i)\\n\\t\\t\\tfor (int j = 0; j < cost[i].size(); ++j)\\n\\t\\t\\t\\tif (cur.left & 1 << i || cur.right & 1 << j)\\n\\t\\t\\t\\t\\tpq.push({ cur.left & ~(1 << i), cur.right & ~(1 << j), cur.cost + cost[i][j] });\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 860909,
                "title": "java-easy-bitmask-solution-very-fast",
                "content": "```\\nclass Solution {\\n    \\n    static long maxx(int ind,List<List<Integer>> cost,int val,int flag){\\n        if(ind>=cost.size()){\\n            for(int i=0;i<cost.get(0).size();i++){\\n                int j=(1<<i) & val;\\n                if(j==0){return Integer.MAX_VALUE;}\\n            }\\n            return 0;}\\n        if(aa[ind][val][flag]!=-1){return aa[ind][val][flag];}\\n        long min=Integer.MAX_VALUE;\\n        if(flag==0){\\n        for(int j=0;j<cost.get(ind).size();j++){\\n           \\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n          \\n        }\\n        }\\n        else{\\n            for(int j=0;j<cost.get(ind).size();j++){\\n            int i=(1<<j) & val;\\n            if(i==0){\\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n            }\\n            }\\n            min=Math.min(min,maxx(ind+1,cost,val,0 ));\\n        }\\n        return aa[ind][val][flag]=min;\\n    }\\n    static long[][][] aa;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        aa=new long[cost.size()][(int)Math.pow(2,cost.get(0).size())+1][2];\\n        for(int j=0;j<aa.length;j++){\\n            for(int i=0;i<aa[0].length;i++){\\n                for(int k=0;k<2;k++){\\n                aa[j][i][k]=-1;\\n                }\\n            }\\n        }\\n        return (int)maxx(0,cost,0,0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    static long maxx(int ind,List<List<Integer>> cost,int val,int flag){\\n        if(ind>=cost.size()){\\n            for(int i=0;i<cost.get(0).size();i++){\\n                int j=(1<<i) & val;\\n                if(j==0){return Integer.MAX_VALUE;}\\n            }\\n            return 0;}\\n        if(aa[ind][val][flag]!=-1){return aa[ind][val][flag];}\\n        long min=Integer.MAX_VALUE;\\n        if(flag==0){\\n        for(int j=0;j<cost.get(ind).size();j++){\\n           \\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n          \\n        }\\n        }\\n        else{\\n            for(int j=0;j<cost.get(ind).size();j++){\\n            int i=(1<<j) & val;\\n            if(i==0){\\n                min=Math.min(min,maxx(ind,cost,(1<<j)|val,1)+cost.get(ind).get(j));\\n            }\\n            }\\n            min=Math.min(min,maxx(ind+1,cost,val,0 ));\\n        }\\n        return aa[ind][val][flag]=min;\\n    }\\n    static long[][][] aa;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        aa=new long[cost.size()][(int)Math.pow(2,cost.get(0).size())+1][2];\\n        for(int j=0;j<aa.length;j++){\\n            for(int i=0;i<aa[0].length;i++){\\n                for(int k=0;k<2;k++){\\n                aa[j][i][k]=-1;\\n                }\\n            }\\n        }\\n        return (int)maxx(0,cost,0,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860083,
                "title": "can-anyone-point-out-my-mistake-i-am-getting-different-value-than-expected-in-some-test-cases",
                "content": "Here is my code:-\\n\\n\\n```\\nclass Solution \\n{\\n    int g1size,g2size;\\n    int dp[13][4096] = {};\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        int i,j;\\n        g1size=cost.size();\\n        g2size=cost[0].size();\\n        \\n            \\n        \\n        vector<int>g2mini(g2size,INT_MAX);\\n        for(i=0;i<g2size;i++)\\n        {\\n            for(j=0;j<g1size;j++)\\n            {\\n                g2mini[i]=min(g2mini[i],cost[j][i]);\\n            }\\n        }\\n        return helper(cost,g2mini,0,0);\\n    }\\npublic: int helper(vector<vector<int>>&cost,vector<int>&g2mini,int gindex,int group2)\\n{\\n    \\n    if(dp[gindex][group2]!=NULL) return dp[gindex][group2];\\n    int i,j;\\n    int sumcost=(gindex>=g1size)?0:INT_MAX;\\n    if(gindex>=g1size)\\n    {\\n        \\n        for(i=0;i<g2size;++i)\\n        {\\n            sumcost+=g2mini[i]*((group2 && (1<<i))==0);\\n        }\\n    }\\n    else\\n    {\\n        \\n        for(i=0;i<g2size;i++)\\n        {\\n            sumcost=min(sumcost,cost[gindex][i]+helper(cost,g2mini,gindex+1,group2|(1<<i)));\\n            \\n        }\\n    }\\n    dp[gindex][group2]=sumcost;\\n    return sumcost;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    int g1size,g2size;\\n    int dp[13][4096] = {};\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) \\n    {\\n        int i,j;\\n        g1size=cost.size();\\n        g2size=cost[0].size();\\n        \\n            \\n        \\n        vector<int>g2mini(g2size,INT_MAX);\\n        for(i=0;i<g2size;i++)\\n        {\\n            for(j=0;j<g1size;j++)\\n            {\\n                g2mini[i]=min(g2mini[i],cost[j][i]);\\n            }\\n        }\\n        return helper(cost,g2mini,0,0);\\n    }\\npublic: int helper(vector<vector<int>>&cost,vector<int>&g2mini,int gindex,int group2)\\n{\\n    \\n    if(dp[gindex][group2]!=NULL) return dp[gindex][group2];\\n    int i,j;\\n    int sumcost=(gindex>=g1size)?0:INT_MAX;\\n    if(gindex>=g1size)\\n    {\\n        \\n        for(i=0;i<g2size;++i)\\n        {\\n            sumcost+=g2mini[i]*((group2 && (1<<i))==0);\\n        }\\n    }\\n    else\\n    {\\n        \\n        for(i=0;i<g2size;i++)\\n        {\\n            sumcost=min(sumcost,cost[gindex][i]+helper(cost,g2mini,gindex+1,group2|(1<<i)));\\n            \\n        }\\n    }\\n    dp[gindex][group2]=sumcost;\\n    return sumcost;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858162,
                "title": "c-dp-with-bit-masking-with-comments",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size(), n = cost[0].size();\\n        dp.resize(m + 1, vector<int>(1<<n, -1));       // dp of [index of i\\'th element set1][n bits for set2]\\n        minCol.resize(n, INT_MAX);\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++)\\n            minCol[j] = min(minCol[j], cost[i][j]);       // min for each column\\n        \\n        return solve(0, 0, cost);       // no element is yet connected\\n    }\\n    \\n\\n// considering each element of set1 one by one, and at the end(idx == m) if some of the elements of set2 are still\\n// not connected, we connect them using the min weight edge from them\\n    \\n    int solve(int idx, int mask2, vector<vector<int>>& cost) {\\n        if(dp[idx][mask2] != -1) return dp[idx][mask2];\\n        \\n        int ans = (idx == m ? 0: INT_MAX);\\n        \\n        if(idx == m) {          // set1 elements already connected, we will only check set 2 elements (columns)\\n            for(int j=0; j<n; j++) if((mask2&(1<<j)) == 0)      // not yet selected\\n                ans += minCol[j];      // choose the min edge to connect this\\n        }\\n        else {\\n            for(int j=0; j<n; j++)\\n                ans = min(ans, cost[idx][j] + solve(idx + 1, mask2|(1<<j), cost));  // connecting i\\'th with j\\'th\\n        }\\n        \\n        return dp[idx][mask2] = ans;\\n    }\\n\\nprivate:\\n    int m, n, done1, done2;\\n    vector<vector<int>> dp;            // [12] * [4096] max\\n    vector<int> minCol;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        m = cost.size(), n = cost[0].size();\\n        dp.resize(m + 1, vector<int>(1<<n, -1));       // dp of [index of i\\'th element set1][n bits for set2]\\n        minCol.resize(n, INT_MAX);\\n        \\n        for(int i=0; i<m; i++) for(int j=0; j<n; j++)\\n            minCol[j] = min(minCol[j], cost[i][j]);       // min for each column\\n        \\n        return solve(0, 0, cost);       // no element is yet connected\\n    }\\n    \\n\\n// considering each element of set1 one by one, and at the end(idx == m) if some of the elements of set2 are still\\n// not connected, we connect them using the min weight edge from them\\n    \\n    int solve(int idx, int mask2, vector<vector<int>>& cost) {\\n        if(dp[idx][mask2] != -1) return dp[idx][mask2];\\n        \\n        int ans = (idx == m ? 0: INT_MAX);\\n        \\n        if(idx == m) {          // set1 elements already connected, we will only check set 2 elements (columns)\\n            for(int j=0; j<n; j++) if((mask2&(1<<j)) == 0)      // not yet selected\\n                ans += minCol[j];      // choose the min edge to connect this\\n        }\\n        else {\\n            for(int j=0; j<n; j++)\\n                ans = min(ans, cost[idx][j] + solve(idx + 1, mask2|(1<<j), cost));  // connecting i\\'th with j\\'th\\n        }\\n        \\n        return dp[idx][mask2] = ans;\\n    }\\n\\nprivate:\\n    int m, n, done1, done2;\\n    vector<vector<int>> dp;            // [12] * [4096] max\\n    vector<int> minCol;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858092,
                "title": "python3-full-explanation-plus-how-to-use-a-bitmask",
                "content": "\\n# Explanation\\nFor those wondering, this is a greedy solution problem.\\n\\nAll connections are found by connecting one side to the other, say the left. Then connecting the remaining unconnected nodes (if any) on the right.\\n\\nHow do we know which side to connect first? The side that goes second is deterministic, like in a 2-player game. It will always attach to the minimum cost. This is why it\\'s a greedy problem. The side that goes first, we need to loop over all possible ways to connect. Each node on the 1st side can connect to any on the 2nd, so there will be 2nd^1st number of ways to do this. We should thus connect the larger side first.\\n\\nNote: to prove this, we need to determine if x > y, is x^y > y^x? for equality, x=y has to be true. So, test out the case of x=3 and y=2. we find (2^3=8) < (3^2=9), thus if x>y we should always pick x^y. Exponents are powerful\\n\\n## algorithm steps\\nFirst, we need the info for the deterministic connections. Find the min cost for each element on the right side (the right side is always smaller). \\n\\nTo loop over all ways to connect the left to the right, we use a bit mask and DP. For the inductive step, assume that all m+1 left nodes have been connected to the right. This is backwards compared to usual. The reason being, we know exactly how the right side connects if the left is fully connected. Therefore left==m is our base case.\\n\\nWe can keep track of which nodes on the right have a connection using a 1 for connected and 0 for not connected. This is represented as a bit string 101110....01 etc. This is the bitmask. To connect the mth node, we create n bitmasks, each with a 1 inserted (if there\\'s already a 1 do nothing) at the ith entry of the bitmask. This is the bitwise & operation with each bit. Each index is like a basis vector, and index i can be represented as 1<<i. Finally, the cost of the ith bitmask is equal to the cost to connect our left node to i, plus the cost of connecting all the right nodes given that bitmask.\\n\\n## bitmasks and lru_cache fun\\nFinal note. The bitmasks work like this: 1<<n yields a unit vector. 3D example - 1<<0 = 001. 1<<1 = 010. and 1<<2 = 100. << moves the leading bit (1) leftwards by (...) digits. The & operator checks if the bitmask has a 1 where the unit vector has a 1. If not, it gives 0, meaning no connection. The | operator says if either the bitmask or our new unit vector has a 1, then the final result has a 1 in that location. Hence it adds a connection.\\n\\nFinal final note: The lru_cache() decorator is seriously amazing. It basically implements top-down DP automatically. Just put in a recursive function and it will keep track of duplicates in the cache, then readily supply the answer. For fun, try typing in lru_cache.cache_info() after you run the code. It tells you how often the lru_cache found a previous answer, and you can get an idea how efficient it is!\\n\\n## Code\\n\\n```\\ndef min_cost(cost):\\n\\t#The zip function just makes every column into an array. Numpy equivalent is cost[:,i].\\n\\tm, n = len(cost), len(cost[0])\\n\\tright_cost = [min(x) for x in zip(*cost)]\\n\\n\\t# The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n\\t@lru_cache(maxsize=None)\\n\\tdef aux(num_left_connected, num_right_connected):\\n\\t\\ti, bitmask = num_left_connected, num_right_connected\\n\\t\\tif i == m:\\n\\t\\t\\treturn sum(right_cost[x] for x in range(n) if bitmask & 1<<x == 0)\\n\\t\\treturn min(cost[i][j] + aux(i+1, bitmask | 1<<j) for j in range(n))\\n\\n\\t# return the cost for 0 initial left connections and 0 intial right connections\\n\\treturn aux(0,0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef min_cost(cost):\\n\\t#The zip function just makes every column into an array. Numpy equivalent is cost[:,i].\\n\\tm, n = len(cost), len(cost[0])\\n\\tright_cost = [min(x) for x in zip(*cost)]\\n\\n\\t# The recursive call tells us what the additional cost is, provided we already connected num_left_connected on the left and num_right_connected on the right.\\n\\t@lru_cache(maxsize=None)\\n\\tdef aux(num_left_connected, num_right_connected):\\n\\t\\ti, bitmask = num_left_connected, num_right_connected\\n\\t\\tif i == m:\\n\\t\\t\\treturn sum(right_cost[x] for x in range(n) if bitmask & 1<<x == 0)\\n\\t\\treturn min(cost[i][j] + aux(i+1, bitmask | 1<<j) for j in range(n))\\n\\n\\t# return the cost for 0 initial left connections and 0 intial right connections\\n\\treturn aux(0,0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 857422,
                "title": "c-top-down-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    vector<vector<int> > c;\\n    vector<int> mi;\\n    vector<vector<int> > dp;\\n    \\n    int util(int i, int mask){\\n        if(i>=n){\\n            int res=0;\\n            for(int j=0; j<m; j++)\\n                if(!(mask&(1<<j))) res+=mi[j];\\n            return res;\\n        }\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=2000000000;\\n        for(int j=0; j<m; j++) ans=min(ans, c[i][j]+util(i+1, mask|(1<<j)));\\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        c=cost, n=c.size(), m=c[0].size();\\n        dp=vector<vector<int> >(n, vector<int>(1<<m, -1));\\n        mi=vector<int>(m);\\n        for(int j=0; j<m; j++){\\n            mi[j]=c[0][j];\\n            for(int i=1; i<n; i++) mi[j]=min(mi[j], c[i][j]);\\n        }\\n        return util(0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n, m;\\n    vector<vector<int> > c;\\n    vector<int> mi;\\n    vector<vector<int> > dp;\\n    \\n    int util(int i, int mask){\\n        if(i>=n){\\n            int res=0;\\n            for(int j=0; j<m; j++)\\n                if(!(mask&(1<<j))) res+=mi[j];\\n            return res;\\n        }\\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=2000000000;\\n        for(int j=0; j<m; j++) ans=min(ans, c[i][j]+util(i+1, mask|(1<<j)));\\n        return dp[i][mask]=ans;\\n    }\\n    \\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        c=cost, n=c.size(), m=c[0].size();\\n        dp=vector<vector<int> >(n, vector<int>(1<<m, -1));\\n        mi=vector<int>(m);\\n        for(int j=0; j<m; j++){\\n            mi[j]=c[0][j];\\n            for(int i=1; i<n; i++) mi[j]=min(mi[j], c[i][j]);\\n        }\\n        return util(0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857053,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\n    const int INF = 1234567890;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int m = cost.size(), n = cost[0].size();\\n        vector<int> best(n, INF);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                best[i] = min(best[i], cost[j][i]);\\n            }\\n        }\\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n        for (const auto& c : cost) {\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                const int temp = dp[i];\\n                dp[i] = INF;\\n                if (temp >= INF) {\\n                    continue;\\n                }\\n                for (int j = 0; j < n; ++j) {\\n                    const int s = i | (1 << j);\\n                    dp[s] = min(dp[s], temp + c[j]);\\n                }\\n                \\n            }\\n        }\\n        int r = INF;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            if (dp[i] == INF) {\\n                continue;\\n            }\\n            int c = dp[i];\\n            for (int j = 0; c < r && j < n; ++j) {\\n                if ((i & (1 << j)) == 0) {\\n                    c += best[j];\\n                }\\n               \\n            }\\n            r = min(r, c);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    const int INF = 1234567890;\\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        const int m = cost.size(), n = cost[0].size();\\n        vector<int> best(n, INF);\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                best[i] = min(best[i], cost[j][i]);\\n            }\\n        }\\n        vector<int> dp(1 << n, INF);\\n        dp[0] = 0;\\n        for (const auto& c : cost) {\\n            for (int i = dp.size() - 1; i >= 0; --i) {\\n                const int temp = dp[i];\\n                dp[i] = INF;\\n                if (temp >= INF) {\\n                    continue;\\n                }\\n                for (int j = 0; j < n; ++j) {\\n                    const int s = i | (1 << j);\\n                    dp[s] = min(dp[s], temp + c[j]);\\n                }\\n                \\n            }\\n        }\\n        int r = INF;\\n        for (int i = 0; i < dp.size(); ++i) {\\n            if (dp[i] == INF) {\\n                continue;\\n            }\\n            int c = dp[i];\\n            for (int j = 0; c < r && j < n; ++j) {\\n                if ((i & (1 << j)) == 0) {\\n                    c += best[j];\\n                }\\n               \\n            }\\n            r = min(r, c);\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856771,
                "title": "dfs-solution-java-100ms-python-not-very-simple",
                "content": "```\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        \"\"\"\\n        :type cost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.cost = cost if len(cost) >= len(cost[0]) else [[cost[j][i] for j in range(len(cost))] for i in range(len(cost[0]))]\\n        self.select = [[False for j in range(len(self.cost[0]))] for i in range(len(self.cost))]\\n        # fast pruning\\n        self.select_cost = float(\\'inf\\')\\n        self.select_cols = [False for i in range(len(self.cost[0]))]\\n        self.partition(0, 0)\\n        for i in range(len(self.cost[0]), len(self.cost)):\\n            self.select_cost += min(self.cost[i])\\n        # dfs\\n        self.align_row = [min(self.cost[i]) for i in range(len(self.cost))]\\n        for i in range(len(self.cost) - 2, -1, -1):\\n            self.align_row[i] += self.align_row[i + 1]\\n        self.cols_rowfull = [False for i in range(len(self.cost[0]))]\\n        self.cols_counts = [0 for i in range(len(self.cost[0]))]\\n        self.backtracking(0, 0)\\n        return self.select_cost\\n    def backtracking(self, row, cost):\\n        if row == len(self.cost):\\n            # check columns\\n            for j in range(len(self.cost[0])):\\n                count = 0\\n                for i in range(len(self.cost)):\\n                    if self.select[i][j]:\\n                        count += 1\\n                if count == 0:\\n                    return\\n            self.select_cost = cost\\n            return\\n        self.choice(row, 0, 0, cost)\\n    # choices\\n    def choice(self, row, j, before, cost):\\n        if row < len(self.cost) - 1 and cost + self.align_row[row + 1] >= self.select_cost:\\n            return\\n        if cost >= self.select_cost:\\n            return\\n        if j == len(self.cost[0]):\\n            if before == 1:\\n                self.backtracking(row + 1, cost)\\n            elif before > 1:\\n                temp = self.cols_rowfull[:]\\n                for k in range(len(self.cost[0])):\\n                    if self.select[row][k]:\\n                        self.cols_rowfull[k] = True\\n                self.backtracking(row + 1, cost)\\n                self.cols_rowfull = temp\\n            return\\n        self.choice(row, j + 1, before, cost)\\n        if not self.cols_rowfull[j]:\\n            self.select[row][j] = True\\n            # check cols_counts\\n            if self.cols_counts[j] == 0 or before == 0:\\n                self.cols_counts[j] += 1\\n                self.choice(row, j + 1, before + 1, cost + self.cost[row][j])\\n                self.cols_counts[j] -= 1\\n            self.select[row][j] = False\\n    def partition(self, row, cost):\\n        if cost >= self.select_cost:\\n            return\\n        if row == len(self.cost[0]):\\n            self.select_cost = cost\\n            return\\n        for j in range(len(self.cost[0])):\\n            if not self.select_cols[j]:\\n                self.select[row][j] = True\\n                self.select_cols[j] = True\\n                self.partition(row + 1, cost + self.cost[row][j])\\n                self.select_cols[j] = False\\n                self.select[row][j] = False\\n```\\n\\t\\t\\t\\t\\nThe problem can be translated into:\\nFind a selection set of elements that:\\n(i) each row must have at least one selected\\n(ii) each column must have at least one selected\\n(iii) if a row has more than two selected, then in each coloumn of the selected element, there are no more selection.\\n(iv) if a column has more than two selected, then in each row of the selected element, there are no more selection.\\n\\nNote that (iii) and (iv) are used for improving pruning.\\nThe dfs solution dives per row, and the choices are the coloumns.\\nTherefore we need global variables \"cols_rowfull\" and \"cols_counts\" to detect whether a specific row or column contains more than one elements selected already.\\n\\nTo improve pruning even better, the initial value of \"select_cost\" is important to be efficiently small enough.\\nThe function partition() uses dfs to find the minimal \"select_cost\" that satisfies the following:\\nFirst transpose the marix if necessary, to make the length <= the height. Then find a selection set in [length * length] that:\\n(i) each row has exactly one selected\\n(ii) each column has exactly one selected\\nThen add \"selected_cost\" with the minimum value of each row left.\\nThe value of \"selected_cost\" thus is minimized the most.\\n\\nIn the main backtracking function, the ending condition is that: check if the current cost **plus the sum of minimum value of each row left** is no less than select_cost.\\n\\nHere is the Java translation: (It is dumb)\\n```\\nclass Solution {\\n    int[][] cost;\\n    boolean[][] select;\\n    int select_cost;\\n    boolean[] select_cols;\\n    int[] align_row;\\n    boolean[] cols_rowfull;\\n    int[] cols_counts;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        if (cost.size() >= cost.get(0).size()) {\\n            this.cost = new int[cost.size()][cost.get(0).size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[i][j] = cost.get(i).get(j);\\n        }\\n        else {\\n            this.cost = new int[cost.get(0).size()][cost.size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[j][i] = cost.get(i).get(j);\\n        }\\n        this.select = new boolean[this.cost.length][this.cost[0].length];\\n        this.select_cost = Integer.MAX_VALUE;\\n        // fast pruning\\n        this.select_cols = new boolean[this.cost[0].length];\\n        partition(0, 0);\\n        this.align_row = new int[this.cost.length];\\n        for (int i = 0; i < this.cost.length; i++) {\\n            int min = this.cost[i][0];\\n            for (int next : this.cost[i])\\n                if (next < min) min = next;\\n            this.align_row[i] = min;\\n        }\\n        for (int i = this.cost[0].length; i < this.cost.length; i++)\\n            this.select_cost += this.align_row[i];\\n        for (int i = this.cost.length - 2; i >= 0; i--)\\n            this.align_row[i] += this.align_row[i + 1];\\n        // dfs\\n        this.cols_rowfull = new boolean[this.cost[0].length];\\n        this.cols_counts = new int[this.cost[0].length];\\n        backtracking(0, 0);\\n        return this.select_cost;\\n    }\\n    private void backtracking(int row, int cost) {\\n        if (row == this.cost.length) {\\n            // check columns\\n            for (int j = 0; j < this.cost[0].length; j++) {\\n                int count = 0;\\n                for (int i = 0; i < this.cost.length; i++)\\n                    if (this.select[i][j]) count++;\\n                if (count == 0) return;\\n            }\\n            this.select_cost = cost;\\n            return;\\n        }\\n        choice(row, 0, 0, cost);\\n    }\\n    private void choice(int row, int j, int before, int cost) {\\n        if (row < this.cost.length - 1 && cost + this.align_row[row + 1] >= this.select_cost) return;\\n        if (cost >= this.select_cost) return;\\n        if (j == this.cost[0].length) {\\n            if (before == 1) backtracking(row + 1, cost);\\n            else if (before > 1) {\\n                boolean[] temp = this.cols_rowfull.clone();\\n                for (int k = 0; k < this.cost[0].length; k++)\\n                    if (this.select[row][k]) this.cols_rowfull[k] = true;\\n                backtracking(row + 1, cost);\\n                this.cols_rowfull = temp;\\n            }\\n            return;\\n        }\\n        choice(row, j + 1, before, cost);\\n        if (!this.cols_rowfull[j]) {\\n            this.select[row][j] = true;\\n            if (this.cols_counts[j] == 0 || before == 0) {\\n                this.cols_counts[j] += 1;\\n                choice(row, j + 1, before + 1, cost + this.cost[row][j]);\\n                this.cols_counts[j] -= 1;\\n            }\\n            this.select[row][j] = false;\\n        }\\n    }\\n    \\n    private void partition(int row, int cost) {\\n        if (cost >= this.select_cost) return;\\n        if (row == this.cost[0].length) {\\n            this.select_cost = cost;\\n            return;\\n        }\\n        for (int j = 0; j < this.cost[0].length; j++)\\n            if (!this.select_cols[j]) {\\n                this.select[row][j] = true;\\n                this.select_cols[j] = true;\\n                partition(row + 1, cost + this.cost[row][j]);\\n                this.select_cols[j] = false;\\n                this.select[row][j] = false;\\n            }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connectTwoGroups(self, cost):\\n        \"\"\"\\n        :type cost: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        self.cost = cost if len(cost) >= len(cost[0]) else [[cost[j][i] for j in range(len(cost))] for i in range(len(cost[0]))]\\n        self.select = [[False for j in range(len(self.cost[0]))] for i in range(len(self.cost))]\\n        # fast pruning\\n        self.select_cost = float(\\'inf\\')\\n        self.select_cols = [False for i in range(len(self.cost[0]))]\\n        self.partition(0, 0)\\n        for i in range(len(self.cost[0]), len(self.cost)):\\n            self.select_cost += min(self.cost[i])\\n        # dfs\\n        self.align_row = [min(self.cost[i]) for i in range(len(self.cost))]\\n        for i in range(len(self.cost) - 2, -1, -1):\\n            self.align_row[i] += self.align_row[i + 1]\\n        self.cols_rowfull = [False for i in range(len(self.cost[0]))]\\n        self.cols_counts = [0 for i in range(len(self.cost[0]))]\\n        self.backtracking(0, 0)\\n        return self.select_cost\\n    def backtracking(self, row, cost):\\n        if row == len(self.cost):\\n            # check columns\\n            for j in range(len(self.cost[0])):\\n                count = 0\\n                for i in range(len(self.cost)):\\n                    if self.select[i][j]:\\n                        count += 1\\n                if count == 0:\\n                    return\\n            self.select_cost = cost\\n            return\\n        self.choice(row, 0, 0, cost)\\n    # choices\\n    def choice(self, row, j, before, cost):\\n        if row < len(self.cost) - 1 and cost + self.align_row[row + 1] >= self.select_cost:\\n            return\\n        if cost >= self.select_cost:\\n            return\\n        if j == len(self.cost[0]):\\n            if before == 1:\\n                self.backtracking(row + 1, cost)\\n            elif before > 1:\\n                temp = self.cols_rowfull[:]\\n                for k in range(len(self.cost[0])):\\n                    if self.select[row][k]:\\n                        self.cols_rowfull[k] = True\\n                self.backtracking(row + 1, cost)\\n                self.cols_rowfull = temp\\n            return\\n        self.choice(row, j + 1, before, cost)\\n        if not self.cols_rowfull[j]:\\n            self.select[row][j] = True\\n            # check cols_counts\\n            if self.cols_counts[j] == 0 or before == 0:\\n                self.cols_counts[j] += 1\\n                self.choice(row, j + 1, before + 1, cost + self.cost[row][j])\\n                self.cols_counts[j] -= 1\\n            self.select[row][j] = False\\n    def partition(self, row, cost):\\n        if cost >= self.select_cost:\\n            return\\n        if row == len(self.cost[0]):\\n            self.select_cost = cost\\n            return\\n        for j in range(len(self.cost[0])):\\n            if not self.select_cols[j]:\\n                self.select[row][j] = True\\n                self.select_cols[j] = True\\n                self.partition(row + 1, cost + self.cost[row][j])\\n                self.select_cols[j] = False\\n                self.select[row][j] = False\\n```\n```\\nclass Solution {\\n    int[][] cost;\\n    boolean[][] select;\\n    int select_cost;\\n    boolean[] select_cols;\\n    int[] align_row;\\n    boolean[] cols_rowfull;\\n    int[] cols_counts;\\n    public int connectTwoGroups(List<List<Integer>> cost) {\\n        if (cost.size() >= cost.get(0).size()) {\\n            this.cost = new int[cost.size()][cost.get(0).size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[i][j] = cost.get(i).get(j);\\n        }\\n        else {\\n            this.cost = new int[cost.get(0).size()][cost.size()];\\n            for (int i = 0; i < cost.size(); i++)\\n                for (int j = 0; j < cost.get(0).size(); j++)\\n                    this.cost[j][i] = cost.get(i).get(j);\\n        }\\n        this.select = new boolean[this.cost.length][this.cost[0].length];\\n        this.select_cost = Integer.MAX_VALUE;\\n        // fast pruning\\n        this.select_cols = new boolean[this.cost[0].length];\\n        partition(0, 0);\\n        this.align_row = new int[this.cost.length];\\n        for (int i = 0; i < this.cost.length; i++) {\\n            int min = this.cost[i][0];\\n            for (int next : this.cost[i])\\n                if (next < min) min = next;\\n            this.align_row[i] = min;\\n        }\\n        for (int i = this.cost[0].length; i < this.cost.length; i++)\\n            this.select_cost += this.align_row[i];\\n        for (int i = this.cost.length - 2; i >= 0; i--)\\n            this.align_row[i] += this.align_row[i + 1];\\n        // dfs\\n        this.cols_rowfull = new boolean[this.cost[0].length];\\n        this.cols_counts = new int[this.cost[0].length];\\n        backtracking(0, 0);\\n        return this.select_cost;\\n    }\\n    private void backtracking(int row, int cost) {\\n        if (row == this.cost.length) {\\n            // check columns\\n            for (int j = 0; j < this.cost[0].length; j++) {\\n                int count = 0;\\n                for (int i = 0; i < this.cost.length; i++)\\n                    if (this.select[i][j]) count++;\\n                if (count == 0) return;\\n            }\\n            this.select_cost = cost;\\n            return;\\n        }\\n        choice(row, 0, 0, cost);\\n    }\\n    private void choice(int row, int j, int before, int cost) {\\n        if (row < this.cost.length - 1 && cost + this.align_row[row + 1] >= this.select_cost) return;\\n        if (cost >= this.select_cost) return;\\n        if (j == this.cost[0].length) {\\n            if (before == 1) backtracking(row + 1, cost);\\n            else if (before > 1) {\\n                boolean[] temp = this.cols_rowfull.clone();\\n                for (int k = 0; k < this.cost[0].length; k++)\\n                    if (this.select[row][k]) this.cols_rowfull[k] = true;\\n                backtracking(row + 1, cost);\\n                this.cols_rowfull = temp;\\n            }\\n            return;\\n        }\\n        choice(row, j + 1, before, cost);\\n        if (!this.cols_rowfull[j]) {\\n            this.select[row][j] = true;\\n            if (this.cols_counts[j] == 0 || before == 0) {\\n                this.cols_counts[j] += 1;\\n                choice(row, j + 1, before + 1, cost + this.cost[row][j]);\\n                this.cols_counts[j] -= 1;\\n            }\\n            this.select[row][j] = false;\\n        }\\n    }\\n    \\n    private void partition(int row, int cost) {\\n        if (cost >= this.select_cost) return;\\n        if (row == this.cost[0].length) {\\n            this.select_cost = cost;\\n            return;\\n        }\\n        for (int j = 0; j < this.cost[0].length; j++)\\n            if (!this.select_cols[j]) {\\n                this.select[row][j] = true;\\n                this.select_cols[j] = true;\\n                partition(row + 1, cost + this.cost[row][j]);\\n                this.select_cols[j] = false;\\n                this.select[row][j] = false;\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856189,
                "title": "c-top-down-dynamic-programing-solution-with-brief-explanation",
                "content": "```\\nclass Solution {\\n    \\n    #define LM 4100\\n    int hi, wi;\\n    vector<vector<int>> cost;\\n    int dp[12][LM];\\n    \\n    int sol(int idx, int wimsk) {\\n        if(idx == hi && wimsk == ((1<<wi)-1)) {\\n            return 0;\\n        }\\n        \\n        if(idx >= hi) {\\n            // all the member of the first group is used but \\n            // there are unmatched group member at the second group\\n            return 1e9+7;\\n        }\\n        \\n        int &res = dp[idx][wimsk];\\n        \\n        if(~res)\\n            return res;\\n        \\n        res = 1e9+7;\\n        \\n        for(int j = 0;j < wi; ++j) {\\n            // try to connect more than one member from the \\n            // second group with the idx th member of the first group  \\n            res = min(res,sol(idx,wimsk|(1<<j))+cost[idx][j]);\\n            \\n            // try to use the remaining member from the first group\\n            res = min(res,sol(idx+1,wimsk|(1<<j))+cost[idx][j]);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        hi = cost.size(), wi = cost[0].size();\\n        this->cost = cost;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    #define LM 4100\\n    int hi, wi;\\n    vector<vector<int>> cost;\\n    int dp[12][LM];\\n    \\n    int sol(int idx, int wimsk) {\\n        if(idx == hi && wimsk == ((1<<wi)-1)) {\\n            return 0;\\n        }\\n        \\n        if(idx >= hi) {\\n            // all the member of the first group is used but \\n            // there are unmatched group member at the second group\\n            return 1e9+7;\\n        }\\n        \\n        int &res = dp[idx][wimsk];\\n        \\n        if(~res)\\n            return res;\\n        \\n        res = 1e9+7;\\n        \\n        for(int j = 0;j < wi; ++j) {\\n            // try to connect more than one member from the \\n            // second group with the idx th member of the first group  \\n            res = min(res,sol(idx,wimsk|(1<<j))+cost[idx][j]);\\n            \\n            // try to use the remaining member from the first group\\n            res = min(res,sol(idx+1,wimsk|(1<<j))+cost[idx][j]);\\n        }\\n        \\n        return res;\\n    }\\n    \\npublic:\\n    int connectTwoGroups(vector<vector<int>>& cost) {\\n        hi = cost.size(), wi = cost[0].size();\\n        this->cost = cost;\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574518,
                "content": [
                    {
                        "username": "MrsBectors",
                        "content": "In real interview will they give the constraints that everyone is exploiting to get the solution accepted?"
                    },
                    {
                        "username": "Chilliou",
                        "content": "Hey,\\nI think there is an error or I do not understand very well.\\nYou must have the shortest path among [[93,56,92],[53,44,18],[86,44,69],[54,60,30]].\\nSo logically the answer would be\\n1--B\\n2--C\\n3--B\\n4--C\\nSo output 56+18+44+30 = 148\\nHowever the expected output is 172.\\nI would like a clarification ?"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "in your answer A is not connected to can of first group point"
                    }
                ]
            },
            {
                "id": 1895316,
                "content": [
                    {
                        "username": "MrsBectors",
                        "content": "In real interview will they give the constraints that everyone is exploiting to get the solution accepted?"
                    },
                    {
                        "username": "Chilliou",
                        "content": "Hey,\\nI think there is an error or I do not understand very well.\\nYou must have the shortest path among [[93,56,92],[53,44,18],[86,44,69],[54,60,30]].\\nSo logically the answer would be\\n1--B\\n2--C\\n3--B\\n4--C\\nSo output 56+18+44+30 = 148\\nHowever the expected output is 172.\\nI would like a clarification ?"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "in your answer A is not connected to can of first group point"
                    }
                ]
            }
        ]
    }
]