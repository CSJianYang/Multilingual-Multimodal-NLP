[
    {
        "title": "Longest Valid Parentheses",
        "question_content": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.\n&nbsp;\nExample 1:\n\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\n\nExample 2:\n\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\n\nExample 3:\n\nInput: s = \"\"\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\t0 <= s.length <= 3 * 104\n\ts[i] is '(', or ')'.",
        "solutions": [
            {
                "id": 14126,
                "title": "my-o-n-solution-using-a-stack",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int n = s.length(), longest = 0;\\n            stack<int> st;\\n            for (int i = 0; i < n; i++) {\\n                if (s[i] == '(') st.push(i);\\n                else {\\n                    if (!st.empty()) {\\n                        if (s[st.top()] == '(') st.pop();\\n                        else st.push(i);\\n                    }\\n                    else st.push(i);\\n                }\\n            }\\n            if (st.empty()) longest = n;\\n            else {\\n                int a = n, b = 0;\\n                while (!st.empty()) {\\n                    b = st.top(); st.pop();\\n                    longest = max(longest, a-b-1);\\n                    a = b;\\n                }\\n                longest = max(longest, a);\\n            }\\n            return longest;\\n        }\\n    };\\n\\nThe workflow of the solution is as below.\\n\\n 1. Scan the string from beginning to end.  \\n 2. If current character is '(',\\n    push its index to the stack. If current character is ')' and the\\n    character at the index of the top of stack is '(', we just find a\\n    matching pair so pop from the stack. Otherwise, we push the index of\\n    ')' to the stack.\\n 3. After the scan is done, the stack will only\\n    contain the indices of characters which cannot be matched. Then\\n    let's use the opposite side -  substring between adjacent indices\\n    should be valid parentheses. \\n 4. If the stack is empty, the whole input\\n    string is valid. Otherwise, we can scan the stack to get longest\\n    valid substring as described in step 3.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int n = s.length(), longest = 0;\\n            stack<int> st;\\n            for (int i = 0; i < n; i++) {\\n                if (s[i] == '(') st.push(i);\\n                else {\\n                    if (!st.empty()) {\\n                        if (s[st.top()] == '(') st.pop();\\n                        else st.push(i);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 14133,
                "title": "my-dp-o-n-solution-without-using-stack",
                "content": "My solution uses DP. The main idea is as follows: I construct a array <b>longest[]</b>, for any longest[i], it stores the longest length of valid parentheses which is end at i.\\n<br>And the DP idea is :\\n<br> If s[i] is '(', set longest[i] to 0,because any string end with '(' cannot be a valid one.\\n<br>Else if s[i] is ')'\\n<br>\\xa0\\xa0\\xa0\\xa0 If s[i-1] is '(', longest[i] = longest[i-2] + 2\\n<br>\\xa0\\xa0\\xa0\\xa0 Else if s[i-1] is ')' **and s[i-longest[i-1]-1] == '('**, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]\\n<br> For example, input \"()(())\", at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6.\\n<br>\\n \\n\\n       int longestValidParentheses(string s) {\\n                if(s.length() <= 1) return 0;\\n                int curMax = 0;\\n                vector<int> longest(s.size(),0);\\n                for(int i=1; i < s.length(); i++){\\n                    if(s[i] == ')'){\\n                        if(s[i-1] == '('){\\n                            longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2;\\n                            curMax = max(longest[i],curMax);\\n                        }\\n                        else{ // if s[i-1] == ')', combine the previous length.\\n                            if(i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                                longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                                curMax = max(longest[i],curMax);\\n                            }\\n                        }\\n                    }\\n                    //else if s[i] == '(', skip it, because longest[i] must be 0\\n                }\\n                return curMax;\\n            }\\n\\nUpdated: thanks to **Philip0116**, I have a more concise solution(though this is not as readable as the above one, but concise):\\n\\n    int longestValidParentheses(string s) {\\n            if(s.length() <= 1) return 0;\\n            int curMax = 0;\\n            vector<int> longest(s.size(),0);\\n            for(int i=1; i < s.length(); i++){\\n                if(s[i] == ')' && i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                        longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                        curMax = max(longest[i],curMax);\\n                }\\n            }\\n            return curMax;\\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "My solution uses DP. The main idea is as follows: I construct a array <b>longest[]</b>, for any longest[i], it stores the longest length of valid parentheses which is end at i.\\n<br>And the DP idea is :\\n<br> If s[i] is '(', set longest[i] to 0,because any string end with '(' cannot be a valid one.\\n<br>Else if s[i] is ')'\\n<br>\\xa0\\xa0\\xa0\\xa0 If s[i-1] is '(', longest[i] = longest[i-2] + 2\\n<br>\\xa0\\xa0\\xa0\\xa0 Else if s[i-1] is ')' **and s[i-longest[i-1]-1] == '('**, longest[i] = longest[i-1] + 2 + longest[i-longest[i-1]-2]\\n<br> For example, input \"()(())\", at i = 5, longest array is [0,2,0,0,2,0], longest[5] = longest[4] + 2 + longest[1] = 6.\\n<br>\\n \\n\\n       int longestValidParentheses(string s) {\\n                if(s.length() <= 1) return 0;\\n                int curMax = 0;\\n                vector<int> longest(s.size(),0);\\n                for(int i=1; i < s.length(); i++){\\n                    if(s[i] == ')'){\\n                        if(s[i-1] == '('){\\n                            longest[i] = (i-2) >= 0 ? (longest[i-2] + 2) : 2;\\n                            curMax = max(longest[i],curMax);\\n                        }\\n                        else{ // if s[i-1] == ')', combine the previous length.\\n                            if(i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                                longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                                curMax = max(longest[i],curMax);\\n                            }\\n                        }\\n                    }\\n                    //else if s[i] == '(', skip it, because longest[i] must be 0\\n                }\\n                return curMax;\\n            }\\n\\nUpdated: thanks to **Philip0116**, I have a more concise solution(though this is not as readable as the above one, but concise):\\n\\n    int longestValidParentheses(string s) {\\n            if(s.length() <= 1) return 0;\\n            int curMax = 0;\\n            vector<int> longest(s.size(),0);\\n            for(int i=1; i < s.length(); i++){\\n                if(s[i] == ')' && i-longest[i-1]-1 >= 0 && s[i-longest[i-1]-1] == '('){\\n                        longest[i] = longest[i-1] + 2 + ((i-longest[i-1]-2 >= 0)?longest[i-longest[i-1]-2]:0);\\n                        curMax = max(longest[i],curMax);\\n                }\\n            }\\n            return curMax;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14147,
                "title": "my-simple-8ms-c-code",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> stk;\\n            stk.push(-1);\\n            int maxL=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                int t=stk.top();\\n                if(t!=-1&&s[i]==')'&&s[t]=='(')\\n                {\\n                    stk.pop();\\n                    maxL=max(maxL,i-stk.top());\\n                }\\n                else\\n                    stk.push(i);\\n            }\\n            return maxL;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> stk;\\n            stk.push(-1);\\n            int maxL=0;\\n            for(int i=0;i<s.size();i++)\\n            {\\n                int t=stk.top();\\n                if(t!=-1&&s[i]==')'&&s[t]=='(')\\n                {\\n                    stk.pop();\\n                    maxL=max(maxL,i-stk.top());\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14167,
                "title": "simple-java-solution-o-n-time-one-stack",
                "content": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int max=0;\\n        int left = -1;\\n        for(int j=0;j<s.length();j++){\\n            if(s.charAt(j)=='(') stack.push(j);            \\n            else {\\n                if (stack.isEmpty()) left=j;\\n                else{\\n                    stack.pop();\\n                    if(stack.isEmpty()) max=Math.max(max,j-left);\\n                    else max=Math.max(max,j-stack.peek());\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        int max=0;\\n        int left = -1;\\n        for(int j=0;j<s.length();j++){\\n            if(s.charAt(j)=='(') stack.push(j);            \\n            else {\\n                if (stack.isEmpty()) left=j;\\n                else{\\n                    stack.pop();\\n                    if(stack.isEmpty()) max=Math.max(max,j-left);\\n                    else max=Math.max(max,j-stack.peek());\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139990,
                "title": "longest-valid-parentheses-short-easy-w-explanation-using-stack",
                "content": "***Solution (Simulating with stack) :***\\n\\nWe can use a stack to find the longest valid parentheses. \\n\\nWe will start by pushing `-1` into the stack at first. This will denote index preceding to **potential start of valid parentheses**. It will be more clear later. Now will start iterating over `s` and we will have two cases -\\n1. **`s[i] == \\'(\\'`** - In this case, we will push the index into the stack (just as we do in valid parentheses check).\\n2. **`s[i] == \\')\\'`** - In this case, we will pop the index from the stack (again just as in parentheses check). Now, after popping, we need to do some simple checks which are main steps of this problem. Again, there will be following scenarios that may occur -\\n    * **stack is not empty** - If stack is not empty, then this **may be our longest valid parentheses**. We update the `MAX_len` as `max(MAX_len, current index - stack.top())`. Do notice, that our bottom of stack will always hold index preceding to a potential valid parentheses.\\n\\t* **stack becomes empty** - This will only happen when we have an extra \\')\\' bracket. There may have been valid parentheses previously which have been updated and stored in `MAX_len`. But, since we now have an extra closing bracket any further extensions of previous valid parentheses is not possible. So, push the current index into stack, again which will denote that bottom of stack will hold the index preceding to a **potential** valid parentheses.\\n\\n```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\\n\\nThe small simulation above might have given you the idea of how this process works. Watch the LC solution showing a gif which will give you better idea. Below is them implementation of the same -\\n\\n\\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, for iterating over the string s.\\n***Space Complexity :*** **`O(N)`**, for maintaining the stack.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14278,
                "title": "two-java-solutions-with-explanation-stack-dp-short-easy-to-understand",
                "content": "// **Stack solution  10ms**  \\nThe idea is simple, we only update the result (max) when we find a \"pair\".  \\nIf we find a pair. We throw this pair away and see how big the gap is between current and previous invalid.  \\nEX: \"( )( )\"  \\nstack: -1, 0,  \\nwhen we get to index 1 \")\", the peek is \"(\" so we pop it out and see what's before \"(\".  \\nIn this example it's -1. So the gap is \"current_index\" - (-1) = 2.  \\n\\nThe idea **only update the result (max) when we find a \"pair\"** and **push -1 to stack first** covered all edge cases.  \\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            LinkedList<Integer> stack = new LinkedList<>();\\n            int result = 0;\\n            stack.push(-1);\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == ')' && stack.size() > 1 && s.charAt(stack.peek()) == '(') {\\n                    stack.pop();\\n                    result = Math.max(result, i - stack.peek());\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n            return result;\\n        }\\n    }\\n\\n\\n\\n**//DP solution  4ms**  \\nThe idea is go through the string and use DP to store the longest valid parentheses at that point.  \\ntake example \"()(())\"  \\ni :    [0,1,2,3,4,5]  \\ns :   [( ,) ,( ,( ,) ,) ]  \\nDP:[0,2,0,0,2,6]  \\n\\n1, We count all the \\u2018(\\u2018.  \\n2, If we find a \\u2018)\\u2019 and \\u2018(\\u2018 counter is not 0, we have at least a valid result size of 2. \\u201c()\"  \\n3, Check the the one before (i - 1). If DP[i - 1] is not 0 means we have something like this \\u201c(())\\u201d . This will have DP \\u201c0024\"  \\n4, We might have something before \"(())\\u201d. Take \"()(())\\u201d example, Check the i = 1 because this might be a consecutive valid string.  \\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            int[] dp = new int[s.length()];\\n            int result = 0;\\n            int leftCount = 0;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == '(') {\\n                    leftCount++;\\n                } else if (leftCount > 0){\\n                    dp[i] = dp[i - 1] + 2;\\n                    dp[i] += (i - dp[i]) >= 0 ? dp[i - dp[i]] : 0;\\n                    result = Math.max(result, dp[i]);\\n                    leftCount--;\\n                }\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n            LinkedList<Integer> stack = new LinkedList<>();\\n            int result = 0;\\n            stack.push(-1);\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == ')' && stack.size() > 1 && s.charAt(stack.peek()) == '(') {\\n                    stack.pop();\\n                    result = Math.max(result, i - stack.peek());\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14312,
                "title": "my-ten-lines-python-solution",
                "content": "   let dp[i] is the number of longest valid  Parentheses ended with the i - 1 position of s, then we have the following relationship:\\ndp[i + 1] = dp[p] + i - p + 1 where p is the position of '(' which can matches current ')' in the stack.\\n\\n      def longestValidParentheses(self, s):\\n        dp, stack = [0]*(len(s) + 1), []\\n        for i in range(len(s)):\\n            if s[i] == '(':\\n                stack.append(i)\\n            else:\\n                if stack:\\n                    p = stack.pop()\\n                    dp[i + 1] = dp[p] + i - p + 1\\n        return max(dp)",
                "solutionTags": [],
                "code": "   let dp[i] is the number of longest valid  Parentheses ended with the i - 1 position of s, then we have the following relationship:\\ndp[i + 1] = dp[p] + i - p + 1 where p is the position of '(' which can matches current ')' in the stack.\\n\\n      def longestValidParentheses(self, s):\\n        dp, stack = [0]*(len(s) + 1), []\\n        for i in range(len(s)):\\n            if s[i] == '(':\\n                stack.append(i)\\n            else:\\n                if stack:\\n                    p = stack.pop()\\n                    dp[i + 1] = dp[p] + i - p + 1\\n        return max(dp)",
                "codeTag": "Python3"
            },
            {
                "id": 345045,
                "title": "c-easy-to-understand",
                "content": "Rather than working with complex valid parenthesis strings, we just mark all of the occurences where an open parenthesis matches a close parenthesis. The idea is to then concatenate all of these individual valid parentheses to identify the longest valid streak of parentheses.\\n\\nFirst, we iterate through the string, keeping track of the indices of open parentheses in a stack. Every time we hit a close parenthesis, we know that the last open and the current close are both valid, so we mark both of these as being valid by overwriting them in the original string with `*`.\\n\\nOnce we have all of the valid individual parentheses marked, we iterate through the string once more and identify the longest sequence of `*`, which is our answer.\\n```cpp\\nint longestValidParentheses(string s) {\\n\\tstack<int> opens;\\n\\tfor(int i = 0; i < s.size(); i++) {\\n\\t\\tif(s[i] == \\'(\\') opens.push(i);\\n\\t\\telse if(opens.size()) {\\n\\t\\t\\ts[opens.top()] = s[i] = \\'*\\';\\n\\t\\t\\topens.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tint curr = 0, res = 0;\\n\\tfor(int i = 0; i <= s.size(); i++) {\\n\\t\\tif(s[i] == \\'*\\') curr++;\\n\\t\\telse {\\n\\t\\t\\tres = max(res, curr);\\n\\t\\t\\tcurr = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(curr, res);\\n}\\n```\\n\\n---\\n\\n**Alternate Solution:**\\n\\nTo reduce memory usage, we can take another approach. Scan the string from left to right, replacing any invalid parentheses with `*`. Then repeat the process, scanning from right to left. The string we\\'re left with should have \"pockets\" of valid parentheses strings separated by `*`. We simply have to iterate through the string and count the longest stretch of parentheses.\\n```\\nint longestValidParentheses(string s, int res = 0) {\\n\\tfor (int i = 0, n = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] == \\'(\\') ++n;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = s.size() - 1, n = 0; i >= 0; --i) \\n\\t\\tif (s[i] == \\')\\') ++n;\\n\\t\\telse if (s[i] == \\'*\\') n = 0;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = 0, cur = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] != \\'*\\') res = max(res, ++cur);\\n\\t\\telse cur = 0;\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nint longestValidParentheses(string s) {\\n\\tstack<int> opens;\\n\\tfor(int i = 0; i < s.size(); i++) {\\n\\t\\tif(s[i] == \\'(\\') opens.push(i);\\n\\t\\telse if(opens.size()) {\\n\\t\\t\\ts[opens.top()] = s[i] = \\'*\\';\\n\\t\\t\\topens.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tint curr = 0, res = 0;\\n\\tfor(int i = 0; i <= s.size(); i++) {\\n\\t\\tif(s[i] == \\'*\\') curr++;\\n\\t\\telse {\\n\\t\\t\\tres = max(res, curr);\\n\\t\\t\\tcurr = 0;\\n\\t\\t}\\n\\t}\\n\\n\\treturn max(curr, res);\\n}\\n```\n```\\nint longestValidParentheses(string s, int res = 0) {\\n\\tfor (int i = 0, n = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] == \\'(\\') ++n;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = s.size() - 1, n = 0; i >= 0; --i) \\n\\t\\tif (s[i] == \\')\\') ++n;\\n\\t\\telse if (s[i] == \\'*\\') n = 0;\\n\\t\\telse if (!n--) s[i] = \\'*\\', n = 0;\\n\\tfor (int i = 0, cur = 0; i < s.size(); ++i)\\n\\t\\tif (s[i] != \\'*\\') res = max(res, ++cur);\\n\\t\\telse cur = 0;\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 243913,
                "title": "7ms-100-o-n-time-o-1-space-without-stack-or-array",
                "content": "- This solution is inspired by maximum sum of subsequence.\\n\\t- Let\\'s recall the O(n) solution for that problem: we give up when the current sum < 0, set the sum = 0 and restart counting from the next number; and we records the maximum all the time.\\n\\t- In this problem, I use sum to indicate whether the expression is balanced:\\n\\t\\t- +1 to represent \\'(\\' and -1 for \\')\\'; if sum == 0, then the substring is balanced;\\n\\t\\t- sum < 0 means the expression is unbalanced, where I give up the current length and start again.\\n\\t- However, when we scan from left side, we can only find the expression unbalanced when \\')\\' appears too often, and \\'(\\' should also be checked for balance, so we should scan again from right side.\\n\\t- Total time complexity is O(n) as we scanned 2 times, and space complexity is O(1) as we don\\'t record things in an array or stack:)\\n```java\\n\\tpublic int longestValidParenthesesOnline(String s) {\\n        if (s == null) return -1;\\n        if (s.length() == 0) return 0;\\n        char[] str = s.toCharArray();\\n        int sum = 0, res = 0, len = 0, n = s.length();\\n\\t\\t// Scan the string from left side, plus 1 for \\'(\\' and minus 1 for \\')\\'.\\n        for (int i = 0; i < n; i++) {\\n            if (str[i] == \\'(\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n\\t\\t// Scan again from right side, plus 1 for \\')\\' and minus 1 for \\'(\\'.\\n        sum = 0;\\n        len = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (str[i] == \\')\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "- This solution is inspired by maximum sum of subsequence.\\n\\t- Let\\'s recall the O(n) solution for that problem: we give up when the current sum < 0, set the sum = 0 and restart counting from the next number; and we records the maximum all the time.\\n\\t- In this problem, I use sum to indicate whether the expression is balanced:\\n\\t\\t- +1 to represent \\'(\\' and -1 for \\')\\'; if sum == 0, then the substring is balanced;\\n\\t\\t- sum < 0 means the expression is unbalanced, where I give up the current length and start again.\\n\\t- However, when we scan from left side, we can only find the expression unbalanced when \\')\\' appears too often, and \\'(\\' should also be checked for balance, so we should scan again from right side.\\n\\t- Total time complexity is O(n) as we scanned 2 times, and space complexity is O(1) as we don\\'t record things in an array or stack:)\\n```java\\n\\tpublic int longestValidParenthesesOnline(String s) {\\n        if (s == null) return -1;\\n        if (s.length() == 0) return 0;\\n        char[] str = s.toCharArray();\\n        int sum = 0, res = 0, len = 0, n = s.length();\\n\\t\\t// Scan the string from left side, plus 1 for \\'(\\' and minus 1 for \\')\\'.\\n        for (int i = 0; i < n; i++) {\\n            if (str[i] == \\'(\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n\\t\\t// Scan again from right side, plus 1 for \\')\\' and minus 1 for \\'(\\'.\\n        sum = 0;\\n        len = 0;\\n        for (int i = n - 1; i >= 0; i--) {\\n            if (str[i] == \\')\\') sum++;\\n            else sum--;\\n            if (sum < 0) {\\n                sum = 0;\\n                len = 0;\\n            } else {\\n                len++;\\n                if (sum == 0) res = Math.max(res, len);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1139982,
                "title": "python-short-dp-explained",
                "content": "This is quite difficult problem, which can be solved with dymamic programming. As usual let us define `dp[i]` the length of the longest valid substring ending at `i`-th index. We can have several cases now:\\n1. If `i == -1`, it means we reached empty string, return `0`, answer for empty string. Also if `s[i] = (`, answer is also `0`, because no valid parantheses can end with `(`\\n2. Now, we have case, when `s[i] = )`. Let us look at the previous element. If it is equal to `(`, then we have `()` as two last elements and we can return `dp(i-2) + 2`.\\n3. Now consider the case, when `s[i-1] = )`, it means, that we have the following situation: `...))`. If we want to find the longest valid parentheses for `i`, first we need to deal with `i-1`. Define `P = i - dp(i-1) - 1`. Then we have the following situation:\\n\\n`...((.....))`\\n\\n`...P.......i`\\n\\nHere on the top is the structure of string and in the bottom are indexes. String from `P + 1` to `i - 1` indexes including is the longest valid parentheses endind with `i-1` place. What we can say about place `P`. If we have `)` element on this place, then we need to return `0`: in this case we have patten `...)(...))...` and we **know** that answer for `dp(P)` is equal to `0`: if it is not, what we considered was not the longest answer for `i-1`. And if answer for `dp(P)` is zero, than answer for `dp(i)` is zero as well.\\nIn the case, when we have `...((.....))`, answer is `dp(i-1) + dp(P-1) + 2`. \\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1 or s[i] == \"(\": return 0\\n            if i >= 1 and s[i-1:i+1] == \"()\": return dp(i-2) + 2\\n            P = i - dp(i-1) - 1\\n            if P >= 0 and s[P] == \"(\":\\n                return dp(i-1) + dp(P-1) + 2\\n            return 0\\n            \\n        return max(dp(i) for i in range(len(s))) if s else 0\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        @lru_cache(None)\\n        def dp(i):\\n            if i == -1 or s[i] == \"(\": return 0\\n            if i >= 1 and s[i-1:i+1] == \"()\": return dp(i-2) + 2\\n            P = i - dp(i-1) - 1\\n            if P >= 0 and s[P] == \"(\":\\n                return dp(i-1) + dp(P-1) + 2\\n            return 0\\n            \\n        return max(dp(i) for i in range(len(s))) if s else 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123926,
                "title": "best-python-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        longest = 0\\n        \\n        for c in s:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2\\n                    longest = max(longest, stack[-1])\\n                else:\\n                    stack = [0]\\n\\n        return longest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        stack = [0]\\n        longest = 0\\n        \\n        for c in s:\\n            if c == \"(\":\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2\\n                    longest = max(longest, stack[-1])\\n                else:\\n                    stack = [0]\\n\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068235,
                "title": "python-easy-2-approaches-space-o-n-and-o-1",
                "content": "The time complexity for both the approaches is `O(len(s)`.\\n\\n 1. ##### **Space - O(len(s))**\\n\\nThis approach solves the problem in similar way as https://leetcode.com/problems/valid-parentheses/ using `Stack`. The stack is used to track indices of `(`. So whenever we hit a `)`, we pop the pair from stack and update the length of valid substring.\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n        stck=[-1] # initialize with a start index\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stck.append(i)\\n            else:\\n                stck.pop()\\n                if not stck: # if popped -1, add a new start index\\n                    stck.append(i)\\n                else:\\n                    max_length=max(max_length, i-stck[-1]) # update the length of the valid substring\\n        return max_length\\n```\\n\\n2. ##### **Space - O(1)**\\nThe valid parantheses problem can also be solved using a counter variable. Below implementation modifies this approach a bit and uses two counters:`left` and `right` for `(` and `)` respectively. \\n\\nThe pseudo code for this approach:\\n1. Increment `left` on hitting `(`.\\n2. Increment `right` on hitting `)`.\\n3. If `left=right`, then calculate the current substring length and update the `max_length`\\n4. If `right>left`, then it means it\\'s an invalid substring. So reset both `left` and `right` to `0`.\\n\\nPerform the above algorithm once on original `s` and then on the reversed `s`.\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n                \\n        l,r=0,0        \\n        # traverse the string from left to right\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1                        \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif r>l: # invalid case as \\')\\' is more\\n                l=r=0\\n        \\n        l,r=0,0        \\n        # traverse the string from right to left\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1            \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif l>r: # invalid case as \\'(\\' is more\\n                l=r=0\\n        return max_length\\n```\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n        stck=[-1] # initialize with a start index\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stck.append(i)\\n            else:\\n                stck.pop()\\n                if not stck: # if popped -1, add a new start index\\n                    stck.append(i)\\n                else:\\n                    max_length=max(max_length, i-stck[-1]) # update the length of the valid substring\\n        return max_length\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        max_length = 0\\n                \\n        l,r=0,0        \\n        # traverse the string from left to right\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1                        \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif r>l: # invalid case as \\')\\' is more\\n                l=r=0\\n        \\n        l,r=0,0        \\n        # traverse the string from right to left\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i] == \\'(\\':\\n                l+=1\\n            else:\\n                r+=1            \\n            if l == r:# valid balanced parantheses substring \\n                max_length=max(max_length, l*2)\\n            elif l>r: # invalid case as \\'(\\' is more\\n                l=r=0\\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14355,
                "title": "my-solution-using-one-stack-in-one-pass",
                "content": "Since any valid parentheses sequence starts from a '(' and ends at ')', we can calculate new length when we meet a ')'. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details.\\n\\n\\n     // Using a stack. One pass\\n        int longestValidParentheses(string s) {\\n            vector<int> stack;\\n            int maxLen = 0;\\n            for (int i = 0; i < s.size(); ++i)\\n            {\\n                if (s[i] == '(')\\n                    stack.push_back(i);\\n                else {\\n                    if (!stack.empty() && s[stack.back()] == '(') {\\n                        stack.pop_back();\\n                        int lastPos = -1;\\n                        if (!stack.empty())\\n                            lastPos = stack.back();\\n                        int curLen = i - lastPos;\\n                        maxLen = (maxLen < curLen) ? curLen : maxLen;\\n                    } else\\n                        stack.push_back(i);\\n                }\\n            }\\n            return maxLen;\\n        }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "Since any valid parentheses sequence starts from a '(' and ends at ')', we can calculate new length when we meet a ')'. The key is to use a stack to store all the indices and the start position is always the one on top of the stack. See the code below for details.\\n\\n\\n     // Using a stack. One pass\\n        int longestValidParentheses(string s) {\\n            vector<int> stack;\\n            int maxLen = 0;\\n            for (int i = 0; i < s.size(); ++i)\\n            {\\n                if (s[i] == '(')\\n                    stack.push_back(i);\\n                else {\\n                    if (!stack.empty() && s[stack.back()] == '(') {\\n                        stack.pop_back();\\n                        int lastPos = -1;\\n                        if (!stack.empty())\\n                            lastPos = stack.back();\\n                        int curLen = i - lastPos;\\n                        maxLen = (maxLen < curLen) ? curLen : maxLen;\\n                    } else\\n                        stack.push_back(i);\\n                }\\n            }\\n            return maxLen;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401956,
                "title": "100-detailed-explaination-with-pictures-o-n-in-c-java-python-stack",
                "content": "# Approach\\n- Here the approach is nothing but we are using a stack and when we encounter an opening brace then we push the index of it into the stack and whenever we touch a closing brace then we see the top of the stack if it\\'s size is one then it means the closing braces have dominated the opening brace. We then edit the top value of the stack to the index of the closing brace.\\n>- This method is clearly depicted in the picture as shown below.\\n\\n![pic1.png](https://assets.leetcode.com/users/images/28c7fe2b-0003-4027-9d8f-94b1abadf7c4_1681156598.7949007.png)\\n\\n>- here answer is given as the line `ans = max(ans , index - stk.top())` only when the size of stack is not 1 and there is a closing brace encountered.\\n\\n---\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stk;\\n        stk.push(-1);\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size();  i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else\\n            {\\n                if(stk.size() == 1)\\n                    stk.top() = i;\\n                else\\n                {\\n                    stk.pop();\\n                    ans = max(ans , i - stk.top());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    int leftCount = 0;\\n    int rightCount = 0;\\n    int maxLength = 0;\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * rightCount);\\n        } else if (rightCount > leftCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    leftCount = rightCount = 0;\\n    \\n    for (int i = s.length() - 1; i >= 0; i--) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * leftCount);\\n        } else if (leftCount > rightCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    return maxLength;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        l=[\\'0\\']*len(s)\\n        for ind,i in enumerate(s):\\n            if i==\\'(\\':\\n                stack.append(ind)\\n            else:\\n                if stack:\\n                    l[stack.pop()]=\\'1\\'\\n                    l[ind]=\\'1\\'\\n        return max(len(i) for i in \\'\\'.join(l).split(\\'0\\'))\\n```\\n\\n---\\n\\n\\n\\n# Complexity\\n>- Time complexity:Here the complexity would be $$O(n)$$ as we are using only a single loop with a stack only so this runs in a linear complexity.\\n\\n>- Space complexity:Here the space complexity would be $O(n)$ as we are using just a stack that too store the elements in the worst case it goes to that complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![UPVOTE.jpg](https://assets.leetcode.com/users/images/d53e3e8f-f0ff-4dbb-bf1f-f44e71c7e735_1681156831.395462.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stk;\\n        stk.push(-1);\\n        int ans = 0;\\n        for(int i = 0 ; i < s.size();  i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);\\n            else\\n            {\\n                if(stk.size() == 1)\\n                    stk.top() = i;\\n                else\\n                {\\n                    stk.pop();\\n                    ans = max(ans , i - stk.top());\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    int leftCount = 0;\\n    int rightCount = 0;\\n    int maxLength = 0;\\n    \\n    for (int i = 0; i < s.length(); i++) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * rightCount);\\n        } else if (rightCount > leftCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    leftCount = rightCount = 0;\\n    \\n    for (int i = s.length() - 1; i >= 0; i--) {\\n        if (s.charAt(i) == \\'(\\') {\\n            leftCount++;\\n        } else {\\n            rightCount++;\\n        }\\n        \\n        if (leftCount == rightCount) {\\n            maxLength = Math.max(maxLength, 2 * leftCount);\\n        } else if (leftCount > rightCount) {\\n            leftCount = rightCount = 0;\\n        }\\n    }\\n    \\n    return maxLength;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        l=[\\'0\\']*len(s)\\n        for ind,i in enumerate(s):\\n            if i==\\'(\\':\\n                stack.append(ind)\\n            else:\\n                if stack:\\n                    l[stack.pop()]=\\'1\\'\\n                    l[ind]=\\'1\\'\\n        return max(len(i) for i in \\'\\'.join(l).split(\\'0\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14256,
                "title": "my-easy-o-n-java-solution-with-explanation",
                "content": "    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            int res=0;\\n            int tep=0;\\n            Stack<Integer> s1=new Stack<>();\\n            int data[]=new int[s.length()];\\n            for(int i=0;i<s.length();i++){\\n                char c=s.charAt(i);\\n                if(c=='(') s1.push(i);\\n                else{\\n                    if(!s1.empty()){\\n                        data[i]=1;\\n                        data[s1.pop()]=1;\\n                    }\\n                }\\n            }\\n            for(int i:data){\\n                if(i==1) tep++;\\n                else {res=Math.max(tep,res);tep=0;}\\n            }\\n            return Math.max(tep,res);\\n        }\\n    }\\n\\nImaging we are coloring the original string, each substring that has valid parentheses is colored with '1' and other characters are colored by '0'.\\nFor example \"( ) ( ( ) \"would become \"11011\". Thus, the problem has converted to finding the longest subsequence that all elements are '1', which could be easily solved.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n            int res=0;\\n            int tep=0;\\n            Stack<Integer> s1=new Stack<>();\\n            int data[]=new int[s.length()];\\n            for(int i=0;i<s.length();i++){\\n                char c=s.charAt(i);\\n                if(c=='(') s1.push(i);\\n                else{\\n                    if(!s1.empty()){\\n                        data[i]=1;\\n                        data[s1.pop()]=1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 14140,
                "title": "constant-space-o-n-time-with-forward-and-backward-pass",
                "content": "When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. \\n\\n\\n    int longestValidParentheses(string s) {\\n        int longest = 0;\\n        int extra=0;\\n        int length=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] == '(') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0) {\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        length = 0;\\n        extra=0;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(s[i] == ')') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0){\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                    \\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        return longest;\\n    }",
                "solutionTags": [],
                "code": "When right parentheses are more than left parentheses in the forward pass, we can discard previous parentheses. In the backward pass, when left parentheses are more than right parentheses, we can discard previous parentheses. \\n\\n\\n    int longestValidParentheses(string s) {\\n        int longest = 0;\\n        int extra=0;\\n        int length=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i] == '(') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0) {\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        length = 0;\\n        extra=0;\\n        for(int i=s.size()-1; i>=0; i--) {\\n            if(s[i] == ')') {\\n                extra++;\\n                length++;\\n            }\\n            else {\\n                if(extra>0){\\n                    extra--;\\n                    length++;\\n                    if(extra == 0)\\n                        longest = max(longest, length);\\n                    \\n                }\\n                else {\\n                    extra = 0;\\n                    length=0;\\n                }\\n            }\\n        }\\n        return longest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14141,
                "title": "pure-1d-dp-without-using-stack-python-with-detailed-explanation",
                "content": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            # use 1D DP\\n            # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i]\\n            dp = [0 for x in xrange(len(s))]\\n            max_to_now = 0\\n            for i in xrange(1,len(s)):\\n                if s[i] == ')':\\n                    # case 1: ()()\\n                    if s[i-1] == '(':\\n                        # add nearest parentheses pairs + 2\\n                        dp[i] = dp[i-2] + 2\\n                    # case 2: (()) \\n                    # i-dp[i-1]-1 is the index of last \"(\" not paired until this \")\"\\n                    elif i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\\n                        if dp[i-1] > 0: # content within current matching pair is valid \\n                        # add nearest parentheses pairs + 2 + parentheses before last \"(\"\\n                            dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n                        else:\\n                        # otherwise is 0\\n                            dp[i] = 0\\n                    max_to_now = max(max_to_now, dp[i])\\n            return max_to_now",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            # use 1D DP\\n            # dp[i] records the longestValidParenthese EXACTLY ENDING at s[i]\\n            dp = [0 for x in xrange(len(s))]\\n            max_to_now = 0\\n            for i in xrange(1,len(s)):\\n                if s[i] == ')':\\n                    # case 1: ()()\\n                    if s[i-1] == '(':\\n                        # add nearest parentheses pairs + 2\\n                        dp[i] = dp[i-2] + 2\\n                    # case 2: (()) \\n                    # i-dp[i-1]-1 is the index of last \"(\" not paired until this \")\"\\n                    elif i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\\n                        if dp[i-1] > 0: # content within current matching pair is valid \\n                        # add nearest parentheses pairs + 2 + parentheses before last \"(\"\\n                            dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n                        else:\\n                        # otherwise is 0\\n                            dp[i] = 0\\n                    max_to_now = max(max_to_now, dp[i])\\n            return max_to_now",
                "codeTag": "Java"
            },
            {
                "id": 14284,
                "title": "8-line-python-solution-stack-80ms",
                "content": "To make sure the stack is not empty, first put in a tuple `(-1, ')')` as it will never be poped out and `-1` can be used to calculate `result`.\\n\\n    def longestValidParentheses(self, s):\\n        stack, result = [(-1, ')')], 0\\n        for i, paren in enumerate(s):\\n            if paren == ')' and stack[-1][1] == '(':\\n                stack.pop()\\n                result = max(result, i - stack[-1][0])\\n            else:\\n                stack += (i, paren),\\n        return result",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "To make sure the stack is not empty, first put in a tuple `(-1, ')')` as it will never be poped out and `-1` can be used to calculate `result`.\\n\\n    def longestValidParentheses(self, s):\\n        stack, result = [(-1, ')')], 0\\n        for i, paren in enumerate(s):\\n            if paren == ')' and stack[-1][1] == '(':\\n                stack.pop()\\n                result = max(result, i - stack[-1][0])\\n            else:\\n                stack += (i, paren),\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 1349298,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        var val = 0, stack = [-1]\\n        for (i, ch) in s.enumerated() {\\n            guard ch != \"(\" else { stack.append(i); continue }\\n            guard stack.count > 1 else { stack[0] = i; continue }\\n            stack.removeLast()\\n            val = max(val, i - stack.last!)\\n        }\\n        return val\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<p><pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The longest valid parentheses substring is \"()\".\\n    func test0() {\\n        let res = solution.longestValidParentheses(\"(()\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    \\n    // The longest valid parentheses substring is \"()()\".\\n    func test1() {\\n        let res = solution.longestValidParentheses(\")()())\")\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test2() {\\n        let res = solution.longestValidParentheses(\"\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n        guard !s.isEmpty else { return 0 }\\n        var val = 0, stack = [-1]\\n        for (i, ch) in s.enumerated() {\\n            guard ch != \"(\" else { stack.append(i); continue }\\n            guard stack.count > 1 else { stack[0] = i; continue }\\n            stack.removeLast()\\n            val = max(val, i - stack.last!)\\n        }\\n        return val\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The longest valid parentheses substring is \"()\".\\n    func test0() {\\n        let res = solution.longestValidParentheses(\"(()\")\\n        XCTAssertEqual(res, 2)\\n    }\\n    \\n    // The longest valid parentheses substring is \"()()\".\\n    func test1() {\\n        let res = solution.longestValidParentheses(\")()())\")\\n        XCTAssertEqual(res, 4)\\n    }\\n    \\n    func test2() {\\n        let res = solution.longestValidParentheses(\"\")\\n        XCTAssertEqual(res, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864061,
                "title": "c-o-n-time-and-o-1-space-0ms-runtime-beats-100-explained",
                "content": "### Intuition\\n\\nBefore explaining the solution, I will write how I came up with the solution.\\n\\nThe main point to notice in this problem is that the moment we get an invalid parenthesis, the subarray can\\'t start from beyond this point.\\nNot clear ? Let\\'s understand with an example.\\n\\nConsider this simple string.\\n```()()))()(())```, at index 4 the subarray starting from index 0 becomes invalid, it is clear the longest valid parenthesis won\\'t start from [0, 3] and end after 4.\\n\\nThis striked me that I can use a sliding window to solve this problem.\\n\\n### How to solve ?\\n\\nConsider a window with left end shown by **i** and right end shown by **j**.\\nInitially **i = 0 and j = 0**\\nLet us consider another variable k which will help us to determine when subarray becomes invalid.\\n\\nNow, we start moving j keeping i as fixed. \\n\\nIncrement k when we encounter ```(``` and decrement when we encounter ```)```.\\n\\nWhenever k becomes zero we will update our answer with max(ans,  j - i + 1)\\nIt is clear when k becomes negative the subarray will become invalid, so we will move the left end i.e **i** to the new position.\\n\\n**Question**\\nWhy are we updating the answer when k is 0 and not when k > 0.\\n**Answer**\\nWe know for sure, whenever we get k as 0 the subarray is valid and length will be j - i + 1.\\nBut when k > 0 the subarray is still valid, but the length will be less than j - i + 1.\\nBut ofcourse we are missing some values, since the length which is less j - i + 1 can be a better answer.\\n\\nConsider this string ```(()```. Here, we will never get k = 0 and hence we can\\'t update our answer.\\n\\n**How to resolve this?**\\nWe have to repeat the above process but this time starting i = n - 1 and j = n - 1. Now, keep moving j to the left side and do the same as above. Here k will increase when we encounter ```)``` and decrease when we encounter ```(```.\\n\\n### Cpp Code\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), i = 0, ans = 0, k = 0;\\n        for(int j = 0; j < n; j++) {\\n            if(s[j] == \\'(\\')  k++;\\n            else if(s[j] == \\')\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, j - i + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j + 1;\\n            }\\n        }\\n        k = 0, i = n - 1;\\n        for(int j = n - 1; j >= 0; j--) {\\n            if(s[j] == \\')\\') {\\n                k++;\\n            }\\n            else if(s[j] == \\'(\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, i - j + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Please upvote if this post is helpful to you :)**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```()()))()(())```\n```(```\n```)```\n```(()```\n```)```\n```(```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), i = 0, ans = 0, k = 0;\\n        for(int j = 0; j < n; j++) {\\n            if(s[j] == \\'(\\')  k++;\\n            else if(s[j] == \\')\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, j - i + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j + 1;\\n            }\\n        }\\n        k = 0, i = n - 1;\\n        for(int j = n - 1; j >= 0; j--) {\\n            if(s[j] == \\')\\') {\\n                k++;\\n            }\\n            else if(s[j] == \\'(\\') {\\n                k--;\\n                if(k == 0)\\n                    ans = max(ans, i - j + 1);\\n            }\\n            if(k < 0) {\\n                k = 0;\\n                i = j - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069416,
                "title": "c-easy-simple-stack-solution-o-n-daily-leetcoding-challenge-may-day-24",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        // created a stack for storing the open parenthesis \\n        stack<int> st;\\n        st.push(-1);            // initially push -1 to the stack because if there is ) then we can not pop our stack if it is empty\\n        \\n        int ans = 0;\\n        \\n        // iterate over the given string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            // if it is open parenthesis then push that index to the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if it is close then pop the stack \\n            // and check it is empty or not if it is empty then push current value to it because if there is another ) then we can not pop our stack if it is empty\\n            // if it is not empty then find the length between the (current index i and stack top index) and store the max value in ans\\n            else\\n            {\\n                st.pop();\\n                \\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    ans = max(ans,i-st.top());\\n            }\\n        }\\n        \\n        // returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        // created a stack for storing the open parenthesis \\n        stack<int> st;\\n        st.push(-1);            // initially push -1 to the stack because if there is ) then we can not pop our stack if it is empty\\n        \\n        int ans = 0;\\n        \\n        // iterate over the given string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            // if it is open parenthesis then push that index to the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if it is close then pop the stack \\n            // and check it is empty or not if it is empty then push current value to it because if there is another ) then we can not pop our stack if it is empty\\n            // if it is not empty then find the length between the (current index i and stack top index) and store the max value in ans\\n            else\\n            {\\n                st.pop();\\n                \\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    ans = max(ans,i-st.top());\\n            }\\n        }\\n        \\n        // returning the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140005,
                "title": "longest-valid-parentheses-js-python-java-c-easy-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nOne of the key things to realize about valid parentheses strings is that they\\'re entirely self-satisfied, meaning that while you can have one substring that is entirely inside another, you can\\'t have two substrings that only partially overlap.\\n\\nThis means that we can use a **greedy O(N) time complexity** solution to this problem without the need for any kind of backtracking. In fact, we should be able to use a very standard stack-based valid parentheses string algorithm with just three very minor modifications.\\n\\nIn a stadard valid parentheses string algorithm, we iterate through the string (**S**) and push the index (**i**) of any **\\'(\\'** to our **stack**. Whenever we find a **\\')\\'**, we match it with the last entry on the **stack** and pop said entry off. We know the string is not valid if we find a **\\')\\'** while there are no **\\'(\\'** indexes in the **stack** with which to match it, and also if we have leftover **\\'(\\'** in the **stack** when we reach the end of **S**.\\n\\nFor this problem, we will need to add in a step that updates our answer (**ans**) when we close a parentheses pair. Since we stored the index of the **\\'(\\'** in our stack, we can easily find the difference between the **\\')\\'** at **i** and the last entry in the **stack**, which should be the length of the valid substring which was just closed.\\n\\nBut here we run into a problem, because consecutive valid substrings can be grouped into a larger valid substring (ie, **\\'()()\\' = 4**). So instead of counting from the *last* **stack** entry, we should actually count from the *second to last* entry, to include any other valid closed substrings since the most recent **\\'(\\'** that will still remain after we pop the just-matched last **stack** entry off.\\n\\nThis, of course, brings us to the second and third changes. Since we\\'re checking the second to last **stack** entry, what happens in the case of **\\'()()\\'** when you close the second valid substring yet there\\'s only the one **stack** entry left at the time?\\n\\nTo avoid this issue, we can just wrap the entire string in another imaginary set of parentheses by starting with **stack = [-1]**, indicating that there\\'s an imaginary **\\'(\\'** just before the beginning of the string at **i = 0**.\\n\\nThe other issue is that we will want to continue even if the string up to **i** becomes invalid due to a **\\')\\'** appearing when the **stack** is \"empty\", or in this case has only our imaginary index left. In that case, we can just effectively restart our **stack** by updating our imaginary **\\'(\\'** index (**stack[0] = i**) and continue on.\\n\\nThen, once we reach the end of **S**, we can just **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 39.9MB** (beats 99% / 78%).\\n```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.6MB** (beats 88% / 71%).\\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 38.7MB** (beats 69% / 94%).\\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.1MB** (beats 100% / 71%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139974,
                "title": "python-c-go-o-n-by-stack-w-comment",
                "content": "O(n) by stack\\n\\n---\\n\\n**Implementation** by stack in Python\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\n        # stack, used to record index of parenthesis\\n        # initialized to -1 as dummy head for valid parentheses length computation\\n        stack = [-1]\\n        \\n        max_length = 0\\n        \\n\\t\\t# linear scan each index and character in input string s\\n        for cur_idx, char in enumerate(s):\\n            \\n            if char == \\'(\\':\\n                \\n                # push when current char is (\\n                stack.append( cur_idx )\\n                \\n            else:\\n                \\n                # pop when current char is )\\n                stack.pop()\\n                \\n                if not stack:\\n                    \\n                    # stack is empty, push current index into stack\\n                    stack.append( cur_idx )\\n                else:\\n                    # stack is non-empty, update maximal valid parentheses length\\n                    max_length = max(max_length, cur_idx - stack[-1])\\n                \\n        return max_length\\n```\\n\\n---\\n\\n**Implementation** by stack in C++\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        // Initialized a stack with -1 on the bottom\\n        std::stack<int> _stack = std::stack<int>( {-1} );\\n        \\n        int maxSize = 0;\\n        \\n        // scan each character\\n        for( int i = 0 ; i < s.length() ;  i++ ){\\n            \\n            char ch = s[i];\\n            \\n            if( ch == \\'(\\' ){\\n                \\n                // current charachter is left bracket\\n                _stack.push( i );\\n                \\n            }else{\\n                \\n                // right charachter is left bracket\\n                _stack.pop();\\n                \\n                if( _stack.empty() ){\\n                    \\n                    // handle for corner case when ) comes before (\\n                    _stack.push( i );\\n                    \\n                }else{\\n                    // update max length if we have paired bracket\\n                    maxSize = max( maxSize, i - _stack.top() );    \\n                }\\n            }\\n        }\\n        \\n        return maxSize;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by stack in Go\\n\\n```\\n// Support function max\\nfunc Max(a, b int)int{\\n    \\n    if a > b{\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\nfunc longestValidParentheses(s string) int {\\n    \\n    // stack, used to record index of parenthesis\\n    // initialized to -1 as dummy head for valid parenthesis length computation\\n    stack := []int{-1}\\n    \\n    maxLength := 0\\n    \\n    // linear scan each index and character in input string s\\n    for curIdx, char := range s{\\n        \\n        if char == \\'(\\'{\\n            \\n            // push when current char is (\\n            stack = append( stack, curIdx)\\n            \\n        }else{\\n            \\n            // pop when current char is )\\n            stack = stack[:len(stack)-1]\\n            \\n            if len(stack)==0{\\n                \\n                // stack is empty, push current index into stack\\n                stack = append( stack, curIdx)\\n            }else{\\n                \\n                // stack is non-empty, update maximal valud parentheses length\\n                \\n                maxLength = Max( maxLength, curIdx - stack[ len(stack)-1 ] )\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return maxLength\\n    \\n}\\n\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Go",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\n        # stack, used to record index of parenthesis\\n        # initialized to -1 as dummy head for valid parentheses length computation\\n        stack = [-1]\\n        \\n        max_length = 0\\n        \\n\\t\\t# linear scan each index and character in input string s\\n        for cur_idx, char in enumerate(s):\\n            \\n            if char == \\'(\\':\\n                \\n                # push when current char is (\\n                stack.append( cur_idx )\\n                \\n            else:\\n                \\n                # pop when current char is )\\n                stack.pop()\\n                \\n                if not stack:\\n                    \\n                    # stack is empty, push current index into stack\\n                    stack.append( cur_idx )\\n                else:\\n                    # stack is non-empty, update maximal valid parentheses length\\n                    max_length = max(max_length, cur_idx - stack[-1])\\n                \\n        return max_length\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        // Initialized a stack with -1 on the bottom\\n        std::stack<int> _stack = std::stack<int>( {-1} );\\n        \\n        int maxSize = 0;\\n        \\n        // scan each character\\n        for( int i = 0 ; i < s.length() ;  i++ ){\\n            \\n            char ch = s[i];\\n            \\n            if( ch == \\'(\\' ){\\n                \\n                // current charachter is left bracket\\n                _stack.push( i );\\n                \\n            }else{\\n                \\n                // right charachter is left bracket\\n                _stack.pop();\\n                \\n                if( _stack.empty() ){\\n                    \\n                    // handle for corner case when ) comes before (\\n                    _stack.push( i );\\n                    \\n                }else{\\n                    // update max length if we have paired bracket\\n                    maxSize = max( maxSize, i - _stack.top() );    \\n                }\\n            }\\n        }\\n        \\n        return maxSize;\\n        \\n    }\\n};\\n```\n```\\n// Support function max\\nfunc Max(a, b int)int{\\n    \\n    if a > b{\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\nfunc longestValidParentheses(s string) int {\\n    \\n    // stack, used to record index of parenthesis\\n    // initialized to -1 as dummy head for valid parenthesis length computation\\n    stack := []int{-1}\\n    \\n    maxLength := 0\\n    \\n    // linear scan each index and character in input string s\\n    for curIdx, char := range s{\\n        \\n        if char == \\'(\\'{\\n            \\n            // push when current char is (\\n            stack = append( stack, curIdx)\\n            \\n        }else{\\n            \\n            // pop when current char is )\\n            stack = stack[:len(stack)-1]\\n            \\n            if len(stack)==0{\\n                \\n                // stack is empty, push current index into stack\\n                stack = append( stack, curIdx)\\n            }else{\\n                \\n                // stack is non-empty, update maximal valud parentheses length\\n                \\n                maxLength = Max( maxLength, curIdx - stack[ len(stack)-1 ] )\\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    return maxLength\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140004,
                "title": "js-python-java-c-easy-stack-solution-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\nOne of the key things to realize about valid parentheses strings is that they\\'re entirely self-satisfied, meaning that while you can have one substring that is entirely inside another, you can\\'t have two substrings that only partially overlap.\\n\\nThis means that we can use a **greedy O(N) time complexity** solution to this problem without the need for any kind of backtracking. In fact, we should be able to use a very standard stack-based valid parentheses string algorithm with just three very minor modifications.\\n\\nIn a stadard valid parentheses string algorithm, we iterate through the string (**S**) and push the index (**i**) of any **\\'(\\'** to our **stack**. Whenever we find a **\\')\\'**, we match it with the last entry on the **stack** and pop said entry off. We know the string is not valid if we find a **\\')\\'** while there are no **\\'(\\'** indexes in the **stack** with which to match it, and also if we have leftover **\\'(\\'** in the **stack** when we reach the end of **S**.\\n\\nFor this problem, we will need to add in a step that updates our answer (**ans**) when we close a parentheses pair. Since we stored the index of the **\\'(\\'** in our stack, we can easily find the difference between the **\\')\\'** at **i** and the last entry in the **stack**, which should be the length of the valid substring which was just closed.\\n\\nBut here we run into a problem, because consecutive valid substrings can be grouped into a larger valid substring (ie, **\\'()()\\' = 4**). So instead of counting from the *last* **stack** entry, we should actually count from the *second to last* entry, to include any other valid closed substrings since the most recent **\\'(\\'** that will still remain after we pop the just-matched last **stack** entry off.\\n\\nThis, of course, brings us to the second and third changes. Since we\\'re checking the second to last **stack** entry, what happens in the case of **\\'()()\\'** when you close the second valid substring yet there\\'s only the one **stack** entry left at the time?\\n\\nTo avoid this issue, we can just wrap the entire string in another imaginary set of parentheses by starting with **stack = [-1]**, indicating that there\\'s an imaginary **\\'(\\'** just before the beginning of the string at **i = 0**.\\n\\nThe other issue is that we will want to continue even if the string up to **i** becomes invalid due to a **\\')\\'** appearing when the **stack** is \"empty\", or in this case has only our imaginary index left. In that case, we can just effectively restart our **stack** by updating our imaginary **\\'(\\'** index (**stack[0] = i**) and continue on.\\n\\nThen, once we reach the end of **S**, we can just **return ans**.\\n\\n---\\n\\n#### ***Implementation:***\\n\\nThere are only minor differences in the code for all four languages.\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\nThe best result for the code below is **76ms / 39.9MB** (beats 99% / 78%).\\n```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\nThe best result for the code below is **40ms / 14.6MB** (beats 88% / 71%).\\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\nThe best result for the code below is **2ms / 38.7MB** (beats 69% / 94%).\\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\nThe best result for the code below is **0ms / 7.1MB** (beats 100% / 71%).\\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestValidParentheses = function(S) {\\n    let stack = [-1], ans = 0\\n    for (let i = 0; i < S.length; i++)\\n        if (S[i] === \\'(\\') stack.push(i)\\n        else if (stack.length === 1) stack[0] = i\\n        else stack.pop(), ans = Math.max(ans, i - stack[stack.length-1])\\n    return ans\\n};\\n```\n```python\\nclass Solution:\\n    def longestValidParentheses(self, S: str) -> int:\\n        stack, ans = [-1], 0\\n        for i in range(len(S)):\\n            if S[i] == \\'(\\': stack.append(i)\\n            elif len(stack) == 1: stack[0] = i\\n            else:\\n                stack.pop()\\n                ans = max(ans, i - stack[-1])\\n        return ans\\n```\n```java\\nclass Solution {\\n    public int longestValidParentheses(String S) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int ans = 0;\\n        for (int i = 0; i < S.length(); i++)\\n            if (S.charAt(i) == \\'(\\') stack.push(i);\\n            else {\\n                stack.pop();\\n                if (stack.isEmpty()) stack.push(i);\\n                else ans = Math.max(ans, i - stack.peek());\\n            }\\n        return ans;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string S) {\\n        vector<int> stack = {-1};\\n        int ans = 0;\\n        for (int i = 0; i < S.size(); i++)\\n            if (S[i] == \\'(\\') stack.push_back(i);\\n            else if (stack.size() == 1) stack[0] = i;\\n            else {\\n                stack.pop_back();\\n                ans = max(ans, i - stack.back());\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027331,
                "title": "java-from-top-down-w-memo-to-bottom-up-dp-beats-100",
                "content": "Since the tag of this problem is `Dynamic Programming`, here I shared a top down approach, similar to solution 2 but for me it\\'s easier to understand. \\n\\nWe define the subproblem as `dp(idx) := length of the longest valid parentheses which use s[idx] as end.`\\n\\nWe only compute when `s[idx] == \\')\\'` since `\\'(\\'` can\\'t be the end of a valid parentheses.\\n\\nThe recurrence relationship is:\\n1. when `s[idx - 1] == \\'(\\'`:\\n\\t `\\'(\\'` and `\\')\\'` at idx - 1 and idx respectively already form a valid `()`, since we want to form the longest substring, we want to check if the substring end with `s[idx - 2]` is also valid, if valid, we need to add the length of it (`dp(idx - 2)`).\\n\\t `dp(idx) = 2 + dp(idx - 2)`\\n2. when `s[idx - 1] == \\')\\'`:\\n\\t\\tfirst we need to check if substring end at `idx - 1` is valid, if not. then we can\\'t use `idx` as end neither. if valid, we want to make sure that `)` at `idx` has a `\\'(\\'` to match it, without this `\\'(\\'`, substring end at `idx` can\\'t be valid as well. So what\\'s the position should such `\\'(\\'` located? Its position is at `idx - dp(idx - 1) - 1`, e.g. `....(  (())  )`, previous valid parentheses length is 4, so the `\\'(\\'` matching `\\')\\'` at idx is at `idx - 4 - 1`, where `4 = dp(idx - 1)`. as in case 1, we want to check if the substring can be longer, so we check the previous index which is left to the `\\'(\\'` that match `\\')\\'` at idx. Its index is `idx - dp(idx - 1) - 2`.\\n\\t\\t`if dp(idx - 1) > 0 && s[idx - dp(idx - 1) - 1] == \\'(\\':        dp(idx) = 2 + dp(idx - 1) + dp(idx - dp(idx - 1) - 2)`\\n\\nBase case is trivial, `dp(idx) = 0 if idx <= 0`\\n\\n```\\nclass Solution {\\n    int[] memo;\\n    \\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dp(s, i));\\n        }\\n        return ans;\\n    }\\n    \\n    private int dp(String s, int idx) {\\n        if (idx <= 0) return 0; // Base case\\n        if (memo[idx] != -1) return memo[idx];\\n\\t\\t\\n        int ans = 0;\\n        if (s.charAt(idx) == \\')\\') {\\n            if (idx > 0 && s.charAt(idx - 1) == \\'(\\') {\\n                ans += 2; // \\'(\\' \\')\\' at idx-1 and idx\\n                ans += dp(s, idx - 2); // previous valid length\\n            } else if (idx > 0 && s.charAt(idx - 1) == \\')\\') {\\n                int prevLen = dp(s, idx - 1); // idx-1 has valid parentheses?\\n                if (prevLen > 0 && idx - prevLen - 1 >= 0 && s.charAt(idx- prevLen - 1) == \\'(\\') {\\n                    ans += 2; // \\'(\\' pair with \\')\\' at idx\\n                    ans += prevLen; // length use s[idx -1] as end\\n                    ans += dp(s, idx - prevLen - 2); // more previous length\\n                }\\n            }\\n        }\\n        memo[idx] = ans;\\n        return ans;\\n    }\\n}\\n```\\n\\nIf you understand this top-down approach, you can easily convert it to bottom-up dp to avoid recursive calls.\\n```\\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        int ans = 0;\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\')\\') {\\n                if (s.charAt(i - 1) == \\'(\\') {\\n                    dp[i] = 2 + (i - 2 >= 0 ? dp[i - 2] : 0);\\n                } else {\\n                    int prevLen = dp[i - 1];\\n                    if (prevLen > 0 && i - prevLen - 1 >= 0 && s.charAt(i - prevLen - 1) == \\'(\\') {\\n                        dp[i] = 2 + prevLen + (i - prevLen - 2 >= 0 ? dp[i - prevLen - 2] : 0);\\n                    }\\n                }\\n            }\\n            ans = Math.max(ans, dp[i]);\\n        }\\n\\n        return ans;\\n    }\\n```\\n\\nTime Complexity: `O(n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int[] memo;\\n    \\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        memo = new int[n];\\n        Arrays.fill(memo, -1);\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.max(ans, dp(s, i));\\n        }\\n        return ans;\\n    }\\n    \\n    private int dp(String s, int idx) {\\n        if (idx <= 0) return 0; // Base case\\n        if (memo[idx] != -1) return memo[idx];\\n\\t\\t\\n        int ans = 0;\\n        if (s.charAt(idx) == \\')\\') {\\n            if (idx > 0 && s.charAt(idx - 1) == \\'(\\') {\\n                ans += 2; // \\'(\\' \\')\\' at idx-1 and idx\\n                ans += dp(s, idx - 2); // previous valid length\\n            } else if (idx > 0 && s.charAt(idx - 1) == \\')\\') {\\n                int prevLen = dp(s, idx - 1); // idx-1 has valid parentheses?\\n                if (prevLen > 0 && idx - prevLen - 1 >= 0 && s.charAt(idx- prevLen - 1) == \\'(\\') {\\n                    ans += 2; // \\'(\\' pair with \\')\\' at idx\\n                    ans += prevLen; // length use s[idx -1] as end\\n                    ans += dp(s, idx - prevLen - 2); // more previous length\\n                }\\n            }\\n        }\\n        memo[idx] = ans;\\n        return ans;\\n    }\\n}\\n```\n```\\n    public int longestValidParentheses(String s) {\\n        int n = s.length();\\n        int[] dp = new int[n];\\n        int ans = 0;\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (s.charAt(i) == \\')\\') {\\n                if (s.charAt(i - 1) == \\'(\\') {\\n                    dp[i] = 2 + (i - 2 >= 0 ? dp[i - 2] : 0);\\n                } else {\\n                    int prevLen = dp[i - 1];\\n                    if (prevLen > 0 && i - prevLen - 1 >= 0 && s.charAt(i - prevLen - 1) == \\'(\\') {\\n                        dp[i] = 2 + prevLen + (i - prevLen - 2 >= 0 ? dp[i - prevLen - 2] : 0);\\n                    }\\n                }\\n            }\\n            ans = Math.max(ans, dp[i]);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14131,
                "title": "explaining-solution-using-stack",
                "content": "I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter '(' we push the index onto the stack and when we encounter ')' we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code\\n\\n \\n\\n    public static int longestValidParentheses(String s) {\\n    \\n    \\n            Stack<Integer> bracketStack = new Stack<Integer>();\\n            int max_len=0;\\n            int current_len=0;\\n            int last = -1;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == '(') {\\n                    \\n                        bracketStack.push(i);\\n                }\\n                else{\\n    \\n                    if(!bracketStack.isEmpty())\\n                    {\\n                        bracketStack.pop();\\n    \\n                    if(!bracketStack.isEmpty())\\n                        current_len = i-bracketStack.peek();\\n                    else\\n                        current_len=i-last;\\n                    max_len = Math.max(max_len,current_len);\\n                    }\\n                    else{\\n                        \\n                        last = i;\\n                    }\\n                }\\n    \\n            }\\n    \\n    \\n            return max_len;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I have seen a lot of good answers but it is not immediately clear how they are achieving the result. I am going to make an attempt to explain my solution using a stack. Every time we encounter '(' we push the index onto the stack and when we encounter ')' we pop the stack and use the current index minus the index at the top of the stack to be the current_length. we check against the max found so far and update if needed. Here is the code\\n\\n \\n\\n    public static int longestValidParentheses(String s) {\\n    \\n    \\n            Stack<Integer> bracketStack = new Stack<Integer>();\\n            int max_len=0;\\n            int current_len=0;\\n            int last = -1;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) == '(') {\\n                    \\n                        bracketStack.push(i);\\n                }\\n                else{\\n    \\n                    if(!bracketStack.isEmpty())\\n                    {\\n                        bracketStack.pop();\\n    \\n                    if(!bracketStack.isEmpty())\\n                        current_len = i-bracketStack.peek();\\n                    else\\n                        current_len=i-last;\\n                    max_len = Math.max(max_len,current_len);\\n                    }\\n                    else{\\n                        \\n                        last = i;\\n                    }\\n                }\\n    \\n            }\\n    \\n    \\n            return max_len;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14146,
                "title": "simple-java-solution",
                "content": "![enter image description here][1]\\n\\n\\n  [1]: http://s11.postimg.org/9i4ju3imr/IMG_20150202_130621.jpg\\n\\n\\n    public int longestValidParentheses(String s) {\\n        char[] S = s.toCharArray();\\n        int[] V = new int[S.length];\\n        int open = 0;\\n        int max = 0;\\n        for (int i=0; i<S.length; i++) {\\n        \\tif (S[i] == '(') open++;\\n        \\tif (S[i] == ')' && open > 0) {\\n        \\t\\tV[i] = 2 + V[i-1] + (i-2-V[i-1] > 0 ? V[i-2-V[i-1]] : 0);\\n        \\t\\topen--;\\n        \\t}\\n        \\tif (V[i] > max) max = V[i];\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "![enter image description here][1]\\n\\n\\n  [1]: http://s11.postimg.org/9i4ju3imr/IMG_20150202_130621.jpg\\n\\n\\n    public int longestValidParentheses(String s) {\\n        char[] S = s.toCharArray();\\n        int[] V = new int[S.length];\\n        int open = 0;\\n        int max = 0;\\n        for (int i=0; i<S.length; i++) {\\n        \\tif (S[i] == '(') open++;\\n        \\tif (S[i] == ')' && open > 0) {\\n        \\t\\tV[i] = 2 + V[i-1] + (i-2-V[i-1] > 0 ? V[i-2-V[i-1]] : 0);\\n        \\t\\topen--;\\n        \\t}\\n        \\tif (V[i] > max) max = V[i];\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1139991,
                "title": "short-easy-w-explanation-o-n-solution-with-stack",
                "content": "***Solution (Simulating with stack) :***\\n\\nWe can use a stack to find the longest valid parentheses. \\n\\nWe will start by pushing `-1` into the stack at first. This will denote index preceding to **potential start of valid parentheses**. It will be more clear later. Now will start iterating over `s` and we will have two cases -\\n1. **`s[i] == \\'(\\'`** - In this case, we will push the index into the stack (just as we do in valid parentheses check).\\n2. **`s[i] == \\')\\'`** - In this case, we will pop the index from the stack (again just as in parentheses check). Now, after popping, we need to do some simple checks which are main steps of this problem. Again, there will be following scenarios that may occur -\\n    * **stack is not empty** - If stack is not empty, then this **may be our longest valid parentheses**. We update the `MAX_len` as `max(MAX_len, current index - stack.top())`. Do notice, that our bottom of stack will always hold index preceding to a potential valid parentheses.\\n\\t* **stack becomes empty** - This will only happen when we have an extra \\')\\' bracket. There may have been valid parentheses previously which have been updated and stored in `MAX_len`. But, since we now have an extra closing bracket any further extensions of previous valid parentheses is not possible. So, push the current index into stack, again which will denote that bottom of stack will hold the index preceding to a **potential** valid parentheses.\\n\\n```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\\n\\nThe small simulation above might have given you the idea of how this process works. Watch the LC solution showing a gif which will give you better idea. Below is them implementation of the same -\\n\\n\\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```\\n\\n***Time Complexity :*** **`O(N)`**, for iterating over the string s.\\n***Space Complexity :*** **`O(N)`**, for maintaining the stack.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nExample - \\'()())()\\'\\nInitial stack(from bottom to top) :  [ -1 ] , MAX = 0\\n\\n1. i = 0          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 0]   |   MAX = 0\\n\\n2. i = 1          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(0, 1 - (-1)) = 2.\\n\\n\\'NOTE : Since the index starts from 0, having index preceding to the start of valid parentheses will give us actual length of the valid parentheses,\\ninstead of us having to add 1 to it everytime.\\'\\n\\n3. i = 2          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [-1, 1]   |   MAX = 2.\\n\\n4. i = 3          |   s[i] = \\')\\'        =>     case-2.1: pop. After pop, stack is not empty so update MAX.\\nstack : [-1]      |   MAX = max(2, 3 - (-1)) = 4.\\n\\n5. i = 4          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nThis denotes any valid parentheses from now will start from next index and previous valid parentheses cant be extended further.\\nstack : [4]       |   MAX = 4.\\n\\n6. i = 5          |   s[i] = \\'(\\'        =>     case-1: push current index into stack\\nstack : [4, 5]    |   MAX = 4.\\n\\n7. i = 6          |   s[i] = \\')\\'        =>     case-2.2: pop. After pop, stack is empty, so push current index into stack.\\nstack : [4]       |   MAX = max(4, 6 - 4) = 4.\\n```\n```\\nint longestValidParentheses(string s) {\\n\\tint MAX = 0;  // denotes length of maximum valid parentheses\\n\\tstack<int> stk;\\n\\tstk.push(-1); // bottom of stack will always hold index preceding to potential start of valid parentheses\\n\\tfor(int i = 0; i < size(s); i++)\\n\\t\\tif(s[i] == \\'(\\') stk.push(i);            \\n\\t\\telse{                \\n\\t\\t\\tstk.pop();\\n\\t\\t\\tif(stk.empty()) stk.push(i);\\n\\t\\t\\telse MAX = max(MAX, i - stk.top());\\n\\t\\t}        \\n\\treturn MAX;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139905,
                "title": "longest-valid-parentheses-simple-code-easy-to-understand-explained",
                "content": "There are different approaches to solve this problem.\\n**Approach -1: Using Stacks** -\\nThe main idea is pretty straight forward, **we only update the result (res) when we find a valid paranthesis.**\\n-> If we find a valid pair. We pop this pair and check gap between the current and previous invalid and update the res.\\n```\\nFor example: s= \"())(())\", stack= [-1 ], res =0, here the answer must be 4, the longest valid paranthesis is from index 3 to 6. So, lets dry run this example.\\n    ->index 0 :  s[i] == \\'(\\'   push into stack,  //stack=[-1,0], res=0\\n    ->index 1 :  s[i] == \\')\\'   we pop it out and see what\\'s before \"(\". In this example it\\'s -1. So the gap is \"current_index - (-1) = 2\"  // res = 2, stack = [-1]\\n    ->index 2 :  s[i] == \\')\\'   we pop -1 the stack, here stack is empty, i.e, it is not a valid pair, so we push current index into stack      //res=2, stack = [2]\\n    ->index-3 :  s[i] == \\'(\\'  we push into stack. // res =2, stack = [2,3]\\n    ->index-4 :  s[i] == \\'(\\'  we push into stack. //res =2, stack = [2,3,4]\\n    ->index-5 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 3 = 2\"     //res =2, stack = [2,3]\\n    ->index-6 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 2 =4\"   //res = max(res,4 ) = 4, stack = [2]\\n```\\nHere we intially pushed \\'-1\\' to stack to cover all edge cases.\\nHope this example helps in understanding the logic. Go through the code for better idea.\\n\\n```\\nint longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int res =0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')  st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else res = max(res,i-st.top());\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n\\n**Approach-2: Dynamic programming**:\\nThe main idea is for every index of our DP array, dp[i], it stores the longest length of valid parentheses which is end at i, and the logic is :\\n```\\n\\n-> If s[i] is \\'(\\',  dp[i] = 0,because any string end with \\'(\\' cannot be a valid paranthesis.\\n-> else if s[i] is \\')\\', we have two conditions,\\n  \\t\\t -> s[i-1] is \\'(\\', dp[i] = dp[i-2] + 2\\n         -> s[i-1] is \\')\\' and s[i-dp[i-1]-1] == \\'(\\', dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n```\\nBasically, we are finding the longest valid paranthesis ending at `index i`.\\n\\n```\\nint longestValidParentheses(string s) {\\n        if(s.length() <= 1) return 0;\\n        int res = 0;\\n        vector<int> dp(s.length(),0);\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i] == \\')\\' && i-dp[i-1]-1 >= 0 && s[i-dp[i-1]-1] == \\'(\\'){\\n                if(i-dp[i-1]-2 >=0) \\n                    dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2];\\n                else \\n                    dp[i] = dp[i-1] + 2;\\n                res = max(dp[i],res);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Do Upvote if you like the explanation and find it helpful!!!**\\n\\nAny other ways to solve this problems ?? Thoughts?? Comment down below !!\\n\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nFor example: s= \"())(())\", stack= [-1 ], res =0, here the answer must be 4, the longest valid paranthesis is from index 3 to 6. So, lets dry run this example.\\n    ->index 0 :  s[i] == \\'(\\'   push into stack,  //stack=[-1,0], res=0\\n    ->index 1 :  s[i] == \\')\\'   we pop it out and see what\\'s before \"(\". In this example it\\'s -1. So the gap is \"current_index - (-1) = 2\"  // res = 2, stack = [-1]\\n    ->index 2 :  s[i] == \\')\\'   we pop -1 the stack, here stack is empty, i.e, it is not a valid pair, so we push current index into stack      //res=2, stack = [2]\\n    ->index-3 :  s[i] == \\'(\\'  we push into stack. // res =2, stack = [2,3]\\n    ->index-4 :  s[i] == \\'(\\'  we push into stack. //res =2, stack = [2,3,4]\\n    ->index-5 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 3 = 2\"     //res =2, stack = [2,3]\\n    ->index-6 :  s[i] == \\')\\'  we pop the stack, update the res, gap = \"current index - 2 =4\"   //res = max(res,4 ) = 4, stack = [2]\\n```\n```\\nint longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int res =0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\')  st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else res = max(res,i-st.top());\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n\\n-> If s[i] is \\'(\\',  dp[i] = 0,because any string end with \\'(\\' cannot be a valid paranthesis.\\n-> else if s[i] is \\')\\', we have two conditions,\\n  \\t\\t -> s[i-1] is \\'(\\', dp[i] = dp[i-2] + 2\\n         -> s[i-1] is \\')\\' and s[i-dp[i-1]-1] == \\'(\\', dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2]\\n```\n```\\nint longestValidParentheses(string s) {\\n        if(s.length() <= 1) return 0;\\n        int res = 0;\\n        vector<int> dp(s.length(),0);\\n        for(int i=1; i<s.length(); i++){\\n            if(s[i] == \\')\\' && i-dp[i-1]-1 >= 0 && s[i-dp[i-1]-1] == \\'(\\'){\\n                if(i-dp[i-1]-2 >=0) \\n                    dp[i] = dp[i-1] + 2 + dp[i-dp[i-1]-2];\\n                else \\n                    dp[i] = dp[i-1] + 2;\\n                res = max(dp[i],res);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14296,
                "title": "my-o-n-time-c-solutions-stack-based-and-dp-based",
                "content": " - DP based solution, O(N) time O(N) space\\n\\nWe can do DP: dp[i] saves the longest valid parentheses that ends at (i-1). To calculate the longest valid parentheses that ends at i (i.e. calculate dp[i+1]), we only need to consider the following cases\\n1) case 1: s[i] = '(', then no valid parentheses that ends at i, so dp[i+1]=0 (i.e. do nothing)\\n2) case 2  s[i]= ')' , then we have to check if this ')' can find a matched '(' just before the longest parentheses ending at i-1 (i.e. check if s[i-dp[i]-1] = '('); \\nif yes, then s[i] extends the longest parentheses ending at i-1 to [i-dp[i]-1, i] and it now connects to the longest parentheses ending at i-dp[i]-2, so the DP update equation becomes dp[i+1] =dp[i]+2+dp[i-dp[i]-1]  \\nif no, then no valid parentheses ending at i, so dp[i+1] =0 (do nothing)\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int len = s.size(), i, res=0, left;\\n            vector<int> dp(len+1,0);\\n            \\n            for(i=1;i<len;++i)\\n            {\\n                if(s[i]==')')\\n                {\\n                    left = i-dp[i]-1;\\n                    if(left>=0 && s[left]=='(') dp[i+1] = dp[i]+2+dp[left];\\n                    res = max(res, dp[i+1]);\\n                }\\n            }\\n            return res;\\n            \\n        }\\n    };\\n\\n 2)  Stack based solution, O(N) time and O(N) space\\nScan s from left to right and use a stack to save all the unmatched '(' or ')' indices. If s[i] ='(', then push i to the stack; if s[i] =')', check if it can match the last unmatched char (i.e. check if s[stk.top()]='('), if so, remove tthe top entry and update res if the current parentheses [stk.top(), i] is longer than res.\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int len = s.size(), maxL=0, i;\\n            stack<int> stk;\\n            stk.push(-1);\\n            for(i=0; i<len;++i)\\n            {\\n                if(s[i]==')' && stk.top()>=0 && s[stk.top()]=='(')\\n                { // if s[i] is ')' and matches the last unmatched  char  \\n                    stk.pop(); // remove the last unmatched char\\n                    maxL = max(maxL, i-stk.top()); // update res\\n                }\\n                else stk.push(i);\\n            }\\n            return maxL;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int len = s.size(), i, res=0, left;\\n            vector<int> dp(len+1,0);\\n            \\n            for(i=1;i<len;++i)\\n            {\\n                if(s[i]==')')\\n                {\\n                    left = i-dp[i]-1;\\n                    if(left>=0 && s[left]=='(') dp[i+1] = dp[i]+2+dp[left];\\n                    res = max(res, dp[i+1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1038932,
                "title": "c-10-lines-easy-stack-solution-o-n-tc-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stck;\\n        stck.push(-1);\\n        int res=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s[i]==\\'(\\') stck.push(i);\\n            \\n            else{\\n                if(!stck.empty())stck.pop();\\n                \\n                if(!stck.empty()){\\n                    res=max(res,i-stck.top());\\n                }\\n                else stck.push(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>stck;\\n        stck.push(-1);\\n        int res=0;\\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            if(s[i]==\\'(\\') stck.push(i);\\n            \\n            else{\\n                if(!stck.empty())stck.pop();\\n                \\n                if(!stck.empty()){\\n                    res=max(res,i-stck.top());\\n                }\\n                else stck.push(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14377,
                "title": "o-n-dp-solution-in-c",
                "content": "      \\n       int longestValidParentheses(string s) {\\n            int cnt = 0; // count of \"(\"\\n            vector<int> dp(s.size()+1, 0);\\n            \\n            for (size_t i = 1; i <= s.size(); i++) {\\n                if (s[i-1] == '(') {\\n                    cnt++;\\n                } else {\\n                    if (cnt > 0) {  // there exists an unclosed \"(\" to match \")\"\\n                        cnt--;\\n                        dp[i] = 2;\\n                        if (s[i-2] == ')')  // add the length of previous closed \")\" neighbor\\n                            dp[i] += dp[i-1];                        \\n                        dp[i] += dp[i-dp[i]]; // add the length of previous valid parentheses\\n                    }\\n                }\\n            }\\n            \\n            return *max_element(dp.begin(), dp.end());\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "      \\n       int longestValidParentheses(string s) {\\n            int cnt = 0; // count of \"(\"\\n            vector<int> dp(s.size()+1, 0);\\n            \\n            for (size_t i = 1; i <= s.size(); i++) {\\n                if (s[i-1] == '(') {\\n                    cnt++;\\n                } else {\\n                    if (cnt > 0) {  // there exists an unclosed \"(\" to match \")\"\\n                        cnt--;\\n                        dp[i] = 2;\\n                        if (s[i-2] == ')')  // add the length of previous closed \")\" neighbor\\n                            dp[i] += dp[i-1];                        \\n                        dp[i] += dp[i-dp[i]]; // add the length of previous valid parentheses\\n                    }\\n                }\\n            }\\n            \\n            return *max_element(dp.begin(), dp.end());\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14271,
                "title": "java-o-n-very-easy-to-understand",
                "content": "    public int longestValidParentheses(String s) {\\n        int max=0,start=0;\\n        Stack<Integer> stack=new Stack();\\n        int[] a=new int[s.length()];\\n        char[] c=s.toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]=='(') stack.push(i);\\n            else if(!stack.empty()){\\n                start=stack.pop();\\n                a[i]=i-start+1;\\n                if(start>1) a[i]+=a[start-1];\\n                max=Math.max(max,a[i]);\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    public int longestValidParentheses(String s) {\\n        int max=0,start=0;\\n        Stack<Integer> stack=new Stack();\\n        int[] a=new int[s.length()];\\n        char[] c=s.toCharArray();\\n        for(int i=0;i<c.length;i++){\\n            if(c[i]=='(') stack.push(i);\\n            else if(!stack.empty()){\\n                start=stack.pop();\\n                a[i]=i-start+1;\\n                if(start>1) a[i]+=a[start-1];\\n                max=Math.max(max,a[i]);\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14298,
                "title": "java-stack-solution-o-n",
                "content": "    public class Solution {\\n    public int longestValidParentheses(String s) {\\n        if(s == null || s.length() <= 1){\\n            return 0;\\n        }\\n        int start = -1;\\n        int res = 0;\\n        LinkedList<Integer> stack = new LinkedList<Integer>();\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == '('){\\n                stack.push(i);\\n            }else{\\n                if(!stack.isEmpty()){\\n                    stack.pop();\\n                    if(!stack.isEmpty()){\\n                        res = Math.max(res,i-stack.peek());\\n                    }else{\\n                        res = Math.max(res,i-start);\\n                    }\\n                }else{\\n                    start = i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestValidParentheses(String s) {\\n        if(s == null || s.length() <= 1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2068304,
                "title": "c-using-left-and-right-parentheses-count",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,maxlen=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*left);\\n\\t\\t//when we traverse from left to right ,if right becomes more than left then we enter into invalid state\\n            else if(right>=left){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        left=0,right=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*right);\\n\\t\\t//when we traverse from right to left ,if left becomes more than right we enter into inavild state\\n            else if(left>=right){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        return maxlen;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,maxlen=0;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*left);\\n\\t\\t//when we traverse from left to right ,if right becomes more than left then we enter into invalid state\\n            else if(right>=left){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        left=0,right=0;\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left==right)\\n                maxlen=max(maxlen,2*right);\\n\\t\\t//when we traverse from right to left ,if left becomes more than right we enter into inavild state\\n            else if(left>=right){\\n                left=0;\\n                right=0;\\n            }\\n        }\\n        return maxlen;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690340,
                "title": "python-c-java-beginner-level-simple-short-solution-easytounderstand",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q32. Longest Valid Parentheses***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l,stack=0,[-1]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    l=max(l,i-stack[-1])\\n        return l;\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        int maxLen = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                stack.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {    \\n                stack.pop();\\n                if(stack.empty())\\n                    stack.push(i);\\n                else\\n                    maxLen = Math.max(maxLen, i - stack.peek());     \\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n    int n = s.length(),len =0,maxlen =0;\\n    stack<int> st;\\n    st.push(-1);\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s[i] == \\'(\\')\\n            st.push(i);\\n        if(s[i] == \\')\\')\\n        {\\n            st.pop();\\n            if(st.empty())\\n                st.push(i);\\n            len = i - st.top();\\n            maxlen = max(maxlen,len);\\n        }\\n    }\\n    return maxlen;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l,stack=0,[-1]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    l=max(l,i-stack[-1])\\n        return l;\\n```\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        int maxLen = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                stack.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {    \\n                stack.pop();\\n                if(stack.empty())\\n                    stack.push(i);\\n                else\\n                    maxLen = Math.max(maxLen, i - stack.peek());     \\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n    int n = s.length(),len =0,maxlen =0;\\n    stack<int> st;\\n    st.push(-1);\\n    for(int i =0;i<n;i++)\\n    {\\n        if(s[i] == \\'(\\')\\n            st.push(i);\\n        if(s[i] == \\')\\')\\n        {\\n            st.pop();\\n            if(st.empty())\\n                st.push(i);\\n            len = i - st.top();\\n            maxlen = max(maxlen,len);\\n        }\\n    }\\n    return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069052,
                "title": "c-0-ms-two-pointer-very-easy",
                "content": "*Left*   : keeps track of  (\\n*Right* : keeps track of )\\n\\nFor First Pass if *Right>Left* happens then they are re-initialized to zero as  \\')\\' can\\'t come before \\'(\\'\\nSimilary,For Second Pass *Left>Right* happens then they are re-initialized to zero as \\'(\\' should come before \\')\\'\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        \\n        int n=s.size();\\n        int ans=0;\\n        int left=0,right=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(s[i]==\\')\\')\\n           {\\n               right++;\\n           }\\n           else if(s[i]==\\'(\\')\\n            {\\n                left++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(right>left)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        left=right=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(s[i]==\\'(\\')\\n           {\\n               left++;\\n           }\\n            else if(s[i]==\\')\\')\\n            {\\n                right++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(left>right)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        \\n        int n=s.size();\\n        int ans=0;\\n        int left=0,right=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(s[i]==\\')\\')\\n           {\\n               right++;\\n           }\\n           else if(s[i]==\\'(\\')\\n            {\\n                left++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(right>left)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        left=right=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n           if(s[i]==\\'(\\')\\n           {\\n               left++;\\n           }\\n            else if(s[i]==\\')\\')\\n            {\\n                right++;\\n            }\\n            if(left==right)\\n            {\\n                ans=max(left+right,ans);\\n            }\\n            else if(left>right)\\n            {\\n                left=right=0;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902507,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n\\t\\tvar string = Array(s)\\n\\n\\n\\t\\tfunc reverse(_ string: [Character]) -> [Character] {\\n\\t\\t\\tvar res: [Character] = []\\n\\t\\t\\tfor c in string.reversed() { res.append(c == \"(\" ? \")\" : \"(\") }\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tfunc _max(_ string: [Character]) -> Int {\\n\\t\\t\\tvar max = 0\\n\\t\\t\\tvar tmp = 0\\n\\t\\t\\tvar lastContinuousIndex = 0\\n\\t\\t\\tvar stack: [Character] = []\\n\\n\\t\\t\\tfor (i, c) in string.enumerated() {\\n\\t\\t\\t\\tif c == \"(\" {\\n\\t\\t\\t\\t\\tif stack.count == 0 { lastContinuousIndex = i }\\n\\t\\t\\t\\t\\tstack.append(c)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlet index = stack.count - 1\\n\\t\\t\\t\\t\\tif index >= 0 && stack[index] == \"(\" {\\n\\t\\t\\t\\t\\t\\tstack.remove(at: index)\\n\\t\\t\\t\\t\\t\\ttmp += 2\\n\\t\\t\\t\\t\\t\\tmax = tmp > max ? tmp : max  \\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tstack.removeAll()\\n\\t\\t\\t\\t\\t\\ttmp = 0\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (stack.count == 0) {\\n\\t\\t\\t\\treturn max\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet a = _max(Array(string[0..<lastContinuousIndex]))\\n\\t\\t\\t\\tlet b =  _max(reverse(Array(string[lastContinuousIndex..<string.count])))\\n\\t\\t\\t\\treturn a > b ? a : b\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn _max(string)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestValidParentheses(_ s: String) -> Int {\\n\\t\\tvar string = Array(s)\\n\\n\\n\\t\\tfunc reverse(_ string: [Character]) -> [Character] {\\n\\t\\t\\tvar res: [Character] = []\\n\\t\\t\\tfor c in string.reversed() { res.append(c == \"(\" ? \")\" : \"(\") }\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\t\\n\\n\\t\\tfunc _max(_ string: [Character]) -> Int {\\n\\t\\t\\tvar max = 0\\n\\t\\t\\tvar tmp = 0\\n\\t\\t\\tvar lastContinuousIndex = 0\\n\\t\\t\\tvar stack: [Character] = []\\n\\n\\t\\t\\tfor (i, c) in string.enumerated() {\\n\\t\\t\\t\\tif c == \"(\" {\\n\\t\\t\\t\\t\\tif stack.count == 0 { lastContinuousIndex = i }\\n\\t\\t\\t\\t\\tstack.append(c)\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlet index = stack.count - 1\\n\\t\\t\\t\\t\\tif index >= 0 && stack[index] == \"(\" {\\n\\t\\t\\t\\t\\t\\tstack.remove(at: index)\\n\\t\\t\\t\\t\\t\\ttmp += 2\\n\\t\\t\\t\\t\\t\\tmax = tmp > max ? tmp : max  \\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tstack.removeAll()\\n\\t\\t\\t\\t\\t\\ttmp = 0\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (stack.count == 0) {\\n\\t\\t\\t\\treturn max\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet a = _max(Array(string[0..<lastContinuousIndex]))\\n\\t\\t\\t\\tlet b =  _max(reverse(Array(string[lastContinuousIndex..<string.count])))\\n\\t\\t\\t\\treturn a > b ? a : b\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn _max(string)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176332,
                "title": "python-dp-stack-very-easy-to-understand-beats-99-52",
                "content": "Simply iterate through the string.\\nIf `s[i] == \"(\"` simply store the position in the stack, and `dp[i] = 0` (because it does not signify the end of any valid parentheses. The position in stack will be used to check if the string made is completed or not later.\\nNow, if `s[i] == \")\"` see if the length of stack > 0, if it is not, `dp[i] = 0` because no valid parentheses end there. if length > 0, then pop the top of the stack, that is the position of the `\"(\"` that completes the current `\")\"`. \\nNow, just check if there was any valid parentheses ending just before that position. Because, if there was, this should be added to our length of the valid parentheses.\\neg:\\n`()(())`\\n`dp = [0, 2, 0, 0, 2, 6]`\\nHere, for the last `)` at position 5, it gets completed by the `(` at position 2, now check position 1, if there is a valid parentheses ending there, add its length to the current length.\\n\\nThe code is below:\\n\\n```\\n def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if not s:\\n            return 0\\n        \\n        stack = []\\n        dp = [0]*len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                stack.append(i)\\n                dp[i] = 0\\n            else: #we have a closing brace\\n                if len(stack) == 0:\\n                    dp[i] = 0\\n                else:\\n                    pos = stack.pop()\\n                    dp[i] = dp[pos-1]+i-pos+1\\n        return max(dp)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        if not s:\\n            return 0\\n        \\n        stack = []\\n        dp = [0]*len(s)\\n        \\n        for i in range(len(s)):\\n            if s[i] == \"(\":\\n                stack.append(i)\\n                dp[i] = 0\\n            else: #we have a closing brace\\n                if len(stack) == 0:\\n                    dp[i] = 0\\n                else:\\n                    pos = stack.pop()\\n                    dp[i] = dp[pos-1]+i-pos+1\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3998060,
                "title": "c-using-stack",
                "content": "# Approach\\nIn My solution, trash indicates breakpoint or we can say that when we encounter \\')\\' but we don\\'t have any \\'(\\' in stack to fulfil it , we can say next longer parentheses will start after this index and we need to keep track it since we are not inserting this into stack, \\nand for rest if stack is not empty we can easily say (index-st.top());\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N) due to stack.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        \\n        stack<int>st;\\n        int trash = 0;\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            if(s[i-1]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                if(st.empty()){\\n                    trash= i;\\n                    continue;\\n                }\\n                else{\\n                    st.pop();\\n                }\\n                if(st.empty()){\\n                    ans= max(ans, (int)(i-trash));\\n                }\\n                else{\\n                    ans= max(ans, (int)(i-st.top()));\\n                } \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        \\n        stack<int>st;\\n        int trash = 0;\\n        int ans = 0;\\n        for(int i=1; i<=n; i++){\\n            if(s[i-1]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                if(st.empty()){\\n                    trash= i;\\n                    continue;\\n                }\\n                else{\\n                    st.pop();\\n                }\\n                if(st.empty()){\\n                    ans= max(ans, (int)(i-trash));\\n                }\\n                else{\\n                    ans= max(ans, (int)(i-st.top()));\\n                } \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950489,
                "title": "simple-java-solution-with-o-n",
                "content": "\\n```\\nclass Solution {\\n    // TC : O(n)\\n    // SC : O(n)\\n    public int longestValidParentheses(String s) {\\n        if(s==null || s.length()<2){\\n            return 0;\\n        }\\n\\n        Stack<Integer> st =new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                st.push(i);\\n            } else{\\n\\n                // current closing bracket\\n\\n                if(!st.empty() && s.charAt(st.peek()) == \\'(\\'){\\n                    // balanced case\\n                    st.pop();\\n                } else {\\n                    // unbalanced case\\n                    st.push(i);\\n                }\\n            }\\n        }\\n     \\n        int maxLen = 0;\\n        int endTerminal = s.length();\\n\\n        while(!st.empty()){\\n            int startTerminal  = st.pop();\\n            maxLen = Math.max(maxLen, endTerminal - startTerminal -1);\\n            endTerminal = startTerminal;\\n        }\\n\\n        return Math.max(endTerminal, maxLen);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // TC : O(n)\\n    // SC : O(n)\\n    public int longestValidParentheses(String s) {\\n        if(s==null || s.length()<2){\\n            return 0;\\n        }\\n\\n        Stack<Integer> st =new Stack<>();\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i) == \\'(\\'){\\n                st.push(i);\\n            } else{\\n\\n                // current closing bracket\\n\\n                if(!st.empty() && s.charAt(st.peek()) == \\'(\\'){\\n                    // balanced case\\n                    st.pop();\\n                } else {\\n                    // unbalanced case\\n                    st.push(i);\\n                }\\n            }\\n        }\\n     \\n        int maxLen = 0;\\n        int endTerminal = s.length();\\n\\n        while(!st.empty()){\\n            int startTerminal  = st.pop();\\n            maxLen = Math.max(maxLen, endTerminal - startTerminal -1);\\n            endTerminal = startTerminal;\\n        }\\n\\n        return Math.max(endTerminal, maxLen);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14227,
                "title": "why-people-give-conclusion-that-this-cannot-be-done-with-o-1-space-my-ac-solution-o-n-run-time-o-1-space",
                "content": "    public class Solution {\\n        public int longestValidParentheses(String s) {\\n          return ltr(s, 0, s.length());\\n        }\\n    \\n        public int ltr(String s, int start, int end) {\\n          int left = start;\\n          int openLeft = 0;\\n          int max = 0;\\n          for(int i = start; i < end; i++) {\\n            if(s.charAt(i) == '(')\\n              openLeft++;\\n            else\\n              openLeft--;\\n            if(openLeft < 0) {\\n              int length = i - left;\\n              if(length > max)\\n                max = length;\\n              left = i + 1;\\n              openLeft = 0;\\n            }\\n          }\\n          if(openLeft == 0) {\\n            int length = end - left;\\n            if(length > max)\\n              max = length;\\n          } {\\n            int length = rtl(s, left, end);\\n            if(length > max)\\n              max = length;\\n          }\\n          return max;\\n        }\\n\\n        public int rtl(String s, int start, int end) {\\n          int right = end;\\n          int openRight = 0;\\n          int max = 0;\\n          for(int i = end - 1; i >= start; i--) {\\n            if(s.charAt(i) == ')')\\n              openRight++;\\n            else\\n              openRight--;\\n            if(openRight < 0) {\\n              int length = right - (i + 1);\\n              if(length > max)\\n                max = length;\\n              right = i;\\n              openRight = 0;\\n            }\\n          }\\n          if(openRight == 0) {\\n            int length = right - start;\\n            if(length > max)\\n              max = length;\\n          }\\n          return max;\\n        }\\n      }\\n\\nI am pretty sure the code can be shorten to maybe half of the current size...... but why bother...\\nThe idea is very simple, 2 iteration at most. First time from left to right, second time from right to left.\\n\\nThe second iteration is only needed if the first iteration has ends with unclosed left bracket.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n          return ltr(s, 0, s.length());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 14357,
                "title": "o-n-one-pass-solution-without-stacks",
                "content": "Basically it is a two pass solution, but I can combine them in one loop.\\n\\nFirst, scan from left to right while checking the balance. Second, scan from right to left in the same way. So no stack is needed.\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int result = 0;\\n            {\\n                int left = 0;\\n                int right = 0;\\n                for (int i = 0; i < s.length(); i++) {\\n                    switch (s[i]) {\\n                    case '(': left++; break;\\n                    case ')': right++; break;\\n                    default: left = right = 0; continue;\\n                    }\\n                    if (left == right && left + right > result) result = left + right;\\n                    if (right > left) left = right = 0;\\n                }\\n            }\\n            {\\n                int left = 0;\\n                int right = 0;\\n                for (int i = s.length(); i > 0; i--) {\\n                    switch (s[i-1]) {\\n                    case '(': left++; break;\\n                    case ')': right++; break;\\n                    default: left = right = 0; continue;\\n                    }\\n                    if (left == right && left + right > result) result = left + right;\\n                    if (left > right) left = right = 0;\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\nCombination:\\n\\n    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int result = 0;\\n            int ll = 0, lr = 0, li = 0;  // left paren sum, right paren sum, left index\\n            int rl = 0, rr = 0, ri = s.length();  // left paren sum, right paren sum, right index\\n            while (li < s.length() && ri > 0) {\\n                switch (s[li]) {\\n                case '(': ll++; break;\\n                case ')': lr++; break;\\n                default: ll = lr = 0;\\n                }\\n                switch (s[ri-1]) {\\n                case '(': rl++; break;\\n                case ')': rr++; break;\\n                default: rl = rr = 0;\\n                }\\n                if (ll == lr && ll + lr > result) result = ll + lr;\\n                if (rl == rr && rl + rr > result) result = rl + rr;\\n                if (ll < lr) ll = lr = 0;\\n                if (rl > rr) rl = rr = 0;\\n                li++; ri--;\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            int result = 0;\\n            {\\n                int left = 0;\\n                int right = 0;\\n                for (int i = 0; i < s.length(); i++) {\\n                    switch (s[i]) {\\n                    case '(': left++; break;\\n                    case ')': right++; break;\\n                    default: left = right = 0; continue;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1149315,
                "title": "java-two-pointer-100-faster-constant-space",
                "content": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        int open=0;\\n        int close=0;\\n        int maxLen=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close>open){\\n                open=close=0;\\n            }\\n        }\\n        \\n        open=close=0;\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close<open){\\n                open=close=0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        int open=0;\\n        int close=0;\\n        int maxLen=0;\\n        \\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close>open){\\n                open=close=0;\\n            }\\n        }\\n        \\n        open=close=0;\\n        \\n        for(int i=s.length()-1;i>=0;i--){\\n            char c=s.charAt(i);\\n            \\n            if(c==\\'(\\') open++;\\n            else close++;\\n            \\n            if(open==close){\\n                maxLen=Math.max(maxLen,open+close);\\n            }\\n            else if(close<open){\\n                open=close=0;\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050101,
                "title": "python-using-stacks-o-n-beats-97",
                "content": "Simple stack implementation in Python.\\n\\n```\\ndef longestValidParentheses(self, s: str) -> int:\\n        stack = [0,] # Initial value to handle \"()\"\\n        max_parenthesis = 0\\n        for bracket in s:\\n            if bracket == \\'(\\':\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2  # Add 2 when a \")\" matches \"(\"\\n                    max_parenthesis = max(max_parenthesis, stack[-1]) # Keep track of longest valid sequence\\n                else:\\n                    stack = [0]\\n\\n        return max_parenthesis\\n\\t",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "Simple stack implementation in Python.\\n\\n```\\ndef longestValidParentheses(self, s: str) -> int:\\n        stack = [0,] # Initial value to handle \"()\"\\n        max_parenthesis = 0\\n        for bracket in s:\\n            if bracket == \\'(\\':\\n                stack.append(0)\\n            else:\\n                if len(stack) > 1:\\n                    val = stack.pop()\\n                    stack[-1] += val + 2  # Add 2 when a \")\" matches \"(\"\\n                    max_parenthesis = max(max_parenthesis, stack[-1]) # Keep track of longest valid sequence\\n                else:\\n                    stack = [0]\\n\\n        return max_parenthesis\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 752095,
                "title": "c-easy-solution-with-stack-and-dynamic-programming-with-explanation",
                "content": "We can solve this problem using stack. We will push -1 into the stack, so that whenever the stack becomes empty then we are sure that it is not valid at that point. So, whenever we have \\')\\' then we pop the element from the stack and if it is empty then the string ending at that index is not valid and we need to push the index so to find next valid parenthesis length. Let\\'s do a dry run of the below code by using the string \"()(()\".\\n\\nFirst, we push -1 so initially stack element is -1.\\nAt i=0, we have s[i]=\\'(\\' , we push the index 0.\\nAt i=1, we have s[i]=\\')\\', we pop the element from the stack so the current valid length till index 1 becomes (i-stack.top()) i.e. (1-(-1))=2.\\nAt i=2, we have s[i]=\\')\\' , we pop the element from the stack and note that stack now becomes empty so any new valid string would start after this index only. Thus, we push the index i=2 in the stack.\\n\\nAt i=3, we have s[i]=\\'(\\', we push the index 3 in the stack.\\nAt i=4, we have s[i]=\\')\\', we pop the element and since the stack is still not empty, we find the length valid till this index as (4-2)=2.\\n\\nThus, the longest valid parenthesis length is 2 for this example.\\nThe time complexity of this approach is O(n) and space complexity is also O(n).\\n\\nPlease let me know me in the comment section if you need further clarification on how this approach works.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> p;\\n        int maxlength=0;\\n        p.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                p.push(i);\\n            }\\n            else{\\n                p.pop();\\n                if(p.empty())\\n                    p.push(i);\\n                else\\n                    maxlength=max(maxlength,i-p.top());\\n            }\\n        }\\n        return maxlength;\\n    }\\n};\\n```\\n\\nWe can also use dynamic programming to solve this problem. We can find the length of valid parenthesis till each index.  For any string ending with \\'(\\' the length would be zero since valid parenthesis cannot end with \\'(\\'. \\n\\nIf the string ends with \\')\\', then there will be two cases :\\n\\n1. If the previous character is \\'(\\' then the length of valid parenthesis ending at this index would be dp[i-2] + 2.\\n2.  We need to check if the character at (i-dp[i-1]-1) =\\'(\\' if it is the length of valid parenthesis ending at this point is dp[i-1] + (i>=2 ? dp[i-dp[i-1]-2] :0) +2.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int maxlength=0;\\n       vector<int> dp(s.length(),0);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(s[i]==\\'(\\')\\n                    dp[i]=(i>=2 ? dp[i-2] : 0)+2;\\n                else if(i-dp[i-1]-1>=0 && s[i-dp[i-1]-1]==\\'(\\')\\n                    dp[i]=dp[i-1]+((i-dp[i-1])>=2 ? dp[i-dp[i-1]-2] :0)+2;\\n            }\\n            maxlength=max(maxlength,dp[i]);\\n        }\\n        return maxlength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> p;\\n        int maxlength=0;\\n        p.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                p.push(i);\\n            }\\n            else{\\n                p.pop();\\n                if(p.empty())\\n                    p.push(i);\\n                else\\n                    maxlength=max(maxlength,i-p.top());\\n            }\\n        }\\n        return maxlength;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int maxlength=0;\\n       vector<int> dp(s.length(),0);\\n        for(int i=1;i<s.length();i++)\\n        {\\n            if(s[i]==\\')\\')\\n            {\\n                if(s[i]==\\'(\\')\\n                    dp[i]=(i>=2 ? dp[i-2] : 0)+2;\\n                else if(i-dp[i-1]-1>=0 && s[i-dp[i-1]-1]==\\'(\\')\\n                    dp[i]=dp[i-1]+((i-dp[i-1])>=2 ? dp[i-dp[i-1]-2] :0)+2;\\n            }\\n            maxlength=max(maxlength,dp[i]);\\n        }\\n        return maxlength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 309306,
                "title": "recursive-c-solution-with-memoization-o-n",
                "content": "/*\\nT : O(n)\\nS : O(n)\\nIdea : try to break in smaller sub problem .\\ncase 1: string ends at \"()\"\\nlongestParenEnding(0, i) = longestParenEnding(0, i - 2) + 2\\n\\ncase 2: string ends with \"))\" for example \"()(())\"\\nlongestParenEnding(0, i) = \\n\\ncase 3: string ends with \"(\"\\nlongestParenEnding(0, i) = 0\\n*/\\n```\\nclass Solution {\\n    int lonParen(int i, string & s, vector<int> & memo){\\n        if(i <= 0){\\n            return 0;\\n        }\\n        \\n        if(memo[i] != -1){\\n            return memo[i];\\n        }\\n        \\n        if(s[i] == \\'(\\'){\\n            memo[i] = 0;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\'(\\'){\\n            memo[i] = lonParen(i - 2, s, memo) + 2;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\')\\'){\\n            int len = lonParen(i - 1, s, memo);\\n            if(i - 1 - len >= 0 && s[i - 1 - len] == \\'(\\'){\\n                memo[i] = len + 2 + lonParen(i - len - 2, s, memo);\\n            }\\n            else{\\n                memo[i] = 0;\\n            }\\n        }\\n        return memo[i];\\n    }\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.size(), maxLen = 0;\\n        vector<int> memo(n, -1);\\n        for(int i = 0; i < n; i++){\\n            maxLen = max(maxLen, lonParen(i, s, memo));\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int lonParen(int i, string & s, vector<int> & memo){\\n        if(i <= 0){\\n            return 0;\\n        }\\n        \\n        if(memo[i] != -1){\\n            return memo[i];\\n        }\\n        \\n        if(s[i] == \\'(\\'){\\n            memo[i] = 0;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\'(\\'){\\n            memo[i] = lonParen(i - 2, s, memo) + 2;\\n        }\\n        else if(s[i] == \\')\\' && s[i - 1] == \\')\\'){\\n            int len = lonParen(i - 1, s, memo);\\n            if(i - 1 - len >= 0 && s[i - 1 - len] == \\'(\\'){\\n                memo[i] = len + 2 + lonParen(i - len - 2, s, memo);\\n            }\\n            else{\\n                memo[i] = 0;\\n            }\\n        }\\n        return memo[i];\\n    }\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.size(), maxLen = 0;\\n        vector<int> memo(n, -1);\\n        for(int i = 0; i < n; i++){\\n            maxLen = max(maxLen, lonParen(i, s, memo));\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14303,
                "title": "o-1-space-python-solution-no-stack",
                "content": "scan s from left to right and then from right to left. The variable names are quite self-explaining. \\n\\n    def longestValidParentheses(self, s):\\n        return max(self.helper(s,'('), self.helper(s[::-1],')'))\\n    \\n    def helper(self, s, left):\\n        ans = 0\\n        maxendinghere = 0\\n        count = 0\\n        for c in s:\\n            if c == left:    #when scan s from left to right, left is '(', otherwise is ')'\\n                count += 1\\n                maxendinghere += 1\\n            else: \\n                count -= 1\\n                if count <0:\\n                    maxendinghere = 0\\n                    count = 0\\n                else:\\n                    maxendinghere += 1\\n                    if count == 0:\\n                        ans = max(ans, maxendinghere)\\n        return ans",
                "solutionTags": [],
                "code": "scan s from left to right and then from right to left. The variable names are quite self-explaining. \\n\\n    def longestValidParentheses(self, s):\\n        return max(self.helper(s,'('), self.helper(s[::-1],')'))\\n    \\n    def helper(self, s, left):\\n        ans = 0\\n        maxendinghere = 0\\n        count = 0\\n        for c in s:\\n            if c == left:    #when scan s from left to right, left is '(', otherwise is ')'\\n                count += 1\\n                maxendinghere += 1\\n            else: \\n                count -= 1\\n                if count <0:\\n                    maxendinghere = 0\\n                    count = 0\\n                else:\\n                    maxendinghere += 1\\n                    if count == 0:\\n                        ans = max(ans, maxendinghere)\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 14137,
                "title": "68-ms-fast-python-solution-beat-97-only-put-starting-index-in-stack-detailed-explaination",
                "content": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            result=0\\n            stk=[]\\n            lst=-1\\n            for i in xrange(len(s)):\\n                if s[i]=='(':\\n                    if lst!=-1:\\n                        stk.append(lst)\\n                        lst=-1\\n                    else:\\n                        stk.append(i)\\n                else:\\n                    if stk:\\n                        stt=stk.pop()\\n                        if i-stt+1>result:\\n                            result=i-stt+1\\n                        lst=stt\\n                    else:\\n                        lst=-1\\n            return result\\n\\nstk store the index of '('. <br>\\nwe intereate through the string. <br>\\nresult is the length of the longest unbroken bracket chain at that position, we update it when we iterate through the string. We initiate it to 0.<br>\\nlst is -1 or the starting index of the unbroken bracket chain we just extended with a matching ')', its initial value is -1, if we iterate to a '(' or a umatchable ')', we set lst to -1. So we are using lst for two purposes.<br>\\nEvery time we see a '(',  we push a index to the stack. if the lst is not -1 (means last time we just got a matching ')' and extended the current unbroken bracket chain and we set lst to the starting index of that chain), we push lst into the stack. If lst is -1, it means we are on index 0 or last character is not a match ')'. We push the index i into the stack. We set lst to -1 in either case.<br>\\nEvery time we see a ')' and the stack is not empty ( means it's a matching ')' ),we pop the stack. we calculate the length of the chain and update the result and set the lst to the popped index. If the stack is empty, it means that's a unmatchable ')', and we set lst to -1.<br>\\nA lot of times, we pop a index and push it right back like when we iterate to index 2 of string \"()()\"\\nIn the end of the interation we will have the length of the longest chain in the result variable\\n\\nLet me know if the explaination doesn't make sense or hard to understand. I will try my best to revise it.",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def longestValidParentheses(self, s):\\n            \"\"\"\\n            :type s: str\\n            :rtype: int\\n            \"\"\"\\n            result=0\\n            stk=[]\\n            lst=-1\\n            for i in xrange(len(s)):\\n                if s[i]=='(':\\n                    if lst!=-1:\\n                        stk.append(lst)\\n                        lst=-1\\n                    else:\\n                        stk.append(i)\\n                else:\\n                    if stk:\\n                        stt=stk.pop()\\n                        if i-stt+1>result:\\n                            result=i-stt+1\\n                        lst=stt\\n                    else:\\n                        lst=-1\\n            return result\\n\\nstk store the index of '('. <br>\\nwe intereate through the string. <br>\\nresult is the length of the longest unbroken bracket chain at that position, we update it when we iterate through the string. We initiate it to 0.<br>\\nlst is -1 or the starting index of the unbroken bracket chain we just extended with a matching ')', its initial value is -1, if we iterate to a '(' or a umatchable ')', we set lst to -1. So we are using lst for two purposes.<br>\\nEvery time we see a '(',  we push a index to the stack. if the lst is not -1 (means last time we just got a matching ')' and extended the current unbroken bracket chain and we set lst to the starting index of that chain), we push lst into the stack. If lst is -1, it means we are on index 0 or last character is not a match ')'. We push the index i into the stack. We set lst to -1 in either case.<br>\\nEvery time we see a ')' and the stack is not empty ( means it's a matching ')' ),we pop the stack. we calculate the length of the chain and update the result and set the lst to the popped index. If the stack is empty, it means that's a unmatchable ')', and we set lst to -1.<br>\\nA lot of times, we pop a index and push it right back like when we iterate to index 2 of string \"()()\"\\nIn the end of the interation we will have the length of the longest chain in the result variable\\n\\nLet me know if the explaination doesn't make sense or hard to understand. I will try my best to revise it.",
                "codeTag": "Java"
            },
            {
                "id": 2068590,
                "title": "c-short-and-simple-solution",
                "content": "Easy stack based problem.<br>\\nComplexities :\\n* **Time :** `O(n)`\\n* **Space :** `O(n)`\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n\\t    int maxVal = 0;\\n\\n    \\tstack<int> st;\\n\\t    st.push(-1);\\n\\n    \\tfor(int i = 0; i < s.size(); i++)\\n\\t    \\tif(s[i] == \\'(\\')\\n                st.push(i);\\n\\n    \\t\\telse {       \\n\\t    \\t\\tst.pop();\\n\\n\\t\\t    \\tif(st.empty())\\n                    st.push(i);\\n    \\t\\t\\telse\\n                    maxVal = max(maxVal, i - st.top());\\n    \\t\\t}        \\n        \\n\\t    return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n\\t    int maxVal = 0;\\n\\n    \\tstack<int> st;\\n\\t    st.push(-1);\\n\\n    \\tfor(int i = 0; i < s.size(); i++)\\n\\t    \\tif(s[i] == \\'(\\')\\n                st.push(i);\\n\\n    \\t\\telse {       \\n\\t    \\t\\tst.pop();\\n\\n\\t\\t    \\tif(st.empty())\\n                    st.push(i);\\n    \\t\\t\\telse\\n                    maxVal = max(maxVal, i - st.top());\\n    \\t\\t}        \\n        \\n\\t    return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899279,
                "title": "python-3-o-n-solution",
                "content": "Algorithm Explanation:\\n1. check for the base case and if valid string make stack and add dummy value (reason explained in step )\\n2. loop through the string using enumerate as we will use both character and index of the character to count the longest valid parentheses\\n3. we will append open bracker index in stack and pop the last element when closed parentheses encountered\\n4.  if we encounter closed parentheses as our first value than we will have dummy value to remove from stack\\n5.  after removing last element from the stack check if stack is empty if it is than append index of current character\\n6.  if not than we will calculate current length which will be current index - last value of stack\\n7.  for max length we will do max of current lengh and assigned max lenght\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# base case check\\n        if not s:\\n            return 0\\n        stack = [-1] # \\n        max_len = 0\\n        for i, ch in enumerate(s):\\n            if ch == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    curr_len = i - stack[len(stack)-1]\\n                    max_len = max(curr_len, max_len)\\n        return max_len\\n```\\n\\nPlease upvote this solution if you find it helpful.\\nany suggestions or imporvement are more than welcome.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# base case check\\n        if not s:\\n            return 0\\n        stack = [-1] # \\n        max_len = 0\\n        for i, ch in enumerate(s):\\n            if ch == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    curr_len = i - stack[len(stack)-1]\\n                    max_len = max(curr_len, max_len)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379451,
                "title": "easy-stack-based-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<int>stk;\\n        int ans=0;\\n        stk.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                if(!stk.empty())\\n                {\\n                    ans=max(ans,i-stk.top());\\n                }\\n                else\\n                {\\n                    stk.push(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<int>stk;\\n        int ans=0;\\n        stk.push(-1);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                if(!stk.empty())\\n                {\\n                    ans=max(ans,i-stk.top());\\n                }\\n                else\\n                {\\n                    stk.push(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144587,
                "title": "java-simple-and-easy-to-understand-solution-using-stack-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        \\n        int maxLen = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\'){ //opening bracket\\n                \\n                stack.push(i);\\n            }else if(s.charAt(i) == \\')\\'){ //closing bracket\\n                \\n                stack.pop();\\n                if(stack.empty()){\\n                    //reset\\n                    stack.push(i);\\n                }else{\\n                    //update maxLen\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                }\\n                    \\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack();\\n        stack.push(-1);\\n        \\n        int maxLen = 0;\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            if(s.charAt(i) == \\'(\\'){ //opening bracket\\n                \\n                stack.push(i);\\n            }else if(s.charAt(i) == \\')\\'){ //closing bracket\\n                \\n                stack.pop();\\n                if(stack.empty()){\\n                    //reset\\n                    stack.push(i);\\n                }else{\\n                    //update maxLen\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                }\\n                    \\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14173,
                "title": "javascript-solution-o-n-with-comments",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestValidParentheses = function(s) {\\n    if (!s || !s.length) { return 0; }\\n\\n    /* We will store the position of every invalid parenthesis.\\n       Once we have that, the solution is simply the longest\\n       subarray between two invalid parentheses */\\n    const invalids = new Set();\\n\\n    /* We stack the opening parentheses as we find them,\\n       and pop them we we meet the corresponding closing\\n       parenthesis. Note that a closing ) always matches the\\n       latest opening ( one, hence the choice of a stack */\\n    const stack = [];\\n\\n    for (let i=0; i<s.length; i++) {\\n        if (s[i] === '(') {\\n            stack.push(i);\\n        } else {\\n            // If we are closing an opening parenthesis, pop it out\\n            if (stack.length) {\\n                stack.pop();\\n            } else {\\n                /* Otherwise there is nothing to close,\\n                   hence this parenthesis is invalid */\\n                invalids.add(i);\\n            }\\n        }\\n    }\\n\\n    /* Any remaining opening parenthesis that has not been closed is\\n       automatically invalid */\\n    while (stack.length) {\\n        invalids.add(stack.pop());\\n    }\\n    \\n    // Here we just count how many valid in between every invalid\\n    let max = 0, count = 0;\\n    for (let i=0; i<=s.length; i++) {\\n        if (i < s.length && !invalids.has(i)) {\\n            count++;\\n        } else {\\n            max = Math.max(max, count);\\n            count = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar longestValidParentheses = function(s) {\\n    if (!s || !s.length) { return 0; }\\n\\n    /* We will store the position of every invalid parenthesis.\\n       Once we have that, the solution is simply the longest\\n       subarray between two invalid parentheses */\\n    const invalids = new Set();\\n\\n    /* We stack the opening parentheses as we find them,\\n       and pop them we we meet the corresponding closing\\n       parenthesis. Note that a closing ) always matches the\\n       latest opening ( one, hence the choice of a stack */\\n    const stack = [];\\n\\n    for (let i=0; i<s.length; i++) {\\n        if (s[i] === '(') {\\n            stack.push(i);\\n        } else {\\n            // If we are closing an opening parenthesis, pop it out\\n            if (stack.length) {\\n                stack.pop();\\n            } else {\\n                /* Otherwise there is nothing to close,\\n                   hence this parenthesis is invalid */\\n                invalids.add(i);\\n            }\\n        }\\n    }\\n\\n    /* Any remaining opening parenthesis that has not been closed is\\n       automatically invalid */\\n    while (stack.length) {\\n        invalids.add(stack.pop());\\n    }\\n    \\n    // Here we just count how many valid in between every invalid\\n    let max = 0, count = 0;\\n    for (let i=0; i<=s.length; i++) {\\n        if (i < s.length && !invalids.has(i)) {\\n            count++;\\n        } else {\\n            max = Math.max(max, count);\\n            count = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 14354,
                "title": "my-simple-java-solution",
                "content": "    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        int maxLen = 0;\\n        int curLen = 0;\\n        for(int i = 0; i < s.length();i++) {\\n            if(s.charAt(i) == '(') {\\n                st.push(curLen);\\n                curLen = 0;\\n            } else if (s.charAt(i) == ')') {\\n                if(st.isEmpty()) {\\n                    curLen = 0;\\n                } else {\\n                    curLen = curLen + st.pop() + 2;\\n                    if(curLen > maxLen) maxLen = curLen;\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [],
                "code": "    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        int maxLen = 0;\\n        int curLen = 0;\\n        for(int i = 0; i < s.length();i++) {\\n            if(s.charAt(i) == '(') {\\n                st.push(curLen);\\n                curLen = 0;\\n            } else if (s.charAt(i) == ')') {\\n                if(st.isEmpty()) {\\n                    curLen = 0;\\n                } else {\\n                    curLen = curLen + st.pop() + 2;\\n                    if(curLen > maxLen) maxLen = curLen;\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14395,
                "title": "within-10-lines-in-python-to-solve-it",
                "content": "      def longestValidParentheses(self, s):\\n        \"\"\" as the \")\" will not effect the final result, which acts as a dummy  element to\\n            make the all the  original elements of s equivalently, \\n            otherwise the first element needs to be dealt with separately. \\n        \"\"\" \\n        s = \")\" + s  \\n        stack, ans = [], 0\\n        for index in xrange(len(s)):\\n          element = s[index]\\n          if element == \")\" and stack and stack[-1][1] == \"(\":\\n            stack.pop()\\n            ans = max(ans, index - stack[-1][0])\\n          else:\\n            stack.append((index, element))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "      def longestValidParentheses(self, s):\\n        \"\"\" as the \")\" will not effect the final result, which acts as a dummy  element to\\n            make the all the  original elements of s equivalently, \\n            otherwise the first element needs to be dealt with separately. \\n        \"\"\" \\n        s = \")\" + s  \\n        stack, ans = [], 0\\n        for index in xrange(len(s)):\\n          element = s[index]\\n          if element == \")\" and stack and stack[-1][1] == \"(\":\\n            stack.pop()\\n            ans = max(ans, index - stack[-1][0])\\n          else:\\n            stack.append((index, element))\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 14405,
                "title": "an-easy-understanding-way-to-solve-it",
                "content": "but maybe with more timewaste.haha\\n\\n    class LVP{\\n    \\n    \\tpublic:\\n    \\tint lvp( string s ){\\n    \\t\\tint len = s.size();\\n    \\t\\tif( !len )\\t\\t\\t// if string is empty, return 0 instantly.\\n    \\t\\t\\treturn 0;\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t\\n    \\t\\t\\tif( s[i] == ')' )\\t\\n    \\t\\t\\t\\tfor( int j = i - 1;j >= 0;j-- )\\t\\t// for every ')\\u2019\\uff0cfind the first match '(' before it\\n    \\t\\t\\t\\t\\tif( s[j] == '(' )\\t{\\t\\t\\t// and mark the two with a special flag,like '0'\\n    \\t\\t\\t\\t\\t\\ts[i] = '0';\\n    \\t\\t\\t\\t\\t\\ts[j] = '0';\\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\tint max = 0,temp = 0;\\t\\t\\t\\t\\t\\t\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t{\\t\\t\\t// the problem changed to find the longest '0' in the string\\n    \\t\\t\\tif( s[i] == '0' )\\n    \\t\\t\\t\\ttemp++;\\n    \\t\\t\\telse\\t{\\n    \\t\\t\\t\\tmax = temp > max ? temp : max;\\n    \\t\\t\\t\\ttemp = 0;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tmax = temp > max ? temp : max;\\t\\t\\t\\t// longest '0'sequence may still stored in temp\\n    \\t\\treturn max;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "but maybe with more timewaste.haha\\n\\n    class LVP{\\n    \\n    \\tpublic:\\n    \\tint lvp( string s ){\\n    \\t\\tint len = s.size();\\n    \\t\\tif( !len )\\t\\t\\t// if string is empty, return 0 instantly.\\n    \\t\\t\\treturn 0;\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t\\n    \\t\\t\\tif( s[i] == ')' )\\t\\n    \\t\\t\\t\\tfor( int j = i - 1;j >= 0;j-- )\\t\\t// for every ')\\u2019\\uff0cfind the first match '(' before it\\n    \\t\\t\\t\\t\\tif( s[j] == '(' )\\t{\\t\\t\\t// and mark the two with a special flag,like '0'\\n    \\t\\t\\t\\t\\t\\ts[i] = '0';\\n    \\t\\t\\t\\t\\t\\ts[j] = '0';\\n    \\t\\t\\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\t}\\n    \\t\\tint max = 0,temp = 0;\\t\\t\\t\\t\\t\\t\\n    \\t\\tfor( int i = 0;i < len;i++ )\\t{\\t\\t\\t// the problem changed to find the longest '0' in the string\\n    \\t\\t\\tif( s[i] == '0' )\\n    \\t\\t\\t\\ttemp++;\\n    \\t\\t\\telse\\t{\\n    \\t\\t\\t\\tmax = temp > max ? temp : max;\\n    \\t\\t\\t\\ttemp = 0;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\tmax = temp > max ? temp : max;\\t\\t\\t\\t// longest '0'sequence may still stored in temp\\n    \\t\\treturn max;\\n    \\t}\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 625799,
                "title": "memorized-dfs-top-down-dp",
                "content": "I did not see a top down approach, so I created one. \\ndp[i] = longest valid parentheses ending at index `i`.\\n\\nStarting from the end of the string `s`, either current position is `(` when it means computation is done for the string ending at index `i`; \\nor a more complex case where the current char is `)` when recursion needs to continue to find out `dp[i - 1]`. \\n```\\nif s[i] == \\'(\\':\\n    dp[i] = 0\\nelif s[i] == \\')\\':\\n\\tif  i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n\\t\\t\\tdp[i] = dp[ i - dp[i - 1] - 2] + 2 + dp[i - 1]\\n\\telse:\\n\\t\\t\\tdp[i] = 0\\n```\\n\\nWe need to do the above for all index within string `s` because we have defined the `dp[i]` to mean such valid string to end in every index. \\nAfter that we want to collect the longest of such valid parentheses. \\n\\nHence the final code for this top down approach:\\n```\\nimport functools\\nclass Solution:\\n    def __init__(self):\\n        self.max = 0\\n        \\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        @functools.lru_cache(maxsize = None)\\n        def dp(s, i):\\n            if i < 0:\\n                return 0\\n\\n            if s[i] == \\'(\\':\\n                return 0\\n\\n            ans = 0\\n            length = dp(s, i - 1)\\n            if i - length - 1 >= 0 and s[i - length - 1] == \\'(\\':\\n                ans = length + 2 + dp(s, i - length - 1 - 1)\\n\\n            self.max = max(self.max, ans)\\n            return ans\\n\\n        for i in range(len(s)):\\n            dp(s, i)\\n            \\n        return self.max\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nif s[i] == \\'(\\':\\n    dp[i] = 0\\nelif s[i] == \\')\\':\\n\\tif  i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n\\t\\t\\tdp[i] = dp[ i - dp[i - 1] - 2] + 2 + dp[i - 1]\\n\\telse:\\n\\t\\t\\tdp[i] = 0\\n```\n```\\nimport functools\\nclass Solution:\\n    def __init__(self):\\n        self.max = 0\\n        \\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        @functools.lru_cache(maxsize = None)\\n        def dp(s, i):\\n            if i < 0:\\n                return 0\\n\\n            if s[i] == \\'(\\':\\n                return 0\\n\\n            ans = 0\\n            length = dp(s, i - 1)\\n            if i - length - 1 >= 0 and s[i - length - 1] == \\'(\\':\\n                ans = length + 2 + dp(s, i - length - 1 - 1)\\n\\n            self.max = max(self.max, ans)\\n            return ans\\n\\n        for i in range(len(s)):\\n            dp(s, i)\\n            \\n        return self.max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593019,
                "title": "store-current-longest-valid-string-on-stack-add-to-it-when-popped-python",
                "content": "A couple of the highest voted solutions are similar, but this was the easist way for me to understand it. Whenever we see a new open paren, we push the current longest streak to the stack. Whenever we see a close paren, we pop the top value if possible, and add the value (which was the previous longest streak up to that point) to the current one (because they are now contiguous) and add 2 to count for the matching open and close parens. If there is no matching open paren for a close paren, reset the current count. Observe:\\n\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack, curr_longest, max_longest = [], 0, 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(curr_longest)\\n                curr_longest = 0\\n            elif c == \\')\\':\\n                if stack:\\n                    curr_longest += stack.pop() + 2\\n                    max_longest = max(max_longest, curr_longest)\\n                else:\\n                    curr_longest = 0\\n        return max_longest\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack, curr_longest, max_longest = [], 0, 0\\n        for c in s:\\n            if c == \\'(\\':\\n                stack.append(curr_longest)\\n                curr_longest = 0\\n            elif c == \\')\\':\\n                if stack:\\n                    curr_longest += stack.pop() + 2\\n                    max_longest = max(max_longest, curr_longest)\\n                else:\\n                    curr_longest = 0\\n        return max_longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555969,
                "title": "js-no-magic-approach-2-beats-99-2-approaches-to-choose-from-feedback-is-welcome",
                "content": "\\n1.Sliding window \\n-time O(N)\\n-space O(N)\\n```\\n\\nvar longestValidParentheses = function(s) {\\n    let longest = 0\\n    let stack=[-1]\\n    \\n    for(let i=0;i<s.length;i++){\\n      let char = s[i]\\n      \\n      if(char === \\'(\\'){\\n        stack.push(i)\\n        continue\\n      }\\n      \\n      stack.pop()\\n      if(!stack.length) stack.push(i)\\n      else longest = Math.max((i - stack[stack.length-1]),longest)\\n    }\\n  \\n    return longest\\n};\\n```\\n\\n2. Using left to right pass then right to left pass\\n-time O(N)\\n-space O(1)\\n\\n```\\n\\nfunction longestValidParentheses(s){\\n  let longest = 0,leftCount = 0, rightCount = 0\\n  \\n  //left to right pass\\n  for(let i=0; i < s.length;i++){\\n    \\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n    \\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount <rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  \\n  //right to left pass\\n  leftCount = 0, rightCount = 0\\n  for(let i=s.length-1; i >= 0;i--){\\n\\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n\\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount >rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  return longest\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar longestValidParentheses = function(s) {\\n    let longest = 0\\n    let stack=[-1]\\n    \\n    for(let i=0;i<s.length;i++){\\n      let char = s[i]\\n      \\n      if(char === \\'(\\'){\\n        stack.push(i)\\n        continue\\n      }\\n      \\n      stack.pop()\\n      if(!stack.length) stack.push(i)\\n      else longest = Math.max((i - stack[stack.length-1]),longest)\\n    }\\n  \\n    return longest\\n};\\n```\n```\\n\\nfunction longestValidParentheses(s){\\n  let longest = 0,leftCount = 0, rightCount = 0\\n  \\n  //left to right pass\\n  for(let i=0; i < s.length;i++){\\n    \\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n    \\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount <rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  \\n  //right to left pass\\n  leftCount = 0, rightCount = 0\\n  for(let i=s.length-1; i >= 0;i--){\\n\\n    if(s[i] === \\'(\\')leftCount++\\n    else rightCount++\\n\\n    if(leftCount === rightCount){\\n      longest = Math.max(longest,leftCount+rightCount)\\n    }else if(leftCount >rightCount){\\n      leftCount=0\\n      rightCount=0\\n    }\\n  }\\n  return longest\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400214,
                "title": "easy-python-solution-no-dynamic-programming",
                "content": "\\tclass Solution(object):\\n\\t\\tdef longestValidParentheses(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tm = l = r = 0\\n\\t\\t\\tfor e in s:\\n\\t\\t\\t\\tif e==\\'(\\':\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\tif l==r:\\n\\t\\t\\t\\t\\tm = max(m,r+l)\\n\\t\\t\\t\\telif r>l:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\tl=r=0\\n\\t\\t\\tfor e in s[::-1]:\\n\\t\\t\\t\\tif e==\\')\\':\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tif l==r: \\n\\t\\t\\t\\t\\tm=max(m,r+l)\\n\\t\\t\\t\\telif l>r:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\treturn m\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef longestValidParentheses(self, s):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type s: str\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tm = l = r = 0\\n\\t\\t\\tfor e in s:\\n\\t\\t\\t\\tif e==\\'(\\':\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\tif l==r:\\n\\t\\t\\t\\t\\tm = max(m,r+l)\\n\\t\\t\\t\\telif r>l:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\tl=r=0\\n\\t\\t\\tfor e in s[::-1]:\\n\\t\\t\\t\\tif e==\\')\\':\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\telse: \\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\tif l==r: \\n\\t\\t\\t\\t\\tm=max(m,r+l)\\n\\t\\t\\t\\telif l>r:\\n\\t\\t\\t\\t\\tl=r=0\\n\\t\\t\\treturn m\\n",
                "codeTag": "Java"
            },
            {
                "id": 14258,
                "title": "very-easy-to-understand-5-ms-o-n-solution-without-stack-or-dp",
                "content": "for input example:\\n\\n\"()()))((()(())(()))((())(()()()()()()(((((())))))())()())()(())(())())))))(())()((((((((()()(())))))())())))()(((()())()))(((()()(((((\"\\n\\nI scan the string forward and backward change the string to:\\n\\n()()##((()(())(()))((())(()()()()()()(((((())))))())()())()(())(())())####(())()((((((((()()(())))))())())))()(((()())()))###()()#####\\n\\nthe invalid ( or ) are removed.\\n\\nThen you count the longest valid substring length.\\n\\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n            char[] c = s.toCharArray();\\n            int len = c.length, t = 0, ans = 0;\\n            for (int i = 0, y = 0; i < len; i++)\\n                if (c[i] == '(')\\n                    y++;\\n                else if (c[i] == ')' && --y < 0) {\\n                    y = 0;\\n                    c[i] = '#';\\n                }\\n                \\n            for (int i = len - 1, y = 0; i >= 0; i--) {\\n                if (c[i] == ')')\\n                    y++;\\n                else if (c[i] == '(' && --y < 0) {\\n                    y = 0;\\n                    c[i] = '#';\\n                }\\n                \\n                t = (c[i] == '#') ? 0 : t + 1;\\n                ans = Math.max(ans, t);\\n            }\\n            System.out.println(new String(c));\\n            \\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n            char[] c = s.toCharArray();\\n            int len = c.length, t = 0, ans = 0;\\n            for (int i = 0, y = 0; i < len; i++)\\n                if (c[i] == '(')\\n                    y++;\\n                else if (c[i] == ')' && --y < 0) {\\n                    y = 0;\\n                    c[i] = '#';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14269,
                "title": "an-intuitive-4ms-solution-a-dp-solution-0ms-and-an-optimized-clean-dp-solution-0ms-in-c",
                "content": "A direct solution is to traverse the string and record the index of '(' until its corresponding ')' in a stack in which process we can get the longest for different sections of valid parentheses and then using a variable max to record the current longest valid parentheses we handled so far; till the end, we return the max - the longest valid parentheses in the string. \\n\\n - Time Cost O(n) \\n - Space Cost O(n)\\n\\n----------\\n    //AC - 4ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int *stack = (int*)malloc(sizeof(int)*len);\\n        int top = -1;\\n        stack[++top] = -1;\\n        int max = 0;\\n        for(int i = 0; i < len; i++)\\n        {\\n            int t = stack[top];\\n            if(t!=-1 && s[i]==')' && s[t]=='(')\\n            {\\n                if(i-stack[--top] > max)\\n                    max = i-stack[top];\\n            }\\n            else\\n                stack[++top] = i;\\n        }\\n        return max;\\n    }\\n    \\nUsing DP is quite simpler and easy to understand, here we can use an array maxs[] to store the longest till the current position of the string - the index of maxs[] is the same as that of the string. \\n\\n - When the current character is '(' then maxs[current]=0, quite intuitive; \\n - when the current character is ')' we need to consider the previous state maxs[current-1] and s[current-1]: \\n - at this time if s[current-1]=='(' we need further check the maxs[current-2] to get the longest valid parentheses; \\n - if s[current-1]==')' then we need to check s[i-maxs[current-1]-1] and maxs[i-maxs[current-1]-2] to get the longest for maxs[current].\\n\\nConfused? check an example here: \"()(())\" if we reached the last ')', then the maxs[current-1]=2 and obviously this is not the longest for maxs[current] and to get the longest we need to check the third character which is the last character not covered by maxs[current-1] -- s[current-maxs[current-1]-1] is the character and then the maxs[current-maxs[current-1]-2] which is the first parentheses in this example.\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n    //AC - 0ms - DP solution;\\n    int longestValidParentheses2(char* s)\\n    {\\n        int len = strlen(s);\\n        if(len < 2) return 0;\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n        {\\n            if(s[i] == ')')\\n            {\\n                if(s[i-1] == '(')\\n                        maxs[i] = 2+ (i>1? maxs[i-2] : 0);\\n                else if(i-maxs[i-1] > 0 && s[i-maxs[i-1]-1] == '(')\\n                        maxs[i] = maxs[i-1] + (i-maxs[i-1]>1? maxs[i-maxs[i-1]-2]:0) + 2; \\n                if(maxs[i] > max)\\n                    max = maxs[i];\\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n \\nIn fact, just as we have analyzed in the DP solution, we can merge the two conditions s[current-1]==')' and s[current-1]=='(' altogether when s[current]==')', because if s[current-1]=='(' then maxs[current-1] will be zero which will force the second condition to be the same with the first, so we are just repeating ourselves! Here is the further optimized DP solution removing the redundancy, which is much terse and clean!\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n\\n    //AC - 0ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxs[i-1];\\n                if(t>0 && s[t-1] == '(') maxs[i] = maxs[i-1] + (t>1? maxs[t-2]:0) + 2; \\n                if(maxs[i] > max) max = maxs[i];\\n            }\\n        return max;\\n    }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "A direct solution is to traverse the string and record the index of '(' until its corresponding ')' in a stack in which process we can get the longest for different sections of valid parentheses and then using a variable max to record the current longest valid parentheses we handled so far; till the end, we return the max - the longest valid parentheses in the string. \\n\\n - Time Cost O(n) \\n - Space Cost O(n)\\n\\n----------\\n    //AC - 4ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int *stack = (int*)malloc(sizeof(int)*len);\\n        int top = -1;\\n        stack[++top] = -1;\\n        int max = 0;\\n        for(int i = 0; i < len; i++)\\n        {\\n            int t = stack[top];\\n            if(t!=-1 && s[i]==')' && s[t]=='(')\\n            {\\n                if(i-stack[--top] > max)\\n                    max = i-stack[top];\\n            }\\n            else\\n                stack[++top] = i;\\n        }\\n        return max;\\n    }\\n    \\nUsing DP is quite simpler and easy to understand, here we can use an array maxs[] to store the longest till the current position of the string - the index of maxs[] is the same as that of the string. \\n\\n - When the current character is '(' then maxs[current]=0, quite intuitive; \\n - when the current character is ')' we need to consider the previous state maxs[current-1] and s[current-1]: \\n - at this time if s[current-1]=='(' we need further check the maxs[current-2] to get the longest valid parentheses; \\n - if s[current-1]==')' then we need to check s[i-maxs[current-1]-1] and maxs[i-maxs[current-1]-2] to get the longest for maxs[current].\\n\\nConfused? check an example here: \"()(())\" if we reached the last ')', then the maxs[current-1]=2 and obviously this is not the longest for maxs[current] and to get the longest we need to check the third character which is the last character not covered by maxs[current-1] -- s[current-maxs[current-1]-1] is the character and then the maxs[current-maxs[current-1]-2] which is the first parentheses in this example.\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n    //AC - 0ms - DP solution;\\n    int longestValidParentheses2(char* s)\\n    {\\n        int len = strlen(s);\\n        if(len < 2) return 0;\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n        {\\n            if(s[i] == ')')\\n            {\\n                if(s[i-1] == '(')\\n                        maxs[i] = 2+ (i>1? maxs[i-2] : 0);\\n                else if(i-maxs[i-1] > 0 && s[i-maxs[i-1]-1] == '(')\\n                        maxs[i] = maxs[i-1] + (i-maxs[i-1]>1? maxs[i-maxs[i-1]-2]:0) + 2; \\n                if(maxs[i] > max)\\n                    max = maxs[i];\\n            }\\n        }\\n        return max;\\n    }\\n    \\n\\n \\nIn fact, just as we have analyzed in the DP solution, we can merge the two conditions s[current-1]==')' and s[current-1]=='(' altogether when s[current]==')', because if s[current-1]=='(' then maxs[current-1] will be zero which will force the second condition to be the same with the first, so we are just repeating ourselves! Here is the further optimized DP solution removing the redundancy, which is much terse and clean!\\n\\n - Time Cost O(n)\\n - Space Cost O(n)\\n\\n----------\\n\\n    //AC - 0ms;\\n    int longestValidParentheses(char* s)\\n    {\\n        int len = strlen(s);\\n        int max = 0;\\n        int *maxs = (int*)malloc(sizeof(int)*len); //record the max viable length ending with the current;\\n        memset(maxs, 0, sizeof(int)*len);\\n        for(int i = 1; i < len; i++)\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxs[i-1];\\n                if(t>0 && s[t-1] == '(') maxs[i] = maxs[i-1] + (t>1? maxs[t-2]:0) + 2; \\n                if(maxs[i] > max) max = maxs[i];\\n            }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3538668,
                "title": "two-approaches-using-stack-and-without-space",
                "content": "# Using Stack:\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        stack.append(-1)\\n        ans=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if len(stack)==0:\\n                    stack.append(i)\\n                ans=max(ans,i-stack[-1])\\n        return ans\\n```\\n# without Space complexity:\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open,close,ans=0,0,0\\n        for i in s:\\n            if i==\"(\":\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif close>open:\\n                open=close=0\\n        open=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if \"(\"==s[i]:\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif open>close:\\n                open=close=0\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack=[]\\n        stack.append(-1)\\n        ans=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if len(stack)==0:\\n                    stack.append(i)\\n                ans=max(ans,i-stack[-1])\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open,close,ans=0,0,0\\n        for i in s:\\n            if i==\"(\":\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif close>open:\\n                open=close=0\\n        open=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if \"(\"==s[i]:\\n                open+=1\\n            else:\\n                close+=1\\n            if close==open:\\n                ans=max(ans,close+open)\\n            elif open>close:\\n                open=close=0\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197466,
                "title": "c-c-python-both-dp-and-stack-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n# If you find this helpful,Please Upvote \\n```\\npublic class Solution {\\n    public int LongestValidParentheses(string s) {\\n        Stack<int> index =new Stack<int>();\\n            for(int i=0;i < s.Length;i++){\\n                if (s[i] == \\'(\\'){\\n                    index.Push(i);\\n                }\\n                else{\\n                    if(index.Any() && s[index.Peek()] == \\'(\\'){\\n                        index.Pop();\\n                    }\\n                    else{\\n                        index.Push(i);\\n                    }\\n                }\\n            }\\n            if(!index.Any()){\\n                return s.Length;\\n            }\\n            int length = s.Length, unwanted = 0;\\n            int result = 0;\\n            while(index.Any()){\\n                unwanted = index.Peek();\\n                index.Pop();\\n                result = Math.Max(result,length - unwanted - 1);\\n                length = unwanted;\\n            }\\n            result = Math.Max(result,length);\\n            return result;\\n    }\\n}\\n```\\n# Python Solution  \\n\\n    def ValidParantheses(s):\\n        length=len(s)\\n        dp=[0]*length\\n        count=0\\n        maxLen=0\\n        pos=0\\n        for par in s:\\n            if par == \\'(\\':\\n                count += 1\\n            elif par == \\')\\':\\n                if count>0:\\n                    count-=1\\n                    #immediate parentheses like ()()\\n                    dp[pos]=dp[pos-1]+2\\n                    #outer parentheses (out of nested parentheses or non immmediate valid parentheses)\\n                    if dp[pos] <= pos:\\n                        dp[pos] = dp[pos]+dp[pos-dp[pos]]\\n                \\n            maxLen=max(maxLen,dp[pos])\\n            pos += 1\\n        return maxLen\\n\\n# Upvote \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "C#",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestValidParentheses(string s) {\\n        Stack<int> index =new Stack<int>();\\n            for(int i=0;i < s.Length;i++){\\n                if (s[i] == \\'(\\'){\\n                    index.Push(i);\\n                }\\n                else{\\n                    if(index.Any() && s[index.Peek()] == \\'(\\'){\\n                        index.Pop();\\n                    }\\n                    else{\\n                        index.Push(i);\\n                    }\\n                }\\n            }\\n            if(!index.Any()){\\n                return s.Length;\\n            }\\n            int length = s.Length, unwanted = 0;\\n            int result = 0;\\n            while(index.Any()){\\n                unwanted = index.Peek();\\n                index.Pop();\\n                result = Math.Max(result,length - unwanted - 1);\\n                length = unwanted;\\n            }\\n            result = Math.Max(result,length);\\n            return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008088,
                "title": "simplest-shortest-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        s.push(-1);\\n        int ans = 0, n = str.size();\\n        for(int i=0; i<n; i++) {\\n            if(s.top() != -1 && str[s.top()] == \\'(\\' && str[i] == \\')\\') s.pop(), ans = max(ans, i - s.top());\\n            else s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        s.push(-1);\\n        int ans = 0, n = str.size();\\n        for(int i=0; i<n; i++) {\\n            if(s.top() != -1 && str[s.top()] == \\'(\\' && str[i] == \\')\\') s.pop(), ans = max(ans, i - s.top());\\n            else s.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449097,
                "title": "c-easy-and-simplest-code-without-dp",
                "content": "\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestValidParentheses(string s) \\n\\t\\t{\\n\\t\\t\\tstack<int>st;\\n\\t\\t\\tst.push(-1);\\n\\t\\t\\tint maxcount=0;\\n\\t\\t\\tfor(int i=0;i<s.length();i++)\\n\\t\\t\\t{\\n\\t\\t\\t   char ch=s[i];\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t st.push(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{ \\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tif(st.empty())st.push(i);\\n\\t\\t\\t\\t   else\\n\\t\\t\\t\\t   {\\n\\t\\t\\t\\t\\t\\tmaxcount =   max(maxcount,i-st.top());\\n\\t\\t\\t\\t   }\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxcount;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestValidParentheses(string s) \\n\\t\\t{\\n\\t\\t\\tstack<int>st;\\n\\t\\t\\tst.push(-1);\\n\\t\\t\\tint maxcount=0;\\n\\t\\t\\tfor(int i=0;i<s.length();i++)\\n\\t\\t\\t{\\n\\t\\t\\t   char ch=s[i];\\n\\t\\t\\t\\tif(ch==\\'(\\')\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t st.push(i);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2420673,
                "title": "c-solution-little-tricky-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        stack<int>st;\\n        int ans=0;\\n        int temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else\\n            {\\n                if(!st.empty())\\n                {\\n                    int k=st.top();\\n                    st.pop();\\n                    dp[k]=(i-k+1);\\n                }\\n            }\\n        }\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(dp[i]==0)\\n            {\\n                temp=0;\\n                i++;\\n            }\\n            else\\n            {\\n                temp+=dp[i];\\n                i+=dp[i];\\n            }\\n            ans=max(ans,temp);\\n        }\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.length();\\n        vector<int>dp(n+1,0);\\n        stack<int>st;\\n        int ans=0;\\n        int temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                st.push(i);\\n            else\\n            {\\n                if(!st.empty())\\n                {\\n                    int k=st.top();\\n                    st.pop();\\n                    dp[k]=(i-k+1);\\n                }\\n            }\\n        }\\n        int i=0;\\n        while(i<n)\\n        {\\n            if(dp[i]==0)\\n            {\\n                temp=0;\\n                i++;\\n            }\\n            else\\n            {\\n                temp+=dp[i];\\n                i+=dp[i];\\n            }\\n            ans=max(ans,temp);\\n        }\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070522,
                "title": "left-and-right-traversal-o-n-time-complexity-o-1-space-complexity-easy-0ms",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,ansLeft=0,ansRight=0;\\n        \\n        // for left traversal \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(right>left) // if count of closing brackets becomes greater than opening bracket\\n            {\\n                right=0;\\n                left=0;\\n            }\\n            else if(right==left)\\n              ansLeft=max(ansLeft,left+right);\\n        }\\n        left=0;\\n        right=0;\\n        // for right traversal\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left>right) // if count of opening brackets becomes greater than closing bracket\\n            {   \\n                left=0;\\n                right=0;\\n                }\\n            else if(left==right)\\n              ansRight=max(ansRight,left+right);\\n        }\\n        return max(ansLeft,ansRight);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0,right=0,ansLeft=0,ansRight=0;\\n        \\n        // for left traversal \\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(right>left) // if count of closing brackets becomes greater than opening bracket\\n            {\\n                right=0;\\n                left=0;\\n            }\\n            else if(right==left)\\n              ansLeft=max(ansLeft,left+right);\\n        }\\n        left=0;\\n        right=0;\\n        // for right traversal\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                left++;\\n            if(s[i]==\\')\\')\\n                right++;\\n            if(left>right) // if count of opening brackets becomes greater than closing bracket\\n            {   \\n                left=0;\\n                right=0;\\n                }\\n            else if(left==right)\\n              ansRight=max(ansRight,left+right);\\n        }\\n        return max(ansLeft,ansRight);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069564,
                "title": "c-2-approach-easy-and-simple",
                "content": "**Please Upvote If It Helps**\\n\\n**Approach : 1 (Using Two Pointer)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int open=0, close=0;\\n        int maxl = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*close);\\n            else if(close>=open)\\n                open=0, close=0;\\n            \\n        }\\n        \\n        open = 0, close = 0;\\n        for(int i = s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*open);\\n            else if(open>=close)\\n                open = 0, close = 0;\\n        }\\n        return maxl;\\n    }\\n};\\n```\\n\\n\\n\\n**Approach : 2 (Using Stack)**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        stk.push(-1);\\n        int maxLength = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                \\n                if(stk.empty())\\n                {\\n                    stk.push(i);\\n                }\\n                else\\n                {\\n                    maxLength = max(maxLength, i-stk.top());\\n                }\\n            }\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n       int open=0, close=0;\\n        int maxl = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*close);\\n            else if(close>=open)\\n                open=0, close=0;\\n            \\n        }\\n        \\n        open = 0, close = 0;\\n        for(int i = s.size()-1; i>=0; i--)\\n        {\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else\\n                close++;\\n            if(close==open)\\n                maxl = max(maxl, 2*open);\\n            else if(open>=close)\\n                open = 0, close = 0;\\n        }\\n        return maxl;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        stk.push(-1);\\n        int maxLength = 0;\\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(s[i] == \\'(\\')\\n            {\\n                stk.push(i);\\n            }\\n            else\\n            {\\n                stk.pop();\\n                \\n                if(stk.empty())\\n                {\\n                    stk.push(i);\\n                }\\n                else\\n                {\\n                    maxLength = max(maxLength, i-stk.top());\\n                }\\n            }\\n        }\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141234,
                "title": "javascript-o-1-space-o-n-time-intuitive-solution",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n```javascript\\nvar longestValidParentheses = function(s) {\\n    let open = 0, close = 0, maxLen = 0;\\n\\n    for(let c of s) {\\n        if(c === \\'(\\') open++;\\n        else close++;\\n        if(open === close) maxLen = Math.max(maxLen, close*2);\\n        else if(close > open) open = close = 0;\\n    }\\n\\n    open = close = 0;\\n    \\n    for(let i = s.length-1; i >= 0; i--) {\\n        if(s[i] === \\')\\') close++;\\n        else open++;\\n        if(open === close) maxLen = Math.max(maxLen, open*2);\\n        else if(open > close) open = close = 0;\\n    }\\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestValidParentheses = function(s) {\\n    let open = 0, close = 0, maxLen = 0;\\n\\n    for(let c of s) {\\n        if(c === \\'(\\') open++;\\n        else close++;\\n        if(open === close) maxLen = Math.max(maxLen, close*2);\\n        else if(close > open) open = close = 0;\\n    }\\n\\n    open = close = 0;\\n    \\n    for(let i = s.length-1; i >= 0; i--) {\\n        if(s[i] === \\')\\') close++;\\n        else open++;\\n        if(open === close) maxLen = Math.max(maxLen, open*2);\\n        else if(open > close) open = close = 0;\\n    }\\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833908,
                "title": "simple-easy-java-solution-o-n-with-comments",
                "content": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        // create an array to mark valid parenthesis.\\n        int[] arr = new int[s.length()];\\n        \\n        // use a stack to store location of opening brackets.\\n        Stack<Integer> stack = new Stack<>();\\n        for(int k=0; k<s.length(); k++) {\\n            // if opening bracket is found, push its location onto the stack.\\n            if (s.charAt(k) == \\'(\\') {\\n                stack.add(k);\\n            }\\n            // if closing bracket is found and stack is not empty, that means the \\n            // the current closing bracket is a pair of the opening bracket at location\\n            // available at stack.peek().\\n            // mark both location as valid in the array.\\n            else if (s.charAt(k) == \\')\\') {\\n                if (!stack.isEmpty()) {\\n                    int top = stack.pop();\\n                    arr[top] = 1;\\n                    arr[k] = 1;\\n                }\\n            }\\n        }\\n        // find maximum of continuous valid locations in the array.\\n        int max = 0;\\n        int curr = 0;\\n        for(int k=0; k<arr.length; k++) {\\n            if(arr[k] == 1) {\\n                curr++;\\n            }\\n            else {\\n                max = Math.max(curr, max);\\n                curr = 0;\\n            }\\n        }\\n        return Math.max(curr, max);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int longestValidParentheses(String s) {\\n        // create an array to mark valid parenthesis.\\n        int[] arr = new int[s.length()];\\n        \\n        // use a stack to store location of opening brackets.\\n        Stack<Integer> stack = new Stack<>();\\n        for(int k=0; k<s.length(); k++) {\\n            // if opening bracket is found, push its location onto the stack.\\n            if (s.charAt(k) == \\'(\\') {\\n                stack.add(k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4043194,
                "title": "easy-to-understand-dp-solution-o-n-5-lines",
                "content": "# Intuition\\nThe problem asks for the length of the longest valid parentheses substring in a given string. To solve this problem, we can use dynamic programming. The idea is to maintain a dynamic programming array `dp`, where `dp[i]` represents the length of the longest valid parentheses substring ending at index `i` of the input string. We can initialize `dp` with zeros and then iterate through the string to update `dp` as we find valid parentheses substrings.\\n\\n# Approach\\n1. Initialize a dynamic programming array `dp` of size `s.size() + 1` and initialize all elements to 0.\\n2. Initialize a variable `ans` to 0, which will store the maximum length of valid parentheses substring found so far.\\n3. Iterate through the characters of the input string `s` from left to right, starting from the second character (index 1).\\n   - If the current character is \\')\\':\\n     - Check if there is a valid opening parenthesis \\'(\\' that can be matched with the current closing parenthesis \\')\\'.\\n     - To do this, check if the character before the current closing parenthesis (at index `i`) is an opening parenthesis \\'(\\', and if the character just before the opening parenthesis (at index `i - dp[i] - 1`) is also an opening parenthesis \\'(\\'.\\n     - If the conditions are met, update `dp[i + 1]` as follows:\\n       - `dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1]`\\n       - Here, `dp[i]` represents the length of valid parentheses substring ending at the previous character, and `dp[i - dp[i] - 1]` represents the length of valid parentheses substring just before the opening parenthesis that matches with the current closing parenthesis.\\n   - Update `ans` with the maximum value between the current `ans` and `dp[i + 1]`.\\n4. After iterating through the entire string, `ans` will contain the length of the longest valid parentheses substring in the input string.\\n5. Return `ans` as the result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input string `s`. We iterate through the string once, and for each character, we perform constant time operations.\\n- Space complexity: O(n), as we use a dynamic programming array `dp` of the same length as the input string.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size() + 1, 0);\\n        int ans = 0;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == \\')\\' && (i - dp[i] - 1) >= 0 && s[i - dp[i] - 1] == \\'(\\')\\n                dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1];\\n            ans = max(ans, dp[i + 1]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size() + 1, 0);\\n        int ans = 0;\\n        for (int i = 1; i < s.size(); i++) {\\n            if (s[i] == \\')\\' && (i - dp[i] - 1) >= 0 && s[i - dp[i] - 1] == \\'(\\')\\n                dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1];\\n            ans = max(ans, dp[i + 1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3926422,
                "title": "commented-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;     // Create a stack to keep track of indices\\n        stk.push(-1);       // Initialize the stack with -1 as a base index\\n        int ans = 0;        // Initialize the answer variable to store the maximum length\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);  // Push the index of an opening parenthesis onto the stack\\n            else {\\n                if(stk.size() == 1)\\n                    stk.top() = i;  // If stack contains only the base index, update it to the current index\\n                else {\\n                    stk.pop();       // Pop the top index from the stack\\n                    ans = max(ans, i - stk.top());  // Calculate the current valid length and update the answer\\n                }\\n            }\\n        }\\n        return ans;   // Return the maximum valid length\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;     // Create a stack to keep track of indices\\n        stk.push(-1);       // Initialize the stack with -1 as a base index\\n        int ans = 0;        // Initialize the answer variable to store the maximum length\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] == \\'(\\')\\n                stk.push(i);  // Push the index of an opening parenthesis onto the stack\\n            else {\\n                if(stk.size() == 1)\\n                    stk.top() = i;  // If stack contains only the base index, update it to the current index\\n                else {\\n                    stk.pop();       // Pop the top index from the stack\\n                    ans = max(ans, i - stk.top());  // Calculate the current valid length and update the answer\\n                }\\n            }\\n        }\\n        return ans;   // Return the maximum valid length\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768052,
                "title": "beats-100-easy-with-proper-commented-explanation-c",
                "content": "# Please Upvote!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The stack will store indices of the characters in the string. For every \\')\\' encountered, we check if the stack is not empty and the character at the top of the stack is \\'(\\', if so, it means that a pair of well-formed parentheses is formed.\\n\\n- The length of the longest valid parentheses can be updated by the current index minus the index at the new top of the stack (if the stack is not empty). If the stack is empty, we just push the current index into the stack.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1); // push -1 as initial index to start from\\n        int maxLength = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            // if current character is \\'(\\', push its index\\n            if(s[i] == \\'(\\') {\\n                st.push(i);\\n            }\\n            else { \\n                // if current character is \\')\\', pop the top\\n                if(!st.empty())\\n                    st.pop();\\n                // if stack is not empty, update the maxLength \\n                // by the difference of current index and index at the top of the stack\\n                if(!st.empty()) {\\n                    maxLength = max(maxLength, i - st.top());\\n                }\\n                else {\\n                    // if stack is empty, push the current index\\n                    st.push(i);\\n                }\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1); // push -1 as initial index to start from\\n        int maxLength = 0;\\n        \\n        for(int i=0; i<s.size(); i++) {\\n            // if current character is \\'(\\', push its index\\n            if(s[i] == \\'(\\') {\\n                st.push(i);\\n            }\\n            else { \\n                // if current character is \\')\\', pop the top\\n                if(!st.empty())\\n                    st.pop();\\n                // if stack is not empty, update the maxLength \\n                // by the difference of current index and index at the top of the stack\\n                if(!st.empty()) {\\n                    maxLength = max(maxLength, i - st.top());\\n                }\\n                else {\\n                    // if stack is empty, push the current index\\n                    st.push(i);\\n                }\\n            }\\n        }\\n        \\n        return maxLength;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610328,
                "title": "stack-based-approach-using-single-loop-java",
                "content": "# Intuition\\nUsed an Stack to find the longest valid parenthesis\\n\\n# Approach\\nStack based approach using single while loop.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity is O(n);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    Stack<Integer> st=new Stack<>();\\n    int ans=0;\\n    st.push(-1);\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)==\\'(\\')\\n            st.push(i);\\n        else{\\n            if(!st.isEmpty())\\n            st.pop();\\n            if(!st.isEmpty())\\n            ans=Math.max(i-st.peek(),ans);\\n            else\\n            st.push(i);\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n    Stack<Integer> st=new Stack<>();\\n    int ans=0;\\n    st.push(-1);\\n    for(int i=0;i<s.length();i++){\\n        if(s.charAt(i)==\\'(\\')\\n            st.push(i);\\n        else{\\n            if(!st.isEmpty())\\n            st.pop();\\n            if(!st.isEmpty())\\n            ans=Math.max(i-st.peek(),ans);\\n            else\\n            st.push(i);\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350181,
                "title": "100-faster-with-comments-c-stack-short-sweet-easy-to-understand",
                "content": "````\\n//IN THIS PROBLEM I FIND LONGEST LONGEST VALID PRENTHESIS SUBSTRING\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        vector<int> v;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                v.push_back(i);\\n            }\\n            else\\n            {\\n                if (v.size() > 0 && s[v.back()] == \\'(\\')\\n                {\\n                    v.pop_back();\\n                }\\n                else\\n                {\\n                    v.push_back(i);\\n                }\\n            }\\n        }\\n        if (v.size() == 0)//ARRAY WE STORE INDICES WHERE OUR SUBSTRINGS WILL BE INCOREECT & EXTRA OPENING BRACKET\\'S INDICES\\n            return s.length();\\n        int ans = 0, a = 0, b = s.length();\\n        while (v.size() > 0)\\n        {\\n            a = v.back();\\n            v.pop_back();\\n            ans = max(ans, b - a - 1);\\n            b = a;\\n        }\\n        ans = max(ans,b);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "````\\n//IN THIS PROBLEM I FIND LONGEST LONGEST VALID PRENTHESIS SUBSTRING\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        vector<int> v;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                v.push_back(i);\\n            }\\n            else\\n            {\\n                if (v.size() > 0 && s[v.back()] == \\'(\\')\\n                {\\n                    v.pop_back();\\n                }\\n                else\\n                {\\n                    v.push_back(i);\\n                }\\n            }\\n        }\\n        if (v.size() == 0)//ARRAY WE STORE INDICES WHERE OUR SUBSTRINGS WILL BE INCOREECT & EXTRA OPENING BRACKET\\'S INDICES\\n            return s.length();\\n        int ans = 0, a = 0, b = s.length();\\n        while (v.size() > 0)\\n        {\\n            a = v.back();\\n            v.pop_back();\\n            ans = max(ans, b - a - 1);\\n            b = a;\\n        }\\n        ans = max(ans,b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881527,
                "title": "c-o-n-easy-to-understand-with-in-depth-explanation-and-examples",
                "content": "#### Table of Contents\\n\\n- [TL;DR](#tldr)\\n  - [Code](#code)\\n  - [Complexity](#complexity)\\n- [In Depth Analysis](#in-depth-analysis)\\n  - [Intuition](#intuition)\\n  - [Approach](#approach)\\n  - [Example](#example)\\n\\n# TL;DR\\n\\nAll we want to do is scan the string from start to finish and use a stack to figure out if the index we are still looking at is a valid parenthesis\\n\\nIn other words, we want to push the indices of the opening brackets and if you encounter a closing bracket, then we calculate how long was this valid parenthesis (assuming that the stack is not empty) and update the ans if it is longer than the current best\\n\\n## Code\\n\\n```c++\\n#define OPEN_BRACKET \\'(\\'\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        const int n = s.size();\\n        int ans = 0;\\n        stack<int> brackets;\\n        brackets.push(-1);\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == OPEN_BRACKET)\\n                brackets.push(i);\\n            else {\\n                brackets.pop();\\n                if (brackets.empty())\\n                    brackets.push(i);\\n                else\\n                    ans = max(ans, i - brackets.top());\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n## Complexity\\n\\n**Time Complexity:** $$O(N)$$\\n**Space Complexity:** $$O(N)$$\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**\\n\\n---\\n\\n# In Depth Analysis\\n\\n## Intuition\\n\\nThis is a modified version of the valid parenthesis problem\\n\\nWe initially push `-1` onto the stack because it is to indicate the last location of a valid parenthesis. At first, the last valid parenthesis finished at index `-1`. Then, every time we encounter an opening bracket, we want to push that onto the stack too. \\n\\nIf it isn\\'t an opening bracket (aka closing bracket), we want to pop off the stack. If the stack is not empty, that means we have encountered a valid parenthesis and the stack\\'s current top is the position before the start of the valid string. Therefore, taking the difference between the current index and the stack\\'s top will yield the length of the valid string and we update the answer if it is longer than the current best.\\n\\nIf the stack is empty, that means that we have no idea where the next valid parenthesis set is (since we always compare it to the stack\\'s top element). Therefore, we just push the current index onto the stack to indicate the location of the last valid parenthesis.\\n\\n## Approach \\n\\nWe initialize push `-1` onto a stack and we iterate through all the characters in `s`. If the current character is a open bracket, push the index onto the stack. Otherwise, we pop off of the top. If the stack then becomes empty, we push the current index onto the stack. Otherwise, we update the answer to be the difference between the current index and the current stack top\\'s value\\n\\n## Example\\n\\nLets use the second example, where `s = \")()())\"`\\n\\nFirst, we push `-1` onto the stack since that the last valid location so far\\n\\n* i = 0\\nStack = [-1] <-- TOP\\nAns = 0\\n\\n`s[0] = \\')\\'`, so we pop off of the stack. Since it is empty now, we push `i = 0` onto the stack\\n\\n* i = 1\\nStack = [0] <-- TOP\\nAns = 0\\n\\n`s[1] = \\'(\\'`, so we push `i = 1` onto the stack\\n\\n* i = 2\\nStack = [0,1] <-- TOP\\nAns = 0\\n\\n`s[2] = \\')\\'`, so we pop off of the stack (`1`). Then, we update ans to be the max between itself and `i - stack.top() = 2 - 0 = 2`\\n\\n* i = 3\\nStack = [0] <-- TOP\\nAns = 2\\n\\n`s[3] = \\'(\\'`, so push `i = 3` onto the stack\\n\\n* i = 4\\nStack = [0,3] <-- TOP\\nAns = 2\\n\\n`s[4] = \\')\\'`, so we pop off of the stack (`3`). Then, we update ans to be the max between itself and `i - stack.top() = 4 - 0 = 4`\\n\\n* i = 5\\nStack = [0] <-- TOP\\nAns = 4\\n\\n`s[5] = \\')\\'`, so we pop off of the stack (`0`). Since the stack is empty now, then we push `i = 5` onto the stack\\n\\n* Aftermath\\n\\nWe return 4, which is the correct answer\\n\\n**PLEASE UPVOTE IF YOU FIND MY POST HELPFUL!! \\uD83E\\uDD7A\\uD83D\\uDE01**",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```c++\\n#define OPEN_BRACKET \\'(\\'\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        const int n = s.size();\\n        int ans = 0;\\n        stack<int> brackets;\\n        brackets.push(-1);\\n        for (int i = 0; i < n; i++) {\\n            if (s[i] == OPEN_BRACKET)\\n                brackets.push(i);\\n            else {\\n                brackets.pop();\\n                if (brackets.empty())\\n                    brackets.push(i);\\n                else\\n                    ans = max(ans, i - brackets.top());\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832087,
                "title": "o-n-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(st.empty()) st.push(i);\\n            else{\\n                if(s[i]==\\'(\\') st.push(i);\\n                else{\\n                    if(s[st.top()]==\\'(\\') st.pop();\\n                    else st.push(i);\\n                }\\n            }\\n        }\\n        int ans;\\n        if(!st.empty())\\n         ans=n-1 - st.top();\\n        else ans=n;\\n        while(!st.empty()){\\n            int a=st.top();\\n            st.pop();\\n            if(!st.empty())\\n            ans=max(ans,a-st.top() -1);\\n            else ans=max(ans,a-0);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(st.empty()) st.push(i);\\n            else{\\n                if(s[i]==\\'(\\') st.push(i);\\n                else{\\n                    if(s[st.top()]==\\'(\\') st.pop();\\n                    else st.push(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2675471,
                "title": "simple-c-solution-100-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0, close=0;\\n        int maxLen=0;\\n\\t\\t\\n\\t\\t//traversing from left\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){   \\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n\\t\\t\\telse if(close>open){      //from left if closing brackets is greater than openin brackets\\n                close=0;\\n                open=0;\\n            }\\n        }\\n        \\n        open=0,close=0;\\n        \\n\\t\\t//traversing from right\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){\\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n            else if(close<open){     //from right if opening brackets is greater than closing brackets\\n                close=0;\\n                open=0;\\n            }            \\n        }\\n        return maxLen;\\n    }\\n};\\n//please upvote if found helpful\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0, close=0;\\n        int maxLen=0;\\n\\t\\t\\n\\t\\t//traversing from left\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){   \\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n\\t\\t\\telse if(close>open){      //from left if closing brackets is greater than openin brackets\\n                close=0;\\n                open=0;\\n            }\\n        }\\n        \\n        open=0,close=0;\\n        \\n\\t\\t//traversing from right\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n\\t\\t\\t//valid pair of paranthesis if number of opening and closing brackets are equal\\n            if(open==close){\\n                int len=open+close;\\n                maxLen=max(maxLen,len);\\n            }\\n            else if(close<open){     //from right if opening brackets is greater than closing brackets\\n                close=0;\\n                open=0;\\n            }            \\n        }\\n        return maxLen;\\n    }\\n};\\n//please upvote if found helpful\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339817,
                "title": "java-0-ms-simple-explanation-with-tc-sc-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        //We push -1 so that if the whole str is ans then we will get ans by \\'i - st.peek()\\' e.g: \\'(())\\' = 3 - (-1) = 3 + 1 = 4\\n        st.push(-1);\\n        int result = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            //If it\\'s an opening bracket then push in the stack\\n            if(s.charAt(i) == \\'(\\') {\\n                st.push(i);\\n            } else {\\n                \\n                st.pop();\\n                if(st.isEmpty()) {\\n                    //If the stack is empty, push the current index as a base for the next valid substring.\\n                   st.push(i); \\n                } else {\\n                    //If the stack is not empty, then find the length of current valid substring by taking the difference between the current index and top of the stack.\\n                    result = Math.max(result, i - st.peek());\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n//Time Complexity : O(n) where n is the length of string\\n//Space Complexity : O(n) due to stack\\n//Please upvote the solution if you like it.\\n```\\nAlso check out my GitHub repository (https://github.com/Ovaishk/DSA-Problems-for-Placement) for solution to other important DSA Problems !!!",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<Integer>();\\n        \\n        //We push -1 so that if the whole str is ans then we will get ans by \\'i - st.peek()\\' e.g: \\'(())\\' = 3 - (-1) = 3 + 1 = 4\\n        st.push(-1);\\n        int result = 0;\\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            //If it\\'s an opening bracket then push in the stack\\n            if(s.charAt(i) == \\'(\\') {\\n                st.push(i);\\n            } else {\\n                \\n                st.pop();\\n                if(st.isEmpty()) {\\n                    //If the stack is empty, push the current index as a base for the next valid substring.\\n                   st.push(i); \\n                } else {\\n                    //If the stack is not empty, then find the length of current valid substring by taking the difference between the current index and top of the stack.\\n                    result = Math.max(result, i - st.peek());\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n\\n//Time Complexity : O(n) where n is the length of string\\n//Space Complexity : O(n) due to stack\\n//Please upvote the solution if you like it.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2070202,
                "title": "js-ts-dynamic-programming-solution-explained",
                "content": "<h2>Dynamic programming with tabulation.</h2>\\n\\n1. <a href=\"#algo\">Algorithm</a>\\n2. <a href=\"#javascript-solution\">JavaScript solution</a>\\n3. <a href=\"#typescript-solution\">TypeScript solution</a>\\n\\n<h3>Intro</h3>\\n\\nLet\\'s say we have a string: \\' ( ) ( ( ) ( ) ) \\'.\\nThe resulting array we got using this approach looks like this (**only the last row** actually):\\n\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>1</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>3</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td>5</td>\\n\\t\\t<td>6</td>\\n\\t\\t<td>7</td>\\n\\t\\t<td> - an index</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td> - a given string</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td>8</td>\\n\\t\\t<td> - a dynamic programming tabulation</td>\\n\\t</tr>\\n</table>\\n\\nThe numbers in **dp** indicate the length of the valid parentheses substring ending at the corresponding index.\\nThe largest number of the **dp** will indicate *the length of the longest parentheses substring*.\\n\\n<h3 id=\"algo\">Algorithm</h3>\\n\\n1. Initialise the **dp** array with zeros. The length of the array equals to the length of the string (e.g. length = 8).\\n\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0</td>\\n\\t</tr>\\n</table>\\n\\n2. We will be checking two adjacent charachters of  the given string (**s[ i - 1 ]** and **s[ i ]**, for i = 1, 2, ... , length-1).\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td><b>[ 0 ]</b></td>\\n\\t\\t<td><b>[ 1 ]</b></td>\\n\\t\\t<td>2</td>\\n\\t\\t<td>...</td>\\n\\t\\t<td rowspan=\"2\"> => </td>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td><b>[ 1 ]</b></td>\\n\\t\\t<td><b>[ 2 ]</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td rowspan=\"2\"> => </td>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ 2 ]</b></td>\\n\\t\\t<td><b>[ 3 ]</b></td>\\n\\t\\t<td>...</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td><b>[ ) ]</b></td>\\n\\t\\t<td>(</td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>(</td>\\n\\t\\t<td><b>[ ) ]</b></td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td><b>[ ( ]</b></td>\\n\\t\\t<td>...</td>\\n\\t</tr>\\n</table>\\n\\n* We will take into consideration only **two conditions**:\\n\\t*a.*  s[ i - 1 ] == \\' **(** \\' && s[ i ] == \\' **)** \\';\\n\\t*b.* s[ i - 1 ] == \\' **)** \\' && s[ i ] == \\' **)** \\'.\\n\\n3. *Condition a.* means that we have found a valid substring \\' **( )** \\' of parentheses of length 2. So we can put the length = 2 of that substring in the **dp** at index i: **dp[ i ] = 2**\\n\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td><b>0</b></td>\\n\\t\\t<td><b>1</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td><b>(</b></td>\\n\\t\\t<td><b>)</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2</td>\\n\\t</tr>\\n</table>\\n\\n* But it could be a subsequent valid substring (e.g. **i = 5 to 6** - this valid substing is a part of the bigger valid substring **i = 3 to 6**). So we also have to check the value in **dp[ i - 2 ]**, and the resulting equation for *condition a.* will be **dp[ i ] = 2 + dp[ i - 2]**.\\n\\nFor **i = 4** and next **i = 6** (i = 5 does not fall under *condition a.*)\\n<table>\\n\\t<tr>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>2</td>\\n\\t\\t<td><b>3</b></td>\\n\\t\\t<td><b>4</b></td>\\n\\t\\t<td rowspan=\"3\"> => </td>\\n\\t\\t<td><b>i</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>4</td>\\n\\t\\t<td><b>5</b></td>\\n\\t\\t<td><b>6</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>(</td>\\n\\t\\t<td><b>(</b></td>\\n\\t\\t<td><b>)</b></td>\\n\\t\\t<td><b>s</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td>)</td>\\n\\t\\t<td><b>(</b></td>\\n\\t\\t<td><b>)</b></td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ 0 ]</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>0 + 2 = 2</td>\\n\\t\\t<td><b>dp</b></td>\\n\\t\\t<td>...</td>\\n\\t\\t<td><b>[ 2 ]</b></td>\\n\\t\\t<td>0</td>\\n\\t\\t<td>2 + 2 = 4</td>\\n\\t</tr>\\n</table>\\n\\n4. *Condition b.* s[ i - 1 ] == \\' **)** \\' && s[ i ] == \\' **)** \\' means that **s[ i ]** could be a closing parentheses of the pattern \\' **(** ( ... ) **)** \\'.\\nIn this case we already checked **s[ i - 1 ]** at the previous step and it could be a part of the previous valid or invalid substring, let\\'s call it **sub<sub>i-1</sub>**. Also we have already put some value in **dp[ i - 1 ]**. Thus, only **s[ i ]** needs further investigation.\\n* We have to check if the character before **sub<sub>i-1</sub>** equals \\' **(** \\'. To do that we subtract the value of **dp[ i - 1 ]** (the length of **sub<sub>i-1</sub>**) plus 1, from **i** to get the resulting equation **s[ i - (dp[ i - 1 ] + 1) ]**.\\n* In this example, for **i = 7** we have to check the character at **i = 2**: s[ 7 - (4 + 1) ] => s[ 2 ] == \\' **(** \\', if ```true``` we will put in **dp[ i ] = 2 + dp [ i - 1] + dp[ i - (dp[ i - 1] + 2) ]**. The last term dp[ i - (dp[ i - 1] + 2) ] appears because we also have to check if there a valid substring just before the considering substring.\\nThat is why in the considering example we get **8** at **dp[ 7 ]**: **2** (when we found the opening parentheses at i = 2) + **4** (the length of the **sub<sub>i-1</sub>** as it is valid) + **2** (the substring at i = 1 is also valid) = **8**.\\n\\n<h3 id=\"javascript-solution\">JavaScript</h3>\\n\\n```\\nfunction longestValidParentheses(s) {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength = 0;\\n    let dp = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```\\n\\n<h3 id=\"typescript-solution\">TypeScript</h3>\\n\\n```\\nfunction longestValidParentheses(s: string): number {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength: number = 0;\\n    let dp: number[] = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Dynamic Programming"
                ],
                "code": "```true```\n```\\nfunction longestValidParentheses(s) {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength = 0;\\n    let dp = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```\n```\\nfunction longestValidParentheses(s: string): number {\\n\\t// maxLength variable is used to monitor the maximum length of the valid substring\\n\\t// every time we fall in condition a. or b.\\n\\t// by using it we don\\'t need to find the maximum value in the resulting dp array\\n    let maxLength: number = 0;\\n    let dp: number[] = new Array(s.length).fill(0);\\n    \\n    for (let i = 1; i < s.length; i++) {\\n        if (s[i - 1] === \\'(\\' && s[i] === \\')\\') { // - condition a.\\n            dp[i] = 2 + (dp[i - 2] || 0); // - dp[i-2] can return undefined, if so we will add zero instead\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n        if (\\n            s[i - 1] === \\')\\' &&\\n            s[i] === \\')\\' &&\\n            s[i - dp[i - 1] - 1] === \\'(\\' // - condition b.\\n        ) {\\n            dp[i] = 2 + dp[i - 1] + (dp[i - dp[i - 1] - 2] || 0);\\n            maxLength = Math.max(maxLength, dp[i]);\\n        }\\n    }\\n    return maxLength;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2068207,
                "title": "java-fastest-solution-tc-100-sc-99-3-solution",
                "content": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int left = 0, right = 0, maxlength = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * right);\\n            } else if (right >= left) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        left = right = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            \\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * left);\\n            } else if (left >= right) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        return maxlength;\\n    }\\n}\\n```\\n\\n**Using Stack**\\n\\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack <Integer> stack = new Stack<>();\\n        int result = 0;\\n        stack.push(-1);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\')\\' && stack.size() > 1 && s.charAt(stack.peek()) == \\'(\\') {\\n                stack.pop();\\n                result = Math.max(result, i - stack.peek());\\n            } else {\\n                stack.push(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n**Using DP**\\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int[] dp = new int[s.length()];\\n        int result = 0;\\n        int leftCount = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                leftCount++;\\n            } else if (leftCount > 0){\\n                dp[i] = dp[i - 1] + 2;\\n                dp[i] += (i - dp[i]) >= 0 ? dp[i - dp[i]] : 0;\\n                result = Math.max(result, dp[i]);\\n                leftCount--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int left = 0, right = 0, maxlength = 0;\\n        \\n        for (int i = 0; i < s.length(); i++) \\n        {\\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * right);\\n            } else if (right >= left) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        left = right = 0;\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            \\n            if (s.charAt(i) == \\'(\\') left++;\\n            else right++;\\n            \\n            if (left == right) {\\n                maxlength = Math.max(maxlength, 2 * left);\\n            } else if (left >= right) {\\n                left = right = 0;\\n            }\\n        }\\n        \\n        return maxlength;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack <Integer> stack = new Stack<>();\\n        int result = 0;\\n        stack.push(-1);\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\')\\' && stack.size() > 1 && s.charAt(stack.peek()) == \\'(\\') {\\n                stack.pop();\\n                result = Math.max(result, i - stack.peek());\\n            } else {\\n                stack.push(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int longestValidParentheses(String s) {\\n        int[] dp = new int[s.length()];\\n        int result = 0;\\n        int leftCount = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                leftCount++;\\n            } else if (leftCount > 0){\\n                dp[i] = dp[i - 1] + 2;\\n                dp[i] += (i - dp[i]) >= 0 ? dp[i - dp[i]] : 0;\\n                result = Math.max(result, dp[i]);\\n                leftCount--;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914266,
                "title": "simple-java-solution-o-n-time-one-stack",
                "content": "\\n```\\npublic int longestValidParentheses(String s) {\\n        if(s.length() == 0) return 0; //If given String is Empty, then return 0\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1); //push value -1 to stack\\n        \\n        int requiredLength = 0;\\n        \\n        for(int i =0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n                if(stack.isEmpty()){\\n                    stack.push(i);\\n                }else{\\n                   requiredLength = Math.max(requiredLength, i - stack.peek());\\n                }\\n            }\\n        }\\n        \\n        return requiredLength;\\n    }\\n```\\nIf you like this solution, please do upvote it",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic int longestValidParentheses(String s) {\\n        if(s.length() == 0) return 0; //If given String is Empty, then return 0\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1); //push value -1 to stack\\n        \\n        int requiredLength = 0;\\n        \\n        for(int i =0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            \\n            if(c == \\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n                if(stack.isEmpty()){\\n                    stack.push(i);\\n                }else{\\n                   requiredLength = Math.max(requiredLength, i - stack.peek());\\n                }\\n            }\\n        }\\n        \\n        return requiredLength;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646136,
                "title": "java-stack-soln-easy-to-understand-code",
                "content": "\\'\\'\\'\\n  public int longestValidParentheses(String s) {\\n      \\n          Stack<Integer> st =new Stack<>();\\n          st.push(-1);\\n          int max=0;\\n          char a[]=s.toCharArray();\\n          \\n          for(int i=0;i<s.length();i++)\\n            {\\n                 if(a[i]==\\'(\\')st.push(i);\\n                 else{\\n                     st.pop();\\n                     \\n                     if(st.empty()) st.push(i);\\n                     else max=Math.max(max,i-st.peek());\\n                     }\\n            }\\n          return max;   \\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "\\'\\'\\'\\n  public int longestValidParentheses(String s) {\\n      \\n          Stack<Integer> st =new Stack<>();\\n          st.push(-1);\\n          int max=0;\\n          char a[]=s.toCharArray();\\n          \\n          for(int i=0;i<s.length();i++)\\n            {\\n                 if(a[i]==\\'(\\')st.push(i);\\n                 else{\\n                     st.pop();\\n                     \\n                     if(st.empty()) st.push(i);\\n                     else max=Math.max(max,i-st.peek());\\n                     }\\n            }\\n          return max;   \\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1523930,
                "title": "javascript-easy-stack-with-comments",
                "content": "```\\nvar longestValidParentheses = function(s) {\\n    if(s.length === 0) return 0;\\n    \\n    let stack = [-1];\\n    let max = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        //push into stack if opening paran\\n        if(s[i] === \\'(\\') {\\n            stack.push(i);\\n        } else {\\n            // pop out if it\\'s an closing paran\\n            stack.pop();\\n            \\n            // if we don\\'t hav anything in stack, push this new index\\n            if(stack.length === 0) {\\n                stack.push(i);\\n            } else {\\n                // i - stack[stack.length - 1] is length of longest substr\\n                max = Math.max(max, i - stack[stack.length - 1]);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar longestValidParentheses = function(s) {\\n    if(s.length === 0) return 0;\\n    \\n    let stack = [-1];\\n    let max = 0;\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        //push into stack if opening paran\\n        if(s[i] === \\'(\\') {\\n            stack.push(i);\\n        } else {\\n            // pop out if it\\'s an closing paran\\n            stack.pop();\\n            \\n            // if we don\\'t hav anything in stack, push this new index\\n            if(stack.length === 0) {\\n                stack.push(i);\\n            } else {\\n                // i - stack[stack.length - 1] is length of longest substr\\n                max = Math.max(max, i - stack[stack.length - 1]);\\n            }\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428156,
                "title": "time-complexity-o-n-space-complexity-o-1-clear-with-explaination",
                "content": "**time complexity:o(n)\\nspace complexity:o(1)**\\nAn opening bracket increase the opens\\nBracket increase the counter of the end brackets,\\nAt each stage I compare if the masses are equal,\\n If so then the sequence so far is correct - So I compare the length of the sequence with the maximum.\\nAt each stage I also check if the brackets are larger than the openers -\\nI mean an incorrect sequence so we initialize the amount of openers and closers by 0\\nFor the first time I went from beginning to end\\nAnd in a second from the end to the beginning\\nEnjoy...\\n\\n```\\n```\\n```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int start = 0, end = 0, max = 0, i = 0;\\n\\n        for (; i < s.length(); i++)\\n        {\\n            s[i] == \\')\\' ? end++ : start++;\\n\\n            if (end == start)\\n            {\\n                if(max<2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n        \\n        start = 0, end = 0;\\n        \\n        for (i = s.length()-1 ; i >= 0 ; i--)\\n        {\\n            s[i] == \\'(\\' ? end++ : start++;\\n            \\n            if (end == start)\\n            {\\n                if(max < 2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n         return max;\\n    }        \\n};\\n \\n```\\n```\\n```\\n",
                "solutionTags": [],
                "code": "```\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int start = 0, end = 0, max = 0, i = 0;\\n\\n        for (; i < s.length(); i++)\\n        {\\n            s[i] == \\')\\' ? end++ : start++;\\n\\n            if (end == start)\\n            {\\n                if(max<2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n        \\n        start = 0, end = 0;\\n        \\n        for (i = s.length()-1 ; i >= 0 ; i--)\\n        {\\n            s[i] == \\'(\\' ? end++ : start++;\\n            \\n            if (end == start)\\n            {\\n                if(max < 2 * start)\\n                     max = 2 * start;\\n            }\\n            else if (end > start)\\n                end = start = 0;\\n        }\\n         return max;\\n    }        \\n};\\n \\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294217,
                "title": "python3-o-n-runtime-o-1-space-self-explananatory-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open_=0\\n        close=0\\n        ans1=0\\n        for i in s:\\n            if i==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans1=max(close*2,ans1)\\n            elif close>open_:\\n                open_=close=0\\n        ans2=0\\n        open_=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans2=max(ans2,2*open_)\\n            elif open_>close:\\n                open_=close=0\\n        return max(ans1,ans2)\\n```\\n\\n\\n**Please Upvote if you find it helpful !!!  ... :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        open_=0\\n        close=0\\n        ans1=0\\n        for i in s:\\n            if i==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans1=max(close*2,ans1)\\n            elif close>open_:\\n                open_=close=0\\n        ans2=0\\n        open_=close=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                open_+=1\\n            else:\\n                close+=1\\n            if open_==close:\\n                ans2=max(ans2,2*open_)\\n            elif open_>close:\\n                open_=close=0\\n        return max(ans1,ans2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294166,
                "title": "c-solution",
                "content": "Method 1\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int close=0,open=0,max_len=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close>open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        close=0;\\n        open=0;\\n         for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close<open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```\\nMethod 2-DP Based,100% fast\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int>v(s.size()+1,0);\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==\\')\\'){// when s[i]==\\')\\' and one index before it is\\'(\\' than v[i] ie no of valid parenthesis upto index i is v[i-2]+2\\n                if(s[i-1]==\\'(\\'){\\n                    v[i]=2+((i-2)>=0?v[i-2]:0);\\n                }\\n                else if(i-v[i-1]>0 && s[i-v[i-1]-1]==\\'(\\'){\\n                    v[i]=2+v[i-1]+((i-v[i-1]-2)>=0?v[i-v[i-1]-2]:0);\\n                \\n                }\\n            }\\n        }\\n        return *max_element(v.begin(),v.end());\\n        \\n    }\\n};\\n```\\n\\ndo upvote if you like it......\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int close=0,open=0,max_len=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close>open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        close=0;\\n        open=0;\\n         for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\'){\\n                open++;\\n            }\\n            else{\\n                close++;\\n            }\\n            if(close==open){\\n                max_len=max(max_len,2*open);\\n            }\\n            else if(close<open){\\n                open=0;\\n                close=0;\\n            }\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int>v(s.size()+1,0);\\n        for(int i=1;i<s.length();i++){\\n            if(s[i]==\\')\\'){// when s[i]==\\')\\' and one index before it is\\'(\\' than v[i] ie no of valid parenthesis upto index i is v[i-2]+2\\n                if(s[i-1]==\\'(\\'){\\n                    v[i]=2+((i-2)>=0?v[i-2]:0);\\n                }\\n                else if(i-v[i-1]>0 && s[i-v[i-1]-1]==\\'(\\'){\\n                    v[i]=2+v[i-1]+((i-v[i-1]-2)>=0?v[i-v[i-1]-2]:0);\\n                \\n                }\\n            }\\n        }\\n        return *max_element(v.begin(),v.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151578,
                "title": "o-n-c-straight-forward-solution-4ms-beats-100",
                "content": "```\\n    int longestValidParentheses(string str) {            \\n    int l = str.length();     \\n    stack<int> s; s.push(-1);           //  bottom mark     \\n    int longLen = 0, newLen;            //  Initialize longest length \\n    for (int i=0; i<l; i++) {           //  Scan the given string from left            \\n        if (str[i] == \\'(\\') s.push(i);   //  for every \\'(\\', pushing index of it into stack \\n        else {                    \\n            s.pop();                    //  removing the current top value \\n            if (!s.empty()) {                \\n                newLen = i - s.top();                \\n                if(newLen > longLen) longLen = newLen;                \\n            } \\n            else s.push(i);\\n        }\\n    } \\n    return longLen;        \\n    }\\n\\t\\t```\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\n    int longestValidParentheses(string str) {            \\n    int l = str.length();     \\n    stack<int> s; s.push(-1);           //  bottom mark     \\n    int longLen = 0, newLen;            //  Initialize longest length \\n    for (int i=0; i<l; i++) {           //  Scan the given string from left            \\n        if (str[i] == \\'(\\') s.push(i);   //  for every \\'(\\', pushing index of it into stack \\n        else {                    \\n            s.pop();                    //  removing the current top value \\n            if (!s.empty()) {                \\n                newLen = i - s.top();                \\n                if(newLen > longLen) longLen = newLen;                \\n            } \\n            else s.push(i);\\n        }\\n    } \\n    return longLen;        \\n    }\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 14316,
                "title": "c-o-n-time-and-o-1-space",
                "content": "Let '(' equals to 1 and ')' equals to -1,if s.substr(i,j-i+1) is a valid parentheses,then the sum of this substring should be 0.\\n\\n     int longestValidParentheses(string s) {\\n            int n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int i=0,j=n-1;\\n            while(s[i]==')')\\n                i++;\\n            while(s[j]=='(')\\n                j--;\\n            s=s.substr(i,j-i+1);  \\n            n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int ans=0,maxlen=0,pos=0,maxlen1=0;\\n            for(i=0;i<n;i++)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans<0)\\n                {\\n                    pos=i+1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen=max(maxlen,i-pos+1);\\n            }\\n            ans=0;\\n            pos=n-1;\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans>0)\\n                {\\n                    pos=i-1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen1=max(maxlen1,pos-i+1);\\n            }\\n            ans= max(maxlen,maxlen1);\\n            return ans;\\n    }",
                "solutionTags": [],
                "code": "Let '(' equals to 1 and ')' equals to -1,if s.substr(i,j-i+1) is a valid parentheses,then the sum of this substring should be 0.\\n\\n     int longestValidParentheses(string s) {\\n            int n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int i=0,j=n-1;\\n            while(s[i]==')')\\n                i++;\\n            while(s[j]=='(')\\n                j--;\\n            s=s.substr(i,j-i+1);  \\n            n=s.length();\\n            if(n<=1)\\n                return 0;\\n            int ans=0,maxlen=0,pos=0,maxlen1=0;\\n            for(i=0;i<n;i++)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans<0)\\n                {\\n                    pos=i+1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen=max(maxlen,i-pos+1);\\n            }\\n            ans=0;\\n            pos=n-1;\\n            for(i=n-1;i>=0;i--)\\n            {\\n                int tmp=s[i]=='('?1:-1;\\n                ans+=tmp;\\n                if(ans>0)\\n                {\\n                    pos=i-1;\\n                    ans=0;\\n                }\\n                else if(ans==0)\\n                    maxlen1=max(maxlen1,pos-i+1);\\n            }\\n            ans= max(maxlen,maxlen1);\\n            return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14364,
                "title": "share-my-java-solution-with-stack-and-dp",
                "content": "Stack:\\n    \\n        public int longestValidParentheses(String s) {\\n            Stack<Integer> st = new Stack<>();\\n            int max = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==')'&&!st.isEmpty()&&s.charAt(st.peek())=='('){\\n                    st.pop();\\n                    max = Math.max(max, i-((st.isEmpty())?-1:st.peek()));\\n                }\\n                else    st.push(i);\\n            }\\n            return max;\\n        }\\n\\nDP:\\n\\n    public int longestValidParentheses(String s) {\\n        /*max[i] = j means subsequence index i-j is longest valid Parentheses*/\\n        int[] max = new int[s.length()+1];\\n        max[s.length()] = s.length();\\n        int sum = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(max[i+1]!=i+1){\\n                if(max[i+1]+1<s.length()&&s.charAt(i)=='('&&s.charAt(max[i+1]+1)==')'){\\n                    max[i] = (max[i+1]+2<s.length()+1&&max[max[i+1]+2]!=max[i+1]+2)?max[max[i+1]+2]:max[i+1]+1;\\n                }\\n                else    max[i] = i;\\n            }\\n            else if(i+1<s.length()&&s.charAt(i+1)==')'&&s.charAt(i)=='('){\\n                max[i] = (i+2<s.length()+1&&max[i+2]!=i+2)?max[i+2]:i+1;\\n            }\\n            else    max[i] = i;\\n            sum = Math.max(sum, max[i]-i+1);\\n        }\\n        return (sum==1)?0:sum;\\n    }",
                "solutionTags": [
                    "Stack"
                ],
                "code": "Stack:\\n    \\n        public int longestValidParentheses(String s) {\\n            Stack<Integer> st = new Stack<>();\\n            int max = 0;\\n            for(int i=0;i<s.length();i++){\\n                if(s.charAt(i)==')'&&!st.isEmpty()&&s.charAt(st.peek())=='('){\\n                    st.pop();\\n                    max = Math.max(max, i-((st.isEmpty())?-1:st.peek()));\\n                }\\n                else    st.push(i);\\n            }\\n            return max;\\n        }\\n\\nDP:\\n\\n    public int longestValidParentheses(String s) {\\n        /*max[i] = j means subsequence index i-j is longest valid Parentheses*/\\n        int[] max = new int[s.length()+1];\\n        max[s.length()] = s.length();\\n        int sum = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(max[i+1]!=i+1){\\n                if(max[i+1]+1<s.length()&&s.charAt(i)=='('&&s.charAt(max[i+1]+1)==')'){\\n                    max[i] = (max[i+1]+2<s.length()+1&&max[max[i+1]+2]!=max[i+1]+2)?max[max[i+1]+2]:max[i+1]+1;\\n                }\\n                else    max[i] = i;\\n            }\\n            else if(i+1<s.length()&&s.charAt(i+1)==')'&&s.charAt(i)=='('){\\n                max[i] = (i+2<s.length()+1&&max[i+2]!=i+2)?max[i+2]:i+1;\\n            }\\n            else    max[i] = i;\\n            sum = Math.max(sum, max[i]-i+1);\\n        }\\n        return (sum==1)?0:sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3928166,
                "title": "easy-java-solution-beats-95-submissions-super-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max =0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n\\n                if(!stack.isEmpty()){\\n                    max = Math.max(max,i-stack.peek());\\n                }\\n                else{\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max =0;\\n\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                stack.push(i);\\n            }else{\\n                stack.pop();\\n\\n                if(!stack.isEmpty()){\\n                    max = Math.max(max,i-stack.peek());\\n                }\\n                else{\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780664,
                "title": "python-97-04-faster-two-approaches-o-1-and-o-n-space",
                "content": "**Brute Force O(n) Space:**\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st=[-1]\\n        m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            else:\\n                st.pop()\\n                if not st: #if -1 is popped\\n                    st.append(i)\\n                else:\\n                    m=max(m,i-st[-1])\\n        return m\\n```\\n**Optimized Solution O(1) Space:**\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif r>l: #invalid case\\n                l=r=0\\n        l=r=0\\n# We are traversing right to left for the test case where opening brackets are more than closing brackets. eg: s = \"(()\"\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif l>r: #invalid case\\n                l=r=0  \\n        return m\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st=[-1]\\n        m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            else:\\n                st.pop()\\n                if not st: #if -1 is popped\\n                    st.append(i)\\n                else:\\n                    m=max(m,i-st[-1])\\n        return m\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=m=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif r>l: #invalid case\\n                l=r=0\\n        l=r=0\\n# We are traversing right to left for the test case where opening brackets are more than closing brackets. eg: s = \"(()\"\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r: #for balanced parantheses\\n                m=max(m,l+r)\\n            elif l>r: #invalid case\\n                l=r=0  \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761737,
                "title": "unique-sol-c-uses-stack-dp-w-8-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution is very unique.\\n\\nUse a stack for int when s[i]=\\'(\\' pushing into the stack otherwise popping x from the top of the stack if the stack is not empty. Compute the valid length ending at the index i storing into dp[i] with the relation dp[i]=i-x+1+dp[x-1] !!!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n8 test cases\\n```\\n\"(()\"\\n\")()())\"\\n\"\"\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n \"()(()\"\\n \")()())\"\\n \"()(())\"\\n \")()())\"\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        if (n<2) return 0;\\n        stack<int> st;\\n        vector<int> dp(n, 0);\\n       \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if (s[i]==\\'(\\') {\\n                st.push(i);\\n            }\\n            else{ //s[i]=\\')\\'\\n                if (!st.empty()){\\n                    int x=st.top();\\n                    dp[i]=i-x+1;//substring s[x:i+1] is valid\\n                    if (x>=1) dp[i]+=dp[x-1];//concatenate with substring\\n                //    cout<<i<<\"->\"<<x<<\":\"<<dp[i]<<endl;\\n                    st.pop();\\n                }\\n            }\\n            ans=max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\n\"(()\"\\n\")()())\"\\n\"\"\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\"\\n \"()(()\"\\n \")()())\"\\n \"()(())\"\\n \")()())\"\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        if (n<2) return 0;\\n        stack<int> st;\\n        vector<int> dp(n, 0);\\n       \\n        int ans=0;\\n        for(int i=0; i<n; i++){\\n            if (s[i]==\\'(\\') {\\n                st.push(i);\\n            }\\n            else{ //s[i]=\\')\\'\\n                if (!st.empty()){\\n                    int x=st.top();\\n                    dp[i]=i-x+1;//substring s[x:i+1] is valid\\n                    if (x>=1) dp[i]+=dp[x-1];//concatenate with substring\\n                //    cout<<i<<\"->\"<<x<<\":\"<<dp[i]<<endl;\\n                    st.pop();\\n                }\\n            }\\n            ans=max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3587753,
                "title": "stack-c-very-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int ans = 0, n = s.length();\\n        vector<int> v;\\n        for(int i = 0; i < n; i++){\\n            if(s[i]==\\'(\\'){\\n                v.push_back(i);\\n            }else{\\n                if(!v.empty() && s[v.back()]==\\'(\\')v.pop_back();\\n                else v.push_back(i);\\n            }\\n        }\\n        if(v.empty()){\\n            return n;\\n        }\\n            // cout<<n<<\" \";\\n        while(!v.empty()){\\n            ans = max(ans,n-v.back()-1);\\n            n = v.back();\\n            // cout<<n<<\" \";\\n            v.pop_back();\\n        }\\n        return ans = max(ans,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int ans = 0, n = s.length();\\n        vector<int> v;\\n        for(int i = 0; i < n; i++){\\n            if(s[i]==\\'(\\'){\\n                v.push_back(i);\\n            }else{\\n                if(!v.empty() && s[v.back()]==\\'(\\')v.pop_back();\\n                else v.push_back(i);\\n            }\\n        }\\n        if(v.empty()){\\n            return n;\\n        }\\n            // cout<<n<<\" \";\\n        while(!v.empty()){\\n            ans = max(ans,n-v.back()-1);\\n            n = v.back();\\n            // cout<<n<<\" \";\\n            v.pop_back();\\n        }\\n        return ans = max(ans,n);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3281987,
                "title": "look-at-it-best-python3-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st = [-1]\\n        maxlength = 0\\n        for i in range(len(s)):\\n            t = st[-1]\\n            if t != -1 and s[i] == \\')\\' and s[t] == \\'(\\':\\n                st.pop()\\n                maxlength = max(maxlength, i - st[-1])\\n            else:\\n                st.append(i)\\n        return maxlength\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        st = [-1]\\n        maxlength = 0\\n        for i in range(len(s)):\\n            t = st[-1]\\n            if t != -1 and s[i] == \\')\\' and s[t] == \\'(\\':\\n                st.pop()\\n                maxlength = max(maxlength, i - st[-1])\\n            else:\\n                st.append(i)\\n        return maxlength\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243659,
                "title": "dynamic-programming-approach-to-longest-valid-parentheses-substring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use dynamic programming. Let dp[i] be the length of the longest valid parentheses substring ending at index i. We can observe the following:\\n\\n1. If s[i] = \\'(\\', there can be no valid substring ending at index i, so dp[i] = 0.\\n2. If s[i] = \\')\\', we have two cases:\\na. If s[i-1] = \\'(\\', then dp[i] = dp[i-2] + 2.\\nb. If s[i-1] = \\')\\' and s[i-dp[i-1]-1] = \\'(\\', then dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2.\\n\\nIn case (2a), we add 2 to dp[i-2] because we have a matching pair of parentheses at indices i-1 and i, and we can extend the valid substring ending at index i-2 (if there is one) to include this pair.\\n\\nIn case (2b), we add dp[i-1] to account for the length of the valid substring ending at index i-1, and dp[i-dp[i-1]-2] to account for any valid substring that starts before the opening bracket of the current substring. For example, consider the string \"(()())\". When we reach the second closing bracket at index 5, we can extend the valid substring ending at index 4 (which has length 2) to include the current pair of parentheses, giving us a length of 4. However, we also need to account for the valid substring that starts before the opening bracket of this substring, which is the substring that ends at index 1 (which has length 2).\\n\\nFinally, the length of the longest valid parentheses substring is the maximum value in the dp array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize the dp array with zeros, and the maximum length variable max_len with 0.\\n- Iterate over the indices of the input string from left to right.\\n- If s[i] = \\')\\', check if the previous character s[i-1] is \\'(\\'. If it is, set dp[i] = dp[i-2] + 2.\\n- Otherwise, check if s[i-dp[i-1]-1] is \\'(\\'. If it is, set dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2.\\n- Update max_len with the maximum value in the dp array.\\n- Return max_len.\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), where n is the length of the input string.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack = [-1]\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    max_len = max(max_len, i - stack[-1])\\n        return max_len\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        stack = [-1]\\n        max_len = 0\\n        for i in range(len(s)):\\n            if s[i] == \\'(\\':\\n                stack.append(i)\\n            else:\\n                stack.pop()\\n                if not stack:\\n                    stack.append(i)\\n                else:\\n                    max_len = max(max_len, i - stack[-1])\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097669,
                "title": "c-easy-solution-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            if(s[i]==\\')\\'){\\n                st.pop();\\n                if(st.size()==0){\\n                    st.push(i);\\n                }\\n                else{\\n                    int c=i-st.top();\\n                    maxi=max(c,maxi);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            if(s[i]==\\')\\'){\\n                st.pop();\\n                if(st.size()==0){\\n                    st.push(i);\\n                }\\n                else{\\n                    int c=i-st.top();\\n                    maxi=max(c,maxi);\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927108,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int t=st.top();\\n            if(t!=-1 &&s[i]==\\')\\'&& s[t]==\\'(\\')\\n            {\\n                st.pop();\\n                ans=max(ans, i-st.top());\\n            }\\n            else\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int t=st.top();\\n            if(t!=-1 &&s[i]==\\')\\'&& s[t]==\\'(\\')\\n            {\\n                st.pop();\\n                ans=max(ans, i-st.top());\\n            }\\n            else\\n                st.push(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891153,
                "title": "c-stack-solution",
                "content": "\\n# Approach\\nstack based\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }else{\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(i);\\n                }\\n                int sz=i-st.top();\\n                ans=max(ans,sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int ans=0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }else{\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(i);\\n                }\\n                int sz=i-st.top();\\n                ans=max(ans,sz);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862929,
                "title": "5-lines-c-easy-solution-time-o-n-space-o-n",
                "content": "just find the distance between current index and last inserted index of stack\\n```\\n  int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int ans=0,i=0;\\n        for(st.push(-1);i<s.size();i++)\\n        {\\n            ans=max(ans,abs(i-st.top())-1);\\n            (st.size()>1&&s[st.top()]==\\'(\\'&&s[i]==\\')\\')?st.pop():st.push(i);\\n        }\\n        return max(ans,abs(st.top()-(int)s.size())-1);\\n    }\\n```\\nPls UPVOTE the solution if u like",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n  int longestValidParentheses(string s) {\\n        stack<int> st;\\n        int ans=0,i=0;\\n        for(st.push(-1);i<s.size();i++)\\n        {\\n            ans=max(ans,abs(i-st.top())-1);\\n            (st.size()>1&&s[st.top()]==\\'(\\'&&s[i]==\\')\\')?st.pop():st.push(i);\\n        }\\n        return max(ans,abs(st.top()-(int)s.size())-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724360,
                "title": "python-o-n-solution-easy",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=c=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l<r:\\n                l=r=0\\n        l=r=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l>r:\\n                l=r=0\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        l=r=c=0\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l<r:\\n                l=r=0\\n        l=r=0\\n        for i in range(len(s)-1,-1,-1):\\n            if s[i]==\\'(\\':\\n                l+=1\\n            else:\\n                r+=1\\n            if l==r:\\n                c=max(c,l+r)\\n            elif l>r:\\n                l=r=0\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2502302,
                "title": "python-very-simple-o-n-with-explanation-and-visualization",
                "content": "There are only two ways a string of parentheses can be invalid:\\n* There are too many closing parentheses i.e. `())`\\n* There are not enough closing parentheses i.e. `(()`\\n\\nThus, if we find a matching closing parentheses for a given open parentheses (by using a stack), *that string **MUST** be valid.*.  Strings are invalid *only* when a closing parentheses cannot be matched correctly. This means that for `(...)`, the `...` contained within will **ALWAYS** be valid, otherwise the closing parentheses `)` would not be matched to the open parentheses `(` to begin with. If this doesn\\'t make sense, I suggest trying to come up with an example to counter that assumption - it will become clear it is true.\\n\\nWe can structure our algorithm to assume everything is invalid, then scan through the string, marking substrings as valid whenever a closing parentheses is matched to an opening parentheses. \\n\\nHere\\'s how it works:\\n\\n1. Initialize a boolean array `validSections` with `length == s.length`, where `validSections[i]` is `true` when `s[i]` is a part of a valid string of parentheses.\\n2.  Scan the string.\\n\\ta. When we encounter an opening parentheses `(`, push its `index` onto the `stack`. \\n\\tb. When we encounter a closing parentheses `)`, pop the last `index` off the stack (it is the `index` of the matching opening parentheses). Set `validSections[currentIndex] = true` and `validSections[poppedIndex] = true`. Everything between those two indexes will **always** already be marked `true`\\\\*. If the stack has nothing to pop, there is nothing to do (because `validSections` is already initialized to false)\\n3. Count and return the longest unbroken sequence of `true` values in `validSections` \\n```python\\nOPEN, = \\'(\\'\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# STEP 1\\n        validSections = [False] * len(s)\\n\\t\\t# STEP 2\\n        stack = []\\n        for index, c in enumerate(s):\\n            if c == OPEN:\\n                stack.append(index)\\n            else:\\n                if len(stack) > 0:\\n                    validSections[index], validSections[stack.pop()] = True, True\\n         \\n\\t\\t# STEP 3\\n        currentLength = 0\\n        best = 0\\n        for valid in validSections:\\n            if valid:\\n                currentLength += 1\\n            else:\\n                currentLength = 0\\n            if best < currentLength:\\n                best = currentLength\\n        return best\\n```\\nIn essence, this method asynchronously builds knowledge of valid substrings into something that is much more easily digestable. If you add a print statement as it scans over the string, you\\'ll see it slowly build the valid sections:\\nHere\\'s an example for the string `\"(()())))()()()()()((()()()()(()(()\"`. Every time it encounters a `)` with a matching `(`, it will add two `x` to mark that substring as valid. \\n```\\n(()())))()()()()()((()()()()(()(()\\n----------------------------------\\n----------------------------------\\n-xx-------------------------------\\n-xx-------------------------------\\n-xxxx-----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx-xx\\n(()())))()()()()()((()()()()(()(()\\n```\\n\\\\* The reason we can\\'t just keep track of the largest `currentIndex - poppedIndex` is because this would keep track of the largest valid single distinct substring, and not group of valid substrings. i.e. `()()` is two distinct substrings, whereas `(()())` is one.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```python\\nOPEN, = \\'(\\'\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n\\t\\t# STEP 1\\n        validSections = [False] * len(s)\\n\\t\\t# STEP 2\\n        stack = []\\n        for index, c in enumerate(s):\\n            if c == OPEN:\\n                stack.append(index)\\n            else:\\n                if len(stack) > 0:\\n                    validSections[index], validSections[stack.pop()] = True, True\\n         \\n\\t\\t# STEP 3\\n        currentLength = 0\\n        best = 0\\n        for valid in validSections:\\n            if valid:\\n                currentLength += 1\\n            else:\\n                currentLength = 0\\n            if best < currentLength:\\n                best = currentLength\\n        return best\\n```\n```\\n(()())))()()()()()((()()()()(()(()\\n----------------------------------\\n----------------------------------\\n-xx-------------------------------\\n-xx-------------------------------\\n-xxxx-----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx----------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xx------------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxx----------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxx--------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxx------------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx----------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xx------------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxx----------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxx--------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx------\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx---\\nxxxxxx--xxxxxxxxxx--xxxxxxxx-xx-xx\\n(()())))()()()()()((()()()()(()(()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386596,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        maxi = 0\\n        stack = [-1]\\n        \\n        for i in range(len(s)) :\\n            if s[i] == \"(\" : stack.append(i)\\n            else :\\n                stack.pop()\\n                if len(stack) == 0 : stack.append(i)\\n                else : maxi = max(maxi, i - stack[-1])\\n        \\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        \\n        maxi = 0\\n        stack = [-1]\\n        \\n        for i in range(len(s)) :\\n            if s[i] == \"(\" : stack.append(i)\\n            else :\\n                stack.pop()\\n                if len(stack) == 0 : stack.append(i)\\n                else : maxi = max(maxi, i - stack[-1])\\n        \\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305947,
                "title": "c-100-no-stack-no-dp-constant-space-tc-o-n",
                "content": "class Solution {\\npublic:\\n\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int lc = 0;  //opening bracket count\\n        int rc = 0;  //closing bracket count\\n        for(int i = 0; i < n; i++)  //left to right iteration\\n        {\\n            if(s[i] == \\'(\\') lc++;\\n            else rc++;\\n            if(lc == rc) ans = max(ans, 2 * lc);\\n            else if(rc > lc) lc = rc = 0;\\n        }\\n        lc = rc = 0;\\n        for(int i = n-1; i >= 0; i--)  //right to left iteration\\n        {\\n            if(s[i] == \\'(\\') lc++;\\n            else rc++;\\n            if(lc == rc) ans = max(ans, lc * 2);\\n            else if(lc > rc) lc = rc = 0;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int longestValidParentheses(string s) {\\n        int n = s.length();\\n        int ans = 0;\\n        int lc = 0;  //opening bracket count\\n        int rc = 0;  //closing bracket count\\n        for(int i = 0; i < n; i++)  //left to right iteration\\n        {\\n            if(s[i] == \\'(\\') lc++;\\n            else rc++;\\n            if(lc == rc) ans = max(ans, 2 * lc);\\n            else if(rc > lc) lc = rc = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2170358,
                "title": "simple-easy-o-n-cpp-solution-without-dp",
                "content": "* We will use stack STL here. \\n* Firstly, if the character is a ( , we will push the index value of ( in the stack.\\n* If the char is ) and stack is not empty, we have the index i (from the traversal itself) and we can pop one ( from the stack..before popping we can take its index value from the stack-top in another variable, say x.\\n* So, by doing so, we are getting pairs of ( and ), thus making a valid parenthesis (MAYBE not the longest one). Now, for the indices of ( and ) pairs already encountered, make (s[i]=\\'.\\').\\n* At the end of traversal, we will be having string s as combinations of ( , ) and \\'.\\' \\n\\n* e.g., if the string is \")(()()())))\", the resulting string becomes - \")........))\"\\n* Now, traverse the string just once to find the longest number of consecutive \\'.\\' and that\\'s our answer ! \\n* The code - \\n* ```     \\n*     class Solution {\\n         public:  \\n    int longestValidParentheses(string s) {\\n        int i = 0;\\n        int x;\\n        int l = 0;\\n        stack<int> st;\\n        int res = 0;\\n        \\n        while (s[i] != \\'\\\\0\\')\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n                s[i] = \\'(\\';\\n            }\\n            else\\n            {\\n                if (!(st.empty()))\\n                {\\n                    x = st.top();\\n                    st.pop();\\n                    s[x] = \\'.\\';\\n                    s[i] = \\'.\\';\\n                }\\n            }\\n            i++;\\n        }\\n        int a = 0;\\n        for (i = 0; s[i] != \\'\\\\0\\'; i++)\\n        {\\n            if (s[i] != \\'.\\')\\n            {\\n                res = max(a, res);\\n                a = 0;\\n            }\\n            else\\n            {\\n                a++;\\n            }\\n        }\\n        return max(res,a);\\n    }\\n};```\\n\\nHope this helps ! :)",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```     \\n*     class Solution {\\n         public:  \\n    int longestValidParentheses(string s) {\\n        int i = 0;\\n        int x;\\n        int l = 0;\\n        stack<int> st;\\n        int res = 0;\\n        \\n        while (s[i] != \\'\\\\0\\')\\n        {\\n            if (s[i] == \\'(\\')\\n            {\\n                st.push(i);\\n                s[i] = \\'(\\';\\n            }\\n            else\\n            {\\n                if (!(st.empty()))\\n                {\\n                    x = st.top();\\n                    st.pop();\\n                    s[x] = \\'.\\';\\n                    s[i] = \\'.\\';\\n                }\\n            }\\n            i++;\\n        }\\n        int a = 0;\\n        for (i = 0; s[i] != \\'\\\\0\\'; i++)\\n        {\\n            if (s[i] != \\'.\\')\\n            {\\n                res = max(a, res);\\n                a = 0;\\n            }\\n            else\\n            {\\n                a++;\\n            }\\n        }\\n        return max(res,a);\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2070364,
                "title": "intution-understanding-easy-to-understand-clean-code-o-n-time-o-n-space",
                "content": "**Lets break this problem into checking if a given String is contains all valid parentheses. Basic algorithm for this will be if we see a start character i.e. \\'( we push it in the stack and if we see end character \\')\\' and if top of the stack is \\'(\\' we pop it. This is similar to postfix expression evaluation logic.**\\n\\nif after doing this stack is not empty we can say that given string does not hold valid parentheses.\\n\\nNow coming to given problem in hand, we have to find a substring of the given string which is valid and is of maximum length.  lets have a look at below analysis. Lets say we have a given string X.\\n\\nX = \\')__________(\\'\\n\\nelements inside first character and last character forms a valid string. What will be the length of that string? It will be index of end character - index of first character -1.\\n\\nThis is the base intution behind this. So if we have position for indivdual mismatch we can find length out string which is valid. \\n\\nSo while evalulting above highlighted logic whenever we face a mismatch why don\\'t we store the index of position where current character is not equal to top of the stack. i.e. where ever mismatch happen .\\n\\nonce we have indexs all we have to do perfom end-start-1 and choose max of range.\\n\\nTry to visulise indexes wherever mimatch happened on a number line of positve integers.\\n\\n0..............5.........10............13............14\\n\\nso max length of valid substring will be between 5 and 0.  You might need to handle some corner cases and some initilzation condition. For that please have a look at the code below.\\n\\n```\\nclass Solution {\\n    static Character START_CHARACTER  = \\'(\\';\\n    static Character END_CHARACTER = \\')\\';\\n    \\n    \\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i=0;i<s.length();i++) {\\n            if(stack.isEmpty()) {\\n                stack.push(i);\\n            }\\n            else if(s.charAt(i)==Solution.END_CHARACTER && s.charAt(stack.peek())==Solution.START_CHARACTER) {\\n                stack.pop();\\n            }else {\\n                stack.push(i);\\n            } \\n        }\\n        int end=s.length();\\n        int start=0;\\n        int longestValidParentheses = 0;\\n        if(stack.isEmpty())\\n            return s.length();\\n        else {\\n            while(!stack.isEmpty()) {\\n            start = stack.pop();\\n            longestValidParentheses = Math.max(end-start-1,longestValidParentheses);\\n            end=start;\\n            }\\n        }\\n        longestValidParentheses = Math.max(end-0,longestValidParentheses);\\n        return longestValidParentheses;\\n    }\\n    \\n \\n}\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    static Character START_CHARACTER  = \\'(\\';\\n    static Character END_CHARACTER = \\')\\';\\n    \\n    \\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<Integer>();\\n        for(int i=0;i<s.length();i++) {\\n            if(stack.isEmpty()) {\\n                stack.push(i);\\n            }\\n            else if(s.charAt(i)==Solution.END_CHARACTER && s.charAt(stack.peek())==Solution.START_CHARACTER) {\\n                stack.pop();\\n            }else {\\n                stack.push(i);\\n            } \\n        }\\n        int end=s.length();\\n        int start=0;\\n        int longestValidParentheses = 0;\\n        if(stack.isEmpty())\\n            return s.length();\\n        else {\\n            while(!stack.isEmpty()) {\\n            start = stack.pop();\\n            longestValidParentheses = Math.max(end-start-1,longestValidParentheses);\\n            end=start;\\n            }\\n        }\\n        longestValidParentheses = Math.max(end-0,longestValidParentheses);\\n        return longestValidParentheses;\\n    }\\n    \\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475321,
                "title": "without-stack-cpp-o-1-space",
                "content": "```\\n int longestValidParentheses(string s) {  \\n          int left = 0, right = 0, maxlength = 0;\\n          int n=s.length();\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n\\n        if (left == right)\\n            maxlength = max(maxlength, 2 * right);\\n \\n\\n        else if (right > left)\\n            left = right = 0;\\n    }\\n \\n    left = right = 0;\\n \\n    for (int i = n - 1; i >= 0; i--) {\\n \\n\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n        if (left == right)\\n            maxlength = max(maxlength, 2 * left);\\n \\n        else if (left > right)\\n            left = right = 0;\\n    }\\n    return maxlength;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n int longestValidParentheses(string s) {  \\n          int left = 0, right = 0, maxlength = 0;\\n          int n=s.length();\\n    for (int i = 0; i < n; i++)\\n    {\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n\\n        if (left == right)\\n            maxlength = max(maxlength, 2 * right);\\n \\n\\n        else if (right > left)\\n            left = right = 0;\\n    }\\n \\n    left = right = 0;\\n \\n    for (int i = n - 1; i >= 0; i--) {\\n \\n\\n        if (s[i] == \\'(\\')\\n            left++;\\n        else\\n            right++;\\n \\n        if (left == right)\\n            maxlength = max(maxlength, 2 * left);\\n \\n        else if (left > right)\\n            left = right = 0;\\n    }\\n    return maxlength;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1430695,
                "title": "using-stack-easy",
                "content": "\\t\\n\\tclass Solution {\\n\\t\\n\\tpublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.length();\\n        stack<int> st;\\n        st.push(-1);\\n        int len = 0;\\n        int maxlen =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            if(s[i] == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                len = i - st.top();\\n                maxlen = max(maxlen,len);\\n            }\\n        }\\n        return maxlen;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\n\\tpublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int n = s.length();\\n        stack<int> st;\\n        st.push(-1);\\n        int len = 0;\\n        int maxlen =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            if(s[i] == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                len = i - st.top();\\n                maxlen = max(maxlen,len);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1428168,
                "title": "c-simple-and-short-stack-solution-with-explanation",
                "content": "**Idea:**\\nWe use a stack to store the un-matched parentheses indices, and keep `last` for the end of the last valid string.\\nWe iterate through the string.\\nIf we find a `(`, we push the index to the stack.\\nIf we find a `)`: If we have elements in the stack - We pop the last element, don\\'t need it.\\nNow, we calculate the length from the previous element until the current one, and store in `res` the maximum.\\nIf we have the previous element in the stack, we use it, Otherwise we use `prev`.\\nIf the stack is empty, we save `i` in `prev`.\\n**Time Complecity:** O(n)\\n**Space Complexity:** O(n)\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        int res = 0, prev = -1;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            \\n           if (s[i] == \\'(\\') stk.push(i);\\n            \\n            else {\\n                if (!stk.empty()) {\\n                    stk.pop();\\n                    if (stk.empty()) res = max(res, i - prev);\\n                    else res = max(res, i - stk.top()); \\n                }\\n                else prev = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> stk;\\n        int res = 0, prev = -1;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            \\n           if (s[i] == \\'(\\') stk.push(i);\\n            \\n            else {\\n                if (!stk.empty()) {\\n                    stk.pop();\\n                    if (stk.empty()) res = max(res, i - prev);\\n                    else res = max(res, i - stk.top()); \\n                }\\n                else prev = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184258,
                "title": "c-python-o-n-solution-using-stack-dp",
                "content": "# Using Stack\\n1. C++\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int i, n = s.size(), ans = 0;\\n        stack<int> st = {};\\n        \\n        for(i = 0; i < n; i++){\\n            if (s[i] != \\')\\')\\n                st.push(i);\\n            else{\\n                if (st.empty()){\\n                    st.push(i);\\n                    continue;\\n                }\\n                if (s[st.top()] == \\'(\\' && s[i] == \\')\\'){\\n                    st.pop();\\n                    ans = !st.empty() ? max(ans, i - st.top()) : max(ans, i + 1);\\n                }\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n2. Python\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        de = deque()\\n        \\n        for i in range(n):\\n            if s[i]!=\\')\\':\\n                de.append(i)\\n            else:\\n                if(len(de) == 0):\\n                    de.append(i)\\n                    continue\\n                if s[de[len(de) - 1]] == \\'(\\' and s[i] == \\')\\':\\n                    de.pop()\\n                    ans = max(ans, i - de[len(de) - 1]) if len(de) != 0 else max(ans, i + 1)\\n                else:\\n                    de.append(i)\\n        \\n        return ans\\n```\\n\\n# Using DP\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        ans = 0\\n        \\n        for i in range(1,n):\\n            if s[i] == \\')\\' and s[i - 1] == \\'(\\':\\n                dp[i] = dp[i-2] + 2;\\n            elif s[i] == \\')\\' and s[i - 1] == \\')\\' and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n                dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int i, n = s.size(), ans = 0;\\n        stack<int> st = {};\\n        \\n        for(i = 0; i < n; i++){\\n            if (s[i] != \\')\\')\\n                st.push(i);\\n            else{\\n                if (st.empty()){\\n                    st.push(i);\\n                    continue;\\n                }\\n                if (s[st.top()] == \\'(\\' && s[i] == \\')\\'){\\n                    st.pop();\\n                    ans = !st.empty() ? max(ans, i - st.top()) : max(ans, i + 1);\\n                }\\n                else\\n                    st.push(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        ans = 0\\n        n = len(s)\\n        de = deque()\\n        \\n        for i in range(n):\\n            if s[i]!=\\')\\':\\n                de.append(i)\\n            else:\\n                if(len(de) == 0):\\n                    de.append(i)\\n                    continue\\n                if s[de[len(de) - 1]] == \\'(\\' and s[i] == \\')\\':\\n                    de.pop()\\n                    ans = max(ans, i - de[len(de) - 1]) if len(de) != 0 else max(ans, i + 1)\\n                else:\\n                    de.append(i)\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        n = len(s)\\n        dp = [0] * n\\n        ans = 0\\n        \\n        for i in range(1,n):\\n            if s[i] == \\')\\' and s[i - 1] == \\'(\\':\\n                dp[i] = dp[i-2] + 2;\\n            elif s[i] == \\')\\' and s[i - 1] == \\')\\' and i - dp[i - 1] - 1 >= 0 and s[i - dp[i - 1] - 1] == \\'(\\':\\n                dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2;\\n            ans = max(ans, dp[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1142701,
                "title": "c-solution-with-stack",
                "content": "```\\n// Runtime: 4 ms, faster than 80.88% of C++ online submissions for Longest Valid Parentheses.\\n// Memory Usage: 7.3 MB, less than 21.73% of C++ online submissions for Longest Valid Parentheses.\\nint longestValidParentheses(string s) {\\n\\tint res = 0;\\n\\tstack<int> st; // stores indexes\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tst.push(i);\\n\\t\\telse {\\n\\t\\t\\tif (!st.empty() && s[st.top()] == \\'(\\') {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tres = max(res, st.empty() ? i + 1 : i - st.top());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n// Runtime: 4 ms, faster than 80.88% of C++ online submissions for Longest Valid Parentheses.\\n// Memory Usage: 7.3 MB, less than 21.73% of C++ online submissions for Longest Valid Parentheses.\\nint longestValidParentheses(string s) {\\n\\tint res = 0;\\n\\tstack<int> st; // stores indexes\\n\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\tif (s[i] == \\'(\\')\\n\\t\\t\\tst.push(i);\\n\\t\\telse {\\n\\t\\t\\tif (!st.empty() && s[st.top()] == \\'(\\') {\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tres = max(res, st.empty() ? i + 1 : i - st.top());\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tst.push(i);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1140452,
                "title": "python-no-dp-no-stack-o-n",
                "content": "Logic: Counting left and right parenthesis\\n```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        m = left = right = 0\\n        \\n        for i in s:\\n            if i==\\'(\\':\\n                left += 1\\n            else:\\n                right += 1\\n            if left == right:\\n                m = max(m, right+left)\\n            elif right>left :\\n                left = right = 0\\n                \\n        left = right=0\\n        \\n        for i in s[::-1]:\\n            if i ==\\')\\':\\n                right += 1\\n            else:\\n                left += 1\\n            if left == right:\\n                m = max(m,right+left )\\n            elif left >right:\\n                left =right=0\\n\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:\\n        m = left = right = 0\\n        \\n        for i in s:\\n            if i==\\'(\\':\\n                left += 1\\n            else:\\n                right += 1\\n            if left == right:\\n                m = max(m, right+left)\\n            elif right>left :\\n                left = right = 0\\n                \\n        left = right=0\\n        \\n        for i in s[::-1]:\\n            if i ==\\')\\':\\n                right += 1\\n            else:\\n                left += 1\\n            if left == right:\\n                m = max(m,right+left )\\n            elif left >right:\\n                left =right=0\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954563,
                "title": "java-recursive-tle-memoization-bottom-up-array",
                "content": "```\\n- For each of the index \\'i\\'\\n\\t- If the current character is \\')\\', then the longest valid parentheses substring is equal to 0\\n\\t- If the current character is \\'(\\'\\n\\t\\t- We will first need to find the longest valid parentheses substring \\'length\\' starting at \\'i + 1\\'\\n\\t\\t- If the character at \\'i + length + 1\\' is equal to \\')\\'\\n\\t\\t\\t- Then we know we can form a valid parentheses substring from index \\'i\\'\\n\\t\\t\\t- We will then need to continue our search for valid parentheses substrings from \\'i + length + 2\\'\\n- We will take the longest length for valid parentheses out of all indices \\'i\\'\\n```\\n```\\npublic class LongestValidParenthesesRecursiveApproach {\\n    public int longestValidParentheses(String s) {\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n\\n        int length1 = longestValidParentheses(i + 1, s);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return length1 + longestValidParentheses(x + 1, s) + 2;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\\n```\\npublic class LongestValidParenthesesMemoizationApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] memo = new int[s.length()];\\n        Arrays.fill(memo, -1);\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s, memo));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s, int[] memo) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n        if (memo[i] != -1) return memo[i];\\n\\n        int length1 = longestValidParentheses(i + 1, s, memo);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return memo[i] = length1 + longestValidParentheses(x + 1, s, memo) + 2;\\n        }\\n\\n        return memo[i] = 0;\\n    }\\n}\\n```\\n```\\npublic class LongestValidParenthesesBottomUp1DApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] length = new int[s.length() + 1];\\n        int maxLength = 0;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\') continue;\\n\\n            int x = i + length[i + 1] + 1;\\n\\n            if (x < s.length() && s.charAt(x) == \\')\\') {\\n                length[i] = length[i + 1] + length[x + 1] + 2;\\n            }\\n\\n            maxLength = Math.max(maxLength, length[i]);\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- For each of the index \\'i\\'\\n\\t- If the current character is \\')\\', then the longest valid parentheses substring is equal to 0\\n\\t- If the current character is \\'(\\'\\n\\t\\t- We will first need to find the longest valid parentheses substring \\'length\\' starting at \\'i + 1\\'\\n\\t\\t- If the character at \\'i + length + 1\\' is equal to \\')\\'\\n\\t\\t\\t- Then we know we can form a valid parentheses substring from index \\'i\\'\\n\\t\\t\\t- We will then need to continue our search for valid parentheses substrings from \\'i + length + 2\\'\\n- We will take the longest length for valid parentheses out of all indices \\'i\\'\\n```\n```\\npublic class LongestValidParenthesesRecursiveApproach {\\n    public int longestValidParentheses(String s) {\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n\\n        int length1 = longestValidParentheses(i + 1, s);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return length1 + longestValidParentheses(x + 1, s) + 2;\\n        }\\n\\n        return 0;\\n    }\\n}\\n```\n```\\npublic class LongestValidParenthesesMemoizationApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] memo = new int[s.length()];\\n        Arrays.fill(memo, -1);\\n        int maxLength = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            maxLength = Math.max(maxLength, longestValidParentheses(i, s, memo));\\n        }\\n\\n        return maxLength;\\n    }\\n\\n    private int longestValidParentheses(int i, String s, int[] memo) {\\n        if (i >= s.length() || s.charAt(i) == \\')\\') return 0;\\n        if (memo[i] != -1) return memo[i];\\n\\n        int length1 = longestValidParentheses(i + 1, s, memo);\\n        int x = i + length1 + 1;\\n\\n        if (x < s.length() && s.charAt(x) == \\')\\') {\\n            return memo[i] = length1 + longestValidParentheses(x + 1, s, memo) + 2;\\n        }\\n\\n        return memo[i] = 0;\\n    }\\n}\\n```\n```\\npublic class LongestValidParenthesesBottomUp1DApproach {\\n    public int longestValidParentheses(String s) {\\n        int[] length = new int[s.length() + 1];\\n        int maxLength = 0;\\n\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == \\')\\') continue;\\n\\n            int x = i + length[i + 1] + 1;\\n\\n            if (x < s.length() && s.charAt(x) == \\')\\') {\\n                length[i] = length[i + 1] + length[x + 1] + 2;\\n            }\\n\\n            maxLength = Math.max(maxLength, length[i]);\\n        }\\n\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575579,
                "title": "dynamic-programming-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size()+1,0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                if(s[i-1]==\\'(\\'){\\n                    dp[i]=((i-2)>=0 ? dp[i-2] : 0) +2;\\n                }\\n                else{\\n                    if((i-dp[i-1])>0 && s[i-dp[i-1]-1]==\\'(\\'){\\n                        dp[i]=dp[i-1]+2+((i-dp[i-1]-2)>=0 ? dp[i-dp[i-1]-2] : 0);\\n                    }\\n                }\\n                //cout<<dp[i]<<\" \";\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        vector<int> dp(s.size()+1,0);\\n        for(int i=1;i<s.size();i++){\\n            if(s[i]==\\')\\'){\\n                if(s[i-1]==\\'(\\'){\\n                    dp[i]=((i-2)>=0 ? dp[i-2] : 0) +2;\\n                }\\n                else{\\n                    if((i-dp[i-1])>0 && s[i-dp[i-1]-1]==\\'(\\'){\\n                        dp[i]=dp[i-1]+2+((i-dp[i-1]-2)>=0 ? dp[i-dp[i-1]-2] : 0);\\n                    }\\n                }\\n                //cout<<dp[i]<<\" \";\\n            }\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 451674,
                "title": "python-linear-scan-98-100",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:        \\n        res, left, right = 0, 0, 0\\n        for i in range(len(s)): # forward scan\\n            if s[i] == \\'(\\':\\n                left += 1\\n            else: # case \\')\\'\\n                right += 1\\n                if right > left:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n        \\n        left, right = 0, 0\\n        for i in reversed(range(len(s))): # backward scan\\n            if s[i] == \\')\\':\\n                right += 1\\n            else: # case \\'(\\'\\n                left += 1\\n                if left > right:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n                    \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s: str) -> int:        \\n        res, left, right = 0, 0, 0\\n        for i in range(len(s)): # forward scan\\n            if s[i] == \\'(\\':\\n                left += 1\\n            else: # case \\')\\'\\n                right += 1\\n                if right > left:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n        \\n        left, right = 0, 0\\n        for i in reversed(range(len(s))): # backward scan\\n            if s[i] == \\')\\':\\n                right += 1\\n            else: # case \\'(\\'\\n                left += 1\\n                if left > right:\\n                    left, right = 0, 0\\n                elif left == right:\\n                    res = max(left+right, res)\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269017,
                "title": "java-7ms-solution-with-stack",
                "content": "```len[i]```  is the length of longest valid substring which ends at the ```ith``` element of ```s```.  \\nApparently, if ```s[i] == \\'(\\'``` then ```len[i] = 0``` . If ```s[i] == \\')\\'```, we calculate ```len[i]``` under the help of stack.\\n\\n```\\npublic int longestValidParentheses(String s) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint len[] = new int[s.length()];\\n\\tint max = 0;\\n\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\tif( s.charAt(i) == \\'(\\' )\\n\\t\\t\\tstack.push(i);\\n\\t\\telse if( !stack.isEmpty() ) {\\n\\t\\t\\tlen[i] = i - stack.peek() + 1; // Currently,len[i] only reprensents the distance between s[i] and its pair \\'(\\'\\n\\t\\t\\tlen[i] += stack.peek() > 0 ? len[stack.peek() - 1] : 0; // plus the length of longest valid substring which ends at the previous element of pair \\'(\\'\\n\\t\\t\\tmax = Math.max(len[i], max);\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```len[i]```\n```ith```\n```s```\n```s[i] == \\'(\\'```\n```len[i] = 0```\n```s[i] == \\')\\'```\n```len[i]```\n```\\npublic int longestValidParentheses(String s) {\\n\\tStack<Integer> stack = new Stack<Integer>();\\n\\tint len[] = new int[s.length()];\\n\\tint max = 0;\\n\\tfor(int i = 0; i < s.length(); i++) {\\n\\t\\tif( s.charAt(i) == \\'(\\' )\\n\\t\\t\\tstack.push(i);\\n\\t\\telse if( !stack.isEmpty() ) {\\n\\t\\t\\tlen[i] = i - stack.peek() + 1; // Currently,len[i] only reprensents the distance between s[i] and its pair \\'(\\'\\n\\t\\t\\tlen[i] += stack.peek() > 0 ? len[stack.peek() - 1] : 0; // plus the length of longest valid substring which ends at the previous element of pair \\'(\\'\\n\\t\\t\\tmax = Math.max(len[i], max);\\n\\t\\t\\tstack.pop();\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229774,
                "title": "c-well-commented-solution-using-stack",
                "content": "```\\n/* Idea borrowed from https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack  */\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s);\\n};\\n\\n/* Returns the length of teh longest valid parenthesis */\\nint Solution :: longestValidParentheses(string str)\\n{\\n    // Idea ---- Traverse the stack and store the indices which are not matched\\n    // Get the largest length b/w consecutive indices\\n    \\n    // string length\\n    int n = str.length();\\n    stack<int> indexStack;\\n    \\n    \\n    // Traverse and remove all the valid indices\\n    for(int i=0; i<n; i++)\\n    {\\n        // if it opening bracket,just push it\\n        if(str[i]==\\'(\\') indexStack.push(i);\\n        \\n        // Else it is a closing bracket\\n        else if(str[i]==\\')\\')\\n        {\\n             // If Stack is empty, then it is unmatched index\\n            if(indexStack.empty()) indexStack.push(i);\\n            \\n            // Else If stack is not empty, check if it contains the matching bracket on top or not\\n            else \\n            {\\n                // If the bracket is valid pop it\\n                if( str[indexStack.top()] == \\'(\\') indexStack.pop();\\n            \\n                // else We have another invalid parenthesis\\n                else indexStack.push(i);\\n            }\\n        }\\n    }\\n    \\n    // If the stack is empty, the whole string is balanced\\n    if(indexStack.empty()) return n;\\n    \\n    // Assume that the string consisted of one extra character, which is of course mismatched\\n    int rightIndex = n;\\n    int leftIndex = 0;\\n    int maxLength = 0;\\n    \\n    \\n    /* A tricky test case. What if in a long string only the last index is inavlid? */\\n    /* ()) Stack would become empty in one go, if you do it naively without updating */\\n    \\n    // Find the largest gap in between\\n    while(!indexStack.empty())\\n    {\\n        // Store the left index\\n        int leftIndex = indexStack.top();\\n        indexStack.pop();\\n        \\n        // The number of elements in [l,r] is r-l+1\\n        // The number of elements strictly b/w l and r is r-l+1-2 = r-l-1\\n        int midLength = rightIndex - leftIndex - 1;\\n        \\n        //update the max length\\n        maxLength = max(maxLength, midLength);\\n        \\n        // update the right index\\n        rightIndex = leftIndex;\\n        \\n        // Check if it was the last element. If it is, it is never coming back to the loop again\\n        // Set the lower index as -1 (Invalid) and update the max now \\n        if(indexStack.empty())\\n        {\\n            leftIndex = -1;\\n            midLength = rightIndex - leftIndex - 1;\\n            maxLength = max(maxLength, midLength);\\n        }\\n    }\\n    \\n    \\n    return maxLength;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/* Idea borrowed from https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack  */\\n\\n\\n\\nclass Solution\\n{\\npublic:\\n    int longestValidParentheses(string s);\\n};\\n\\n/* Returns the length of teh longest valid parenthesis */\\nint Solution :: longestValidParentheses(string str)\\n{\\n    // Idea ---- Traverse the stack and store the indices which are not matched\\n    // Get the largest length b/w consecutive indices\\n    \\n    // string length\\n    int n = str.length();\\n    stack<int> indexStack;\\n    \\n    \\n    // Traverse and remove all the valid indices\\n    for(int i=0; i<n; i++)\\n    {\\n        // if it opening bracket,just push it\\n        if(str[i]==\\'(\\') indexStack.push(i);\\n        \\n        // Else it is a closing bracket\\n        else if(str[i]==\\')\\')\\n        {\\n             // If Stack is empty, then it is unmatched index\\n            if(indexStack.empty()) indexStack.push(i);\\n            \\n            // Else If stack is not empty, check if it contains the matching bracket on top or not\\n            else \\n            {\\n                // If the bracket is valid pop it\\n                if( str[indexStack.top()] == \\'(\\') indexStack.pop();\\n            \\n                // else We have another invalid parenthesis\\n                else indexStack.push(i);\\n            }\\n        }\\n    }\\n    \\n    // If the stack is empty, the whole string is balanced\\n    if(indexStack.empty()) return n;\\n    \\n    // Assume that the string consisted of one extra character, which is of course mismatched\\n    int rightIndex = n;\\n    int leftIndex = 0;\\n    int maxLength = 0;\\n    \\n    \\n    /* A tricky test case. What if in a long string only the last index is inavlid? */\\n    /* ()) Stack would become empty in one go, if you do it naively without updating */\\n    \\n    // Find the largest gap in between\\n    while(!indexStack.empty())\\n    {\\n        // Store the left index\\n        int leftIndex = indexStack.top();\\n        indexStack.pop();\\n        \\n        // The number of elements in [l,r] is r-l+1\\n        // The number of elements strictly b/w l and r is r-l+1-2 = r-l-1\\n        int midLength = rightIndex - leftIndex - 1;\\n        \\n        //update the max length\\n        maxLength = max(maxLength, midLength);\\n        \\n        // update the right index\\n        rightIndex = leftIndex;\\n        \\n        // Check if it was the last element. If it is, it is never coming back to the loop again\\n        // Set the lower index as -1 (Invalid) and update the max now \\n        if(indexStack.empty())\\n        {\\n            leftIndex = -1;\\n            midLength = rightIndex - leftIndex - 1;\\n            maxLength = max(maxLength, midLength);\\n        }\\n    }\\n    \\n    \\n    return maxLength;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180397,
                "title": "my-python-beating-99-6-with-o-n",
                "content": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        \\n        # \\u626B\\u63CF\\u4E00\\u904D\\uFF0C\\u6784\\u9020\\u4E00\\u4E2A\\u6808\\uFF0C\\u6700\\u540E\\u53EA\\u5269\\u4E0B\\u5339\\u914D\\u4E0D\\u4E0A\\u7684\\u7D22\\u5F15\\n        stack = []\\n        for i in range(l):\\n            if s[i] == \\')\\' and stack and s[stack[-1]] == \\'(\\':\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        # \\u4E0D\\u5728\\u6808\\u5185\\u7684\\u7D22\\u5F15\\u662F\\u53EF\\u4EE5\\u5339\\u914D\\u4E0A\\u7684\\uFF0C\\u76F8\\u90BB\\u7D22\\u5F15\\u4E4B\\u95F4\\u7684\\u5B50\\u4E32\\u4E3A\\u6709\\u6548\\u5B50\\u4E32\\n        if not stack:\\n            return l\\n        stack.insert(0, -1)\\n        stack.append(l)\\n        return max(stack[i+1]-stack[i]-1 for i in range(len(stack)-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        l = len(s)\\n        \\n        # \\u626B\\u63CF\\u4E00\\u904D\\uFF0C\\u6784\\u9020\\u4E00\\u4E2A\\u6808\\uFF0C\\u6700\\u540E\\u53EA\\u5269\\u4E0B\\u5339\\u914D\\u4E0D\\u4E0A\\u7684\\u7D22\\u5F15\\n        stack = []\\n        for i in range(l):\\n            if s[i] == \\')\\' and stack and s[stack[-1]] == \\'(\\':\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        # \\u4E0D\\u5728\\u6808\\u5185\\u7684\\u7D22\\u5F15\\u662F\\u53EF\\u4EE5\\u5339\\u914D\\u4E0A\\u7684\\uFF0C\\u76F8\\u90BB\\u7D22\\u5F15\\u4E4B\\u95F4\\u7684\\u5B50\\u4E32\\u4E3A\\u6709\\u6548\\u5B50\\u4E32\\n        if not stack:\\n            return l\\n        stack.insert(0, -1)\\n        stack.append(l)\\n        return max(stack[i+1]-stack[i]-1 for i in range(len(stack)-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14210,
                "title": "python-o-n-solution-with-2-passes-sliding-window-no-stack-or-dp-needed",
                "content": "```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        longest = 0\\n        start = 0\\n        n = 0\\n        \\n        for i, p in enumerate(s):\\n            if p == \"(\":\\n                n += 1\\n            else: # p == \")\"\\n                n -= 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        start = 0\\n        n = 0\\n        for i, p in enumerate(s[::-1]):\\n            if p == \"(\":\\n                n -= 1\\n            else: # p == \")\"\\n                n += 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        return longest\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        longest = 0\\n        start = 0\\n        n = 0\\n        \\n        for i, p in enumerate(s):\\n            if p == \"(\":\\n                n += 1\\n            else: # p == \")\"\\n                n -= 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        start = 0\\n        n = 0\\n        for i, p in enumerate(s[::-1]):\\n            if p == \"(\":\\n                n -= 1\\n            else: # p == \")\"\\n                n += 1\\n            \\n            if n < 0:\\n                start = i + 1\\n                n = 0\\n            elif n == 0:\\n                longest = max(longest, i+1-start)\\n\\n        return longest\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14208,
                "title": "concise-one-pass-dp-solution-without-stack",
                "content": "left: remaining left parentheses that haven't been paired.\\nDP[i + 1]: longest paired parentheses ended at index i. (i from 0 to size - 1)\\n\\nOnce we met a ')' and have unpaired '(', increase the length by 2 based on the previous DP value. The trick is that the newly generated length may not be the final DP value. \\n\\nFor the following example : '(()())', note that DP index start from 1, not 0.\\n\\nSuppose we just met the second ')', DP[5] = DP[4] + 2 = 0 + 2 = 2.\\nNow we should go back to the first ')' to check if there are previously matched string. If yes, add them up.\\nThus, DP[5] += DP[5 - DP[5]] \\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int size = (int)s.size();\\n        vector<int> DP(size + 1, 0);\\n        int left = 0, longest = 0;\\n        for(int i = 0; i < size; ++i){\\n            if(s[i] == '('){\\n                left++;\\n            }else if(s[i] == ')' && left > 0){\\n                DP[i + 1] = DP[i] + 2;\\n                DP[i + 1] += DP[i + 1 - DP[i + 1]];\\n                left--;\\n            }\\n            longest = max(longest, DP[i + 1]);\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int size = (int)s.size();\\n        vector<int> DP(size + 1, 0);\\n        int left = 0, longest = 0;\\n        for(int i = 0; i < size; ++i){\\n            if(s[i] == '('){\\n                left++;\\n            }else if(s[i] == ')' && left > 0){\\n                DP[i + 1] = DP[i] + 2;\\n                DP[i + 1] += DP[i + 1 - DP[i + 1]];\\n                left--;\\n            }\\n            longest = max(longest, DP[i + 1]);\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14244,
                "title": "very-direct-dp-solution-clean-and-efficient-besides-it-s-beautifully-explained",
                "content": "\\nSearching for the equation is always the key in DP problem, in this problem we are about to suppose the longest till the `current`,\\n> maxSub[len] = {0};\\n \\nalways stick this in mind before reading the following code.\\n\\nOnce we encounter a closing bracket `)` then we check its previous `longest` valid parentheses and try to find its corresponding open bracket `(`\\n\\n> int t = i-maxSub[i-1]\\n\\nto check whether there is a `corresponding` open bracket `(`\\n\\n> if(t>0 && s[t-1] == '(')\\n\\nif there is, then we should retrieve the `longest` for the current closing bracket `)`\\n\\n> maxSub[i] = (t>1? maxSub[t-2] : 0)+maxSub[i-1]+2;\\n\\nat last, we update the global longest and there. \\n\\nWe're done the job easily and beautifully.\\n\\n**Enjoy your day...**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        int len = s.length(), longest = 0;\\n        if(!len) return 0;\\n        int maxSub[len] = {0};\\n        for(int i = 0; i < len; ++i)\\n        {\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxSub[i-1];\\n                if(t>0 && s[t-1] == '(') maxSub[i] = (t>1? maxSub[t-2] : 0)+maxSub[i-1]+2;\\n                longest = max(longest, maxSub[i]);\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        int len = s.length(), longest = 0;\\n        if(!len) return 0;\\n        int maxSub[len] = {0};\\n        for(int i = 0; i < len; ++i)\\n        {\\n            if(s[i] == ')')\\n            {\\n                int t = i-maxSub[i-1];\\n                if(t>0 && s[t-1] == '(') maxSub[i] = (t>1? maxSub[t-2] : 0)+maxSub[i-1]+2;\\n                longest = max(longest, maxSub[i]);\\n            }\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14259,
                "title": "8ms-c-simple-dp-solution",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            size_t numLefts = 0, maxLen = 0;\\n            vector<size_t> f(s.size(), 0);\\n            for(size_t i = 0;i < s.size();++i){\\n                if(s[i] == '(')\\n                    ++numLefts;\\n                else if(numLefts > 0){\\n                    --numLefts;\\n                    f[i] = f[i - 1] + 2;\\n                    int prev = i - f[i];\\n                    if(prev > 0)\\n                        f[i] += f[prev];\\n                    maxLen = max(maxLen, f[i]);\\n                }\\n            }\\n            return maxLen;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            size_t numLefts = 0, maxLen = 0;\\n            vector<size_t> f(s.size(), 0);\\n            for(size_t i = 0;i < s.size();++i){\\n                if(s[i] == '(')\\n                    ++numLefts;\\n                else if(numLefts > 0){\\n                    --numLefts;\\n                    f[i] = f[i - 1] + 2;\\n                    int prev = i - f[i];\\n                    if(prev > 0)\\n                        f[i] += f[prev];\\n                    maxLen = max(maxLen, f[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14313,
                "title": "java-solution-12ms-structure-simple-and-clear-o-n",
                "content": "    public int longestValidParentheses(String s) {\\n        //use to record how many token left in the stack\\n        int left =0;\\n        //use to record how many left Parentheses in the stack\\n        Stack<Integer> stack = new Stack<>();\\n        //record the max length\\n        int max=0;\\n        for(int index=0; index<s.length(); index++){\\n            Character ch = s.charAt(index);\\n            if(ch=='('){//put the char into the stack directly\\n                stack.push(index);\\n            }\\n            else{\\n                if(stack.isEmpty()){\\n                    //add the left char directly, as this char will never be matched\\n                    left=index+1;\\n                }\\n                else{\\n                    //there have left parentheses in the stack canbe paired\\n                    stack.pop();\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, index-left+1);\\n                    }\\n                    else{\\n                        max = Math.max(max, index-stack.peek());\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int longestValidParentheses(String s) {\\n        //use to record how many token left in the stack\\n        int left =0;\\n        //use to record how many left Parentheses in the stack\\n        Stack<Integer> stack = new Stack<>();\\n        //record the max length\\n        int max=0;\\n        for(int index=0; index<s.length(); index++){\\n            Character ch = s.charAt(index);\\n            if(ch=='('){//put the char into the stack directly\\n                stack.push(index);\\n            }\\n            else{\\n                if(stack.isEmpty()){\\n                    //add the left char directly, as this char will never be matched\\n                    left=index+1;\\n                }\\n                else{\\n                    //there have left parentheses in the stack canbe paired\\n                    stack.pop();\\n                    if(stack.isEmpty()){\\n                        max = Math.max(max, index-left+1);\\n                    }\\n                    else{\\n                        max = Math.max(max, index-stack.peek());\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14324,
                "title": "c-o-n-easy-understand",
                "content": "    class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> st;  st.push(0);\\n            int res = 0;\\n            for (int i=0; i<s.length(); i++) {\\n                if (s[i] == '(') {\\n                    st.push(i+1);\\n                } else {\\n                    st.pop();\\n                    if (st.size()) {\\n                        res = max(res, i + 1 - st.top());\\n                    } else {\\n                        st.push(i+1);\\n                    }\\n                }   \\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int longestValidParentheses(string s) {\\n            stack<int> st;  st.push(0);\\n            int res = 0;\\n            for (int i=0; i<s.length(); i++) {\\n                if (s[i] == '(') {\\n                    st.push(i+1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14352,
                "title": "a-simple-c-dp-solution-without-stack-8ms-in-8-lines",
                "content": "     1. dp[i] = {max(k) | s[i-k+1, i] is well formed. k=0 means empty}\\n     2. For char s[i], we should check the char s[i-1-dp[i-1]]. \\n      If s[i] and s[i-1-dp[i-1]] are matched, substring from  i-1-dp[i-1] to i is well formed. \\n      Then, we should joint it with previous well formed substring which ends at s[i-1-dp[i-1]-1].\\n    \\n     int longestValidParentheses(string s) {\\n                vector<int> dp(s.length(),0);\\n                int res = 0;\\n                for(int i=1; i<s.length(); ++i)\\n                    if(s[i]==')' && i-1-dp[i-1]>=0 &&s[i-1-dp[i-1]]=='('){\\n                        if(i-1-dp[i-1]-1 >= 0) dp[i]= dp[i-1]+2+dp[i-1-dp[i-1]-1];\\n                        else  dp[i]= dp[i-1]+2;\\n                        res = max(res, dp[i]);\\n                    }\\n                return res;\\n            }",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "     1. dp[i] = {max(k) | s[i-k+1, i] is well formed. k=0 means empty}\\n     2. For char s[i], we should check the char s[i-1-dp[i-1]]. \\n      If s[i] and s[i-1-dp[i-1]] are matched, substring from  i-1-dp[i-1] to i is well formed. \\n      Then, we should joint it with previous well formed substring which ends at s[i-1-dp[i-1]-1].\\n    \\n     int longestValidParentheses(string s) {\\n                vector<int> dp(s.length(),0);\\n                int res = 0;\\n                for(int i=1; i<s.length(); ++i)\\n                    if(s[i]==')' && i-1-dp[i-1]>=0 &&s[i-1-dp[i-1]]=='('){\\n                        if(i-1-dp[i-1]-1 >= 0) dp[i]= dp[i-1]+2+dp[i-1-dp[i-1]-1];\\n                        else  dp[i]= dp[i-1]+2;\\n                        res = max(res, dp[i]);\\n                    }\\n                return res;\\n            }",
                "codeTag": "Unknown"
            },
            {
                "id": 14353,
                "title": "o-n-in-time-o-1-in-space",
                "content": "Could there be better improvements on this?\\n\\n    public class Solution {\\n        public int longestValidParentheses(String s) {\\n        \\tint length = 0;\\n            int score = 0;\\n            int start = 0;\\n            int cur = 0;\\n            int bound;\\n            \\n            while (cur < s.length()) {\\n                score += (s.charAt(cur) == '(') ? 1 : -1;\\n                \\n                if (score == 0) {\\n                    length = Math.max(length, cur - start + 1);            \\t\\n                } else if (score < 0) {\\n                    start = cur + 1;\\n                    score = 0;\\n                }\\n    \\n                ++cur;\\n            }\\n            \\n            if (score > 0) {\\n                bound = start - 1;\\n                cur = s.length() - 1;\\n                start = cur;\\n                score = 0;\\n                \\n                while (cur > bound) {\\n                    score += (s.charAt(cur) == ')') ? 1 : -1;\\n                    \\n                    if (score == 0) {\\n                        length = Math.max(length, start - cur + 1);            \\t\\n                    } else if (score < 0) {\\n                        start = cur - 1;\\n                        score = 0;\\n                    }\\n                    \\n                    --cur;\\n                }\\n            }\\n            \\n            return length;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int longestValidParentheses(String s) {\\n        \\tint length = 0;\\n            int score = 0;\\n            int start = 0;\\n            int cur = 0;\\n            int bound;\\n            \\n            while (cur < s.length()) {\\n                score += (s.charAt(cur) == '(') ? 1 : -1;\\n                \\n                if (score == 0) {\\n                    length = Math.max(length, cur - start + 1);            \\t\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4030188,
                "title": "easy-java-solution-stack-basic-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        if (s.length() == 0 || s.length() == 1) return 0;\\n\\n        int maxLen = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(i);\\n            } else {\\n                stack.pop();\\n                if (!stack.isEmpty()) {\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        if (s.length() == 0 || s.length() == 1) return 0;\\n\\n        int maxLen = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'(\\') {\\n                stack.push(i);\\n            } else {\\n                stack.pop();\\n                if (!stack.isEmpty()) {\\n                    maxLen = Math.max(maxLen, i - stack.peek());\\n                } else {\\n                    stack.push(i);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973342,
                "title": "c-solution-with-o-n-time-and-o-1-space",
                "content": "# Intuition\\nCheck valid parentheses from front as well as back and take the maximum of them.\\n\\n# Approach\\nTake single interger `stack` so that we do not have to use any extra space. And increate `stack` when we get a `(` and decrease when we get a `)`\\n\\nIf we get a `)` when `stack` is `0`, then it becomes an invalid parantheses.\\n\\nDo the same for backward direction but increase `stack` when we get a `)` and decrease when we get `(` and take the maximum of all the answers and return.\\n\\n# Complexity\\n- Time complexity:\\n`O(N)` - Doing two linear traverse from front and back\\n\\n- Space complexity:\\n`O(1)` - Not taking any extra spaces\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int lastInvalid = -1;\\n        int stack = 0;\\n        int ans = 0;\\n\\n        for(int i = 0; i < s.size(); i += 1) {\\n            if (s[i] == \\'(\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, i - lastInvalid);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        stack = 0;\\n        lastInvalid = s.size();\\n        for(int i = s.size() - 1; i >= 0; i -= 1) {\\n            if (s[i] == \\')\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, lastInvalid - i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int lastInvalid = -1;\\n        int stack = 0;\\n        int ans = 0;\\n\\n        for(int i = 0; i < s.size(); i += 1) {\\n            if (s[i] == \\'(\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, i - lastInvalid);\\n                    }\\n                }\\n            }\\n        }\\n    \\n        stack = 0;\\n        lastInvalid = s.size();\\n        for(int i = s.size() - 1; i >= 0; i -= 1) {\\n            if (s[i] == \\')\\') {\\n                stack += 1;\\n            } else {\\n                if (stack == 0) {\\n                    lastInvalid = i;\\n                } else {\\n                    stack -= 1;\\n                    if (stack == 0) {\\n                        ans = max(ans, lastInvalid - i);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758119,
                "title": "simple-c-stack-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int ans=0;\\n        int t=0;\\n        stack<int> st;\\n      \\n        st.push(-1);\\n        \\n        for(auto i:s)\\n        {\\n            if(i==\\'(\\') {\\n                st.push(t);\\n                \\n            }\\n            else{\\n                if(!st.empty() && st.top()!=-1 && s[st.top()]==\\'(\\')\\n                {\\n                    st.pop();\\n                   \\n                    ans=max(ans,abs(t-st.top()));\\n                    \\n                }\\n                else st.push(t);\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        \\n        int ans=0;\\n        int t=0;\\n        stack<int> st;\\n      \\n        st.push(-1);\\n        \\n        for(auto i:s)\\n        {\\n            if(i==\\'(\\') {\\n                st.push(t);\\n                \\n            }\\n            else{\\n                if(!st.empty() && st.top()!=-1 && s[st.top()]==\\'(\\')\\n                {\\n                    st.pop();\\n                   \\n                    ans=max(ans,abs(t-st.top()));\\n                    \\n                }\\n                else st.push(t);\\n            }\\n            t++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603982,
                "title": "easy-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxlen=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if(ch==\\'(\\')\\n                st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty())\\n                st.push(i);\\n                else{\\n                    int len=i-st.top();\\n                    maxlen=max(len,maxlen);\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxlen=0;\\n        for(int i=0;i<s.length();i++){\\n            char ch=s[i];\\n            if(ch==\\'(\\')\\n                st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty())\\n                st.push(i);\\n                else{\\n                    int len=i-st.top();\\n                    maxlen=max(len,maxlen);\\n                }\\n            }\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532224,
                "title": "easy-to-understand-approach-c-using-stacks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you have done Valid Parenthesis(Easy) Question, you will understand why I started with stacks.\\n\\nLink : https://leetcode.com/problems/valid-parentheses/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a stack and push -1 into it\\n2. Now initialize ```maxLen = 0 ```\\n3. Iterate over string ``` s ``` and set``` ch = s[i] ```.\\n4. Now check ```if(ch == \\'(\\')``` then push ith element in the stack\\n5. Otherwise pop the stack.\\n6. Check if stack is empty or not.\\n7. For empty case, just push ith element.\\n8. Otherwise, set ```int len = i - st.top()``` \\n9. Now, compute ```maxLen``` and return it.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        \\n        int maxLen = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n\\n            if(ch == \\'(\\') {\\n                st.push(i);\\n            }\\n\\n            else {\\n                st.pop();\\n                if(st.empty()) {\\n                    st.push(i);\\n                }\\n                else {\\n                    int len = i - st.top();\\n                    maxLen = max(len, maxLen);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```maxLen = 0 ```\n``` s ```\n``` ch = s[i] ```\n```if(ch == \\'(\\')```\n```int len = i - st.top()```\n```maxLen```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        \\n        int maxLen = 0;\\n\\n        for(int i = 0; i < s.size(); i++) {\\n            char ch = s[i];\\n\\n            if(ch == \\'(\\') {\\n                st.push(i);\\n            }\\n\\n            else {\\n                st.pop();\\n                if(st.empty()) {\\n                    st.push(i);\\n                }\\n                else {\\n                    int len = i - st.top();\\n                    maxLen = max(len, maxLen);\\n                }\\n            }\\n        }\\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497599,
                "title": "easy-c-solution-using-stack",
                "content": "\\n# Approach:\\nTake a stack and push(-1) into it \\nthen we can do is check if s[i] is \" ( \" or not ,\\nif yes then push teh index \\'i\\' into it \\nif not then pop()\\n,if the stack is empty then push the \\'i\\' index \\nelse check the max of maxi, i-s.top()\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else \\n            {\\n                st.pop();\\n                if(st.empty())\\n                {\\n                    st.push(i);\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,i-st.top());\\n                }\\n            } \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s)\\n    {\\n        stack<int>st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i =0;i<s.size();i++)\\n        {\\n            if(s[i]==\\'(\\')\\n            {\\n                st.push(i);\\n            }\\n            else \\n            {\\n                st.pop();\\n                if(st.empty())\\n                {\\n                    st.push(i);\\n                }\\n                else\\n                {\\n                    maxi=max(maxi,i-st.top());\\n                }\\n            } \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490138,
                "title": "java-solution-for-longest-valid-parenthesis-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is that the stack helps to keep track of the unmatched open parentheses and their indices. By storing the indices, we can easily calculate the length of valid parentheses substrings when a matching close parenthesis is found\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize an empty stack.\\n- Iterate through the string s from index 0 to the end.\\n- If the current character is an open parenthesis \\'(\\', push an integer array containing the index and a value 0 (representing an open parenthesis) onto the stack.\\n- If the current character is a close parenthesis \\')\\', check if the stack is empty or if the top element of the stack has a value of 1 (representing a close parenthesis). If either condition is true, push an integer array containing the index and a value 1 (representing a close parenthesis) onto the stack.\\n- If the stack is not empty and the top element has a value of 0 (representing an open parenthesis), pop the top element from the stack. Calculate the length of the current valid parentheses substring and update the result with the maximum length found so far.\\n- Return the result after iterating through the entire string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the string s. The algorithm iterates through the string once and performs constant-time operations for each character.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), where n is the length of the string s. In the worst case, the stack may store all the characters of the string, resulting in a space complexity of O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<int[]> stack = new Stack<int[]>();\\n        int result = 0;\\n        for(int i=0; i<=s.length()-1; i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                int[] a = {i,0};\\n                stack.push(a);\\n            }\\n            else\\n            {\\n                if(stack.empty()||stack.peek()[1]==1)\\n                {\\n                    int[] a = {i,1};\\n                    stack.push(a);\\n                }\\n                else\\n                {\\n                    stack.pop();\\n                    int currentLen=0;\\n                    if(stack.empty())\\n                    {\\n                        currentLen = i+1;\\n                    }\\n                    else\\n                    {\\n                        currentLen = i-stack.peek()[0];\\n                    }\\n                    result = Math.max(result, currentLen);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<int[]> stack = new Stack<int[]>();\\n        int result = 0;\\n        for(int i=0; i<=s.length()-1; i++)\\n        {\\n            char c = s.charAt(i);\\n            if(c==\\'(\\')\\n            {\\n                int[] a = {i,0};\\n                stack.push(a);\\n            }\\n            else\\n            {\\n                if(stack.empty()||stack.peek()[1]==1)\\n                {\\n                    int[] a = {i,1};\\n                    stack.push(a);\\n                }\\n                else\\n                {\\n                    stack.pop();\\n                    int currentLen=0;\\n                    if(stack.empty())\\n                    {\\n                        currentLen = i+1;\\n                    }\\n                    else\\n                    {\\n                        currentLen = i-stack.peek()[0];\\n                    }\\n                    result = Math.max(result, currentLen);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456794,
                "title": "only-dual-traversal",
                "content": "#*Self Explanatory Code*\\n\\n# Complexity\\n- Time complexity:  O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int l=0,r=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(r>l){     //valid substring(parenthesis) can only found ahead\\n               l=r=0;\\n           }\\n           \\n        }\\n     l=r=0;\\n         for(int i=s.size()-1;i>=0;i--){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(l>r){\\n               l=r=0;\\n           }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int l=0,r=0;\\n        int ans=0;\\n        for(int i=0;i<s.size();i++){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(r>l){     //valid substring(parenthesis) can only found ahead\\n               l=r=0;\\n           }\\n           \\n        }\\n     l=r=0;\\n         for(int i=s.size()-1;i>=0;i--){\\n           if(s[i]==\\'(\\') l++;\\n           if(s[i]==\\')\\') r++;\\n           if(l==r){\\n               ans=max(ans,l+r);\\n           }\\n           if(l>r){\\n               l=r=0;\\n           }\\n           \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341450,
                "title": "basic-but-efficient-solution-with-comments-added",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            //base conidition\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                //Means \\')\\' has appeared\\n                if(!st.empty()){\\n                    if(s[st.top()]==\\'(\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        st.push(i);\\n                    }\\n                }\\n                //If we come to this part means that stack is empty \\n                //and this is the first wrong paranthesis\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n        }\\n\\n        //Now we want to give the length of longest valid paranthesis \\n        //substring\\n        int a=n;\\n        int longest=0;\\n        //if st is empty mean no wrong paranthesis\\n        if(st.empty()){\\n            return a;\\n        }\\n        else{\\n            while(!st.empty()){\\n                int b=st.top();\\n                st.pop();\\n                longest=max(longest,a-b-1);\\n                a=b;\\n            }\\n            longest=max(longest,a);\\n            return longest;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            //base conidition\\n            if(s[i]==\\'(\\'){\\n                st.push(i);\\n            }\\n            else{\\n                //Means \\')\\' has appeared\\n                if(!st.empty()){\\n                    if(s[st.top()]==\\'(\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        st.push(i);\\n                    }\\n                }\\n                //If we come to this part means that stack is empty \\n                //and this is the first wrong paranthesis\\n                else{\\n                    st.push(i);\\n                }\\n            }\\n        }\\n\\n        //Now we want to give the length of longest valid paranthesis \\n        //substring\\n        int a=n;\\n        int longest=0;\\n        //if st is empty mean no wrong paranthesis\\n        if(st.empty()){\\n            return a;\\n        }\\n        else{\\n            while(!st.empty()){\\n                int b=st.top();\\n                st.pop();\\n                longest=max(longest,a-b-1);\\n                a=b;\\n            }\\n            longest=max(longest,a);\\n            return longest;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108956,
                "title": "faster-than-100-constant-space-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0;\\n        int right=0;\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')left++;\\n            else right++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(right>left)left=right=0;\\n        }\\n        left=right=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\')right++;\\n            else left++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(left>right)left=right=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int left=0;\\n        int right=0;\\n        int ans=0;\\n        int n=s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'(\\')left++;\\n            else right++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(right>left)left=right=0;\\n        }\\n        left=right=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(s[i]==\\')\\')right++;\\n            else left++;\\n            if(left==right)ans=max(ans,right*2);\\n            else if(left>right)left=right=0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100013,
                "title": "c-easy-solution",
                "content": "The key idea is, if you find a valid sequence then replace the indexes  with \"*\".\\nAfter that you can find the longest substring which contains only star within O(n) complexity.\\n![image.png](https://assets.leetcode.com/users/images/4c667b2c-5af5-4d01-af91-b1ea46b8c5ab_1674703023.6571789.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    typedef long long int ll;\\npublic:\\n    int longestValidParentheses(string st) {\\n   stack<pair<char, int>>s;\\n   int n = st.size();\\n   for (int i = 0; i < n; i++)\\n   {\\n      if (st[i] == \\')\\' and !s.empty() and s.top().first == \\'(\\')\\n      {\\n         int t = s.top().second;\\n         st[t] = \\'*\\';\\n         st[i] = \\'*\\'; s.pop();\\n      }\\n      else s.push({st[i], i});\\n   }\\n   ll mx = 0, cnt = 0;\\n   for (int i = 1; i < n; i++)\\n   {\\n      if (st[i] == \\'*\\')cnt = 1;\\n      while (i < n and st[i] == st[i - 1] and st[i] == \\'*\\'){cnt++; i++;}\\n      mx = max(mx, cnt);cnt = 0;\\n   }\\n    cout << mx << endl;\\n    return mx;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long int ll;\\npublic:\\n    int longestValidParentheses(string st) {\\n   stack<pair<char, int>>s;\\n   int n = st.size();\\n   for (int i = 0; i < n; i++)\\n   {\\n      if (st[i] == \\')\\' and !s.empty() and s.top().first == \\'(\\')\\n      {\\n         int t = s.top().second;\\n         st[t] = \\'*\\';\\n         st[i] = \\'*\\'; s.pop();\\n      }\\n      else s.push({st[i], i});\\n   }\\n   ll mx = 0, cnt = 0;\\n   for (int i = 1; i < n; i++)\\n   {\\n      if (st[i] == \\'*\\')cnt = 1;\\n      while (i < n and st[i] == st[i - 1] and st[i] == \\'*\\'){cnt++; i++;}\\n      mx = max(mx, cnt);cnt = 0;\\n   }\\n    cout << mx << endl;\\n    return mx;\\n    }\\n   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3096028,
                "title": "easy-java-stack",
                "content": "\\n\\tclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Character> braces=new Stack<>();\\n        Stack<Integer> index=new Stack<>();\\n        int max=0;\\n        index.push(-1);  // default value\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                braces.push(\\'(\\');\\n                index.push(i);\\n            } \\n            else{ \\n    // str.charAt(i)==\\')\\' closing bracket we will get only two either open or close\\n                if(!braces.isEmpty()&& braces.peek()==\\'(\\'){\\n                    braces.pop();\\n                    index.pop();\\n                    max=Math.max(max,i-index.peek());\\n                }\\n                else{\\n                    index.push(i);\\n                }\\n            }\\n        }\\n        return max;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Character> braces=new Stack<>();\\n        Stack<Integer> index=new Stack<>();\\n        int max=0;\\n        index.push(-1);  // default value\\n        for(int i=0;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\'){\\n                braces.push(\\'(\\');\\n                index.push(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2927444,
                "title": "simple-java-o-n-solution-using-stack",
                "content": "# Intuition\\nContinuous push and pop according to the characters in the string\\nand then checking in last \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        \\n        Stack<Integer> stk = new Stack<>() ;\\n       if(!s.isEmpty())\\n        stk.push(0);\\n        for(int i = 1 ; i< s.length() ;i++){\\n            if(stk.isEmpty())\\n                stk.push(i);\\n           \\n            else if(s.charAt(stk.peek()) == \\'(\\' && s.charAt(i) == \\')\\')\\n            {\\n\\n                stk.pop();\\n            }\\n            else \\n                stk.push(i);\\n                \\n        }\\n       \\n        if(stk.isEmpty())\\n        return s.length() ;\\n        \\n        if(stk.size()==1 && s.length()!=1 && ((stk.peek()==0)|| (stk.peek()==s.length()-1)))\\n        return s.length()-1;\\n      \\n       \\n         int max = 0 ;\\n        int len = s.length() -1;\\n        while(!stk.isEmpty()){\\n            int a =stk.pop();\\n             max = Math.max(len-a,max);\\n            len = a-1;\\n            \\n        }\\n         \\n        return Math.max(max,len-0+1) ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        \\n        Stack<Integer> stk = new Stack<>() ;\\n       if(!s.isEmpty())\\n        stk.push(0);\\n        for(int i = 1 ; i< s.length() ;i++){\\n            if(stk.isEmpty())\\n                stk.push(i);\\n           \\n            else if(s.charAt(stk.peek()) == \\'(\\' && s.charAt(i) == \\')\\')\\n            {\\n\\n                stk.pop();\\n            }\\n            else \\n                stk.push(i);\\n                \\n        }\\n       \\n        if(stk.isEmpty())\\n        return s.length() ;\\n        \\n        if(stk.size()==1 && s.length()!=1 && ((stk.peek()==0)|| (stk.peek()==s.length()-1)))\\n        return s.length()-1;\\n      \\n       \\n         int max = 0 ;\\n        int len = s.length() -1;\\n        while(!stk.isEmpty()){\\n            int a =stk.pop();\\n             max = Math.max(len-a,max);\\n            len = a-1;\\n            \\n        }\\n         \\n        return Math.max(max,len-0+1) ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852493,
                "title": "98-faster-easy-to-understand-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }else{\\n                if(!s.empty() && str[s.top()] == \\'(\\'){\\n                    s.pop();\\n                }\\n                else{\\n                    s.push(i);\\n                }\\n            }\\n        }\\n        if(s.empty())return str.length();\\n        int a = str.length(), b = 0;\\n        int ans = 0;\\n        while(!s.empty()){\\n            b = s.top();\\n            s.pop();\\n            ans = max(ans,a-b-1);\\n            a = b;\\n        }\\n        ans = max(ans,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string str) {\\n        stack<int> s;\\n        for(int i = 0; i < str.length(); i++){\\n            if(str[i]==\\'(\\'){\\n                s.push(i);\\n            }else{\\n                if(!s.empty() && str[s.top()] == \\'(\\'){\\n                    s.pop();\\n                }\\n                else{\\n                    s.push(i);\\n                }\\n            }\\n        }\\n        if(s.empty())return str.length();\\n        int a = str.length(), b = 0;\\n        int ans = 0;\\n        while(!s.empty()){\\n            b = s.top();\\n            s.pop();\\n            ans = max(ans,a-b-1);\\n            a = b;\\n        }\\n        ans = max(ans,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644332,
                "title": "simple-java-solution-with-explanation-in-o-n-tc-and-o-1-sc",
                "content": "```\\nint open = 0, close = 0, max = 0;\\n\\n        for(int i=0;i<s.length();++i){\\n           char c = s.charAt(i);\\n           if(c == \\'(\\'){\\n               open++;\\n           }else{\\n               close++;\\n           }\\n           if(open == close){\\n               max = Math.max(max,open+close);                  // open*2 / close*2 / open+close will give same answer\\n           } else if(close>open) {\\n               open = close = 0;\\n           }\\n        }\\n\\n        open = close = 0;\\n\\n//if u dont understand why i,m doing backward traversal also ,then try to dry run this \"((()\"\\n\\n        for(int i=s.length()-1;i>=0;--i){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                open++;\\n            }else{\\n                close++;\\n            }\\n            if(open == close){\\n                max = Math.max(max,open+close);                  \\n            }else if(close<open) {\\n                open = close = 0;\\n            }\\n        }\\n\\n        return max;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint open = 0, close = 0, max = 0;\\n\\n        for(int i=0;i<s.length();++i){\\n           char c = s.charAt(i);\\n           if(c == \\'(\\'){\\n               open++;\\n           }else{\\n               close++;\\n           }\\n           if(open == close){\\n               max = Math.max(max,open+close);                  // open*2 / close*2 / open+close will give same answer\\n           } else if(close>open) {\\n               open = close = 0;\\n           }\\n        }\\n\\n        open = close = 0;\\n\\n//if u dont understand why i,m doing backward traversal also ,then try to dry run this \"((()\"\\n\\n        for(int i=s.length()-1;i>=0;--i){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\'){\\n                open++;\\n            }else{\\n                close++;\\n            }\\n            if(open == close){\\n                max = Math.max(max,open+close);                  \\n            }else if(close<open) {\\n                open = close = 0;\\n            }\\n        }\\n\\n        return max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2428385,
                "title": "c-stack-o-n",
                "content": "* `prev` stores the index, after which the valid subtring can be found.\\n\\n* if a closing bracket `)` is found without it\\'s previous opening bracket, then we update the `prev` to this index, as the previous valid parenthesis cannot extended through this index.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st ;\\n        int ans = 0 , prev = -1 ;\\n        \\n        for(int i = prev + 1 ; i < s.size() ; ++i ){\\n            if(s[i] == \\'(\\') st.push(i) ;\\n            else{\\n                if(st.empty()) {prev = i ;continue ;}\\n                st.pop() ;\\n                //now update the answer \\n                if(st.size()) ans = max(ans,i-st.top()) ;\\n                else ans = max(ans,i - prev) ;\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st ;\\n        int ans = 0 , prev = -1 ;\\n        \\n        for(int i = prev + 1 ; i < s.size() ; ++i ){\\n            if(s[i] == \\'(\\') st.push(i) ;\\n            else{\\n                if(st.empty()) {prev = i ;continue ;}\\n                st.pop() ;\\n                //now update the answer \\n                if(st.size()) ans = max(ans,i-st.top()) ;\\n                else ans = max(ans,i - prev) ;\\n            }\\n        }\\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262772,
                "title": "java-intuition-easy-understanding-stack",
                "content": "**Inutition:**\\n\\n- Everytime a matching \\')\\' for a \\'(\\' is found we have found a valid parenetheses length. We need to compute the length upto that point and see if it is greater than the previously found length and then accordingly update the maxLength.\\n- We maintain the index positions in a stack. We initialize the stack, even before we start the processing, by pushing an index -1 onto the stack. This initialization of -1 facilitates the computation of the length of the valid parentheses, as -1 represents the index of the last invalid parentheses.\\n- For \\'(\\' we keep track of the start of the parentheses by inserting the index onto the stack, with a hope to find the matching closed \\')\\' one in future. When a closed \\')\\' parentheses is found, we pop out the topmost opening \\'(\\' index and calculate the length of the parentheses, by subtracting the current \\')\\' closing index with the topmost item on the stack, the topmost index will have the index of the invalid parentheses. \\n- In the event, when the stack is empty, we didn\\'t find a matching \\'(\\' brace and hence we cannot calculate a valid length. Instead we keep track of the index of this invalid close \\')\\', as this can be the next -1 position of the next valid parentheses.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max=0;\\n        for(int i=0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\')\\n                stack.push(i);\\n            else{            \\n                stack.pop();\\n                if(stack.isEmpty())\\n                    stack.push(i);\\n                else\\n                    max = Math.max(max, i-stack.peek());\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(-1);\\n        int max=0;\\n        for(int i=0; i < s.length(); i++){\\n            char c = s.charAt(i);\\n            if(c == \\'(\\')\\n                stack.push(i);\\n            else{            \\n                stack.pop();\\n                if(stack.isEmpty())\\n                    stack.push(i);\\n                else\\n                    max = Math.max(max, i-stack.peek());\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069645,
                "title": "c-use-stack-explanation-through-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    //Use stack property to solve this problem\\n    int longestValidParentheses(string s) \\n    {\\n        //storing open parenthesis index in stack \\n        stack<int> st;\\n        // initially push -1 to the stack to avoid close parenthesis \\')\\'\\n        st.push(-1);            \\n        \\n        int count = 0;\\n        \\n        // iterate over the string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // if it is open parenthesis \\'(\\' then push its index into the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if close pathenthesis \\')\\' occur from pop the stack \\n            else\\n            {\\n                st.pop();\\n                \\n                // check whether the stack is empty or not if it is empty \\n                // then push current index into it because if there is another \\')\\' \\n                //then we can not pop index from our stack\\n                if(st.empty())\\n                    st.push(i);\\n                \\n                // if it is not empty then find the length between the (current index i \\n                // and index at stack top) and store max value\\n                else\\n                    count = max(count,i-st.top());\\n            }\\n        }\\n \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use stack property to solve this problem\\n    int longestValidParentheses(string s) \\n    {\\n        //storing open parenthesis index in stack \\n        stack<int> st;\\n        // initially push -1 to the stack to avoid close parenthesis \\')\\'\\n        st.push(-1);            \\n        \\n        int count = 0;\\n        \\n        // iterate over the string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            // if it is open parenthesis \\'(\\' then push its index into the stack\\n            if(s[i] == \\'(\\')\\n                st.push(i);\\n            \\n            // if close pathenthesis \\')\\' occur from pop the stack \\n            else\\n            {\\n                st.pop();\\n                \\n                // check whether the stack is empty or not if it is empty \\n                // then push current index into it because if there is another \\')\\' \\n                //then we can not pop index from our stack\\n                if(st.empty())\\n                    st.push(i);\\n                \\n                // if it is not empty then find the length between the (current index i \\n                // and index at stack top) and store max value\\n                else\\n                    count = max(count,i-st.top());\\n            }\\n        }\\n \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068859,
                "title": "o-n-solution-without-using-stack-faster-than-100",
                "content": "Pls do upvote if you find this useful. \\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        int op=0;\\n        int cl=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                op++;\\n            else if(s[i]==\\')\\')\\n                cl++;\\n\\t\\t\\t\\t// we get our answer when open paranthesis is equals to closed one. \\n            if(op==cl)\\n               ans=max(ans,2*op);\\n\\t\\t\\t   // if count of closed parenthesis is greater than open then reset values to 0. \\n            else if(cl>op)\\n            {  \\n                cl=0;\\n                op=0;\\n            }\\n            \\n        }\\n\\t\\t\\n\\t\\t// Check  same thing in reverse order\\n        cl=0,op=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(s[i]==\\'(\\')\\n               cl++;\\n            else\\n               op++;\\n            \\n            if(op==cl)\\n               ans=max(ans,op*2);\\n            else if(cl>op)\\n            {\\n                cl=0;\\n                op=0;\\n            }\\n                \\n        }\\n          return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n=s.size();\\n        int op=0;\\n        int cl=0;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'(\\')\\n                op++;\\n            else if(s[i]==\\')\\')\\n                cl++;\\n\\t\\t\\t\\t// we get our answer when open paranthesis is equals to closed one. \\n            if(op==cl)\\n               ans=max(ans,2*op);\\n\\t\\t\\t   // if count of closed parenthesis is greater than open then reset values to 0. \\n            else if(cl>op)\\n            {  \\n                cl=0;\\n                op=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2068654,
                "title": "c-o-n-using-stack-without-extra-space",
                "content": "**1. Using Stack:**\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else maxi=max(maxi,i-st.top());\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n```\\nTC-> O(N)    SC->O(N)\\n```\\n\\n**2. Without Extra space:**\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0,close=0, res=0;\\n        // forward traverse:\\n        for(auto ch:s){\\n            if(ch==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(close>open) open=close=0;\\n        }\\n        open=close=0;\\n        // backward traverse:\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(open>close) open=close=0;\\n        }\\n        return res;\\n    }\\n};\\n```\\n```\\nTC-> O(N)    Sc-> O(1) \\n```\\n**If you like it, do upvote!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        stack<int> st;\\n        st.push(-1);\\n        int maxi=0;\\n        for(int i=0;i<s.size();i++) {\\n            if(s[i]==\\'(\\') st.push(i);\\n            else{\\n                st.pop();\\n                if(st.empty()) st.push(i);\\n                else maxi=max(maxi,i-st.top());\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```\n```\\nTC-> O(N)    SC->O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int open=0,close=0, res=0;\\n        // forward traverse:\\n        for(auto ch:s){\\n            if(ch==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(close>open) open=close=0;\\n        }\\n        open=close=0;\\n        // backward traverse:\\n        for(int i=s.size()-1;i>=0;i--){\\n            if(s[i]==\\'(\\') open++;\\n            else close++;\\n            if(open==close) res=max(res,open+close);\\n            else if(open>close) open=close=0;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nTC-> O(N)    Sc-> O(1) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984645,
                "title": "c-o-n-time-and-o-1-space",
                "content": "\\tpublic:\\n\\t\\tint longestValidParentheses(string s) {\\n        \\n        int open = 0, closed = 0; \\n        int maxi = 0;\\n        for(char c:s){\\n            if(c==\\'(\\')\\n                open++;\\n            else if(c==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(closed>open){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        open = 0, closed = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else if(s[i]==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(open>closed){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        return maxi;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tpublic:\\n\\t\\tint longestValidParentheses(string s) {\\n        \\n        int open = 0, closed = 0; \\n        int maxi = 0;\\n        for(char c:s){\\n            if(c==\\'(\\')\\n                open++;\\n            else if(c==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(closed>open){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        open = 0, closed = 0;\\n        for(int i=s.length()-1;i>=0;i--){\\n            if(s[i]==\\'(\\')\\n                open++;\\n            else if(s[i]==\\')\\')\\n                closed++;\\n            \\n            if(open==closed){\\n                maxi = max(maxi, open+closed);\\n            }\\n            else if(open>closed){\\n                open = closed = 0;\\n            }\\n        }\\n        \\n        return maxi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1877261,
                "title": "very-simple-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a5e86a84-f7e5-4bf4-9300-73a48301dafc_1648060029.66314.png)\\n\\n1. A bracket can either be a part of valid parentheses or not.\\n2. We can assign a flag to each parentheses. 0 - part of invalid parentheses, 1 - part of valid parentheses\\n3. Once we have marked every bracket with a flag we will have an array containing only 0s and 1s.\\n4. We can find the length of largest subarray filled with only 1s using prefix sum.\\n5. The length of the largest subarray filled with only 1s will be the length of longest valid parentheses.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.size();\\n        vector<int> flags(n, 0);\\n        \\n        stack<pair<char, int>> stk;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s[i];\\n\\n            if (stk.empty()) stk.push({ch, i});\\n            else {\\n                if (stk.top().first == \\'(\\' && ch == \\')\\') {\\n                    flags[i] = 1;\\n                    flags[stk.top().second] = true;\\n                    stk.pop();\\n                } else stk.push({ch, i});\\n            }\\n        }\\n        \\n        int maxLen = 0;\\n\\n        int prefix = 0;\\n        // longest length of consecutive 1s\\n        for(int flag: flags) {\\n            if (flag == 0) prefix = 0;\\n            else {\\n                prefix++;\\n                maxLen = max(prefix, maxLen);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.size();\\n        vector<int> flags(n, 0);\\n        \\n        stack<pair<char, int>> stk;\\n        for(int i = 0; i < n; i++) {\\n            char ch = s[i];\\n\\n            if (stk.empty()) stk.push({ch, i});\\n            else {\\n                if (stk.top().first == \\'(\\' && ch == \\')\\') {\\n                    flags[i] = 1;\\n                    flags[stk.top().second] = true;\\n                    stk.pop();\\n                } else stk.push({ch, i});\\n            }\\n        }\\n        \\n        int maxLen = 0;\\n\\n        int prefix = 0;\\n        // longest length of consecutive 1s\\n        for(int flag: flags) {\\n            if (flag == 0) prefix = 0;\\n            else {\\n                prefix++;\\n                maxLen = max(prefix, maxLen);\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1571083,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572316,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1574996,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568026,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572211,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568853,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1566722,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1571085,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 2042924,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1704382,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1571083,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572316,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1574996,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568026,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1572211,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1568853,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1566722,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1571085,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 2042924,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1704382,
                "content": [
                    {
                        "username": "uuisafresh",
                        "content": "So in this case I use stack and an array, and then change this problem as **finding longest continuous 1 in a 01 array**. Let me tell how to do it.\\n\\nFirst, stack push position of each '(', then when we meet ')' I pop stack to find its match'('\\uff0c place both ')' and '(' as 1 in array\\n\\nFor example, (()()\\uff0carray should look like[0,1,1,1,1]\\n\\nThen it is super easy, to find out longest substring that all items are 1 !!!"
                    },
                    {
                        "username": "birindersinghji",
                        "content": "Here\\'s the Python implementation of this solution!\\n\\n```\\ndef longestValidParentheses(s: str) -> int:\\n        # Convert to an array of 1s\\n        stack = []\\n        ans = [0] * len(s)\\n\\n        for i, char in enumerate(s):\\n            if not stack or char == \"(\":\\n                stack.append((char, i))\\n            \\n            elif char == \")\":\\n                if stack[-1][0] == \"(\":\\n                    _, idx = stack.pop()\\n                    ans[i], ans[idx] = 1, 1\\n                else:\\n                    stack.append((\")\", i))\\n\\n        # Now find the longest substring of 1s\\n        ones = 0\\n        ret = 0\\n        for char in ans:\\n            if char == 1:\\n                ones+=1\\n                ret = max(ret, ones)\\n            else:\\n                ones = 0\\n        \\n        return ret\\n```"
                    },
                    {
                        "username": "Simonvu",
                        "content": "brilliant!!"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "[@PredatorMK2](/PredatorMK2) do you fully understand his approach?"
                    },
                    {
                        "username": "PredatorMK2",
                        "content": "this code will fail because of testcase \")(\" as it is not balanced and this approach will return 2 for it\\n"
                    },
                    {
                        "username": "lotus18",
                        "content": "Great Idea!\\n\\nCode For The Above Approach\\n\\nclass Solution \\n{\\npublic:\\n    int longestValidParentheses(string s) \\n    {\\n        stack<pair<int,int>> st;\\n        int n=s.size();\\n        vector<int> v(n,0);\\n        for(int x=0; x<n; x++)\\n        {\\n            if(s[x]==\\'(\\') st.push({s[x],x});\\n            else\\n            {\\n                if(!st.empty() && st.top().first==\\'(\\')\\n                {\\n                    v[x]=1;\\n                    v[st.top().second]=1;\\n                    st.pop();\\n                }\\n            }\\n        }\\n        int start=-1, end=-1;\\n        int ans=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(v[x]==1)\\n            {\\n                start=x;\\n                int i=x+1;\\n                while(i<n && v[i]) i++;\\n                end=i-1;\\n                x=end;\\n                ans=max(ans,end-start+1);\\n                start=-1,end=-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "viocost",
                        "content": "The description only shows example with ()() sequences being correct.\\nHow about this: (()()) or this ((()(())))? Are they correct?"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Yep they\\'re correct"
                    },
                    {
                        "username": "Akshay1740",
                        "content": "yes they are also correct."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "This is just a monotonic Stack problem like Next Greater element or Previous Smaller element but the only difference is that we are trying to maintain the order inside the stack instead of a monotonically increasing or decreasing sequence.\\n\\nStack Problems can be broken down into 1 or 2 algorithmic techniques and this is one of them!\\n\\nSimilar Problems :\\nNext Greater Element\\nNext Smaller Element\\nPrevious Greater Element\\nPrevious Smaller Element\\nLargest Rectangle in Histogram\\n\\nCheers && Happy Coding !"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Thanks man. "
                    },
                    {
                        "username": "nirajthakare",
                        "content": "really helpful!!!"
                    },
                    {
                        "username": "av9ash",
                        "content": "()(() how is this the longest valid parentheses? Answer is 4 I think its 2\\nCan someone please explain"
                    },
                    {
                        "username": "abdulwaheed333",
                        "content": "Of course ! you are right but  first we have to find is it valid or not? .So in this there are two valid outputs () and (). length is 4."
                    },
                    {
                        "username": "singhabhinash",
                        "content": "think your logic based on below test case, it will work\ns = \"()((())(()()()\", longestValidParentheses = max(2, 4, 6) = 6"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "I realised that, questions is asking for longest possible substring , not the subsequence.  In case of subsequence ans will be 4, and incase of substring ans will 2"
                    },
                    {
                        "username": "Cozmos77",
                        "content": "[@a13375572211](/a13375572211) exactly ,faced the same issue and i think the answer should be 4 rather than 2.\\n"
                    },
                    {
                        "username": "calm27",
                        "content": "[@a13375572211](/a13375572211) did you try to address this test case? I faced same problem and there are no buttons for report "
                    },
                    {
                        "username": "mandliyarajendra11",
                        "content": "[@a13375572211](/a13375572211) bro need longest i found invalid then count start from 0"
                    },
                    {
                        "username": "a13375572211",
                        "content": "The answer is 2 but i got 4 and its saying incorrect, but i think its suppose to be 4 because ()(() has 2 valid parentheses"
                    },
                    {
                        "username": "dj_ios1988",
                        "content": "from the description:\nInput: \"(()\"\nOutput: 2\n\nand in the testcase\nInput: “\"()(()\"”\nOutput: 4\nExpected :2\n\nwhy these two have diferent answer of \"(()\" ?\n"
                    },
                    {
                        "username": "shubhankadam",
                        "content": "[@a13375572211](/a13375572211) it expects the longest correct sequence, here it is 2, since the sequence is broken by \\'(\\' in the middle\\n"
                    },
                    {
                        "username": "a13375572211",
                        "content": "Exactly bro, I have the same question"
                    },
                    {
                        "username": "shawngao",
                        "content": "@administrators Is this intended or not?\\n\\nAll Java solution will TLE on this test case:\\n\\n\"((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((\""
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 24.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/longest-valid-parentheses/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Using Dynamic Programming\n\n  \n**Approach 3:** Using Stack\n\n  \n**Approach 4:** Without extra space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "MohitBansal_",
                        "content": "i done  this question by storing index\\'s of opening bracket in stack\\ncan any body know  other approach? "
                    },
                    {
                        "username": "1337beef",
                        "content": "Is this  (())  counted as valid?"
                    },
                    {
                        "username": "manishsinghrajwar80",
                        "content": "yes"
                    },
                    {
                        "username": "Om_Kumar_Singh",
                        "content": "Keep in mind that string must be valid, for example \"()(()\" answer will be 2. "
                    },
                    {
                        "username": "10gksten",
                        "content": "s = \"()(())\"\\nhow come the expected output is 6?"
                    },
                    {
                        "username": "default-writer",
                        "content": "by definition any sequence not breaking the source rules are valid"
                    },
                    {
                        "username": "10gksten",
                        "content": "[@MrLambda42](/MrLambda42) I will take a look on the pdf and get back on this. Thankyou"
                    },
                    {
                        "username": "MrLambda42",
                        "content": "Looks like it\\'s the longest valid sequence of consecutive properly closed parentheses [len(\"()\") + len(\"(())\")] and not just longest singular sequence of properly closed parentheses like max[len(\"()\"), len(\"(())\")].\\n\\nex: \"()(()\" gives 2 because the second ( is not closed, so the streak is maxed out at 2.\\nOn the other hand, ()(()) has two consecutive sequences that match to 2 + 4 => \"()\" + \"(())\" = 6.\\n\\nThere are some graphs in https://madalgo.au.dk/fileadmin/madalgo/OA_PDF_s/C471.pdf that illustrate how parentheses are balanced and how one may reach the conclusion of the longest consecutive sequence of closed parentheses."
                    }
                ]
            },
            {
                "id": 1576835,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1574745,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1571084,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1576733,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2060510,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2052159,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2024840,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2022604,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 2005752,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1999896,
                "content": [
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/"
                    },
                    {
                        "username": "Goober",
                        "content": "https://leetcode.com/submissions/detail/435599297/\\n\\n1. **use stack**.\\njust if match \"()\" then just pop and then left stack head cnt++\\n2. **use map to record the valid parenthess counts of head element of stack**\\nuse element struct for recording each index in string and value of each index in string\\n\\n"
                    },
                    {
                        "username": "i3",
                        "content": "![enter image description here][1]\\n\\n\\n  [1]: http://wanzy.me/1.png\\n\\nGot \"Wrong answer\" while \"Run Code\" gave the right result."
                    },
                    {
                        "username": "pythonProgrammerHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/longest-valid-parentheses-leetcode-python/\\n"
                    },
                    {
                        "username": "Aayushyu",
                        "content": "The examples should also show that nested parenthesis are also considered in it and must be taken accounted for."
                    },
                    {
                        "username": "nasheethahmeda04",
                        "content": "TLE in SUBMIT but ACCEPTED in TEST CASE\\n\\n\\nSo I tried to solve this by traversing each substring from longest to shortest, I return the current length if any of the substring is valid.\\n\\nMy code:\\n ```\\nclass Solution(object):\\n    def longestValidParentheses(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n\\n        l = len(s)\\n        for i in range(l, 1, -1):\\n            for j in range(l - i + 1):\\n                if self.valid(s[j:i+j]):\\n                    return i\\n        else:\\n            return 0\\n    \\n    def valid(self, parenthesis):\\n        legal = 0\\n        for ch in parenthesis:\\n            if ch == \\'(\\':\\n                legal += 1\\n            elif legal <= 0:\\n                return False\\n            else:\\n                legal -= 1\\n        return True if legal == 0 else False\\n```\\n\\nit sometimes shows TLE in 226/231 and sometimes in 227/231 etc...\\nit solves both of those cases and other cases in TEST CASES.\\n\\nhttps://support.leetcode.com/hc/en-us/articles/360011834174-I-encountered-Wrong-Answer-Runtime-Error-for-a-specific-test-case-When-I-test-my-code-using-this-test-case-it-produced-the-correct-output-Why-\\n\\nin that it says I should not use any global or static variables, afaik I did not use any of them. But i have used a function to validate a string, it is still a method and using it as a global function does not change the outcome too.\\n\\nPlease point out any corrections and do inform me, thanks"
                    },
                    {
                        "username": "user8272RT",
                        "content": "When I see parentheses, I think of stack."
                    },
                    {
                        "username": "ankit_lekhak03",
                        "content": "Why is there a Dynamic Programming tag for this question???\\nThe solution seems to do nothing with dynamic programming!!\\n"
                    },
                    {
                        "username": "pijjalover",
                        "content": "()(()\\nhow is this 2 only? It isnt written that the parenthesis must be continous..."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "This is a medium-level problem since $$O(n^2)$$ solution gets accepted. If the constraints were >= $$10^5$$, it would be hard.\\n\\nMy $$O(n^2)$$ solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestValidParentheses(string s) {\\n        int n = s.length(), res = 0;\\n        for(int i = 0; i < n; i++){\\n            int cnt = 0;\\n            for(int j = i; j < n; j++){\\n                if(!cnt and s[j] == \\')\\') break;\\n                if(s[j] == \\'(\\') cnt++;\\n                else cnt--;\\n                if(!cnt) res = max(res, j - i + 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n"
                    }
                ]
            },
            {
                "id": 1980238,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1959430,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1932622,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1926106,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1888182,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1864340,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1851831,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1839542,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1835929,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            },
            {
                "id": 1755754,
                "content": [
                    {
                        "username": "harchetsingh12",
                        "content": "i dont think this should be hard\\n"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Most simplest approach I have seen till now. Only you need to mark for valid ones and count after. It may not be optimized but it is good until it passing all testcases.\\n[Solution](https://leetcode.com/problems/longest-valid-parentheses/solutions/3729896/unique-approach-easy-to-understand-the-question/)"
                    },
                    {
                        "username": "prixxx",
                        "content": "how is \"()(()\" the answer for this testcase equal to 2? could someone explain\\n shouldnt it be 4?"
                    },
                    {
                        "username": "yshaikh2424",
                        "content": "Valid parentheses are not in a substring."
                    },
                    {
                        "username": "IsaiUriepero",
                        "content": "The function returns the length of the longest valid parentheses substring in the given string."
                    },
                    {
                        "username": "Lokesh04",
                        "content": "what will be the output if s=\"()(()))()()()\"\\ngiven solution giving 8 but i think it should be 14 answer"
                    },
                    {
                        "username": "prshntvrm1",
                        "content": "How  for the following string \"()(()\":\\nthe expected output is 2 \\nwhile code output is 4, which seems tobe correct ?"
                    },
                    {
                        "username": "user8326LT",
                        "content": "why does this output will be 2  for this testcase \"()(()\""
                    },
                    {
                        "username": "marshel__69",
                        "content": "how the heck answer for this \"()(()\" is 2"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question mentioned substring so i think the middle \\'(\\' breaks the string. so we must return the longest substring length.\\nIt may be wrong. I too have the same doubt."
                    },
                    {
                        "username": "Stellar_Serene",
                        "content": "if you encounter the problem of index out of bounds with the illegal index of -128, you might be defining stack pointer as char like me."
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "hey hi hello , can anyone tell me what is wrong with my code and why i am getting run time error with this \n\nclass Solution {\npublic:\n    int longestValidParentheses(string expr) {\n        int counter=0;\n        stack<char> temp;\n        vector<int> ans;\n    for (int i = 0; i < expr.length(); i++) {\n        if (temp.empty()) {\n            temp.push(expr[i]);\n        }\n        else if ((temp.top() == '(' && expr[i] == ')')\n                 || (temp.top() == '{' && expr[i] == '}')\n                 || (temp.top() == '[' && expr[i] == ']')) {\n            temp.pop();\n            counter=counter+2;\n            ans.push_back(counter);\n        }\n        else {\n            temp.push(expr[i]);\n            counter=0;\n        }\n    }\n   int sie=ans.size();\n   return ans[sie-1];\n    }\n};"
                    }
                ]
            }
        ]
    }
]