[
    {
        "title": "Spiral Matrix III",
        "question_content": "You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.\nReturn an array of coordinates representing the positions of the grid in the order you visited them.\n&nbsp;\nExample 1:\n\nInput: rows = 1, cols = 4, rStart = 0, cStart = 0\nOutput: [[0,0],[0,1],[0,2],[0,3]]\n\nExample 2:\n\nInput: rows = 5, cols = 6, rStart = 1, cStart = 4\nOutput: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n\n&nbsp;\nConstraints:\n\n\t1 <= rows, cols <= 100\n\t0 <= rStart < rows\n\t0 <= cStart < cols",
        "solutions": [
            {
                "id": 158970,
                "title": "c-java-python-1-1-2-2-3-3-steps",
                "content": "## **Intuition**:\\nTake steps one by one.\\nIf the location is inside of grid, add it to `res`.\\nBut how to simulate the path?\\n\\nIt seems to be annoying, but if we observer the path:\\n\\nmove right `1` step, turn right\\nmove down `1` step, turn right\\nmove left `2` steps, turn right\\nmove top `2` steps, turn right,\\nmove right `3` steps, turn right\\nmove down `3` steps, turn right\\nmove left `4` steps, turn right\\nmove top `4` steps, turn right,\\n\\nwe can find the sequence of steps: 1,1,2,2,3,3,4,4,5,5....\\n\\nSo there are two thing to figure out:\\n1. how to generate sequence 1,1,2,2,3,3,4,4,5,5\\n2. how to turn right?\\n<br>\\n\\n## **Generate sequence 1,1,2,2,3,3,4,4,5,5**\\nLet `n` be index of this sequence.\\nThen `A0 = 1`, `A1 = 1`, `A2 = 2` ......\\nWe can find that `An = n / 2 + 1`\\n<br>\\n\\n## **How to turn right?**\\nBy cross product:\\nAssume current direction is (x, y) in plane, which is (x, y, 0) in space.\\nThen the direction after turn right (x, y, 0) \\xD7 (0, 0, 1) = (y, -x, 0)\\nTranslate to code: `tmp = x; x = y; y = -tmp;`\\n\\nBy arrays of arrays:\\nThe directions order is (0,1),(1,0),(0,-1),(-1,0), then repeat.\\nJust define a variable.\\n<br>\\n\\n## **Time Complexity**:\\nTime `O(max(R,C)^2)`\\nSpace `O(R*C)` for output\\n<br>\\n\\n**Java:**\\n```java\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int dx = 0, dy = 1, n = 0, tmp;\\n        for (int j = 0; j < R * C; ++n) {\\n            for (int i = 0; i < n / 2 + 1; ++i) {\\n                if (0 <= x && x < R && 0 <= y && y < C)\\n                    res[j++] = new int[] {x, y};\\n                x += dx;\\n                y += dy;\\n            }\\n            tmp = dx;\\n            dx = dy;\\n            dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\\n**C++:**\\n```cpp\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r, int c) {\\n        vector<vector<int>> res = {{r, c}};\\n        int dx = 0, dy = 1, tmp;\\n        for (int n = 0; res.size() < R * C; n++) {\\n            for (int i = 0; i < n / 2 + 1; i++) {\\n                r += dx, c += dy;\\n                if (0 <= r && r < R && 0 <= c && c < C)\\n                    res.push_back({r, c});\\n            }\\n            tmp = dx, dx = dy, dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```python\\n    def spiralMatrixIII(self, R, C, x, y):\\n        res = []\\n        dx, dy, n = 0, 1, 0\\n        while len(res) < R * C:\\n            for i in xrange(n / 2 + 1):\\n                if 0 <= x < R and 0 <= y < C:\\n                    res.append([x, y])\\n                x, y = x + dx, y + dy\\n            dx, dy, n = dy, -dx, n + 1\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int dx = 0, dy = 1, n = 0, tmp;\\n        for (int j = 0; j < R * C; ++n) {\\n            for (int i = 0; i < n / 2 + 1; ++i) {\\n                if (0 <= x && x < R && 0 <= y && y < C)\\n                    res[j++] = new int[] {x, y};\\n                x += dx;\\n                y += dy;\\n            }\\n            tmp = dx;\\n            dx = dy;\\n            dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r, int c) {\\n        vector<vector<int>> res = {{r, c}};\\n        int dx = 0, dy = 1, tmp;\\n        for (int n = 0; res.size() < R * C; n++) {\\n            for (int i = 0; i < n / 2 + 1; i++) {\\n                r += dx, c += dy;\\n                if (0 <= r && r < R && 0 <= c && c < C)\\n                    res.push_back({r, c});\\n            }\\n            tmp = dx, dx = dy, dy = -tmp;\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def spiralMatrixIII(self, R, C, x, y):\\n        res = []\\n        dx, dy, n = 0, 1, 0\\n        while len(res) < R * C:\\n            for i in xrange(n / 2 + 1):\\n                if 0 <= x < R and 0 <= y < C:\\n                    res.append([x, y])\\n                x, y = x + dx, y + dy\\n            dx, dy, n = dy, -dx, n + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158977,
                "title": "java-15-lines-concise-solution-with-comments",
                "content": "```Java\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] dirt = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // east, south, west, north\\n        List<int[]> res = new ArrayList<>();\\n        int len = 0, d = 0; // move <len> steps in the <d> direction\\n        res.add(new int[]{r0, c0});\\n        while (res.size() < R * C) {\\n            if (d == 0 || d == 2) len++; // when move east or west, the length of path need plus 1 \\n            for (int i = 0; i < len; i++) {\\n                r0 += dirt[d][0];\\n                c0 += dirt[d][1];\\n                if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C) // check valid\\n                    res.add(new int[]{r0, c0});\\n            }\\n            d = (d + 1) % 4; // turn to next direction\\n        }\\n        return res.toArray(new int[R * C][2]);\\n    }\\n```",
                "solutionTags": [],
                "code": "```Java\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] dirt = new int[][]{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // east, south, west, north\\n        List<int[]> res = new ArrayList<>();\\n        int len = 0, d = 0; // move <len> steps in the <d> direction\\n        res.add(new int[]{r0, c0});\\n        while (res.size() < R * C) {\\n            if (d == 0 || d == 2) len++; // when move east or west, the length of path need plus 1 \\n            for (int i = 0; i < len; i++) {\\n                r0 += dirt[d][0];\\n                c0 += dirt[d][1];\\n                if (r0 >= 0 && r0 < R && c0 >= 0 && c0 < C) // check valid\\n                    res.add(new int[]{r0, c0});\\n            }\\n            d = (d + 1) % 4; // turn to next direction\\n        }\\n        return res.toArray(new int[R * C][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362319,
                "title": "super-clean-code-python",
                "content": "The idea is that you keep a \"ghost\" point which keeps moving and whenever the ghost point takes a step you check if it\\'s valid. If valid, append to the return array. \\n\\n```\\nclass Solution(object):\\n    \\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        ret = [(r0, c0)] \\n        is_valid = lambda row, col: row >= 0 and row < R and col >= 0 and col < C \\n        \\n        steps = 1 \\n        r, c = r0, c0 \\n        while len(ret) < R * C: \\n            # Go east 1\\n            for step in xrange(steps):\\n                r, c = r, c + 1 \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            # Go down 1 \\n            for step in xrange(steps):\\n                r, c = r + 1, c \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            steps += 1\\n                    \\n            # Go west 2 \\n            for step in xrange(steps):\\n                r, c = r, c - 1\\n                if is_valid(r, c): ret.append((r, c))           \\n            \\n            # Go north 2 \\n            for step in xrange(steps):\\n                r, c = r - 1, c \\n                if is_valid(r, c): ret.append((r, c))           \\n                    \\n            steps += 1\\n            \\n        return ret \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        ret = [(r0, c0)] \\n        is_valid = lambda row, col: row >= 0 and row < R and col >= 0 and col < C \\n        \\n        steps = 1 \\n        r, c = r0, c0 \\n        while len(ret) < R * C: \\n            # Go east 1\\n            for step in xrange(steps):\\n                r, c = r, c + 1 \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            # Go down 1 \\n            for step in xrange(steps):\\n                r, c = r + 1, c \\n                if is_valid(r, c): ret.append((r, c))\\n                    \\n            steps += 1\\n                    \\n            # Go west 2 \\n            for step in xrange(steps):\\n                r, c = r, c - 1\\n                if is_valid(r, c): ret.append((r, c))           \\n            \\n            # Go north 2 \\n            for step in xrange(steps):\\n                r, c = r - 1, c \\n                if is_valid(r, c): ret.append((r, c))           \\n                    \\n            steps += 1\\n            \\n        return ret \\n```",
                "codeTag": "Java"
            },
            {
                "id": 158971,
                "title": "python-sort-all-coordinates",
                "content": "Put all valid coordinates to a list `res`\\n\\nSort all coordinates by the following rule:\\n\\n0. Change coordinates to a relative coordinates to center.\\n\\n1. Sort ascending by the distance to the center `max(abs(x), abs(y))`\\nIf `max(abs(x), abs(y)) == 0`, it\\'s the center.\\nIf `max(abs(x), abs(y)) == 1`, it\\'s in the first layer around the center\\n\\n2. Sort descending by the angle to the center `max(abs(x), abs(y))`\\n\\n\\n**Python:**\\n```\\n    def spiralMatrixIII(self, R, C, r, c):\\n        def key((x, y)):\\n            x, y = x - r, y - c\\n            return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2)))\\n        return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key)\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    def spiralMatrixIII(self, R, C, r, c):\\n        def key((x, y)):\\n            x, y = x - r, y - c\\n            return (max(abs(x), abs(y)), -((math.atan2(-1, 1) - math.atan2(x, y)) % (math.pi * 2)))\\n        return sorted([(i, j) for i in xrange(R) for j in xrange(C)], key=key)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 163370,
                "title": "simple-easy-to-understand-java-solution",
                "content": "The idea here is that once we start at (r=r0, c=c0), we walk along the east, then south, then west, and then north. \\n\\nWhen we go east, we do c++ (column increases), when we go west, we do c--, when we go south, we do r++ (row increases), and when we go north, we do r--.\\n\\nAfter starting at (r0,c0), we need to walk in spirals, where the length of the spiral increases after every two directions. For example 2, we start at (r0=1, c0=4), then we go east by one length, we go south by one length. Following that, we go west by 2 length and then, go north by 2 length. After that, we go in next directions by 3 lengths, and so on.\\n\\nThe trick here is that we continue to walk in spiral, whether the current (r,c) is valid or not. However, we add (r,c) to the result only if it is valid.\\n\\n```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511489,
                "title": "java-tc-o-max-r-c-2-sc-o-1-simulating-a-spiral-walk",
                "content": "```java\\n/**\\n * Distance covered in each direction follows 1, 1, 2, 2, 3, 3, 4, 4... pattern.\\n *\\n * Order of directions: Right, Down, Left, Up. Whenever the direction becomes\\n * right or left, the distance travelled in that direction increases by 1.\\n *\\n * So the distance travelled is sum of 1, 1, 2, 2, ... 2*max(R,C), 2*max(R,C).\\n *\\n * Time Complexity: O(max(R, C)^2)\\n *\\n * Space Complexity: O(1) -> Excluding the result.\\n *\\n * R = Input number of rows. C = Input number of columns.\\n */\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        if (rows < 0 || cols < 0 || rStart < 0 || rStart >= rows || cStart < 0 || cStart >= cols) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int totalLen = rows * cols;\\n        int[][] result = new int[totalLen][2];\\n        result[0] = new int[] { rStart, cStart };\\n        if (totalLen == 1) {\\n            return result;\\n        }\\n\\n        int dist = 0;\\n        int row = rStart;\\n        int col = cStart;\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int dirIdx = 0;\\n        int count = 1;\\n\\n        while (count < totalLen) {\\n            if (dirIdx == 0 || dirIdx == 2) {\\n                dist++;\\n            }\\n            for (int i = 1; i <= dist; i++) {\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n                if (row >= 0 && row < rows && col >= 0 && col < cols) {\\n                    result[count++] = new int[] { row, col };\\n                    if (count == totalLen) {\\n                        return result;\\n                    }\\n                }\\n            }\\n            dirIdx = (dirIdx + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Spiral Matrix question on LeetCode:\\n- [54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/discuss/1511476/Java-or-TC:-O(M*N)-or-SC:-O(1)-or-Optimized-solution-using-Switch-Case)\\n- [59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/discuss/1511479/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Multiple-optimized-ways-to-solve-this-question)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Distance covered in each direction follows 1, 1, 2, 2, 3, 3, 4, 4... pattern.\\n *\\n * Order of directions: Right, Down, Left, Up. Whenever the direction becomes\\n * right or left, the distance travelled in that direction increases by 1.\\n *\\n * So the distance travelled is sum of 1, 1, 2, 2, ... 2*max(R,C), 2*max(R,C).\\n *\\n * Time Complexity: O(max(R, C)^2)\\n *\\n * Space Complexity: O(1) -> Excluding the result.\\n *\\n * R = Input number of rows. C = Input number of columns.\\n */\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        if (rows < 0 || cols < 0 || rStart < 0 || rStart >= rows || cStart < 0 || cStart >= cols) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int totalLen = rows * cols;\\n        int[][] result = new int[totalLen][2];\\n        result[0] = new int[] { rStart, cStart };\\n        if (totalLen == 1) {\\n            return result;\\n        }\\n\\n        int dist = 0;\\n        int row = rStart;\\n        int col = cStart;\\n        int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n        int dirIdx = 0;\\n        int count = 1;\\n\\n        while (count < totalLen) {\\n            if (dirIdx == 0 || dirIdx == 2) {\\n                dist++;\\n            }\\n            for (int i = 1; i <= dist; i++) {\\n                row += dirs[dirIdx][0];\\n                col += dirs[dirIdx][1];\\n                if (row >= 0 && row < rows && col >= 0 && col < cols) {\\n                    result[count++] = new int[] { row, col };\\n                    if (count == totalLen) {\\n                        return result;\\n                    }\\n                }\\n            }\\n            dirIdx = (dirIdx + 1) % 4;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159128,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {\\n        \\n        vector<vector<int>>sol;\\n        int n = 0;\\n        int step=1;\\n\\twhile(n<R*C){\\n\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx++;\\n\\t\\t}\\n\\t\\tstep++;\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty--;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx--;\\n\\t\\t}\\n\\t\\tstep++;\\n\\n\\n\\n\\t}\\n        \\n        return sol;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int x, int y) {\\n        \\n        vector<vector<int>>sol;\\n        int n = 0;\\n        int step=1;\\n\\twhile(n<R*C){\\n\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx++;\\n\\t\\t}\\n\\t\\tstep++;\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\ty--;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < step; ++i)\\n\\t\\t{\\n\\t\\t\\tif(x>=0 and x<R and y>=0 and y<C)sol.push_back(vector<int>{x,y}),n++;\\n\\t\\t\\tx--;\\n\\t\\t}\\n\\t\\tstep++;\\n\\n\\n\\n\\t}\\n        \\n        return sol;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184851,
                "title": "python-beats-100",
                "content": "```\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = r0\n        j = c0\n        coordinates = [[r0, c0]]\n        step_size = 1\n        sign = 1\n        while len(coordinates) < R*C:\n            for _ in range(step_size):\n                j += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            for _ in range(step_size):\n                i += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            step_size += 1\n            sign *= -1\n        return coordinates\n```",
                "solutionTags": [],
                "code": "```\nclass Solution(object):\n    def spiralMatrixIII(self, R, C, r0, c0):\n        \"\"\"\n        :type R: int\n        :type C: int\n        :type r0: int\n        :type c0: int\n        :rtype: List[List[int]]\n        \"\"\"\n        i = r0\n        j = c0\n        coordinates = [[r0, c0]]\n        step_size = 1\n        sign = 1\n        while len(coordinates) < R*C:\n            for _ in range(step_size):\n                j += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            for _ in range(step_size):\n                i += sign\n                if i < R and j < C and i >= 0 and j >= 0:\n                    coordinates.append([i, j])\n            \n            step_size += 1\n            sign *= -1\n        return coordinates\n```",
                "codeTag": "Java"
            },
            {
                "id": 158954,
                "title": "java-simulation-17-lines-with-line-by-line-explanation",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res= new int[R*C][2];\\n        res[0]=new int[]{r0, c0};\\n        int len=0, idx=1, k=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (idx<R*C){\\n            len++;\\n            for (int round=0; round<2; round++){\\n                for (int sz=len; sz>0; sz--){\\n                    r0+=d[k];\\n                    c0+=d[k+1];\\n                    if (r0<0 || r0>=R || c0<0 || c0>=C) continue;\\n                    res[idx++]=new int[]{r0, c0};\\n                }\\n                k=(k+1)%4;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/caraxin/image_1534044938.png)\\n\\nHappy Coding!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res= new int[R*C][2];\\n        res[0]=new int[]{r0, c0};\\n        int len=0, idx=1, k=0;\\n        int[] d= new int[]{0,1,0,-1,0};\\n        while (idx<R*C){\\n            len++;\\n            for (int round=0; round<2; round++){\\n                for (int sz=len; sz>0; sz--){\\n                    r0+=d[k];\\n                    c0+=d[k+1];\\n                    if (r0<0 || r0>=R || c0<0 || c0>=C) continue;\\n                    res[idx++]=new int[]{r0, c0};\\n                }\\n                k=(k+1)%4;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483264,
                "title": "sort-coordinates-python",
                "content": "Sort by:\\n1) layer = max(&Delta;r, &Delta;c)\\n2) right-bottom half before left-top half\\n3) By r and c (increasing or decreasing depending on the half)\\n```\\ndef spiralMatrixIII(self, R, C, r0, c0):\\n    return sorted([[r, c] for r in range(R) for c in range(C)],\\n                  key=lambda (r, c): (max(abs(r - r0), abs(c - c0)),\\n                                      (0, r, -c) if r + c > r0 + c0 else (1, -r, c)))\\n```\\nWritten after seeing @lee215\\'s title \"[Sort All Coordinates](https://leetcode.com/problems/spiral-matrix-iii/discuss/158971/Python-Sort-All-Coordinates)\" but before looking at its code.",
                "solutionTags": [],
                "code": "```\\ndef spiralMatrixIII(self, R, C, r0, c0):\\n    return sorted([[r, c] for r in range(R) for c in range(C)],\\n                  key=lambda (r, c): (max(abs(r - r0), abs(c - c0)),\\n                                      (0, r, -c) if r + c > r0 + c0 else (1, -r, c)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 482757,
                "title": "c-from-approach-to-implementation-explained",
                "content": "# Observation 1- How to traverse\\nIn this approach I have traversed the path of the spiral after making a few observations. If you refer \\nExample 2, R = 5, C = 6, r0 = 1, c0 = 4, you will notice the direction of the walk does not change\\nfrom 1 to 2, \\n2 to 3, \\n3 to 5,\\n5 to 7, ....\\nHere  2-1 = 3-2\\n5-3 = 7-5\\n![image](https://assets.leetcode.com/users/debipur/image_1579243848.png)\\nThis brings us to our first observation, the length of the line along which direction does not change\\nremains equal after the odd number of changes and after even direction changes the length \\nincreases by 1.\\n# Approach\\nSo, our approach here is we keep track of our current coordinates. Also have a array which stores the\\nchange required to move right, down, left and up respectively :- {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}.\\nAccording to the no. of steps taken, position in current line and no. of direction changes we make \\nthe change to our current cordinate. At each coordinate we check whether it is a valid cell, if so we \\npush it to answer.\\n```\\ninline bool isvalid(vector<int> &cur, int R, int C){\\n\\tif(cur[0] >= 0 && cur[1] >= 0 && cur[0] < R && cur[1] < C)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\\n# Observation 2- How long to traverse\\nThe question is how long we need to move? If you draw(rather imagine) the spiral, for the following\\nboundary case it answers our question, R = 100, C = 1, r0 = 0, c0 = 0. You will find (2*max(R, C))^2 is\\nthe maximum number of steps you will need.\\n```\\nvector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> ans;\\n        vector<int> cur = {r0, c0};\\n        ans.push_back(cur);\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int totsteps = 2*max(R, C); totsteps*=totsteps;\\n\\t\\tint stepi = 0, d = 0;                    //tracks i th step and d th direction change\\n        int linelen = 1;\\n        while(stepi <= totsteps){\\n            for(int a = 1; a <=2; ++a){          // looping twice for same length\\n                int k = 1;                       //tracks steps taken in current line\\n                while(k <= linelen){\\n                    cur[0] += dir[d][0];\\n                    cur[1] += dir[d][1];\\n                    if(isvalid(cur, R, C)) ans.push_back(cur);\\n                    k++; stepi++;\\n                }\\n                d = (d+1)%4;\\n            }\\n            linelen++;\\n        }\\n        return ans;\\n    }\\n```\\nMy first post here in leetcode :)\\nLet me know if this helped or did I leave out details.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\ninline bool isvalid(vector<int> &cur, int R, int C){\\n\\tif(cur[0] >= 0 && cur[1] >= 0 && cur[0] < R && cur[1] < C)\\n\\t\\treturn true;\\n\\treturn false;\\n}\\n```\n```\\nvector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> ans;\\n        vector<int> cur = {r0, c0};\\n        ans.push_back(cur);\\n        vector<vector<int>> dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int totsteps = 2*max(R, C); totsteps*=totsteps;\\n\\t\\tint stepi = 0, d = 0;                    //tracks i th step and d th direction change\\n        int linelen = 1;\\n        while(stepi <= totsteps){\\n            for(int a = 1; a <=2; ++a){          // looping twice for same length\\n                int k = 1;                       //tracks steps taken in current line\\n                while(k <= linelen){\\n                    cur[0] += dir[d][0];\\n                    cur[1] += dir[d][1];\\n                    if(isvalid(cur, R, C)) ans.push_back(cur);\\n                    k++; stepi++;\\n                }\\n                d = (d+1)%4;\\n            }\\n            linelen++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166570,
                "title": "c-easy-explanation-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans;\\n        ans.push_back({rStart, cStart}); //Pushing the starting point in answer\\n        int topRow = rStart-1; //Row above starting point\\n        int bottomRow = rStart+1; //Row below starting point\\n        int leftCol = cStart-1; //Col left to starting point\\n        int rightCol = cStart+1; //Col right to starting point\\n        \\n        while(topRow != -1 || bottomRow != rows || leftCol != -1 || rightCol != cols){ //Untill all rows and columns are exhausted\\n            \\n            if(rightCol != cols){ //Checking if this col is exhausted\\n                for(int i = topRow+1; i < bottomRow;i++) ans.push_back({i, rightCol}); //Running loop from one bottom of top row till bottom row in right col\\n                rightCol++; //Incrementing the col forward\\n            }\\n            //Similar things are done below with different cols and rows\\n            if(bottomRow != rows){\\n                for(int j = rightCol-1; j > leftCol; j--) ans.push_back({bottomRow, j});\\n                bottomRow++;\\n            }\\n            \\n            if(leftCol != -1){\\n                for(int i = bottomRow-1; i > topRow; i--) ans.push_back({i, leftCol});\\n                leftCol--;\\n            }\\n            \\n            if(topRow != -1){\\n                for(int j = leftCol+1; j < rightCol; j++) ans.push_back({topRow, j});\\n                topRow--;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you think this post was ***helpful***, I will be happy if you give a ***upvote***. Any questions or discussions are welcome! **Thanks a lot.** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans;\\n        ans.push_back({rStart, cStart}); //Pushing the starting point in answer\\n        int topRow = rStart-1; //Row above starting point\\n        int bottomRow = rStart+1; //Row below starting point\\n        int leftCol = cStart-1; //Col left to starting point\\n        int rightCol = cStart+1; //Col right to starting point\\n        \\n        while(topRow != -1 || bottomRow != rows || leftCol != -1 || rightCol != cols){ //Untill all rows and columns are exhausted\\n            \\n            if(rightCol != cols){ //Checking if this col is exhausted\\n                for(int i = topRow+1; i < bottomRow;i++) ans.push_back({i, rightCol}); //Running loop from one bottom of top row till bottom row in right col\\n                rightCol++; //Incrementing the col forward\\n            }\\n            //Similar things are done below with different cols and rows\\n            if(bottomRow != rows){\\n                for(int j = rightCol-1; j > leftCol; j--) ans.push_back({bottomRow, j});\\n                bottomRow++;\\n            }\\n            \\n            if(leftCol != -1){\\n                for(int i = bottomRow-1; i > topRow; i--) ans.push_back({i, leftCol});\\n                leftCol--;\\n            }\\n            \\n            if(topRow != -1){\\n                for(int j = leftCol+1; j < rightCol; j++) ans.push_back({topRow, j});\\n                topRow--;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351356,
                "title": "python-easy-simulation-iterative-approach-notes",
                "content": "```\\n/*\\ninitialize val to 1\\ninitialize answer set with starting index\\nAlgo\\nGo in infinite loop\\n   Go right val times, if the index is valid, add all those indexes to answer set\\n   Go Down val times, if the index is valid, add all those indexes to answer set\\n   Go Left val+1 times, if the index is valid, add all those indexes to answer set\\n   Go Up val + 1 times, if the index is valid, add all those indexes to answer set\\n   if the answer set has rows*cols entries, break out of loop and return the answer set\\n*/\\n```\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = [[rStart, cStart]]\\n        val = 1\\n        i, j = rStart, cStart\\n        def is_valid(i, j):\\n            if 0 <= i < rows and 0 <= j < cols:\\n                return True\\n            return False\\n        \\n        while True:\\n            if len(ans) == rows * cols:\\n                return ans\\n            \\n            # go right val times\\n            for _ in range(val):\\n                j+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go bottom val times\\n            for _ in range(val):\\n                i+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go left val+1 times\\n            for _ in range(val+1):\\n                j-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go up val+1 times\\n            for _ in range(val+1):\\n                i-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            val+=2\\n```",
                "solutionTags": [
                    "Python",
                    "Simulation"
                ],
                "code": "```\\n/*\\ninitialize val to 1\\ninitialize answer set with starting index\\nAlgo\\nGo in infinite loop\\n   Go right val times, if the index is valid, add all those indexes to answer set\\n   Go Down val times, if the index is valid, add all those indexes to answer set\\n   Go Left val+1 times, if the index is valid, add all those indexes to answer set\\n   Go Up val + 1 times, if the index is valid, add all those indexes to answer set\\n   if the answer set has rows*cols entries, break out of loop and return the answer set\\n*/\\n```\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = [[rStart, cStart]]\\n        val = 1\\n        i, j = rStart, cStart\\n        def is_valid(i, j):\\n            if 0 <= i < rows and 0 <= j < cols:\\n                return True\\n            return False\\n        \\n        while True:\\n            if len(ans) == rows * cols:\\n                return ans\\n            \\n            # go right val times\\n            for _ in range(val):\\n                j+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go bottom val times\\n            for _ in range(val):\\n                i+=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go left val+1 times\\n            for _ in range(val+1):\\n                j-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            # go up val+1 times\\n            for _ in range(val+1):\\n                i-=1\\n                if is_valid(i,j):\\n                    ans.append([i,j])\\n            val+=2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633745,
                "title": "easy-c-solution",
                "content": "In the below algorithm, I have used direction parameters :\\n(0,1) for east\\n(1,0) for south\\n(0,-1) for west\\n(-1,0) for north\\n\\nEven there is a chance of getting out of the boundary, this algorithm works fine only because of this statement:\\n```\\nif(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n```\\n\\n\\nComplete Code:-\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> result = {{rStart,cStart}};\\n        \\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        int len = 0, d = 0;\\n        \\n        while(result.size()<rows*cols){\\n            \\n            if(d==0 || d==2) len++;\\n            \\n            for(int i=0;i<len;i++){\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n            }\\n            d = (d+1)%4;\\n        }\\n        return result;\\n    }\\n};\\n```\\nKindly upvote if you get any help here.\\nHappy coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nif(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> result = {{rStart,cStart}};\\n        \\n        vector<vector<int>> dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        int len = 0, d = 0;\\n        \\n        while(result.size()<rows*cols){\\n            \\n            if(d==0 || d==2) len++;\\n            \\n            for(int i=0;i<len;i++){\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols){\\n                    result.push_back({rStart,cStart});\\n                }\\n            }\\n            d = (d+1)%4;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440599,
                "title": "java-solution-using-simple-walking-simulation-97",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        final int totalCellsToVisit = R * C;\\n        final int[][] cells = new int[totalCellsToVisit][2];\\n        int cellsVisited = 0;\\n        int stepLength = 1;\\n        int stepsTaken = 0;\\n        int direction = 0;\\n        int row = r0, column = c0;\\n        \\n        while (cellsVisited < totalCellsToVisit) {\\n            // If we are inside the matrix, record the position\\n            if (row >= 0 && row < R && column >= 0 && column < C) {\\n                cells[cellsVisited][0] = row;\\n                cells[cellsVisited][1] = column;\\n                cellsVisited++;\\n            }\\n            \\n            // Move a step to correct direction (0=E, 1=S, 2=W, 3=N)\\n            if (direction == 0) { column++; }\\n            else if (direction == 1) { row++; }\\n            else if (direction == 2) { column--; }\\n            else if (direction == 3) { row--; }\\n            stepsTaken++;\\n            \\n            // If we are taken the correct amount of steps to the current direction,\\n            // change direction\\n            if (stepsTaken == stepLength) {\\n                stepsTaken = 0;\\n                direction++;\\n                // When going east or west increase the steps we take for each direction\\n                if (direction == 2) {\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                } else if (direction == 4) {\\n                    direction = 0;\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                }\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        final int totalCellsToVisit = R * C;\\n        final int[][] cells = new int[totalCellsToVisit][2];\\n        int cellsVisited = 0;\\n        int stepLength = 1;\\n        int stepsTaken = 0;\\n        int direction = 0;\\n        int row = r0, column = c0;\\n        \\n        while (cellsVisited < totalCellsToVisit) {\\n            // If we are inside the matrix, record the position\\n            if (row >= 0 && row < R && column >= 0 && column < C) {\\n                cells[cellsVisited][0] = row;\\n                cells[cellsVisited][1] = column;\\n                cellsVisited++;\\n            }\\n            \\n            // Move a step to correct direction (0=E, 1=S, 2=W, 3=N)\\n            if (direction == 0) { column++; }\\n            else if (direction == 1) { row++; }\\n            else if (direction == 2) { column--; }\\n            else if (direction == 3) { row--; }\\n            stepsTaken++;\\n            \\n            // If we are taken the correct amount of steps to the current direction,\\n            // change direction\\n            if (stepsTaken == stepLength) {\\n                stepsTaken = 0;\\n                direction++;\\n                // When going east or west increase the steps we take for each direction\\n                if (direction == 2) {\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                } else if (direction == 4) {\\n                    direction = 0;\\n                    stepLength++;\\n                    stepsTaken = 0;\\n                }\\n            }\\n        }\\n        return cells;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945963,
                "title": "c-easy-solution-0ms-intuitive-approach",
                "content": "class Solution {\\npublic:\\n    \\n    bool Valid(int i,int j,int n,int m){\\n        if(i<0 || j<0 || j>=m || i>=n) return false;\\n        return true;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int x, int y) {\\n        vector<vector<int>> ans ;\\n        ans.push_back({x,y});   //initial point\\n        int len=1;\\n        while(ans.size()<n*m){              //Base Case --> once we get whole grid --> break\\n            for(int j=1;j<=len;j++){        //going right \\n                if(Valid(x,y+j,n,m)){       //Checking if this pos exists in Grid\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y+=len;                         //Updating the value of y coordinate \\n            for(int i=1;i<=len;i++){        //Going Down\\n                if(Valid(x+i,y,n,m)) ans.push_back({x+i,y});        //Checking if exists in Grid\\n            }\\n            x+=len;                         //Updating X coordinate \\n            len++;          //Increasing length of step in each direction \\n            for(int j=1;j<=len;j++){        //Going Left \\n                if(Valid(x,y-j,n,m)) ans.push_back({x,y-j});\\n            }\\n            y-=len;\\n            for(int i=1;i<=len;i++){        //Going Up\\n                if(Valid(x-i,y,n,m)) ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    bool Valid(int i,int j,int n,int m){\\n        if(i<0 || j<0 || j>=m || i>=n) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1426785,
                "title": "python-3-simulation-explanation",
                "content": "### Explanation\\n- Starting with a step length of `1`, move one time to right, then turn; move one time to below\\n- Increase step length, `1 + 1 = 2`, move 2 times to left, then turn; move 2 times to above\\n- So, for each step length, we will move `step` for 2 directions, then increase `step` by one; and repeat\\n- To summarize:\\n\\t- `Step == 1, move*step, turn, move*step, turn`\\n\\t- `Step += 1, move*step, turn, move*step, turn`\\n\\t- `Step += 1, move*step, turn, move*step, turn`\\n\\t- `... ... repeat`\\n### Implementation\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total, cnt, step, i = rows * cols, 1, 1, 0\\n        ans = [[rStart, cStart]]\\n        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements\\n        while cnt < total:\\n            for k in range(step):\\n                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]\\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ans.append([rStart, cStart])\\n                    cnt += 1       # count visited \\n            i = (i + 1) % 4        # changing direction\\n            step += not i % 2      # increase step every 2 directions\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total, cnt, step, i = rows * cols, 1, 1, 0\\n        ans = [[rStart, cStart]]\\n        direction = {0: (0, 1), 1: (1, 0), 2: (0, -1), 3: (-1, 0)} # setup direction movements\\n        while cnt < total:\\n            for k in range(step):\\n                rStart, cStart = rStart+direction[i][0], cStart + direction[i][1]\\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ans.append([rStart, cStart])\\n                    cnt += 1       # count visited \\n            i = (i + 1) % 4        # changing direction\\n            step += not i % 2      # increase step every 2 directions\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897620,
                "title": "javascript-one-pass-solution",
                "content": "The idea in each spiral both row and col movements will have the same offset. but may have different limits (or boundaries). \\nSo compute `cLimit` for column and  `rLimit`  for row and update the offset to the next spiral length whenever both `i`  add `j` are equal to their respective limits\\n\\n```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let offset = 1, cLimit = c0+offset, rLimit = r0+offset\\n    let i = r0, j = c0\\n    let res = []\\n    \\n    while(res.length < R*C){\\n\\t\\t//if i and j are within the boundaries of the matix and to res\\n        if(i>=0 && j>=0 && i<R && j<C){  \\n            res.push([i,j])\\n        }\\n        // if i and j are both equal to their respective limits upate offset to next spiral length and direction\\n        if(i == rLimit && cLimit == j){ \\n            offset = offset<0 ? offset-1 : offset+1\\n            offset *= -1\\n            cLimit = cLimit + offset\\n            rLimit = rLimit + offset\\n        }\\n        // each of the four possible movements through the matrix\\n        if(j<cLimit) j++\\n        else if(i<rLimit) i++\\n        else if(j>cLimit) j--\\n        else if(i>rLimit) i--\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let offset = 1, cLimit = c0+offset, rLimit = r0+offset\\n    let i = r0, j = c0\\n    let res = []\\n    \\n    while(res.length < R*C){\\n\\t\\t//if i and j are within the boundaries of the matix and to res\\n        if(i>=0 && j>=0 && i<R && j<C){  \\n            res.push([i,j])\\n        }\\n        // if i and j are both equal to their respective limits upate offset to next spiral length and direction\\n        if(i == rLimit && cLimit == j){ \\n            offset = offset<0 ? offset-1 : offset+1\\n            offset *= -1\\n            cLimit = cLimit + offset\\n            rLimit = rLimit + offset\\n        }\\n        // each of the four possible movements through the matrix\\n        if(j<cLimit) j++\\n        else if(i<rLimit) i++\\n        else if(j>cLimit) j--\\n        else if(i>rLimit) i--\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 347424,
                "title": "java-solution-just-like-clean-robot",
                "content": "Just like robot clean problem, use```curDirection```to record the curDirection and ```(curDirection + 1) % 4```to find the next direction.\\nWhen the direction is equals 0 or 2, ```len++```\\u3002\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[] dx = new int[]{0, 1, 0, -1};\\n        int[] dy = new int[]{1, 0, -1, 0};\\n        List<int[]> list = new ArrayList<>();\\n        int curDirection = 0;\\n        list.add(new int[]{r0, c0});\\n        int len = 0;\\n        while (list.size() < R * C) {\\n            if (curDirection == 0 || curDirection == 2) len++;\\n            for (int i = 0; i < len; i++) {\\n                r0 += dx[curDirection];\\n                c0 += dy[curDirection];\\n                if (r0 < 0 || r0 >= R || c0 < 0 || c0 >= C) continue;\\n                list.add(new int[]{r0, c0});\\n            }\\n            curDirection = (curDirection + 1) % 4;\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```curDirection```\n```(curDirection + 1) % 4```\n```len++```\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[] dx = new int[]{0, 1, 0, -1};\\n        int[] dy = new int[]{1, 0, -1, 0};\\n        List<int[]> list = new ArrayList<>();\\n        int curDirection = 0;\\n        list.add(new int[]{r0, c0});\\n        int len = 0;\\n        while (list.size() < R * C) {\\n            if (curDirection == 0 || curDirection == 2) len++;\\n            for (int i = 0; i < len; i++) {\\n                r0 += dx[curDirection];\\n                c0 += dy[curDirection];\\n                if (r0 < 0 || r0 >= R || c0 < 0 || c0 >= C) continue;\\n                list.add(new int[]{r0, c0});\\n            }\\n            curDirection = (curDirection + 1) % 4;\\n        }\\n        int[][] res = new int[list.size()][2];\\n        for (int i = 0; i < res.length; i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292721,
                "title": "c-f-cing-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans(rows* cols, vector<int>(2));\\n        int i=0;\\n        ans[i++]={rStart,cStart};\\n        int len=0;\\n        int d=0;\\n        int direction[]={0,1,0,-1,0};\\n        while(i<rows*cols){\\n            if(d==0 ||d==2){\\n                len++;\\n            }\\n            for(int k=0;k<len;k++){\\n                rStart+=direction[d];\\n                cStart+=direction[d+1];\\n               if(rStart<rows && rStart>=0&& cStart<cols && cStart>=0 ){\\n                    ans[i++]={rStart,cStart};\\n            \\n                } \\n            }\\n         d=++d%4;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        vector<vector<int>> ans(rows* cols, vector<int>(2));\\n        int i=0;\\n        ans[i++]={rStart,cStart};\\n        int len=0;\\n        int d=0;\\n        int direction[]={0,1,0,-1,0};\\n        while(i<rows*cols){\\n            if(d==0 ||d==2){\\n                len++;\\n            }\\n            for(int k=0;k<len;k++){\\n                rStart+=direction[d];\\n                cStart+=direction[d+1];\\n               if(rStart<rows && rStart>=0&& cStart<cols && cStart>=0 ){\\n                    ans[i++]={rStart,cStart};\\n            \\n                } \\n            }\\n         d=++d%4;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837586,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        List<int[]> result = new();\\n       int[,] directions = new int[,]{{0,1} ,{1,0},{0,-1},{-1,0}};\\n        int len =0;\\n        int d =0;\\n        result.Add(new int[]{rStart, cStart});\\n\\n        while(result.Count < rows * cols)\\n        {\\n            //directions right---> or left <---, increase len++\\n            if(d==0 || d==2)\\n            {\\n                len++;\\n            }\\n            for(int k=0; k<len; k++)\\n            {\\n                rStart += directions[d,0];\\n                cStart += directions[d,1];\\n                if(rStart < rows && rStart >=0 && cStart < cols && cStart >=0)\\n                {\\n                    result.Add(new int[]{rStart, cStart});\\n                }\\n            }\\n            d= (d+1) % 4;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        List<int[]> result = new();\\n       int[,] directions = new int[,]{{0,1} ,{1,0},{0,-1},{-1,0}};\\n        int len =0;\\n        int d =0;\\n        result.Add(new int[]{rStart, cStart});\\n\\n        while(result.Count < rows * cols)\\n        {\\n            //directions right---> or left <---, increase len++\\n            if(d==0 || d==2)\\n            {\\n                len++;\\n            }\\n            for(int k=0; k<len; k++)\\n            {\\n                rStart += directions[d,0];\\n                cStart += directions[d,1];\\n                if(rStart < rows && rStart >=0 && cStart < cols && cStart >=0)\\n                {\\n                    result.Add(new int[]{rStart, cStart});\\n                }\\n            }\\n            d= (d+1) % 4;\\n        }\\n        return result.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718364,
                "title": "easy-python-solution-based-on-spiral-matrix-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter every iteration of a row or column we need to widen our range.\\nIf the first row we\\'re reading is length of two when we read if in reverse direction we need to add one more element to it.\\nEg. Lets read a row in to the left direction then when we eventually try to read in the reverse that is to the right direction. We include one more element. 1->2 then 5<-4<-3\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = []\\n        left, right = cStart, cStart+1\\n        top, bottom = rStart, rStart+1\\n        current = 1\\n        move = 0\\n        while current <= rows*cols:\\n            # fill top\\n            for i in range(left+move, right+1):\\n                if self.inbound(top, i, rows, cols):\\n                    ans.append([top, i])\\n                    current += 1\\n            left -= 1\\n            # fill right\\n            for i in range(top+1, bottom+1):\\n                if self.inbound(i, right, rows, cols):\\n                    ans.append([i, right])\\n                    current += 1\\n            top -= 1\\n            # fill bottom\\n            for i in range(right-1, left-1, -1):\\n                if self.inbound(bottom, i, rows, cols):\\n                    ans.append([bottom, i])\\n                    current += 1\\n            right += 1\\n            # fill left\\n            for i in range(bottom-1, top-1, -1):\\n                if self.inbound(i, left, rows, cols):\\n                    ans.append([i, left])\\n                    current += 1\\n            bottom += 1\\n            move = 1\\n        return ans\\n    def inbound(self, r, c, rows, cols):\\n        return 0<=r<rows and 0<=c<cols\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ans = []\\n        left, right = cStart, cStart+1\\n        top, bottom = rStart, rStart+1\\n        current = 1\\n        move = 0\\n        while current <= rows*cols:\\n            # fill top\\n            for i in range(left+move, right+1):\\n                if self.inbound(top, i, rows, cols):\\n                    ans.append([top, i])\\n                    current += 1\\n            left -= 1\\n            # fill right\\n            for i in range(top+1, bottom+1):\\n                if self.inbound(i, right, rows, cols):\\n                    ans.append([i, right])\\n                    current += 1\\n            top -= 1\\n            # fill bottom\\n            for i in range(right-1, left-1, -1):\\n                if self.inbound(bottom, i, rows, cols):\\n                    ans.append([bottom, i])\\n                    current += 1\\n            right += 1\\n            # fill left\\n            for i in range(bottom-1, top-1, -1):\\n                if self.inbound(i, left, rows, cols):\\n                    ans.append([i, left])\\n                    current += 1\\n            bottom += 1\\n            move = 1\\n        return ans\\n    def inbound(self, r, c, rows, cols):\\n        return 0<=r<rows and 0<=c<cols\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188144,
                "title": "java-spiral-matrix-iii",
                "content": "In this question first we need to observe ans understand that how the direction will change or I should say what is the condition when the iterator itr (which is traversing array(matrix)) will change its direction of iteration.\\n\\nBy observation we figured it out that iterator itr is traversing the array in a pattern or elements of array are arranged in a definite pattern \\n   itr moves 1 step in right\\n   itr then moves 1step down \\n   itr then moves 2 steps in left\\n   itr then moves 2 steps top\\n   itr then moves 3 steps in right\\n   itr then moves 3 steps down\\n   itr then moves 4 steps in left\\n   itr then moves 4 steps top\\n   itr then moves 5 step in right\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   .\\n   ans so on till the last element is reached\\n   \\n  ![image](https://assets.leetcode.com/users/images/cf928875-778b-49d7-9fc0-c5e08c1e17de_1656001345.1119683.png)\\n\\n\\n   \\n   here we can observe that itreator itr traverse the array in a pattern   1,1,2,2,3,3,4,4,5,5,6,6,.............\\n   \\n   so now we know the pattern, we have to derive the formula to get that pattern to traverse the array\\n   let  A(0)==1, A(1)==1, A(2)==2, A(3)==2, A(4)==3, A(5)==3, A(6)==4, . . . . . . . . . . . . . . and so on\\n   \\n   so, by this we can conclude\\n        A(n)= n/2 + 1;\\n\\t\\there n belong to (0, length of row of ans)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n   Now, we have one more challenge to change the direction of array in this we have four cases\\n  Case 1:-  When iterate from left to right\\n\\t\\t\\t\\t  here we need to increment the column index only \\n\\n  Case 2:- When iterate from top to bottom\\n\\t\\t\\t\\there we need to increment the row index only\\n\\n  Case 3:- When iterate from right to left\\n\\t\\t\\t\\there we need to decrement the column index only\\n\\n  Case 4:- When iterate from bottom to top \\n\\t\\t\\t\\there we need to decrement the row index only\\n\\t\\t\\t\\t\\t\\nTo handle or perform the above for cases we can do this by using simple technique\\ntake   int dx=0, dy=1, temp=0;\\nand    rStart==x, cStart=y\\n\\nnow just perfor this simple following code when the inner loop has done traversing in one direction or  you can say after  the completion of inner loop \\n\\ntemp=dx;\\ndx=dy;\\ndy= -tmp;\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int x, int y) {\\n        \\n        int[][] ans=new int[rows*cols][2];\\n        int n=0;\\n        int dx=0;\\n        int dy=1;\\n        int temp=0;\\n        \\n        for(int j=0;j<rows*cols;++n){\\n            for(int i=0;i< n/2 + 1;++i){\\n                \\n                if(x>=0 && x<rows && y>=0 && y<cols){\\n                    // here we are assigning the new 1D array to row of 2D array (ans) \\n                    // it will remind you some basic concept of aray that every thing in java is an object\\n                    ans[j++]=new int[]{x,y};\\n                }\\n                \\n                x=x+dx;\\n                y=y+dy;\\n            }\\n            // by this code we will change the direction of array(ans) traversing\\n            // left to right\\n            // top to bottom\\n            // right to left\\n            // bottom to up\\n            temp=dx;\\n            dx=dy;\\n            dy= -temp;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```\\n\\t\\t\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n\\t\\t\\n\\t\\tclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int x, int y) {\\n        \\n        int[][] ans=new int[rows*cols][2];\\n        int n=0;\\n        int dx=0;\\n        int dy=1;\\n        int temp=0;\\n        \\n        for(int j=0;j<rows*cols;++n){\\n            for(int i=0;i< n/2 + 1;++i){\\n                \\n                if(x>=0 && x<rows && y>=0 && y<cols){\\n                    // here we are assigning the new 1D array to row of 2D array (ans) \\n                    // it will remind you some basic concept of aray that every thing in java is an object\\n                    ans[j++]=new int[]{x,y};\\n                }\\n                \\n                x=x+dx;\\n                y=y+dy;\\n            }\\n            // by this code we will change the direction of array(ans) traversing\\n            // left to right\\n            // top to bottom\\n            // right to left\\n            // bottom to up\\n            temp=dx;\\n            dx=dy;\\n            dy= -temp;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941300,
                "title": "c-easy-understanding",
                "content": "intution :\\nin each iteration you are traversing a square \\n     ->  downwards -> leftwards ->upwards ->righwards\\nwhile traversing check if the cell is within the grid\\nif with in the grid assign the value of count and increment count value\\nafter each iteration update the value of l,r,t,b\\n\\nl = index of left most column\\nr = index of right most column\\nt = index of top  row\\nb = index of bottom row\\n```\\nclass Solution {\\npublic:\\n    int m1,n1;\\n    void solve(vector<vector<int>>&res,int r,int c,int &ct){\\n        if(r>=0 && r<m1 && c>=0 && c<n1){\\n            {res.push_back({r,c});ct++;}\\n        }\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rs, int cs) {\\n        \\n        vector<vector<int>>res;\\n        res.push_back({rs,cs});\\n        int l=cs-1,r=cs+1,t=rs-1,b=rs+1,ct=2;\\n        m1=m;n1=n;\\n        while(ct<=m*n){\\n            for(int i=t+1;i<b;i++) solve(res,i,r,ct);\\n            for(int i=r;i>=l;i--)  solve(res,b,i,ct);\\n            for(int i=b-1;i>t;i--) solve(res,i,l,ct);\\n            for(int i=l;i<=r;i++)  solve(res,t,i,ct);\\n            r++;l--;t--;b++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nplease upvote if you like .\\nHappy coding :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m1,n1;\\n    void solve(vector<vector<int>>&res,int r,int c,int &ct){\\n        if(r>=0 && r<m1 && c>=0 && c<n1){\\n            {res.push_back({r,c});ct++;}\\n        }\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rs, int cs) {\\n        \\n        vector<vector<int>>res;\\n        res.push_back({rs,cs});\\n        int l=cs-1,r=cs+1,t=rs-1,b=rs+1,ct=2;\\n        m1=m;n1=n;\\n        while(ct<=m*n){\\n            for(int i=t+1;i<b;i++) solve(res,i,r,ct);\\n            for(int i=r;i>=l;i--)  solve(res,b,i,ct);\\n            for(int i=b-1;i>t;i--) solve(res,i,l,ct);\\n            for(int i=l;i<=r;i++)  solve(res,t,i,ct);\\n            r++;l--;t--;b++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637681,
                "title": "python3-simple",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        res=[]\\n        rowMin=rStart\\n        rowMax=rStart+1\\n        colMin=cStart\\n        colMax=cStart+1\\n        while len(res)!=rows*cols:\\n            \\n            for col in range(colMin,colMax):\\n                if 0<=col<cols and 0<=rowMin<rows: res.append([rowMin,col])\\n            \\n            for row in range(rowMin,rowMax):\\n                if 0<=colMax<cols and 0<=row<rows: res.append([row,colMax])\\n            \\n            colMin-=1\\n            \\n            for col in range(colMax,colMin,-1):\\n                if 0<=col<cols and 0<=rowMax<rows: res.append([rowMax,col])\\n            \\n            rowMin-=1\\n            \\n            for row in range(rowMax,rowMin,-1):\\n                if 0<=colMin<cols and 0<=row<rows: res.append([row,colMin])\\n            \\n            colMax+=1\\n            rowMax+=1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        res=[]\\n        rowMin=rStart\\n        rowMax=rStart+1\\n        colMin=cStart\\n        colMax=cStart+1\\n        while len(res)!=rows*cols:\\n            \\n            for col in range(colMin,colMax):\\n                if 0<=col<cols and 0<=rowMin<rows: res.append([rowMin,col])\\n            \\n            for row in range(rowMin,rowMax):\\n                if 0<=colMax<cols and 0<=row<rows: res.append([row,colMax])\\n            \\n            colMin-=1\\n            \\n            for col in range(colMax,colMin,-1):\\n                if 0<=col<cols and 0<=rowMax<rows: res.append([rowMax,col])\\n            \\n            rowMin-=1\\n            \\n            for row in range(rowMax,rowMin,-1):\\n                if 0<=colMin<cols and 0<=row<rows: res.append([row,colMin])\\n            \\n            colMax+=1\\n            rowMax+=1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607741,
                "title": "cpp-solution-faster-than-99-12",
                "content": "On observing we need to take take steps in each direction two times, like we start from left, then we take one step to left than we go down(directed to) and take one step there, after that we need to take 2 steps the same way to right and to up, the  solution is the sollowing the same rule> I know its a bit lengthy but ***TIME MATTERS*** most IMO.(99.12%)\\n```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n\\t\\t//base case\\n        if(rows==1 && cols==1){\\n            temp.push_back(0);\\n            temp.push_back(0);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        int steps=1;\\n        int n=2;\\n        int size=0;\\n        int x=rStart,y=cStart;\\n\\t\\t\\n\\t\\t//variable for tracking the direction\\n        char dir=\\'r\\';\\n\\t\\t\\n\\t\\t//for first step\\n        temp.push_back(x);\\n        temp.push_back(y);\\n        ans.push_back(temp);\\n        size++;\\n        temp.clear();\\n        while(size<=cols*rows){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<steps;j++){\\n                    if(dir==\\'r\\')y++;\\n                    else if(dir==\\'b\\')x++;\\n                    else if(dir==\\'l\\')y--;\\n                    else if(dir==\\'u\\')x--;\\n                    if(x>=0 && x<rows && y>=0 && y<cols){\\n                        temp.push_back(x);\\n                        temp.push_back(y);\\n                        ans.push_back(temp);\\n                        temp.clear();\\n                        size++;\\n                        if(size==cols*rows)return ans;\\n                    }\\n                }\\n                if(dir==\\'r\\')dir=\\'b\\';\\n                else if(dir==\\'b\\')dir=\\'l\\';\\n                else if(dir==\\'l\\')dir=\\'u\\';\\n                else if(dir==\\'u\\')dir=\\'r\\';\\n            }\\n\\t\\t\\t//after two iterations in 2 directions we need to change the number of steps\\n            steps++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        vector<int>temp;\\n\\t\\t//base case\\n        if(rows==1 && cols==1){\\n            temp.push_back(0);\\n            temp.push_back(0);\\n            ans.push_back(temp);\\n            return ans;\\n        }\\n        int steps=1;\\n        int n=2;\\n        int size=0;\\n        int x=rStart,y=cStart;\\n\\t\\t\\n\\t\\t//variable for tracking the direction\\n        char dir=\\'r\\';\\n\\t\\t\\n\\t\\t//for first step\\n        temp.push_back(x);\\n        temp.push_back(y);\\n        ans.push_back(temp);\\n        size++;\\n        temp.clear();\\n        while(size<=cols*rows){\\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<steps;j++){\\n                    if(dir==\\'r\\')y++;\\n                    else if(dir==\\'b\\')x++;\\n                    else if(dir==\\'l\\')y--;\\n                    else if(dir==\\'u\\')x--;\\n                    if(x>=0 && x<rows && y>=0 && y<cols){\\n                        temp.push_back(x);\\n                        temp.push_back(y);\\n                        ans.push_back(temp);\\n                        temp.clear();\\n                        size++;\\n                        if(size==cols*rows)return ans;\\n                    }\\n                }\\n                if(dir==\\'r\\')dir=\\'b\\';\\n                else if(dir==\\'b\\')dir=\\'l\\';\\n                else if(dir==\\'l\\')dir=\\'u\\';\\n                else if(dir==\\'u\\')dir=\\'r\\';\\n            }\\n\\t\\t\\t//after two iterations in 2 directions we need to change the number of steps\\n            steps++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 600122,
                "title": "java-straightforward-solution",
                "content": "```\\n\\tpublic int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] ret = new int[R*C][2];\\n        int step = 1;\\n        int i = 0;\\n        int r = r0;\\n        int c = c0;\\n        int offset = 1;\\n        while (i < R*C) {\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                c += offset;\\n            }\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                r += offset;\\n            }\\n            step++;\\n            offset = -offset;\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] ret = new int[R*C][2];\\n        int step = 1;\\n        int i = 0;\\n        int r = r0;\\n        int c = c0;\\n        int offset = 1;\\n        while (i < R*C) {\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                c += offset;\\n            }\\n            for (int j = 0; j < step; j++) {\\n                if (r >= 0 && c >= 0 && r < R && c < C && i < R*C) {\\n                    ret[i][0] = r;\\n                    ret[i][1] = c;\\n                    i++;\\n                }\\n                r += offset;\\n            }\\n            step++;\\n            offset = -offset;\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159178,
                "title": "javascript-solution-straightforward-with-graph",
                "content": "The key point is to traverse the elements in correct order.\\n### Steps:\\n* Find out how many times we should do the traversal (four lines one time, as shown in the graph);\\n* Each time, we traverse four lines, and we push every element we meet, no matter whether they belong to the matrix or not;\\n* We filter the result we got, and leave only elements that belong to the matrix.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/lmiaoj/image_1534089926.png)\\n\\n```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let n = Math.max(r0, c0, R-1-r0, C-1-c0);\\n    let res = [[r0,c0]];\\n    for(let i=1; i<=n; i++){\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0+j,c0+i]); //line 1\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+i,c0+j]); //line 2\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+j,c0-i]); //line 3\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0-i,c0+j]); //line 4\\n    }\\n    return res.filter(x=>x[0]>=0&&x[0]<R&&x[1]>=0&&x[1]<C);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    let n = Math.max(r0, c0, R-1-r0, C-1-c0);\\n    let res = [[r0,c0]];\\n    for(let i=1; i<=n; i++){\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0+j,c0+i]); //line 1\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+i,c0+j]); //line 2\\n    \\tfor(let j=i-1; j>=-i; j--) res.push([r0+j,c0-i]); //line 3\\n    \\tfor(let j=1-i; j<=i; j++) res.push([r0-i,c0+j]); //line 4\\n    }\\n    return res.filter(x=>x[0]>=0&&x[0]<R&&x[1]>=0&&x[1]<C);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3709692,
                "title": "c-simple-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraversing spirally and checking whether that element belong to matrix or not\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing the matrix spirally and for each element we are checking  whether it lies in matrix or not and if len of answer becomes equal to rows*cols, we return.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(rows*rows*cols*cols)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j, int row, int col)\\n    {\\n        return (i>=0 && j>=0 && i<row && j<col);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n\\n        int step = 1;\\n        int i = rStart,j = cStart;\\n\\n        while(ans.size() < rows*cols)\\n        {\\n            if(ans.size()==rows*cols)\\n            return ans;\\n\\n            int k=0;\\n            while(k<step)\\n            {\\n                j++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                j--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int i,int j, int row, int col)\\n    {\\n        return (i>=0 && j>=0 && i<row && j<col);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n\\n        int step = 1;\\n        int i = rStart,j = cStart;\\n\\n        while(ans.size() < rows*cols)\\n        {\\n            if(ans.size()==rows*cols)\\n            return ans;\\n\\n            int k=0;\\n            while(k<step)\\n            {\\n                j++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i++;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                j--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            k=0;\\n            while(k<step)\\n            {\\n                i--;\\n                if(isvalid(i,j,rows,cols))\\n                {\\n                    ans.push_back({i,j});\\n                    if(ans.size()==rows*cols)\\n                    return ans;\\n                }\\n                k++;\\n            }\\n\\n            step++;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508037,
                "title": "easy-to-understand-approach-commented",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int nrow,int ncol,int n,int m){\\n        return nrow>=0 && nrow<n && ncol>=0 && ncol<m ;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>>spiral;\\n        spiral.push_back({rStart,cStart});\\n        //till now, 1 coordinate used \\n        int used=1,move=1; \\n        while(used<rows*cols){\\n \\n            //for right movement first [1,2,3...]\\n            int canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n\\n            //for down movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF RIGHT-DOWN MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n            \\n\\n            //for left movement \\n              canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            \\n            //for up movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF LEFT-UP MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n        }\\n        return spiral;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int nrow,int ncol,int n,int m){\\n        return nrow>=0 && nrow<n && ncol>=0 && ncol<m ;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>>spiral;\\n        spiral.push_back({rStart,cStart});\\n        //till now, 1 coordinate used \\n        int used=1,move=1; \\n        while(used<rows*cols){\\n \\n            //for right movement first [1,2,3...]\\n            int canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n\\n            //for down movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart++;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF RIGHT-DOWN MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n            \\n\\n            //for left movement \\n              canMove=move;\\n            while(canMove--){\\n                //row remains same column changes\\n                cStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            \\n            //for up movement \\n              canMove=move;\\n            while(canMove--){\\n                //column remains same row changes\\n                rStart--;\\n                //if new position valid take it in spiral order \\n                if(isValid(rStart,cStart,rows,cols)){\\n                     spiral.push_back({rStart,cStart});\\n                     used++; //another coordinate used \\n                }\\n            }\\n            //AFTER ONE SET OF LEFT-UP MOVEMENT MOVE INCREASES BY 1 \\n            move++;\\n        }\\n        return spiral;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399551,
                "title": "java-beats-100-0ms-runtime-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(rows * cols)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix = new int[rows*cols][2];\\n        int k = 0;\\n        \\n        int rEnd = rStart + 1;\\n        int cEnd = cStart + 1;\\n\\n        while(true) {\\n            // right \\n            for(int i = cStart; i <= cEnd; i++) {\\n                if(i < cols && i >= 0 && rStart >= 0) {\\n                    matrix[k][0] = rStart;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n            cStart--;\\n            cEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // down \\n            for(int i = rStart + 1; i <= rEnd; i++) {\\n                if(i < rows && i >= 0 && cEnd - 1 < cols) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cEnd - 1;\\n                    k++;\\n                }\\n            }\\n            rStart--;\\n            rEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // left\\n            for(int i = cEnd - 2; i >= cStart; i--) {\\n                if(i >= 0 && i < cols && rEnd - 1 < rows) {\\n                    matrix[k][0] = rEnd - 1;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // up\\n            for(int i = rEnd - 2; i > rStart; i--) {\\n                if(i >= 0 && i < rows && cStart >= 0) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cStart;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix = new int[rows*cols][2];\\n        int k = 0;\\n        \\n        int rEnd = rStart + 1;\\n        int cEnd = cStart + 1;\\n\\n        while(true) {\\n            // right \\n            for(int i = cStart; i <= cEnd; i++) {\\n                if(i < cols && i >= 0 && rStart >= 0) {\\n                    matrix[k][0] = rStart;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n            cStart--;\\n            cEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // down \\n            for(int i = rStart + 1; i <= rEnd; i++) {\\n                if(i < rows && i >= 0 && cEnd - 1 < cols) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cEnd - 1;\\n                    k++;\\n                }\\n            }\\n            rStart--;\\n            rEnd++;\\n\\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // left\\n            for(int i = cEnd - 2; i >= cStart; i--) {\\n                if(i >= 0 && i < cols && rEnd - 1 < rows) {\\n                    matrix[k][0] = rEnd - 1;\\n                    matrix[k][1] = i;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n\\n            // up\\n            for(int i = rEnd - 2; i > rStart; i--) {\\n                if(i >= 0 && i < rows && cStart >= 0) {\\n                    matrix[k][0] = i;\\n                    matrix[k][1] = cStart;\\n                    k++;\\n                }\\n            }\\n        \\n            if(k == matrix.length) {\\n                break;\\n            }\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152133,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int idx;\\n    int[][] ret;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ret[idx][0] = r;\\n        ret[idx++][1] = c;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ret = new int[R * C][2];\\n        while (idx < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010933,
                "title": "c-commented-solution",
                "content": "# Intuition\\nThe below code works like this:\\n\\n```\\nstartPos {Row, Col}\\nloop 1:\\nCol -> + 1, Row -> + 0\\nCol -> + 0, Row -> + 1\\n++ Counter\\nloop 2:\\nCol -> - 1, Row -> + 0\\nCol -> - 1, Row -> + 0\\nCol -> + 0, Row -> - 1\\nCol -> + 0, Row -> - 1\\n++ Counter\\n...\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        vector<int> startPos {rStart, cStart};\\n        result.push_back(startPos);\\n\\n        // For each walk, firstly we move the column by \"\"counter\"\" steps,\\n        //                secondly we move the row by \"\"counter\"\" steps,\\n        // Note that the step direction will depend on the \"counter % 2 == 0\"\\n        int counter {1};\\n        while(result.size() != rows * cols) {\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[1] = startPos[1] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[0] = startPos[0] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n            \\n            ++ counter;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstartPos {Row, Col}\\nloop 1:\\nCol -> + 1, Row -> + 0\\nCol -> + 0, Row -> + 1\\n++ Counter\\nloop 2:\\nCol -> - 1, Row -> + 0\\nCol -> - 1, Row -> + 0\\nCol -> + 0, Row -> - 1\\nCol -> + 0, Row -> - 1\\n++ Counter\\n...\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        vector<int> startPos {rStart, cStart};\\n        result.push_back(startPos);\\n\\n        // For each walk, firstly we move the column by \"\"counter\"\" steps,\\n        //                secondly we move the row by \"\"counter\"\" steps,\\n        // Note that the step direction will depend on the \"counter % 2 == 0\"\\n        int counter {1};\\n        while(result.size() != rows * cols) {\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[1] = startPos[1] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n\\n            for (int i = 1; i <= counter; ++ i) {\\n                startPos[0] = startPos[0] + (counter % 2 == 0 ? -1 : 1);\\n                if (startPos[1] >= 0 && startPos[0] >= 0 && startPos[1] < cols && startPos[0] < rows)\\n                    result.push_back(startPos);\\n            }\\n            \\n            ++ counter;\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777454,
                "title": "c-solution-with-explanation-and-complexity",
                "content": "After solving a few examples by myself, I found some observations:\\n* The number of grids that we are traversing in one direction starts from 1 and after traversing two direction it increases. I have called it as **checker** in code\\n* For stoping the traversal, we have to count all rows * cols grids. So i created **counter**\\n* Before pushing the coordinates in the ans vector, we need to check if it belongs inside the matrix or not. For that \\n\\t\\t0 <= i <= rows\\n\\t\\t0 <= j <= cols\\nwhere i is the index for row and j is the index for column.\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/ea296c0e-0175-4170-816b-133d40d94c51_1667559130.6659496.jpeg)\\n\\n**Space Complexity**: O(rows * cols)\\n**Time Complexity:** O(6 + (n - 1)* 8), where n = max(rows, cols)\\n```\\nclass Solution {\\npublic:\\n\\n\\t//function to check if i and j belong to matrix or not\\n    bool valid_to_push(int i, int j, int rows, int cols){\\n        if(i>=0 && i<rows && j>=0 && j<cols)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int counter, direction, checker;\\n        ans.push_back({rStart, cStart});\\n        counter = 1; \\n        direction = 0;\\n        checker = 1;\\n        \\n        int i = rStart, j = cStart;\\n\\t\\t\\n        while(counter != rows * cols){\\n\\t\\t\\t// for direction 0\\n            if(direction == 0){\\n\\t\\t\\t\\t// only traverse till checker\\n                for(int k = 1; k<= checker; k++){\\n                    j++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 1; //change direction\\n            }\\n\\t\\t\\t// for direction 1\\n            if(direction == 1){\\n                for(int k = 1; k<= checker; k++){\\n                    i++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 2; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n\\t\\t\\t\\n\\t\\t\\t// for direction 2\\n            if(direction == 2){\\n                for(int k = 1; k<= checker; k++){\\n                    j--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 3; //change direction\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// for direction 3\\n            if(direction == 3){\\n                for(int k = 1; k<= checker; k++){\\n                    i--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 0; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\t//function to check if i and j belong to matrix or not\\n    bool valid_to_push(int i, int j, int rows, int cols){\\n        if(i>=0 && i<rows && j>=0 && j<cols)\\n            return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int counter, direction, checker;\\n        ans.push_back({rStart, cStart});\\n        counter = 1; \\n        direction = 0;\\n        checker = 1;\\n        \\n        int i = rStart, j = cStart;\\n\\t\\t\\n        while(counter != rows * cols){\\n\\t\\t\\t// for direction 0\\n            if(direction == 0){\\n\\t\\t\\t\\t// only traverse till checker\\n                for(int k = 1; k<= checker; k++){\\n                    j++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 1; //change direction\\n            }\\n\\t\\t\\t// for direction 1\\n            if(direction == 1){\\n                for(int k = 1; k<= checker; k++){\\n                    i++;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 2; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n\\t\\t\\t\\n\\t\\t\\t// for direction 2\\n            if(direction == 2){\\n                for(int k = 1; k<= checker; k++){\\n                    j--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 3; //change direction\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// for direction 3\\n            if(direction == 3){\\n                for(int k = 1; k<= checker; k++){\\n                    i--;\\n                    if(valid_to_push(i,j,rows,cols)){\\n                        ans.push_back({i, j});\\n                        counter++;\\n                    }\\n                }\\n                direction = 0; //change direction\\n            }\\n            checker++; // increase after traversing two direction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692625,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2131312,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/689bb355-4bde-4d86-bac1-13b88f5cb601_1654783840.3640954.png)\\n```\\nint** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    res[0][0] = rStart; res[0][1] = cStart;\\n    int up = 1, right = 1, cntRL = 0, cntUD = 0, idx = 1;\\n    while (idx < (*returnSize)) {\\n        for (int shift = 1; shift <= right; shift++) {\\n            cStart = (cntRL % 2 == 0) ? cStart + 1 : cStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntRL++;\\n        right++;\\n        for (int shift = 1; shift <= up; shift++) {\\n            rStart = (cntUD % 2 == 0) ? rStart + 1 : rStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntUD++;\\n        up++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** spiralMatrixIII(int rows, int cols, int rStart, int cStart, int* returnSize, int** returnColumnSizes) {\\n    (*returnSize) = rows * cols;\\n    *returnColumnSizes = (int*) malloc((*returnSize) * sizeof(int));\\n    int** res = (int**) malloc((*returnSize) * sizeof(int*));\\n    for (int i = 0; i < (*returnSize); i++) {\\n        res[i] = (int*) calloc(2, sizeof(int));\\n        (*returnColumnSizes)[i] = 2;\\n    }\\n    res[0][0] = rStart; res[0][1] = cStart;\\n    int up = 1, right = 1, cntRL = 0, cntUD = 0, idx = 1;\\n    while (idx < (*returnSize)) {\\n        for (int shift = 1; shift <= right; shift++) {\\n            cStart = (cntRL % 2 == 0) ? cStart + 1 : cStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntRL++;\\n        right++;\\n        for (int shift = 1; shift <= up; shift++) {\\n            rStart = (cntUD % 2 == 0) ? rStart + 1 : rStart - 1;\\n            if (rStart < rows && cStart < cols && rStart > -1 && cStart > -1) {\\n                res[idx][0] = rStart;\\n                res[idx][1] = cStart;\\n                idx++;\\n            }\\n        }\\n        cntUD++;\\n        up++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946605,
                "title": "easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // {0,1,0,-1,0}   directions  0-> col++, 1->row++, 2-> col-- 3->row--\\n        \\n        \\n        int directions[]={0,1,0,-1,0} ;\\n        \\n        int steps=0;\\n        int move=0;\\n        int count=0;\\n        int ans[][]=new int[rows*cols][2];\\n        ans[count][0]=rStart;\\n        ans[count][1]=cStart;\\n        count++;\\n        \\n        int row=rStart,col=cStart;\\n        \\n        while(count<rows*cols)\\n        {\\n            if(move==0 || move== 2)\\n                steps++;\\n            \\n            for(int i=0;i<steps;i++)\\n            {\\n                row+=directions[move];\\n                col+=directions[move+1];\\n               if(row<rows && row>=0 && col<cols && col>=0)\\n               {\\n                ans[count][0]=row;\\n                ans[count][1]=col;\\n                count++;\\n               }\\n                \\n            }\\n            if(move!=0)\\n            move=(move+1)%4;\\n            else \\n                move++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // {0,1,0,-1,0}   directions  0-> col++, 1->row++, 2-> col-- 3->row--\\n        \\n        \\n        int directions[]={0,1,0,-1,0} ;\\n        \\n        int steps=0;\\n        int move=0;\\n        int count=0;\\n        int ans[][]=new int[rows*cols][2];\\n        ans[count][0]=rStart;\\n        ans[count][1]=cStart;\\n        count++;\\n        \\n        int row=rStart,col=cStart;\\n        \\n        while(count<rows*cols)\\n        {\\n            if(move==0 || move== 2)\\n                steps++;\\n            \\n            for(int i=0;i<steps;i++)\\n            {\\n                row+=directions[move];\\n                col+=directions[move+1];\\n               if(row<rows && row>=0 && col<cols && col>=0)\\n               {\\n                ans[count][0]=row;\\n                ans[count][1]=col;\\n                count++;\\n               }\\n                \\n            }\\n            if(move!=0)\\n            move=(move+1)%4;\\n            else \\n                move++;\\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943274,
                "title": "c-solution-intutive",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int result=rows*cols;\\n        int limit=1;\\n        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        int d=0;\\n        vector<vector<int>>ans={{rStart,cStart}};\\n        int no=1;\\n        while(ans.size()!=result)\\n        {\\n            for(int i=0;i<limit;i++)\\n            {\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    ans.push_back({rStart,cStart});\\n                }\\n            }\\n                \\n                \\n                d=(d+1)%4;\\n            if(no==2)\\n            {\\n                limit++;no=1;\\n            }\\n            else no++;\\n                \\n                \\n                \\n        }\\n        return ans;\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int result=rows*cols;\\n        int limit=1;\\n        int dir[4][2]={{0,1},{1,0},{0,-1},{-1,0}};\\n        int d=0;\\n        vector<vector<int>>ans={{rStart,cStart}};\\n        int no=1;\\n        while(ans.size()!=result)\\n        {\\n            for(int i=0;i<limit;i++)\\n            {\\n                rStart+=dir[d][0];\\n                cStart+=dir[d][1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    ans.push_back({rStart,cStart});\\n                }\\n            }\\n                \\n                \\n                d=(d+1)%4;\\n            if(no==2)\\n            {\\n                limit++;no=1;\\n            }\\n            else no++;\\n                \\n                \\n                \\n        }\\n        return ans;\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739543,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix=new int[rows*cols][2];\\n        int i=0;\\n        matrix[i++]=new int[]{rStart,cStart};  //adding the initial position\\n        int d=0;          // this will be used for direction there can be 4 direction only 0 1 2 3 \\n\\t\\tint len=0;          //this is to take the number of steps;\\n        int[] directions=new int[]{0,1,0,-1,0};   //\\n        while(i<rows*cols){\\n            if(d==0||d==2){   // 0 for east 1 for south 2 for west and 3 for south \\n                len++;              //because only when we are facing east  or facing west then we are moving 1 step more\\n            }\\n            for(int k=0;k<len;k++){    //this for loop is to give the position after each step\\n                rStart+=directions[d];     //when facing east the x coordinate will not be changing only y coordinate will be changing that\\'s why cStart is incremented\\n                cStart+=directions[d+1];\\n                if(rStart<rows&&rStart>=0&&cStart<cols&&cStart>=0){\\n                    matrix[i++]=new int[]{rStart,cStart};         //this condition is to ensure we are only adding the coordinates of position which are in the matrix \\n                }\\n            }\\n            d=++d%4;       //this is to ensure d values never exceed 3 because we only want 4 direction and d value will be changing many times \\n            \\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] matrix=new int[rows*cols][2];\\n        int i=0;\\n        matrix[i++]=new int[]{rStart,cStart};  //adding the initial position\\n        int d=0;          // this will be used for direction there can be 4 direction only 0 1 2 3 \\n\\t\\tint len=0;          //this is to take the number of steps;\\n        int[] directions=new int[]{0,1,0,-1,0};   //\\n        while(i<rows*cols){\\n            if(d==0||d==2){   // 0 for east 1 for south 2 for west and 3 for south \\n                len++;              //because only when we are facing east  or facing west then we are moving 1 step more\\n            }\\n            for(int k=0;k<len;k++){    //this for loop is to give the position after each step\\n                rStart+=directions[d];     //when facing east the x coordinate will not be changing only y coordinate will be changing that\\'s why cStart is incremented\\n                cStart+=directions[d+1];\\n                if(rStart<rows&&rStart>=0&&cStart<cols&&cStart>=0){\\n                    matrix[i++]=new int[]{rStart,cStart};         //this condition is to ensure we are only adding the coordinates of position which are in the matrix \\n                }\\n            }\\n            d=++d%4;       //this is to ensure d values never exceed 3 because we only want 4 direction and d value will be changing many times \\n            \\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735206,
                "title": "java-solution-using-recursion-faster-than-99-43",
                "content": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int topr = rStart-1;\\n        int bottomr =rStart+1;\\n        int leftc = cStart-1;\\n        int rightc =cStart+1;\\n        ans[0][0] = rStart;\\n        ans[0][1]= cStart;\\n        \\n        \\n        return path(rows, cols, rStart, cStart, topr, bottomr, leftc, rightc, ans, 1);\\n    }\\n    int[][] path(int rows, int cols, int rStart, int cStart, int topr, int bottomr, int leftc, int rightc, int[][] mat, int x){\\n        \\n        if(topr<0 && bottomr>rows-1 && leftc<0 && rightc>cols-1){\\n            return mat;\\n        }\\n        \\n        for(int i = topr+1 ; i <= bottomr; i++){\\n            if(i<rows && i>=0 && rightc>=0 && rightc<cols){\\n                mat[x][0]=i;\\n                mat[x][1]=rightc;\\n                x +=1;\\n            }\\n        }\\n        for(int i =rightc-1; i>= leftc ; i--){\\n            if(i>=0 && i<cols && bottomr>=0 && bottomr < rows){\\n                mat[x][0]=bottomr;\\n                mat[x][1]=i;\\n                x +=1;\\n            }\\n        }\\n        for(int i =bottomr-1; i>=topr; i--){\\n            if(i<rows && i>=0 && leftc >= 0 && leftc<cols){\\n                mat[x][0]=i;\\n                mat[x][1]=leftc;\\n                x +=1;\\n            }\\n        }\\n        for(int i = leftc+1 ; i<= rightc; i++){\\n            if(i<cols && i>=0 && topr>=0 && topr<rows){\\n                mat[x][0]=topr;\\n                mat[x][1]=i;\\n                x +=1;\\n            }\\n        }\\n        return path(rows, cols, rStart+1, cStart, topr-1, bottomr+1, leftc-1, rightc+1, mat, x);\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int topr = rStart-1;\\n        int bottomr =rStart+1;\\n        int leftc = cStart-1;\\n        int rightc =cStart+1;\\n        ans[0][0] = rStart;\\n        ans[0][1]= cStart;\\n        \\n        \\n        return path(rows, cols, rStart, cStart, topr, bottomr, leftc, rightc, ans, 1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1688165,
                "title": "javascript-commented-solution",
                "content": "\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\n var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let r = rStart, c = cStart, results = [];\\n    results.push([r,c]);\\n    // Draw a picture of an infinite grid, then highlight a smaller grid inside with ${rows} of rows and ${cols} of columns.\\n    // Draw a little man at the rStart row and the cStart column.\\n    // We will tell the man to walk a number of steps in a certain direction.\\n    // if the man is on a highlighted square, he will collect it.\\n    const walk = (steps,rStep,cStep) => {\\n        for (let i =0;i<steps;i++) {\\n            r +=rStep, c+=cStep;\\n            if ( r>=0 && c >=0 && r < rows && c<cols) results.push([r,c]);\\n        }\\n    }\\n    // we need to direct the little man how to walk\\n    // first he will walk a distance of one step.\\n    let distance = 1;  \\n    // think about how he will walk the spiral.\\n     \\n    // we will tell the man to walk right 1 unit.\\n    // after that he will walk down 1 unit.\\n    let rDirection = 0, cDirection = 1;\\n     \\n    // then he walks left 2 units, then he walks up 2 units \\n    // then he walks right 3 units, then walks down 3 units\\n     \\n    // do this pattern until he collects all the squares. \\n    while (results.length < rows*cols) {\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [cDirection,rDirection];\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [-1*cDirection,-1*rDirection];\\n        distance++;\\n    }\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\n var spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let r = rStart, c = cStart, results = [];\\n    results.push([r,c]);\\n    // Draw a picture of an infinite grid, then highlight a smaller grid inside with ${rows} of rows and ${cols} of columns.\\n    // Draw a little man at the rStart row and the cStart column.\\n    // We will tell the man to walk a number of steps in a certain direction.\\n    // if the man is on a highlighted square, he will collect it.\\n    const walk = (steps,rStep,cStep) => {\\n        for (let i =0;i<steps;i++) {\\n            r +=rStep, c+=cStep;\\n            if ( r>=0 && c >=0 && r < rows && c<cols) results.push([r,c]);\\n        }\\n    }\\n    // we need to direct the little man how to walk\\n    // first he will walk a distance of one step.\\n    let distance = 1;  \\n    // think about how he will walk the spiral.\\n     \\n    // we will tell the man to walk right 1 unit.\\n    // after that he will walk down 1 unit.\\n    let rDirection = 0, cDirection = 1;\\n     \\n    // then he walks left 2 units, then he walks up 2 units \\n    // then he walks right 3 units, then walks down 3 units\\n     \\n    // do this pattern until he collects all the squares. \\n    while (results.length < rows*cols) {\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [cDirection,rDirection];\\n        walk(distance,rDirection,cDirection);\\n        [rDirection,cDirection] = [-1*cDirection,-1*rDirection];\\n        distance++;\\n    }\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283466,
                "title": "efficient-c-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int i, int j) {\\n\\t\\n\\t   // vector where we will store our elements indices { i , j }\\n       vector<vector<int>> matrix(rows*cols,vector<int>(2)); \\n\\t\\tint x=2;            // value to be used and incremented step by step\\n        int k=rows*cols,n1=0;      // max value is rows*cols\\n        int steps=1,t;      //  number of steps to go in any direction, we will increase this time to time\\n        matrix[n1++]={i,j};       // initialized first indice\\n        while(x<=k){\\n            \\n\\t\\t\\t// now first we will traverse steps number of steps in right direction\\n\\t\\t\\t// at every step, we will check if its a valid matrix indice or not\\n\\t\\t\\tt=steps;\\n            while(t--){\\n                j++;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n\\t\\t\\t\\t// for any valid indice, we will store that indice in matrix and increment x\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// now we will traverse same number of steps vertically down \\n            t=steps;\\n            while(t--){\\n                i++;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t// now we will traverse steps+1 number of steps in left direction\\n            steps++;\\n            t=steps;\\n            while(t--){\\n                j--;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// now we will traverse same number of steps vertically upward \\n            t=steps;\\n            while(t--){\\n                i--;\\n                if( j<cols && i<rows && j>=0 && i>=0) {\\n                    matrix[n1++]={ i , j };\\n                    x++;\\n                }\\n            }\\n\\t\\t\\t// now we again increase steps by 1 to maintain clockwise motion\\n            l++;\\n        }\\n        return matrix;  // our matrix is ready \\n    }\\n// NOTE:- To understand the code, have a look at the given sample examples and understand the motion.\\n// If understood the concept then please press the up arrow on the left of this solution.\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int i, int j) {\\n\\t\\n\\t   // vector where we will store our elements indices { i , j }",
                "codeTag": "Java"
            },
            {
                "id": 352599,
                "title": "c-clean-code-beat-96-with-explanation",
                "content": "**take a pen and paper, try to draw the path once by yourself, you will notice that**\\n```\\n\\t\\t\\t       i    wanted steps\\ngo right  by 1     0        1 = i/2+1\\ngo down   by 1     1        1 = i/2+1\\ngo left   by 2     2        2 = i/2+1\\ngo up     by 2     3        2 = i/2+1\\ngo right  by 3     4        3 = i/2+1\\ngo down   by 3     5        3 = i/2+1\\ngo left   by 4     6        4 = i/2+1\\ngo up     by 4     7        4 = i/2+1\\n...etc\\n```\\n**once we meet out of bound, don\\'t add it to the answer and just going forward.**\\n\\n```\\nclass Solution {\\npublic:\\n    int way[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> res;\\n        res.push_back({r0,c0}); //put the source first\\n        int direction = 0, end_cnt = 1;\\n        for(int i = 0 ; end_cnt < R*C ; i++){\\n            int cnt = i/2+1;\\n            while(cnt--){\\n                r0 += way[direction][0];\\n                c0 += way[direction][1];\\n                if(r0 >= 0 && r0 < R && c0 < C && c0 >= 0) // only when current node is a valid position, add vector to the answer. There is no duplicate node, don\\'t worry.\\n                    res.push_back({r0,c0}),end_cnt++;\\n            }\\n            direction = (direction+1)%4; //each i loop, change direction\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t       i    wanted steps\\ngo right  by 1     0        1 = i/2+1\\ngo down   by 1     1        1 = i/2+1\\ngo left   by 2     2        2 = i/2+1\\ngo up     by 2     3        2 = i/2+1\\ngo right  by 3     4        3 = i/2+1\\ngo down   by 3     5        3 = i/2+1\\ngo left   by 4     6        4 = i/2+1\\ngo up     by 4     7        4 = i/2+1\\n...etc\\n```\n```\\nclass Solution {\\npublic:\\n    int way[4][2] = {{0,1},{1,0},{0,-1},{-1,0}};\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        vector<vector<int>> res;\\n        res.push_back({r0,c0}); //put the source first\\n        int direction = 0, end_cnt = 1;\\n        for(int i = 0 ; end_cnt < R*C ; i++){\\n            int cnt = i/2+1;\\n            while(cnt--){\\n                r0 += way[direction][0];\\n                c0 += way[direction][1];\\n                if(r0 >= 0 && r0 < R && c0 < C && c0 >= 0) // only when current node is a valid position, add vector to the answer. There is no duplicate node, don\\'t worry.\\n                    res.push_back({r0,c0}),end_cnt++;\\n            }\\n            direction = (direction+1)%4; //each i loop, change direction\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160624,
                "title": "python-version-with-counting-turn-times",
                "content": "```\\ndef  spiralMatrixIII(R, C, r0, c0):\\n        res = [[r0,c0]]\\n        count_turn = 0\\n        di = 0\\n        x, y = r0, c0\\n        dx = [0, 1, 0, -1]\\n        dy = [1, 0, -1, 0]\\n        while len(res) < R*C:\\n            steps = count_turn//2 + 1\\n            for step in range(steps):\\n                x += dx[di]\\n                y += dy[di]\\n                if 0<= x<= R-1 and 0 <= y <=C-1:\\n                    res.append([x, y])\\n            count_turn += 1\\n            di = (di+1)%4\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef  spiralMatrixIII(R, C, r0, c0):\\n        res = [[r0,c0]]\\n        count_turn = 0\\n        di = 0\\n        x, y = r0, c0\\n        dx = [0, 1, 0, -1]\\n        dy = [1, 0, -1, 0]\\n        while len(res) < R*C:\\n            steps = count_turn//2 + 1\\n            for step in range(steps):\\n                x += dx[di]\\n                y += dy[di]\\n                if 0<= x<= R-1 and 0 <= y <=C-1:\\n                    res.append([x, y])\\n            count_turn += 1\\n            di = (di+1)%4\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158995,
                "title": "python-infinite-generator-yield",
                "content": "* use a generator to generate the infinite sequence of spiral coordinates\\n* every time a coordinate is within bounds, add it to the solution\\n* based on the spiral pattern:\\n  * no coordinate is visited twice\\n  * every coordinate is visited\\n  * the total number of spiral coordinates generated will not exceed approximately 4 times the size of the grid (since the first RxCx4 spiral coordinates should cover all four cuadrants around the starting point)\\n* stop when RxC coordinates have been collected\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        def nxt(r,c):\\n            d=1\\n            yield (r,c)\\n            while True:\\n                for i in range(d):\\n                    c+=1\\n                    yield (r,c)\\n                for i in range(d):\\n                    r+=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    c-=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    r-=1\\n                    yield (r,c)\\n                d+=2\\n        \\n        ret=[]\\n        r,c=r0,c0\\n        for (r,c) in nxt(r0,c0):\\n            if 0<=r<R and 0<=c<C:\\n                ret.append([r,c])\\n            if len(ret)==R*C:\\n                break\\n            \\n        return ret\\n\\t\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        \\n        def nxt(r,c):\\n            d=1\\n            yield (r,c)\\n            while True:\\n                for i in range(d):\\n                    c+=1\\n                    yield (r,c)\\n                for i in range(d):\\n                    r+=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    c-=1\\n                    yield (r,c)\\n                for i in range(d+1):\\n                    r-=1\\n                    yield (r,c)\\n                d+=2\\n        \\n        ret=[]\\n        r,c=r0,c0\\n        for (r,c) in nxt(r0,c0):\\n            if 0<=r<R and 0<=c<C:\\n                ret.append([r,c])\\n            if len(ret)==R*C:\\n                break\\n            \\n        return ret\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750377,
                "title": "solution-made-easy",
                "content": "# Approach\\nSame as Spiral Matrix 1\\nJust keep in mind that we do not have to stop once we are out of the boundary. The stopping condition is that when we have visited all the cells i.e. $$ans.size() == m*n$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int x, int y) {\\n        vector<vector<int>> ans;\\n\\n        int len = 1;\\n        ans.push_back({x,y});\\n\\n        while(ans.size() < m*n) {\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y+j,m,n)) {\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y += len;\\n            \\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x+i,y,m,n)) {\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x += len;\\n\\n            len++;\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y-j,m,n)) {\\n                    ans.push_back({x,y-j});\\n                }\\n            }\\n            y -= len;\\n\\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x-i,y,m,n)) {\\n                    ans.push_back({x-i,y});\\n                }\\n            }\\n            x -= len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n\\n    bool isValid(int i, int j, int m, int n) {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n};\\n```\\n\\nCheck all the Spiral Matrix Problems (1 to 4) here -\\nSpiral Matrix 1 - https://leetcode.com/problems/spiral-matrix/solutions/3747955/easy-traversal/\\nSpiral Matrix 2 - https://leetcode.com/problems/spiral-matrix-ii/solutions/3747970/same-as-spiral-matrix-i/\\nSpiral Matrix 3 - https://leetcode.com/problems/spiral-matrix-iii/solutions/3750377/solution-made-easy/\\nSpiral Matrix 4 - https://leetcode.com/problems/spiral-matrix-iv/solutions/2230030/simple-solution/\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int x, int y) {\\n        vector<vector<int>> ans;\\n\\n        int len = 1;\\n        ans.push_back({x,y});\\n\\n        while(ans.size() < m*n) {\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y+j,m,n)) {\\n                    ans.push_back({x,y+j});\\n                }\\n            }\\n            y += len;\\n            \\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x+i,y,m,n)) {\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x += len;\\n\\n            len++;\\n            for(int j=1 ; j<=len ; j++) {\\n                if(isValid(x,y-j,m,n)) {\\n                    ans.push_back({x,y-j});\\n                }\\n            }\\n            y -= len;\\n\\n            for(int i=1 ; i<=len ; i++) {\\n                if(isValid(x-i,y,m,n)) {\\n                    ans.push_back({x-i,y});\\n                }\\n            }\\n            x -= len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n\\n    bool isValid(int i, int j, int m, int n) {\\n        return (i>=0 && j>=0 && i<m && j<n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507866,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        vector<vector<int>> result;\\n        int total = 0;\\n\\n        int rowStart = rStart;\\n        int rowEnd = rStart;\\n\\n        int colStart = cStart;\\n        int colEnd = cStart;\\n\\n        while(true){\\n            for(int i=colStart; i<=colEnd; i++){\\n                if(i >= 0 && i < cols && rowStart >= 0){\\n                    result.push_back({rowStart, i});\\n                    total++;\\n                }\\n            }\\n            colEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowStart; i<=rowEnd; i++){\\n                if(i >= 0 && i < rows && colEnd < cols){\\n                    result.push_back({i, colEnd});\\n                    total++;\\n                }\\n            }\\n            rowEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=colEnd; i>=colStart; i--){\\n                if(i >= 0 && i < cols && rowEnd < rows){\\n                    result.push_back({rowEnd, i});\\n                    total++;\\n                }\\n            }\\n            colStart--;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowEnd; i>=rowStart; i--){\\n                if(i >= 0 && i < rows && colStart >= 0){\\n                    result.push_back({i, colStart});\\n                    total++;\\n                }\\n            }\\n            rowStart--;\\n            if(total == (rows * cols))\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        visits = []\\n        top, bottom, left, right = rStart, rStart + 1, cStart, cStart + 1\\n\\n        self.incr = 1\\n        direction = 0\\n\\n        def place(row, col):\\n            visits.append([row, col])\\n            self.incr += 1\\n        \\n        while self.incr != (1 + rows * cols):\\n            if direction == 0:\\n                if top >= 0:\\n                    row = top\\n                    for col in range(max(left, 0), min(right, cols)):\\n                        place(row, col)\\n                right += 1\\n            if direction == 1:\\n                if right <= cols:\\n                    col = right - 1\\n                    for row in range(max(top, 0), min(bottom, rows)):\\n                        place(row, col)\\n                bottom += 1\\n            if direction == 2:\\n                if bottom <= rows:\\n                    row = bottom - 1\\n                    for col in range(min(right - 1, cols - 1), max(left - 1, -1), -1):\\n                        place(row, col)\\n                left -= 1\\n            if direction == 3:\\n                if left >= 0:\\n                    col = left\\n                    for row in range(min(bottom - 1, rows - 1), max(top - 1, -1), -1):\\n                        place(row, col)\\n                top -= 1\\n            direction = (direction + 1) % 4\\n        return visits\\n```\\n\\n```Java []\\nclass Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart };\\n        while (index < result.length) {\\n            ++moves;\\n            addToResult(result, moves, 1, 0);\\n            addToResult(result, moves, 0, 1);\\n            ++moves;\\n            addToResult(result, moves, -1, 0);\\n            addToResult(result, moves, 0, -1);\\n        }\\n        return result;\\n    }\\n    public void addToResult(int[][] result, int moves, int horizontal, int vertical) {\\n        for (int i = 0; i < moves; ++i) {\\n            row += vertical;\\n            col += horizontal;\\n            if (row < rows && row > -1 && col < cols && col > -1) {\\n                result[index] = new int[] { row, col };\\n                ++index;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n\\n        vector<vector<int>> result;\\n        int total = 0;\\n\\n        int rowStart = rStart;\\n        int rowEnd = rStart;\\n\\n        int colStart = cStart;\\n        int colEnd = cStart;\\n\\n        while(true){\\n            for(int i=colStart; i<=colEnd; i++){\\n                if(i >= 0 && i < cols && rowStart >= 0){\\n                    result.push_back({rowStart, i});\\n                    total++;\\n                }\\n            }\\n            colEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowStart; i<=rowEnd; i++){\\n                if(i >= 0 && i < rows && colEnd < cols){\\n                    result.push_back({i, colEnd});\\n                    total++;\\n                }\\n            }\\n            rowEnd++;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=colEnd; i>=colStart; i--){\\n                if(i >= 0 && i < cols && rowEnd < rows){\\n                    result.push_back({rowEnd, i});\\n                    total++;\\n                }\\n            }\\n            colStart--;\\n            if(total == (rows * cols))\\n                break;\\n            for(int i=rowEnd; i>=rowStart; i--){\\n                if(i >= 0 && i < rows && colStart >= 0){\\n                    result.push_back({i, colStart});\\n                    total++;\\n                }\\n            }\\n            rowStart--;\\n            if(total == (rows * cols))\\n                break;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        visits = []\\n        top, bottom, left, right = rStart, rStart + 1, cStart, cStart + 1\\n\\n        self.incr = 1\\n        direction = 0\\n\\n        def place(row, col):\\n            visits.append([row, col])\\n            self.incr += 1\\n        \\n        while self.incr != (1 + rows * cols):\\n            if direction == 0:\\n                if top >= 0:\\n                    row = top\\n                    for col in range(max(left, 0), min(right, cols)):\\n                        place(row, col)\\n                right += 1\\n            if direction == 1:\\n                if right <= cols:\\n                    col = right - 1\\n                    for row in range(max(top, 0), min(bottom, rows)):\\n                        place(row, col)\\n                bottom += 1\\n            if direction == 2:\\n                if bottom <= rows:\\n                    row = bottom - 1\\n                    for col in range(min(right - 1, cols - 1), max(left - 1, -1), -1):\\n                        place(row, col)\\n                left -= 1\\n            if direction == 3:\\n                if left >= 0:\\n                    col = left\\n                    for row in range(min(bottom - 1, rows - 1), max(top - 1, -1), -1):\\n                        place(row, col)\\n                top -= 1\\n            direction = (direction + 1) % 4\\n        return visits\\n```\n```Java []\\nclass Solution {\\n    int index = 1;\\n    int row;\\n    int col;\\n    int rows;\\n    int cols;\\n\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int moves = 0;\\n        row = rStart;\\n        col = cStart;\\n        this.rows = rows;\\n        this.cols = cols;\\n        result[0] = new int[] { rStart, cStart };\\n        while (index < result.length) {\\n            ++moves;\\n            addToResult(result, moves, 1, 0);\\n            addToResult(result, moves, 0, 1);\\n            ++moves;\\n            addToResult(result, moves, -1, 0);\\n            addToResult(result, moves, 0, -1);\\n        }\\n        return result;\\n    }\\n    public void addToResult(int[][] result, int moves, int horizontal, int vertical) {\\n        for (int i = 0; i < moves; ++i) {\\n            row += vertical;\\n            col += horizontal;\\n            if (row < rows && row > -1 && col < cols && col > -1) {\\n                result[index] = new int[] { row, col };\\n                ++index;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3507245,
                "title": "c-easy-solution",
                "content": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int top = rStart, down = rStart, left = cStart, right = cStart;\\n        ans.push_back({rStart, cStart});\\n        int count = 1;\\n        \\n        int dir = 0;\\n        //rows* cols => no of elements in the matrix\\n        while(count < rows*cols)\\n        {\\n            if(dir == 0)\\n            {\\n                for(int i=left+1; i<=right+1; i++)\\n                {\\n                    if(i>=0 && i<cols && top>=0 && top<rows)\\n                    {\\n                        ans.push_back({top, i});\\n                        count++;\\n                    }\\n                }\\n                right++;\\n            }\\n            else if(dir == 1)\\n            {\\n                for(int i=top+1; i<=down+1; i++)\\n                {\\n                    if(i>=0 && i<rows && right>=0 && right<cols)\\n                    {\\n                        ans.push_back({i, right});\\n                        count++;\\n                    }\\n                }\\n                down++;\\n            }\\n            else if(dir == 2)\\n            {\\n                for(int i=right-1; i>=left-1; i--)\\n                {\\n                    if(i>=0 && i<cols && down>=0 && down<rows)\\n                    {\\n                        ans.push_back({down, i});\\n                        count++;\\n                    }\\n                }\\n                left--;\\n            }\\n            else if(dir == 3)\\n            {\\n                for(int i=down-1; i>=top-1; i--)\\n                {\\n                    if(i>=0 && i<rows && left>=0 && left<cols)\\n                    {\\n                        ans.push_back({i, left});\\n                        count++;\\n                    }\\n                }\\n                top--;\\n            }\\n            dir = (dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int top = rStart, down = rStart, left = cStart, right = cStart;\\n        ans.push_back({rStart, cStart});\\n        int count = 1;\\n        \\n        int dir = 0;\\n        //rows* cols => no of elements in the matrix\\n        while(count < rows*cols)\\n        {\\n            if(dir == 0)\\n            {\\n                for(int i=left+1; i<=right+1; i++)\\n                {\\n                    if(i>=0 && i<cols && top>=0 && top<rows)\\n                    {\\n                        ans.push_back({top, i});\\n                        count++;\\n                    }\\n                }\\n                right++;\\n            }\\n            else if(dir == 1)\\n            {\\n                for(int i=top+1; i<=down+1; i++)\\n                {\\n                    if(i>=0 && i<rows && right>=0 && right<cols)\\n                    {\\n                        ans.push_back({i, right});\\n                        count++;\\n                    }\\n                }\\n                down++;\\n            }\\n            else if(dir == 2)\\n            {\\n                for(int i=right-1; i>=left-1; i--)\\n                {\\n                    if(i>=0 && i<cols && down>=0 && down<rows)\\n                    {\\n                        ans.push_back({down, i});\\n                        count++;\\n                    }\\n                }\\n                left--;\\n            }\\n            else if(dir == 3)\\n            {\\n                for(int i=down-1; i>=top-1; i--)\\n                {\\n                    if(i>=0 && i<rows && left>=0 && left<cols)\\n                    {\\n                        ans.push_back({i, left});\\n                        count++;\\n                    }\\n                }\\n                top--;\\n            }\\n            dir = (dir+1)%4;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3504467,
                "title": "simple-simulation-solution-python",
                "content": "# Intuition and Approach\\n* start the simulation from starting cell and insert position of cells in to ans which lie within the matrix\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n\\n- Space complexity: O(N^2)\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, m: int, n: int, i: int, j: int) -> List[List[int]]:\\n        ans=[]\\n        lb,rb,tb,bb=j,j,i,i\\n        while(len(ans)<m*n):\\n            while(j<rb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j+=1\\n            rb+=1\\n            while(i<bb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i+=1\\n            bb+=1\\n            while(j>lb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j-=1\\n            lb-=1\\n            while(i>tb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i-=1\\n            tb-=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, m: int, n: int, i: int, j: int) -> List[List[int]]:\\n        ans=[]\\n        lb,rb,tb,bb=j,j,i,i\\n        while(len(ans)<m*n):\\n            while(j<rb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j+=1\\n            rb+=1\\n            while(i<bb+1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i+=1\\n            bb+=1\\n            while(j>lb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                j-=1\\n            lb-=1\\n            while(i>tb-1):\\n                if(i<m and j<n and i>=0 and j>=0):ans.append([i,j])\\n                i-=1\\n            tb-=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812047,
                "title": "spiral-matrix-iii-adapted-dfs-solution",
                "content": "# Approach\\nWe keep track of 5 main variables:\\n1. x: colum number\\n2. y: row number\\n3. d: current direction\\n3. visited: Set of Pairs of visited col & row\\n4. result: List of ordered visited pairs\\n\\nEach time we check the direction and possible x & y values :\\n- if next position already visited: keep moving in the same current position.\\n- if next position is not visited: update x & y\\n\\n**Grid\\'s boundary**:\\nMoving outside of the grid\\'s boundary will not cause a problem if we ignore the positions in the final result. It is not needed to include the outer positions in the visited set. \\n\\n# Complexity\\n- Time complexity: **O(n*m)**\\n\\n- Space complexity: **O(n*m)**\\n\\nNote: *n=rows, m=columns*\\n\\n# Code\\n```\\nenum class Direction {\\n    RIGHT, DOWN, LEFT, UP\\n}\\n\\nclass Solution {\\n\\n    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {\\n        val visited: MutableSet<Pair<Int, Int>> = mutableSetOf()\\n        val result: MutableList<IntArray> = mutableListOf()\\n        var y = rStart\\n        var x = cStart\\n        var d: Direction = Direction.UP\\n        fun dfs() {\\n            if (x in 0 until cols && y in 0 until rows) {\\n                visited.add(Pair(y, x))\\n                result.add(intArrayOf(y, x))\\n            }\\n            when (d) {\\n                Direction.RIGHT -> {\\n                    if (!visited.contains(Pair(y+1, x))) {y+=1; d=Direction.DOWN}\\n                    else {x+=1; d=Direction.RIGHT}\\n                }\\n                Direction.DOWN -> {\\n                    if (!visited.contains(Pair(y, x-1))) {x-=1; d=Direction.LEFT}\\n                    else {y+=1; d=Direction.DOWN}\\n                }\\n                Direction.LEFT -> {\\n                    if (!visited.contains(Pair(y-1, x))) {y-=1; d=Direction.UP}\\n                    else {x-=1; d=Direction.LEFT}\\n                }\\n                Direction.UP -> {\\n                    if (!visited.contains(Pair(y, x+1))) {x+=1; d=Direction.RIGHT}\\n                    else {y-=1; d=Direction.UP}\\n                }\\n            }\\n            if (visited.size == rows * cols){\\n                return\\n            } else { dfs() }\\n        }\\n        dfs()\\n        return result.toTypedArray()\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nenum class Direction {\\n    RIGHT, DOWN, LEFT, UP\\n}\\n\\nclass Solution {\\n\\n    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {\\n        val visited: MutableSet<Pair<Int, Int>> = mutableSetOf()\\n        val result: MutableList<IntArray> = mutableListOf()\\n        var y = rStart\\n        var x = cStart\\n        var d: Direction = Direction.UP\\n        fun dfs() {\\n            if (x in 0 until cols && y in 0 until rows) {\\n                visited.add(Pair(y, x))\\n                result.add(intArrayOf(y, x))\\n            }\\n            when (d) {\\n                Direction.RIGHT -> {\\n                    if (!visited.contains(Pair(y+1, x))) {y+=1; d=Direction.DOWN}\\n                    else {x+=1; d=Direction.RIGHT}\\n                }\\n                Direction.DOWN -> {\\n                    if (!visited.contains(Pair(y, x-1))) {x-=1; d=Direction.LEFT}\\n                    else {y+=1; d=Direction.DOWN}\\n                }\\n                Direction.LEFT -> {\\n                    if (!visited.contains(Pair(y-1, x))) {y-=1; d=Direction.UP}\\n                    else {x-=1; d=Direction.LEFT}\\n                }\\n                Direction.UP -> {\\n                    if (!visited.contains(Pair(y, x+1))) {x+=1; d=Direction.RIGHT}\\n                    else {y-=1; d=Direction.UP}\\n                }\\n            }\\n            if (visited.size == rows * cols){\\n                return\\n            } else { dfs() }\\n        }\\n        dfs()\\n        return result.toTypedArray()\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288908,
                "title": "c-easy-code-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/f1fe41ab-78f6-476e-9878-58beac74b5a6_1657953630.037121.jpeg)\\n\\n\\n\\n//  Key idea behind this approach is to spirally(clockwise) traverse matrix and expand traversal area( decrementing top and left, incrementing right and down) and keep checking boundary condition\\n\\n// T.C = O(rows*cols) , S.C = O(rows*cols)\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        \\n        vector<vector<int>> ans ;\\n        \\n        // keep track which cell is visited to avoid duplicate insertion in ans \\n        vector<vector<bool>> isvisited( rows, vector<bool>( cols, false ) ) ;\\n        \\n        int top = rStart , down = (rStart < (rows-1)) ? rStart+1 : rStart , left = cStart, right = (cStart < (cols-1)) ? cStart+1 : cStart ;\\n        \\n        int direction = 0 ;   // 0 == forward, 1 == downward , 2 == backward, 3 == upward\\n        \\n        \\n        ans.push_back({rStart, cStart}) ;\\n        \\n        isvisited[rStart][cStart] = true ;\\n        \\n        while( (int)ans.size() < (rows*cols) ){\\n            \\n           \\n            // forward move\\n            \\n            if( direction == 0 ){\\n                \\n                for( int i = left+1 ; i <= right ; ++i ){\\n                    \\n                    if(!isvisited[top][i]){\\n                        \\n                        ans.push_back({ top , i }) ;\\n                        \\n                        isvisited[top][i] = true ;\\n                    }\\n                }\\n            }\\n            \\n            // downward move\\n            \\n            else if( direction == 1 ){\\n                \\n                for( int i = top+1 ; i <= down ; ++i ){\\n                    \\n                    if( !isvisited[i][right] ){\\n                        \\n                        ans.push_back({ i , right }) ;\\n                        \\n                        isvisited[i][right] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n               if( top > 0 ){\\n                \\ttop -= 1 ;\\n                }\\n                if( left > 0 ){\\n                \\tleft -= 1 ;\\n                }\\n            }\\n            \\n            // backward move\\n            \\n            else if( direction == 2 ){\\n                \\n                for( int i = right-1 ; i >= left ; --i ){\\n                    \\n                    if( !isvisited[down][i] ){\\n                        \\n                        ans.push_back({ down , i }) ;\\n                        \\n                        isvisited[down][i] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n                if( right < (cols-1)){\\n                \\tright += 1 ;\\n                }\\n            }\\n            \\n            // upward move\\n            \\n            else if( direction == 3 ){\\n                \\n                for( int i = down-1 ; i >= top ; --i ){\\n                    \\n                    if( !isvisited[i][left] ){\\n                        \\n                        ans.push_back({ i, left }) ;\\n                        \\n                        isvisited[i][left] = true ;\\n                    }\\n                }\\n                // if we can expand area, expand it(boundary condtion)\\n                if( down < (rows-1)){\\n                \\tdown += 1;\\n                }\\n            }\\n            \\n            \\n            direction =  (direction+1)%4 ;\\n           \\n        } \\n        \\n        return ans ;\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        \\n        vector<vector<int>> ans ;\\n        \\n        // keep track which cell is visited to avoid duplicate insertion in ans \\n        vector<vector<bool>> isvisited( rows, vector<bool>( cols, false ) ) ;\\n        \\n        int top = rStart , down = (rStart < (rows-1)) ? rStart+1 : rStart , left = cStart, right = (cStart < (cols-1)) ? cStart+1 : cStart ;\\n        \\n        int direction = 0 ;   // 0 == forward, 1 == downward , 2 == backward, 3 == upward\\n        \\n        \\n        ans.push_back({rStart, cStart}",
                "codeTag": "Java"
            },
            {
                "id": 2238692,
                "title": "c-simple-simulate-the-process-with-ease",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int r,int c,int n,int m)\\n    {\\n        return r>=0&&r<n&&c>=0&&c<m;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int c=0;\\n        int grids=rows*cols;\\n        int go=1;\\n        bool up,left,right,down;\\n        left=up=down=false;\\n        int z=0;\\n        right=true;\\n        while(true)\\n        {\\n            if(isvalid(rStart,cStart,rows,cols))\\n            {\\n                c++;\\n                // cout<<c<<endl;\\n                // cout<<rStart<<\" \"<<cStart<<endl;\\n                ans.push_back({rStart,cStart});\\n            }\\n            if(c==grids)\\n            {\\n                break;\\n            }\\n            if(right&&z!=go)\\n            {\\n                cStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    right=false;\\n                    down=true;\\n                    z=0;\\n                }\\n            }\\n            else if(down&&z!=go)\\n            {\\n                rStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    down=false;\\n                    left=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n            else if(left)\\n            {\\n                cStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    left=false;\\n                    up=true;\\n                    z=0;\\n                }\\n            }\\n            else if(up)\\n            {\\n                rStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    up=false;\\n                    right=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int r,int c,int n,int m)\\n    {\\n        return r>=0&&r<n&&c>=0&&c<m;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int c=0;\\n        int grids=rows*cols;\\n        int go=1;\\n        bool up,left,right,down;\\n        left=up=down=false;\\n        int z=0;\\n        right=true;\\n        while(true)\\n        {\\n            if(isvalid(rStart,cStart,rows,cols))\\n            {\\n                c++;\\n                // cout<<c<<endl;\\n                // cout<<rStart<<\" \"<<cStart<<endl;\\n                ans.push_back({rStart,cStart});\\n            }\\n            if(c==grids)\\n            {\\n                break;\\n            }\\n            if(right&&z!=go)\\n            {\\n                cStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    right=false;\\n                    down=true;\\n                    z=0;\\n                }\\n            }\\n            else if(down&&z!=go)\\n            {\\n                rStart++;\\n                z++;\\n                if(z==go)\\n                {\\n                    down=false;\\n                    left=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n            else if(left)\\n            {\\n                cStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    left=false;\\n                    up=true;\\n                    z=0;\\n                }\\n            }\\n            else if(up)\\n            {\\n                rStart--;\\n                z++;\\n                if(z==go)\\n                {\\n                    up=false;\\n                    right=true;\\n                    go++;\\n                    z=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2091734,
                "title": "java-easy-to-understand-solution",
                "content": "```\\npublic static final int[][] dir = new int[][]{{0,1}, {1,0}, {0,-1}, {-1, 0}};\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] coords = new int[rows*cols][2];\\n        int ind = 0;\\n        int count = 0;\\n        int d = 0;\\n        int x = rStart, y = cStart;\\n        coords[ind++] = new int[]{rStart, cStart};\\n        while(ind < rows*cols) {\\n            if(d % 2 == 0)\\n                count++;\\n            for(int i = 0; i < count; i++) {\\n                x += dir[d][0];\\n                y += dir[d][1];\\n                if(isCoordValid(x, y, rows, cols))\\n                    coords[ind++] = new int[]{x, y};\\n            }\\n            d = (d+1)%4;\\n        }\\n        return coords;\\n    }\\n    \\n    private boolean isCoordValid(int x, int y, int rows, int cols) {\\n        return x >= 0 && y >= 0 && x < rows && y < cols;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static final int[][] dir = new int[][]{{0,1}, {1,0}, {0,-1}, {-1, 0}};\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] coords = new int[rows*cols][2];\\n        int ind = 0;\\n        int count = 0;\\n        int d = 0;\\n        int x = rStart, y = cStart;\\n        coords[ind++] = new int[]{rStart, cStart};\\n        while(ind < rows*cols) {\\n            if(d % 2 == 0)\\n                count++;\\n            for(int i = 0; i < count; i++) {\\n                x += dir[d][0];\\n                y += dir[d][1];\\n                if(isCoordValid(x, y, rows, cols))\\n                    coords[ind++] = new int[]{x, y};\\n            }\\n            d = (d+1)%4;\\n        }\\n        return coords;\\n    }\\n    \\n    private boolean isCoordValid(int x, int y, int rows, int cols) {\\n        return x >= 0 && y >= 0 && x < rows && y < cols;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038092,
                "title": "python-go-easy-to-understand-because-i-m-a-dummy-and-so-are-you",
                "content": "This is a dummy\\'s way to solve the problem so it might be a bit lengthy, but I figure this should be easy to understand.\\n\\nFirst look at the picture with the arrows in the question (Look at the second example, it\\'s easier to visualize).\\n\\nHere\\'s the steps we follow:\\n- First move 1 step to the right\\n- Then move 1 step down\\n- Then move 2 steps to the left\\n- Then move 2 steps up\\n- Then move 3 steps to the right\\n- This goes on...\\n\\nHow can we exploit this pattern? By making a step variable.\\n- If the step is odd, we move right then down\\n- If the step is even, we move left then up\\n\\nFor each movement, we check if the position is within the matrix boundary. If it is, we add it to the solution, if not we ignore.\\n\\nJust look at the code. It\\'s really simple.\\n\\nHere\\'s the code:\\n\\n**Python:**\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, row: int, col: int) -> List[List[int]]:\\n        step = 1\\n        res = [[row, col]] # we always start with the given position\\n        while len(res) < rows * cols: # stop when we have enough elements\\n            if step % 2 == 1: # odd step\\n                stop = col + step\\n                while col < stop: # move left\\n                    col += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row + step\\n                while row < stop: # move down\\n                    row += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            else: # even step\\n                stop = col - step\\n                while col > stop: # move right\\n                    col -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row - step\\n                while row > stop: # move up\\n                    row -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            step += 1\\n            \\n        return res\\n    \\n    def is_valid(self, row, col, rows, cols):\\n        return row >= 0 and row < rows and col >= 0 and col < cols\\n```\\n\\n**Go:**\\n```\\nfunc spiralMatrixIII(rows int, cols int, row int, col int) [][]int {\\n    step := 1\\n    res := [][]int{[]int{row, col}}\\n    \\n    for len(res) < rows * cols {\\n        if step % 2 == 1 { // odd step\\n            stop := col + step\\n            for col < stop { // move left\\n                col++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row + step\\n            for row < stop { // move down\\n                row++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        } else { // even step\\n            stop := col - step\\n            for col > stop { // move right\\n                col--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row - step\\n            for row > stop { // move up\\n                row--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        }\\n        \\n        step++\\n    }\\n    \\n    return res\\n}\\n\\nfunc is_valid(row, col, rows, cols int) bool {\\n    return row >= 0 && row < rows && col >= 0 && col < cols\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, row: int, col: int) -> List[List[int]]:\\n        step = 1\\n        res = [[row, col]] # we always start with the given position\\n        while len(res) < rows * cols: # stop when we have enough elements\\n            if step % 2 == 1: # odd step\\n                stop = col + step\\n                while col < stop: # move left\\n                    col += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row + step\\n                while row < stop: # move down\\n                    row += 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            else: # even step\\n                stop = col - step\\n                while col > stop: # move right\\n                    col -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n                stop = row - step\\n                while row > stop: # move up\\n                    row -= 1\\n                    if self.is_valid(row, col, rows, cols):\\n                        res.append([row, col])\\n                \\n            step += 1\\n            \\n        return res\\n    \\n    def is_valid(self, row, col, rows, cols):\\n        return row >= 0 and row < rows and col >= 0 and col < cols\\n```\n```\\nfunc spiralMatrixIII(rows int, cols int, row int, col int) [][]int {\\n    step := 1\\n    res := [][]int{[]int{row, col}}\\n    \\n    for len(res) < rows * cols {\\n        if step % 2 == 1 { // odd step\\n            stop := col + step\\n            for col < stop { // move left\\n                col++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row + step\\n            for row < stop { // move down\\n                row++\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        } else { // even step\\n            stop := col - step\\n            for col > stop { // move right\\n                col--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n            \\n            stop = row - step\\n            for row > stop { // move up\\n                row--\\n                if is_valid(row, col, rows, cols) {\\n                    res = append(res, []int{row, col})\\n                }\\n            }\\n        }\\n        \\n        step++\\n    }\\n    \\n    return res\\n}\\n\\nfunc is_valid(row, col, rows, cols int) bool {\\n    return row >= 0 && row < rows && col >= 0 && col < cols\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956245,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int i=0;\\n        ans[i++] = new int[]{rStart, cStart};\\n        \\n        int len=0;\\n        int d=0;\\n        int[] direction = new int[]{0, 1, 0, -1, 0};\\n        \\n        while(i < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int k=0; k<len; k++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart<rows && rStart>=0 && cStart<cols && cStart >= 0){\\n                    ans[i++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] ans = new int[rows*cols][2];\\n        int i=0;\\n        ans[i++] = new int[]{rStart, cStart};\\n        \\n        int len=0;\\n        int d=0;\\n        int[] direction = new int[]{0, 1, 0, -1, 0};\\n        \\n        while(i < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int k=0; k<len; k++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart<rows && rStart>=0 && cStart<cols && cStart >= 0){\\n                    ans[i++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942233,
                "title": "c-with-issafe-function",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int isSafe(int rows, int cols, int i, int j)\\n    {\\n\\n        if (i < 0 || j < 0 || j >= cols || i >= rows)\\n        {\\n            return false;\\n        }\\n        return true;\\n    } \\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n    {\\n        int num = 2;\\n        vector<vector<int>> ans;\\n        int move = 0;\\n        ans.push_back(vector<int>{rStart, cStart});\\n        while (num <= rows * cols)\\n        {\\n\\n            move++;\\n            // right\\n            int p = move;\\n            while (p--)\\n            {\\n                cStart++;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // down\\n            p = move;\\n            while (p--)\\n            {\\n                rStart++;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            move++;\\n            // r -> l\\n            p = move;\\n            while (p--)\\n            {\\n                cStart--;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // d -> u\\n            p = move;\\n            while (p--)\\n            {\\n                rStart--;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int isSafe(int rows, int cols, int i, int j)\\n    {\\n\\n        if (i < 0 || j < 0 || j >= cols || i >= rows)\\n        {\\n            return false;\\n        }\\n        return true;\\n    } \\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n    {\\n        int num = 2;\\n        vector<vector<int>> ans;\\n        int move = 0;\\n        ans.push_back(vector<int>{rStart, cStart});\\n        while (num <= rows * cols)\\n        {\\n\\n            move++;\\n            // right\\n            int p = move;\\n            while (p--)\\n            {\\n                cStart++;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // down\\n            p = move;\\n            while (p--)\\n            {\\n                rStart++;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            move++;\\n            // r -> l\\n            p = move;\\n            while (p--)\\n            {\\n                cStart--;\\n                if (isSafe(rows , cols , rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n\\n            // d -> u\\n            p = move;\\n            while (p--)\\n            {\\n                rStart--;\\n                if (isSafe(rows , cols, rStart, cStart))\\n                {\\n                    ans.push_back(vector<int>{rStart, cStart});\\n                    num++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942077,
                "title": "python",
                "content": "\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        i, j = rStart, cStart\\n        coordinates = [[rStart,cStart]]\\n        \\n        step, sign = 1, 1\\n        \\n        while len(coordinates) < rows*cols:\\n            for _ in range(step):\\n                j += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            for _ in range(step):\\n                i += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            step += 1\\n            sign *= -1\\n    \\n        return coordinates",
                "solutionTags": [],
                "code": "\\n    def spiralMatrixIII(self, rows, cols, rStart, cStart):\\n        i, j = rStart, cStart\\n        coordinates = [[rStart,cStart]]\\n        \\n        step, sign = 1, 1\\n        \\n        while len(coordinates) < rows*cols:\\n            for _ in range(step):\\n                j += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            for _ in range(step):\\n                i += sign\\n                if 0 <= i < rows and 0 <= j < cols:\\n                    coordinates.append([i,j])\\n                    \\n            step += 1\\n            sign *= -1\\n    \\n        return coordinates",
                "codeTag": "Python3"
            },
            {
                "id": 1760359,
                "title": "java-simple-code-faster-than-99-47",
                "content": "\\n\\n```\\nclass Solution {\\n      int size = 0;\\n      int[][] mat;\\n    \\n     public void add(int r, int c, int rows, int cols) {\\n            \\n            //Check out of bound condition , if it is out of bound , don\\'t do anything\\n            //just return it\\n            \\n            if(r>=rows || r<0 || c>=cols || c<0) {\\n                return;\\n            }\\n            \\n             mat[size][0] = r;\\n             mat[size++][1] = c;        //size is increaed for next trip or iteration\\n     }\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\n /*     \\nThere are rows X cols elements in Matrix , and each of that element we have to\\ntraverse in clockwise spiral i.e Jalebi , and we need to print co-ordinates of each\\nelement , so we need rows = rows X cols and in each 1D Array , there are two indices\\nonly i.e (row , col) , so we need cols = 2\\n*/    \\n \\n        mat = new int[rows * cols][2];\\n        \\n        int len = 1;\\n        int r = rStart, c = cStart;\\n        \\n        while(size < rows * cols) {\\n            \\n            //Move Right or East , so cols will increase\\n            for(int i=0; i<len; i++) {\\n                add(r, c++,  rows , cols);\\n            }\\n            \\n            //Move Down or South , so rows will increase\\n            for(int i=0; i<len; i++) {\\n                add(r++, c, rows, cols);\\n            }\\n                    len++;  \\n            \\n            //Move Left or West , so cols will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r, c--, rows, cols);\\n            }\\n                    \\n            //Move Up or North , so rows will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r--, c, rows, cols);\\n            }\\n                    len++;\\n        }\\n                    return mat;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n      int size = 0;\\n      int[][] mat;\\n    \\n     public void add(int r, int c, int rows, int cols) {\\n            \\n            //Check out of bound condition , if it is out of bound , don\\'t do anything\\n            //just return it\\n            \\n            if(r>=rows || r<0 || c>=cols || c<0) {\\n                return;\\n            }\\n            \\n             mat[size][0] = r;\\n             mat[size++][1] = c;        //size is increaed for next trip or iteration\\n     }\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\n /*     \\nThere are rows X cols elements in Matrix , and each of that element we have to\\ntraverse in clockwise spiral i.e Jalebi , and we need to print co-ordinates of each\\nelement , so we need rows = rows X cols and in each 1D Array , there are two indices\\nonly i.e (row , col) , so we need cols = 2\\n*/    \\n \\n        mat = new int[rows * cols][2];\\n        \\n        int len = 1;\\n        int r = rStart, c = cStart;\\n        \\n        while(size < rows * cols) {\\n            \\n            //Move Right or East , so cols will increase\\n            for(int i=0; i<len; i++) {\\n                add(r, c++,  rows , cols);\\n            }\\n            \\n            //Move Down or South , so rows will increase\\n            for(int i=0; i<len; i++) {\\n                add(r++, c, rows, cols);\\n            }\\n                    len++;  \\n            \\n            //Move Left or West , so cols will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r, c--, rows, cols);\\n            }\\n                    \\n            //Move Up or North , so rows will decrease\\n            for(int i=0; i<len; i++) {\\n                add(r--, c, rows, cols);\\n            }\\n                    len++;\\n        }\\n                    return mat;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731664,
                "title": "java-easy-solution-with-explaintation",
                "content": "\\n      class Solution{\\n      public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        //first we need an 2D array to store all the indices\\n        //of rows = r*c and columns = 2 .\\n        int[][] res = new int[rows*cols][2];\\n        \\n        //edge case\\n        int size = rows*cols ; \\n     \\n\\t   //since initial positions index is given \\n        res[0] = new int[]{ rStart , cStart};\\n        if(size == 1) { return res ; }\\n        \\n        //we need an another array which change row and col values\\n        //so that we can move in spiral order.\\n        int[][] dir = { {0,1} , {1,0} , {0,-1} , {-1,0} };\\n        //now why I took these specific values in my dir array\\n        //bcoz if you notice the given examples , You will see a\\n        //pattern.\\n        //First we go east column increases & row remains constant so {0,1}\\n        //Second we go south row increases & column remains constant so {1,0}\\n        //Third we go west column decreases & row remains constant so {0,-1}\\n        //Fourth we go north row decreases & column remains constant so{-1,0}\\n        \\n        //now since we are moving in 4 directions so after a complete\\n        //revolution we need do reset direction to east \\n        //or we can say reset dir arr to its begining.\\n        int d = 0 ; // this variable gonna help us in his task.\\n        int len = 0; // this will decide how much length to go in a direction\\n        \\n       \\n        int count = 1 ; // this will be our counter var to break the loop\\n        // we put 1 element in res thats why count = 1.\\n        \\n        //now a loop to get all other indices in spiral manner\\n        \\n        while(count<rows*cols)\\n        {\\n            if(d==0||d==2) { len++ ; } //1,1,2,2,3,3,4,4\\n            //Above condition will helps in achieving the repeating sequence\\n            \\n            for(int i=0;i<len;i++)\\n            {\\n                rStart = rStart + dir[d][0]; //increase or decrease row\\n                cStart = cStart + dir[d][1]; //increase or decrease column\\n                \\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    //Above condition will check if the row & col values\\n                    //are in the given matrix or not. If true then we will\\n                    //add them in our result array.\\n                    res[count++] = new int[]{ rStart , cStart };\\n                }\\n            }\\n            //we have to change values of d in order to change the diection\\n            \\n            d = ( d+1 ) % 4 ; // this will reset the value to 0 after a revolution.                                                           \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution{\\n      public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        //first we need an 2D array to store all the indices\\n        //of rows = r*c and columns = 2 .\\n        int[][] res = new int[rows*cols][2];\\n        \\n        //edge case\\n        int size = rows*cols ; \\n     \\n\\t   //since initial positions index is given \\n        res[0] = new int[]{ rStart , cStart}",
                "codeTag": "Java"
            },
            {
                "id": 1696940,
                "title": "java-solution-easy",
                "content": "```class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] ans = new int[rows*cols][2];\\n        \\n        int t = rStart;\\n        int d = t+1;\\n        int l = cStart;\\n        int r = l+1;\\n        int i = 0;\\n        int j = 0;\\n        \\n        ans[i][j++] = rStart;\\n        ans[i++][j] = cStart;\\n        j = 0;\\n        \\n        while((i<(rows*cols)) && j<2){\\n            \\n            for(int a = l+1; a<=r && i<(rows*cols); a++){\\n                if(a<cols && t>=0 && a>=0){\\n                    ans[i][j++] = t;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            l--;\\n            \\n            for(int a = t+1; a<=d && i<(rows*cols); a++){\\n                if(a<rows && r<cols && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = r;\\n                    j=0;\\n                }\\n            }\\n            t--;\\n            \\n            for(int a = r-1; a>=l && i<(rows*cols); a--){\\n                if(a<cols && d<rows && a>=0){\\n                    ans[i][j++] = d;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            r++;\\n            \\n            for(int a = d-1; a>=t && i<(rows*cols); a--){\\n                if(a<rows && l>=0 && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = l;\\n                    j=0;\\n                }\\n            }\\n            d++;\\n        }\\n        return ans;\\n    }\\n}```\\n\\nThere are four for loops for 4 movements  and the if condition take care that ans contains correct numbers for rows and collumn",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] ans = new int[rows*cols][2];\\n        \\n        int t = rStart;\\n        int d = t+1;\\n        int l = cStart;\\n        int r = l+1;\\n        int i = 0;\\n        int j = 0;\\n        \\n        ans[i][j++] = rStart;\\n        ans[i++][j] = cStart;\\n        j = 0;\\n        \\n        while((i<(rows*cols)) && j<2){\\n            \\n            for(int a = l+1; a<=r && i<(rows*cols); a++){\\n                if(a<cols && t>=0 && a>=0){\\n                    ans[i][j++] = t;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            l--;\\n            \\n            for(int a = t+1; a<=d && i<(rows*cols); a++){\\n                if(a<rows && r<cols && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = r;\\n                    j=0;\\n                }\\n            }\\n            t--;\\n            \\n            for(int a = r-1; a>=l && i<(rows*cols); a--){\\n                if(a<cols && d<rows && a>=0){\\n                    ans[i][j++] = d;\\n                    ans[i++][j] = a;\\n                    j=0;\\n                }\\n            }\\n            r++;\\n            \\n            for(int a = d-1; a>=t && i<(rows*cols); a--){\\n                if(a<rows && l>=0 && a>=0){\\n                    ans[i][j++] = a;\\n                    ans[i++][j] = l;\\n                    j=0;\\n                }\\n            }\\n            d++;\\n        }\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1594604,
                "title": "c-98-4-solution",
                "content": "```\\n/*\\nRuntime: 8 ms, faster than 98.40% of C++ online submissions for Spiral Matrix III.\\nMemory Usage: 12.2 MB, less than 62.57% of C++ online submissions for Spiral Matrix III.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(const int rows, \\n                                        const int cols, \\n                                        const int rStart, \\n                                        const int cStart) \\n    {        \\n        const int SIZE = rows * cols;\\n        \\n        if ( 0 == SIZE ) return {};\\n        if ( 1 == SIZE ) \\n        {\\n            return { {0, 0} };\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        int count = 1;\\n        int r = rStart;\\n        int c = cStart;\\n        int step = 2;\\n        ans.push_back( {r, c} );\\n        \\n        while (1)\\n        {\\n            for ( int i = c; i < c+step; i++ )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += step-1;\\n            \\n            for ( int i = r; i < r+step; i++ )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += step-1;\\n            step++;\\n            \\n            for ( int i = c; i > c-step; i-- )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += 1-step;\\n            \\n            for ( int i = r; i > r-step; i-- )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += 1-step;\\n            step++;\\n        }\\n                \\n        return ans;      \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 8 ms, faster than 98.40% of C++ online submissions for Spiral Matrix III.\\nMemory Usage: 12.2 MB, less than 62.57% of C++ online submissions for Spiral Matrix III.\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(const int rows, \\n                                        const int cols, \\n                                        const int rStart, \\n                                        const int cStart) \\n    {        \\n        const int SIZE = rows * cols;\\n        \\n        if ( 0 == SIZE ) return {};\\n        if ( 1 == SIZE ) \\n        {\\n            return { {0, 0} };\\n        }\\n        \\n        vector<vector<int>> ans;\\n        \\n        int count = 1;\\n        int r = rStart;\\n        int c = cStart;\\n        int step = 2;\\n        ans.push_back( {r, c} );\\n        \\n        while (1)\\n        {\\n            for ( int i = c; i < c+step; i++ )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += step-1;\\n            \\n            for ( int i = r; i < r+step; i++ )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += step-1;\\n            step++;\\n            \\n            for ( int i = c; i > c-step; i-- )\\n            {\\n                if (  0 <= i && i < cols \\n                   && 0 <= r && r < rows )\\n                {\\n                    if ( i==c ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {r, i} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            c += 1-step;\\n            \\n            for ( int i = r; i > r-step; i-- )\\n            {\\n                if (  0 <= i && i < rows \\n                   && 0 <= c && c < cols )\\n                {\\n                    if ( i==r ) continue;\\n                    else\\n                    {\\n                        ans.push_back( {i, c} );\\n                        count++;\\n                    }\\n                }\\n            }\\n            \\n            if ( count >= SIZE ) break;\\n            r += 1-step;\\n            step++;\\n        }\\n                \\n        return ans;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365212,
                "title": "to-practice-the-recursion",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\t\\t// int[][] arr = new int[rows][cols];\\n\\t\\t\\t// arr[rStart][cStart] = 1;\\n\\t\\t\\tint[][] ans = new int[rows * cols][2];\\n\\t\\t\\tif (rows == 1 && cols == 1) return ans;\\n        \\n\\t\\t\\tint[] writer = new int[1];\\n\\t\\t\\tans[0][0] = rStart;\\n\\t\\t\\tans[0][1] = cStart;        \\n\\t\\t\\twriter[0] = 2;\\n\\t\\t\\tspiralMatrixIII(ans, 3, 0, rows, cols, rStart, cStart, writer);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n    \\n\\t\\tprivate void spiralMatrixIII(int[][] ans, int size, int offset, int rows, int cols, int rStart, int cStart, int[] writer) {\\n\\t\\t\\tif ((rStart + offset >= rows) && (rStart - offset < 0) && (cStart + offset >= cols) && (cStart - offset < 0)) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\t// right\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart - offset + i <= rows - 1) && (cStart + 1 + offset <= cols - 1) && (rStart - offset + i >= 0) && (cStart + 1 + offset >=0)){\\n\\t\\t\\t\\t\\t// arr[rStart - offset + i][cStart + 1 + offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - offset + i;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart + 1 + offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} \\n        \\n\\t\\t\\t// bottom\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart + 1 + offset <= rows - 1) && (cStart - i + offset <= cols - 1) && (rStart + 1 + offset >= 0) && (cStart - i + offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart + 1 + offset][cStart - i + offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart + 1 + offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart - i + offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// left\\n\\t\\t\\tfor (int i = 0; i < size - 1; i ++) {\\n\\t\\t\\t\\tif ((rStart - i + offset <= rows - 1) && (cStart - 1 - offset <= cols - 1) && (rStart - i + offset >= 0) && (cStart - 1 - offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart - i + offset][cStart - 1 - offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++; \\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - i + offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart - 1 - offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        \\n\\t\\t\\t// top\\n\\t\\t\\tfor (int i = 0; i < size - 1; i++) {\\n\\t\\t\\t\\tif ((rStart - 1 - offset <= rows - 1) && (cStart + i - offset <= cols - 1) && (rStart - 1 - offset >= 0) && (cStart + i - offset >= 0)){\\n\\t\\t\\t\\t\\t// arr[rStart - 1 - offset][cStart + i - offset] = writer[0];\\n\\t\\t\\t\\t\\twriter[0]++;  \\n\\t\\t\\t\\t\\tans[writer[0] - 2][0] = rStart - 1 - offset;\\n\\t\\t\\t\\t\\tans[writer[0] - 2][1] = cStart + i - offset;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tspiralMatrixIII(ans, size + 2, offset + 1, rows, cols, rStart, cStart, writer);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\t\\t\\t// int[][] arr = new int[rows][cols];\\n\\t\\t\\t// arr[rStart][cStart] = 1;\\n\\t\\t\\tint[][] ans = new int[rows * cols][2];\\n\\t\\t\\tif (rows == 1 && cols == 1) return ans;\\n        \\n\\t\\t\\tint[] writer = new int[1];\\n\\t\\t\\tans[0][0] = rStart;\\n\\t\\t\\tans[0][1] = cStart;        \\n\\t\\t\\twriter[0] = 2;\\n\\t\\t\\tspiralMatrixIII(ans, 3, 0, rows, cols, rStart, cStart, writer);\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1285754,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        i ,j = rStart, cStart\\n        inc = 1\\n        ans = [[rStart, cStart]]\\n        while len(ans) < rows*cols:\\n            if inc % 2 == 0:\\n                c = inc * -1\\n            else:\\n                c = inc\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    j -= 1\\n                else:\\n                    j += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    i -= 1\\n                else:\\n                    i += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            inc += 1\\n        return ans\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        i ,j = rStart, cStart\\n        inc = 1\\n        ans = [[rStart, cStart]]\\n        while len(ans) < rows*cols:\\n            if inc % 2 == 0:\\n                c = inc * -1\\n            else:\\n                c = inc\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    j -= 1\\n                else:\\n                    j += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            z = abs(c)\\n            while z > 0:\\n                if c < 0:\\n                    i -= 1\\n                else:\\n                    i += 1\\n                if i in range(0, rows) and j in range(0, cols):\\n                    ans.append([i, j])\\n                z -= 1\\n            inc += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218501,
                "title": "java-iterative-approach-clear-code",
                "content": "Here\\'s a clear iterative code in Java, keep expanding to higher square as done with up, down, then expand col then expand row.\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        List<int[]> l = new ArrayList<>();\\n        int rowStart = rStart, rowEnd = rStart+1;\\n        int colStart = cStart, colEnd = cStart+1;\\n        while (l.size() != n) {\\n            for (int j = colStart; j <= colEnd; j++) {\\n                if (isValid(rowStart, j, rows, cols)) {\\n                    l.add(new int[]{rowStart, j});\\n                }\\n            }\\n            for (int i = rowStart+1; i <= rowEnd; i++) {\\n                if (isValid(i, colEnd, rows, cols)) {\\n                    l.add(new int[]{i, colEnd});\\n                }\\n            }\\n            for (int j = colEnd-1; j >= colStart-1; j--) {\\n                if (isValid(rowEnd, j, rows, cols)) {\\n                    l.add(new int[]{rowEnd, j});\\n                }\\n            }\\n            for (int i = rowEnd-1; i >= rowStart; i--) {\\n                if (isValid(i, colStart-1, rows, cols)) {\\n                    l.add(new int[]{i, colStart-1});\\n                }\\n            }\\n            rowStart--;\\n            colStart--;\\n            rowEnd++;\\n            colEnd++;\\n        }\\n        int[][] res = new int[l.size()][];\\n        for (int i = 0; i < l.size(); i++) {\\n            res[i] = l.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int i, int j, int rows, int cols) {\\n        return (i >= 0 && i < rows && j >= 0 && j < cols);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        List<int[]> l = new ArrayList<>();\\n        int rowStart = rStart, rowEnd = rStart+1;\\n        int colStart = cStart, colEnd = cStart+1;\\n        while (l.size() != n) {\\n            for (int j = colStart; j <= colEnd; j++) {\\n                if (isValid(rowStart, j, rows, cols)) {\\n                    l.add(new int[]{rowStart, j});\\n                }\\n            }\\n            for (int i = rowStart+1; i <= rowEnd; i++) {\\n                if (isValid(i, colEnd, rows, cols)) {\\n                    l.add(new int[]{i, colEnd});\\n                }\\n            }\\n            for (int j = colEnd-1; j >= colStart-1; j--) {\\n                if (isValid(rowEnd, j, rows, cols)) {\\n                    l.add(new int[]{rowEnd, j});\\n                }\\n            }\\n            for (int i = rowEnd-1; i >= rowStart; i--) {\\n                if (isValid(i, colStart-1, rows, cols)) {\\n                    l.add(new int[]{i, colStart-1});\\n                }\\n            }\\n            rowStart--;\\n            colStart--;\\n            rowEnd++;\\n            colEnd++;\\n        }\\n        int[][] res = new int[l.size()][];\\n        for (int i = 0; i < l.size(); i++) {\\n            res[i] = l.get(i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean isValid(int i, int j, int rows, int cols) {\\n        return (i >= 0 && i < rows && j >= 0 && j < cols);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979712,
                "title": "python-solution-faster-than-96",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = [[r0, c0]]\\n        c_r, c_c = r0, c0  # current row, current column\\n        s, d = 1, 1  # step, direction\\n\\n        while len(res) < R * C:\\n            for _ in range(s):\\n                c_c = c_c + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            for _ in range(s):\\n                c_r = c_r + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            s += 1\\n            d *= -1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = [[r0, c0]]\\n        c_r, c_c = r0, c0  # current row, current column\\n        s, d = 1, 1  # step, direction\\n\\n        while len(res) < R * C:\\n            for _ in range(s):\\n                c_c = c_c + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            for _ in range(s):\\n                c_r = c_r + 1 * d\\n                if 0 <= c_r < R and 0 <= c_c < C:\\n                    res.append([c_r, c_c])\\n\\n            s += 1\\n            d *= -1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866874,
                "title": "java-very-simple-concise-and-fast",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R*C][2];\\n        \\n        int direction=0;//{0,1,2,3};\\n        int index=0;\\n        int r=r0, c=c0;\\n        int step=0, size=1;\\n        \\n        while(index < R*C){\\n            if(r>=0 && r<=R-1 && c>=0 && c<=C-1){\\n                result[index][0]=r;\\n                result[index][1]=c;\\n                index++;\\n            }\\n\\n            if(direction==0){\\n                c++;\\n            }else if(direction==1)\\n                r++;\\n            else if(direction==2){\\n                c--;\\n            }else if(direction==3)\\n                r--;\\n            \\n            step++; //steps taken on a same direction\\n            if(step == size){\\n                direction= (direction+1) %4;\\n                //only on east and west we increase size.\\n                if(direction==0 || direction ==2)\\n                    size++;\\n                step=0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R*C][2];\\n        \\n        int direction=0;//{0,1,2,3};\\n        int index=0;\\n        int r=r0, c=c0;\\n        int step=0, size=1;\\n        \\n        while(index < R*C){\\n            if(r>=0 && r<=R-1 && c>=0 && c<=C-1){\\n                result[index][0]=r;\\n                result[index][1]=c;\\n                index++;\\n            }\\n\\n            if(direction==0){\\n                c++;\\n            }else if(direction==1)\\n                r++;\\n            else if(direction==2){\\n                c--;\\n            }else if(direction==3)\\n                r--;\\n            \\n            step++; //steps taken on a same direction\\n            if(step == size){\\n                direction= (direction+1) %4;\\n                //only on east and west we increase size.\\n                if(direction==0 || direction ==2)\\n                    size++;\\n                step=0;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848527,
                "title": "95-runtime-50-space-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int cnt = 2;\\n        int inc = 1;\\n        vector<vector<int>> fi;\\n        fi.push_back({r0, c0});\\n        while(cnt <= R*C){\\n            for(int i = c0+1; i <= c0 + inc && i < C && (r0 >= 0 && r0 < R); i++){\\n                if(i >= 0){\\n                    cnt++;\\n                    fi.push_back({r0, i});\\n                } \\n\\n            }\\n            c0 = c0+inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            \\n            for(int i = r0+1; i <= r0+ inc && i < R && (c0 >= 0 && c0 < C); i++){\\n                if(i >= 0){\\n                    cnt++;\\n                    fi.push_back({i, c0});\\n                }\\n            }\\n            r0 = r0 + inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            inc++;\\n            for(int i = c0-1; i >= c0 - inc && i>= 0 && (r0 >= 0 && r0 < R); i--){\\n                if(i < C){\\n                    cnt++;\\n                    fi.push_back({r0, i});\\n                }\\n            }\\n            c0 = c0-inc;\\n            if(cnt>R*C){\\n                break;\\n            }\\n            for(int i = r0-1; i >= r0 - inc && i >= 0 && (c0 >= 0 && c0 < C); i--){\\n                if(i < R) {\\n                    cnt++;\\n                    fi.push_back({i, c0});\\n                }     \\n            }\\n            r0 = r0-inc;\\n            if(cnt > R*C){\\n                break;\\n            }\\n            inc++;\\n        }\\n        return fi;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int cnt = 2;\\n        int inc = 1;\\n        vector<vector<int>> fi;\\n        fi.push_back({r0, c0}",
                "codeTag": "Java"
            },
            {
                "id": 834247,
                "title": "a-python-concise-solution-for-generic-these-problem",
                "content": "`direction` is a generator for right, down, left, up loop. If the direction is horizontal, step + 1.\\n```python\\ndef spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n    ans = [(r0, c0)]\\n    step = 0\\n    while len(ans) < R*C:\\n        di, dj = next(direction)        \\n        if di==0:\\n            step += 1\\n        for _ in range(step):\\n            r0 += di\\n            c0 += dj\\n            if 0<=r0<R and 0<=c0<C:\\n                ans.append((r0, c0))\\n    return ans\\n```",
                "solutionTags": [],
                "code": "```python\\ndef spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n    direction = itertools.cycle([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n    ans = [(r0, c0)]\\n    step = 0\\n    while len(ans) < R*C:\\n        di, dj = next(direction)        \\n        if di==0:\\n            step += 1\\n        for _ in range(step):\\n            r0 += di\\n            c0 += dj\\n            if 0<=r0<R and 0<=c0<C:\\n                ans.append((r0, c0))\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 812777,
                "title": "python-easy-simple-solution-91-faster",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        ans = []\\n        len_row, len_col = 0, 2\\n        start_row, start_col= r0, c0\\n        direction = 1\\n        cnt = 0\\n\\n        while cnt < R * C:\\n            curr_row, curr_col = start_row, start_col\\n            for c in range(len_col):\\n                curr_col = start_col + c * direction\\n                if 0 <= start_row < R and 0 <= curr_col < C:\\n                    ans.append([start_row, curr_col])\\n                    cnt += 1\\n\\t\\t\\t\\t\\t\\n            start_col = curr_col\\n            start_row += direction\\n\\n            for r in range(len_row):\\n                curr_row = start_row + r * direction\\n                if 0 <= curr_row < R and 0 <= start_col < C:\\n                    ans.append([curr_row, start_col])\\n                    cnt += 1\\n\\n            len_row += 1\\n            len_col += 1\\n            start_row = curr_row\\n            start_row += direction\\n            direction *= -1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        ans = []\\n        len_row, len_col = 0, 2\\n        start_row, start_col= r0, c0\\n        direction = 1\\n        cnt = 0\\n\\n        while cnt < R * C:\\n            curr_row, curr_col = start_row, start_col\\n            for c in range(len_col):\\n                curr_col = start_col + c * direction\\n                if 0 <= start_row < R and 0 <= curr_col < C:\\n                    ans.append([start_row, curr_col])\\n                    cnt += 1\\n\\t\\t\\t\\t\\t\\n            start_col = curr_col\\n            start_row += direction\\n\\n            for r in range(len_row):\\n                curr_row = start_row + r * direction\\n                if 0 <= curr_row < R and 0 <= start_col < C:\\n                    ans.append([curr_row, start_col])\\n                    cnt += 1\\n\\n            len_row += 1\\n            len_col += 1\\n            start_row = curr_row\\n            start_row += direction\\n            direction *= -1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812019,
                "title": "python-beats-100-simple-solution-with-explanation",
                "content": "**Explanation**\\nThe basic idea behind this question is to increment the number of cells traversed after every column and row operation. So if we can perform these two operations and increment the number of cells it needs to traverse next, we simply reach the solution. \\nIn this solution, I have checked if the number of steps required is odd or even. In case of odd, we need to increase the indices by 1 and decrease by 1 in case of even, i.e., go right or south in case of odd steps and west or north in case of even steps. \\n\\n**Hope this helps!**\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        out = [[r0,c0]]\\n        steps = 1\\n        \\n        while len(out) == R*C:\\n            rowS = colS = steps\\n            if rowS % 2 == 0:\\n                x = True\\n            else:\\n                x = False\\n                \\n            while colS != 0:\\n                if not x:\\n                    c0 += 1\\n                else:\\n                    c0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                colS -= 1\\n                \\n            while rowS != 0:\\n                if not x:\\n                    r0 += 1\\n                else:\\n                    r0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                rowS -= 1\\n            \\n            steps += 1\\n            \\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        out = [[r0,c0]]\\n        steps = 1\\n        \\n        while len(out) == R*C:\\n            rowS = colS = steps\\n            if rowS % 2 == 0:\\n                x = True\\n            else:\\n                x = False\\n                \\n            while colS != 0:\\n                if not x:\\n                    c0 += 1\\n                else:\\n                    c0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                colS -= 1\\n                \\n            while rowS != 0:\\n                if not x:\\n                    r0 += 1\\n                else:\\n                    r0 -= 1\\n                if 0 <= c0 < C and 0 <= r0 < R:\\n                    out.append([r0,c0])\\n                rowS -= 1\\n            \\n            steps += 1\\n            \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710300,
                "title": "simple-and-concise-c-solution",
                "content": "<iframe src=\"https://leetcode.com/playground/3psR9eMH/shared\" frameBorder=\"0\" width=\"600\" height=\"650\"></iframe>",
                "solutionTags": [],
                "code": "<iframe src=\"https://leetcode.com/playground/3psR9eMH/shared\" frameBorder=\"0\" width=\"600\" height=\"650\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 633901,
                "title": "simpleish-js",
                "content": "```\\n\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    var totalTile = R * C\\n    var amount    = 1\\n    var output    = [[ r0, c0 ]]\\n    var place     = [ r0, c0 ]\\n    var direction = directions[0]\\n    \\n    while ( output.length < totalTile ) {\\n        walk( place, amount | 0, direction, output, R, C )\\n        amount += .5\\n        direction = directions[ ( directions.indexOf( direction ) + 1 ) % 4 ]\\n    }\\n    \\n    return output\\n}\\n\\nconst directions = [\\n    [ 0, 1 ], // east\\n    [ 1, 0 ], // south\\n    [ 0, -1 ], // west\\n    [ -1, 0 ], // north\\n]\\n    \\nconst walk = ( place, amount, direction, output, R, C ) => {\\n    while ( amount ) {\\n        place[0] += direction[0]\\n        place[1] += direction[1]\\n\\n        if ( isInGrid( place[0], place[1], R, C ) )\\n            output.push([ place[0], place[1] ])\\n        \\n        amount--\\n    }\\n}\\n\\nconst isInGrid = ( r, c, R, C ) => 0 <= r && 0 <= c && r < R && c < C\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    var totalTile = R * C\\n    var amount    = 1\\n    var output    = [[ r0, c0 ]]\\n    var place     = [ r0, c0 ]\\n    var direction = directions[0]\\n    \\n    while ( output.length < totalTile ) {\\n        walk( place, amount | 0, direction, output, R, C )\\n        amount += .5\\n        direction = directions[ ( directions.indexOf( direction ) + 1 ) % 4 ]\\n    }\\n    \\n    return output\\n}\\n\\nconst directions = [\\n    [ 0, 1 ], // east\\n    [ 1, 0 ], // south\\n    [ 0, -1 ], // west\\n    [ -1, 0 ], // north\\n]\\n    \\nconst walk = ( place, amount, direction, output, R, C ) => {\\n    while ( amount ) {\\n        place[0] += direction[0]\\n        place[1] += direction[1]\\n\\n        if ( isInGrid( place[0], place[1], R, C ) )\\n            output.push([ place[0], place[1] ])\\n        \\n        amount--\\n    }\\n}\\n\\nconst isInGrid = ( r, c, R, C ) => 0 <= r && 0 <= c && r < R && c < C\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584440,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        target = R * C\\n        \\n        def in_matrix():\\n            if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                return True \\n            return False\\n        while len(res) < target:\\n            i += 1\\n            #move right\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 += 1\\n            \\n            #move down\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 += 1\\n            \\n            i += 1\\n            \\n            #move Left\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 -= 1\\n                \\n            #move up\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 -= 1\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        res = []\\n        i = 0\\n        target = R * C\\n        \\n        def in_matrix():\\n            if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                return True \\n            return False\\n        while len(res) < target:\\n            i += 1\\n            #move right\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 += 1\\n            \\n            #move down\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 += 1\\n            \\n            i += 1\\n            \\n            #move Left\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                c0 -= 1\\n                \\n            #move up\\n            for _ in range(i):\\n                if in_matrix():\\n                    res.append([r0, c0])\\n                r0 -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 513543,
                "title": "simple-java-solution",
                "content": "```java\\nclass Solution {\\n    \\n    int[] dr = new int[] { 0, 1, 0, -1 };\\n    int[] dc = new int[] { 1, 0, -1, 0 };\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int x = r0, y = c0;\\n        \\n        int[][] res = new int[R*C][2];\\n        res[0][0] = r0;\\n        res[0][1] = c0;\\n\\n        int count = 1;\\n        int size = 1;\\n        \\n        int dir = 0;\\n        \\n        while (count < R * C) {\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;;\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;\\n            size++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    int[] dr = new int[] { 0, 1, 0, -1 };\\n    int[] dc = new int[] { 1, 0, -1, 0 };\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        \\n        int x = r0, y = c0;\\n        \\n        int[][] res = new int[R*C][2];\\n        res[0][0] = r0;\\n        res[0][1] = c0;\\n\\n        int count = 1;\\n        int size = 1;\\n        \\n        int dir = 0;\\n        \\n        while (count < R * C) {\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;;\\n            \\n            for (int i = 0; i < size; i++) {\\n                x = x + dr[dir];\\n                y = y + dc[dir];\\n\\n                if (0 <= x && x < R && 0 <= y && y < C) {\\n                    res[count][0] = x;\\n                    res[count][1] = y;\\n                    count++;\\n                }\\n            }\\n            \\n            dir = (dir + 1) % 4;\\n            size++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501338,
                "title": "python-detailed-explanation-easy-to-understand",
                "content": "Let\\'s assume the board is infinite (then we don\\'t need to care about the case of moving out of boundary, we can add restrictions back later), if the current position is ```(i,j)```, the moves are:\\n```\\ni,j\\ni,j-1\\ni+1,j+1\\ni+1,j\\ni+1,j-1\\ni,j-1\\ni-1,j-1\\n------ (first round ends)\\ni-1,j\\ni-1,j+1\\ni-1,j+2\\ni,j+2\\ni-1,j+2\\n...\\n```\\nLet\\'s make a cut each time when we move to ```(i-k, j-k), k=1,2,3...``` and call it a round, then we\\'ll find the following pattern in each round(```R``` means ```move right```, ```L``` means ```move left```, ```U``` means ```move up```, ```D``` means ```move down```):\\n```\\nfirst round: RDLLUUR\\nsecond round: RRDDDLLLLUUUURR\\nthird round: RRRDDDDDLLLLLLUUUUUURRR\\n```\\nAs you can see:\\nthe number of R: 1 2 3......\\nthe number of D: 1 3 5......\\nthe number of L:  2 4 6......\\nthe number of U: 2 4 6......\\nthe number of R: 1 2 3......\\nThe pattern is quite clear now, from the above observation, we can use 5 counters to count RDLUR, and update positions in five for-loops, update rules:\\n```\\ncnt1+=1\\ncnt2+=2\\ncnt3+=2\\ncnt4+=2\\ncnt5+=1\\n```\\nbecause so far our board is infinite, now we also need to consider the restriction for a legal step, it\\'s simple:\\n```\\n0 <= cur_x < R and 0 <= cur_y < C\\n```\\nBased on the code above, we have the code below:\\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        def isGood(x, y):\\n            return 0 <= x < R and 0 <= y < C\\n        \\n        ans = [[r0, c0]]\\n        cnt1 = 1  # R\\n        cnt2 = 1  # D\\n        cnt3 = 2  # L\\n        cnt4 = 2  # U\\n        cnt5 = 1  # R\\n        nx, ny = r0, c0\\n        while len(ans) != R*C:\\n            for i in range(cnt1):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt2):\\n                nx, ny = nx+1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt3):\\n                nx, ny = nx, ny-1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt4):\\n                nx, ny = nx-1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt5):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            cnt1+=1\\n            cnt2+=2\\n            cnt3+=2\\n            cnt4+=2\\n            cnt5+=1\\n            \\n        return ans\\n```\\nNot elegant, but easy enough to understand.",
                "solutionTags": [],
                "code": "```(i,j)```\n```\\ni,j\\ni,j-1\\ni+1,j+1\\ni+1,j\\ni+1,j-1\\ni,j-1\\ni-1,j-1\\n------ (first round ends)\\ni-1,j\\ni-1,j+1\\ni-1,j+2\\ni,j+2\\ni-1,j+2\\n...\\n```\n```(i-k, j-k), k=1,2,3...```\n```R```\n```move right```\n```L```\n```move left```\n```U```\n```move up```\n```D```\n```move down```\n```\\nfirst round: RDLLUUR\\nsecond round: RRDDDLLLLUUUURR\\nthird round: RRRDDDDDLLLLLLUUUUUURRR\\n```\n```\\ncnt1+=1\\ncnt2+=2\\ncnt3+=2\\ncnt4+=2\\ncnt5+=1\\n```\n```\\n0 <= cur_x < R and 0 <= cur_y < C\\n```\n```\\nclass Solution(object):\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        def isGood(x, y):\\n            return 0 <= x < R and 0 <= y < C\\n        \\n        ans = [[r0, c0]]\\n        cnt1 = 1  # R\\n        cnt2 = 1  # D\\n        cnt3 = 2  # L\\n        cnt4 = 2  # U\\n        cnt5 = 1  # R\\n        nx, ny = r0, c0\\n        while len(ans) != R*C:\\n            for i in range(cnt1):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt2):\\n                nx, ny = nx+1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt3):\\n                nx, ny = nx, ny-1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt4):\\n                nx, ny = nx-1, ny\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            for i in range(cnt5):\\n                nx, ny = nx, ny+1\\n                if isGood(nx, ny):\\n                    ans.append([nx, ny])\\n            cnt1+=1\\n            cnt2+=2\\n            cnt3+=2\\n            cnt4+=2\\n            cnt5+=1\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479084,
                "title": "python-concise-solution-beats-100-run-time-and-memory",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        out=[[r0,c0]]\\n        rn,cn=r0,c0\\n        step=1\\n        while len(out)!=R*C:                \\n            direction = ((-1)**(step-1))\\n            if rn<R and rn>-1:             \\n                for c in range(step): \\n                    cn += direction \\n                    if cn<C and cn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                cn+= direction*step\\n            if cn<C and cn>-1:              \\n                for c in range(step):\\n                    rn += direction\\n                    if rn<R and rn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                rn += direction*step\\n            step+=1\\n        return out \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:\\n        out=[[r0,c0]]\\n        rn,cn=r0,c0\\n        step=1\\n        while len(out)!=R*C:                \\n            direction = ((-1)**(step-1))\\n            if rn<R and rn>-1:             \\n                for c in range(step): \\n                    cn += direction \\n                    if cn<C and cn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                cn+= direction*step\\n            if cn<C and cn>-1:              \\n                for c in range(step):\\n                    rn += direction\\n                    if rn<R and rn>-1:\\n                        out.append([rn,cn])\\n            else:                          \\n                rn += direction*step\\n            step+=1\\n        return out \\n```",
                "codeTag": "Java"
            },
            {
                "id": 384657,
                "title": "java-clean-solution-step-by-step-with-explanation",
                "content": "```\\nclass Solution {\\n    /*  Time Complexity: the worse condition is when the starting point\\n        is in the south-east corner of the grid, which requires the function\\n        to traveal through (2max(R,C)) ^ 2 points thus the TM would be \\n        O((max(R, C)^2)). Space complexity would be O(R*C)*/\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        // direction: right, down, left, up\\n        int[] dirRow = new int[]{0, 1, 0, -1};\\n        int[] dirCol = new int[]{1, 0, -1, 0};\\n        \\n        int[][] result = new int[R*C][2];\\n        result[0] = new int[]{r0, c0};\\n        // use count to keep track of number of nodes that have been found\\n        // use k to keep track of direction and steps\\n        int count = 1, k = 1;\\n        \\n        while (count != R*C) {\\n            // get direction\\n            int dir = (k - 1) % 4;\\n            // get number of steps\\n            int step = k % 2 == 0 ? k / 2 : (k + 1) / 2;\\n            \\n            // move in this direction\\n            for (int i = 0; i < step; i++) {\\n                r0 += dirRow[dir];\\n                c0 += dirCol[dir];\\n                // check for the bound, if within the bound\\n                // then add them into the result array\\n                if (r0 < R && c0 < C && r0 >= 0 && c0 >= 0) {\\n                    result[count] = new int[]{r0, c0};\\n                    count++;\\n                }\\n            }\\n            k++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /*  Time Complexity: the worse condition is when the starting point\\n        is in the south-east corner of the grid, which requires the function\\n        to traveal through (2max(R,C)) ^ 2 points thus the TM would be \\n        O((max(R, C)^2)). Space complexity would be O(R*C)*/\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        // direction: right, down, left, up\\n        int[] dirRow = new int[]{0, 1, 0, -1};\\n        int[] dirCol = new int[]{1, 0, -1, 0};\\n        \\n        int[][] result = new int[R*C][2];\\n        result[0] = new int[]{r0, c0};\\n        // use count to keep track of number of nodes that have been found\\n        // use k to keep track of direction and steps\\n        int count = 1, k = 1;\\n        \\n        while (count != R*C) {\\n            // get direction\\n            int dir = (k - 1) % 4;\\n            // get number of steps\\n            int step = k % 2 == 0 ? k / 2 : (k + 1) / 2;\\n            \\n            // move in this direction\\n            for (int i = 0; i < step; i++) {\\n                r0 += dirRow[dir];\\n                c0 += dirCol[dir];\\n                // check for the bound, if within the bound\\n                // then add them into the result array\\n                if (r0 < R && c0 < C && r0 >= 0 && c0 >= 0) {\\n                    result[count] = new int[]{r0, c0};\\n                    count++;\\n                }\\n            }\\n            k++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383209,
                "title": "simple-java-solution",
                "content": "```\\n    //Steps : 1,1,2,2,3,3,4,4...(increase step by 1 when turn east or west)\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //east, south, west, north\\n        int steps = 0, dir = 0, count = 0;\\n        res[0] = new int[]{x, y};\\n        count++;\\n        while (count < R * C) {\\n            if (dir == 0 || dir == 2)\\n                steps++;\\n            for (int i = 0; i < steps; i++) {\\n                x += dirs[dir][0];\\n                y += dirs[dir][1];\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    res[count++] = new int[]{x, y};\\n                }\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    //Steps : 1,1,2,2,3,3,4,4...(increase step by 1 when turn east or west)\\n    public int[][] spiralMatrixIII(int R, int C, int x, int y) {\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; //east, south, west, north\\n        int steps = 0, dir = 0, count = 0;\\n        res[0] = new int[]{x, y};\\n        count++;\\n        while (count < R * C) {\\n            if (dir == 0 || dir == 2)\\n                steps++;\\n            for (int i = 0; i < steps; i++) {\\n                x += dirs[dir][0];\\n                y += dirs[dir][1];\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    res[count++] = new int[]{x, y};\\n                }\\n            }\\n            dir = (dir + 1) % 4;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 267308,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int R, int C, int r0, int c0) {\\n        var res = new int[R * C][];\\n\\n        int cur = 0, len = 1;\\n\\n        while (cur < R * C)\\n        {\\n            for (var i = c0; i < c0 + len; i++) if (i >= 0 && i < C && r0 >= 0 && r0 < R) res[cur++] = new[] { r0, i };\\n\\n            c0 += len;\\n\\n            for (var i = r0; i < r0 + len; i++) if (c0 < C && c0 >= 0 && i >= 0 && i < R) res[cur++] = new[] { i, c0 };\\n\\n            r0 += len++;\\n\\n            for (var i = c0; i > c0 - len; i--) if (r0 < R && r0 >= 0 && i >= 0 && i < C) res[cur++] = new[] { r0, i };\\n\\n            c0 -= len;\\n\\n            for (var i = r0; i > r0 - len; i--) if (i >= 0 && i < R && c0 >= 0 && c0 < C) res[cur++] = new[] { i, c0 };\\n\\n            r0 -= len++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] SpiralMatrixIII(int R, int C, int r0, int c0) {\\n        var res = new int[R * C][];\\n\\n        int cur = 0, len = 1;\\n\\n        while (cur < R * C)\\n        {\\n            for (var i = c0; i < c0 + len; i++) if (i >= 0 && i < C && r0 >= 0 && r0 < R) res[cur++] = new[] { r0, i };\\n\\n            c0 += len;\\n\\n            for (var i = r0; i < r0 + len; i++) if (c0 < C && c0 >= 0 && i >= 0 && i < R) res[cur++] = new[] { i, c0 };\\n\\n            r0 += len++;\\n\\n            for (var i = c0; i > c0 - len; i--) if (r0 < R && r0 >= 0 && i >= 0 && i < C) res[cur++] = new[] { r0, i };\\n\\n            c0 -= len;\\n\\n            for (var i = r0; i > r0 - len; i--) if (i >= 0 && i < R && c0 >= 0 && c0 < C) res[cur++] = new[] { i, c0 };\\n\\n            r0 -= len++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260748,
                "title": "javascript-solution-with-comments-beats-100",
                "content": "```\\n/**\\n * @param {number} R\\n * @param {number} C\\n * @param {number} r0\\n * @param {number} c0\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    // Set start space.\\n    let r = r0;\\n    let c = c0;\\n    let startSpace = [r, c];\\n    \\n    // Define possible diredctions, start from index = 0.\\n    const directions = [\\'+c\\', \\'+r\\', \\'-c\\', \\'-r\\'];\\n    let directionIndex = 0;\\n    \\n    // Add startSpace to the result array.\\n    const result = [startSpace];\\n    \\n    // Mark the start space as parsed and start from spiral shape with length = 2.\\n    let parsedSpaces = 1;\\n    let spiralLength = 2;\\n    \\n    // Define helper method for setting the next direction.\\n    const changeDirection = () => {\\n        directionIndex = directionIndex + 1 > 3 ? 0 : directionIndex + 1;\\n    }\\n    \\n    // Iterate until all R * C spaces of the grid are parsed.\\n    while (result.length < R * C) {\\n        // Calculate the amount of spaces in the next spiral shape.\\n        const areaOfSpiralShape = spiralLength ** 2;\\n        \\n        // Iterate until all spaces of the current spiral shape are parsed.\\n        while (parsedSpaces <= areaOfSpiralShape) {\\n            const isLastSpace = parsedSpaces === areaOfSpiralShape - 1;\\n            \\n            // 1. Go to the next space by incrementing/decrementing c/r according to direction.\\n            // 2. Check if a wall of the current spiral shape is reached.\\n            // 3. Change direction if the wall is reached.\\n            // 4. Exception: leave the current direction if the last space of spiral is reached.\\n            switch (directions[directionIndex]) {\\n                case \\'+c\\':\\n                    c++;\\n                    if (!isLastSpace && c + 1 >= startSpace[1] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-c\\':\\n                    c--;\\n                    if (!isLastSpace && c - 1 <= startSpace[1] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'+r\\':\\n                    r++;\\n                    if (!isLastSpace && r + 1 >= startSpace[0] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-r\\': \\n                    r--;\\n                    if (!isLastSpace && r - 1 <= startSpace[0] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n            }\\n            \\n            // Add to result in case [r, c] is within R*C grid.\\n            if (c >= 0 && c < C && r >= 0 && r < R) {\\n                result.push([r, c]);\\n            }\\n            parsedSpaces++;\\n        }\\n        \\n        // Set the start space of the next spiral.\\n        startSpace = [r, c];\\n        spiralLength++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} R\\n * @param {number} C\\n * @param {number} r0\\n * @param {number} c0\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(R, C, r0, c0) {\\n    // Set start space.\\n    let r = r0;\\n    let c = c0;\\n    let startSpace = [r, c];\\n    \\n    // Define possible diredctions, start from index = 0.\\n    const directions = [\\'+c\\', \\'+r\\', \\'-c\\', \\'-r\\'];\\n    let directionIndex = 0;\\n    \\n    // Add startSpace to the result array.\\n    const result = [startSpace];\\n    \\n    // Mark the start space as parsed and start from spiral shape with length = 2.\\n    let parsedSpaces = 1;\\n    let spiralLength = 2;\\n    \\n    // Define helper method for setting the next direction.\\n    const changeDirection = () => {\\n        directionIndex = directionIndex + 1 > 3 ? 0 : directionIndex + 1;\\n    }\\n    \\n    // Iterate until all R * C spaces of the grid are parsed.\\n    while (result.length < R * C) {\\n        // Calculate the amount of spaces in the next spiral shape.\\n        const areaOfSpiralShape = spiralLength ** 2;\\n        \\n        // Iterate until all spaces of the current spiral shape are parsed.\\n        while (parsedSpaces <= areaOfSpiralShape) {\\n            const isLastSpace = parsedSpaces === areaOfSpiralShape - 1;\\n            \\n            // 1. Go to the next space by incrementing/decrementing c/r according to direction.\\n            // 2. Check if a wall of the current spiral shape is reached.\\n            // 3. Change direction if the wall is reached.\\n            // 4. Exception: leave the current direction if the last space of spiral is reached.\\n            switch (directions[directionIndex]) {\\n                case \\'+c\\':\\n                    c++;\\n                    if (!isLastSpace && c + 1 >= startSpace[1] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-c\\':\\n                    c--;\\n                    if (!isLastSpace && c - 1 <= startSpace[1] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'+r\\':\\n                    r++;\\n                    if (!isLastSpace && r + 1 >= startSpace[0] + spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n                case \\'-r\\': \\n                    r--;\\n                    if (!isLastSpace && r - 1 <= startSpace[0] - spiralLength) {\\n                        changeDirection();\\n                    }\\n                    break;\\n            }\\n            \\n            // Add to result in case [r, c] is within R*C grid.\\n            if (c >= 0 && c < C && r >= 0 && r < R) {\\n                result.push([r, c]);\\n            }\\n            parsedSpaces++;\\n        }\\n        \\n        // Set the start space of the next spiral.\\n        startSpace = [r, c];\\n        spiralLength++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 220530,
                "title": "python-real-o-r-c-solution-skipping-paths-outside-the-grid-beats-100",
                "content": "Here is the solution that skips rows and columns outside of the grid in O(1) instead of traversing them and checking if every cell is valid like most other solutions do (which yields them O(max(R,C)^2) time complexity which is apparent if you try a case like `1000 1 0 0`\\n\\nWhen I use `timeit` on my function with arguments `30000, 1, 0, 0` my algorithm takes less than 0.05 seconds on my machine, compared to admin provided solution which given exactly the same input takes around 238 seconds to complete (~4 minutes). And it grows really really fast after that, whereas my solution can process input `1000000, 1, 0, 0` in 1.5 seconds.\\n\\n```python \\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d = 0\\n        steps = 0\\n        ans = [[r0, c0]]\\n        \\n        total = R*C\\n        while len(ans) < total:\\n            d = d % 4\\n            if d % 2 == 0:\\n                steps += 1\\n            steps_left = steps\\n            while steps_left:\\n                r0 = r0 + dirs[d][0]\\n                c0 = c0 + dirs[d][1]\\n                steps_left -= 1\\n                if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                    ans.append([r0, c0])\\n                elif steps_left:\\n                    if d == 0:\\n                        if c0 < 0 and r0 >= 0:\\n                            steps_left += c0 + 1\\n                            c0 = -1\\n                        else:\\n                            c0 += steps_left\\n                            steps_left = 0\\n                    elif d == 1:\\n                        if r0 < 0 and c0 < C:\\n                            steps_left += r0 + 1\\n                            r0 = -1\\n                        else:\\n                            r0 += steps_left\\n                            steps_left = 0\\n                    elif d == 2:\\n                        if c0 >= C and r0 < R:\\n                            steps_left -= c0 - C\\n                            c0 = C\\n                        else:\\n                            c0 -= steps_left\\n                            steps_left = 0\\n                    else:\\n                        if r0 >= R and c0 >= 0:\\n                            steps_left -= r0 - R\\n                            r0 = R\\n                        else:\\n                            r0 -= steps_left\\n                            steps_left = 0\\n            d += 1\\n        return ans",
                "solutionTags": [],
                "code": "Here is the solution that skips rows and columns outside of the grid in O(1) instead of traversing them and checking if every cell is valid like most other solutions do (which yields them O(max(R,C)^2) time complexity which is apparent if you try a case like `1000 1 0 0`\\n\\nWhen I use `timeit` on my function with arguments `30000, 1, 0, 0` my algorithm takes less than 0.05 seconds on my machine, compared to admin provided solution which given exactly the same input takes around 238 seconds to complete (~4 minutes). And it grows really really fast after that, whereas my solution can process input `1000000, 1, 0, 0` in 1.5 seconds.\\n\\n```python \\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        \"\"\"\\n        :type R: int\\n        :type C: int\\n        :type r0: int\\n        :type c0: int\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]\\n        d = 0\\n        steps = 0\\n        ans = [[r0, c0]]\\n        \\n        total = R*C\\n        while len(ans) < total:\\n            d = d % 4\\n            if d % 2 == 0:\\n                steps += 1\\n            steps_left = steps\\n            while steps_left:\\n                r0 = r0 + dirs[d][0]\\n                c0 = c0 + dirs[d][1]\\n                steps_left -= 1\\n                if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n                    ans.append([r0, c0])\\n                elif steps_left:\\n                    if d == 0:\\n                        if c0 < 0 and r0 >= 0:\\n                            steps_left += c0 + 1\\n                            c0 = -1\\n                        else:\\n                            c0 += steps_left\\n                            steps_left = 0\\n                    elif d == 1:\\n                        if r0 < 0 and c0 < C:\\n                            steps_left += r0 + 1\\n                            r0 = -1\\n                        else:\\n                            r0 += steps_left\\n                            steps_left = 0\\n                    elif d == 2:\\n                        if c0 >= C and r0 < R:\\n                            steps_left -= c0 - C\\n                            c0 = C\\n                        else:\\n                            c0 -= steps_left\\n                            steps_left = 0\\n                    else:\\n                        if r0 >= R and c0 >= 0:\\n                            steps_left -= r0 - R\\n                            r0 = R\\n                        else:\\n                            r0 -= steps_left\\n                            steps_left = 0\\n            d += 1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 219801,
                "title": "c-straightforward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int limit=R*C,size=1,direction=0,counter=1,num=2;\\n        vector<vector<int>> res={{r0,c0}};\\n        while(size<limit)\\n        {\\n            switch(direction)\\n            {   case 0:c0++;break;\\n                case 1:r0++;break;\\n                case 2:c0--;break;\\n                case 3:r0--;break;  }  \\n            if(r0>-1&&c0>-1&&r0<R&&c0<C) res.push_back({r0,c0}),size++;\\n            if((--counter)==0) counter=(++num)/2,direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int limit=R*C,size=1,direction=0,counter=1,num=2;\\n        vector<vector<int>> res={{r0,c0}};\\n        while(size<limit)\\n        {\\n            switch(direction)\\n            {   case 0:c0++;break;\\n                case 1:r0++;break;\\n                case 2:c0--;break;\\n                case 3:r0--;break;  }  \\n            if(r0>-1&&c0>-1&&r0<R&&c0<C) res.push_back({r0,c0}),size++;\\n            if((--counter)==0) counter=(++num)/2,direction=(direction+1)%4;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159580,
                "title": "simple-python3-solution-with-video-explanation",
                "content": "Video Link: https://www.youtube.com/watch?v=zG05E85u1s0\\n\\n```\\nclass Solution:\\n  def spiralMatrixIII(self, R, C, r0, c0):\\n    \"\"\"\\n    :type R: int\\n    :type C: int\\n    :type r0: int\\n    :type c0: int\\n    :rtype: List[List[int]]\\n    \"\"\"\\n\\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n    dir_idx = 0\\n    total = R*C\\n    steps = 1\\n    increment = 1\\n    result = [[r0, c0]]\\n\\n    while len(result) < total:\\n      for i in range(increment):\\n        r0, c0 = r0 + dirs[dir_idx][0], c0 + dirs[dir_idx][1]\\n        if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n          result.append([r0, c0])\\n      \\n      dir_idx = (dir_idx + 1) % 4\\n      if steps % 2 == 0:\\n        increment += 1\\n      steps += 1\\n    \\n    return result\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def spiralMatrixIII(self, R, C, r0, c0):\\n    \"\"\"\\n    :type R: int\\n    :type C: int\\n    :type r0: int\\n    :type c0: int\\n    :rtype: List[List[int]]\\n    \"\"\"\\n\\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n    dir_idx = 0\\n    total = R*C\\n    steps = 1\\n    increment = 1\\n    result = [[r0, c0]]\\n\\n    while len(result) < total:\\n      for i in range(increment):\\n        r0, c0 = r0 + dirs[dir_idx][0], c0 + dirs[dir_idx][1]\\n        if r0 >= 0 and r0 < R and c0 >= 0 and c0 < C:\\n          result.append([r0, c0])\\n      \\n      dir_idx = (dir_idx + 1) % 4\\n      if steps % 2 == 0:\\n        increment += 1\\n      steps += 1\\n    \\n    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159112,
                "title": "short-java-solution",
                "content": "```\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res = new int[R * C][2], dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] v = new boolean[R][C];\\n        int x = r0, y = c0, count = 0, dir = 0;\\n        \\n        while (count < R * C) {\\n            if(x >= 0 && x < R && y >=0 && y < C) {\\n                res[count][0] = x;\\n                res[count][1] = y;\\n                v[x][y] = true;\\n                count++;\\n            }\\n            x += dirs[dir][0];\\n            y += dirs[dir][1];\\n            \\n            dir = (dir + 1)%4;\\n            \\n            //one more step to check if we should change dir\\n            int xx = x + dirs[dir][0];\\n            int yy = y + dirs[dir][1];\\n            if(xx >= 0 && xx < R && yy >=0 && yy < C && v[xx][yy]) dir = (dir + 4 - 1)%4;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] res = new int[R * C][2], dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        boolean[][] v = new boolean[R][C];\\n        int x = r0, y = c0, count = 0, dir = 0;\\n        \\n        while (count < R * C) {\\n            if(x >= 0 && x < R && y >=0 && y < C) {\\n                res[count][0] = x;\\n                res[count][1] = y;\\n                v[x][y] = true;\\n                count++;\\n            }\\n            x += dirs[dir][0];\\n            y += dirs[dir][1];\\n            \\n            dir = (dir + 1)%4;\\n            \\n            //one more step to check if we should change dir\\n            int xx = x + dirs[dir][0];\\n            int yy = y + dirs[dir][1];\\n            if(xx >= 0 && xx < R && yy >=0 && yy < C && v[xx][yy]) dir = (dir + 4 - 1)%4;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 158983,
                "title": "python-iterative-solution",
                "content": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1\\n        while len(res) < n:\\n            for __ in range(2):\\n                for _ in range(l):\\n                    r0 += direct[ind][0]\\n                    c0 += direct[ind][1]\\n                    if 0 <= r0 < R and 0 <= c0 < C:\\n                        res.append([r0, c0])\\n                ind = (ind + 1) % 4\\n            l += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, R, C, r0, c0):\\n        direct, res, n, l, ind = [(-1, 0), (0, 1), (1, 0), (0, -1)], [[r0, c0]], R * C, 1, 1\\n        while len(res) < n:\\n            for __ in range(2):\\n                for _ in range(l):\\n                    r0 += direct[ind][0]\\n                    c0 += direct[ind][1]\\n                    if 0 <= r0 < R and 0 <= c0 < C:\\n                        res.append([r0, c0])\\n                ind = (ind + 1) % 4\\n            l += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158975,
                "title": "brute-force",
                "content": "high level idea is quite simple: we simulate the circle. If we change direction twice, we add 1 to our step.\\n\\n\\tclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int direction = 0; //0\\n        int step = 1;\\n        int index = 1;\\n        int flag = 0;\\n        \\n        result[0][0] = r0;\\n        result[0][1] = c0;\\n        int x = r0;\\n        int y = c0;\\n        \\n        while(index < R * C) {\\n            for(int i = 0; i < step; i++) {\\n                switch(direction) {\\n                    case 0 :\\n                        y = y+ 1;\\n                        break;\\n                    case 1:\\n                        x = x + 1;\\n                        break;\\n                    case 2:\\n                        y = y- 1;\\n                        break;\\n                    case 3:\\n                        x = x - 1;\\n                        break;\\n                }\\n                \\n                if(isValid(R, C, x, y)) {\\n                    if(index >= R * C) {\\n                        return result;\\n                    }\\n                    \\n                    result[index][0] = x;\\n                    result[index++][1] = y;\\n                }\\n                \\n            }\\n            direction++;\\n            direction = direction % 4;\\n            \\n            if(flag == 1) {\\n                step++;\\n                \\n            }\\n            flag = (flag + 1) % 2;\\n            \\n        }\\n        return result;     \\n    }\\n    \\n    private boolean isValid(int R, int C, int x, int y) {\\n        return x >= 0 && x < R && y >= 0 && y < C;\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int direction = 0; //0\\n        int step = 1;\\n        int index = 1;\\n        int flag = 0;\\n        \\n        result[0][0] = r0;\\n        result[0][1] = c0;\\n        int x = r0;\\n        int y = c0;\\n        \\n        while(index < R * C) {\\n            for(int i = 0; i < step; i++) {\\n                switch(direction) {\\n                    case 0 :\\n                        y = y+ 1;\\n                        break;\\n                    case 1:\\n                        x = x + 1;\\n                        break;\\n                    case 2:\\n                        y = y- 1;\\n                        break;\\n                    case 3:\\n                        x = x - 1;\\n                        break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 158968,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        if (R == 0 || C == 0) return new int[0][0];\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{ 0, 1 }, {1, 0 }, {0, -1}, {-1, 0}};\\n        int p = 0; //current pointing direction: 0, 1, 2, 3\\n        int[] steps = {1, 1}; //steps to move along c and r direction\\n        int r = r0, c = c0;\\n        res[0] = new int[] {r0, c0};\\n        int i = 1;\\n        while (i < R * C) {\\n            for (int j = 0; j < steps[p % 2]; j++) {\\n                int[] dir = dirs[p];\\n                r += dir[0];\\n                c += dir[1];\\n                if (r >= 0 && r < R && c >= 0 && c < C) {\\n                    res[i++] = new int[] {r, c};\\n                }\\n            }\\n            steps[p % 2]++;\\n            p = (p + 1) % 4;\\n        }\\n        return res; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        if (R == 0 || C == 0) return new int[0][0];\\n        int[][] res = new int[R * C][2];\\n        int[][] dirs = {{ 0, 1 }",
                "codeTag": "Java"
            },
            {
                "id": 158962,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int total = R*C;\\n        int dx[4] = { 0 , 1, 0, -1};\\n        int dy[4] = { 1 , 0, -1, 0};\\n        int cnt = 0;\\n        vector<vector<int> > ans;\\n        ans.push_back({r0, c0});\\n        while(total > ans.size() ){\\n            int step = cnt/2+1;\\n            for( int i = 1; i<=step;i++){\\n                r0 += dx[cnt%4];\\n                c0 += dy[cnt%4];\\n                if( r0 >= 0 && c0 >= 0 && r0 < R && c0 <C )\\n                    ans.push_back({r0,c0});\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int total = R*C;\\n        int dx[4] = { 0 , 1, 0, -1};\\n        int dy[4] = { 1 , 0, -1, 0};\\n        int cnt = 0;\\n        vector<vector<int> > ans;\\n        ans.push_back({r0, c0});\\n        while(total > ans.size() ){\\n            int step = cnt/2+1;\\n            for( int i = 1; i<=step;i++){\\n                r0 += dx[cnt%4];\\n                c0 += dy[cnt%4];\\n                if( r0 >= 0 && c0 >= 0 && r0 < R && c0 <C )\\n                    ans.push_back({r0,c0});\\n            }\\n            cnt++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069939,
                "title": "java-solution",
                "content": "\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n            int[][] ans = new int[rows*cols][2];\\n            int i=0;\\n            ans[i++]= new int[]{rStart,cStart};\\n\\n            int len = 0;\\n            int d = 0;\\n\\n            int[] directions = new int[]{0,1,0,-1,0};\\n\\n            while(i< rows*cols){\\n                if(d==0 || d==2){\\n                    len++;\\n                }\\n                for(int k=0;k<len;k++){\\n                    rStart += directions[d];\\n                    cStart += directions[d+1];\\n                    if(rStart<rows && rStart>=0 && cStart<cols && cStart>=0){\\n                        ans[i++]=new int[]{rStart,cStart};\\n                    }\\n                }\\n                d = ++d % 4;\\n            }\\n\\n            return ans;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n            int[][] ans = new int[rows*cols][2];\\n            int i=0;\\n            ans[i++]= new int[]{rStart,cStart}",
                "codeTag": "Java"
            },
            {
                "id": 4066962,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def doMove(self, rows, cols, current_pos, direction_index, distance):\\n        directions = [\\'e\\', \\'s\\', \\'w\\', \\'n\\']\\n        new_direction = directions[direction_index]\\n        spaces_moved = 1\\n        moves = []\\n        while(spaces_moved <= distance):\\n            if new_direction == \\'e\\':\\n                if current_pos[1] + 1 < cols and current_pos[0] >= 0 and current_pos[0] < rows and current_pos[1]+1 >=0:\\n                    moves.append([current_pos[0], current_pos[1]+1])\\n                current_pos = [current_pos[0], current_pos[1]+1]\\n                \\n            \\n            elif new_direction == \\'s\\':\\n                if current_pos[0]+1 < rows and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0]+1 >=0:\\n                    moves.append([current_pos[0]+1, current_pos[1]])\\n                current_pos = [current_pos[0]+1, current_pos[1]]\\n\\n            elif new_direction == \\'w\\':\\n                if current_pos[1] - 1 >= 0 and current_pos[0] >=0 and current_pos[0] < rows and current_pos[1]-1 < cols:\\n                    moves.append([current_pos[0], current_pos[1] - 1])\\n                current_pos = [current_pos[0], current_pos[1] - 1]\\n\\n            else:\\n                if current_pos[0] - 1 >= 0 and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0] - 1 < rows:\\n                    moves.append([current_pos[0]-1, current_pos[1]])\\n                current_pos = [current_pos[0]-1, current_pos[1]]\\n\\n            spaces_moved += 1\\n\\n        return moves, current_pos\\n\\n\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        skip_add = True\\n        visited = []\\n        direction_index = 0\\n        distance = 1\\n        current_pos = [rStart, cStart]\\n        visited.append(current_pos)\\n\\n        while(len(visited) < (rows * cols)):\\n            latest_moves, current_pos = self.doMove(rows, cols, current_pos, direction_index, distance)\\n            visited.extend(latest_moves)\\n            direction_index += 1\\n            if direction_index > 3:\\n                direction_index = 0\\n            if not skip_add:\\n                skip_add = True\\n                distance += 1\\n            else:\\n                skip_add = False\\n\\n            \\n\\n        return visited\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def doMove(self, rows, cols, current_pos, direction_index, distance):\\n        directions = [\\'e\\', \\'s\\', \\'w\\', \\'n\\']\\n        new_direction = directions[direction_index]\\n        spaces_moved = 1\\n        moves = []\\n        while(spaces_moved <= distance):\\n            if new_direction == \\'e\\':\\n                if current_pos[1] + 1 < cols and current_pos[0] >= 0 and current_pos[0] < rows and current_pos[1]+1 >=0:\\n                    moves.append([current_pos[0], current_pos[1]+1])\\n                current_pos = [current_pos[0], current_pos[1]+1]\\n                \\n            \\n            elif new_direction == \\'s\\':\\n                if current_pos[0]+1 < rows and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0]+1 >=0:\\n                    moves.append([current_pos[0]+1, current_pos[1]])\\n                current_pos = [current_pos[0]+1, current_pos[1]]\\n\\n            elif new_direction == \\'w\\':\\n                if current_pos[1] - 1 >= 0 and current_pos[0] >=0 and current_pos[0] < rows and current_pos[1]-1 < cols:\\n                    moves.append([current_pos[0], current_pos[1] - 1])\\n                current_pos = [current_pos[0], current_pos[1] - 1]\\n\\n            else:\\n                if current_pos[0] - 1 >= 0 and current_pos[1] < cols and current_pos[1] >= 0 and current_pos[0] - 1 < rows:\\n                    moves.append([current_pos[0]-1, current_pos[1]])\\n                current_pos = [current_pos[0]-1, current_pos[1]]\\n\\n            spaces_moved += 1\\n\\n        return moves, current_pos\\n\\n\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        skip_add = True\\n        visited = []\\n        direction_index = 0\\n        distance = 1\\n        current_pos = [rStart, cStart]\\n        visited.append(current_pos)\\n\\n        while(len(visited) < (rows * cols)):\\n            latest_moves, current_pos = self.doMove(rows, cols, current_pos, direction_index, distance)\\n            visited.extend(latest_moves)\\n            direction_index += 1\\n            if direction_index > 3:\\n                direction_index = 0\\n            if not skip_add:\\n                skip_add = True\\n                distance += 1\\n            else:\\n                skip_add = False\\n\\n            \\n\\n        return visited\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066023,
                "title": "spiral-matrix-iii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAS we have done in spiral-I,spiral-II their was not given from where to start so we assume 4 pointers top,bottom,left,right but in this it is mentioned from where to start so in this traverse matrix till size of resultant array is less than size of matix (rows*cols);\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize len to 1 to represent the length of the current spiral.\\nCreate an empty 2D vector ans to store the coordinates in the spiral.\\nAdd the starting coordinate (rStart, cStart) to ans.\\nEnter a loop that continues until ans contains coordinates for all cells in the grid.\\nInside the loop:\\na. Move right by iterating i from 1 to len, adding valid coordinates to ans.\\nb. Update the y coordinate to the right boundary.\\nc. Move down by iterating i from 1 to len, adding valid coordinates to ans.\\nd. Update the x coordinate to the bottom boundary.\\ne. Increment len to increase the length of the spiral.\\nf. Move left by iterating i from 1 to len, adding valid coordinates to ans.\\ng. Update the y coordinate to the left boundary.\\nh. Move up by iterating i from 1 to len, adding valid coordinates to ans.\\ni. Update the x coordinate to the top boundary.\\nRepeat the above steps until ans contains coordinates for all cells in the grid.\\nReturn the ans vector containing the spiral coordinates.\\n# This code essentially follows a clockwise spiral pattern, extending the spiral by increasing len and updating the boundary coordinates in each direction (right, down, left, up) until all cells are covered.\\n\\n\\n# Complexity\\n- Time complexity:O(n*m)  ; n=rows,m=cols\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*m) ; n=rows,m=cols\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool validcoordinate(int r,int m,int rows,int cols){\\n           return r>=0&&m>=0&&r<rows&&m<cols;\\n        }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len=1;\\n        vector<vector<int>>ans;\\n        ans.push_back({rStart,cStart});\\n        int x=rStart,y=cStart;\\n    //jbtk ans ka size matrix ke size se kam ho tbtk loop chle kuki sare cell visit krne hai\\n        while(ans.size()<rows*cols){\\n            //toward right\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y+i,rows,cols))\\n                ans.push_back({x,y+i});\\n            }\\n            //goes out of boundary\\n            y+=len;\\n            //toward down\\n            for(int i=1;i<=len;i++){\\n                //check currently in valid cell or not\\n                if(validcoordinate(x+i,y,rows,cols)){\\n                    ans.push_back({x+i,y});\\n                }\\n            }\\n            x+=len;\\n            len++;\\n            //toward left\\n            for(int i=1;i<=len;i++){\\n                if(validcoordinate(x,y-i,rows,cols))\\n                ans.push_back({x,y-i});\\n            }\\n            y-=len;\\n            //toward up\\n            for(int i=1;i<=len;i++){\\n              if(validcoordinate(x-i,y,rows,cols))\\n              ans.push_back({x-i,y});\\n            }\\n            x-=len;\\n            len++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064400,
                "title": "r-50-m-70",
                "content": "# Complexity\\n- Time complexity: **O(max(m, n) ** 2)**\\nm - rows input value.\\nn - cols input value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(m * n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        # maximum size of row|column, inside the matrix.\\n        row_limit: int = rows\\n        col_limit: int = cols\\n        y: int = rStart\\n        x: int = cStart\\n        dx: int = 0\\n        dy: int = 0\\n        # All coordinates inside given matrix limits.\\n        insides: list[list[int]] = [[y, x]]\\n        # Maximum cells in given matrix.\\n        all_insides: int = rows * cols\\n        turn: int = 0\\n        # Standard steps we need to cover first ROW|COLUMN.\\n        y_steps: int = 1\\n        x_steps: int = 1\\n        # Essentially we\\'re just traversing matrix, and storing correct coordinates.\\n        # From some given point, we just travel ROW|COLUMN and expand it on turns.\\n        # Starting from sizes: ROW == 1, COLUMN == 1 and ending only when all coordinates added.\\n        while len(insides) != all_insides:\\n            if turn == 4:\\n                turn = 0\\n            if turn == 0:\\n                dx = 1\\n                dy = 0\\n            elif turn == 1:\\n                dx = 0\\n                dy = 1\\n            elif turn == 2:\\n                dx = -1\\n                dy = 0\\n            elif turn == 3:\\n                dx = 0\\n                dy = -1\\n            cur_steps: int = 0\\n            if turn == 0 or turn == 2:\\n                while cur_steps != x_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    # Inside matrix.\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    # Out of bounds, no reasons to make steps.\\n                    # Just change coordinate to the last position we could have reach.\\n                    elif dx == 1 and x >= col_limit:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                    elif dx == -1 and x < 0:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                x_steps += 1\\n                turn += 1\\n            elif turn == 1 or turn == 3:\\n                while cur_steps != y_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    elif dy == 1 and y >= row_limit:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                    elif dy == -1 and y < 0:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                y_steps += 1\\n                turn += 1\\n        return insides\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        # maximum size of row|column, inside the matrix.\\n        row_limit: int = rows\\n        col_limit: int = cols\\n        y: int = rStart\\n        x: int = cStart\\n        dx: int = 0\\n        dy: int = 0\\n        # All coordinates inside given matrix limits.\\n        insides: list[list[int]] = [[y, x]]\\n        # Maximum cells in given matrix.\\n        all_insides: int = rows * cols\\n        turn: int = 0\\n        # Standard steps we need to cover first ROW|COLUMN.\\n        y_steps: int = 1\\n        x_steps: int = 1\\n        # Essentially we\\'re just traversing matrix, and storing correct coordinates.\\n        # From some given point, we just travel ROW|COLUMN and expand it on turns.\\n        # Starting from sizes: ROW == 1, COLUMN == 1 and ending only when all coordinates added.\\n        while len(insides) != all_insides:\\n            if turn == 4:\\n                turn = 0\\n            if turn == 0:\\n                dx = 1\\n                dy = 0\\n            elif turn == 1:\\n                dx = 0\\n                dy = 1\\n            elif turn == 2:\\n                dx = -1\\n                dy = 0\\n            elif turn == 3:\\n                dx = 0\\n                dy = -1\\n            cur_steps: int = 0\\n            if turn == 0 or turn == 2:\\n                while cur_steps != x_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    # Inside matrix.\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    # Out of bounds, no reasons to make steps.\\n                    # Just change coordinate to the last position we could have reach.\\n                    elif dx == 1 and x >= col_limit:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                    elif dx == -1 and x < 0:\\n                        x += dx * (x_steps - cur_steps)\\n                        break\\n                x_steps += 1\\n                turn += 1\\n            elif turn == 1 or turn == 3:\\n                while cur_steps != y_steps:\\n                    y += dy\\n                    x += dx\\n                    cur_steps += 1\\n                    if 0 <= y < row_limit and 0 <= x < col_limit:\\n                        insides.append([y, x])\\n                    elif dy == 1 and y >= row_limit:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                    elif dy == -1 and y < 0:\\n                        y += dy * (y_steps - cur_steps)\\n                        break\\n                y_steps += 1\\n                turn += 1\\n        return insides\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031124,
                "title": "super-easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(R^2 * C^2) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int[][] result = new int[R * C][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}}; // Right, Down, Left, Up\\n        int direction = 0; // Start with the right direction\\n        int steps = 1; // Number of steps to take in the current direction\\n        int count = 0; // Number of cells visited\\n        \\n        int x = r0;\\n        int y = c0;\\n        \\n        while (count < R * C) {\\n            for (int i = 0; i < steps; i++) {\\n                if (x >= 0 && x < R && y >= 0 && y < C) {\\n                    result[count][0] = x;\\n                    result[count][1] = y;\\n                    count++;\\n                }\\n                \\n                // Move in the current direction\\n                x += directions[direction][0];\\n                y += directions[direction][1];\\n            }\\n            \\n            // Change direction after every two steps\\n            direction = (direction + 1) % 4;\\n            \\n            // Increase steps after every two directions\\n            if (direction == 0 || direction == 2) {\\n                steps++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012986,
                "title": "java-esy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][];\\n        int k = 0;\\n        res[k++] = new int[]{rStart, cStart};\\n        int[] direction = {0, 1, 0, -1, 0};\\n        int d = 0;\\n        int len = 0;\\n        while(k < rows * cols){\\n            if(d == 0 || d == 2){\\n                len++;\\n            }\\n            for(int i = 0; i < len; i++){\\n                rStart += direction[d];\\n                cStart += direction[d+1];\\n                \\n                if(rStart > -1 && rStart < rows && cStart > -1 && cStart < cols){\\n                    res[k++] = new int[]{rStart, cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012467,
                "title": "c-simple-brute-force-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        static const struct { int dRow, dCol, dSteps; } dirs[] = {\\n            // right,   down,      left,        up\\n            {0, 1, 0}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 1},\\n        };\\n\\n        vector<vector<int>> res;\\n        res.reserve(rows * cols);\\n\\n        int row = rStart, col = cStart;\\n        for (int nSteps = 1; res.size() < rows * cols; nSteps += 2) {\\n            for (const auto& dir : dirs) {\\n                for (int i = 0; i < nSteps + dir.dSteps; ++i) {\\n                    if (row >= 0 && row < rows && col >= 0 && col < cols)\\n                        res.emplace_back(vector<int>{row, col});\\n                    row += dir.dRow;\\n                    col += dir.dCol;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        static const struct { int dRow, dCol, dSteps; } dirs[] = {\\n            // right,   down,      left,        up\\n            {0, 1, 0}, {1, 0, 0}, {0, -1, 1}, {-1, 0, 1},\\n        };\\n\\n        vector<vector<int>> res;\\n        res.reserve(rows * cols);\\n\\n        int row = rStart, col = cStart;\\n        for (int nSteps = 1; res.size() < rows * cols; nSteps += 2) {\\n            for (const auto& dir : dirs) {\\n                for (int i = 0; i < nSteps + dir.dSteps; ++i) {\\n                    if (row >= 0 && row < rows && col >= 0 && col < cols)\\n                        res.emplace_back(vector<int>{row, col});\\n                    row += dir.dRow;\\n                    col += dir.dCol;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003147,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int totalCells = rows * cols;\\n        int[][] result = new int[totalCells][2];\\n\\n        result[0][0] = rStart;\\n        result[0][1] = cStart;\\n        if (totalCells == 1) return result;\\n\\n        // every left and every right up the steps;\\n        int totalSteps = 1;\\n        int steps = 0;\\n        String dir = \"right\";\\n        int[] currentCell = new int[]{rStart, cStart, 0};\\n        while (totalSteps < totalCells) {\\n            if (dir.equals(\"right\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"down\";\\n            }\\n            if (dir.equals(\"down\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"left\";\\n            }\\n            if (dir.equals(\"left\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"up\";\\n            }\\n            if (dir.equals(\"up\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"right\";\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int addSteps(String dir, int steps, int[] currentCell, int[][] result, int rows, int cols) {\\n        int addedSteps = 0;\\n        for (int i = 0; i < steps; i++) {\\n            if (dir.equals(\"right\")) {\\n                currentCell[1]++;\\n            } else if (dir.equals(\"down\")) {\\n                currentCell[0]++;\\n            } else if (dir.equals(\"left\")) {\\n                currentCell[1]--;\\n            } else  if (dir.equals(\"up\")) {\\n                currentCell[0]--;\\n            }\\n            if (currentCell[0] < 0 || currentCell[0] >= rows || currentCell[1] < 0 || currentCell[1] >= cols) continue;\\n            currentCell[2]++;\\n            result[currentCell[2]][0] = currentCell[0];\\n            result[currentCell[2]][1] = currentCell[1];\\n            addedSteps++;\\n        }\\n        return addedSteps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int totalCells = rows * cols;\\n        int[][] result = new int[totalCells][2];\\n\\n        result[0][0] = rStart;\\n        result[0][1] = cStart;\\n        if (totalCells == 1) return result;\\n\\n        // every left and every right up the steps;\\n        int totalSteps = 1;\\n        int steps = 0;\\n        String dir = \"right\";\\n        int[] currentCell = new int[]{rStart, cStart, 0};\\n        while (totalSteps < totalCells) {\\n            if (dir.equals(\"right\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"down\";\\n            }\\n            if (dir.equals(\"down\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"left\";\\n            }\\n            if (dir.equals(\"left\")) {\\n                steps++;\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"up\";\\n            }\\n            if (dir.equals(\"up\")) {\\n                totalSteps += addSteps(dir, steps, currentCell, result, rows, cols);\\n                dir = \"right\";\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int addSteps(String dir, int steps, int[] currentCell, int[][] result, int rows, int cols) {\\n        int addedSteps = 0;\\n        for (int i = 0; i < steps; i++) {\\n            if (dir.equals(\"right\")) {\\n                currentCell[1]++;\\n            } else if (dir.equals(\"down\")) {\\n                currentCell[0]++;\\n            } else if (dir.equals(\"left\")) {\\n                currentCell[1]--;\\n            } else  if (dir.equals(\"up\")) {\\n                currentCell[0]--;\\n            }\\n            if (currentCell[0] < 0 || currentCell[0] >= rows || currentCell[1] < 0 || currentCell[1] >= cols) continue;\\n            currentCell[2]++;\\n            result[currentCell[2]][0] = currentCell[0];\\n            result[currentCell[2]][1] = currentCell[1];\\n            addedSteps++;\\n        }\\n        return addedSteps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995487,
                "title": "beats-96-python-straightforward-solution",
                "content": "# Intuition\\nGenerates a spiral matrix of integers within a grid (rows x cols), starting at a specified point (rStart, cStart). It moves in four directions (right, down, left, up) while incrementing numbers until the entire grid is covered.\\n\\n# Complexity\\n- Time complexity: **O(rows * cols)**\\n- Space complexity: **O(rows * cols)**\\n![image.png](https://assets.leetcode.com/users/images/05db3c52-f603-4ca3-8d9a-808e088a982d_1693720178.937379.png)\\n\\n# Code\\n```py\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int):\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curRow, curCol = rStart, cStart\\n        curNum = 1\\n        dirIdx = 0\\n        iterLen = 1\\n        res = [[rStart, cStart]]\\n        while curNum < rows * cols:\\n            dr, dc = directions[dirIdx]\\n            for c in range(iterLen):\\n                newR = curRow + dr\\n                newC = curCol + dc\\n\\n                if 0 <= newR < rows and 0 <= newC < cols:\\n                    curNum += 1\\n                    res.append([newR, newC])\\n                curRow = newR\\n                curCol = newC\\n\\n            dirIdx = (dirIdx + 1) % 4\\n            if dirIdx % 2 == 0:  # Increase iterLen every two directions\\n                iterLen += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```py\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int):\\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        curRow, curCol = rStart, cStart\\n        curNum = 1\\n        dirIdx = 0\\n        iterLen = 1\\n        res = [[rStart, cStart]]\\n        while curNum < rows * cols:\\n            dr, dc = directions[dirIdx]\\n            for c in range(iterLen):\\n                newR = curRow + dr\\n                newC = curCol + dc\\n\\n                if 0 <= newR < rows and 0 <= newC < cols:\\n                    curNum += 1\\n                    res.append([newR, newC])\\n                curRow = newR\\n                curCol = newC\\n\\n            dirIdx = (dirIdx + 1) % 4\\n            if dirIdx % 2 == 0:  # Increase iterLen every two directions\\n                iterLen += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988426,
                "title": "optimal-solution-and-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int x , int y){\\n        vector<vector<int>>v{{x,y}};\\n        int size = r*c , l=1;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int x , int y){\\n        vector<vector<int>>v{{x,y}};\\n        int size = r*c , l=1;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988412,
                "title": "simplest-and-easiest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int rS , int cS){\\n        vector<vector<int>>v{{rS,cS}};\\n        int size = r*c , l=1 , x=rS , y=cS;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is(int i , int j , int r , int c){\\n        return i>=0 && j>=0 && i<r && j<c;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int r , int c , int rS , int cS){\\n        vector<vector<int>>v{{rS,cS}};\\n        int size = r*c , l=1 , x=rS , y=cS;\\n        while(v.size()<size){\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y+j , r , c)){\\n                    v.push_back({x,y+j});\\n                }\\n            }\\n            y+=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x+j , y , r , c)){\\n                    v.push_back({x+j,y});\\n                }\\n            }\\n            x+=l;\\n            l++;\\n            for(int j=1; j<=l; j++){\\n                if(is(x , y-j , r , c)){\\n                    v.push_back({x,y-j});\\n                }\\n            }\\n            y-=l;\\n            for(int j=1; j<=l; j++){\\n                if(is(x-j , y , r , c)){\\n                    v.push_back({x-j,y});\\n                }\\n            }\\n            x-=l;\\n            l++;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983475,
                "title": "java-straightforward",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // lets make some boundaries and stick with it !\\n        int left = cStart -1 , right = cStart+1 , top = rStart-1 , btm = rStart+1 , cnt= 0;\\n        int [][] res = new int[rows*cols][2];\\n        while(cnt < rows * cols ){\\n            // move left to right\\n            for( ; cStart <= right ; cStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = right ;\\n            rStart++;\\n\\n            // top to btm \\n            for( ; rStart <= btm ; rStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = btm  ;\\n            cStart--;\\n\\n            //right to left\\n            for( ; cStart >= left ; cStart--){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = left;\\n            rStart--;\\n\\n            // btm to top\\n            for( ; rStart >= top ; rStart--){\\n                if( check(rStart , cStart , rows , cols))   res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = top ;\\n            cStart++;\\n\\n            top--;btm++;left--;right++;\\n            \\n        }\\n        return res;\\n    }\\n    public boolean check( int rStart , int cStart , int rows , int cols){\\n        if( rStart >= 0 && rStart <rows && cStart >= 0 && cStart < cols)  return true ;\\n        return false ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // lets make some boundaries and stick with it !\\n        int left = cStart -1 , right = cStart+1 , top = rStart-1 , btm = rStart+1 , cnt= 0;\\n        int [][] res = new int[rows*cols][2];\\n        while(cnt < rows * cols ){\\n            // move left to right\\n            for( ; cStart <= right ; cStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = right ;\\n            rStart++;\\n\\n            // top to btm \\n            for( ; rStart <= btm ; rStart++){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = btm  ;\\n            cStart--;\\n\\n            //right to left\\n            for( ; cStart >= left ; cStart--){\\n                if( check(rStart , cStart , rows , cols)) res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            cStart = left;\\n            rStart--;\\n\\n            // btm to top\\n            for( ; rStart >= top ; rStart--){\\n                if( check(rStart , cStart , rows , cols))   res[cnt++] = new int[]{rStart ,cStart};\\n            }\\n            rStart = top ;\\n            cStart++;\\n\\n            top--;btm++;left--;right++;\\n            \\n        }\\n        return res;\\n    }\\n    public boolean check( int rStart , int cStart , int rows , int cols){\\n        if( rStart >= 0 && rStart <rows && cStart >= 0 && cStart < cols)  return true ;\\n        return false ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981258,
                "title": "c-matrix-traversal",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(rows*cols)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    inline bool isValid(int cr,int cc,int rows, int cols){\\n        return cr>=0 && cc>=0 && cr<rows && cc <cols;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> dirs {{0,1,0},{1,0,0},{0,-1,1},{-1,0,1}};\\n        int cellsToVisit = rows*cols-1,cl=1,cr=rStart,cc=cStart;\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n        while (cellsToVisit>0){\\n            for (int i=0;i<4 && cellsToVisit>0;i++){\\n                for (int j=0;j<cl+dirs[i][2]&& cellsToVisit>0;j++){\\n                    cr += dirs[i][0];\\n                    cc += dirs[i][1];\\n                    //cout << cr << \"-\" << cc << endl;\\n                    if (isValid(cr,cc,rows,cols)) ans.push_back({cr,cc}),cellsToVisit--;\\n                }\\n            }\\n            cl+=2;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    inline bool isValid(int cr,int cc,int rows, int cols){\\n        return cr>=0 && cc>=0 && cr<rows && cc <cols;\\n    }\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> dirs {{0,1,0},{1,0,0},{0,-1,1},{-1,0,1}};\\n        int cellsToVisit = rows*cols-1,cl=1,cr=rStart,cc=cStart;\\n        vector<vector<int>> ans;\\n        ans.push_back({rStart,cStart});\\n        while (cellsToVisit>0){\\n            for (int i=0;i<4 && cellsToVisit>0;i++){\\n                for (int j=0;j<cl+dirs[i][2]&& cellsToVisit>0;j++){\\n                    cr += dirs[i][0];\\n                    cc += dirs[i][1];\\n                    //cout << cr << \"-\" << cc << endl;\\n                    if (isValid(cr,cc,rows,cols)) ans.push_back({cr,cc}),cellsToVisit--;\\n                }\\n            }\\n            cl+=2;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3971173,
                "title": "easy-solution-cpp-fastest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rstart, int cstart) {\\n        vector<vector<int>> ans;\\n        int total = rows * cols;\\n        int ec = cstart, sc = cstart;\\n        int sr = rstart , er = rstart;\\n            \\n        while(ans.size() < total){\\n            ec++;\\n            if(sr >= 0) \\n                for(int i = max(0,sc); i < min(cols,ec) ; i++) \\n                    ans.push_back({sr,i});\\n                  \\n            er++;\\n            if(ec < cols) \\n                for(int i = max(sr,0) ; i < min(er,rows); i++) \\n                    ans.push_back({i,ec});\\n\\n            sc--;\\n            if(er < rows) \\n                for(int i = min (ec, cols-1); i >max(-1, sc) ;i--) \\n                    ans.push_back({er,i});\\n                   \\n            sr--;\\n            if(sc >=0 )\\n                for(int i = min(er,rows-1) ;i > max(-1,sr) ; i--) \\n                    ans.push_back({i,sc}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rstart, int cstart) {\\n        vector<vector<int>> ans;\\n        int total = rows * cols;\\n        int ec = cstart, sc = cstart;\\n        int sr = rstart , er = rstart;\\n            \\n        while(ans.size() < total){\\n            ec++;\\n            if(sr >= 0) \\n                for(int i = max(0,sc); i < min(cols,ec) ; i++) \\n                    ans.push_back({sr,i});\\n                  \\n            er++;\\n            if(ec < cols) \\n                for(int i = max(sr,0) ; i < min(er,rows); i++) \\n                    ans.push_back({i,ec});\\n\\n            sc--;\\n            if(er < rows) \\n                for(int i = min (ec, cols-1); i >max(-1, sc) ;i--) \\n                    ans.push_back({er,i});\\n                   \\n            sr--;\\n            if(sc >=0 )\\n                for(int i = min(er,rows-1) ;i > max(-1,sr) ; i--) \\n                    ans.push_back({i,sc}); \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956137,
                "title": "solution-same-with-spiral-matrix-i-and-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> sprial(rows, vector<int>(cols));\\n        int i = 0;\\n        int a = rStart;\\n        int b = cStart;\\n        int layer1 = max({a, rows-a, cols-b, b});\\n        sprial.erase(sprial.begin(), sprial.end());\\n        sprial.push_back({rStart, cStart});\\n        for (int layer = 0; layer <= layer1;){\\n            for(i = 0; i < (2 * layer + 1); i++){\\n                if((b - layer + i + 1) >= 0 && (b - layer + i + 1) < cols && (a - layer) >= 0) {\\n                    sprial.push_back({a - layer, b - layer + i + 1});\\n                    }\\n            }\\n            layer++;\\n            for(i = 0; i < 2 * layer - 1; i++){\\n                if((a - layer + i + 2) < rows && (a - layer + i + 2)>=0 && (b + layer) < cols) {\\n                    sprial.push_back({a - layer + 2 + i, b + layer});\\n                    }\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((b + layer - i -1) < cols && (b + layer - i -1) >= 0 && (a + layer) < rows) {\\n                    sprial.push_back({a + layer, b + layer -i - 1});}\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((a + layer - i -1) < rows && (a + layer - i -1) >= 0 && (b - layer) >= 0) {\\n                    sprial.push_back({a + layer - i -1, b - layer});}\\n            }\\n        }\\n        return sprial;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> sprial(rows, vector<int>(cols));\\n        int i = 0;\\n        int a = rStart;\\n        int b = cStart;\\n        int layer1 = max({a, rows-a, cols-b, b});\\n        sprial.erase(sprial.begin(), sprial.end());\\n        sprial.push_back({rStart, cStart});\\n        for (int layer = 0; layer <= layer1;){\\n            for(i = 0; i < (2 * layer + 1); i++){\\n                if((b - layer + i + 1) >= 0 && (b - layer + i + 1) < cols && (a - layer) >= 0) {\\n                    sprial.push_back({a - layer, b - layer + i + 1});\\n                    }\\n            }\\n            layer++;\\n            for(i = 0; i < 2 * layer - 1; i++){\\n                if((a - layer + i + 2) < rows && (a - layer + i + 2)>=0 && (b + layer) < cols) {\\n                    sprial.push_back({a - layer + 2 + i, b + layer});\\n                    }\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((b + layer - i -1) < cols && (b + layer - i -1) >= 0 && (a + layer) < rows) {\\n                    sprial.push_back({a + layer, b + layer -i - 1});}\\n            }\\n            for(i = 0; i < 2 * layer; i++){\\n                if((a + layer - i -1) < rows && (a + layer - i -1) >= 0 && (b - layer) >= 0) {\\n                    sprial.push_back({a + layer - i -1, b - layer});}\\n            }\\n        }\\n        return sprial;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908272,
                "title": "easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows * cols][2];\\n        int in = 0;\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int rs = rStart;\\n        int cs = cStart;\\n        int directionIndex = 0;\\n        int steps = 1;\\n        while (in < rows * cols) {\\n            for (int i = 0; i < steps; i++) {\\n                if (rs >= 0 && rs < rows && cs >= 0 && cs < cols) {\\n                    mat[in][0] = rs;\\n                    mat[in][1] = cs;\\n                    in++;\\n                }\\n                rs += directions[directionIndex][0];\\n                cs += directions[directionIndex][1];\\n            }\\n            if (directionIndex % 2 == 1) {\\n                steps++;\\n            }\\n            directionIndex = (directionIndex + 1) % 4;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] mat = new int[rows * cols][2];\\n        int in = 0;\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int rs = rStart;\\n        int cs = cStart;\\n        int directionIndex = 0;\\n        int steps = 1;\\n        while (in < rows * cols) {\\n            for (int i = 0; i < steps; i++) {\\n                if (rs >= 0 && rs < rows && cs >= 0 && cs < cols) {\\n                    mat[in][0] = rs;\\n                    mat[in][1] = cs;\\n                    in++;\\n                }\\n                rs += directions[directionIndex][0];\\n                cs += directions[directionIndex][1];\\n            }\\n            if (directionIndex % 2 == 1) {\\n                steps++;\\n            }\\n            directionIndex = (directionIndex + 1) % 4;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861073,
                "title": "elegant-c-solution",
                "content": "\\n# Solution\\n\\nAdd start cell to the solution list. \\n\\nStart from given starting position and walk until result list contains all `R * C` cells.\\n\\n# Complexity\\n\\nWorst case scenario when $$R = 1$$, $$C > 1$$, and starting position $$(0, C-1)$$ corner. To reach $$(0, C-2)$$ we need to do spiral around, and trace $$3 *3$$ square before we reach starting position. To reach $$(0, C-3)$$ cell we must do $$5 * 5$$ moves. It is easy to see that the algorithm will require $$O(max(R, C)^2)$$ steps to walk all $$R*C$$ cells.\\n\\n# Code\\n\\n```\\n// define how to add pairs\\ntemplate<typename T, typename K>\\nvoid operator +=(pair<T,K> &lhs, const pair<T,K> &rhs) {\\n    lhs.first += rhs.first;\\n    lhs.second += rhs.second;\\n}\\n\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        pair<int, int> pos = { rStart, cStart};\\n    \\n        const vector<pair<int,int>> dirs = {\\n            {  0,  1 }, // E\\n            {  1,  0 }, // S\\n            {  0, -1 }, // W\\n            { -1,  0 }  // N\\n        };\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols); // from problem statement\\n        ans.push_back({pos.first, pos.second});\\n\\n        const int cnt = rows * cols;\\n\\n        int r = 1; // radius\\n        int s = 0; // steps\\n\\n        while (ans.size() < cnt) {\\n            const auto &move = dirs[s++ % dirs.size()];\\n\\n            for (int k = 0; k < r && ans.size() < cnt; ++k) {\\n                pos += move;\\n                \\n                if (pos.first == clamp(pos.first, 0, rows - 1) && \\n                    pos.second == clamp(pos.second, 0, cols - 1)) {\\n                    ans.push_back({pos.first, pos.second});\\n                }\\n            }\\n\\n            // every two steps increase radius\\n            if (s % 2 == 0) {\\n                r++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// define how to add pairs\\ntemplate<typename T, typename K>\\nvoid operator +=(pair<T,K> &lhs, const pair<T,K> &rhs) {\\n    lhs.first += rhs.first;\\n    lhs.second += rhs.second;\\n}\\n\\nclass Solution {\\n\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        pair<int, int> pos = { rStart, cStart};\\n    \\n        const vector<pair<int,int>> dirs = {\\n            {  0,  1 }, // E\\n            {  1,  0 }, // S\\n            {  0, -1 }, // W\\n            { -1,  0 }  // N\\n        };\\n\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols); // from problem statement\\n        ans.push_back({pos.first, pos.second});\\n\\n        const int cnt = rows * cols;\\n\\n        int r = 1; // radius\\n        int s = 0; // steps\\n\\n        while (ans.size() < cnt) {\\n            const auto &move = dirs[s++ % dirs.size()];\\n\\n            for (int k = 0; k < r && ans.size() < cnt; ++k) {\\n                pos += move;\\n                \\n                if (pos.first == clamp(pos.first, 0, rows - 1) && \\n                    pos.second == clamp(pos.second, 0, cols - 1)) {\\n                    ans.push_back({pos.first, pos.second});\\n                }\\n            }\\n\\n            // every two steps increase radius\\n            if (s % 2 == 0) {\\n                r++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849650,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe algorithm generates a spiral path by simulating movement starting from a given position. It traverses right, down, left, and up in a spiral pattern, increasing the step length to cover all cells.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing sets, the algorithm tracks already traversed and all possible coordinates. It ensures cell validity and avoids revisiting cells. By incrementally updating the step length, it efficiently covers all cells in the grid. The output grid is constructed with the visited cells in the order of traversal, forming a spiral pattern that represents the desired path. This approach ensures a complete and optimized traversal of the grid to solve the spiral matrix III problem.\\n# Complexity\\n- Time complexity: O(row^2 + column^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(row * column)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // Create an unordered_set to store the coordinates of all cells in the grid\\n        unordered_set<string> coordinates;\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                // Convert the row and column indices to a string and insert into the set\\n                coordinates.insert(to_string(r) + \"-\" + to_string(c));\\n            }\\n        }\\n\\n        // Create an unordered_set to store the already traversed coordinates\\n        unordered_set<string> AlreadyTraversed;\\n\\n        // Create a vector to store the final output grid\\n        vector<vector<int>> OutputGrid;\\n\\n        // Initialize the current row and column with the starting positions\\n        int curr_row = rStart;\\n        int curr_column = cStart;\\n\\n        // Push the starting cell into the output grid\\n        OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n        // Mark the starting cell as already traversed\\n        AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n\\n        // Initialize the current step length to 1\\n        int curr = 1;\\n\\n        // Continue traversing until all cells have been visited\\n        while (AlreadyTraversed.size() != coordinates.size()) {\\n            // Traverse to the right\\n            for (int i = 0; i < curr; i++) {\\n                // Move to the next right cell\\n                curr_column++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse down\\n            for (int i = 0; i < curr; i++) {\\n                // Move down by 1\\n                curr_row++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n\\n            // Traverse to the left\\n            for (int i = 0; i < curr; i++) {\\n                // Move left by one\\n                curr_column--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse up\\n            for (int i = 0; i < curr; i++) {\\n                // Move up by 1\\n                curr_row--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n        }\\n\\n        // Return the final output grid containing the spiral path\\n        return OutputGrid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        // Create an unordered_set to store the coordinates of all cells in the grid\\n        unordered_set<string> coordinates;\\n        for (int r = 0; r < rows; r++) {\\n            for (int c = 0; c < cols; c++) {\\n                // Convert the row and column indices to a string and insert into the set\\n                coordinates.insert(to_string(r) + \"-\" + to_string(c));\\n            }\\n        }\\n\\n        // Create an unordered_set to store the already traversed coordinates\\n        unordered_set<string> AlreadyTraversed;\\n\\n        // Create a vector to store the final output grid\\n        vector<vector<int>> OutputGrid;\\n\\n        // Initialize the current row and column with the starting positions\\n        int curr_row = rStart;\\n        int curr_column = cStart;\\n\\n        // Push the starting cell into the output grid\\n        OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n        // Mark the starting cell as already traversed\\n        AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n\\n        // Initialize the current step length to 1\\n        int curr = 1;\\n\\n        // Continue traversing until all cells have been visited\\n        while (AlreadyTraversed.size() != coordinates.size()) {\\n            // Traverse to the right\\n            for (int i = 0; i < curr; i++) {\\n                // Move to the next right cell\\n                curr_column++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse down\\n            for (int i = 0; i < curr; i++) {\\n                // Move down by 1\\n                curr_row++;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n\\n            // Traverse to the left\\n            for (int i = 0; i < curr; i++) {\\n                // Move left by one\\n                curr_column--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Traverse up\\n            for (int i = 0; i < curr; i++) {\\n                // Move up by 1\\n                curr_row--;\\n\\n                // If the cell is within the grid and not already traversed\\n                if (coordinates.find(to_string(curr_row) + \"-\" + to_string(curr_column)) != coordinates.end()) {\\n                    // Push it to the output array\\n                    OutputGrid.push_back(vector<int>{curr_row, curr_column});\\n\\n                    // Mark it as already traversed\\n                    AlreadyTraversed.insert(to_string(curr_row) + \"-\" + to_string(curr_column));\\n                }\\n            }\\n\\n            // Increment the current step length\\n            curr++;\\n        }\\n\\n        // Return the final output grid containing the spiral path\\n        return OutputGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828031,
                "title": "java-straightforward-simulation",
                "content": "The square we walk in grows its sides by **2** each iteration; i.e., **1 x 1**-> **3 x 3**-> **5 x 5**. The walk down needs to be one shorter than the others, and the walk right needs to be one longer.\\n\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][2];\\n        \\n        int x = rStart, y = cStart, idx = 0, spiralSize = 1;\\n        while (idx < res.length) {\\n            //walk down\\n            for (int i = 0; i < spiralSize - 2; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x++;\\n            }\\n            //walk left\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y--;\\n            }\\n            //walk up\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x--;\\n            }\\n            //walk right\\n            for (int i = 0; i < spiralSize; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y++;\\n            }\\n            spiralSize += 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] res = new int[rows * cols][2];\\n        \\n        int x = rStart, y = cStart, idx = 0, spiralSize = 1;\\n        while (idx < res.length) {\\n            //walk down\\n            for (int i = 0; i < spiralSize - 2; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x++;\\n            }\\n            //walk left\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y--;\\n            }\\n            //walk up\\n            for (int i = 0; i < spiralSize - 1; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                x--;\\n            }\\n            //walk right\\n            for (int i = 0; i < spiralSize; i++) {\\n                if (x >= 0 && y >= 0 && x < rows && y < cols)\\n                    res[idx++] = new int[]{x, y};\\n                y++;\\n            }\\n            spiralSize += 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815975,
                "title": "innovative-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int max=rows*cols;\\n        int res[][]=new int[max][2];\\n        int i=1,minus=1,count=0;\\n        res[count++]=new int[]{rStart,cStart};\\n        while(count<max){\\n            for(int j=i;j>0;j--){\\n                cStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            for(int j=i;j>0;j--){\\n                rStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            minus*=-1;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int max=rows*cols;\\n        int res[][]=new int[max][2];\\n        int i=1,minus=1,count=0;\\n        res[count++]=new int[]{rStart,cStart};\\n        while(count<max){\\n            for(int j=i;j>0;j--){\\n                cStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            for(int j=i;j>0;j--){\\n                rStart+=minus;\\n                if(rStart<rows && cStart<cols && rStart>=0 && cStart>=0){\\n                    res[count++]=new int[]{rStart,cStart};\\n                    if(count>=max) return res;\\n                }\\n            }\\n            minus*=-1;\\n            i++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785773,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = [(0 ,1), (1, 0), (0, -1), (-1, 0)]\\n        step = 0\\n        w = 2\\n        ret = [[rStart, cStart]]\\n        r, c = rStart, cStart\\n        while len(ret) < rows * cols:\\n            direction = directions[step % 4]\\n\\n            for i in range(1, w):\\n                r += direction[0]\\n                c += direction[1]\\n                if r >= 0 and r < rows and c >= 0 and c < cols:\\n                    ret.append([r, c])\\n\\n            step += 1\\n            if step % 2 == 0:\\n                w += 1\\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = [(0 ,1), (1, 0), (0, -1), (-1, 0)]\\n        step = 0\\n        w = 2\\n        ret = [[rStart, cStart]]\\n        r, c = rStart, cStart\\n        while len(ret) < rows * cols:\\n            direction = directions[step % 4]\\n\\n            for i in range(1, w):\\n                r += direction[0]\\n                c += direction[1]\\n                if r >= 0 and r < rows and c >= 0 and c < cols:\\n                    ret.append([r, c])\\n\\n            step += 1\\n            if step % 2 == 0:\\n                w += 1\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773371,
                "title": "java-easy-understable-problem",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int size = 1;\\n        int dir = 1;\\n        int result[][] = new int[rows * cols][2];\\n        result[0] = new int[]{rStart, cStart};\\n        \\n        while (size < rows * cols) {\\n            // for east\\n            int east = 1;\\n            while (east <= dir) {\\n                cStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                east++;\\n            }\\n            \\n            // for south\\n            int south = 1;\\n            while (south <= dir) {\\n                rStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                south++;\\n            }\\n            \\n            dir++;\\n            \\n            // for west\\n            int west = 1;\\n            while (west <= dir) {\\n                cStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                west++;\\n            }\\n            \\n            // for north\\n            int north = 1;\\n            while (north <= dir) {\\n                rStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                north++;\\n            }\\n            \\n            dir++;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static boolean check(int row, int col, int rows, int cols) {\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int size = 1;\\n        int dir = 1;\\n        int result[][] = new int[rows * cols][2];\\n        result[0] = new int[]{rStart, cStart};\\n        \\n        while (size < rows * cols) {\\n            // for east\\n            int east = 1;\\n            while (east <= dir) {\\n                cStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                east++;\\n            }\\n            \\n            // for south\\n            int south = 1;\\n            while (south <= dir) {\\n                rStart++;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                south++;\\n            }\\n            \\n            dir++;\\n            \\n            // for west\\n            int west = 1;\\n            while (west <= dir) {\\n                cStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                west++;\\n            }\\n            \\n            // for north\\n            int north = 1;\\n            while (north <= dir) {\\n                rStart--;\\n                if (check(rStart, cStart, rows, cols)) {\\n                    result[size] = new int[]{rStart, cStart};\\n                    size++;\\n                }\\n                north++;\\n            }\\n            \\n            dir++;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public static boolean check(int row, int col, int rows, int cols) {\\n        return row >= 0 && row < rows && col >= 0 && col < cols;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741426,
                "title": "slow-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix.append([i,j])\\n        mypath = [[rStart, cStart]]\\n        mypoint = [rStart, cStart]\\n        offset = 1\\n        while len(mypath) < len(matrix):\\n            # right\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]+1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # down\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]+1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            #left\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]-1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # up\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]-1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            steps += 1\\n\\n\\n        return mypath\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = []\\n        for i in range(rows):\\n            for j in range(cols):\\n                matrix.append([i,j])\\n        mypath = [[rStart, cStart]]\\n        mypoint = [rStart, cStart]\\n        offset = 1\\n        while len(mypath) < len(matrix):\\n            # right\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]+1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # down\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]+1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            #left\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0],mypoint[1]-1]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            # up\\n            for i in range(1, offset+1):\\n                mypoint = [mypoint[0]-1,mypoint[1]]\\n                if mypoint in matrix:\\n                    mypath.append(mypoint)\\n            offset += 1\\n            steps += 1\\n\\n\\n        return mypath\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734825,
                "title": "easiest-code-you-will-ever-find-beats-everyone",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, r: int, c: int, i: int, j: int) -> List[List[int]]:\\n\\n\\n        ans = []                                    \\n        rb, lb, ub, db = j, j, i, i                 \\n        while (len(ans) < r*c):                     \\n            while j < rb + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j += 1                              \\n            rb += 1                                 \\n                                            \\n            while i < db + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i += 1                              \\n            db += 1                                 \\n                                            \\n            while j > lb - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j -= 1                              \\n            lb -= 1                                 \\n                                            \\n            while i > ub - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i -= 1                              \\n            ub -= 1                                 \\n        return ans                                                      \\n                  \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, r: int, c: int, i: int, j: int) -> List[List[int]]:\\n\\n\\n        ans = []                                    \\n        rb, lb, ub, db = j, j, i, i                 \\n        while (len(ans) < r*c):                     \\n            while j < rb + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j += 1                              \\n            rb += 1                                 \\n                                            \\n            while i < db + 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i += 1                              \\n            db += 1                                 \\n                                            \\n            while j > lb - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                j -= 1                              \\n            lb -= 1                                 \\n                                            \\n            while i > ub - 1:                       \\n                if(i<r and j<c and i>=0 and j>=0):  \\n                    ans.append([i, j])              \\n                i -= 1                              \\n            ub -= 1                                 \\n        return ans                                                      \\n                  \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734049,
                "title": "c-termination-condition-one-loop-design-hard-problem-2023-july",
                "content": "July 7, 2023\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo be a good thinker, it takes a lot of practice. \\n\\nThe challenge part is to define termination condition for spiral matrix movement. With uncertain Spiral visit\\'s length, all nodes inside matrix should be able to be visited once. \\n\\nI also learn to write C# in short form, using int[,] instead of declaring two arrays. \\n\\n```\\n// clockwise, right, down, left, up\\nvar directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n```\\n\\nBetter than the following\\n```\\n var directionRow = new int[] { 0, 1, 0, -1 };\\n var directionCol = new int[] { 1, 0, -1, 0 };\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter 6+ month break, I came back to warmup my C# coding skills to prepare Meta phone screen in 2 months. \\n\\nThe following are needed:\\n1. Work on basics of algorithm - start one algorithm a day, code one algorithm a day\\n2. Also challenge myself to solve more algorithms, really go through painful feelings to fail on some algorithms. \\n3. Get back on working on C# coding skills, one tip a time. \\n4. Trust myself to learn better, fail better.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _885_spiral_matrix_III\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n\\n            var result = test.SpiralMatrixIII(1, 4, 0, 0);\\n            var sb = new StringBuilder();\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                sb.Append(string.Join(\"-\", result[i]));                \\n                sb.Append(\",\");\\n            }\\n            \\n            Debug.Assert(sb.ToString().CompareTo(\"0-0,0-1,0-2,0-3,\") == 0);\\n\\n            result = test.SpiralMatrixIII(5, 6, 1, 4);\\n        }\\n\\n        /// <summary>\\n        /// Spiral matrix \\n        /// study code\\n        /// https://leetcode.com/problems/spiral-matrix-iii/solutions/2837586/c/\\n        /// </summary>\\n        /// <param name=\"rows\"></param>\\n        /// <param name=\"cols\"></param>\\n        /// <param name=\"rStart\"></param>\\n        /// <param name=\"cStart\"></param>\\n        /// <returns></returns>\\n        public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n        {\\n            var result = new List<int[]>();\\n\\n            // clockwise, right, down, left, up\\n            var directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n            var steps = 0;\\n            var direction = 0;\\n\\n            result.Add(new int[] { rStart, cStart });\\n\\n            // based on two facts: All nodes will be visited in the matrix\\n            // step - 1, 1, 2, 2, 3, 3, ...\\n            // We do not care about nodes outside of matrix - just go through those nodes if needed\\n            // Think about more carefully - one loop - termination condition - ?\\n            while (result.Count < rows * cols)\\n            {\\n                //directions right---> or left <---, increase steps++\\n                if (direction == 0 || direction == 2)\\n                {\\n                    steps++;\\n                }\\n\\n                for (int index = 0; index < steps; index++)\\n                {\\n                    rStart += directions[direction, 0];\\n                    cStart += directions[direction, 1];\\n\\n                    // if it is in matrix range - out-of-range - just ignore\\n                    if (rStart < rows && rStart >= 0 && cStart < cols && cStart >= 0)\\n                    {\\n                        result.Add(new int[] { rStart, cStart });\\n                    }\\n                }\\n\\n                direction = (direction + 1) % 4;\\n            }\\n\\n            return result.ToArray();\\n        }\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n// clockwise, right, down, left, up\\nvar directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n```\n```\\n var directionRow = new int[] { 0, 1, 0, -1 };\\n var directionCol = new int[] { 1, 0, -1, 0 };\\n```\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _885_spiral_matrix_III\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var test = new Program();\\n\\n            var result = test.SpiralMatrixIII(1, 4, 0, 0);\\n            var sb = new StringBuilder();\\n            for (var i = 0; i < result.Length; i++)\\n            {\\n                sb.Append(string.Join(\"-\", result[i]));                \\n                sb.Append(\",\");\\n            }\\n            \\n            Debug.Assert(sb.ToString().CompareTo(\"0-0,0-1,0-2,0-3,\") == 0);\\n\\n            result = test.SpiralMatrixIII(5, 6, 1, 4);\\n        }\\n\\n        /// <summary>\\n        /// Spiral matrix \\n        /// study code\\n        /// https://leetcode.com/problems/spiral-matrix-iii/solutions/2837586/c/\\n        /// </summary>\\n        /// <param name=\"rows\"></param>\\n        /// <param name=\"cols\"></param>\\n        /// <param name=\"rStart\"></param>\\n        /// <param name=\"cStart\"></param>\\n        /// <returns></returns>\\n        public int[][] SpiralMatrixIII(int rows, int cols, int rStart, int cStart)\\n        {\\n            var result = new List<int[]>();\\n\\n            // clockwise, right, down, left, up\\n            var directions = new int[,] { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\n            var steps = 0;\\n            var direction = 0;\\n\\n            result.Add(new int[] { rStart, cStart });\\n\\n            // based on two facts: All nodes will be visited in the matrix\\n            // step - 1, 1, 2, 2, 3, 3, ...\\n            // We do not care about nodes outside of matrix - just go through those nodes if needed\\n            // Think about more carefully - one loop - termination condition - ?\\n            while (result.Count < rows * cols)\\n            {\\n                //directions right---> or left <---, increase steps++\\n                if (direction == 0 || direction == 2)\\n                {\\n                    steps++;\\n                }\\n\\n                for (int index = 0; index < steps; index++)\\n                {\\n                    rStart += directions[direction, 0];\\n                    cStart += directions[direction, 1];\\n\\n                    // if it is in matrix range - out-of-range - just ignore\\n                    if (rStart < rows && rStart >= 0 && cStart < cols && cStart >= 0)\\n                    {\\n                        result.Add(new int[] { rStart, cStart });\\n                    }\\n                }\\n\\n                direction = (direction + 1) % 4;\\n            }\\n\\n            return result.ToArray();\\n        }\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723058,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        \\n        // Initialize the boundary variables\\n        int left = cStart - 1;\\n        int right = cStart + 1;\\n        int top = rStart - 1;\\n        int bottom = rStart + 1;\\n        \\n        // Add the initial position to the result\\n        result.push_back({rStart, cStart});\\n\\n        // Continue until all positions are covered\\n        while (left > -1 || right < cols || top > -1 || bottom < rows) {\\n            // Traverse right from top to bottom\\n            if (right < cols) {\\n                for (int i = top + 1; i < bottom; i++) {\\n                    result.push_back({i, right});\\n                }\\n                right++;\\n            }\\n            \\n            // Traverse down from right to left\\n            if (bottom < rows) {\\n                for (int i = right - 1; i > left; i--) {\\n                    result.push_back({bottom, i});\\n                }\\n                bottom++;\\n            }\\n            \\n            // Traverse left from bottom to top\\n            if (left > -1) {\\n                for (int i = bottom - 1; i > top; i--) {\\n                    result.push_back({i, left});\\n                }\\n                left--;\\n            }\\n            \\n            // Traverse up from left to right\\n            if (top > -1) {\\n                for (int i = left + 1; i < right; i++) {\\n                    result.push_back({top, i});\\n                }\\n                top--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result;\\n        \\n        // Initialize the boundary variables\\n        int left = cStart - 1;\\n        int right = cStart + 1;\\n        int top = rStart - 1;\\n        int bottom = rStart + 1;\\n        \\n        // Add the initial position to the result\\n        result.push_back({rStart, cStart});\\n\\n        // Continue until all positions are covered\\n        while (left > -1 || right < cols || top > -1 || bottom < rows) {\\n            // Traverse right from top to bottom\\n            if (right < cols) {\\n                for (int i = top + 1; i < bottom; i++) {\\n                    result.push_back({i, right});\\n                }\\n                right++;\\n            }\\n            \\n            // Traverse down from right to left\\n            if (bottom < rows) {\\n                for (int i = right - 1; i > left; i--) {\\n                    result.push_back({bottom, i});\\n                }\\n                bottom++;\\n            }\\n            \\n            // Traverse left from bottom to top\\n            if (left > -1) {\\n                for (int i = bottom - 1; i > top; i--) {\\n                    result.push_back({i, left});\\n                }\\n                left--;\\n            }\\n            \\n            // Traverse up from left to right\\n            if (top > -1) {\\n                for (int i = left + 1; i < right; i++) {\\n                    result.push_back({top, i});\\n                }\\n                top--;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705690,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] matrix = new int[rows*cols][2];\\n        int i=0;\\n        // 0th row is filled and i is incremented afterwards\\n        matrix[i++]=new int[]{rStart,cStart};\\n\\n        int d=0; // for direction moving\\n        //to move in all directions as per the need\\n        int[] directions = new int[]{0,1,0,-1,0}; \\n        int length =0;\\n\\n        while(i < rows*cols)\\n        {\\n            if(d==0 || d==2) // length need not to be incremnted in case of 3 or 4\\n            {\\n                length++;\\n            }\\n          //loop will run the length times\\n            for(int j=0; j<length; j++)\\n            {\\n                rStart += directions[d];\\n                cStart += directions[d+1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    matrix[i++] = new int[]{rStart,cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return matrix;\\n    }\\n}\\n```\\n\\nUpvote please\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        \\n        int[][] matrix = new int[rows*cols][2];\\n        int i=0;\\n        // 0th row is filled and i is incremented afterwards\\n        matrix[i++]=new int[]{rStart,cStart};\\n\\n        int d=0; // for direction moving\\n        //to move in all directions as per the need\\n        int[] directions = new int[]{0,1,0,-1,0}; \\n        int length =0;\\n\\n        while(i < rows*cols)\\n        {\\n            if(d==0 || d==2) // length need not to be incremnted in case of 3 or 4\\n            {\\n                length++;\\n            }\\n          //loop will run the length times\\n            for(int j=0; j<length; j++)\\n            {\\n                rStart += directions[d];\\n                cStart += directions[d+1];\\n                if(rStart>=0 && rStart<rows && cStart>=0 && cStart<cols)\\n                {\\n                    matrix[i++] = new int[]{rStart,cStart};\\n                }\\n            }\\n            d = ++d % 4;\\n        }\\n        return matrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684268,
                "title": "c-very-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols);\\n\\n        enum directions {RIGHT, DOWN, LEFT, UP};\\n        int dir = RIGHT;\\n        int step = 1;\\n        int countAll = rows*cols;\\n\\n        int i = rStart;\\n        int j = cStart;\\n\\n        while(countAll > 0) {\\n            if (dir == RIGHT) {\\n                if (i >=0 && i < rows)\\n                for(int k = max(j, 0), maxK = min(j+step-1, cols-1); k <= maxK; k++) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j += step;\\n                dir = DOWN;\\n            } else if (dir == DOWN) {\\n                if (j >=0 && j < cols)\\n                for(int k = max(i, 0), maxK = min(i+step-1, rows-1); k <= maxK; k++) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i += step;\\n                step++;\\n                dir = LEFT;\\n            }if (dir == LEFT) {\\n                if (i >=0 && i < rows)\\n                for(int k = min(j, cols-1), minK = max(j-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j -= step;\\n                dir = UP;\\n            } else if (dir == UP) {\\n                if (j >=0 && j < cols)\\n                for(int k = min(i, rows-1), minK = max(i-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i -= step;\\n                step++;\\n                dir = RIGHT;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        ans.reserve(rows*cols);\\n\\n        enum directions {RIGHT, DOWN, LEFT, UP};\\n        int dir = RIGHT;\\n        int step = 1;\\n        int countAll = rows*cols;\\n\\n        int i = rStart;\\n        int j = cStart;\\n\\n        while(countAll > 0) {\\n            if (dir == RIGHT) {\\n                if (i >=0 && i < rows)\\n                for(int k = max(j, 0), maxK = min(j+step-1, cols-1); k <= maxK; k++) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j += step;\\n                dir = DOWN;\\n            } else if (dir == DOWN) {\\n                if (j >=0 && j < cols)\\n                for(int k = max(i, 0), maxK = min(i+step-1, rows-1); k <= maxK; k++) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i += step;\\n                step++;\\n                dir = LEFT;\\n            }if (dir == LEFT) {\\n                if (i >=0 && i < rows)\\n                for(int k = min(j, cols-1), minK = max(j-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({i, k});\\n                    countAll--;\\n                }\\n                j -= step;\\n                dir = UP;\\n            } else if (dir == UP) {\\n                if (j >=0 && j < cols)\\n                for(int k = min(i, rows-1), minK = max(i-step+1, 0); k >= minK; k--) {\\n                    ans.push_back({k, j});\\n                    countAll--;\\n                }\\n                i -= step;\\n                step++;\\n                dir = RIGHT;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657077,
                "title": "solution-with-comments-3",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int directionIndex = 0;\\n        int currentRow = rStart;\\n        int currentCol = cStart;\\n        int count = 0;\\n        int stepsInCurrentDirection = 1;\\n\\n        while (count < rows * cols) {\\n            for (int i = 0; i < 2; i++) {  // \\u041E\\u0431\\u0440\\u043E\\u0431\\u043A\\u0430 \\u0434\\u0432\\u043E\\u0445 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n                for (int j = 0; j < stepsInCurrentDirection; j++) {\\n                    if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {\\n                        result[count++] = new int[]{currentRow, currentCol};\\n                    }\\n                    currentRow += directions[directionIndex][0];\\n                    currentCol += directions[directionIndex][1];\\n                    if (count == rows * cols) {\\n                        return result;  // \\u0412\\u0441\\u0456 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0456\\u0457 \\u0432\\u0456\\u0434\\u0432\\u0456\\u0434\\u0430\\u043D\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\n                    }\\n                }\\n                directionIndex = (directionIndex + 1) % 4;  // \\u0417\\u043C\\u0456\\u043D\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n            }\\n            stepsInCurrentDirection++;  // \\u0417\\u0431\\u0456\\u043B\\u044C\\u0448\\u0435\\u043D\\u043D\\u044F \\u043A\\u0456\\u043B\\u044C\\u043A\\u043E\\u0441\\u0442\\u0456 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043D\\u0430\\u0441\\u0442\\u0443\\u043F\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] result = new int[rows * cols][2];\\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n        int directionIndex = 0;\\n        int currentRow = rStart;\\n        int currentCol = cStart;\\n        int count = 0;\\n        int stepsInCurrentDirection = 1;\\n\\n        while (count < rows * cols) {\\n            for (int i = 0; i < 2; i++) {  // \\u041E\\u0431\\u0440\\u043E\\u0431\\u043A\\u0430 \\u0434\\u0432\\u043E\\u0445 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043F\\u043E\\u0442\\u043E\\u0447\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n                for (int j = 0; j < stepsInCurrentDirection; j++) {\\n                    if (currentRow >= 0 && currentRow < rows && currentCol >= 0 && currentCol < cols) {\\n                        result[count++] = new int[]{currentRow, currentCol};\\n                    }\\n                    currentRow += directions[directionIndex][0];\\n                    currentCol += directions[directionIndex][1];\\n                    if (count == rows * cols) {\\n                        return result;  // \\u0412\\u0441\\u0456 \\u043F\\u043E\\u0437\\u0438\\u0446\\u0456\\u0457 \\u0432\\u0456\\u0434\\u0432\\u0456\\u0434\\u0430\\u043D\\u0456, \\u043F\\u043E\\u0432\\u0435\\u0440\\u0442\\u0430\\u0454\\u043C\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\n                    }\\n                }\\n                directionIndex = (directionIndex + 1) % 4;  // \\u0417\\u043C\\u0456\\u043D\\u0430 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n            }\\n            stepsInCurrentDirection++;  // \\u0417\\u0431\\u0456\\u043B\\u044C\\u0448\\u0435\\u043D\\u043D\\u044F \\u043A\\u0456\\u043B\\u044C\\u043A\\u043E\\u0441\\u0442\\u0456 \\u043A\\u0440\\u043E\\u043A\\u0456\\u0432 \\u0443 \\u043D\\u0430\\u0441\\u0442\\u0443\\u043F\\u043D\\u043E\\u043C\\u0443 \\u043D\\u0430\\u043F\\u0440\\u044F\\u043C\\u043A\\u0443\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649528,
                "title": "python",
                "content": "\\n# Code\\n```\\nclass Solution:\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total = rows * cols\\n        if total == 1:\\n            return [[rStart, cStart]]\\n        c = 1\\n        step = 0\\n        jump = 1\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n        idx = 0\\n        d = dirs[idx]\\n\\n        i = rStart\\n        j = cStart\\n        matrix = [[0 for _ in range(cols)] for _ in range(rows)]\\n        matrix[rStart][cStart] = 1\\n        res = [[rStart, cStart]]\\n\\n        while c <= total:\\n\\n            inext = i + d[0] * jump\\n            jnext = j + d[1] * jump\\n            if idx < 2:\\n                ds = 1\\n                istart = i\\n                iend = inext+1\\n                jstart = j\\n                jend = jnext+1\\n            else:\\n                ds = -1\\n                istart = i\\n                iend = inext-1\\n                jstart = j\\n                jend = jnext-1\\n\\n            for ic in range(istart, iend, ds):\\n                for jc in range(jstart, jend, ds):\\n                    if 0 <= ic < rows and 0 <= jc < cols and matrix[ic][jc] == 0:\\n                        c += 1\\n                        res.append([ic, jc])\\n                        matrix[ic][jc] = 1\\n                        if c == total:\\n\\n                            return res\\n\\n            step += 1\\n            \\n            if idx == 3:\\n                idx = 0\\n            else:\\n                idx += 1\\n            d = dirs[idx]\\n            \\n            if step == 2:\\n                step = 0\\n                jump += 1\\n            \\n            i = inext\\n            j = jnext\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        total = rows * cols\\n        if total == 1:\\n            return [[rStart, cStart]]\\n        c = 1\\n        step = 0\\n        jump = 1\\n        dirs = [(0,1), (1,0), (0,-1), (-1,0)]\\n        idx = 0\\n        d = dirs[idx]\\n\\n        i = rStart\\n        j = cStart\\n        matrix = [[0 for _ in range(cols)] for _ in range(rows)]\\n        matrix[rStart][cStart] = 1\\n        res = [[rStart, cStart]]\\n\\n        while c <= total:\\n\\n            inext = i + d[0] * jump\\n            jnext = j + d[1] * jump\\n            if idx < 2:\\n                ds = 1\\n                istart = i\\n                iend = inext+1\\n                jstart = j\\n                jend = jnext+1\\n            else:\\n                ds = -1\\n                istart = i\\n                iend = inext-1\\n                jstart = j\\n                jend = jnext-1\\n\\n            for ic in range(istart, iend, ds):\\n                for jc in range(jstart, jend, ds):\\n                    if 0 <= ic < rows and 0 <= jc < cols and matrix[ic][jc] == 0:\\n                        c += 1\\n                        res.append([ic, jc])\\n                        matrix[ic][jc] = 1\\n                        if c == total:\\n\\n                            return res\\n\\n            step += 1\\n            \\n            if idx == 3:\\n                idx = 0\\n            else:\\n                idx += 1\\n            d = dirs[idx]\\n            \\n            if step == 2:\\n                step = 0\\n                jump += 1\\n            \\n            i = inext\\n            j = jnext\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620449,
                "title": "brute-force",
                "content": "# Approach\\nSimilar to I and II, store direction in a deque, and use a counter to determine floor((n+1)/2) steps to take, for all natural number n.\\n\\nIf the coordinate is in grid, at coordinate to grid (or increment a counter). Continue this process until all coordinate in grid is collected. \\n\\n# Complexity\\n- Time complexity: O((max(rows, cols))^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(rows * cols)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ret = [[rStart, cStart]]\\n        direction = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        count = 2\\n\\n        while True:\\n            dx, dy = direction[0]\\n\\n            for i in range(count//2):\\n                rStart += dx\\n                cStart += dy\\n                \\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ret.append([rStart, cStart]) \\n            \\n            if len(ret) == rows * cols:\\n                return ret\\n            \\n            direction.rotate(-1)\\n            count += 1\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        ret = [[rStart, cStart]]\\n        direction = deque([(0, 1), (1, 0), (0, -1), (-1, 0)])\\n        count = 2\\n\\n        while True:\\n            dx, dy = direction[0]\\n\\n            for i in range(count//2):\\n                rStart += dx\\n                cStart += dy\\n                \\n                if 0 <= rStart < rows and 0 <= cStart < cols:\\n                    ret.append([rStart, cStart]) \\n            \\n            if len(ret) == rows * cols:\\n                return ret\\n            \\n            direction.rotate(-1)\\n            count += 1\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613845,
                "title": "simple-simulation",
                "content": "# Approach\\nWe simulate spiral traversal. When we are inside given boundaries we append to the result.\\n\\n# Complexity\\n- Time complexity: $$O(4*rows*cols)$$ ~ $$O(rows*cols)$$.\\n\\n- Space complexity: $$O(rows*cols)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        curDir = 0\\n        result = []\\n        r, c = rStart, cStart\\n        steps = 1\\n        n = 0\\n        while n < rows*cols:\\n            for _ in range(2):\\n                for _ in range(steps):\\n                    if 0 <= r < rows and 0 <= c < cols:\\n                        result.append([r,c])\\n                        n += 1\\n\\n                    r += directions[curDir][0]\\n                    c += directions[curDir][1]\\n            \\n                curDir = (curDir + 1)%len(directions)\\n\\n            steps += 1\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        directions = ((0, 1), (1, 0), (0, -1), (-1, 0))\\n        curDir = 0\\n        result = []\\n        r, c = rStart, cStart\\n        steps = 1\\n        n = 0\\n        while n < rows*cols:\\n            for _ in range(2):\\n                for _ in range(steps):\\n                    if 0 <= r < rows and 0 <= c < cols:\\n                        result.append([r,c])\\n                        n += 1\\n\\n                    r += directions[curDir][0]\\n                    c += directions[curDir][1]\\n            \\n                curDir = (curDir + 1)%len(directions)\\n\\n            steps += 1\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605129,
                "title": "c-solution-with-explanation",
                "content": "# EXPLANATION\\nWe created 2-D vector **v** for our traversal.\\nStored the given coordinates in **i** and **j** respectively.\\nCreated a 2-D vector **ans** for our answer.\\n\\nLet\\'s see the idea:-\\nWe took bool\\na = for traversal left to right (if possible)\\nb = for traversal top to bottom (if possible)\\nc = for traversal right to left (if possible)\\nd = for traversal bottom to top (if possible)\\nThe idea is to keep track of 4 index to check if traversal is possible or not. The coordinates of 4-index are stored in vector **p**.\\nIn the first set of the conditions we we checked if the 4 point are going to lie in **v** or not.\\nInside big while loop\\nWe traversed in spiral form and on every inner loop, we checked if we are not out of vector and simultaneously added the coordinates in **ans**.\\nFinally returned the answer.\\nIT WILL BE BETTER IF THE CODE IS DRY RUN FOR JUST ONE SPIRAL MOVEMENT, FOR BETTER UNDERSTANDING.\\nIn this we need to check for condition of corner cases too.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> v(rows,vector<int>(cols,0));\\n        int i=rStart,j=cStart;\\n        vector<vector<int>> ans;\\n        bool a=true,b=true,c=true,d=true;\\n        vector<vector<int>> p={{i,j},{i,j+1},{i+1,j},{i,j-1}};\\n        if(p[1][1]>=cols)\\n            b=false;\\n        if(p[2][0]>=rows)\\n            c=false;\\n        else if(p[2][1]+1<cols)\\n            p[2][1]++;\\n        if(p[3][1]<0)\\n            d=false;\\n        else if(p[3][0]+1<rows)\\n            p[3][0]++;\\n        while(a || b || c || d){\\n            if(a){\\n                int x=p[0][0],y=p[0][1];\\n                while(y<cols && y!=p[1][1])\\n                    ans.push_back({x,y++});\\n                p[0][0]--;\\n                if(p[0][0]<0)\\n                    a=false;\\n                (p[0][1]-1<0)?:p[0][1]--;\\n            }\\n            if(b){\\n                int x=p[1][0],y=p[1][1];\\n                while(x<rows && x!=p[2][0])\\n                    ans.push_back({x++,y});\\n                p[1][1]++;\\n                if(p[1][1]>=cols)\\n                    b=false;\\n                (p[1][0]-1<0)?:p[1][0]--;\\n            }\\n            if(c){\\n                int x=p[2][0],y=p[2][1];\\n                while(y>=0 && y!=p[3][1])\\n                    ans.push_back({x,y--});\\n                p[2][0]++;\\n                if(p[2][0]>=rows)\\n                    c=false;\\n                (p[2][1]+1>=cols)?:p[2][1]++;\\n            }\\n            if(d){\\n                int x=p[3][0],y=p[3][1];\\n                while(x>=0 && x!=p[0][0])\\n                    ans.push_back({x--,y});\\n                p[3][1]--;\\n                if(p[3][1]<0)\\n                    d=false;\\n                (p[3][0]+1>=rows)?:p[3][0]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> v(rows,vector<int>(cols,0));\\n        int i=rStart,j=cStart;\\n        vector<vector<int>> ans;\\n        bool a=true,b=true,c=true,d=true;\\n        vector<vector<int>> p={{i,j},{i,j+1},{i+1,j},{i,j-1}};\\n        if(p[1][1]>=cols)\\n            b=false;\\n        if(p[2][0]>=rows)\\n            c=false;\\n        else if(p[2][1]+1<cols)\\n            p[2][1]++;\\n        if(p[3][1]<0)\\n            d=false;\\n        else if(p[3][0]+1<rows)\\n            p[3][0]++;\\n        while(a || b || c || d){\\n            if(a){\\n                int x=p[0][0],y=p[0][1];\\n                while(y<cols && y!=p[1][1])\\n                    ans.push_back({x,y++});\\n                p[0][0]--;\\n                if(p[0][0]<0)\\n                    a=false;\\n                (p[0][1]-1<0)?:p[0][1]--;\\n            }\\n            if(b){\\n                int x=p[1][0],y=p[1][1];\\n                while(x<rows && x!=p[2][0])\\n                    ans.push_back({x++,y});\\n                p[1][1]++;\\n                if(p[1][1]>=cols)\\n                    b=false;\\n                (p[1][0]-1<0)?:p[1][0]--;\\n            }\\n            if(c){\\n                int x=p[2][0],y=p[2][1];\\n                while(y>=0 && y!=p[3][1])\\n                    ans.push_back({x,y--});\\n                p[2][0]++;\\n                if(p[2][0]>=rows)\\n                    c=false;\\n                (p[2][1]+1>=cols)?:p[2][1]++;\\n            }\\n            if(d){\\n                int x=p[3][0],y=p[3][1];\\n                while(x>=0 && x!=p[0][0])\\n                    ans.push_back({x--,y});\\n                p[3][1]--;\\n                if(p[3][1]<0)\\n                    d=false;\\n                (p[3][0]+1>=rows)?:p[3][0]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602266,
                "title": "python-straightforward-and-logical",
                "content": "# Intuition\\n1. Notice that we must traverse the spiral walk regardless if we are inside or outside the grid boundaries.\\n2. We will need to continue spiral walking until visiting all cells.\\n3. The spiral walk follows a pattern:\\n4. Move forward `k` steps, turn right, move forward `k` steps, turn right, then increment `k += 1`. \\n5. Each time we move, we visit the cell by checking if we are within the boundaries, if so, then we append to output.\\n\\n# Code\\n```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        d = 0\\n        k = 1\\n        x, y = rStart, cStart\\n        output = []\\n        output.append([x, y])\\n        while len(output) < rows * cols:\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # increment k\\n            k += 1\\n        \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\\n        d = 0\\n        k = 1\\n        x, y = rStart, cStart\\n        output = []\\n        output.append([x, y])\\n        while len(output) < rows * cols:\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # move forward k steps\\n            dx, dy = moves[d]\\n            for _ in range(k):\\n                x += dx\\n                y += dy\\n                if 0 <= x < rows and 0 <= y < cols:\\n                    output.append([x, y])\\n            # turn right\\n            d = (d + 1) % 4\\n            # increment k\\n            k += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590449,
                "title": "go-simple-solution",
                "content": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n\\n\\tres := make([][]int, 0, rows*cols)\\n\\tres = append(res, []int{rStart, cStart})\\n\\n\\tcount := 1\\n\\tlimit := 1\\n\\tdirections := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n\\tcol, row := cStart, rStart\\n\\tfor count != rows*cols {\\n\\t\\tfor k, d := range directions {\\n\\t\\t\\tfor c := 0; c < limit; c++ {\\n\\t\\t\\t\\trow += d[0]\\n\\t\\t\\t\\tcol += d[1]\\n\\t\\t\\t\\tif col < cols && row < rows && row >= 0 && col >= 0 {\\n\\t\\t\\t\\t\\tres = append(res, []int{row, col})\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif k == 1 || k == 3 {\\n\\t\\t\\t\\tlimit += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n\\n\\tres := make([][]int, 0, rows*cols)\\n\\tres = append(res, []int{rStart, cStart})\\n\\n\\tcount := 1\\n\\tlimit := 1\\n\\tdirections := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}}\\n\\tcol, row := cStart, rStart\\n\\tfor count != rows*cols {\\n\\t\\tfor k, d := range directions {\\n\\t\\t\\tfor c := 0; c < limit; c++ {\\n\\t\\t\\t\\trow += d[0]\\n\\t\\t\\t\\tcol += d[1]\\n\\t\\t\\t\\tif col < cols && row < rows && row >= 0 && col >= 0 {\\n\\t\\t\\t\\t\\tres = append(res, []int{row, col})\\n\\t\\t\\t\\t\\tcount++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif k == 1 || k == 3 {\\n\\t\\t\\t\\tlimit += 1\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3562668,
                "title": "simple-rotating-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. create bound for start/end of row and column\\n2. rotate increasing our bounds by 1 each time\\n3. if an index is within our grid bounds add it to the result set\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n    res := [][]int{}\\n\\n    rstart, rend := rStart, rStart + 1\\n    cstart, cend := cStart, cStart + 1\\n\\n    for len(res) < rows * cols {\\n        for i := cstart; i <= cend; i++ {\\n            res = add(res, rstart, i, rows, cols)\\n        }\\n\\n        cstart--\\n\\n        for i := rstart + 1; i <= rend; i++ {\\n            res = add(res, i, cend, rows, cols)\\n        }\\n\\n        rstart--\\n\\n        for i := cend - 1; i >= cstart; i-- {\\n            res = add(res, rend, i, rows, cols)\\n        }\\n\\n        cend++\\n\\n        for i := rend - 1; i > rstart; i-- {\\n            res = add(res, i, cstart, rows, cols)\\n        }\\n\\n        rend++\\n    }\\n\\n    return res\\n}\\n\\nfunc add(res [][]int, i int, j int, rows int, cols int) [][]int {\\n    if i < 0 || i > rows - 1 || j < 0 || j > cols - 1 {\\n        return res\\n    }\\n\\n    return append(res, []int{i, j})\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc spiralMatrixIII(rows int, cols int, rStart int, cStart int) [][]int {\\n    res := [][]int{}\\n\\n    rstart, rend := rStart, rStart + 1\\n    cstart, cend := cStart, cStart + 1\\n\\n    for len(res) < rows * cols {\\n        for i := cstart; i <= cend; i++ {\\n            res = add(res, rstart, i, rows, cols)\\n        }\\n\\n        cstart--\\n\\n        for i := rstart + 1; i <= rend; i++ {\\n            res = add(res, i, cend, rows, cols)\\n        }\\n\\n        rstart--\\n\\n        for i := cend - 1; i >= cstart; i-- {\\n            res = add(res, rend, i, rows, cols)\\n        }\\n\\n        cend++\\n\\n        for i := rend - 1; i > rstart; i-- {\\n            res = add(res, i, cstart, rows, cols)\\n        }\\n\\n        rend++\\n    }\\n\\n    return res\\n}\\n\\nfunc add(res [][]int, i int, j int, rows int, cols int) [][]int {\\n    if i < 0 || i > rows - 1 || j < 0 || j > cols - 1 {\\n        return res\\n    }\\n\\n    return append(res, []int{i, j})\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539627,
                "title": "swift-clean-solution-explained",
                "content": "# Approach\\n###### Simulate the walk, ignoring whether we stay in the grid or not, and record positions of the grid in the order we encounter them.\\n###### Keep track of the count of steps needed in current direction. When it becomes zero, turn clockwise and reset the counter, incrementing it every second time.\\n###### Take the unit vector $$(0, 1)$$ pointing to the right as the start move direction. When it\\'s time to turn, use the force of science to get a new heading. As the math says, the orthogonals to vector $$(A, B)$$ are vectors $$(-B, A)$$ and $$(B, -A)$$, the former is original turned $$90^0$$ counter-clockwise and the latter is $$(A, B)$$ turned $$90^0$$ clockwise, which is what we need.\\n\\n# Complexity\\n- Time complexity: $$O(max(R, C)^2)$$. Potentially, our walk needs to spiral until we move $$R$$ in one direction, and $$C$$ in another direction, so as to reach every cell of the grid.\\n- Space complexity: $$O(R*C)$$, the space used by the answer.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    struct Coord\\n    {\\n        var i, j: Int\\n        init(_ i: Int, _ j: Int) { self.i = i; self.j = j }\\n        static func += (lhs: inout Coord, rhs: Coord) { lhs.i += rhs.i; lhs.j += rhs.j }\\n    }\\n    \\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        var coord = Coord(rStart, cStart), direction = Coord(0, 1)\\n        func isInGrid() -> Bool {\\n            coord.i >= 0 && coord.i < rows && coord.j >= 0 && coord.j < cols\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.i, coord.j])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.i, direction.j) = (direction.j, -direction.i)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord += direction\\n            steps -= 1\\n        }\\n        return visited\\n    }\\n}\\n\\n```\\n### The same, using SIMD2 vector type just for kicks\\n```\\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        // coord.x is rows from top to down, coord.y is columns from left to right\\n        var coord = SIMD2(rStart, cStart), direction = SIMD2(0, 1)\\n\\n        let origin = SIMD2(0, 0), corner = SIMD2(rows - 1, cols - 1)\\n        let SIMD2True = SIMDMask<SIMD2<Int>>(repeating: true)\\n        func isInGrid() -> Bool { \\n            ((coord .>= origin) == SIMD2True) && ((coord .<= corner) == SIMD2True)\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.x, coord.y])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.x, direction.y) = (direction.y, -direction.x)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord &+= direction\\n            steps -= 1            \\n        }\\n        return visited\\n    }\\n```",
                "solutionTags": [
                    "Swift",
                    "Math",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    struct Coord\\n    {\\n        var i, j: Int\\n        init(_ i: Int, _ j: Int) { self.i = i; self.j = j }\\n        static func += (lhs: inout Coord, rhs: Coord) { lhs.i += rhs.i; lhs.j += rhs.j }\\n    }\\n    \\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        var coord = Coord(rStart, cStart), direction = Coord(0, 1)\\n        func isInGrid() -> Bool {\\n            coord.i >= 0 && coord.i < rows && coord.j >= 0 && coord.j < cols\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.i, coord.j])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.i, direction.j) = (direction.j, -direction.i)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord += direction\\n            steps -= 1\\n        }\\n        return visited\\n    }\\n}\\n\\n```\n```\\n    func spiralMatrixIII(_ rows: Int, _ cols: Int, _ rStart: Int, _ cStart: Int) -> [[Int]]\\n    {\\n        // coord.x is rows from top to down, coord.y is columns from left to right\\n        var coord = SIMD2(rStart, cStart), direction = SIMD2(0, 1)\\n\\n        let origin = SIMD2(0, 0), corner = SIMD2(rows - 1, cols - 1)\\n        let SIMD2True = SIMDMask<SIMD2<Int>>(repeating: true)\\n        func isInGrid() -> Bool { \\n            ((coord .>= origin) == SIMD2True) && ((coord .<= corner) == SIMD2True)\\n        }\\n\\n        let cellCount = rows * cols\\n        var visited: [[Int]] = [], steps = 1, maxSteps = 2\\n        while true\\n        {\\n            if isInGrid() {\\n                visited.append([coord.x, coord.y])\\n                if visited.count == cellCount { break }\\n            }\\n\\n            if steps == 0\\n            {   // turn clockwise\\n                (direction.x, direction.y) = (direction.y, -direction.x)\\n                // calculate amount of steps in new direction\\n                maxSteps += 1\\n                steps = maxSteps / 2\\n            }\\n            // advance in the current direction\\n            coord &+= direction\\n            steps -= 1            \\n        }\\n        return visited\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519800,
                "title": "simple-c-code-with-o-n-4",
                "content": "# Complexity\\n- Time complexity:\\nO(ror*row*col*col)\\n\\n- Space complexity:\\nWe have not used any extra space bu to return the answer we have used a space of O(row*col)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        int left=cStart, right=cStart+1, bottom=rStart+1,top=rStart;\\n        vector<vector<int>> ans;\\n        while(n){\\n            //right\\n            for(int i=left; i<=right; i++){\\n                if(i<=cols-1 && i>=0 && top>=0 && top<=rows-1){\\n                    ans.push_back({top, i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n\\n            //bottom\\n            for(int i=top+1; i<=bottom; i++){\\n                if(right<=cols-1 && right>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n\\n            //left\\n            for(int i=right-1; i>=left; i--){\\n                if(i<=cols-1 && i>=0 && bottom>=0 && bottom<=rows-1){\\n                    ans.push_back({bottom, i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n\\n            //top\\n            for(int i=bottom-1; i>top; i--){\\n                if(left<=cols-1 && left>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int n = rows*cols;\\n        int left=cStart, right=cStart+1, bottom=rStart+1,top=rStart;\\n        vector<vector<int>> ans;\\n        while(n){\\n            //right\\n            for(int i=left; i<=right; i++){\\n                if(i<=cols-1 && i>=0 && top>=0 && top<=rows-1){\\n                    ans.push_back({top, i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n\\n            //bottom\\n            for(int i=top+1; i<=bottom; i++){\\n                if(right<=cols-1 && right>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n\\n            //left\\n            for(int i=right-1; i>=left; i--){\\n                if(i<=cols-1 && i>=0 && bottom>=0 && bottom<=rows-1){\\n                    ans.push_back({bottom, i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n\\n            //top\\n            for(int i=bottom-1; i>top; i--){\\n                if(left<=cols-1 && left>=0 && i>=0 && i<=rows-1){\\n                    ans.push_back({i, left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519783,
                "title": "simple-c-solution-with-o-n-4",
                "content": "# Complexity\\n- Time complexity: O(r * r * c * c)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(r*c)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int r, int c, int sr, int sc) {\\n        int n=r*c;\\n        vector<vector<int>>ans;\\n        int top=sr,right=sc+1;\\n        int bottom=sr+1,left=sc;\\n        while(n>0){\\n            for(int i=left;i<=right;++i){\\n                if(top>=0 && top<r && i>=0 && i<c){\\n                    ans.push_back({top,i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n            for(int i=top+1;i<=bottom;++i){\\n                if(i>=0 && i<r && right>=0 && right<c){\\n                    ans.push_back({i,right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n            for(int i=right-1;i>left;--i){\\n                if(bottom>=0 && bottom<r && i>=0 && i<c){\\n                    ans.push_back({bottom,i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n            for(int i=bottom;i>top;--i){\\n                if(i>=0 && i<r && left>=0 && left<c){\\n                    ans.push_back({i,left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int r, int c, int sr, int sc) {\\n        int n=r*c;\\n        vector<vector<int>>ans;\\n        int top=sr,right=sc+1;\\n        int bottom=sr+1,left=sc;\\n        while(n>0){\\n            for(int i=left;i<=right;++i){\\n                if(top>=0 && top<r && i>=0 && i<c){\\n                    ans.push_back({top,i});\\n                    n--;\\n                }\\n            }\\n            left--;\\n            for(int i=top+1;i<=bottom;++i){\\n                if(i>=0 && i<r && right>=0 && right<c){\\n                    ans.push_back({i,right});\\n                    n--;\\n                }\\n            }\\n            top--;\\n            for(int i=right-1;i>left;--i){\\n                if(bottom>=0 && bottom<r && i>=0 && i<c){\\n                    ans.push_back({bottom,i});\\n                    n--;\\n                }\\n            }\\n            right++;\\n            for(int i=bottom;i>top;--i){\\n                if(i>=0 && i<r && left>=0 && left<c){\\n                    ans.push_back({i,left});\\n                    n--;\\n                }\\n            }\\n            bottom++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516395,
                "title": "spiral-matrix-iii-very-easy-solution-in-c-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int required_movements = rows * cols;\\n        int i = rStart, j = cStart;\\n        int steps = 0, steps_cpy = 0;\\n        ans.push_back({i, j});\\n        while(ans.size() < required_movements)\\n        {\\n            steps++;\\n            steps_cpy = steps;\\n            while(steps_cpy > 0)\\n            {\\n                if(steps % 2 != 0)\\n                {\\n                    j++;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--;\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--; \\n                }\\n            }\\n            if(ans.size() < required_movements)\\n            {\\n                steps_cpy = steps;\\n                while(steps_cpy > 0)\\n                {\\n                    if(steps % 2 != 0)\\n                    {\\n                        i++;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--;\\n                    }\\n                    else\\n                    {\\n                        i--;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--; \\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int required_movements = rows * cols;\\n        int i = rStart, j = cStart;\\n        int steps = 0, steps_cpy = 0;\\n        ans.push_back({i, j});\\n        while(ans.size() < required_movements)\\n        {\\n            steps++;\\n            steps_cpy = steps;\\n            while(steps_cpy > 0)\\n            {\\n                if(steps % 2 != 0)\\n                {\\n                    j++;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--;\\n                }\\n                else\\n                {\\n                    j--;\\n                    if(i>=0 && i<rows && j>=0 && j<cols)\\n                    {\\n                        ans.push_back({i, j});\\n                    }\\n                    steps_cpy--; \\n                }\\n            }\\n            if(ans.size() < required_movements)\\n            {\\n                steps_cpy = steps;\\n                while(steps_cpy > 0)\\n                {\\n                    if(steps % 2 != 0)\\n                    {\\n                        i++;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--;\\n                    }\\n                    else\\n                    {\\n                        i--;\\n                        if(i>=0 && i<rows && j>=0 && j<cols)\\n                        {\\n                            ans.push_back({i, j});\\n                        }\\n                        steps_cpy--; \\n                    }\\n                }\\n            }\\n        }  \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512926,
                "title": "java-solution",
                "content": "# Time complexity:\\nO ( max ( rows, cols ) ^2 )\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len = rows*cols;\\n        int[][] ans = new int[len][2];\\n        int ai = 0;\\n        ans[ai][0] = rStart;\\n        ans[ai][1] = cStart++;\\n        ai++;\\n        int rEnd = rStart-1;\\n        int cEnd = cStart;\\n        while(ai<len){\\n            //go right\\n            for(int i=cStart; i<=cEnd && ai<len; i++){\\n                if(rStart<0 || i<0  || i>=cols) continue;\\n                ans[ai][0] = rStart;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rStart++; //cuz starting row is covered now\\n            rEnd+=2;\\n\\n            //go down -> travel rows\\n            for(int i=rStart; i<=rEnd && ai<len; i++){\\n                if(i<0 || i>=rows || cEnd>=cols) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cEnd;\\n                ai++;\\n            }\\n            cEnd--; //cuz last column is finished now\\n            cStart-=2;\\n            \\n            //go left -> travel columns\\n            for(int i=cEnd; i>=cStart && ai<len; i--){\\n                if(rEnd>=rows || i<0 || i>=cols) continue;\\n                ans[ai][0] = rEnd;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rEnd--; //cuz last row is now done\\n            rStart-=2;\\n            \\n            //go up -> travel rows\\n            for(int i=rEnd; i>=rStart && ai<len; i--){\\n                if(cStart<0 || i<0 || i>=rows) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cStart;\\n                ai++;\\n            }\\n            cStart++; //cuz starting col is now done\\n            cEnd+=2;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int len = rows*cols;\\n        int[][] ans = new int[len][2];\\n        int ai = 0;\\n        ans[ai][0] = rStart;\\n        ans[ai][1] = cStart++;\\n        ai++;\\n        int rEnd = rStart-1;\\n        int cEnd = cStart;\\n        while(ai<len){\\n            //go right\\n            for(int i=cStart; i<=cEnd && ai<len; i++){\\n                if(rStart<0 || i<0  || i>=cols) continue;\\n                ans[ai][0] = rStart;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rStart++; //cuz starting row is covered now\\n            rEnd+=2;\\n\\n            //go down -> travel rows\\n            for(int i=rStart; i<=rEnd && ai<len; i++){\\n                if(i<0 || i>=rows || cEnd>=cols) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cEnd;\\n                ai++;\\n            }\\n            cEnd--; //cuz last column is finished now\\n            cStart-=2;\\n            \\n            //go left -> travel columns\\n            for(int i=cEnd; i>=cStart && ai<len; i--){\\n                if(rEnd>=rows || i<0 || i>=cols) continue;\\n                ans[ai][0] = rEnd;\\n                ans[ai][1] = i;\\n                ai++;\\n            }\\n            rEnd--; //cuz last row is now done\\n            rStart-=2;\\n            \\n            //go up -> travel rows\\n            for(int i=rEnd; i>=rStart && ai<len; i--){\\n                if(cStart<0 || i<0 || i>=rows) continue;\\n                ans[ai][0] = i;\\n                ans[ai][1] = cStart;\\n                ai++;\\n            }\\n            cStart++; //cuz starting col is now done\\n            cEnd+=2;\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509778,
                "title": "python-solution-based-spiral-matrix-1-2-and-4-easy-understanding",
                "content": "\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = [[-1 for i in range(cols)] for j in range(rows)]\\n        if rows==0:\\n            return []\\n        t=rStart\\n        ans=[]\\n        b=t+1\\n        l=cStart\\n        r=l+1\\n        d=0\\n        ct=1\\n        while ct<=rows*cols:\\n            if l<=0:\\n                l=0\\n            if t<=0:\\n                t=0\\n            if r>=cols-1:\\n                r=cols-1\\n            if b>=rows-1:\\n                b=rows-1\\n            if(d==0):\\n                for i in range(l,r+1):\\n                    if matrix[t][i]==-1:\\n                        ans.append([t,i])\\n                        matrix[t][i]=0\\n                        ct+=1\\n                d=1\\n                l-=1\\n            elif(d==1):\\n                for i in range(t,b+1):\\n                    if matrix[i][r]==-1:\\n                        matrix[i][r]=0\\n                        ans.append([i,r])\\n                        ct+=1\\n                d=2\\n                t-=1\\n            elif(d==2):\\n                for i in reversed(range(l,r+1)):\\n                    if matrix[b][i]==-1:\\n                        ans.append([b,i])\\n                        matrix[b][i]=0\\n                        ct+=1\\n                r+=1\\n                d=3\\n            elif(d==3):\\n                for i in reversed(range(t,b+1)):\\n                    if matrix[i][l]==-1:\\n                        ans.append([i,l])\\n                        matrix[i][l]=0\\n                        ct+=1\\n                b+=1\\n                d=0\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "\\n    def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> List[List[int]]:\\n        matrix = [[-1 for i in range(cols)] for j in range(rows)]\\n        if rows==0:\\n            return []\\n        t=rStart\\n        ans=[]\\n        b=t+1\\n        l=cStart\\n        r=l+1\\n        d=0\\n        ct=1\\n        while ct<=rows*cols:\\n            if l<=0:\\n                l=0\\n            if t<=0:\\n                t=0\\n            if r>=cols-1:\\n                r=cols-1\\n            if b>=rows-1:\\n                b=rows-1\\n            if(d==0):\\n                for i in range(l,r+1):\\n                    if matrix[t][i]==-1:\\n                        ans.append([t,i])\\n                        matrix[t][i]=0\\n                        ct+=1\\n                d=1\\n                l-=1\\n            elif(d==1):\\n                for i in range(t,b+1):\\n                    if matrix[i][r]==-1:\\n                        matrix[i][r]=0\\n                        ans.append([i,r])\\n                        ct+=1\\n                d=2\\n                t-=1\\n            elif(d==2):\\n                for i in reversed(range(l,r+1)):\\n                    if matrix[b][i]==-1:\\n                        ans.append([b,i])\\n                        matrix[b][i]=0\\n                        ct+=1\\n                r+=1\\n                d=3\\n            elif(d==3):\\n                for i in reversed(range(t,b+1)):\\n                    if matrix[i][l]==-1:\\n                        ans.append([i,l])\\n                        matrix[i][l]=0\\n                        ct+=1\\n                b+=1\\n                d=0\\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3509589,
                "title": "java-solution-with-approach",
                "content": "# Intuition\\nfor solving spiral matrix III you should be able to solve spiral matrix I and II \\ncheckout my solution link for spiral matrix I and II with the same approach I have solved spiral matrix III with little changes.\\n\\nspiral matrix I :-https://leetcode.com/problems/spiral-matrix/solutions/3506074/easy-beats-100-java-while-loop/?orderBy=most_votes\\n\\nspiral matrix II :-https://leetcode.com/problems/spiral-matrix-ii/solutions/3509420/easy-java-solution-with-explanation/?orderBy=most_votes\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n     int[] a1 = new int[rows*cols];\\n     int[] a2 = new int[rows*cols];\\n     int[][] arr = new int[rows*cols][2];\\n     int add=0;\\n     int i1=0;\\n     int index=0;\\n\\n\\n     while(add!=rows*cols){\\n     int c1=cStart+1; // in spiral matrix III loop conditions and \\n     int c2=cStart-1; //dependent on both i1 and these 4 variables\\n     int r1=rStart+1;\\n     int r2=rStart-1;\\n\\n\\n         int i=rStart-i1;\\n         int j=cStart-i1;\\n            if(i<rows&&i>=0&&j<cols&&j>=0){\\n                a1[index]=i;// add first element \\n                a2[index]=j;\\n                index++;\\n                add++;\\n            }    \\n         if(add==rows*cols){\\n             add(arr,a1,a2); // when this condition becomes true we \\n             return arr;     //got our answer \\n         }\\n         j++;\\n         c1=c1+i1;\\n\\n\\n         while(j<=c1){//first while loop going right\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n            a1[index]=i;\\n            a2[index]=j;\\n            index++;\\n            add++;\\n             }\\n             if(add==rows*cols){ // check each time\\n             add(arr,a1,a2);     // you can write function for that\\n             return arr;\\n         }\\n             j++;\\n         }\\n         j--;\\n         i++;\\n         r1=r1+i1;\\n\\n\\n         while(i<=r1){//second while loop going down\\n             if(i<rows && i>=0 && j<cols && j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i++;             \\n         }\\n         i--;\\n         j--;\\n         c2=c2-i1;\\n\\n\\n         while(j>=c2){//third while loop going left\\n             if(i<rows&&i>=0&&j<cols&&j>=0){ \\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         j--;            \\n         }  \\n         j++;\\n         i--;\\n         r2=r2-i1;\\n\\n\\n         while(i>r2){//fourth while  loop going up\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i--;        \\n         }\\n\\n\\n         i1++;     // i1 variable which is deciding all conditions\\n            // of the loop and increasing by one in each iteration\\n\\n     }\\n     return arr;\\n    }\\n    public static void add(int[][] arr ,int[] a1,int[] a2){\\n        for(int i=0;i<a1.length;i++){\\n            arr[i][0]=a1[i];\\n            arr[i][1]=a2[i];\\n        }\\n    }\\n\\n    public static boolean \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n     int[] a1 = new int[rows*cols];\\n     int[] a2 = new int[rows*cols];\\n     int[][] arr = new int[rows*cols][2];\\n     int add=0;\\n     int i1=0;\\n     int index=0;\\n\\n\\n     while(add!=rows*cols){\\n     int c1=cStart+1; // in spiral matrix III loop conditions and \\n     int c2=cStart-1; //dependent on both i1 and these 4 variables\\n     int r1=rStart+1;\\n     int r2=rStart-1;\\n\\n\\n         int i=rStart-i1;\\n         int j=cStart-i1;\\n            if(i<rows&&i>=0&&j<cols&&j>=0){\\n                a1[index]=i;// add first element \\n                a2[index]=j;\\n                index++;\\n                add++;\\n            }    \\n         if(add==rows*cols){\\n             add(arr,a1,a2); // when this condition becomes true we \\n             return arr;     //got our answer \\n         }\\n         j++;\\n         c1=c1+i1;\\n\\n\\n         while(j<=c1){//first while loop going right\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n            a1[index]=i;\\n            a2[index]=j;\\n            index++;\\n            add++;\\n             }\\n             if(add==rows*cols){ // check each time\\n             add(arr,a1,a2);     // you can write function for that\\n             return arr;\\n         }\\n             j++;\\n         }\\n         j--;\\n         i++;\\n         r1=r1+i1;\\n\\n\\n         while(i<=r1){//second while loop going down\\n             if(i<rows && i>=0 && j<cols && j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i++;             \\n         }\\n         i--;\\n         j--;\\n         c2=c2-i1;\\n\\n\\n         while(j>=c2){//third while loop going left\\n             if(i<rows&&i>=0&&j<cols&&j>=0){ \\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         j--;            \\n         }  \\n         j++;\\n         i--;\\n         r2=r2-i1;\\n\\n\\n         while(i>r2){//fourth while  loop going up\\n             if(i<rows&&i>=0&&j<cols&&j>=0){\\n         a1[index]=i;\\n         a2[index]=j;\\n         index++;\\n         add++;\\n             }\\n          if(add==rows*cols){\\n             add(arr,a1,a2);\\n             return arr;\\n         }\\n         i--;        \\n         }\\n\\n\\n         i1++;     // i1 variable which is deciding all conditions\\n            // of the loop and increasing by one in each iteration\\n\\n     }\\n     return arr;\\n    }\\n    public static void add(int[][] arr ,int[] a1,int[] a2){\\n        for(int i=0;i<a1.length;i++){\\n            arr[i][0]=a1[i];\\n            arr[i][1]=a2[i];\\n        }\\n    }\\n\\n    public static boolean \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509429,
                "title": "clean-and-explanined-one-past-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * n) as it would just visit each of the item in the matrix for once.(I did vertify my thinking with Chat GPT)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) as constant of the space was used\\n\\n# Code\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  //as mention in the editorial, we walk in 1,1,2,2,3,3 ... \\n  //and so on pattern, so the step is used to count \\n  //the step before turning\\n  let step = 1;\\n\\n  let curStep = 0;\\n  let turnCount = 0;\\n  //turnCount is used to indicate which direction is moving, \\n  //if it is 0, it means moving right as direction[turnCount] = [0,1]\\n  let ans = [[rStart, cStart]];\\n\\n  let sr = rStart, sc = cStart;\\n\\n  const direction = [[0,1],[1,0],[0,-1],[-1,0]];\\n\\n  while(ans.length < rows * cols){\\n    curStep = step;\\n    while(curStep){\\n      const [dx, dy] = direction[turnCount];\\n      sr += dx;\\n      sc += dy;\\n      if(sr >=0 && sr < rows && sc >= 0 && sc < cols){\\n        ans.push([sr, sc]);\\n      }\\n      curStep--;\\n    }\\n    turnCount = (turnCount + 1) % direction.length;\\n\\n    //the number of step is increased when the direction is moving left or right,\\n    //which means direction[2] || direction[0] on the direction array    \\n    if(turnCount === 2 || turnCount === 0){\\n      step++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n  //as mention in the editorial, we walk in 1,1,2,2,3,3 ... \\n  //and so on pattern, so the step is used to count \\n  //the step before turning\\n  let step = 1;\\n\\n  let curStep = 0;\\n  let turnCount = 0;\\n  //turnCount is used to indicate which direction is moving, \\n  //if it is 0, it means moving right as direction[turnCount] = [0,1]\\n  let ans = [[rStart, cStart]];\\n\\n  let sr = rStart, sc = cStart;\\n\\n  const direction = [[0,1],[1,0],[0,-1],[-1,0]];\\n\\n  while(ans.length < rows * cols){\\n    curStep = step;\\n    while(curStep){\\n      const [dx, dy] = direction[turnCount];\\n      sr += dx;\\n      sc += dy;\\n      if(sr >=0 && sr < rows && sc >= 0 && sc < cols){\\n        ans.push([sr, sc]);\\n      }\\n      curStep--;\\n    }\\n    turnCount = (turnCount + 1) % direction.length;\\n\\n    //the number of step is increased when the direction is moving left or right,\\n    //which means direction[2] || direction[0] on the direction array    \\n    if(turnCount === 2 || turnCount === 0){\\n      step++;\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3509096,
                "title": "java-code-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe simple approach that comes to mind is traverse in spiral direction from the current position, if we are within matrix are we will add that to our ans otherwise ignore, this way we will cover all indexes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstart from current index and start traversing in spiral way,\\nComments are added in code for more clarity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nif size of matrix is X then max we will iterate 4*X indexes.\\nO(4*X)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(X)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        //set the size of matrix -1 because we already visited one position\\n        int size = rows*cols-1;\\n        //shift is the number of steps in one direction, we can also say one side of rectangle\\n        int shift = 1;\\n        //when to increase shift, we will increase shift after completing two sides\\n        boolean increaseShift = false;\\n        //op stands for operation, operations means the direction of traversal\\n        int op = 1;\\n        //start and end point\\n        int x=rStart;\\n        int y=cStart;\\n        //array to store ans\\n        int[][] ans = new int[size+1][2];\\n        //index of ans array\\n        int idx=0;\\n        //count of steps in one particular direction\\n        int currentCount=0;\\n        //we add the current position\\n        ans[idx][0]=rStart;\\n        ans[idx][1]=cStart;\\n        idx++;\\n        while(size>0){\\n            if(op==1){\\n                y++;\\n            }else if(op==2){\\n                x++;\\n            }else if(op==3){\\n                y--;\\n            }else if(op==4){\\n                x--;\\n            }\\n            //increase the count in this direction\\n            currentCount++;\\n            //if position is within our range then add to ans\\n            if(inRange(rows,cols,x,y)){\\n                    ans[idx][0]=x;\\n                    ans[idx][1]=y;\\n                    idx++;\\n                    size--;\\n            }\\n            //if current count is equal to max steps then...\\n            if(currentCount==shift){\\n                currentCount=0; //reset\\n                op++;   //change direction\\n                op=op%4;\\n                if(op==0){\\n                    op=4;\\n                }\\n                if(!increaseShift){ //logic to increase shift\\n                    increaseShift=true;\\n                }else{\\n                    increaseShift=false;\\n                    shift++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean inRange(int rows, int cols, int x, int y){\\n        if(x<0 || x>=rows){\\n            return false;\\n        }\\n        if(y<0 || y>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        //set the size of matrix -1 because we already visited one position\\n        int size = rows*cols-1;\\n        //shift is the number of steps in one direction, we can also say one side of rectangle\\n        int shift = 1;\\n        //when to increase shift, we will increase shift after completing two sides\\n        boolean increaseShift = false;\\n        //op stands for operation, operations means the direction of traversal\\n        int op = 1;\\n        //start and end point\\n        int x=rStart;\\n        int y=cStart;\\n        //array to store ans\\n        int[][] ans = new int[size+1][2];\\n        //index of ans array\\n        int idx=0;\\n        //count of steps in one particular direction\\n        int currentCount=0;\\n        //we add the current position\\n        ans[idx][0]=rStart;\\n        ans[idx][1]=cStart;\\n        idx++;\\n        while(size>0){\\n            if(op==1){\\n                y++;\\n            }else if(op==2){\\n                x++;\\n            }else if(op==3){\\n                y--;\\n            }else if(op==4){\\n                x--;\\n            }\\n            //increase the count in this direction\\n            currentCount++;\\n            //if position is within our range then add to ans\\n            if(inRange(rows,cols,x,y)){\\n                    ans[idx][0]=x;\\n                    ans[idx][1]=y;\\n                    idx++;\\n                    size--;\\n            }\\n            //if current count is equal to max steps then...\\n            if(currentCount==shift){\\n                currentCount=0; //reset\\n                op++;   //change direction\\n                op=op%4;\\n                if(op==0){\\n                    op=4;\\n                }\\n                if(!increaseShift){ //logic to increase shift\\n                    increaseShift=true;\\n                }else{\\n                    increaseShift=false;\\n                    shift++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean inRange(int rows, int cols, int x, int y){\\n        if(x<0 || x>=rows){\\n            return false;\\n        }\\n        if(y<0 || y>=cols){\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508974,
                "title": "50-long-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlet go = ([r, c]: number[], direction: \"u\" | \"d\" | \"l\" | \"r\") => {\\n    switch (direction) {\\n        case \"u\":\\n            return [r-1, c]\\n        case \"d\":\\n            return [r+1, c]\\n        case \"l\":\\n            return [r, c-1]\\n        case \"r\":\\n            return [r, c+1]\\n        default:\\n            return [r, c]\\n    }\\n}\\n\\nlet convertToOrgCoords = ([r,c]: number[], [expandedXLength, expandedYLength]: number[]) => {\\n    return [r-expandedYLength, c-expandedXLength]\\n}\\n\\nlet isOutOfBound = ([r,c]: number[], rows: number, cols: number):boolean => {\\n    if(r < 0 || r >= rows) return true;\\n    if(c < 0 || c >= cols) return true;\\n    return false;\\n}\\n\\n\\nlet getExpandedCoords = (rows: number, cols: number, rStart: number, cStart: number): number[][] => {\\n    let leftLength = cStart;\\n    let rightLength = cols-cStart-1;\\n    let maxXAxis = Math.max(leftLength, rightLength);\\n    let topLength = rStart;\\n    let bottomLength = rows-rStart-1;\\n    let maxYAxis = Math.max(topLength, bottomLength);\\n    let maxLength = Math.max(maxXAxis, maxYAxis);\\n    let expandedXLength = maxLength-cStart;\\n    let expandedYLength = maxLength-rStart;\\n    // console.log(maxLength, maxXAxis, maxYAxis)\\n    return [[maxLength, maxLength], [expandedXLength, expandedYLength]];\\n}\\n\\nfunction spiralMatrixIII(rows: number, cols: number, rStart: number, cStart: number): number[][] {\\n    let res: number[][] = []\\n    let l = Math.max(cStart, rStart)*2+1;\\n    let [startCoords, expandedLength] = getExpandedCoords(rows, cols, rStart, cStart);\\n    // console.log(expandedLength)\\n    res.push(convertToOrgCoords(startCoords, expandedLength));\\n    let step = 1;\\n    let direction: (\"u\" | \"d\" | \"l\" | \"r\")[] = [\"r\", \"d\", \"l\", \"u\"];\\n    let t = rows*cols;\\n    if(res.length === t) return res;\\n    // let z = 0\\n    let coords = startCoords;\\n    while(true) {\\n    // while(z<2) {\\n        // z++;\\n        for(let i=0; i<4; i++) {\\n            for(let j=0; j<step; j++) {\\n                coords = go(coords, direction[i])\\n                let orgCoords = convertToOrgCoords(coords, expandedLength)\\n                if(isOutOfBound(orgCoords, rows, cols)) continue;\\n                res.push(orgCoords);\\n                if(res.length === t) return res;\\n                // console.log(orgCoords, coords)\\n            }\\n            if(i === 1) step++;\\n        }\\n        step++;\\n        // console.log(res)\\n        // break;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nlet go = ([r, c]: number[], direction: \"u\" | \"d\" | \"l\" | \"r\") => {\\n    switch (direction) {\\n        case \"u\":\\n            return [r-1, c]\\n        case \"d\":\\n            return [r+1, c]\\n        case \"l\":\\n            return [r, c-1]\\n        case \"r\":\\n            return [r, c+1]\\n        default:\\n            return [r, c]\\n    }\\n}\\n\\nlet convertToOrgCoords = ([r,c]: number[], [expandedXLength, expandedYLength]: number[]) => {\\n    return [r-expandedYLength, c-expandedXLength]\\n}\\n\\nlet isOutOfBound = ([r,c]: number[], rows: number, cols: number):boolean => {\\n    if(r < 0 || r >= rows) return true;\\n    if(c < 0 || c >= cols) return true;\\n    return false;\\n}\\n\\n\\nlet getExpandedCoords = (rows: number, cols: number, rStart: number, cStart: number): number[][] => {\\n    let leftLength = cStart;\\n    let rightLength = cols-cStart-1;\\n    let maxXAxis = Math.max(leftLength, rightLength);\\n    let topLength = rStart;\\n    let bottomLength = rows-rStart-1;\\n    let maxYAxis = Math.max(topLength, bottomLength);\\n    let maxLength = Math.max(maxXAxis, maxYAxis);\\n    let expandedXLength = maxLength-cStart;\\n    let expandedYLength = maxLength-rStart;\\n    // console.log(maxLength, maxXAxis, maxYAxis)\\n    return [[maxLength, maxLength], [expandedXLength, expandedYLength]];\\n}\\n\\nfunction spiralMatrixIII(rows: number, cols: number, rStart: number, cStart: number): number[][] {\\n    let res: number[][] = []\\n    let l = Math.max(cStart, rStart)*2+1;\\n    let [startCoords, expandedLength] = getExpandedCoords(rows, cols, rStart, cStart);\\n    // console.log(expandedLength)\\n    res.push(convertToOrgCoords(startCoords, expandedLength));\\n    let step = 1;\\n    let direction: (\"u\" | \"d\" | \"l\" | \"r\")[] = [\"r\", \"d\", \"l\", \"u\"];\\n    let t = rows*cols;\\n    if(res.length === t) return res;\\n    // let z = 0\\n    let coords = startCoords;\\n    while(true) {\\n    // while(z<2) {\\n        // z++;\\n        for(let i=0; i<4; i++) {\\n            for(let j=0; j<step; j++) {\\n                coords = go(coords, direction[i])\\n                let orgCoords = convertToOrgCoords(coords, expandedLength)\\n                if(isOutOfBound(orgCoords, rows, cols)) continue;\\n                res.push(orgCoords);\\n                if(res.length === t) return res;\\n                // console.log(orgCoords, coords)\\n            }\\n            if(i === 1) step++;\\n        }\\n        step++;\\n        // console.log(res)\\n        // break;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3508609,
                "title": "spiral-walking-using-point-direction-datatypes",
                "content": "# Approach\\nUses Direction and Point datatypes. Walk in a spiral by keeping track of `step_count` and `step_length`. When changing direction from Up or Down, the `step_length` increases by `1`. \\n\\nOnly push to the `output` array if the input is within the bounds.\\n\\nTerminate when the number of steps walked in a single direction is larger than `n`.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {\\n        let n = i32::max(r_start + rows, c_start + cols) * 2;\\n\\n        let mut output: Vec<Vec<i32>> = vec![];\\n        let mut position = Point {\\n            x: c_start,\\n            y: r_start,\\n        };\\n        let mut direction = Direction::Right;\\n        let (mut step_length, mut step_count) = (1, 0);\\n\\n        loop {\\n            if position.x >= 0 && position.x < cols && position.y >= 0 && position.y < rows {\\n                output.push(vec![position.y, position.x]);\\n            }\\n            position = position.next_point(&direction);\\n            step_count += 1;\\n\\n            if step_count >= step_length {\\n                step_count = 0;\\n                if direction == Direction::Down || direction == Direction::Up {\\n                    step_length += 1;\\n                }\\n                direction = direction.next();\\n            }\\n            if step_count > n {\\n                break;\\n            }\\n        }\\n\\n        output\\n    }\\n}\\n\\n#[derive(PartialEq, Eq)]\\nenum Direction {\\n    Right,\\n    Down,\\n    Left,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn next(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Down,\\n            Direction::Down => Direction::Left,\\n            Direction::Left => Direction::Up,\\n            Direction::Up => Direction::Right,\\n        }\\n    }\\n}\\n\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    pub fn next_point(&self, direction: &Direction) -> Point {\\n        match direction {\\n            Direction::Right => Point {\\n                x: self.x + 1,\\n                y: self.y,\\n            },\\n            Direction::Down => Point {\\n                x: self.x,\\n                y: self.y + 1,\\n            },\\n            Direction::Left => Point {\\n                x: self.x - 1,\\n                y: self.y,\\n            },\\n            Direction::Up => Point {\\n                x: self.x,\\n                y: self.y - 1,\\n            },\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {\\n        let n = i32::max(r_start + rows, c_start + cols) * 2;\\n\\n        let mut output: Vec<Vec<i32>> = vec![];\\n        let mut position = Point {\\n            x: c_start,\\n            y: r_start,\\n        };\\n        let mut direction = Direction::Right;\\n        let (mut step_length, mut step_count) = (1, 0);\\n\\n        loop {\\n            if position.x >= 0 && position.x < cols && position.y >= 0 && position.y < rows {\\n                output.push(vec![position.y, position.x]);\\n            }\\n            position = position.next_point(&direction);\\n            step_count += 1;\\n\\n            if step_count >= step_length {\\n                step_count = 0;\\n                if direction == Direction::Down || direction == Direction::Up {\\n                    step_length += 1;\\n                }\\n                direction = direction.next();\\n            }\\n            if step_count > n {\\n                break;\\n            }\\n        }\\n\\n        output\\n    }\\n}\\n\\n#[derive(PartialEq, Eq)]\\nenum Direction {\\n    Right,\\n    Down,\\n    Left,\\n    Up,\\n}\\n\\nimpl Direction {\\n    pub fn next(&self) -> Direction {\\n        match self {\\n            Direction::Right => Direction::Down,\\n            Direction::Down => Direction::Left,\\n            Direction::Left => Direction::Up,\\n            Direction::Up => Direction::Right,\\n        }\\n    }\\n}\\n\\nstruct Point {\\n    x: i32,\\n    y: i32,\\n}\\n\\nimpl Point {\\n    pub fn next_point(&self, direction: &Direction) -> Point {\\n        match direction {\\n            Direction::Right => Point {\\n                x: self.x + 1,\\n                y: self.y,\\n            },\\n            Direction::Down => Point {\\n                x: self.x,\\n                y: self.y + 1,\\n            },\\n            Direction::Left => Point {\\n                x: self.x - 1,\\n                y: self.y,\\n            },\\n            Direction::Up => Point {\\n                x: self.x,\\n                y: self.y - 1,\\n            },\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506810,
                "title": "easy-brute-force-with-explaination",
                "content": "# Intuition\\nIf we observer the path:\\n\\nmove right 1 step, turn right\\nmove down 1 step, turn right\\nmove left 2 steps, turn right\\nmove top 2 steps, turn right,\\nmove right 3 steps, turn right\\nmove down 3 steps, turn right\\nmove left 4 steps, turn right\\nmove top 4 steps, turn right,\\n\\nwe can find the sequence of steps: 1,1,2,2,3,3,4,4,5,5....\\n\\nThus, the length variable keeps changing after 2 steps, i.e, 1,1 then 2,2 then 3,3 and so on.\\n\\n# Code\\n```\\nclass Solution {\\n    int index;\\n    int[][] ans;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ans[index][0] = r;\\n        ans[index][1] = c;\\n        index++;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ans= new int[R * C][2];\\n        while (index < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int index;\\n    int[][] ans;\\n    \\n    private void add (int r, int c, int R, int C) {\\n        if (r >= R || r < 0 || c >= C || c < 0) return;\\n        ans[index][0] = r;\\n        ans[index][1] = c;\\n        index++;\\n    }\\n    \\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\\n        int r = r0, c = c0, len = 1;\\n        ans= new int[R * C][2];\\n        while (index < (R * C )) {         \\n            for (int k = 0; k < len; k++) add(r, c++, R, C);          \\n            for (int k = 0; k < len; k++) add(r++, c, R, C);\\n            len++;\\n            for (int k = 0; k < len; k++) add(r, c--, R, C);\\n            for (int k = 0; k < len; k++) add(r--, c, R, C);\\n            len++;   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504838,
                "title": "javascript-easy-understanding-solution",
                "content": "# Intuition\\nUse 4 while loop to move from top left to top right, top right to bottom right, bottom right to bottom left and bottom left to top left. We will travel each edge in 1 while loop and then extend the bound until it reach the border.\\n\\n# Code\\n```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let res = [];\\n    let leftCol = cStart, rightCol = cStart;\\n    let topRow = rStart, bottomRow = rStart;\\n    let i = rStart, j = cStart;\\n    let visit = {};\\n    while (1) {\\n        rightCol = rightCol + 1 === cols ? rightCol : rightCol + 1;\\n        while (j <= rightCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j++;\\n        }\\n        j--;\\n        if (res.length === rows * cols) break;\\n        bottomRow = bottomRow + 1 === rows ? bottomRow : bottomRow + 1;\\n        while (i <= bottomRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i++;\\n        }\\n        i--;\\n        if (res.length === rows * cols) break;\\n        leftCol = leftCol === 0 ? 0 : leftCol - 1;\\n        while (j >= leftCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j--;\\n        }\\n        j++;\\n        if (res.length === rows * cols) break;\\n        topRow = topRow === 0 ? 0 : topRow - 1;\\n        while (i >= topRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i--;\\n        }\\n        i++;\\n        if (res.length === rows * cols) break;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} rows\\n * @param {number} cols\\n * @param {number} rStart\\n * @param {number} cStart\\n * @return {number[][]}\\n */\\nvar spiralMatrixIII = function(rows, cols, rStart, cStart) {\\n    let res = [];\\n    let leftCol = cStart, rightCol = cStart;\\n    let topRow = rStart, bottomRow = rStart;\\n    let i = rStart, j = cStart;\\n    let visit = {};\\n    while (1) {\\n        rightCol = rightCol + 1 === cols ? rightCol : rightCol + 1;\\n        while (j <= rightCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j++;\\n        }\\n        j--;\\n        if (res.length === rows * cols) break;\\n        bottomRow = bottomRow + 1 === rows ? bottomRow : bottomRow + 1;\\n        while (i <= bottomRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i++;\\n        }\\n        i--;\\n        if (res.length === rows * cols) break;\\n        leftCol = leftCol === 0 ? 0 : leftCol - 1;\\n        while (j >= leftCol){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            j--;\\n        }\\n        j++;\\n        if (res.length === rows * cols) break;\\n        topRow = topRow === 0 ? 0 : topRow - 1;\\n        while (i >= topRow){\\n            if (visit[[i, j]] === undefined) res.push([i, j]);\\n            visit[[i, j]] = true;\\n            i--;\\n        }\\n        i++;\\n        if (res.length === rows * cols) break;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3503916,
                "title": "c-112233-sequence-observation-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nObservation of Sequence 11223344......\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Variables: i -> Row, j -> col, k -> sequence number**\\n1) put (r, c) in ans.\\n2) then observe that every time we take \"k\" number of row\\'s OR col\\'s elements either in right or left side(For Row) OR top or down side(For Col). \\n3) Upper codition manages to generate the spiral.\\n4) We take those indices only which are in the grid, For that we applied codition(ok(i, j)).\\n7) If size of \"ans\" becomes (n*m) means we took elements of grid then we break(Here, \"done\" Do that which is nothing but #define....).\\n8) Try to do Dry Run by yourself for \"k\" values upto 4 it will be more clear.\\n \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * M)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N * M)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define done {if(ans.size() == n * m) break;}\\n    \\n    int N, M;\\n    bool ok(int i, int j)\\n    {\\n        return (i >= 0 && j >= 0 && i < N && j < M);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int r, int c) {\\n        N = n, M = m;\\n        vector<vector<int>> ans;\\n        int i = r, j = c + 1, k = 1;\\n        ans.push_back({r, c});\\n        while(1)\\n        {\\n            done;\\n\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j++;\\n            }\\n            j--;\\n\\n            done;\\n\\n            i++;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i++;\\n            }\\n            i--;\\n            \\n            done;\\n            k++;\\n\\n            j--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j--;\\n            }\\n            j++;\\n            \\n            done;\\n\\n            i--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i--;\\n            }\\n            i++;\\n\\n            done;\\n            k++;\\n\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define done {if(ans.size() == n * m) break;}\\n    \\n    int N, M;\\n    bool ok(int i, int j)\\n    {\\n        return (i >= 0 && j >= 0 && i < N && j < M);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int n, int m, int r, int c) {\\n        N = n, M = m;\\n        vector<vector<int>> ans;\\n        int i = r, j = c + 1, k = 1;\\n        ans.push_back({r, c});\\n        while(1)\\n        {\\n            done;\\n\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j++;\\n            }\\n            j--;\\n\\n            done;\\n\\n            i++;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i++;\\n            }\\n            i--;\\n            \\n            done;\\n            k++;\\n\\n            j--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                j--;\\n            }\\n            j++;\\n            \\n            done;\\n\\n            i--;\\n            for(int l = 1; l <= k; l++)\\n            {\\n                if(ok(i, j)) ans.push_back({i, j});\\n                if(ans.size() == n * m) break;\\n                i--;\\n            }\\n            i++;\\n\\n            done;\\n            k++;\\n\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503860,
                "title": "c-simple-and-understandable-solution-two-pointers",
                "content": "# Intuition\\nFirst of all, set the left and right pointer as cStart and up and down pointer as rStart.And initialize num as 0 to keep track of element we have visited.\\nThen do the following in the different blocks:\\n//Upper Block (dir=0)\\n    Traverse it from left to right keeping **\"up\"** pointer as constant and after it increment the **\"right\"** pointer by 1. \\n//Right Block (dir=1)\\n    Traverse it from up to down keeping **\"right\"** pointer as constant and after it increment the **\"down\"** pointer by 1. \\n//Lower Block (dir=2)\\n    Traverse it from right to left keeping **\"down\"** pointer as constant and after it decrement the **\"left\"** pointer by 1. \\n//Left Block (dir=3)\\n    Traverse it from down to up keeping **\"left\"** pointer as constant and after it decrement the **\"up\"** pointer by 1.\\n**Note :-** Before traversing any block, check whether it(left,right,up,down) lies in the matrix or not. \\n# Approach\\nTwo pointers.\\n\\n# Complexity\\n- Time complexity:\\n    O(rows*cols)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result(rows*cols,vector<int>(2,0));\\n        int left=cStart,right=cStart,up=rStart,down=rStart;\\n        int dir=0,num=0;\\n        while (num < rows*cols){\\n            //upper block\\n            if (dir==0){\\n                if (up>=0){\\n                    for (int i=max(left,0);i<=min(right,cols-1);i++){\\n                        result[num][0]=up;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                right++;\\n            }\\n            //right block\\n            if (dir==1){\\n                if (right<cols){\\n                    for (int i=max(up,0);i<=min(down,rows-1);i++){\\n                        result[num][0]=i;\\n                        result[num][1]=right;\\n                        num++;\\n                    }\\n                }\\n                down++;\\n            }\\n            //lower block\\n            if (dir==2){\\n                if (down < rows){\\n                    for (int i=min(right,cols-1);i>=max(left,0);i--){\\n                        result[num][0]=down;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                left--;\\n            }\\n            //left block\\n            if (dir==3){\\n                if (left>=0){\\n                    for (int i=min(down,rows-1);i>=max(up,0);i--){\\n                        result[num][0]=i;\\n                        result[num][1]=left;\\n                        num++;\\n                    }\\n                }\\n                up--;\\n            }\\n            dir++;\\n            if (dir==4)\\n                dir=0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> result(rows*cols,vector<int>(2,0));\\n        int left=cStart,right=cStart,up=rStart,down=rStart;\\n        int dir=0,num=0;\\n        while (num < rows*cols){\\n            //upper block\\n            if (dir==0){\\n                if (up>=0){\\n                    for (int i=max(left,0);i<=min(right,cols-1);i++){\\n                        result[num][0]=up;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                right++;\\n            }\\n            //right block\\n            if (dir==1){\\n                if (right<cols){\\n                    for (int i=max(up,0);i<=min(down,rows-1);i++){\\n                        result[num][0]=i;\\n                        result[num][1]=right;\\n                        num++;\\n                    }\\n                }\\n                down++;\\n            }\\n            //lower block\\n            if (dir==2){\\n                if (down < rows){\\n                    for (int i=min(right,cols-1);i>=max(left,0);i--){\\n                        result[num][0]=down;\\n                        result[num][1]=i;\\n                        num++;\\n                    }\\n                }\\n                left--;\\n            }\\n            //left block\\n            if (dir==3){\\n                if (left>=0){\\n                    for (int i=min(down,rows-1);i>=max(up,0);i--){\\n                        result[num][0]=i;\\n                        result[num][1]=left;\\n                        num++;\\n                    }\\n                }\\n                up--;\\n            }\\n            dir++;\\n            if (dir==4)\\n                dir=0;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476884,
                "title": "c-simply-traverse-as-directed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFollow path as directed.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhile following spiral path, if row and col falls on matrix, add to answer vector.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int r = rStart, c = cStart;\\n        int step = 1, dir = 1;\\n        ans.push_back({r,c});\\n        while (ans.size() < rows*cols) {\\n            for (int i = 0; i < step; i++) {\\n                c += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            for (int i = 0; i < step; i++) {\\n                r += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            dir *= -1;\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        vector<vector<int>> ans;\\n        int r = rStart, c = cStart;\\n        int step = 1, dir = 1;\\n        ans.push_back({r,c});\\n        while (ans.size() < rows*cols) {\\n            for (int i = 0; i < step; i++) {\\n                c += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            for (int i = 0; i < step; i++) {\\n                r += dir;\\n                if (r >= 0 and r < rows and c >= 0 and c < cols)\\n                    ans.push_back({r,c});\\n            }\\n            dir *= -1;\\n            step++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456668,
                "title": "java-easy-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n       int[][] ans= new int[rows*cols][2];\\n       int rmax=rStart+1, cmax=cStart+1, j=0;\\n        while(j<ans.length){\\n            for(int i=cStart; i<cmax; i++){\\n                if(j>=ans.length || i>=cols || rStart<0){rStart=0; break;}\\n                ans[j][0]=rStart;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cStart--;\\n            for(int i=rStart; i<rmax; i++){\\n                if(j>=ans.length || i>=rows || cmax>=cols){cmax=cols-1; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cmax;\\n                j++;\\n            }\\n            rStart--;\\n            for(int i=cmax; i>cStart; i--){\\n                if(j>=ans.length || i<0  || rmax>=rows){rmax=rows-1; break;}\\n                ans[j][0]=rmax;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cmax++;\\n            for(int i=rmax; i>rStart; i--){\\n                if(j>=ans.length || i<0 || cStart<0){cStart=0; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cStart;\\n                j++;\\n            }\\n            rmax++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n       int[][] ans= new int[rows*cols][2];\\n       int rmax=rStart+1, cmax=cStart+1, j=0;\\n        while(j<ans.length){\\n            for(int i=cStart; i<cmax; i++){\\n                if(j>=ans.length || i>=cols || rStart<0){rStart=0; break;}\\n                ans[j][0]=rStart;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cStart--;\\n            for(int i=rStart; i<rmax; i++){\\n                if(j>=ans.length || i>=rows || cmax>=cols){cmax=cols-1; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cmax;\\n                j++;\\n            }\\n            rStart--;\\n            for(int i=cmax; i>cStart; i--){\\n                if(j>=ans.length || i<0  || rmax>=rows){rmax=rows-1; break;}\\n                ans[j][0]=rmax;\\n                ans[j][1]=i;\\n                j++;\\n            }\\n            cmax++;\\n            for(int i=rmax; i>rStart; i--){\\n                if(j>=ans.length || i<0 || cStart<0){cStart=0; break;}\\n                ans[j][0]=i;\\n                ans[j][1]=cStart;\\n                j++;\\n            }\\n            rmax++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454323,
                "title": "1-1-2-2-3-3-steps-firstly-right-down-n-then-left-up-simulation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m, int n, int i, int j)\\n    {\\n        if(i>=0 and i<m and j>=0 and j<n) return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rStart, int cStart) {\\n        vector<vector<int>>mat;\\n        int cnt = 1;\\n        int movement = 1;\\n        int i = rStart, j = cStart;\\n        bool rd = true;\\n        while(cnt <= m*n)\\n        {\\n            int curr = 0;\\n            if(rd)\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j++;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i++;\\n                    curr++;\\n                }\\n                rd = false;\\n                movement++;\\n            }\\n            else\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j--;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i--;\\n                    curr++;\\n                }\\n                rd = true;\\n                movement++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int m, int n, int i, int j)\\n    {\\n        if(i>=0 and i<m and j>=0 and j<n) return true;\\n        return false;\\n    }\\n    vector<vector<int>> spiralMatrixIII(int m, int n, int rStart, int cStart) {\\n        vector<vector<int>>mat;\\n        int cnt = 1;\\n        int movement = 1;\\n        int i = rStart, j = cStart;\\n        bool rd = true;\\n        while(cnt <= m*n)\\n        {\\n            int curr = 0;\\n            if(rd)\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j++;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i++;\\n                    curr++;\\n                }\\n                rd = false;\\n                movement++;\\n            }\\n            else\\n            {\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    j--;\\n                    curr++;\\n                }\\n                curr = 0;\\n                while(curr < movement)\\n                {\\n                    if(isValid(m, n, i, j))\\n                    {\\n                        mat.push_back({i, j});\\n                        cnt++;\\n                    }\\n                    i--;\\n                    curr++;\\n                }\\n                rd = true;\\n                movement++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447270,
                "title": "easy-clean-java-solution-directions",
                "content": "If we look at the spiral, the noOfElements written in different direction looks like 1, 1, 2, 2, 3, 3 ...\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        int totalElement = rows * cols;\\n\\n        // Result Matrix having rows equal to the totalElements\\n        int[][] resMatrix = new int[totalElement][2];\\n\\n        int i = rStart, j = cStart;\\n        int count = 1;\\n\\n        // trackes the noOfElements to be written in a particular direction\\n        int length = 1;\\n\\n        // this loop will run until all the elements are written\\n        while(count <= totalElement) {\\n\\n            // Looping through each direction and writing the length noOfElements in that direction\\n            for(Direction dir : Direction.values()) {\\n                for(int rep = 0; rep < length; rep++) {\\n                    if(i < rows && j < cols && i >=0 && j >= 0) {\\n                        resMatrix[count - 1][0] = i;\\n                        resMatrix[count - 1][1] = j;\\n                        count++;\\n                    }\\n                    i = i + dir.rMove;\\n                    j = j + dir.cMove;\\n                }\\n\\n                // the length will change after every two direction\\n                if(dir.ordinal() % 2 != 0) {\\n                    length++;\\n                }\\n            }\\n        }\\n        return resMatrix;\\n    }\\n\\n    enum Direction {\\n        RIGHT(0,1), DOWN(1,0), LEFT(0,-1), UP(-1,0);\\n\\n        // rMove, cMove: value to be added to the indexes to move to the next positon in a given direction\\n        final int rMove;\\n        final int cMove;\\n\\n        Direction(int rMove, int cMove) {\\n            this.rMove = rMove;\\n            this.cMove = cMove;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n\\n        int totalElement = rows * cols;\\n\\n        // Result Matrix having rows equal to the totalElements\\n        int[][] resMatrix = new int[totalElement][2];\\n\\n        int i = rStart, j = cStart;\\n        int count = 1;\\n\\n        // trackes the noOfElements to be written in a particular direction\\n        int length = 1;\\n\\n        // this loop will run until all the elements are written\\n        while(count <= totalElement) {\\n\\n            // Looping through each direction and writing the length noOfElements in that direction\\n            for(Direction dir : Direction.values()) {\\n                for(int rep = 0; rep < length; rep++) {\\n                    if(i < rows && j < cols && i >=0 && j >= 0) {\\n                        resMatrix[count - 1][0] = i;\\n                        resMatrix[count - 1][1] = j;\\n                        count++;\\n                    }\\n                    i = i + dir.rMove;\\n                    j = j + dir.cMove;\\n                }\\n\\n                // the length will change after every two direction\\n                if(dir.ordinal() % 2 != 0) {\\n                    length++;\\n                }\\n            }\\n        }\\n        return resMatrix;\\n    }\\n\\n    enum Direction {\\n        RIGHT(0,1), DOWN(1,0), LEFT(0,-1), UP(-1,0);\\n\\n        // rMove, cMove: value to be added to the indexes to move to the next positon in a given direction\\n        final int rMove;\\n        final int cMove;\\n\\n        Direction(int rMove, int cMove) {\\n            this.rMove = rMove;\\n            this.cMove = cMove;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438808,
                "title": "simpe-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int arr[][] = new int[rows*cols][2];\\n        int row=rStart, col=cStart;\\n        int rowLast = row, collast = col;\\n        int c=0;\\n        while(c<rows*cols)\\n        {\\n            collast++;\\n            if(row>=0)\\n            {\\n                for(int i=col; i<collast; i++)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=row;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            rowLast++;\\n            if(collast<cols)\\n            {\\n                for(int i=row; i<rowLast; i++)\\n                    if(i>=0 && i<rows)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=collast;\\n                    }\\n            }\\n            col--;\\n            if(rowLast<rows)\\n            {\\n                for(int i=collast; i>col; i--)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=rowLast;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            row--;\\n            if(col>=0)\\n            {\\n                for(int i=rowLast; i>row; i--)\\n                {\\n                    if(i>=0 && i<rows && c<rows*cols)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=col;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int arr[][] = new int[rows*cols][2];\\n        int row=rStart, col=cStart;\\n        int rowLast = row, collast = col;\\n        int c=0;\\n        while(c<rows*cols)\\n        {\\n            collast++;\\n            if(row>=0)\\n            {\\n                for(int i=col; i<collast; i++)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=row;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            rowLast++;\\n            if(collast<cols)\\n            {\\n                for(int i=row; i<rowLast; i++)\\n                    if(i>=0 && i<rows)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=collast;\\n                    }\\n            }\\n            col--;\\n            if(rowLast<rows)\\n            {\\n                for(int i=collast; i>col; i--)\\n                    if(i>=0 && i<cols)\\n                    {\\n                        arr[c][0]=rowLast;\\n                        arr[c++][1]=i;\\n                    }\\n            }\\n            row--;\\n            if(col>=0)\\n            {\\n                for(int i=rowLast; i>row; i--)\\n                {\\n                    if(i>=0 && i<rows && c<rows*cols)\\n                    {\\n                        arr[c][0]=i;\\n                        arr[c++][1]=col;\\n                    }\\n                }\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421247,
                "title": "java-soln-simulation",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] spiralMatrix = new int[rows * cols][2];\\n        \\n        int count = 1;\\n        int x = rStart;\\n        int y = cStart;\\n        int offset = Math.max(cStart, cols - cStart);\\n        int rightLimit = cStart + 2, downLimit = rStart + 2, leftLimit = cStart - 1, upLimit = rStart - 1;\\n        while(count <= rows * cols) {\\n            // right\\n            while(y < rightLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y <= rightLimit - 1) y++;\\n            }\\n            y--;\\n            \\n            // down\\n            x++;\\n            while(x < downLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x <= downLimit - 1) x++;\\n            }\\n            x--;\\n            \\n            // left\\n            y--;\\n            while(y >= leftLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y >= leftLimit) y--;\\n            }\\n            y++;\\n            \\n            // up\\n            x--;\\n            while(x >= upLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x >= upLimit) x--;\\n            }\\n            x++;\\n            \\n            y++;\\n            upLimit--;\\n            rightLimit++;\\n            downLimit++;\\n            leftLimit--;\\n        }\\n        \\n        return spiralMatrix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        int[][] spiralMatrix = new int[rows * cols][2];\\n        \\n        int count = 1;\\n        int x = rStart;\\n        int y = cStart;\\n        int offset = Math.max(cStart, cols - cStart);\\n        int rightLimit = cStart + 2, downLimit = rStart + 2, leftLimit = cStart - 1, upLimit = rStart - 1;\\n        while(count <= rows * cols) {\\n            // right\\n            while(y < rightLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y <= rightLimit - 1) y++;\\n            }\\n            y--;\\n            \\n            // down\\n            x++;\\n            while(x < downLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x <= downLimit - 1) x++;\\n            }\\n            x--;\\n            \\n            // left\\n            y--;\\n            while(y >= leftLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(y >= leftLimit) y--;\\n            }\\n            y++;\\n            \\n            // up\\n            x--;\\n            while(x >= upLimit) {\\n                if(x >= 0 && x < rows && y >= 0 && y < cols) {\\n                    spiralMatrix[count - 1][0] = x;\\n                    spiralMatrix[count - 1][1] = y;\\n                    count++;\\n                }\\n                if(x >= upLimit) x--;\\n            }\\n            x++;\\n            \\n            y++;\\n            upLimit--;\\n            rightLimit++;\\n            downLimit++;\\n            leftLimit--;\\n        }\\n        \\n        return spiralMatrix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391541,
                "title": "imperative-approach-python3",
                "content": "# Code\\n```\\n\\n        UP, RIGHT, DOWN, LEFT = 0, 1, 2, 3\\n        \\n        def switch(d):\\n            return {\\n                UP:    RIGHT,\\n                RIGHT:  DOWN,\\n                DOWN:   LEFT,\\n                LEFT:     UP\\n            }[d]\\n            \\n        def move(i, j, d):\\n            return {\\n                UP:     (i - 1,     j),\\n                RIGHT:  (    i, j + 1),\\n                DOWN:   (i + 1,     j),\\n                LEFT:   (    i, j - 1)\\n            }[d]\\n\\n        def valid(i, j, m, n):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        res       = [(i, j)]\\n        d         = RIGHT\\n        num_movs  = 1\\n        it        = 0\\n\\n        while len(res) < rows * cols:\\n            for _ in range(num_movs):\\n                i, j = move(i, j, d)\\n                if valid(i, j, rows, cols):\\n                    res.append((i, j))\\n\\n            num_movs  += it & 1          # Increment every two iterations\\n            d          = switch(d)\\n            it        += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n        UP, RIGHT, DOWN, LEFT = 0, 1, 2, 3\\n        \\n        def switch(d):\\n            return {\\n                UP:    RIGHT,\\n                RIGHT:  DOWN,\\n                DOWN:   LEFT,\\n                LEFT:     UP\\n            }[d]\\n            \\n        def move(i, j, d):\\n            return {\\n                UP:     (i - 1,     j),\\n                RIGHT:  (    i, j + 1),\\n                DOWN:   (i + 1,     j),\\n                LEFT:   (    i, j - 1)\\n            }[d]\\n\\n        def valid(i, j, m, n):\\n            return 0 <= i < m and 0 <= j < n\\n        \\n        res       = [(i, j)]\\n        d         = RIGHT\\n        num_movs  = 1\\n        it        = 0\\n\\n        while len(res) < rows * cols:\\n            for _ in range(num_movs):\\n                i, j = move(i, j, d)\\n                if valid(i, j, rows, cols):\\n                    res.append((i, j))\\n\\n            num_movs  += it & 1          # Increment every two iterations\\n            d          = switch(d)\\n            it        += 1\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3356529,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        vector<vector<int>>ans;\\n        int r=rStart;\\n        int c=cStart;\\n        int cnt=0;\\n        int steps=2;\\n        bool even=1;\\n        cnt++;\\n        ans.push_back({rStart,cStart});\\n        while(cnt<rows*cols)\\n        {\\n             if (even)\\n             {\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    c++;\\n                    if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        \\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    r++;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n             }\\n             else{\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                     c--;\\n                      if ( r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                    r--;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n             }\\n             steps++;\\n             even=1-even;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        vector<vector<int>>ans;\\n        int r=rStart;\\n        int c=cStart;\\n        int cnt=0;\\n        int steps=2;\\n        bool even=1;\\n        cnt++;\\n        ans.push_back({rStart,cStart});\\n        while(cnt<rows*cols)\\n        {\\n             if (even)\\n             {\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    c++;\\n                    if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        \\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n                for (int i=0;i<steps-1;i++)\\n                {\\n                    r++;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                }\\n             }\\n             else{\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                     c--;\\n                      if ( r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n                 for (int i=0;i<steps-1;i++)\\n                 {\\n                    r--;\\n                     if (r>=0 && c>=0 &&r<rows && c<cols)\\n                    {\\n                        ans.push_back({r,c});\\n                        cnt++;\\n                    }\\n                 }\\n             }\\n             steps++;\\n             even=1-even;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356397,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool liesInside(int r, int c, int rows, int cols)\\n    {\\n        return (r>=0 && r<rows && c>=0 && c<cols);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        int cnt=1;\\n        vector<vector<int>> ans;\\n        vector<int> v={rStart,cStart};\\n        ans.push_back(v);\\n        int count=0, d=0, steps=1;\\n        int r=rStart, c=cStart;\\n        while(cnt!=(rows*cols))\\n        {\\n            for(int x=1; x<=steps; x++)\\n            {\\n                if(d==0)\\n                {\\n                    c++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==1)\\n                {\\n                    r++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==2)\\n                {\\n                    c--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n                else\\n                {\\n                    r--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n            }\\n            count++;\\n            d=(d+1)%4;\\n            if(count%2==0) steps++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool liesInside(int r, int c, int rows, int cols)\\n    {\\n        return (r>=0 && r<rows && c>=0 && c<cols);\\n    }\\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, int rStart, int cStart) \\n    {\\n        int cnt=1;\\n        vector<vector<int>> ans;\\n        vector<int> v={rStart,cStart};\\n        ans.push_back(v);\\n        int count=0, d=0, steps=1;\\n        int r=rStart, c=cStart;\\n        while(cnt!=(rows*cols))\\n        {\\n            for(int x=1; x<=steps; x++)\\n            {\\n                if(d==0)\\n                {\\n                    c++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==1)\\n                {\\n                    r++;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    }\\n                }\\n                else if(d==2)\\n                {\\n                    c--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n                else\\n                {\\n                    r--;\\n                    if(liesInside(r,c,rows,cols)) \\n                    {\\n                        vector<int> v={r,c};\\n                        ans.push_back(v);\\n                        cnt++;\\n                    } \\n                }\\n            }\\n            count++;\\n            d=(d+1)%4;\\n            if(count%2==0) steps++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351492,
                "title": "simple-java-solution-using-while-loop-and-if-conditions",
                "content": "```\\nclass Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        char ch=\\'s\\';\\n        int r=0;\\n        int[][] ans=new int[rows*cols][2];\\n        ans[r][0]=rStart;\\n        ans[r][1]=cStart;r++;\\n        cStart++;\\n        int times=0;\\n        int i=1;\\n        while(i<(rows*cols)){\\n           if(ch==\\'s\\'){\\n               times=times+1;\\n               ch=\\'r\\';\\n           }\\n            else if(ch==\\'r\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                        ans[r][0]=rStart;\\n                        ans[r][1]=cStart;\\n                    \\n                    r++;i++;\\n                    }\\n                    cStart++;\\n                    temp--;\\n                }\\n                ch=\\'d\\';\\n                rStart++;\\n                cStart--;\\n            }\\n            else if(ch==\\'d\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    \\n                   r++;i++;}\\n                    rStart++;\\n                     temp--;\\n                }\\n                ch=\\'l\\';\\n                times=times+1;\\n                rStart--;\\n                cStart--;\\n            }\\n            else if(ch==\\'l\\'){\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    \\n                    r++;i++;\\n                }\\n                    cStart--;\\n                    temp--;\\n                }\\n                ch=\\'u\\';\\n                cStart++;\\n                rStart--;\\n            }\\n            else{\\n                int temp=times;\\n                while(temp>0){\\n                    if(rStart>=0 && rStart<rows&&cStart>=0&&cStart<cols){\\n                    ans[r][0]=rStart;\\n                    ans[r][1]=cStart;\\n                    r++;i++;\\n                }\\n                    rStart--;\\n                temp--;\\n                }\\n                ch=\\'r\\';\\n                times=times+1;\\n                rStart++;\\n                cStart++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[][] spiralMatrixIII(int rows, int cols, int rStart, int cStart) {\\n        char ch=\\'s\\';\\n        int r=0;\\n        int[][] ans=new int[rows*cols][2];\\n        ans[r][0]=rStart;\\n        ans[r][1]=cStart;r++;\\n        cStart++;\\n        int times=0;\\n        int i=1;\\n        while(i<(rows*cols)){\\n           if(ch==\\'s\\'){\\n               times=times+1;\\n               ch=\\'r\\';\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 3344671,
                "title": "crazy-code-will-blow-off-you-mind-c",
                "content": "# Intuition\\n<Moving in spiral and filling the value in v[t++] if ro and co lie in boundary>\\n\\n# Approach\\n<moving in a spiral ,.. with the help .of direction(d) and displacement(a)>\\n\\n# Complexity\\n- Time complexity:\\n<$$O(n^m)$$>\\n\\n- Space complexity:\\n<$$O(n*m)$$>\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrixIII(int row, int col, int ro, int co) {\\n    int n=row*col;\\n    vector<vector<int>>v(n);\\n    int a=1;\\n    int t=0;\\n    int d=1;\\n    int c;\\n    while(t<n){\\n        c=a;\\n        while(c--){ // moving right \\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            co+=d;\\n        }\\n        c=a;\\n        while(c--){  /// moving downward\\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            ro+=d;\\n        }\\n        d*=(-1); /// and we will change the direction \\n        a++; /// we will increase the distane we will now cover ..\\n    }\\n    return v;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> spiralMatrixIII(int row, int col, int ro, int co) {\\n    int n=row*col;\\n    vector<vector<int>>v(n);\\n    int a=1;\\n    int t=0;\\n    int d=1;\\n    int c;\\n    while(t<n){\\n        c=a;\\n        while(c--){ // moving right \\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            co+=d;\\n        }\\n        c=a;\\n        while(c--){  /// moving downward\\n            if(-1<ro && ro<row && -1<co && co<col){v[t++]={ro,co};}\\n            ro+=d;\\n        }\\n        d*=(-1); /// and we will change the direction \\n        a++; /// we will increase the distane we will now cover ..\\n    }\\n    return v;\\n}\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565679,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1899832,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1804177,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1782042,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1965068,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2037855,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1970393,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1888980,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2052023,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2020544,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1565679,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1899832,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1804177,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1782042,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1965068,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2037855,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1970393,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 1888980,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2052023,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            },
            {
                "id": 2020544,
                "content": [
                    {
                        "username": "wise",
                        "content": "Whenever we would move outside the boundary of the grid, we continue our walk outside the grid (but may return to the grid boundary later.) \\n\\nwhat the heck is this?"
                    },
                    {
                        "username": "yinlosky",
                        "content": "It means you keeps walking even if you are outside of the grid, but because you are walking clockwise, eventually you will return back to the grid, and you will start saving the cell that is in the gird into your result. If the cell is outside of the grid, you do not save the cell. \\nTake out a piece of paper, and draw a grid, and start at any cell and walk clockwise and you will understand. "
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn\\'t be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\\n\\nYou can also actually calculate the actual dimensions of the matrix this starting point would\\'ve been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order.\\n\\n"
                    },
                    {
                        "username": "bharat_gupta",
                        "content": "I can feel a spiral moving inside my head forcing me to break my pc."
                    },
                    {
                        "username": "harsh_reality_",
                        "content": "\\uD83D\\uDE02"
                    },
                    {
                        "username": "papaggalos",
                        "content": "Exquisite problem, I\\'m on the brink of forgetting how LOOPS work!"
                    },
                    {
                        "username": "BREATHTAKER200",
                        "content": "Why??"
                    },
                    {
                        "username": "neil_paul",
                        "content": "\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "**Since I was walking outside the grid and by mistake I turned anti-clockwise now I am  in South Korea trying to figure out what went wrong**"
                    },
                    {
                        "username": "To-heeb",
                        "content": ",keep moving forward you will be in North Korea in a no time"
                    },
                    {
                        "username": "saadkhan123456789",
                        "content": "This should have been marked as \\'Hard\\'"
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Once you\\'ve done Spiral Matrix I this one isn\\'t particularly challenging. Just keep an eye on how many steps you take when going right, down, left, and up, and how those steps increase at a regular interval on each cycle."
                    },
                    {
                        "username": "sav20011962",
                        "content": "Hello, I can not understand - in the previous tasks of this series:\\n54.Spiral Matrix\\n59. Spiral Matrix II\\nthe matrix was bypassed in a twisting spiral, the bypass rules were obvious and unambiguous, but here the rules have changed and the principle of changing the direction of movement is generally incomprehensible. For example, in \"Example 1\" why suddenly after \"2\" do not continue to move to the right, why change direction to \"down\". Similarly, in \"Example 2\" after \"3\" - why does the direction change to \"left\" while the direction \"down\" is free?"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@sav20011962](/sav20011962) it is mentioned that you are facing east, so it essentially means that the movement is left to right initially"
                    },
                    {
                        "username": "sav20011962",
                        "content": "[@2uringTested](/2uringTested) \\nnowhere is it indicated that the initial movement is \"left-to-right\", just \"clockwise\", then if the movement is \"top-down\" first, this matrix will turn out:\\n30 25 16 05 06 07\\n29 24 15 04 01 08\\n28 23 14 03 02 09\\n27 22 13 12 11 10\\n26 21 20 19 18 17"
                    },
                    {
                        "username": "2uringTested",
                        "content": "where ever you are starting the spiral in this problem, consider it to be the end point of the spiral traversal we were doing in previous such problems like spiral matrix I and spiral Matrix II, if the (rStart,cStart) were exactly at the middle of the matrix then we wouldn't be going out of the matrix at all, but since it is not exactly at the middle, it means its the spiral end to a even bigger matrix, of which, only a part of it is given to us.\n\nYou can also actually calculate the actual dimensions of the matrix this starting point would've been a spiral end to. and make a 2d matrix of that size, traverse it normally and push every coordinate which would be within this given rows and cols and ignore the ones which wouldnt be there in it and then reverse that order."
                    },
                    {
                        "username": "pulkit31997",
                        "content": "Examining the lengths of our walk in each direction, we find the following pattern: 1, 1, 2, 2, 3, 3, 4, 4, ...\\nshould be mentioned in description"
                    },
                    {
                        "username": "gaurav707026",
                        "content": "I am here after solving two similar problems i.e. matrix I and matrix II and thought this will be the similar problem, but travelling outside the matrix made me out of track."
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Burgers with No Waste of Ingredients",
        "question_content": "<p>Given two integers <code>tomatoSlices</code> and <code>cheeseSlices</code>. The ingredients of different burgers are as follows:</p>\n\n<ul>\n\t<li><strong>Jumbo Burger:</strong> <code>4</code> tomato slices and <code>1</code> cheese slice.</li>\n\t<li><strong>Small Burger:</strong> <code>2</code> Tomato slices and <code>1</code> cheese slice.</li>\n</ul>\n\n<p>Return <code>[total_jumbo, total_small]</code> so that the number of remaining <code>tomatoSlices</code> equal to <code>0</code> and the number of remaining <code>cheeseSlices</code> equal to <code>0</code>. If it is not possible to make the remaining <code>tomatoSlices</code> and <code>cheeseSlices</code> equal to <code>0</code> return <code>[]</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> tomatoSlices = 16, cheeseSlices = 7\n<strong>Output:</strong> [1,6]\n<strong>Explantion:</strong> To make one jumbo burger and 6 small burgers we need 4*1 + 2*6 = 16 tomato and 1 + 6 = 7 cheese.\nThere will be no remaining ingredients.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> tomatoSlices = 17, cheeseSlices = 4\n<strong>Output:</strong> []\n<strong>Explantion:</strong> There will be no way to use all ingredients to make small and jumbo burgers.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> tomatoSlices = 4, cheeseSlices = 17\n<strong>Output:</strong> []\n<strong>Explantion:</strong> Making 1 jumbo burger there will be 16 cheese remaining and making 2 small burgers there will be 15 cheese remaining.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= tomatoSlices, cheeseSlices &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 441321,
                "title": "java-c-python-chickens-and-rabbits",
                "content": "# **Intuition**\\nClassic problem, https://w.wiki/D2S\\nSorry that I don\\'t know the name in English.\\nMaybe  Chickens and Rabbits problem\\n<br>\\n\\n# **Explanation**\\ntomate number `t` should not be odd,\\nand it should valid that `c * 2 <= t && t <= c * 4`.\\n\\nFrom\\n`jumbo + small = cheese`\\n`jumbo * 2 + small = tomate / 2`\\n\\nWe can get that\\n`jumb0 = tomate / 2 - cheese`\\nSo that\\n`small = cheese * 2 - tomate / 2`\\n<br>\\n\\n# **Complexity**\\nTime `O(1)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        return t % 2 == 0 && c * 2 <= t && t <= c * 4 ? Arrays.asList(t / 2 - c, c * 2 - t / 2) :  new ArrayList();\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def numOfBurgers(self, t, c):\\n        return [t / 2 - c, c * 2 - t / 2] if t % 2 == 0 and c * 2 <= t <= c * 4 else []\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        return t % 2 == 0 && c * 2 <= t && t <= c * 4 ? Arrays.asList(t / 2 - c, c * 2 - t / 2) :  new ArrayList();\\n    }\\n```\n```cpp\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n```\n```python\\n    def numOfBurgers(self, t, c):\\n        return [t / 2 - c, c * 2 - t / 2] if t % 2 == 0 and c * 2 <= t <= c * 4 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 441342,
                "title": "java-python-3-solve-a-linear-equations-group-w-brief-explanation-and-analysis",
                "content": "According the description of the problem, we have the following:\\n```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\\nTherefore:\\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\n```\\nLet `x` and `y` indicate `jumbo` and `small` Burger, respectively, then\\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\\n=>\\n```\\n2x = tomatoSlices - 2 * cheeseSlices\\n```\\n=>\\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\\n\\n----\\n\\n```java\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\\n```python\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```\\n**Analysis**\\n\\nTime & space: O(1).",
                "solutionTags": [],
                "code": "```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\n```\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\n```\\n2x = tomatoSlices - 2 * cheeseSlices\\n```\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\n```java\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\n```python\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 441475,
                "title": "the-only-realistic-solution",
                "content": "I believe this is how you\\'d solve it after eating a lot of burgers.\\n```\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int burgers = cheeseSlices;\\n        for (int jumbo = 0; jumbo <= burgers; jumbo++) {\\n            int small = burgers - jumbo;\\n            if (tomatoSlices == 4*jumbo + 2*small)\\n                return {jumbo, small};\\n        }\\n        return {};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int burgers = cheeseSlices;\\n        for (int jumbo = 0; jumbo <= burgers; jumbo++) {\\n            int small = burgers - jumbo;\\n            if (tomatoSlices == 4*jumbo + 2*small)\\n                return {jumbo, small};\\n        }\\n        return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656213,
                "title": "o-1-solution-with-complete-analysis",
                "content": "Imagine, `x` number of jumbo burgers and `y` number of small burgers are made from the given `tomatoSlices` and `cheeseSlices`. \\n\\nSo, the equation would be, \\n`4x + 2y = tomatoSlices` which means, total number of tomatoSlices required for making `x` jumbo burgers and `y` small burgers should be EXACTLY `tomatoSlices` (if possible)\\n\\nSecond equation would be,\\n`x + y = cheeseSlices` which means, total number of cheeseSlices required for making `x` jumbo burgers and `y` small burgers should be EXACTLY `cheeseSlices` (if possible)\\n\\nThe way we solve this equation is,\\nmultiply `4` on both sides of equation 2.\\nSo, `4x + 4y = 4*cheeseSlices` <-- Equation 3\\n\\nSubtract equation 1 from equaiton 3\\n\\n```\\n    4x + 4y = 4*cheeseSlices (equation 3)\\n-   4x + 2y = tomatoSlices (equation 1)\\n\\t__________________________________________\\n         2y = 4*cheeseSlices - tomatoSlices <-- Equation 4\\n```\\n\\nNow, if the solution is impossible, we will not get a positive whole integer value for `y` from equation 4.\\nSo, let\\'s make a quick check for that. \\n`y = (4*cheeseSlices - tomatoSlices) / 2` (Based on equation 4)\\n\\nwhich means, for `y` to be a positive whole integer `4*cheeseSlices - tomatoSlices` must be positive and a multple of 2, otherwise we return empty list.\\n\\nafter getting y, use equation 2 to get x\\n`x = cheeseSlices - y`\\n\\nAgain check if x is a positive whole integer. (Because `x` could turn out negative based on value of `y`). So, if `x` is negative, return an empty list.\\n\\nIf all goes well, return list of `x` and `y` as result.\\n\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\tint jCount = 0, // x\\n\\t\\tsCount = 0; // y\\n\\n\\t// 4x + 2y = tomatoSlices\\n\\t// x + y = cheeseSlices\\n\\n\\tif ((4*cheeseSlices - tomatoSlices) < 0 || (4*cheeseSlices - tomatoSlices) % 2 != 0) {\\n\\t\\treturn Collections.emptyList();\\n\\t}\\n\\n\\tsCount = (4*cheeseSlices - tomatoSlices) / 2;\\n\\tjCount = cheeseSlices - sCount;\\n\\n\\treturn jCount >= 0\\n\\t\\t? Arrays.asList(jCount, sCount)\\n\\t\\t: Collections.emptyList();\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    4x + 4y = 4*cheeseSlices (equation 3)\\n-   4x + 2y = tomatoSlices (equation 1)\\n\\t__________________________________________\\n         2y = 4*cheeseSlices - tomatoSlices <-- Equation 4\\n```\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\tint jCount = 0, // x\\n\\t\\tsCount = 0; // y\\n\\n\\t// 4x + 2y = tomatoSlices\\n\\t// x + y = cheeseSlices\\n\\n\\tif ((4*cheeseSlices - tomatoSlices) < 0 || (4*cheeseSlices - tomatoSlices) % 2 != 0) {\\n\\t\\treturn Collections.emptyList();\\n\\t}\\n\\n\\tsCount = (4*cheeseSlices - tomatoSlices) / 2;\\n\\tjCount = cheeseSlices - sCount;\\n\\n\\treturn jCount >= 0\\n\\t\\t? Arrays.asList(jCount, sCount)\\n\\t\\t: Collections.emptyList();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444896,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int totalNumberBurgers = cheeseSlices;\\n        \\n        // Low & high represent boundaries of binary search for number of jumbo burgers\\n        int low = 0; int high = totalNumberBurgers;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            int currSlices = mid*4 + (totalNumberBurgers - mid)*2;\\n            if (currSlices == tomatoSlices) {\\n                return {mid, totalNumberBurgers-mid};\\n            }\\n            \\n            if (currSlices < tomatoSlices) {\\n                low = mid+1;\\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int totalNumberBurgers = cheeseSlices;\\n        \\n        // Low & high represent boundaries of binary search for number of jumbo burgers\\n        int low = 0; int high = totalNumberBurgers;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            int currSlices = mid*4 + (totalNumberBurgers - mid)*2;\\n            if (currSlices == tomatoSlices) {\\n                return {mid, totalNumberBurgers-mid};\\n            }\\n            \\n            if (currSlices < tomatoSlices) {\\n                low = mid+1;\\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        \\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441434,
                "title": "easy-java-to-understand-beats-100",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        List<Integer> ret = new ArrayList<>();\\n        if(t%2!=0||((t/2)>2*c)||c>(t/2))return ret;\\n        ret.add((t/2-c));\\n        ret.add((2*c-t/2));\\n        return ret;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/vshnlucky/image_1575176370.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        List<Integer> ret = new ArrayList<>();\\n        if(t%2!=0||((t/2)>2*c)||c>(t/2))return ret;\\n        ret.add((t/2-c));\\n        ret.add((2*c-t/2));\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441323,
                "title": "java-simple-easy-solution-o-1-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // need to solve 2 equations\\n        // 4 * jumbo + 2 * small = tomatoSlices, jumbo + small = cheeseSlices\\n        \\n        if(tomatoSlices % 2 == 1) return ans;\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if(jumbo < 0 || jumbo % 2 == 1) return ans;\\n        \\n        jumbo /= 2;\\n        \\n        int small = cheeseSlices - jumbo;\\n        if(small < 0) return ans;\\n        \\n        ans.add(jumbo);\\n        ans.add(small);\\n        \\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        // need to solve 2 equations\\n        // 4 * jumbo + 2 * small = tomatoSlices, jumbo + small = cheeseSlices\\n        \\n        if(tomatoSlices % 2 == 1) return ans;\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if(jumbo < 0 || jumbo % 2 == 1) return ans;\\n        \\n        jumbo /= 2;\\n        \\n        int small = cheeseSlices - jumbo;\\n        if(small < 0) return ans;\\n        \\n        ans.add(jumbo);\\n        ans.add(small);\\n        \\n        return ans;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 441299,
                "title": "python-easy-solution-with-explanation-2-known-2-variables",
                "content": "treat it like two equations where you have 2 known 2 variable:\\n    \\nLet number of small burgers be y and number of jumbo burgers be x.\\ntotal tomatoslices used will be 4x +2y \\ntotal cheeseSlices used will be x+y\\n\\n4x +2y = tomatoSlices\\nx+y = cheeseSlices\\n\\nSolving for x and y , we get:\\n\\ny= ((4* cheeseSlices) - tomatoSlices)/2\\nx= cheeseSlices - y\\n```\\n\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        small = ((4*c)-t)/2\\n        jumbo = c-small\\n        if small.is_integer() and small >= 0 and jumbo >= 0:\\n            return [int(jumbo), int(small)]\\n        else:\\n            return []\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        small = ((4*c)-t)/2\\n        jumbo = c-small\\n        if small.is_integer() and small >= 0 and jumbo >= 0:\\n            return [int(jumbo), int(small)]\\n        else:\\n            return []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889527,
                "title": "java-solution-two-solutions",
                "content": "**Checking all the possible solutions**\\nRuntime : **497ms**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        boolean cond1 = (tomatoSlices == 0 && cheeseSlices !=0) || (tomatoSlices != 0 && cheeseSlices ==0);\\n        boolean cond2 = (tomatoSlices < cheeseSlices);\\n        boolean cond3 = (tomatoSlices%2 == 1);\\n        if(cond1 || cond2 ||  cond3){\\n            return new ArrayList<>();\\n        }\\n        int low = 0;\\n        int high = cheeseSlices;\\n        while(low <= cheeseSlices){\\n            int Jumbo_Burger = 4*low;\\n            int Small_Burger = 2*high;\\n            if(Jumbo_Burger + Small_Burger == tomatoSlices){\\n               return Arrays.asList(low,high);\\n            }\\n            low++;\\n            high--;\\n        }\\n        \\n        //if not above then there is no answer\\n        return new ArrayList<>();\\n    }\\n```\\n\\n**Simple Math**\\n**Run Time : 1ms**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        //Jumbo Burger = (tomatoSlices/2) - cheeseSlices;\\n        //Jumbo Burger + Small Burger = cheeseSlices\\n        \\n        //check for even tomatoes\\n        if(tomatoSlices %2 == 1){\\n            return new ArrayList<>();\\n        }\\n        int Jumbo_Burger =  (tomatoSlices/2) - cheeseSlices;\\n        \\n        //check for Jumbo_Burger\\n        if(Jumbo_Burger <0 || Jumbo_Burger > cheeseSlices){\\n             return new ArrayList<>();\\n        }\\n        int Small_Burger = cheeseSlices - Jumbo_Burger;\\n        return Arrays.asList(Jumbo_Burger,Small_Burger);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        boolean cond1 = (tomatoSlices == 0 && cheeseSlices !=0) || (tomatoSlices != 0 && cheeseSlices ==0);\\n        boolean cond2 = (tomatoSlices < cheeseSlices);\\n        boolean cond3 = (tomatoSlices%2 == 1);\\n        if(cond1 || cond2 ||  cond3){\\n            return new ArrayList<>();\\n        }\\n        int low = 0;\\n        int high = cheeseSlices;\\n        while(low <= cheeseSlices){\\n            int Jumbo_Burger = 4*low;\\n            int Small_Burger = 2*high;\\n            if(Jumbo_Burger + Small_Burger == tomatoSlices){\\n               return Arrays.asList(low,high);\\n            }\\n            low++;\\n            high--;\\n        }\\n        \\n        //if not above then there is no answer\\n        return new ArrayList<>();\\n    }\\n```\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        //Jumbo Burger = (tomatoSlices/2) - cheeseSlices;\\n        //Jumbo Burger + Small Burger = cheeseSlices\\n        \\n        //check for even tomatoes\\n        if(tomatoSlices %2 == 1){\\n            return new ArrayList<>();\\n        }\\n        int Jumbo_Burger =  (tomatoSlices/2) - cheeseSlices;\\n        \\n        //check for Jumbo_Burger\\n        if(Jumbo_Burger <0 || Jumbo_Burger > cheeseSlices){\\n             return new ArrayList<>();\\n        }\\n        int Small_Burger = cheeseSlices - Jumbo_Burger;\\n        return Arrays.asList(Jumbo_Burger,Small_Burger);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057564,
                "title": "java-python-3-solve-a-linear-equations-group-w-brief-explanation-and-analysis",
                "content": "According the description of the problem, we have the following:\\n\\n```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\\n\\nTherefore:\\n\\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\nLet x and y indicate jumbo and small Burger, respectively, then\\n```\\n\\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\\n\\n**=>**\\n\\n```2x = tomatoSlices - 2 * cheeseSlices```\\n\\n**=>**\\n\\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\\n\\n\\n**JAVA**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\\n\\n**PYTHON**\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```\\n\\n**Analysis**\\n\\n**Time & space: O(1).**",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nJumbo Burger: 4 tomato slices and 1 cheese slice.\\nSmall Burger: 2 Tomato slices and 1 cheese slice.\\n```\n```\\n4 * Jumbo Burger + 2 * Small Burger = tomatoSlices\\nJumbo Burger + Small Burger = cheeseSlices\\nLet x and y indicate jumbo and small Burger, respectively, then\\n```\n```\\n4x + 2y = tomatoSlices\\nx + y = cheeseSlices\\n```\n```2x = tomatoSlices - 2 * cheeseSlices```\n```\\nx = (tomatoSlices - 2 * cheeseSlices) / 2\\ny = cheeseSlices - x\\n```\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int twoX = tomatoSlices - 2 * cheeseSlices, x = twoX / 2, y = cheeseSlices - x;\\n        return twoX >= 0 && twoX % 2 == 0 && y >= 0 ? Arrays.asList(x, y) : Arrays.asList();        \\n    }\\n```\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        two_x = tomatoSlices - 2 * cheeseSlices\\n        x = two_x // 2\\n        y = cheeseSlices - x\\n        return [x, y] if two_x >= 0 and not two_x % 2 and y >= 0 else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1599441,
                "title": "python3-linear-equation-explained-beats-100",
                "content": "We notice that the number of burger limited by chees slices, i.e. number of burgers are going to be equal to number of chees slices. Thus,  if we denote number of small burgers as `x` and number of big burgers as `y`, we got an equation `x + y = cheesSlices`. This immediately suggest the use of linear equations. Since we have 2 unknowns, we need a second equation which is `x*2 + y*4 = tomatoSlices`. Then we simply express `y` through the `x`, substitute one into another and calculate `y` and `x`.\\n\\n```\\n\\tx + y = cheesSlices\\n\\t2*x + 4*y = tomatoSlices\\n\\t\\n\\tx = cheesSlices - y\\n\\t2*(cheesSlices - y) + y*4 = tomatoSlices\\n\\t\\n\\ty = tomatoSlices/2 - cheesSlices\\n```\\n\\nRuntime: 20 ms, faster than **100.00%** of Python3 online submissions for Number of Burgers with No Waste of Ingredients.\\nMemory Usage: 14.3 MB, less than **53.33%** of Python3 online submissions for Number of Burgers with No Waste of Ingredients.\\n\\n```\\nclass Solution:\\n    def numOfBurgers(self, ts: int, cs: int) -> List[int]:             \\n        x = ts/2 - cs\\n        y = cs - x\\n\\n        if x < 0 or x % 1 or y < 0 or y % 1:\\n            return []\\n\\n        return [int(x), int(y)]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tx + y = cheesSlices\\n\\t2*x + 4*y = tomatoSlices\\n\\t\\n\\tx = cheesSlices - y\\n\\t2*(cheesSlices - y) + y*4 = tomatoSlices\\n\\t\\n\\ty = tomatoSlices/2 - cheesSlices\\n```\n```\\nclass Solution:\\n    def numOfBurgers(self, ts: int, cs: int) -> List[int]:             \\n        x = ts/2 - cs\\n        y = cs - x\\n\\n        if x < 0 or x % 1 or y < 0 or y % 1:\\n            return []\\n\\n        return [int(x), int(y)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348226,
                "title": "best-logical-solution-100-faster-o-1-time-o-1-space-no-dsa-required",
                "content": "\\tThis problem can be easily converted into a 2 equations, 2 variables maths problem.\\n\\t\\n\\tFor making a Jumbo burger we require: 4 tomato slices and 1 cheese slice.\\n\\tSimilarly for making a Small burger we require: 2 tomato slices and 1 cheese slice.\\n\\t\\n\\tLet the number of Jumbo burgers which can be made using the given slices be denoted by \\'x\\' and \\n\\tnumber of Small burgers which can be made using the given slices be denoted by \\'y\\'.\\n\\t\\n\\tNow since each jumbo burger (x) has 4 tomato slices and each small burger (y) has 2 tomato slices:\\n\\twe can note that the total number of tomato slices will be equal to: \\n\\tTomato slices (T) = 4*x + 2*y  - (i)\\n\\t\\n\\tSimilarly each jumbo burger (x) has 1 cheese slice and each small burger (y) has 1 cheese slice:\\n\\twe can note that the total number of cheese slices will be equal to: \\n\\tCheese slices (C) = x + y  - (ii)\\n\\t\\n\\tSolving equations (i) and (ii) we get:\\n\\tx = (T - 2*C) / 2\\n\\ty = (4*C - T) / 2\\n\\t\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) \\n    {\\n        if(T==0 && C==0)// if both the slices are zero\\n        {\\n            return {0,0};\\n        }\\n        if(T==0 || C==0)// if either one is zero, answer is not possible\\n        {\\n            return {};\\n        }\\n        int x = T-(2*C);\\n        if(x>0)\\n        {\\n            x = x/2;\\n        }\\n        int y = (4*C)-T;\\n        if(y>0)\\n        {\\n            y = y/2;\\n        }\\n        if(x+y==C && ((4*x)+(2*y))==T)\\n        {\\n            return {x,y};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) \\n    {\\n        if(T==0 && C==0)// if both the slices are zero\\n        {\\n            return {0,0};\\n        }\\n        if(T==0 || C==0)// if either one is zero, answer is not possible\\n        {\\n            return {};\\n        }\\n        int x = T-(2*C);\\n        if(x>0)\\n        {\\n            x = x/2;\\n        }\\n        int y = (4*C)-T;\\n        if(y>0)\\n        {\\n            y = y/2;\\n        }\\n        if(x+y==C && ((4*x)+(2*y))==T)\\n        {\\n            return {x,y};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955083,
                "title": "python3-with-explanation",
                "content": "if cheese == 0, return [0, 0] only when tomato ==0.\\n\\nthe tomato/cheese ratio is determined by [2,4]\\n\\nno matter what the combination is, the number of tomato will always be even.\\n\\nThen, start with all burger 2, it will cost 2* cheese.\\nThe difference between tomato and 2* cheese will be compensated by burger 1. each additional burger 1 will offset 2 extra cheese.\\n\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices==0:\\n            return [0,0] if tomatoSlices==0 else []\\n        elif tomatoSlices/cheeseSlices<2 or tomatoSlices/cheeseSlices>4 or tomatoSlices%2==1:\\n            return []\\n        else:\\n            ans=(tomatoSlices-2*cheeseSlices)//2\\n            return [ans,cheeseSlices-ans]\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices==0:\\n            return [0,0] if tomatoSlices==0 else []\\n        elif tomatoSlices/cheeseSlices<2 or tomatoSlices/cheeseSlices>4 or tomatoSlices%2==1:\\n            return []\\n        else:\\n            ans=(tomatoSlices-2*cheeseSlices)//2\\n            return [ans,cheeseSlices-ans]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 551868,
                "title": "math-python-using-2-variables-linear-algebra-to-solve-the-problem",
                "content": "We are given here the number of tomato slices (T) and the number of cheese slices (C). Using them, we should make the burgers, jumbo and small. A jumbo burger requires 4 tomato slices and 1 cheese slice and a small burger requires 2 tomato slices and 1 cheese slices. Let J and S represent the number of jumbo burgers and small burgers. Also, \\n\\nSo, \\n*4J + 2S = T\\n  J +   S = C*\\n\\nGiven the values of T and C, we should find the values of J and S. That is solving the two variable linear equations. But wait! Are there any constraints?\\n\\nYes, there are. The number of burgers can\\'t be decimals or negatives.\\nSo, the constraints are:\\n*J \\u2208  {0, 1, 2, 3, ...}*\\n*S \\u2208  {0, 1, 2, 3, ...}*\\n\\nAs the matrix `[[4, 2], [1, 1]]` has non-zero determinant (i.e 2), there exists a unique solution. After finding the solution, we need to see if the solution satisfies the constraints. If it satisfies, return the list `[J, S]`, else return `[]`.\\n\\nTo find the inverse matrix, we divide the adjoint matrix by the determinant. So, the solution is:\\n*[[J], [S]] = 0.5 * [[0.5, -1], [0.5, 2]] x [[T], [C]]*\\n\\nNote that `x` represents matrix multiplication. So, we come up with the following solution.\\n\\nPython solution:\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n\\t\\t# on the basis of the matrix solution\\n        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]\\n\\t\\t\\n\\t\\t# using the constraints to see if solution satisfies it\\n        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:\\n            return [int(ans[0]), int(ans[1])]\\n        else:\\n            return []\\n```\\n\\nHave fun!",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n\\t\\t# on the basis of the matrix solution\\n        ans = [0.5 * tomatoSlices - cheeseSlices, -0.5 * tomatoSlices + 2 * cheeseSlices]\\n\\t\\t\\n\\t\\t# using the constraints to see if solution satisfies it\\n        if 0 <= int(ans[0]) == ans[0] and 0 <= int(ans[1]) == ans[1]:\\n            return [int(ans[0]), int(ans[1])]\\n        else:\\n            return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441779,
                "title": "elegant-c-java-go-python-javascript-2-lines-o-1-time-space",
                "content": "This clearly should be \"Easy\" not \"Medium\".\\nCheck viability conditions first, then allocate greedily: jumbo = tomato/2 - cheese, small = cheese - jumbo.\\n\\nJava\\n``` \\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return Collections.emptyList();\\n        return Arrays.asList(ts/2-cs, 2*cs-ts/2);\\n    }\\n}\\n```\\nC++\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return {};\\n        return {ts/2-cs, 2*cs-ts/2};\\n    }\\n};\\n```\\nGo\\n```\\nfunc numOfBurgers(ts int, cs int) []int {\\n    if ts%2==1 || ts/2<cs || ts/4>cs {\\n        return []int{}\\n    } \\n    return []int{ts/2-cs, 2*cs-ts/2}\\n}\\n```\\nPython\\n```\\nclass Solution(object):\\n    def numOfBurgers(self, ts, cs):\\n        return [] if ts%2==1 or ts/2<cs or ts/4>cs else [ts/2-cs, 2*cs-ts/2]\\n```\\nJavaScript\\n```\\nfunction numOfBurgers(ts, cs) {\\n    return ts%2==1 || ts/2<cs || ts/4>cs ? [] : [ts/2-cs, 2*cs-ts/2];\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "``` \\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return Collections.emptyList();\\n        return Arrays.asList(ts/2-cs, 2*cs-ts/2);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        if (ts%2==1 || ts/2<cs || ts/4>cs) return {};\\n        return {ts/2-cs, 2*cs-ts/2};\\n    }\\n};\\n```\n```\\nfunc numOfBurgers(ts int, cs int) []int {\\n    if ts%2==1 || ts/2<cs || ts/4>cs {\\n        return []int{}\\n    } \\n    return []int{ts/2-cs, 2*cs-ts/2}\\n}\\n```\n```\\nclass Solution(object):\\n    def numOfBurgers(self, ts, cs):\\n        return [] if ts%2==1 or ts/2<cs or ts/4>cs else [ts/2-cs, 2*cs-ts/2]\\n```\n```\\nfunction numOfBurgers(ts, cs) {\\n    return ts%2==1 || ts/2<cs || ts/4>cs ? [] : [ts/2-cs, 2*cs-ts/2];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490817,
                "title": "simple-math",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>ans;\\n        if(tomatoSlices%2==1) return ans;\\n        else\\n        {\\n            if(cheeseSlices>=ceil(1.0*tomatoSlices/4)&& cheeseSlices<=tomatoSlices/2)\\n            {\\n                int jumbo=((tomatoSlices/2) -cheeseSlices);\\n                int small=cheeseSlices-jumbo;\\n                ans.push_back(jumbo);\\n                ans.push_back(small);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>ans;\\n        if(tomatoSlices%2==1) return ans;\\n        else\\n        {\\n            if(cheeseSlices>=ceil(1.0*tomatoSlices/4)&& cheeseSlices<=tomatoSlices/2)\\n            {\\n                int jumbo=((tomatoSlices/2) -cheeseSlices);\\n                int small=cheeseSlices-jumbo;\\n                ans.push_back(jumbo);\\n                ans.push_back(small);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251518,
                "title": "beats-100-simplest-explanation",
                "content": "# Intuition\\nlet no be large and small \\n4*large  + 2*small = tomato .... eqn(i)\\nlarge + small = cheese ..... eqn(ii)\\nfrom both equation \\nlarge = (tomato)/2 - cheese \\nsmall = cheese - large \\n\\n.\\n.\\nPls upvote if you liked !!\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) \\n    {\\n        \\n        if(tomato % 2!=0 || cheese*2> tomato || cheese >tomato)\\n        return { } ;\\n        int large  = tomato/2 - cheese ; \\n        int small = cheese - large ; \\n        if(large >=0 && small>=0)\\n        return {large,small};\\n        else return { };\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) \\n    {\\n        \\n        if(tomato % 2!=0 || cheese*2> tomato || cheese >tomato)\\n        return { } ;\\n        int large  = tomato/2 - cheese ; \\n        int small = cheese - large ; \\n        if(large >=0 && small>=0)\\n        return {large,small};\\n        else return { };\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607558,
                "title": "python-solution-basic-algebra",
                "content": "```\\nclass Solution:\\n    # Basic algebra\\n    # x, y = tomato, cheese\\n    # j, s = number of jumbo and small burgers made\\n    # 4*j + 2*s = x\\n    # j + s = y\\n    # 2*j + 2*s = 2y\\n    # 2*j = x - 2y\\n    # s = y - j = y - (x-2*y)/2 = 2*y - x/2\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x, y = tomatoSlices, cheeseSlices\\n        if x < 2*y or y < x/4 or (x-2*y)%2 != 0 or x%2 != 0:\\n            return []\\n        return [(x-2*y)//2, 2*y-x // 2]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # Basic algebra\\n    # x, y = tomato, cheese\\n    # j, s = number of jumbo and small burgers made\\n    # 4*j + 2*s = x\\n    # j + s = y\\n    # 2*j + 2*s = 2y\\n    # 2*j = x - 2y\\n    # s = y - j = y - (x-2*y)/2 = 2*y - x/2\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x, y = tomatoSlices, cheeseSlices\\n        if x < 2*y or y < x/4 or (x-2*y)%2 != 0 or x%2 != 0:\\n            return []\\n        return [(x-2*y)//2, 2*y-x // 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2539048,
                "title": "o-1-well-commented-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        \\n        if(tomato % 2 == 1) return {}; //if number of tomatoes are odd it\\'s not possible\\n        \\n        int l = tomato/4 + tomato%4; //setting a lower limit (i greedyly use as many jumbo as possible)\\n        \\n        if(tomato < 4)  l = 0; // if less than 4 tomatoes jumbo cant be used\\n        \\n        int h = tomato/2; //setting an upper limit (i greedyly use as many small as possible)\\n        \\n        if(cheese < l || cheese > h) return {}; //cheese should lie b/w the limits... why? simple logic cant produce more or less than that\\n        \\n        int small = h - (2*(h-cheese)); //number of small burgers (how this formula came check below)\\n        \\n        int big = cheese-small; // number of larger burgers\\n        \\n        return {big,small};\\n    }\\n};\\n\\n/*\\n\\n\\nlet tomatoes = 20 and cheese = 7\\n\\nlet\\'s find out if cheese lies within limits;\\nl = 5 h = 10\\nyes !!\\n\\nnow,\\n2 2 2 2 2 2 2 2 2 2 => i need 10 cheese for this but have 7 (need to remove 3 cheese)\\nin order to remove 3 cheese i will remove 6 2\\'s and replace with 3 4\\'s..\\nthat is,\\nnew small burgers = allFromSmall - (2*(allFromSmall - cheese));  ==> 10 - (2*(10-7)) ==>4\\nnew big ones = cheese - smalls ==> 7-4 = 3\\nans :: {3,4}\\n\\n\\n*/\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        \\n        if(tomato % 2 == 1) return {}; //if number of tomatoes are odd it\\'s not possible\\n        \\n        int l = tomato/4 + tomato%4; //setting a lower limit (i greedyly use as many jumbo as possible)\\n        \\n        if(tomato < 4)  l = 0; // if less than 4 tomatoes jumbo cant be used\\n        \\n        int h = tomato/2; //setting an upper limit (i greedyly use as many small as possible)\\n        \\n        if(cheese < l || cheese > h) return {}; //cheese should lie b/w the limits... why? simple logic cant produce more or less than that\\n        \\n        int small = h - (2*(h-cheese)); //number of small burgers (how this formula came check below)\\n        \\n        int big = cheese-small; // number of larger burgers\\n        \\n        return {big,small};\\n    }\\n};\\n\\n/*\\n\\n\\nlet tomatoes = 20 and cheese = 7\\n\\nlet\\'s find out if cheese lies within limits;\\nl = 5 h = 10\\nyes !!\\n\\nnow,\\n2 2 2 2 2 2 2 2 2 2 => i need 10 cheese for this but have 7 (need to remove 3 cheese)\\nin order to remove 3 cheese i will remove 6 2\\'s and replace with 3 4\\'s..\\nthat is,\\nnew small burgers = allFromSmall - (2*(allFromSmall - cheese));  ==> 10 - (2*(10-7)) ==>4\\nnew big ones = cheese - smalls ==> 7-4 = 3\\nans :: {3,4}\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770237,
                "title": "100-faster-o-1-solution",
                "content": "** Overview- Make two equation from given constraint. Say we have J jumbo burger and S small burger\\n     then total tomato=4j+2s and total cheese =j+s and now just solve them.**\\n\\t \\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\tif(t==0 && c==0) return {0,0};\\n\\t\\t\\t\\tif(t==0 || t%2!=0 || c==0) return {};\\n\\t\\t\\t\\t vector<int> v;\\n\\t\\t\\t\\t int x1=ceil((t-2*c)/2);\\n\\t\\t\\t\\t int x2=floor((t-2*c)/2);\\n\\t\\t\\t\\t if(x1>=0 && x2>=0 && x1==x2 && c-x1>=0){\\n\\t\\t\\t\\t\\t  v.push_back(x1);\\n\\t\\t\\t\\t\\t  v.push_back(c-x1);\\n\\t\\t\\t\\t }\\n\\t\\t\\t\\t return v;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\tif(t==0 && c==0) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1415148,
                "title": "c-o-1-faster-than-100-intuitive-solution-solve-linear-equations-explained-in-detail",
                "content": "# **Intuition and Maths Involved**\\nYou see, they ask us to use up all ingredients without wastage , if you just look a little carefully you will realize its more like a class 9th problem of **Pair Of Linear Equations in Two variables**, where all you need is to simply check if the 2 equations have \"whole number \" solutions .. \\n\\n\\nLet me explain :-\\nLet\\'s say we can create **x** jumbo burgers and **y** small ones ..\\n**Total cheeseslices Used  = x + y**  (all burgers use one cheeseslice so x + y burgers neeed x+ y slices , right?)\\ntomatoslices used in x Jumbo burgers = 4x (4 in each burger, means total 4x will be needed)\\nTomatoslices used in y small burgers = 2y (2 in each burger, means total 2x will be needed)\\n**Total tomatoeslices Used  = 4x + 2y**\\n\\nSo we are basically left with 2 equations at hand : -\\n**4x + 2y = tomatoslices       ----------(i)\\n\\tx + y = cheeseslices       ----------(ii)**\\n\\nIf we try to solve them we get x and y as \\n**x = (tomatoSlices - 2*cheeseSlices) / 2\\ny = cheeseSlices - x**\\nNow, all we need is to check if x and y we are getting, are whole numbers or not...\\nbecause you won\\'t be just making negative number of burgers or a fraction of them, will you? : -)\\n\\n# Implementation \\nIt could be one liner, but I prefer code to be more understandable than being very short : -)\\n```\\n\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n            double x = 0, y = 0;\\n            x = (tomatoSlices - 2*cheeseSlices);\\n            x = x / 2;\\n            y = cheeseSlices - x;\\n            if(ceil(x) == x and ceil(y) == y and x >= 0 and y >= 0) // checks for whole number\\n               return {(int)x,(int)y};\\n            return {};\\n    }\\n```\\n# Complexity Analysis\\nTime Complexity - O(1)  // no iterations, just direct calculations \\nSpace Complecity - O(1) // No space needed except for 2 variable x and y : - ))\\nFaster than 100% \\n\\n**Please upvote if you find it useful !!**\\n",
                "solutionTags": [],
                "code": "```\\n\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n            double x = 0, y = 0;\\n            x = (tomatoSlices - 2*cheeseSlices);\\n            x = x / 2;\\n            y = cheeseSlices - x;\\n            if(ceil(x) == x and ceil(y) == y and x >= 0 and y >= 0) // checks for whole number\\n               return {(int)x,(int)y};\\n            return {};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1080107,
                "title": "linear-algebra-solution-with-explanation",
                "content": "This solution is not accepted by leetcode, but nonetheless I thought I would share. We can think of this problem as \\'Some amount of Jumbo Burgers + some amount of Small Burgers better = the amount of tomato and cheese slices I have. Let `J = Jumbor Burger`, let `S = Small Burger`, let `t = tomato slices I have`, let `c = cheese slices I have`. \\nThen,  `4*J + S*2 = t`,` J + S = c`. The first equation in words says, \\'For 1 Jumber Burger I need 4 slices of tomatoes and for 1 Small burger I need 2 slices of tomatoes. Now, I don\\'t know how many Jumbo Burgers and Small burgers I am going to make, but how ever many I end up making I better use all the tomatoe slices.\\' Similarly, the second equation in words says, \\'For 1 Jumber Burger I need 1 slice of cheese and for 1 Small burger I need 1 slice of cheese. Now, I don\\'t know how many Jumbo Burgers and Small burgers I am going to make, but how ever many I end up making I better use all the cheese slices.\\' Now we have a linear system of equations and we have tools to solve this problem. \\n\\n```\\nimport numpy as np\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        # Linear Algebra solution\\n        a = np.array([[4, 2], [1, 1]])\\n        b = np.array([tomatoSlices, cheeseSlices])\\n        x = np.linalg.solve(a, b)\\n        return x\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        # Linear Algebra solution\\n        a = np.array([[4, 2], [1, 1]])\\n        b = np.array([tomatoSlices, cheeseSlices])\\n        x = np.linalg.solve(a, b)\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441667,
                "title": "python-3-one-line-beats-100-24-ms-with-explanation",
                "content": "_Explanation:_\\nLet x = number of jumbo burgers and y = number of small burgers. Then we can write the following system of equations: 4x + 2y = T  and  x + y = C. Using substitution, we can solve this linear system to get: x = T/2 - C  and  y = 2C - T/2. Note that although there is *always* a unique solution to this system (since the lines have different slopes), the solutions may not always make sense in the context of this problem. Specifically, x and y must be non-negative whole numbers. This requires three conditions to be met:\\n\\n1) T must be even (that is: T % 2 == 0)\\n2) x = T/2 - C \\u2265 0 (that is: T \\u2265 2C)\\n3) y = 2C - T/2 \\u2265 0 (that is: 4C \\u2265 T)\\n\\nThus we return [ ] if any of these conditions fail. Otherwise we return [x,y]. \\n```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "_Explanation:_\\nLet x = number of jumbo burgers and y = number of small burgers. Then we can write the following system of equations: 4x + 2y = T  and  x + y = C. Using substitution, we can solve this linear system to get: x = T/2 - C  and  y = 2C - T/2. Note that although there is *always* a unique solution to this system (since the lines have different slopes), the solutions may not always make sense in the context of this problem. Specifically, x and y must be non-negative whole numbers. This requires three conditions to be met:\\n\\n1) T must be even (that is: T % 2 == 0)\\n2) x = T/2 - C \\u2265 0 (that is: T \\u2265 2C)\\n3) y = 2C - T/2 \\u2265 0 (that is: 4C \\u2265 T)\\n\\nThus we return [ ] if any of these conditions fail. Otherwise we return [x,y]. \\n```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 441385,
                "title": "c-2-linear-equations-in-2-variables",
                "content": "Let the number of jumbo burgers and small burgers that will be our answer be x and y respectively. Now, the tomato slices and cheese slices used in each of our burgers will be:\\n\\n**Jumbo Burger**\\n\\tTomato Slices = 4*x\\n\\tCheese Slices = x\\n\\t\\n**Small Burger**\\n\\tTomato Slices = 2*y\\n\\tCheese Slices = y\\n\\t\\nNow, for no wastage of ingredients, the number of tomato slices and cheese slices used must be equal to the available number of tomato slices and cheese slices respectively. Therefore, the following 2 equations must hold:\\n\\n\\t4*x + 2*y = tomatoSlices\\n\\tx + y = cheeseSlices\\n\\t\\nSolving for x and y gives us:\\n\\n\\tx = tomatoSlices/2 - cheeseSlices\\n\\ty = 2*cheeseSlices - tomatoSlices/2\\n\\t\\nFor our answers to be valid, both x and y must not be negative as well as fractional. For integral answers, tomatoSlices/2 must be an integer, which is only possible when tomatoSlices is divisible by 2. For non-negative answers, we will compute x and y and check if they are both positive. If they are, we will return them as the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> result;\\n        if(tomatoSlices%2 == 0)\\n        {\\n            int x = tomatoSlices/2 - cheeseSlices;\\n            int y = 2*cheeseSlices - tomatoSlices/2;\\n            if(x>=0 && y>=0)\\n            {\\n                result.push_back(x);\\n                result.push_back(y);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> result;\\n        if(tomatoSlices%2 == 0)\\n        {\\n            int x = tomatoSlices/2 - cheeseSlices;\\n            int y = 2*cheeseSlices - tomatoSlices/2;\\n            if(x>=0 && y>=0)\\n            {\\n                result.push_back(x);\\n                result.push_back(y);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011164,
                "title": "fast-accepted-o-1-c-java-code-beats-100",
                "content": "# Complexity\\n- Time complexity : **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# JAVA\\n -- | Details | --\\n -- | -- | --:\\n**Runtime** | **1** *ms* | *Beats* **100%**\\n**Memory** | **40** *MB* | *Beats* **70%**\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tSlices, int cSlices) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        int x = tSlices - 2*cSlices;\\n        int y = cSlices - x/2;\\n        if(x<0 || x%2!=0 || y<1 )\\n            if(tSlices!=0 || cSlices!=0)\\n                return result;\\n        result.add(x/2); result.add(y);\\n        return result;\\n    }\\n}\\n```\\n# C\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | **3** *ms* | *Beats* **100%**\\n**Memory** | **5** *MB* | *Beats* **100%**\\n```\\nint* numOfBurgers(int tSlices, int cSlices, int* returnSize){\\n    *returnSize = 0;\\n    int *result;\\n    int x = tSlices-2*cSlices;\\n    int y = cSlices-x/2;\\n    if(x<0 || x%2 || y<1 )\\n        if(tSlices || cSlices)\\n            return result;\\n    *returnSize = 2;\\n    result = (int *)malloc(sizeof(int)*2);\\n    result[0] = x/2; result[1] = y;\\n    return result;    \\n}\\n```\\n## Tom need a UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tSlices, int cSlices) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        int x = tSlices - 2*cSlices;\\n        int y = cSlices - x/2;\\n        if(x<0 || x%2!=0 || y<1 )\\n            if(tSlices!=0 || cSlices!=0)\\n                return result;\\n        result.add(x/2); result.add(y);\\n        return result;\\n    }\\n}\\n```\n```\\nint* numOfBurgers(int tSlices, int cSlices, int* returnSize){\\n    *returnSize = 0;\\n    int *result;\\n    int x = tSlices-2*cSlices;\\n    int y = cSlices-x/2;\\n    if(x<0 || x%2 || y<1 )\\n        if(tSlices || cSlices)\\n            return result;\\n    *returnSize = 2;\\n    result = (int *)malloc(sizeof(int)*2);\\n    result[0] = x/2; result[1] = y;\\n    return result;    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876200,
                "title": "easy-c-solution-in-one-line",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**```O(1)```**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n**```O(1)```**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n// if it helps plzz upvote it \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 0 && cheeseSlices <= tomatoSlices/2 && tomatoSlices <= cheeseSlices *4)\\n            return {(tomatoSlices/2)-cheeseSlices,(2*cheeseSlices) - (tomatoSlices/2)};\\n        return {};\\n    }\\n};\\n// if it helps plzz upvote it \\uD83D\\uDE09**Bold**\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```O(1)```\n```O(1)```\n```\\n// if it helps plzz upvote it \\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 0 && cheeseSlices <= tomatoSlices/2 && tomatoSlices <= cheeseSlices *4)\\n            return {(tomatoSlices/2)-cheeseSlices,(2*cheeseSlices) - (tomatoSlices/2)};\\n        return {};\\n    }\\n};\\n// if it helps plzz upvote it \\uD83D\\uDE09**Bold**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751409,
                "title": "o-1-simple-algebra-linear-equation-in-2-variables",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\t// Lets assume a is total number of tomato slices for jumbo burger and b is total number of tomato slices for small burger\\n\\t\\t\\t\\t// Now if provided data will give answer it must satisfy these two given equation \\n\\t\\t\\t   // Equation 1\\n\\t\\t\\t\\t// a/4 + b/2 = c    i.e. total tomato slices for jumbo burger / 4 + total slices for small burger / 2 should be equal to total cheese slices\\n\\t\\t\\t\\t// Equation 2\\n\\t\\t\\t\\t// a+b = t       also total tomato slices for jumbo burger + total slices for small burger  should be equal to total cheese tomato slice\\n\\t\\t\\t\\t// here t is total tomato slice and c is total cheese slice \\n\\t\\t\\t\\tint b = 4*c-t;\\n\\t\\t\\t\\tint a = t-b;\\n\\t\\t\\t\\tif( a<0 || b<0 || b%2!=0 || a%4 !=0) return {};\\n\\t\\t\\t\\tb/=2;\\n\\t\\t\\t\\ta/=4;\\n\\t\\t\\t\\treturn {a,b};\\n\\n\\n\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n\\t\\t\\tvector<int> numOfBurgers(int t, int c) {\\n\\t\\t\\t\\t// Lets assume a is total number of tomato slices for jumbo burger and b is total number of tomato slices for small burger\\n\\t\\t\\t\\t// Now if provided data will give answer it must satisfy these two given equation \\n\\t\\t\\t   // Equation 1\\n\\t\\t\\t\\t// a/4 + b/2 = c    i.e. total tomato slices for jumbo burger / 4 + total slices for small burger / 2 should be equal to total cheese slices\\n\\t\\t\\t\\t// Equation 2\\n\\t\\t\\t\\t// a+b = t       also total tomato slices for jumbo burger + total slices for small burger  should be equal to total cheese tomato slice\\n\\t\\t\\t\\t// here t is total tomato slice and c is total cheese slice \\n\\t\\t\\t\\tint b = 4*c-t;\\n\\t\\t\\t\\tint a = t-b;\\n\\t\\t\\t\\tif( a<0 || b<0 || b%2!=0 || a%4 !=0) return {}",
                "codeTag": "Java"
            },
            {
                "id": 3570961,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (cheeseSlices * 2 > tomatoSlices) return [];\\n    if (tomatoSlices % 2 === 1) return [];\\n    if (tomatoSlices === 0 && cheeseSlices === 0) return [0, 0];\\n\\n    const maxSmallBurger = tomatoSlices / 2;\\n    const jumboBurger = maxSmallBurger - cheeseSlices;\\n    const smallBurger = maxSmallBurger - jumboBurger * 2;\\n\\n    return smallBurger >= 0 ? [jumboBurger, smallBurger] : [];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (cheeseSlices * 2 > tomatoSlices) return [];\\n    if (tomatoSlices % 2 === 1) return [];\\n    if (tomatoSlices === 0 && cheeseSlices === 0) return [0, 0];\\n\\n    const maxSmallBurger = tomatoSlices / 2;\\n    const jumboBurger = maxSmallBurger - cheeseSlices;\\n    const smallBurger = maxSmallBurger - jumboBurger * 2;\\n\\n    return smallBurger >= 0 ? [jumboBurger, smallBurger] : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3430090,
                "title": "alternative-solution-binary-search-explained",
                "content": "# Intuition\\nWell you can do this problem in many linear way but i tried to do this in binary search for a better understanding of binary Search algorithm.\\nSo what are the left and right limits? Its the 0 and the max Jumbo burger we can create from given tomatoes(t).\\nFind the remaining tomatoes left for making small burgers after making jumbo burgers, if it is equal to number of cheese(c) given return it as ans.\\nNow suppose the total no of Jumbo + small burger < required Burger\\n-> We are making more Jumbo than required shift right pointer\\nelse:\\nshift left pointer\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        if t % 2 != 0: # its odd then 1 tomato will always be remaining\\n          return []\\n        totalJumbo = t // 4\\n        left = 0\\n        right = totalJumbo\\n        while left < right:\\n            mid = (left + right) // 2\\n            remaining = t - (4 * mid)\\n            totalSmall = remaining / 2\\n            burgerPossible = mid + totalSmall\\n            if burgerPossible == c:\\n                return [mid, int(totalSmall)]\\n            elif (burgerPossible) < c: # we are making more jumbo reduce it \\n                right = mid\\n            else:\\n                left = mid + 1\\n        remaining = t - (4 * left)\\n        Small = remaining / 2\\n        if left + Small == c:\\n            return [left, int(Small)]\\n        return []\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        if t % 2 != 0: # its odd then 1 tomato will always be remaining\\n          return []\\n        totalJumbo = t // 4\\n        left = 0\\n        right = totalJumbo\\n        while left < right:\\n            mid = (left + right) // 2\\n            remaining = t - (4 * mid)\\n            totalSmall = remaining / 2\\n            burgerPossible = mid + totalSmall\\n            if burgerPossible == c:\\n                return [mid, int(totalSmall)]\\n            elif (burgerPossible) < c: # we are making more jumbo reduce it \\n                right = mid\\n            else:\\n                left = mid + 1\\n        remaining = t - (4 * left)\\n        Small = remaining / 2\\n        if left + Small == c:\\n            return [left, int(Small)]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845361,
                "title": "no-math-intuitive-greedy-solution",
                "content": "Split tomatoSlices to count of 4s as maximum as possible. For Example if tomatoSlices are 18 then count of 4s should be 4 and count of 2s should be 2. Silimarly for 16, count of 4 is 4 and count of 2 is 0.  Then we break down the count of 4s and count of 2s such that it equals to cheeseSlices.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n    \\n        if(cheeseSlices == 0 && tomatoSlices == 0){\\n            return {0, 0} ;\\n        }\\n        if(cheeseSlices >= tomatoSlices || tomatoSlices %2 != 0){\\n            return {} ;\\n        }\\n        int cnt4s = 0 ;\\n        int cnt2s = 0 ;\\n        if(tomatoSlices %4 == 0){\\n            cnt4s += tomatoSlices /4 ;\\n        }else{\\n            cnt4s += tomatoSlices /4 ;\\n            cnt2s++ ;\\n        }\\n        \\n        while(cheeseSlices > (cnt4s + cnt2s)){\\n            if(cnt4s < 0){\\n                return {};\\n            }\\n            cnt4s-- ;\\n            cnt2s += 2 ;\\n        }\\n        \\n        if(cheeseSlices == (cnt4s + cnt2s)){\\n            return {cnt4s, cnt2s} ;\\n        }\\n        return {} ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n    \\n        if(cheeseSlices == 0 && tomatoSlices == 0){\\n            return {0, 0} ;\\n        }\\n        if(cheeseSlices >= tomatoSlices || tomatoSlices %2 != 0){\\n            return {} ;\\n        }\\n        int cnt4s = 0 ;\\n        int cnt2s = 0 ;\\n        if(tomatoSlices %4 == 0){\\n            cnt4s += tomatoSlices /4 ;\\n        }else{\\n            cnt4s += tomatoSlices /4 ;\\n            cnt2s++ ;\\n        }\\n        \\n        while(cheeseSlices > (cnt4s + cnt2s)){\\n            if(cnt4s < 0){\\n                return {};\\n            }\\n            cnt4s-- ;\\n            cnt2s += 2 ;\\n        }\\n        \\n        if(cheeseSlices == (cnt4s + cnt2s)){\\n            return {cnt4s, cnt2s} ;\\n        }\\n        return {} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843901,
                "title": "c-easy-fast",
                "content": "\\n# Code\\n```\\n//from lee 215\\nclass Solution {\\npublic:\\n        vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from lee 215\\nclass Solution {\\npublic:\\n        vector<int> numOfBurgers(int t, int c) {\\n        if (t % 2 == 0 && c * 2 <= t && t <= c * 4)\\n            return {t / 2 - c, c * 2 - t / 2};\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609231,
                "title": "c-easy-solution-explained-with-comments-tc-o-1-oc-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int a = tomatoSlices;\\n        int b = cheeseSlices;\\n        \\n        // Let the number of Jumbo and Small Burger be x and y\\n        double x,y;\\n        \\n        // Solve the simultaneous equation for x and y\\n        x = (double)(a-2*b)/(double)2;\\n        y = (double)(4*b-a)/(double)2;\\n        \\n        // Check if they can be actual values of number of burgers\\n        if(x==(int)x && y==(int)y && x>=0 && y>=0){\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int a = tomatoSlices;\\n        int b = cheeseSlices;\\n        \\n        // Let the number of Jumbo and Small Burger be x and y\\n        double x,y;\\n        \\n        // Solve the simultaneous equation for x and y\\n        x = (double)(a-2*b)/(double)2;\\n        y = (double)(4*b-a)/(double)2;\\n        \\n        // Check if they can be actual values of number of burgers\\n        if(x==(int)x && y==(int)y && x>=0 && y>=0){\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520545,
                "title": "obviously-range-is-between-0-cheezeslice-cheezeslice-0-check-all-cases-matching-to-tomato-one",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(c>t/2 || t%2 || t/4 > c)\\n            return {};\\n        \\n        for(int i=0;i<=c;i++)\\n        {\\n            if(i*4 + (c-i)*2 == t)\\n                return {i,c-i};\\n        }\\n        \\n        return {};\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(c>t/2 || t%2 || t/4 > c)\\n            return {};\\n        \\n        for(int i=0;i<=c;i++)\\n        {\\n            if(i*4 + (c-i)*2 == t)\\n                return {i,c-i};\\n        }\\n        \\n        return {};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351357,
                "title": "python-o-1-tc-o-1-sc",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n\\t\\t\\t# total_jumbo + total_small = cheeseSlices\\n\\t\\t\\t# (4 * total_jumbo) + (2 * total_small) = tomatoSlices ie..., (2 * total_jumbo) + total_small = tomatoSlices / 2\\n\\n\\t\\t\\t# solve above two eq for total_jumbo and total_small;\\n\\t\\t\\t# total_jumbo = tomatoSlices/2 - cheeseSlices\\n\\t\\t\\t# total_small = 2*cheeseSlices - tomatoSlices/2\\n\\n\\t\\t\\tif 2 * cheeseSlices <= tomatoSlices <= 4 * cheeseSlices and  not tomatoSlices % 2:\\n\\t\\t\\t\\treturn [tomatoSlices // 2 - cheeseSlices, 2 * cheeseSlices - tomatoSlices // 2]\\n\\t\\t\\telse: return []\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n\\t\\t\\t# total_jumbo + total_small = cheeseSlices\\n\\t\\t\\t# (4 * total_jumbo) + (2 * total_small) = tomatoSlices ie..., (2 * total_jumbo) + total_small = tomatoSlices / 2\\n\\n\\t\\t\\t# solve above two eq for total_jumbo and total_small;\\n\\t\\t\\t# total_jumbo = tomatoSlices/2 - cheeseSlices\\n\\t\\t\\t# total_small = 2*cheeseSlices - tomatoSlices/2\\n\\n\\t\\t\\tif 2 * cheeseSlices <= tomatoSlices <= 4 * cheeseSlices and  not tomatoSlices % 2:\\n\\t\\t\\t\\treturn [tomatoSlices // 2 - cheeseSlices, 2 * cheeseSlices - tomatoSlices // 2]\\n\\t\\t\\telse: return []\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1941373,
                "title": "binary-search-on-tomatoes-assuming-atleast-one-answer-exists",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ans = cheeseSlices;\\n        int low = 0, high = ans;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if((mid * 4) + ((ans - mid) * 2) == tomatoSlices)\\n                return {mid, ans - mid};\\n           if((mid * 4) + ((ans - mid) * 2) < tomatoSlices)\\n               low = mid +1;\\n            else\\n                high = mid - 1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ans = cheeseSlices;\\n        int low = 0, high = ans;\\n        while(low <= high)\\n        {\\n            int mid = (low + high) / 2;\\n            if((mid * 4) + ((ans - mid) * 2) == tomatoSlices)\\n                return {mid, ans - mid};\\n           if((mid * 4) + ((ans - mid) * 2) < tomatoSlices)\\n               low = mid +1;\\n            else\\n                high = mid - 1;\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783836,
                "title": "c-2-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato>cheese*4 or tomato<2*cheese or tomato%2!=0) return {};\\n        return {tomato/2-cheese, cheese*2-tomato/2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato>cheese*4 or tomato<2*cheese or tomato%2!=0) return {};\\n        return {tomato/2-cheese, cheese*2-tomato/2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1773626,
                "title": "time-o-1-and-space-o-1-explore-the-unexplored",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices == 0 and cheeseSlices == 0:\\n            return [0,0]\\n        elif tomatoSlices % 2 != 0 or cheeseSlices * 4 < tomatoSlices or tomatoSlices < cheeseSlices * 2 or cheeseSlices == 0 or tomatoSlices == 0:\\n            return []\\n        \\n        remaining = tomatoSlices - (cheeseSlices * 2)\\n        \\n        if 4 * (remaining // 2) + (2 * (cheeseSlices - (remaining // 2))) == tomatoSlices:\\n            return [remaining // 2, cheeseSlices - (remaining // 2)]\\n\\n        return []\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices == 0 and cheeseSlices == 0:\\n            return [0,0]\\n        elif tomatoSlices % 2 != 0 or cheeseSlices * 4 < tomatoSlices or tomatoSlices < cheeseSlices * 2 or cheeseSlices == 0 or tomatoSlices == 0:\\n            return []\\n        \\n        remaining = tomatoSlices - (cheeseSlices * 2)\\n        \\n        if 4 * (remaining // 2) + (2 * (cheeseSlices - (remaining // 2))) == tomatoSlices:\\n            return [remaining // 2, cheeseSlices - (remaining // 2)]\\n\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630421,
                "title": "fast-python-sol-o-1",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = tomatoSlices - 2 * cheeseSlices\\n        if x >= 0 and x % 2 == 0 and cheeseSlices - x // 2 >= 0:\\n            return [x // 2, cheeseSlices - x // 2]\\n        return []",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = tomatoSlices - 2 * cheeseSlices\\n        if x >= 0 and x % 2 == 0 and cheeseSlices - x // 2 >= 0:\\n            return [x // 2, cheeseSlices - x // 2]\\n        return []",
                "codeTag": "Java"
            },
            {
                "id": 1485768,
                "title": "c-simple-maths",
                "content": "\\n    // jumbo{4t,1c}\\n    // small{2t,1c}\\n    vector<int> numOfBurgers(int tom, int che) {\\n        int j,s;\\n        // 4*j + 2*s=tom\\n        // j+s=che \\n        \\n        if(int((tom-2*che)/2)==(double)(tom-2*che)/2)\\n        {\\n            j=(tom-2*che)/2;\\n            s=che-j;\\n            if(j>=0 && s>=0)\\n            return vector<int>{j,s};\\n        }\\n        \\n        return vector<int>();\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "\\n    // jumbo{4t,1c}\\n    // small{2t,1c}\\n    vector<int> numOfBurgers(int tom, int che) {\\n        int j,s;\\n        // 4*j + 2*s=tom\\n        // j+s=che \\n        \\n        if(int((tom-2*che)/2)==(double)(tom-2*che)/2)\\n        {\\n            j=(tom-2*che)/2;\\n            s=che-j;\\n            if(j>=0 && s>=0)\\n            return vector<int>{j,s};\\n        }\\n        \\n        return vector<int>();\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1293382,
                "title": "c-math-solution",
                "content": "Solution:\\nLet T = # of tomato slices, C = # of cheese slices, x = # of jumbo burgers, y = # of small burgers => x + y = C, 4x + 2y = T\\nSolving the system of equations we get x = (T - 2C) / 2, y = C - (T - 2C) / 2 = (4C - T) / 2\\n\\n```\\nclass Solution {\\npublic:\\n    /// 4 ms, faster than 68.27% of C++\\n    /// 7.1 MB, less than 97.21% of C++\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if (tomatoSlices % 2)\\n            return vector<int>();\\n        int jb = (tomatoSlices - 2*cheeseSlices) / 2;\\n        int sb = cheeseSlices - jb;\\n        if (jb < 0 || sb < 0)\\n            return vector<int>();\\n        return {jb,sb};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    /// 4 ms, faster than 68.27% of C++\\n    /// 7.1 MB, less than 97.21% of C++\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if (tomatoSlices % 2)\\n            return vector<int>();\\n        int jb = (tomatoSlices - 2*cheeseSlices) / 2;\\n        int sb = cheeseSlices - jb;\\n        if (jb < 0 || sb < 0)\\n            return vector<int>();\\n        return {jb,sb}",
                "codeTag": "Java"
            },
            {
                "id": 1289712,
                "title": "simple-linear-eqn-solving-faster-than-100-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int vt, int vc) {\\n        int x=0,y=0;\\n        List<Integer> al=new ArrayList<>();\\n// 4x+2y=vt and x+y=vc =>2x=vt-2*vc=> x=vt-2*vc/2 only if x and y are pos integer its valid\\n\\n        if(vt>=2*vc&&(vt-2*vc)%2==0){\\n           x=(vt-2*vc)/2;\\n            y=vc-x; \\n            if(y>=0){\\n                al.add(x);\\n            al.add(y);\\n            }\\n        }\\n        return al;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> numOfBurgers(int vt, int vc) {\\n        int x=0,y=0;\\n        List<Integer> al=new ArrayList<>();\\n// 4x+2y=vt and x+y=vc =>2x=vt-2*vc=> x=vt-2*vc/2 only if x and y are pos integer its valid\\n\\n        if(vt>=2*vc&&(vt-2*vc)%2==0){\\n           x=(vt-2*vc)/2;\\n            y=vc-x; \\n            if(y>=0){\\n                al.add(x);\\n            al.add(y);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1226554,
                "title": "java-intuitive-o-1-o-1-choose-1-type-convert",
                "content": "The idea is simple... start with all small (based on number of cheese slices), then see how many we need to convert to large to satisfy the target. If the number of conversions we need to do is negative or greater than the number of smalls we have, it cannot be done.\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if (tomatoSlices % 2 == 1) return List.of();\\n        \\n        int nSmall = cheeseSlices; // assume all small\\n        \\n        int nTomatoSlicesLeft = tomatoSlices - nSmall * 2;\\n        int nLarge = nTomatoSlicesLeft / 2;\\n        \\n        if (nLarge < 0) return List.of(); // smalls alone used more than available tomato slices\\n        if (nLarge > nSmall) return List.of(); // not enough to convert\\n        \\n        nSmall -= nLarge;\\n        \\n        return List.of(nLarge, nSmall);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if (tomatoSlices % 2 == 1) return List.of();\\n        \\n        int nSmall = cheeseSlices; // assume all small\\n        \\n        int nTomatoSlicesLeft = tomatoSlices - nSmall * 2;\\n        int nLarge = nTomatoSlicesLeft / 2;\\n        \\n        if (nLarge < 0) return List.of(); // smalls alone used more than available tomato slices\\n        if (nLarge > nSmall) return List.of(); // not enough to convert\\n        \\n        nSmall -= nLarge;\\n        \\n        return List.of(nLarge, nSmall);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1221140,
                "title": "solving-using-linear-equation",
                "content": "```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        y = (4*cheeseSlices - tomatoSlices)\\n        if y%2==0 and y>=0:\\n            y/=2\\n            if(cheeseSlices-y>=0):\\n                return [cheeseSlices-y, y]\\n        return []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        y = (4*cheeseSlices - tomatoSlices)\\n        if y%2==0 and y>=0:\\n            y/=2\\n            if(cheeseSlices-y>=0):\\n                return [cheeseSlices-y, y]\\n        return []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194577,
                "title": "java-0-1-time-and-o-1-space",
                "content": "Let x be the jumbo and y be the small burgers two linear equations formed will be\\n4x+2y=No.of tomato\\nx+y=No.of cheese\\nRest can be done by using simple maths\\nPlease upvote if you like the approach\\n\\n```\\n public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if((tomatoSlices-2*cheeseSlices)%2!=0){\\n            return new ArrayList<>();\\n        }\\n        \\n        int jumbo=(tomatoSlices-2*cheeseSlices)/2;\\n        int small=(cheeseSlices-jumbo);\\n        \\n      \\n        \\n        List<Integer> result=new ArrayList<>();\\n        if(jumbo>=0 && small>=0){\\n        result.add(jumbo);\\n        result.add(small);\\n        return result;\\n        }\\n        else{\\n          return result;\\n        }\\n       \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Let x be the jumbo and y be the small burgers two linear equations formed will be\\n4x+2y=No.of tomato\\nx+y=No.of cheese\\nRest can be done by using simple maths\\nPlease upvote if you like the approach\\n\\n```\\n public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if((tomatoSlices-2*cheeseSlices)%2!=0){\\n            return new ArrayList<>();\\n        }\\n        \\n        int jumbo=(tomatoSlices-2*cheeseSlices)/2;\\n        int small=(cheeseSlices-jumbo);\\n        \\n      \\n        \\n        List<Integer> result=new ArrayList<>();\\n        if(jumbo>=0 && small>=0){\\n        result.add(jumbo);\\n        result.add(small);\\n        return result;\\n        }\\n        else{\\n          return result;\\n        }\\n       \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1188000,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        total_jumbo = 0\\n        total_small = 0\\n        if tomatoSlices%2 != 0 or tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices :\\n\\t\\t\\t#checking for invalid values\\n            return []\\n        else:\\n            if tomatoSlices > 0 and cheeseSlices > 0:\\n                k = tomatoSlices % (2*cheeseSlices) #number of tomatoslices remained after making all small\\n                total_small += cheeseSlices \\n                if k > 0:\\n\\t\\t\\t\\t    #sending slices from small to jumbo\\n                    total_jumbo  = k // 2\\n                    total_small -= total_jumbo  \\n        return [total_jumbo,total_small]\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        total_jumbo = 0\\n        total_small = 0\\n        if tomatoSlices%2 != 0 or tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices :\\n\\t\\t\\t#checking for invalid values\\n            return []\\n        else:\\n            if tomatoSlices > 0 and cheeseSlices > 0:\\n                k = tomatoSlices % (2*cheeseSlices) #number of tomatoslices remained after making all small\\n                total_small += cheeseSlices \\n                if k > 0:\\n\\t\\t\\t\\t    #sending slices from small to jumbo\\n                    total_jumbo  = k // 2\\n                    total_small -= total_jumbo  \\n        return [total_jumbo,total_small]\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166666,
                "title": "very-easy-greedy-approach-in-c",
                "content": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {};\\n        else \\n        {\\n            int k=(tomatoSlices/2-cheeseSlices);\\n                if(k<0)\\n                    return {};\\n            int p=(cheeseSlices-k);\\n                if(p<0)\\n                    return {};\\n            return {k,p};\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 1114739,
                "title": "c-binary-search-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Binary search: we know for sure the # of small burgers will be >= 0 && <= cheeseSlices.\\n        // So we use binary search to find out the ultimate # of small burgers.\\n        //\\n        // The condition is:\\n        // 1) if the left tomato slices and cheese slices can make exact N # of jumbos, return the result.\\n        // 2) if the left tomato slices is not enough to make exact # of jumbos, we need to make more small\\n        //    burgers and less jumbo burgers, hence search from mid + 1 to right.\\n        // 3) if left cheese slices is not enough to make exact # of jumbos, we need to make less small burgers\\n        //    and more jumbo burgers, hence search from left to mid - 1.\\n        return numOfBurgers(tomatoSlices, cheeseSlices, 0, cheeseSlices);\\n    }\\n    \\nprivate:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return {};\\n        }\\n        \\n        int mid = left + (right - left) / 2; \\n        int leftTomatoes = tomatoSlices - mid * 2;\\n        int leftCheeses = cheeseSlices - mid;\\n        \\n        if (leftCheeses * 4 == leftTomatoes)\\n        {\\n            return {leftCheeses, mid};\\n        }\\n        \\n        if (leftCheeses * 4 < leftTomatoes)\\n        {\\n            return numOfBurgers(tomatoSlices, cheeseSlices, left, mid - 1);\\n        }\\n        \\n        return numOfBurgers(tomatoSlices, cheeseSlices, mid + 1, right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Binary search: we know for sure the # of small burgers will be >= 0 && <= cheeseSlices.\\n        // So we use binary search to find out the ultimate # of small burgers.\\n        //\\n        // The condition is:\\n        // 1) if the left tomato slices and cheese slices can make exact N # of jumbos, return the result.\\n        // 2) if the left tomato slices is not enough to make exact # of jumbos, we need to make more small\\n        //    burgers and less jumbo burgers, hence search from mid + 1 to right.\\n        // 3) if left cheese slices is not enough to make exact # of jumbos, we need to make less small burgers\\n        //    and more jumbo burgers, hence search from left to mid - 1.\\n        return numOfBurgers(tomatoSlices, cheeseSlices, 0, cheeseSlices);\\n    }\\n    \\nprivate:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices, int left, int right)\\n    {\\n        if (left > right)\\n        {\\n            return {};\\n        }\\n        \\n        int mid = left + (right - left) / 2; \\n        int leftTomatoes = tomatoSlices - mid * 2;\\n        int leftCheeses = cheeseSlices - mid;\\n        \\n        if (leftCheeses * 4 == leftTomatoes)\\n        {\\n            return {leftCheeses, mid};\\n        }\\n        \\n        if (leftCheeses * 4 < leftTomatoes)\\n        {\\n            return numOfBurgers(tomatoSlices, cheeseSlices, left, mid - 1);\\n        }\\n        \\n        return numOfBurgers(tomatoSlices, cheeseSlices, mid + 1, right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039997,
                "title": "easy-c-with-comments-linear-equations",
                "content": "Jumbo Burgers: 4 Tomatoes + 1 CheeseSlice\\nSmall Burgers: 2 Tomatoes + 1 CheeseSlice\\n\\nb = Jumbo Burgers, s = Small burgers\\n\\nThe two equations are\\n4*b + 2*s = Total no. of TomatoSlices\\nb + s = Total no. of CheeseSlices\\n\\n**if no. TomatoSlices is odd then no solution possible**\\n\\nsolving them we get-\\n\\n**Jumbo Burgers = TomatoSlices/2 - cheeseSlices\\nSmall Burgers = 2*CheeseSlices - TomatoSlices/2**\\n\\n```\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // base case\\n            return {};\\n        \\n        tomatoSlices /=2;\\n        int b=tomatoSlices - cheeseSlices, s= 2*cheeseSlices - tomatoSlices;\\n        \\n        if(b < 0 || s < 0) // if b or s comes out to be negative\\n            return {};\\n        \\n        return {b, s};\\n    }\\n",
                "solutionTags": [],
                "code": "Jumbo Burgers: 4 Tomatoes + 1 CheeseSlice\\nSmall Burgers: 2 Tomatoes + 1 CheeseSlice\\n\\nb = Jumbo Burgers, s = Small burgers\\n\\nThe two equations are\\n4*b + 2*s = Total no. of TomatoSlices\\nb + s = Total no. of CheeseSlices\\n\\n**if no. TomatoSlices is odd then no solution possible**\\n\\nsolving them we get-\\n\\n**Jumbo Burgers = TomatoSlices/2 - cheeseSlices\\nSmall Burgers = 2*CheeseSlices - TomatoSlices/2**\\n\\n```\\nvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // base case\\n            return {};\\n        \\n        tomatoSlices /=2;\\n        int b=tomatoSlices - cheeseSlices, s= 2*cheeseSlices - tomatoSlices;\\n        \\n        if(b < 0 || s < 0) // if b or s comes out to be negative\\n            return {};\\n        \\n        return {b, s};\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1029915,
                "title": "simple-linear-equation-solution",
                "content": "Lets say we take x jumbo and y small burgers so we can say that:\\n```\\n\\tx + y = cheese_slices\\n\\t\\n\\t4x + y = tomato_slices\\n\\t\\n```\\n\\nOn solving the 2 linear equation we only want +ve solutions\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs){\\n        if(ts%2)\\n            return {};\\n        if(ts/2 < cs || 2*cs < ts/2)\\n            return {};      \\n        int jmb = (ts - 2*cs)/2;\\n        int sml = (2*cs - ts/2);\\n        return {jmb, sml};\\n    }\\n};\\n```\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tx + y = cheese_slices\\n\\t\\n\\t4x + y = tomato_slices\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs){\\n        if(ts%2)\\n            return {};\\n        if(ts/2 < cs || 2*cs < ts/2)\\n            return {};      \\n        int jmb = (ts - 2*cs)/2;\\n        int sml = (2*cs - ts/2);\\n        return {jmb, sml};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909355,
                "title": "c-o-1-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int> v;\\n        if(4*c<t) return v;\\n        if((4*c-t)%2!=0) return v;\\n        \\n        int x = (4*c-t)/2;\\n        if(c-x<0) return v;\\n        v.push_back(c-x);\\n        v.push_back(x);\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int> v;\\n        if(4*c<t) return v;\\n        if((4*c-t)%2!=0) return v;\\n        \\n        int x = (4*c-t)/2;\\n        if(c-x<0) return v;\\n        v.push_back(c-x);\\n        v.push_back(x);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 903002,
                "title": "c-simple-maths-explanation-0ms",
                "content": "Solving Equations:\\nLet no of big burgers be X,\\nLet no of small burgers be Y,\\nthen,\\n4X + 2Y=T             (i)\\nX + Y=C         (ii)\\nfrom (ii),          Y=C-X\\n4X + 2 (C-X) =T\\n4X + 2C - 2X=T\\n2X + 2C=T\\nX=(T - 2C) / 2        : where T= tomatoslices and C= cheeseslices which is given.\\n& Y= C-X\\nhence {X,Y} is the answer.\\t\\t   \\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {};\\n        if(cheeseSlices<tomatoSlices/4)\\n            return {};\\n        if(cheeseSlices>tomatoSlices/2)\\n            return {};\\n        int x=(tomatoSlices-(2*cheeseSlices))/2;\\n        int y=cheeseSlices-x;\\n        return {x,y};\\n    }\\n};\\n```\\nPlease Upvote if you like!!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0)\\n            return {};\\n        if(cheeseSlices<tomatoSlices/4)\\n            return {};\\n        if(cheeseSlices>tomatoSlices/2)\\n            return {};\\n        int x=(tomatoSlices-(2*cheeseSlices))/2;\\n        int y=cheeseSlices-x;\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849216,
                "title": "python3-gaussian-elimination",
                "content": "```\\ndef gaussianElimination(m):\\n    r, c = len(m), len(m[0])\\n    for i in range(r):\\n        # if m[i][i] is 0, find j that m[j][i] != 0 and exchange rows i and j.\\n        for j in range(i, r):\\n            if m[j][i] != 0:\\n                m[i], m[j] = m[j], m[i]\\n                break\\n        # no solution.\\n        if m[i][i] == 0:\\n            return []\\n        # do row reduction for every row, so we don\\'t need back substitution.\\n        for j in range(r):\\n            if j == i: continue\\n            diff = - m[j][i] / m[i][i]\\n            for k in range(c):\\n                m[j][k] += diff * m[i][k]\\n    return [m[i][-1] / m[i][i] for i in range(r)]\\n\\ndef normalize(res):\\n    r = [int(x) for x in res if x >= 0 and abs(x - int(x)) < 0.000001]\\n    if len(r) != len(res):\\n        return []\\n    return r\\n\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        res = gaussianElimination([[4, 2, t], [1, 1, c]])\\n        return normalize(res)\\n```",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\ndef gaussianElimination(m):\\n    r, c = len(m), len(m[0])\\n    for i in range(r):\\n        # if m[i][i] is 0, find j that m[j][i] != 0 and exchange rows i and j.\\n        for j in range(i, r):\\n            if m[j][i] != 0:\\n                m[i], m[j] = m[j], m[i]\\n                break\\n        # no solution.\\n        if m[i][i] == 0:\\n            return []\\n        # do row reduction for every row, so we don\\'t need back substitution.\\n        for j in range(r):\\n            if j == i: continue\\n            diff = - m[j][i] / m[i][i]\\n            for k in range(c):\\n                m[j][k] += diff * m[i][k]\\n    return [m[i][-1] / m[i][i] for i in range(r)]\\n\\ndef normalize(res):\\n    r = [int(x) for x in res if x >= 0 and abs(x - int(x)) < 0.000001]\\n    if len(r) != len(res):\\n        return []\\n    return r\\n\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        res = gaussianElimination([[4, 2, t], [1, 1, c]])\\n        return normalize(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844915,
                "title": "simple-math",
                "content": "```java\\n/*\\n* 4x + 2y = tomato\\n* 1*x + 1*y = cheese\\n*/\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int jumbo = tomatoSlices/2-cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n        if (jumbo < 0 || small < 0 || tomatoSlices%2 == 1) {\\n            return Collections.emptyList();\\n        }\\n        return Arrays.asList(jumbo, small);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/*\\n* 4x + 2y = tomato\\n* 1*x + 1*y = cheese\\n*/\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int jumbo = tomatoSlices/2-cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n        if (jumbo < 0 || small < 0 || tomatoSlices%2 == 1) {\\n            return Collections.emptyList();\\n        }\\n        return Arrays.asList(jumbo, small);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733966,
                "title": "c-simple-5-line-sol",
                "content": "**Explanation** : Let\\'s assume \\n`x` be the *number of Jumbo Burgers* \\n`y` be the *number of Small Burger*. \\nSo total tomatoSlices used will be given by equation (ts) : \\n`ts` : ***4x+2y***\\nTotal CheeseSlices used (cs) : \\n`cs` : ***x + y***\\n\\nSolving the following would give us x = `ts-2*cs/2`\\nIf any of x and y is negative then it\\'s not possible to make `ts and cs` as 0.\\nand if total ts obtained after using x and y is <0 or >0 then also the answer won\\'t exist.\\nReturn `{}` in those cases else return `{x,y}`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        int x = (ts- 2*cs)/2;\\n        int y = cs- x;\\n        if(x <0 || y<0) return {};\\n        if(4*x + 2*y < ts || 4*x + 2*y > ts) return {};  \\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        int x = (ts- 2*cs)/2;\\n        int y = cs- x;\\n        if(x <0 || y<0) return {};\\n        if(4*x + 2*y < ts || 4*x + 2*y > ts) return {};  \\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733241,
                "title": "python-math-solution",
                "content": "X: Big burger Y: small burger\\n\\n4X + 2Y = T \\nX+Y = C\\n\\n=> X = T/2-C, Y = 2C-T/2 , both X and Y need > 0 , so \\n```\\nif tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n```\\n\\nSource \\n\\n```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if tomatoSlices%2 == 1:\\n            return []\\n        \\n        if tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n        \\n        return [tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nif tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n```\n```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if tomatoSlices%2 == 1:\\n            return []\\n        \\n        if tomatoSlices < 2*cheeseSlices or tomatoSlices > 4*cheeseSlices:\\n            return []\\n        \\n        return [tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 534759,
                "title": "java-this-question-should-be-under-easy",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if(tomatoSlices % 2 == 1){\\n            return res;\\n        }\\n\\n        int smallCount = cheeseSlices*2;\\n        int extra = tomatoSlices - smallCount;\\n        if(extra >= 0) {\\n            int jumboCount = extra / 2;\\n\\n            if(cheeseSlices >= jumboCount) {\\n                res.add(jumboCount);\\n                res.add(cheeseSlices - jumboCount);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if(tomatoSlices % 2 == 1){\\n            return res;\\n        }\\n\\n        int smallCount = cheeseSlices*2;\\n        int extra = tomatoSlices - smallCount;\\n        if(extra >= 0) {\\n            int jumboCount = extra / 2;\\n\\n            if(cheeseSlices >= jumboCount) {\\n                res.add(jumboCount);\\n                res.add(cheeseSlices - jumboCount);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488609,
                "title": "rust-4ms-and-1-9mb-100",
                "content": "Solve it use math directly\\n\\n```rust\\n// [tomato_slices /2 - cheese_slices, 2 * cheese_slices - tomato_slices / 2]  tomato_slices should be even\\npub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n    if tomato_slices % 2 != 0 { return Vec::<i32>::new(); }\\n    let x = tomato_slices / 2 - cheese_slices;\\n    let y = 2 * cheese_slices - tomato_slices / 2;\\n    if x < 0 || y < 0 { return Vec::<i32>::new(); };\\n    vec![x, y]\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n// [tomato_slices /2 - cheese_slices, 2 * cheese_slices - tomato_slices / 2]  tomato_slices should be even\\npub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n    if tomato_slices % 2 != 0 { return Vec::<i32>::new(); }\\n    let x = tomato_slices / 2 - cheese_slices;\\n    let y = 2 * cheese_slices - tomato_slices / 2;\\n    if x < 0 || y < 0 { return Vec::<i32>::new(); };\\n    vec![x, y]\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 444801,
                "title": "i-psyched-myself-out-so-i-came-up-with-a-python-binary-search-solution-88-faster",
                "content": "Is this overkill?\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\tif tomatoSlices % 2 == 1:\\n\\t\\treturn []\\n\\n\\tst = 0\\n\\ten = cheeseSlices\\n\\n\\twhile(st < en):\\n\\t\\thalf = st + math.floor((en - st) / 2)\\n\\n\\t\\tsm = (half * 4) + ((cheeseSlices-half)*2)\\n\\t\\tif sm == tomatoSlices:\\n\\t\\t\\treturn [half, cheeseSlices-half]\\n\\n\\t\\tif sm < tomatoSlices:\\n\\t\\t\\tst = half+1\\n\\t\\telse:\\n\\t\\t\\ten = half\\n\\n\\tif cheeseSlices * 4 == tomatoSlices:\\n\\t\\treturn [cheeseSlices, 0]\\n\\n\\treturn []\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\tif tomatoSlices % 2 == 1:\\n\\t\\treturn []\\n\\n\\tst = 0\\n\\ten = cheeseSlices\\n\\n\\twhile(st < en):\\n\\t\\thalf = st + math.floor((en - st) / 2)\\n\\n\\t\\tsm = (half * 4) + ((cheeseSlices-half)*2)\\n\\t\\tif sm == tomatoSlices:\\n\\t\\t\\treturn [half, cheeseSlices-half]\\n\\n\\t\\tif sm < tomatoSlices:\\n\\t\\t\\tst = half+1\\n\\t\\telse:\\n\\t\\t\\ten = half\\n\\n\\tif cheeseSlices * 4 == tomatoSlices:\\n\\t\\treturn [cheeseSlices, 0]\\n\\n\\treturn []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 441479,
                "title": "python-time-o-1-100-0-space-o-1-100-0-full-explain",
                "content": "For explain, please see comments.\\nI just want to say... who will buy a jumbo burger that only have more tomato? Seriousely?\\n\\n\\n```\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282876212/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Its a simple binary simultaneous equations\\n        # We have:\\n        #   f1: 4x+2y = tomatoSlices\\n        #   f2: x+y = cheeseSlices\\n        # Get x (total_jumbo):\\n        #   2x = (4x+2y) - (2x+2y)\\n        #      = f1 - 2*f2\\n        #      = tomatoSlices - 2*cheeseSlices\\n        #    x = 0.5*tomatoSlices - cheeseSlices\\n        # Get y (total_small):\\n        #    y = f1 - x\\n        #      = cheeseSlices - x \\n        #      = cheeseSlices - (0.5*tomatoSlices - cheeseSlices)\\n        #    y = -0.5*tomatoSlices + 2*cheeseSlices\\n        # Note:\\n        #   We solve the function, but its answer might not fit in this case\\n        #   1. We can\\'t sell half burger\\n        #   2. We can\\'t sell negative burger\\n        #   3. According to (1) and (2), x and y must be natural number (0 included)\\n        #   4. We didn\\'t need to worry about error in float, because it just divide by 2,\\n        #      which means there will no error occur in this situation\\n        x =  0.5*tomatoSlices -   cheeseSlices\\n        y = -0.5*tomatoSlices + 2*cheeseSlices\\n        \\n        if not x.is_integer() or not y.is_integer() or x < 0 or y < 0:\\n            return []\\n        else:\\n            return[int(x), int(y)]\\n```\\n\\nIf you really didn\\'t want to use float, well by add a check, we can use only integer\\nAnd if your are crazy, so you decide not to use any divide or multiply, well, use shift\\nBut this way will let code not let clean since we seperate the return place\\n```python\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282877921/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Only tomatoSlices need to be divide\\n        # You can also check this first\\n        if tomatoSlices & 1: return []\\n        \\n        x =  (tomatoSlices>>1) - (cheeseSlices)\\n        y = -(tomatoSlices>>1) + (cheeseSlices<<1)\\n        \\n        if x < 0 or y < 0:\\n            return []\\n        else:\\n            return [x, y]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282876212/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Its a simple binary simultaneous equations\\n        # We have:\\n        #   f1: 4x+2y = tomatoSlices\\n        #   f2: x+y = cheeseSlices\\n        # Get x (total_jumbo):\\n        #   2x = (4x+2y) - (2x+2y)\\n        #      = f1 - 2*f2\\n        #      = tomatoSlices - 2*cheeseSlices\\n        #    x = 0.5*tomatoSlices - cheeseSlices\\n        # Get y (total_small):\\n        #    y = f1 - x\\n        #      = cheeseSlices - x \\n        #      = cheeseSlices - (0.5*tomatoSlices - cheeseSlices)\\n        #    y = -0.5*tomatoSlices + 2*cheeseSlices\\n        # Note:\\n        #   We solve the function, but its answer might not fit in this case\\n        #   1. We can\\'t sell half burger\\n        #   2. We can\\'t sell negative burger\\n        #   3. According to (1) and (2), x and y must be natural number (0 included)\\n        #   4. We didn\\'t need to worry about error in float, because it just divide by 2,\\n        #      which means there will no error occur in this situation\\n        x =  0.5*tomatoSlices -   cheeseSlices\\n        y = -0.5*tomatoSlices + 2*cheeseSlices\\n        \\n        if not x.is_integer() or not y.is_integer() or x < 0 or y < 0:\\n            return []\\n        else:\\n            return[int(x), int(y)]\\n```\n```python\\n# Dev: Chumicat\\n# Date: 2019/12/1\\n# Submission: https://leetcode.com/submissions/detail/282877921/\\n# (Time, Space) Complexity : O(1), O(1)\\n\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        # Only tomatoSlices need to be divide\\n        # You can also check this first\\n        if tomatoSlices & 1: return []\\n        \\n        x =  (tomatoSlices>>1) - (cheeseSlices)\\n        y = -(tomatoSlices>>1) + (cheeseSlices<<1)\\n        \\n        if x < 0 or y < 0:\\n            return []\\n        else:\\n            return [x, y]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 441458,
                "title": "javascript-solution-math",
                "content": "Since both kinds of burgers require 1 cheese slice, in total there has to be ```cheeseSlices``` number of burgers.\\n```\\n4jumbo + 2small = tomatoSlices (1)\\njumbo + small = cheeseSlices\\nOR \\n2jumbo + 2small = 2cheeseSlices (2)\\n\\nSubtracting (2) from (1) we have:\\n2jumbo = tomatoSlices - 2cheeseSlices\\n\\njumbo = (tomatoSlices - 2cheeseSlices) / 2\\nsmall = cheeseSlices - jumbo\\n```\\nAnd of course both of them have to be integers >= 0\\n```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n  let jumbo = (tomatoSlices - 2 * cheeseSlices) / 2;\\n  let small = cheeseSlices - jumbo;\\n  return jumbo >= 0 && small >= 0 && jumbo % 1 == 0 ? [jumbo, small] : [];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```cheeseSlices```\n```\\n4jumbo + 2small = tomatoSlices (1)\\njumbo + small = cheeseSlices\\nOR \\n2jumbo + 2small = 2cheeseSlices (2)\\n\\nSubtracting (2) from (1) we have:\\n2jumbo = tomatoSlices - 2cheeseSlices\\n\\njumbo = (tomatoSlices - 2cheeseSlices) / 2\\nsmall = cheeseSlices - jumbo\\n```\n```\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n  let jumbo = (tomatoSlices - 2 * cheeseSlices) / 2;\\n  let small = cheeseSlices - jumbo;\\n  return jumbo >= 0 && small >= 0 && jumbo % 1 == 0 ? [jumbo, small] : [];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 441304,
                "title": "straightforward-math-solution-detailed",
                "content": "Since we are given the total number of cheese and tomato slices along with the cost for creating a jumbo and small burger we can setup a system of equations quite easily by noting that:\\n```\\ncheeseSlices = numJumboBurgers * (cheeseSlice/JumboBurger) + numSmallBurgers * (cheeseSlice/SmallBurger)\\ntomatoSlices = numJumboBurgers * (tomatoSlice/JumboBurger) + numSmallBurgers * (tomatoSlice/SmallBurger)\\n```\\n\\nNow we are given that cheeseSlice/JumboBurger = 1, cheeseSlice/SmallBurger = 1, tomatoSlice/JumboBurger = 4, tomatoSlice/SmallBurger = 2. \\n\\nFor simplicity let X = numJumboBurgers and Y = numSmallBurgers, then our system of equations becomes:\\n\\n```\\ncheeseSlices = X * 1 + Y * 1 => Y = cheeseSlices - X\\ntomatoSlices = X * 4 + Y * 2 => tomatoSlices = 4X + 2 * (cheeseSlices - X) = 2X + 2 * cheeseSlices\\n```\\n\\nTherefore, ```X = (tomatoSlices - 2 * cheeseSlices) / 2``` and this can be substituted into\\n```Y = cheeseSlices - X``` to find Y.\\n\\nNow to ensure the solution is valid we must enforce that X and Y are positive integers. This leads to the constraints: X >= 0, Y >= 0, and X * 4 + Y * 2 == tomatoSlices (Last equality verifies that there was no remainder during the divisions)\\n\\nCode:\\n```Java\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) \\n{\\n\\tList<Integer> ans = new ArrayList<Integer>();\\n\\n\\tint X = (tomatoSlices - 2 * cheeseSlices) / 2;\\n\\tint Y = cheeseSlices - X;\\n\\n\\tif (X * 4 + Y * 2 == tomatoSlices && X >= 0 && Y >= 0)\\n\\t{\\n\\t\\tans.add(X);\\n\\t\\tans.add(Y);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\ncheeseSlices = numJumboBurgers * (cheeseSlice/JumboBurger) + numSmallBurgers * (cheeseSlice/SmallBurger)\\ntomatoSlices = numJumboBurgers * (tomatoSlice/JumboBurger) + numSmallBurgers * (tomatoSlice/SmallBurger)\\n```\n```\\ncheeseSlices = X * 1 + Y * 1 => Y = cheeseSlices - X\\ntomatoSlices = X * 4 + Y * 2 => tomatoSlices = 4X + 2 * (cheeseSlices - X) = 2X + 2 * cheeseSlices\\n```\n```X = (tomatoSlices - 2 * cheeseSlices) / 2```\n```Y = cheeseSlices - X```\n```Java\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) \\n{\\n\\tList<Integer> ans = new ArrayList<Integer>();\\n\\n\\tint X = (tomatoSlices - 2 * cheeseSlices) / 2;\\n\\tint Y = cheeseSlices - X;\\n\\n\\tif (X * 4 + Y * 2 == tomatoSlices && X >= 0 && Y >= 0)\\n\\t{\\n\\t\\tans.add(X);\\n\\t\\tans.add(Y);\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083615,
                "title": "linear-equation-basic-mathematics-o-1-method",
                "content": "# Intuition\\n   BY USING BASIC QUADRATIC MATHEMATICS\\n\\n# Approach\\n    Let the number of jumbo burgers be x and no of small burgers be y\\n    So according to the question:\\n         4*(x)+2*(y)=TomatoSlices\\n         x+y = CheeseSlices\\n    On solving the values for x,y for the given 2 equations:\\n    x = (tomatoSlices/2-cheeseSlices)\\n    y = (2*(cheeseSlices)-TomatoSlices//2)\\n    By looking at the above two equations,we can infer that:\\n       tomatoSlices must be a even number \\n       and Both x,y must be zero\\n\\n# Complexity\\n- Time complexity:O(1)\\n      \\n\\n- Space complexity: O(1)\\n      \\n\\n# Code\\n```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n       if tomatoSlices<cheeseSlices:\\n           return []\\n       if tomatoSlices%2!=0:\\n           return []\\n       if (2*(cheeseSlices)-(tomatoSlices)//2)<0 or (tomatoSlices//2-cheeseSlices)<0:\\n           return []\\n       return [(tomatoSlices//2-cheeseSlices),(2*(cheeseSlices)-(tomatoSlices)//2)]\\n       \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n       if tomatoSlices<cheeseSlices:\\n           return []\\n       if tomatoSlices%2!=0:\\n           return []\\n       if (2*(cheeseSlices)-(tomatoSlices)//2)<0 or (tomatoSlices//2-cheeseSlices)<0:\\n           return []\\n       return [(tomatoSlices//2-cheeseSlices),(2*(cheeseSlices)-(tomatoSlices)//2)]\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027157,
                "title": "0-ms-100-solution-o-1-time-and-space",
                "content": "# Intuition\\n\\nThe problem can be turned into **pair of linear equations** with two variables, whose solution always exists(fortunately).\\n\\n# Approach\\nJust check if the solution of the equations are whole numbers(no of burgers cant be negative or fraction...0 is allowed tho).\\n\\nLets assume we can make \\'x\\' jumbo and \\'y\\' small burgers.\\nFor perfect case(where no slices are left off):\\n\\n## 1. 4*x+2*y=a    //a is total tomato slices given\\n## 2. x+y=b        //b is total cheese slices given\\n\\nMultiply (2) by 2 and then subtract it from 1.\\n\\nYou can the following results for x,y in terms of a and b:\\n## x=(a-2*b)/2;\\n## y=(4*b-a)/2;\\n\\nNow you know...\\n\\n# Complexity\\n- Time complexity:\\nO(1).\\n\\n- Space complexity:\\nO(1)   //Size 2(constant) array to return the output,\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int a=tomatoSlices;\\n        int b=cheeseSlices;\\n        int x=a-2*b;    //x being no of twice of jumbo burgers that can be made\\n        int y=4*b-a;    //y being no of twice of small burgers that can be made\\n        if(x>=0&&y>=0&&(x%2==0)&&(y%2==0))  //check whether x and y are whole nubers\\n        {\\n            return {x/2,y/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int a=tomatoSlices;\\n        int b=cheeseSlices;\\n        int x=a-2*b;    //x being no of twice of jumbo burgers that can be made\\n        int y=4*b-a;    //y being no of twice of small burgers that can be made\\n        if(x>=0&&y>=0&&(x%2==0)&&(y%2==0))  //check whether x and y are whole nubers\\n        {\\n            return {x/2,y/2};\\n        }\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027057,
                "title": "matrix-mathematics",
                "content": "# Intuition\\nAfter reading through the hints, the solution is apparent with a bit of matrix mathematics. To start, we can see that we have a system with two equations and two unknowns, so we know we have a singular satisfiable answer. To work from this, we then can approach in the following manner. \\n\\n1) Set up you system of equations for jumbo and small burgers \\n    a. Jumbo as J, Tomato as T, CheeseSlices as C, then \\n    b. J = 4 * T + 1 * C \\n    c. S = 2 * T + 1 * C \\n2) We need the dual form of the above, so we conduct a shift to a system based on T and C instead of J and S by using the columns \\n    a. T = 4J + 2S \\n    b. C = 1J + 1S \\n3) From here, we conduct row matrix reductions to do the following \\n    a. Note that twice of 2b from 2a yields 2J = T - 2C \\n    b. Reduce this to J = T/2 - C \\n    c. Use 3b to find S = 2C - T/2 \\n4) Consider extrema points that will violate this; these are odd tomato slices, areas where C is greater than 2 * C and any instances of negative J or S (can\\'t make negative burgers). Code these in as boolean offshoots of the main process. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith the intuition thus laid out, we can solve as follows \\n- Handle your extrema cases outside of calculations first (too much cheese, odd tomato slices) \\n- calculate J (if negative, return []) \\n- calculate S (if negative, return []) \\n- otherwise return [J, S]\\n\\n# Complexity\\n- Time complexity : 10 operations\\nOur time complexity is bounded very nicely by doing the math by hand before starting. Otherwise, we would have on the order of n^2 for row reduction matrix mathematics at best. As a nice system, we have in total \\n    - 2 multiplication, 2 subtractions, 1 division, 1 modulo and 4 comparisons = 10 operations. \\n\\n- Space complexity : O(1) \\n    - 3 variables are used which falls to O(1)  \\n\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices > 2 * tomatoSlices : \\n            return [] \\n        elif tomatoSlices % 2 : \\n            return [] \\n        else : \\n            T2 = tomatoSlices//2 \\n            J = T2 - cheeseSlices \\n            if J < 0 : \\n                return [] \\n            S = 2 * cheeseSlices - T2\\n            return [] if S < 0 else [J, S]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if cheeseSlices > 2 * tomatoSlices : \\n            return [] \\n        elif tomatoSlices % 2 : \\n            return [] \\n        else : \\n            T2 = tomatoSlices//2 \\n            J = T2 - cheeseSlices \\n            if J < 0 : \\n                return [] \\n            S = 2 * cheeseSlices - T2\\n            return [] if S < 0 else [J, S]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985771,
                "title": "beats-100-very-clean-solution-explained",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$ \\n\\n```\\nLet there be x JUMBO burgers and \\'y\\' SMALL burgers\\nJumbo Burger => 4*x tomato slices and 1*x cheese slice.\\nSmall Burger => 2*y tomato slices and 1*y cheese slice.\\n\\n4*x + 2*y = tomatoSlices  \\n1*x + 1*y = cheeseSlices\\n\\n4*x + 2*y = t \\n1*x + 1*y = c\\n _         _ _    _     _   _\\n|  4    2  ||  x  |  = |  t  |\\n|_ 1    1 _||_ y _|    |_ c _|\\n\\n_     _     _      _ -1 _   _\\n|  x  |  = |  4  2  |  |  t  |\\n|_ y _|    |_ 1  1 _|  |_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |d|  |_-1   4 _||_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |2|  |_-1   4 _||_ c _|\\n\\n_     _       _            _\\n|  x  |  =   | ( t - 2c)/2  |\\n|_ y _|      |_(-t + 4c)/2 _|\\n\\nfor valid cases, both x and y should be positive and integers\\n\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int t = tomatoSlices, c = cheeseSlices;\\n\\n         double ans1 = (t-2*c)/2.0, ans2 = (4*c - t)/2.0;\\n        if(ans1 >= 0 && ans2 >= 0 && ans1 == int(ans1) && ans2 == int(ans2))\\n          return {int(ans1),int(ans2)};\\n\\n    return {};\\n    }\\n};         \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nLet there be x JUMBO burgers and \\'y\\' SMALL burgers\\nJumbo Burger => 4*x tomato slices and 1*x cheese slice.\\nSmall Burger => 2*y tomato slices and 1*y cheese slice.\\n\\n4*x + 2*y = tomatoSlices  \\n1*x + 1*y = cheeseSlices\\n\\n4*x + 2*y = t \\n1*x + 1*y = c\\n _         _ _    _     _   _\\n|  4    2  ||  x  |  = |  t  |\\n|_ 1    1 _||_ y _|    |_ c _|\\n\\n_     _     _      _ -1 _   _\\n|  x  |  = |  4  2  |  |  t  |\\n|_ y _|    |_ 1  1 _|  |_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |d|  |_-1   4 _||_ c _|\\n\\n_     _      1    _      _  _   _\\n|  x  |  =  ---  |  1  -2  ||  t  |\\n|_ y _|     |2|  |_-1   4 _||_ c _|\\n\\n_     _       _            _\\n|  x  |  =   | ( t - 2c)/2  |\\n|_ y _|      |_(-t + 4c)/2 _|\\n\\nfor valid cases, both x and y should be positive and integers\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int t = tomatoSlices, c = cheeseSlices;\\n\\n         double ans1 = (t-2*c)/2.0, ans2 = (4*c - t)/2.0;\\n        if(ans1 >= 0 && ans2 >= 0 && ans1 == int(ans1) && ans2 == int(ans2))\\n          return {int(ans1),int(ans2)};\\n\\n    return {};\\n    }\\n};         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939384,
                "title": "cpp-solution-in-o-1-time-complexity",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if(tomatoSlices == 0 && cheeseSlices == 0)\\n            return {0, 0};\\n\\n        if(tomatoSlices == 0 || cheeseSlices == 0)\\n            return {};\\n\\n        // since 4x + 2y = tomatoSlices && x + y = cheeseSlices\\n        int jumbo = tomatoSlices/2 - cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n\\n        if(jumbo < 0 || small < 0)\\n            return {};\\n\\n        if( ((4*jumbo) + (2*small) == tomatoSlices) && (jumbo + small == cheeseSlices))\\n            return {jumbo, small};\\n\\n\\n\\n        return {};\\n\\n    }\\n};\\n```\\nHope you understand the code.",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        if(tomatoSlices == 0 && cheeseSlices == 0)\\n            return {0, 0};\\n\\n        if(tomatoSlices == 0 || cheeseSlices == 0)\\n            return {};\\n\\n        // since 4x + 2y = tomatoSlices && x + y = cheeseSlices\\n        int jumbo = tomatoSlices/2 - cheeseSlices;\\n        int small = cheeseSlices - jumbo;\\n\\n        if(jumbo < 0 || small < 0)\\n            return {};\\n\\n        if( ((4*jumbo) + (2*small) == tomatoSlices) && (jumbo + small == cheeseSlices))\\n            return {jumbo, small};\\n\\n\\n\\n        return {};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930851,
                "title": "1-liner",
                "content": "```ruby\\ndef num_of_burgers t, c\\n    t.even? && (c..c * 2) === (t /= 2) ? [j = t - c, c - j] : []\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef num_of_burgers t, c\\n    t.even? && (c..c * 2) === (t /= 2) ? [j = t - c, c - j] : []\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3910844,
                "title": "ruby-o-1-solution-with-explanation-100-100",
                "content": "# Approach\\n1. It\\'s impossible to use all ingredients if there\\'s an odd number of tomato slices, of if the number is too high/low.\\n2. Since we always use two or four tomato slices, it\\'s easier to think of them in units of two.  Divide by two.\\n3. If tomato and cheese slices were equal, we would make only small burgers.  For every extra tomato slice (or pair of slices), we turn one small burger into a jumbo.  The number of jumbo burgers is just the difference, and the number of small is the rest of the cheese slices.\\n4. Return jumbo and small.\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef num_of_burgers(tomato, cheese)\\n    return [] if tomato % 2 == 1\\n    return [] if tomato > cheese * 4 || tomato < cheese * 2\\n\\n    tomato /= 2\\n    jumbo = tomato - cheese\\n    small = cheese - jumbo\\n    \\n    [jumbo,small]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef num_of_burgers(tomato, cheese)\\n    return [] if tomato % 2 == 1\\n    return [] if tomato > cheese * 4 || tomato < cheese * 2\\n\\n    tomato /= 2\\n    jumbo = tomato - cheese\\n    small = cheese - jumbo\\n    \\n    [jumbo,small]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3907245,
                "title": "just-if-else-ladder-needed-totally-conditional-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n    \\n    \\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(0);\\n        ans.push_back(cheeseSlices);\\n        return ans;\\n    }\\n    \\n    int count1 = 0;\\n    while(tomatoSlices != cheeseSlices*2){\\n        tomatoSlices -= 4;\\n        cheeseSlices --;\\n        count1 ++;\\n\\n        if(tomatoSlices < 0){\\n            return {};\\n        }\\n    }\\n    ans.push_back(count1);\\n\\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(cheeseSlices);\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n    \\n    \\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(0);\\n        ans.push_back(cheeseSlices);\\n        return ans;\\n    }\\n    \\n    int count1 = 0;\\n    while(tomatoSlices != cheeseSlices*2){\\n        tomatoSlices -= 4;\\n        cheeseSlices --;\\n        count1 ++;\\n\\n        if(tomatoSlices < 0){\\n            return {};\\n        }\\n    }\\n    ans.push_back(count1);\\n\\n    if(tomatoSlices == cheeseSlices*2){\\n        ans.push_back(cheeseSlices);\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3896859,
                "title": "python-3-solution-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n        return [tomatoSlices//2 - cheeseSlices, 2*cheeseSlices - tomatoSlices//2] if (tomatoSlices - 2*cheeseSlices)%2 == 0 and (tomatoSlices - 2*cheeseSlices) >= 0 and (2*cheeseSlices - tomatoSlices//2) >= 0 else []\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\n        return [tomatoSlices//2 - cheeseSlices, 2*cheeseSlices - tomatoSlices//2] if (tomatoSlices - 2*cheeseSlices)%2 == 0 and (tomatoSlices - 2*cheeseSlices) >= 0 and (2*cheeseSlices - tomatoSlices//2) >= 0 else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887249,
                "title": "cpp-easy-implementation-5-line-code",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tom, int chee) {\\n        if(tom%2!=0)return {};\\n        if(tom<chee)return {};tom/=2;\\n        int x=tom-chee,y=2*chee-tom;\\n        if(x<0 || y<0)return {};\\n        return {x,y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tom, int chee) {\\n        if(tom%2!=0)return {};\\n        if(tom<chee)return {};tom/=2;\\n        int x=tom-chee,y=2*chee-tom;\\n        if(x<0 || y<0)return {};\\n        return {x,y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844528,
                "title": "python-exercise-in-solving-linear-equations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLetting T = ```tomatoSlices``` and C = ```cheeseSlices```, we have the equations:\\n        T = tomatoSlices; C = cheeseSlices\\n        T - ( 4*J + 2*S ) = 0\\n        C - ( 1*J + 1*S ) = 0\\n        T = 4*J + 2*S\\n        C = 1*J + 1*S\\n        T - 2*C = 2*J\\n        T - 4*C = -2*S\\n        T / 2 - C = J\\n        - T / 2 + 2 * C = S\\nWe also need two validity checks:  First, T must be even because it\\'s divided by two, and Second, both S and J must be non-negative\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement the last two equations and add logic for the validity checks.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ because there is no dependence in the size of the input (a pair of scalars )\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ because the only temporary variables are scalars.\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T = tomatoSlices; C = cheeseSlices\\n        # T - ( 4*J + 2*S ) = 0\\n        # C - ( 1*J + 1*S ) = 0\\n        # T = 4*J + 2*S\\n        # C = 1*J + 1*S\\n        # T - 2*C = 2*J\\n        # T - 4*C = -2*S\\n        if T % 2 == 1:\\n            return []\\n        else:\\n            J = ( T - 2 * C ) // 2\\n            S = - ( T - 4 * C ) // 2\\n            if J >= 0 and S >= 0:\\n                return [ J, S ]\\n            else:\\n                return []\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```tomatoSlices```\n```cheeseSlices```\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T = tomatoSlices; C = cheeseSlices\\n        # T - ( 4*J + 2*S ) = 0\\n        # C - ( 1*J + 1*S ) = 0\\n        # T = 4*J + 2*S\\n        # C = 1*J + 1*S\\n        # T - 2*C = 2*J\\n        # T - 4*C = -2*S\\n        if T % 2 == 1:\\n            return []\\n        else:\\n            J = ( T - 2 * C ) // 2\\n            S = - ( T - 4 * C ) // 2\\n            if J >= 0 and S >= 0:\\n                return [ J, S ]\\n            else:\\n                return []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822362,
                "title": "c-100-faster-math-eqns",
                "content": "**Intuition :** Intuition is simple , it just like we r given 2 linear equation with 2 variables  and we have to solve them for finding value of variables.\\n\\nLet , no of tomato slices be t , no of cheese slices be c.\\nIn one big burger 4 tomato slice and one cheese needed.\\nwhile for small one 2 tomato slice and one cheese needed.\\n\\nlet , no of big burgers =x.\\nno of small burgers =y.\\n\\nthen , 4x+2y = t.  or 2x+y=t/2. ---Eq(1).\\nand , x+y=c.  --Eq(2).\\n\\n**Important observation :** there is no values exist for x and y when t==odd . from Eq 1.\\n\\nnow , tym for code.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if(t%2!=0)return ans;\\n        int a=0,b=0;\\n        a= t/2- c;\\n        b= c-a;\\n        if(a<0||b<0)return ans;\\n        ans.push_back(a);\\n        ans.push_back(b);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if(t%2!=0)return ans;\\n        int a=0,b=0;\\n        a= t/2- c;\\n        b= c-a;\\n        if(a<0||b<0)return ans;\\n        ans.push_back(a);\\n        ans.push_back(b);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819191,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tom, int chese) {\\n\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        double t = (double)tom;\\n        double c = (double)chese;\\n        double x = (t-2*c)/2;\\n        double y = c-x;\\n\\n        if(x<0 || y<0 || x-(int)x !=0) return ans;\\n        else{\\n            ans.add((int)x);\\n            ans.add((int)y);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tom, int chese) {\\n\\n        List<Integer> ans = new ArrayList<>();\\n        \\n        double t = (double)tom;\\n        double c = (double)chese;\\n        double x = (t-2*c)/2;\\n        double y = c-x;\\n\\n        if(x<0 || y<0 || x-(int)x !=0) return ans;\\n        else{\\n            ans.add((int)x);\\n            ans.add((int)y);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808691,
                "title": "java-o-1-space-and-time-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Jumbo Burger: 4 tomato slices and 1 cheese slice.\\n        // Small Burger: 2 Tomato slices and 1 cheese slice.\\n\\n        // 4 * x + 2 * y = tomatoSlices\\n        // 2*x + 2*y = 2* cheeseSlices\\n\\n        int jumbo = (tomatoSlices - 2 * cheeseSlices) / 2 ;\\n        int small = cheeseSlices - jumbo ;\\n\\n        if(jumbo >=0 && \\n           small>=0 &&\\n             4 * jumbo + 2* small == tomatoSlices\\n             && jumbo + small == cheeseSlices ){\\n           return List.of(jumbo, small);\\n\\n        }\\n        return new ArrayList();\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Jumbo Burger: 4 tomato slices and 1 cheese slice.\\n        // Small Burger: 2 Tomato slices and 1 cheese slice.\\n\\n        // 4 * x + 2 * y = tomatoSlices\\n        // 2*x + 2*y = 2* cheeseSlices\\n\\n        int jumbo = (tomatoSlices - 2 * cheeseSlices) / 2 ;\\n        int small = cheeseSlices - jumbo ;\\n\\n        if(jumbo >=0 && \\n           small>=0 &&\\n             4 * jumbo + 2* small == tomatoSlices\\n             && jumbo + small == cheeseSlices ){\\n           return List.of(jumbo, small);\\n\\n        }\\n        return new ArrayList();\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773118,
                "title": "c-3-liner-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(t%2!=0) return {};\\n        if((t-2*c)%2!=0 || (t-2*c<0) || c-(t-2*c)/2<0) return {};\\n        return {(t-2*c)/2,c-(t-2*c)/2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if(t%2!=0) return {};\\n        if((t-2*c)%2!=0 || (t-2*c<0) || c-(t-2*c)/2<0) return {};\\n        return {(t-2*c)/2,c-(t-2*c)/2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724441,
                "title": "python-simple-math",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        \"\"\"\\n        [4t + 1c, 2t + 1c], where t = c = 0, else []\\n\\n        16t  7c\\n        4t: 16t-1x4t=12t  7c-1x1c=6c -> 1\\n        2t: 12t-6x2t=0t   6c-6x1c=0c -> 6\\n        0t == 0c\\n            \\n        j + s = c # total burgers that could be made = total cheese slices needed for the burgers\\n        4j + 2s = t # j jumbo + s small require t tomato slices\\n        \\n        s = 2c - t/2\\n        j = c - s\\n        \"\"\"\\n        return [] if t % 2 or (s := 2 * c - t // 2) < 0 or (j := c - s) < 0 else [j, s]\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        \"\"\"\\n        [4t + 1c, 2t + 1c], where t = c = 0, else []\\n\\n        16t  7c\\n        4t: 16t-1x4t=12t  7c-1x1c=6c -> 1\\n        2t: 12t-6x2t=0t   6c-6x1c=0c -> 6\\n        0t == 0c\\n            \\n        j + s = c # total burgers that could be made = total cheese slices needed for the burgers\\n        4j + 2s = t # j jumbo + s small require t tomato slices\\n        \\n        s = 2c - t/2\\n        j = c - s\\n        \"\"\"\\n        return [] if t % 2 or (s := 2 * c - t // 2) < 0 or (j := c - s) < 0 else [j, s]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712249,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (tomatoSlices % 2 === 1) return []\\n    if (tomatoSlices / cheeseSlices < 2) return []\\n    if (tomatoSlices / cheeseSlices > 4) return []\\n    let jumbo =  (tomatoSlices - (cheeseSlices * 2)) / 2\\n    return [jumbo, cheeseSlices - jumbo]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if (tomatoSlices % 2 === 1) return []\\n    if (tomatoSlices / cheeseSlices < 2) return []\\n    if (tomatoSlices / cheeseSlices > 4) return []\\n    let jumbo =  (tomatoSlices - (cheeseSlices * 2)) / 2\\n    return [jumbo, cheeseSlices - jumbo]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3687892,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // x= jumbo , y = small :\\n        // 1. x*4 + y*2 = tomatoSlices\\n        // 2. x + y =  cheeseSlices\\n        // x = (tomatoSlices - 2 * cheeseSlices)/2 , y = cheeseSlices - x      \\n        int jumbo = (tomatoSlices - 2 * cheeseSlices)/2 , small = cheeseSlices - jumbo;\\n        return (jumbo < 0 || tomatoSlices % 2 ==1|| small <0) ? new ArrayList(): Arrays.asList(jumbo,small);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // x= jumbo , y = small :\\n        // 1. x*4 + y*2 = tomatoSlices\\n        // 2. x + y =  cheeseSlices\\n        // x = (tomatoSlices - 2 * cheeseSlices)/2 , y = cheeseSlices - x      \\n        int jumbo = (tomatoSlices - 2 * cheeseSlices)/2 , small = cheeseSlices - jumbo;\\n        return (jumbo < 0 || tomatoSlices % 2 ==1|| small <0) ? new ArrayList(): Arrays.asList(jumbo,small);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3657898,
                "title": "c-beats-100-simple-1-line-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n$$2x+4y=t ,x+y=c$$\\nSo $$x=2c-t/2, y=t/2-c$$\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if(tomatoSlices%2==1 || tomatoSlices<2*cheeseSlices || tomatoSlices>4*cheeseSlices){return {};}\\n        return {tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n        if(tomatoSlices%2==1 || tomatoSlices<2*cheeseSlices || tomatoSlices>4*cheeseSlices){return {};}\\n        return {tomatoSlices/2-cheeseSlices, 2*cheeseSlices-tomatoSlices/2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649368,
                "title": "2-lines-solution-simple-but-people-fail-to-understand",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> numOfBurgers(int t, int c) {\\n        int c4=0;\\n        while(c4<c && (c+c4)*2<t) c4++;\\n        if((c+c4)*2==t)\\n        {\\n            ans.push_back(c4);\\n            ans.push_back(c-c4);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    vector<int> numOfBurgers(int t, int c) {\\n        int c4=0;\\n        while(c4<c && (c+c4)*2<t) c4++;\\n        if((c+c4)*2==t)\\n        {\\n            ans.push_back(c4);\\n            ans.push_back(c-c4);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627445,
                "title": "o-1-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>v;\\n        if(tomatoSlices%2!=0)return v;\\n        \\n        if(cheeseSlices>tomatoSlices/2)return v;\\n        \\n        int jumbo=(tomatoSlices)/2-cheeseSlices;\\n        \\n        int small=cheeseSlices-jumbo;\\n        \\n        if(small<0 || jumbo<0)return v;\\n        \\n        v.push_back(jumbo);\\n        v.push_back(small);\\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int>v;\\n        if(tomatoSlices%2!=0)return v;\\n        \\n        if(cheeseSlices>tomatoSlices/2)return v;\\n        \\n        int jumbo=(tomatoSlices)/2-cheeseSlices;\\n        \\n        int small=cheeseSlices-jumbo;\\n        \\n        if(small<0 || jumbo<0)return v;\\n        \\n        v.push_back(jumbo);\\n        v.push_back(small);\\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599986,
                "title": "c-solution-using-simple-maths",
                "content": "# Intuition\\nSolved the question using simple maths. \\ncreate 2 equations :\\n4*jb + 2*sb = tomatoSlices;\\n1*jb + 1*sb = cheeseSlices;\\n\\n\\n# Approach\\nsolving the 2 linear equations we get \\nsb= (4*cheeseSlices- tomatoSlices)/2\\njb= (tomatoSlices- 2*cheeseSlices)/2\\n\\napplying edge cases of non negativity and checking if no decimals come we can solve this question.\\n\\n\\n# Complexity\\n- Time complexity:\\no(1) as we are not using any loop.\\n\\n- Space complexity:\\nlinear space complexity of vector used.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if (cheeseSlices > tomatoSlices) return ans;\\n\\n        float jb= (tomatoSlices- 2*cheeseSlices)/2.0;\\n        if (jb == ceil(jb) && jb>=0){\\n            ans.push_back(int(jb));\\n        }\\n        else {\\n            return {};\\n        }\\n\\n        float sb= (4*cheeseSlices - tomatoSlices)/2.0;\\n        if (sb == ceil(sb) && sb>=0 ){\\n            ans.push_back(int(sb));\\n            return ans;\\n        }\\n        else {\\n            return {};\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if (cheeseSlices > tomatoSlices) return ans;\\n\\n        float jb= (tomatoSlices- 2*cheeseSlices)/2.0;\\n        if (jb == ceil(jb) && jb>=0){\\n            ans.push_back(int(jb));\\n        }\\n        else {\\n            return {};\\n        }\\n\\n        float sb= (4*cheeseSlices - tomatoSlices)/2.0;\\n        if (sb == ceil(sb) && sb>=0 ){\\n            ans.push_back(int(sb));\\n            return ans;\\n        }\\n        else {\\n            return {};\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598426,
                "title": "algebra-time-o-1-space-o-1",
                "content": "class Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if tomatoSlices & 1:\\n            return []\\n        \\n        \\n        if (tomatoSlices - 2*cheeseSlices) < 0 or (tomatoSlices - 2*cheeseSlices) & 1:\\n            return []\\n        \\n        jumbo = (tomatoSlices - 2*cheeseSlices) >> 1\\n        \\n        small = cheeseSlices - jumbo\\n        \\n        if small < 0:\\n            return []\\n        \\n        return [jumbo, small]\\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        \"\"\"\\n        :type tomatoSlices: int\\n        :type cheeseSlices: int\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if tomatoSlices & 1:\\n            return []\\n        \\n        \\n        if (tomatoSlices - 2*cheeseSlices) < 0 or (tomatoSlices - 2*cheeseSlices) & 1:\\n            return []\\n        \\n        jumbo = (tomatoSlices - 2*cheeseSlices) >> 1\\n        \\n        small = cheeseSlices - jumbo\\n        \\n        if small < 0:\\n            return []\\n        \\n        return [jumbo, small]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3591459,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0 || 2*cheeseSlices>tomatoSlices || 4*cheeseSlices<tomatoSlices) return {};\\n        if((tomatoSlices-(2*cheeseSlices))%2==1) return {};\\n        int jumbo=(tomatoSlices-(2*cheeseSlices))/2;\\n        return {jumbo,cheeseSlices-jumbo};\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        j = (tomatoSlices - 2*cheeseSlices)/2\\n        if int(j) != j or j<0 or cheeseSlices-j<0: \\n            return []\\n        else:\\n            return [int(j), int(cheeseSlices-j)]\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> output = new ArrayList();\\n        int x = 0; int y = 0;\\n\\n        if (tomatoSlices % 2 != 0 || cheeseSlices > tomatoSlices)\\n            return output;\\n\\n        x = -cheeseSlices + (tomatoSlices / 2);\\n        y = (2 * cheeseSlices) - (tomatoSlices / 2);\\n        if (x < 0 || y < 0) \\n            return output;\\n\\n        output.add(x); output.add(y);\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2!=0 || 2*cheeseSlices>tomatoSlices || 4*cheeseSlices<tomatoSlices) return {};\\n        if((tomatoSlices-(2*cheeseSlices))%2==1) return {};\\n        int jumbo=(tomatoSlices-(2*cheeseSlices))/2;\\n        return {jumbo,cheeseSlices-jumbo};\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        j = (tomatoSlices - 2*cheeseSlices)/2\\n        if int(j) != j or j<0 or cheeseSlices-j<0: \\n            return []\\n        else:\\n            return [int(j), int(cheeseSlices-j)]\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> output = new ArrayList();\\n        int x = 0; int y = 0;\\n\\n        if (tomatoSlices % 2 != 0 || cheeseSlices > tomatoSlices)\\n            return output;\\n\\n        x = -cheeseSlices + (tomatoSlices / 2);\\n        y = (2 * cheeseSlices) - (tomatoSlices / 2);\\n        if (x < 0 || y < 0) \\n            return output;\\n\\n        output.add(x); output.add(y);\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569443,
                "title": "simple-java-beats-100-runtime-beats-99-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if (tomatoSlices%2 != 0) return res;\\n\\n        if (cheeseSlices*2 > tomatoSlices) return res;\\n\\n        int rem = tomatoSlices - cheeseSlices*2;\\n        int jumbos = rem/2;\\n        int smalls = cheeseSlices - jumbos;\\n\\n        if (smalls < 0) return res;\\n        res.add(jumbos);\\n        res.add(smalls);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> res = new ArrayList<>();\\n        if (tomatoSlices%2 != 0) return res;\\n\\n        if (cheeseSlices*2 > tomatoSlices) return res;\\n\\n        int rem = tomatoSlices - cheeseSlices*2;\\n        int jumbos = rem/2;\\n        int smalls = cheeseSlices - jumbos;\\n\\n        if (smalls < 0) return res;\\n        res.add(jumbos);\\n        res.add(smalls);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561856,
                "title": "java-linear-equations-group",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        int sb = (int)(2*cs-0.5*ts);\\n        int jb = cs-sb;\\n        return ts%2==1||sb<0||jb<0 ? List.of():List.of(jb,sb);\\n    }\\n    \\n    //linear equations system\\n    //4*jb+2*sb = ts;\\n    //sb+jb     = cs\\n    \\n    //express jb via cs and sb\\n    // jb=cs-sb;\\n    \\n    //rewrite the first equation using new jb definition:\\n    //4*(cs-sb)+2*sb = ts;\\n    \\n    //then, find sb from it\\n    //4*cs - 4*sb+2sb = ts; <=>\\n    //4cs-2sb=ts; <=>\\n    //2sb=4cs-ts <=>\\n    //sb=2cs-0.5ts\\n    \\n    //and afterwards, let\\'s find jb from it:\\n    //sb+jb=cs <=>\\n    //jb=cs-sb\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int ts, int cs) {\\n        int sb = (int)(2*cs-0.5*ts);\\n        int jb = cs-sb;\\n        return ts%2==1||sb<0||jb<0 ? List.of():List.of(jb,sb);\\n    }\\n    \\n    //linear equations system\\n    //4*jb+2*sb = ts;\\n    //sb+jb     = cs\\n    \\n    //express jb via cs and sb\\n    // jb=cs-sb;\\n    \\n    //rewrite the first equation using new jb definition:\\n    //4*(cs-sb)+2*sb = ts;\\n    \\n    //then, find sb from it\\n    //4*cs - 4*sb+2sb = ts; <=>\\n    //4cs-2sb=ts; <=>\\n    //2sb=4cs-ts <=>\\n    //sb=2cs-0.5ts\\n    \\n    //and afterwards, let\\'s find jb from it:\\n    //sb+jb=cs <=>\\n    //jb=cs-sb\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481628,
                "title": "simple-concise-1-liner-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, T: int, C: int) -> List[int]:\\n        return [[T//2 - C, 2*C - T//2],[]][T % 2 or T < 2*C or 4*C < T]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434080,
                "title": "java-beats-100-o-1-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>ans = new ArrayList<>();\\n\\n        if(tomatoSlices %2 == 1)\\n            return ans;\\n        int x = tomatoSlices/2 - cheeseSlices;\\n        int y = cheeseSlices - x;\\n        if(x < 0 || y < 0){\\n            return ans;\\n        }\\n        ans.add(x);\\n        ans.add(y);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>ans = new ArrayList<>();\\n\\n        if(tomatoSlices %2 == 1)\\n            return ans;\\n        int x = tomatoSlices/2 - cheeseSlices;\\n        int y = cheeseSlices - x;\\n        if(x < 0 || y < 0){\\n            return ans;\\n        }\\n        ans.add(x);\\n        ans.add(y);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385844,
                "title": "c-o-1-with-thought-process-explained",
                "content": "The range of tomatoes must be within 4 * cheese slices and 2 * cheese slices and must be even to be valid. Lets say we wanted to start with making every burger with 2 tomato 1 cheese, we would be left over with total tomato slices - 2 * (slices of cheese). For the left over slices we would need to pair 2 at a time and convert a 2 tomato burger to a 4 tomato burger. So left over slices / 2 would be the amount of big burgers to make, and the amount of cheese needed for them. Then subtract that amount of cheese from the total cheese to find the remaining cheese to be used 1 slice at a time for a smaller burger.\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t > c * 4 || t < c * 2 || t % 2 == 1) return {};\\n        vector<int> ans(2);\\n        int minDif = c * 2;\\n        int extra = t - minDif;\\n        ans[0] = extra / 2;\\n        ans[1] = c - ans[0];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        if (t > c * 4 || t < c * 2 || t % 2 == 1) return {};\\n        vector<int> ans(2);\\n        int minDif = c * 2;\\n        int extra = t - minDif;\\n        ans[0] = extra / 2;\\n        ans[1] = c - ans[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376851,
                "title": "java-o-1-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        // j+s=c\\n        // 4*j+2*s=t\\n\\n        // 2s=4*c-t --> s=2c-t/2\\n        // -2j=2c-t --> j=t/2-c\\n\\n        return(2*c>=t/2 && t/2>=c && t%2==0)?new ArrayList<Integer>(Arrays.asList(t/2-c,2*c-t/2)):new ArrayList<Integer>();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int t, int c) {\\n        // j+s=c\\n        // 4*j+2*s=t\\n\\n        // 2s=4*c-t --> s=2c-t/2\\n        // -2j=2c-t --> j=t/2-c\\n\\n        return(2*c>=t/2 && t/2>=c && t%2==0)?new ArrayList<Integer>(Arrays.asList(t/2-c,2*c-t/2)):new ArrayList<Integer>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341590,
                "title": "simple-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if (tomatoSlices % 2 == 1) return l;\\n        if (tomatoSlices / 2 < cheeseSlices) return l;\\n        if (cheeseSlices * 2 < tomatoSlices / 2) return l;\\n        l.add(tomatoSlices / 2 - cheeseSlices);\\n        l.add(cheeseSlices * 2 - tomatoSlices / 2);\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if (tomatoSlices % 2 == 1) return l;\\n        if (tomatoSlices / 2 < cheeseSlices) return l;\\n        if (cheeseSlices * 2 < tomatoSlices / 2) return l;\\n        l.add(tomatoSlices / 2 - cheeseSlices);\\n        l.add(cheeseSlices * 2 - tomatoSlices / 2);\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328215,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize){\\n    \\n    int Jumbo_2 =  tomatoSlices - 2*cheeseSlices ;\\n    printf(\"%d \", Jumbo_2 ) ;\\n    if( Jumbo_2 < 0 || Jumbo_2 % 2 != 0 ||  (cheeseSlices - Jumbo_2/2) < 0){\\n        *returnSize = 0 ;\\n        return NULL ;\\n    }\\n    int* ans = malloc( 2 * sizeof(int) ) ;\\n    *returnSize = 2 ;\\n    ans[0] = Jumbo_2/2 ;\\n    ans[1] = cheeseSlices - ans[0] ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* numOfBurgers(int tomatoSlices, int cheeseSlices, int* returnSize){\\n    \\n    int Jumbo_2 =  tomatoSlices - 2*cheeseSlices ;\\n    printf(\"%d \", Jumbo_2 ) ;\\n    if( Jumbo_2 < 0 || Jumbo_2 % 2 != 0 ||  (cheeseSlices - Jumbo_2/2) < 0){\\n        *returnSize = 0 ;\\n        return NULL ;\\n    }\\n    int* ans = malloc( 2 * sizeof(int) ) ;\\n    *returnSize = 2 ;\\n    ans[0] = Jumbo_2/2 ;\\n    ans[1] = cheeseSlices - ans[0] ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3327100,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices%2==0 and cheeseSlices*2<=tomatoSlices<=cheeseSlices*4:\\n            return [tomatoSlices//2-cheeseSlices,2*cheeseSlices-tomatoSlices//2]\\n\\n        else:\\n            return []    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices%2==0 and cheeseSlices*2<=tomatoSlices<=cheeseSlices*4:\\n            return [tomatoSlices//2-cheeseSlices,2*cheeseSlices-tomatoSlices//2]\\n\\n        else:\\n            return []    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320456,
                "title": "easy-solution-intutive-maths-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ch=cheeseSlices;\\n        int to=tomatoSlices;\\n        if(ch>to || ch*4<to) return {};\\n\\n        long long int x=to/2-ch;\\n        long long int y=ch-x;\\n        if(x<0 || y<0) return {};\\n         \\n         if(x+y==ch && ((x*4+y*2)==to)) return {(int)x,(int)y};\\n         return {};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        int ch=cheeseSlices;\\n        int to=tomatoSlices;\\n        if(ch>to || ch*4<to) return {};\\n\\n        long long int x=to/2-ch;\\n        long long int y=ch-x;\\n        if(x<0 || y<0) return {};\\n         \\n         if(x+y==ch && ((x*4+y*2)==to)) return {(int)x,(int)y};\\n         return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290550,
                "title": "java-solution",
                "content": "# Intuition\\nThe number of chees slices determine the total number of burgers that would be made\\n\\n# Approach\\n As each of the burgers need the number of cheese slices as one then the noumber of chesse slices will determint the total number of burgers jumbo and small that will be made now we would form a equation as 4i+2(b-i) which statr with the value of i as 0 it will loop through all the conditon of diffrent number of jumbo and small burgers made untile it find the right number\\n\\n# Complexity\\n- Time complexity: O(cheeseSlices)\\n- Space complexity: Constant\\n<!-- space complexity is costant -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<Integer>();\\n        int b=cheeseSlices;\\n        int used=0;\\n        if(tomatoSlices==0&&cheeseSlices==0){\\n            ans.add(0);\\n            ans.add(0);\\n\\n            return ans;\\n        }\\n\\n        for(int i=0;i<b;i++){\\n            used=4*i+2*b-2*i;\\n            if(tomatoSlices==used){\\n                ans.add(i);\\n                ans.add(b-i);\\n                break;\\n                \\n            }\\n        }\\n\\n    return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<Integer>();\\n        int b=cheeseSlices;\\n        int used=0;\\n        if(tomatoSlices==0&&cheeseSlices==0){\\n            ans.add(0);\\n            ans.add(0);\\n\\n            return ans;\\n        }\\n\\n        for(int i=0;i<b;i++){\\n            used=4*i+2*b-2*i;\\n            if(tomatoSlices==used){\\n                ans.add(i);\\n                ans.add(b-i);\\n                break;\\n                \\n            }\\n        }\\n\\n    return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288686,
                "title": "simple-and-short-o-1-1ms-faster-than-100-math-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<>();\\n        int val=tomatoSlices-2*cheeseSlices;\\n        if(val>=0 && (val&1)==0 && cheeseSlices-val/2>=0){\\n            ans.add(val/2);\\n            ans.add(cheeseSlices-val/2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans=new ArrayList<>();\\n        int val=tomatoSlices-2*cheeseSlices;\\n        if(val>=0 && (val&1)==0 && cheeseSlices-val/2>=0){\\n            ans.add(val/2);\\n            ans.add(cheeseSlices-val/2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285098,
                "title": "easy-javascript-solution-number-of-burgers-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNumber of cheeseSlices is the variable that determine how many JumboBurger and SmallBurger will be made with zero remaining for both slices\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    First if odd number of tomatoSlices is given return [] b/c it is not possible to divide evenly.For number of cheeseSlices iterate in for loop and try every combination of i and n-i. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n), where n is number of cheeseSlices given.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if(tomatoSlices %2 != 0) return []\\n\\n    const JB=4,SB=2;\\n    for(let i=0; i<=cheeseSlices; i++){\\n        if(JB*i + SB*(cheeseSlices-i) == tomatoSlices){\\n            return [i,cheeseSlices-i]\\n        }\\n    }\\n\\n    return []\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} tomatoSlices\\n * @param {number} cheeseSlices\\n * @return {number[]}\\n */\\nvar numOfBurgers = function(tomatoSlices, cheeseSlices) {\\n    if(tomatoSlices %2 != 0) return []\\n\\n    const JB=4,SB=2;\\n    for(let i=0; i<=cheeseSlices; i++){\\n        if(JB*i + SB*(cheeseSlices-i) == tomatoSlices){\\n            return [i,cheeseSlices-i]\\n        }\\n    }\\n\\n    return []\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3277238,
                "title": "just-a-simple-high-school-question-math-c-o-1-sc-o-1-tc",
                "content": "```\\nvector<int> numOfBurgers(int t, int c) {\\n        if(t<2*c or t>4*c) return {};\\n        if((t-2*c)/2.0!=(t-2*c)/2) return {};\\n        return {(t-2*c)/2,c-((t-2*c)/2)};\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nvector<int> numOfBurgers(int t, int c) {\\n        if(t<2*c or t>4*c) return {};\\n        if((t-2*c)/2.0!=(t-2*c)/2) return {};\\n        return {(t-2*c)/2,c-((t-2*c)/2)};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268251,
                "title": "easy-solution-0ms-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> burg;\\n        double x=(tomatoSlices-2*cheeseSlices)/2.0;\\n        double y=cheeseSlices-x;\\n        if(x-int(x) == 0 && x>=0 && y>=0)\\n        {\\n            burg.push_back(x);\\n            burg.push_back(y);\\n        }\\n\\n    return burg;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> burg;\\n        double x=(tomatoSlices-2*cheeseSlices)/2.0;\\n        double y=cheeseSlices-x;\\n        if(x-int(x) == 0 && x>=0 && y>=0)\\n        {\\n            burg.push_back(x);\\n            burg.push_back(y);\\n        }\\n\\n    return burg;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207917,
                "title": "java-fastest-100-no-loops-nothing-but-a-math-problem",
                "content": "# Intuition\\nRather than use loop to simulate problem. For you guys this is (\"NOTHING BUT\") a math problem and it should not be a medium difficulty.\\n\\n# Approach\\nFirst check that there is enough tomatos 2*cheese <= tomat0 <= 4*cheese and even number of slices. Otherwise return empty list.\\nNow start will makes small burgers 2 * cheese. There remaining are use for the burgers. \\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int toma, int cheese) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        int small_cheese = cheese * 2;  /// use up all the cheese to make small burgers\\n        int total_big = 0;\\n        int total_small = 0;\\n        if (toma >= cheese * 2 && toma <= 4 * cheese && toma % 2 == 0) {\\n // we divide by 2 instead of 4 because 2 cheese are accounted for in the \\'small\\' burger\\n            total_big = (toma - small_cheese) /2;  \\n            total_small = cheese - total_big;\\n        }\\n        else \\n            return new ArrayList<>();\\n        res.add(total_big);  res.add(total_small);\\n        return res;\\n    }\\n\\n  \\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int toma, int cheese) {\\n        List<Integer> res = new ArrayList<>();\\n\\n        int small_cheese = cheese * 2;  /// use up all the cheese to make small burgers\\n        int total_big = 0;\\n        int total_small = 0;\\n        if (toma >= cheese * 2 && toma <= 4 * cheese && toma % 2 == 0) {\\n // we divide by 2 instead of 4 because 2 cheese are accounted for in the \\'small\\' burger\\n            total_big = (toma - small_cheese) /2;  \\n            total_small = cheese - total_big;\\n        }\\n        else \\n            return new ArrayList<>();\\n        res.add(total_big);  res.add(total_small);\\n        return res;\\n    }\\n\\n  \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197583,
                "title": "2-lines-c-o-1",
                "content": "***million lines from a Pen may reach the globe,Even so some dozen lines of Codes rule all over it***\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2||cheeseSlices*4<tomatoSlices||cheeseSlices*2>tomatoSlices)return {};\\n        int n=(tomatoSlices-(2*cheeseSlices))/2;return {n,cheeseSlices-n};\\n    }\\n};\\n```\\n**logik**\\n1.if tomato slices are odd , they can\\'t be used in any way as we can take 2 or 4 at a time so by stating the obvious **Sum of two even numbers is even** \\n2.If there are more cheese slices than half of tomato slices then too there will be always some cheese remaining , similarly if they are less than one fourth then there will be tomato slices remaining\\n3. consider we make m large burgers and n small ones so total tomato slices=2n+4m\\n4.total cheeze slices=m+n\\n5.solving equation 3 and 4 we get**n=(tomatoSlices-(2xcheeseSlices))/2**  and **m=cheeseSlices-n**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2||cheeseSlices*4<tomatoSlices||cheeseSlices*2>tomatoSlices)return {};\\n        int n=(tomatoSlices-(2*cheeseSlices))/2;return {n,cheeseSlices-n};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132315,
                "title": "java-o-1-1-ms-100",
                "content": "PLEASE UPVOTE IF HELPFUL\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n\\n        if(2 * cheeseSlices > tomatoSlices) { return res; }\\n\\n        if(tomatoSlices > 4 * cheeseSlices) { return res; }\\n\\n        if((tomatoSlices & 1) == 1) { return res; }\\n\\n        res.add(tomatoSlices / 2 - cheeseSlices);\\n        res.add(cheeseSlices - res.get(0));\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> res = new ArrayList<Integer>();\\n\\n        if(2 * cheeseSlices > tomatoSlices) { return res; }\\n\\n        if(tomatoSlices > 4 * cheeseSlices) { return res; }\\n\\n        if((tomatoSlices & 1) == 1) { return res; }\\n\\n        res.add(tomatoSlices / 2 - cheeseSlices);\\n        res.add(cheeseSlices - res.get(0));\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107889,
                "title": "c-10-lines-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(float a, float b) {\\n        int x=(a/2)-b;\\n        int y=b-x;\\n        cout<<x<<\" \"<<y<<endl;\\n        vector<int>v;\\n        if(x<0 || y<0) return v;\\n        if((2*x)+y!=(a/2)) return v;\\n        if(x+y!=b) return v;\\n        v.push_back(x);\\n        v.push_back(y);\\n        return v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(float a, float b) {\\n        int x=(a/2)-b;\\n        int y=b-x;\\n        cout<<x<<\" \"<<y<<endl;\\n        vector<int>v;\\n        if(x<0 || y<0) return v;\\n        if((2*x)+y!=(a/2)) return v;\\n        if(x+y!=b) return v;\\n        v.push_back(x);\\n        v.push_back(y);\\n        return v;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3089819,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n        let (tomato_slices, cheese_slices) = (tomato_slices as i64, cheese_slices as i64);\\n        let (a, b) = (tomato_slices - 2 * cheese_slices, 4 * cheese_slices - tomato_slices);\\n        if a < 0 || b < 0 || a % 2 != 0 || b % 2 != 0 {\\n            return vec![];\\n        }\\n        vec![(a / 2) as i32, (b / 2) as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_of_burgers(tomato_slices: i32, cheese_slices: i32) -> Vec<i32> {\\n        let (tomato_slices, cheese_slices) = (tomato_slices as i64, cheese_slices as i64);\\n        let (a, b) = (tomato_slices - 2 * cheese_slices, 4 * cheese_slices - tomato_slices);\\n        if a < 0 || b < 0 || a % 2 != 0 || b % 2 != 0 {\\n            return vec![];\\n        }\\n        vec![(a / 2) as i32, (b / 2) as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024796,
                "title": "c-fast-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan be solved by forming mathematical equations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince, we are capable of forming two equations and we need to find out values of two variables. Hence, we can find out the values of these variables by solving both the equations.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if(tomatoSlices%2==0 && tomatoSlices/2>=cheeseSlices && 2*cheeseSlices>=tomatoSlices/2)\\n        {\\n            ans.push_back(tomatoSlices/2-cheeseSlices);\\n            ans.push_back(2*cheeseSlices-tomatoSlices/2);\\n            return ans;\\n        }\\n\\n        else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        if(tomatoSlices%2==0 && tomatoSlices/2>=cheeseSlices && 2*cheeseSlices>=tomatoSlices/2)\\n        {\\n            ans.push_back(tomatoSlices/2-cheeseSlices);\\n            ans.push_back(2*cheeseSlices-tomatoSlices/2);\\n            return ans;\\n        }\\n\\n        else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963783,
                "title": "simple-approach-with-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can directly solve the approach using simple math technique.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, we must determine whether the tomato slices are odd or even. There is no chance that the burger can be made if the tomato slices are not even, as both burgers require even tomato slices. Therefore, if tomato slices are even, we can proceed with the mathematical method. Further steps are given in code as a comment.\\n\\nLet\\'s say there are \\'j\\' jumbo burgers possible and \\'s\\' small burgers possible.\\n\\n=> Total tomato slices needed for them = 4*j + 2*s = ts\\nand Total cheese slices needed for them is = j + s = cs\\n\\nAfter finding j and s we can find the final answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        \\n        vector<int> ans;\\n\\n        /*\\n        4j + 2s = ts\\n        j + s = cs\\n        => 2j + 2s = 2cs\\n\\n        => 2j = ts - 2cs\\n        => j = ts - 2cs / 2\\n\\n        => s = 2cs - (ts/2)\\n        */\\n\\n        if (ts%2==0)\\n        {\\n            int j = (ts - 2*cs)/2;\\n            int s = 2*cs - (ts/2);\\n            if (j >= 0 &&  s>= 0)\\n            {\\n                ans.push_back(j);\\n                ans.push_back(s);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n        \\n        vector<int> ans;\\n\\n        /*\\n        4j + 2s = ts\\n        j + s = cs\\n        => 2j + 2s = 2cs\\n\\n        => 2j = ts - 2cs\\n        => j = ts - 2cs / 2\\n\\n        => s = 2cs - (ts/2)\\n        */\\n\\n        if (ts%2==0)\\n        {\\n            int j = (ts - 2*cs)/2;\\n            int s = 2*cs - (ts/2);\\n            if (j >= 0 &&  s>= 0)\\n            {\\n                ans.push_back(j);\\n                ans.push_back(s);\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929661,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        val = (tomatoSlices - 2*cheeseSlices)\\n\\n        if val >= 0 and val%2 == 0 and cheeseSlices-val//2 >= 0:\\n            return [val//2,cheeseSlices-val//2]\\n\\n        return []\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices, cheeseSlices):\\n        val = (tomatoSlices - 2*cheeseSlices)\\n\\n        if val >= 0 and val%2 == 0 and cheeseSlices-val//2 >= 0:\\n            return [val//2,cheeseSlices-val//2]\\n\\n        return []\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842765,
                "title": "python-math-system-of-equations-step-by-step",
                "content": "The important fact here is that one of the main conditions for the quantities of Tomatoes (t) and Cheese slices (c) to be valid, they must follow this relationship:\\nThe total number of tomatoes (t) is 4 times the number of cheese slices of each jumbo burger (c1), plus 2 times the number of cheese slices in each small burger (c2). If that\\'s not satisfied, then we cannot make use of all the ingredients.\\nAnd the total number of cheese slices (c) equals the sum of the slices of each type of burger (c1 + c2)\\nCommon sense dictates that c1 >= 0 and c2 >= 0.\\nThat yields:\\n```\\nt = 4 * c1 + 2 * c2\\nc = c1 + c2\\n```\\nWith constraints `c1 >= 0, c2 >= 0, and they are both integers`\\n\\nWhich can be solved step by step:\\nReplacing `c1` by `c - c2`\\n`t` = `4 * (c - c2) + 2 * c2` = `4 * c - 2 * c2`\\nIt follows that\\n`c2` = `(4 * c - t) / 2` = `2 * c - t / 2` the latter expression being so as to keep the numbers low\\nand \\n`c1` = `c - c2`\\n\\nThen we just have to check that:\\n* `c2 is actually an integer`\\n* `c2 < c`\\n* `c2 >= 0`\\n\\nAnd that\\'s pretty much it.\\n**Constant time and space complexity.**\\n\\n```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        cSmall = 2 * c - t / 2\\n        if (int(cSmall) != cSmall or int(cSmall) > c or cSmall < 0): return []\\n        \\n        return [c - int(cSmall), int(cSmall)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nt = 4 * c1 + 2 * c2\\nc = c1 + c2\\n```\n```\\nclass Solution:\\n    def numOfBurgers(self, t: int, c: int) -> List[int]:\\n        cSmall = 2 * c - t / 2\\n        if (int(cSmall) != cSmall or int(cSmall) > c or cSmall < 0): return []\\n        \\n        return [c - int(cSmall), int(cSmall)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839395,
                "title": "python-simple-formula",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        #x, cheeseSlices-x   be [jumbo,small]\\n        #4x,2(cheese-x)=tomato\\n        #2x=tomato-2cheese\\n        #Let 2x be n\\n        n=tomatoSlices-2*cheeseSlices\\n        if n%2==0:\\n            if n//2>=0 and n//2<=cheeseSlices:return [n//2,cheeseSlices-n//2]\\n        return []\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        #x, cheeseSlices-x   be [jumbo,small]\\n        #4x,2(cheese-x)=tomato\\n        #2x=tomato-2cheese\\n        #Let 2x be n\\n        n=tomatoSlices-2*cheeseSlices\\n        if n%2==0:\\n            if n//2>=0 and n//2<=cheeseSlices:return [n//2,cheeseSlices-n//2]\\n        return []\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815396,
                "title": "math-with-styeps",
                "content": "vector<int> numOfBurgers(int ts, int cs) {\\n        vector<int> ans;\\n        /*\\n        x*4 + y*2 = ts    (1)\\n        x*1 + y*1 = cs    (2)\\n            \\n        2(x*2 + y) = ts\\n        x*1 + y*1 = cs\\n        \\n        divide (1) by 2  \\n        x*2 +y = ts/2   (3)\\n        x + y = cs\\n            \\n\\t\\t(3)-(2) yields\\n        x = ts/2 -cs\\n\\t\\t\\n        subsitute into (2) and derive for y\\n        y =cs -x\\n        */\\n        \\n\\t\\t//if ts is odd then there is not solution, from (1)\\n        if(ts%2)return ans;\\n        \\n        int x= ts/2-cs;\\n        int y = cs-x;\\n        \\n\\t\\t//x and y can not be zero in this context\\n        if(x<0 || y<0)return ans;\\n        \\n        ans.push_back(x);\\n        ans.push_back(y);\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "vector<int> numOfBurgers(int ts, int cs) {\\n        vector<int> ans;\\n        /*\\n        x*4 + y*2 = ts    (1)\\n        x*1 + y*1 = cs    (2)\\n            \\n        2(x*2 + y) = ts\\n        x*1 + y*1 = cs\\n        \\n        divide (1) by 2  \\n        x*2 +y = ts/2   (3)\\n        x + y = cs\\n            \\n\\t\\t(3)-(2) yields\\n        x = ts/2 -cs\\n\\t\\t\\n        subsitute into (2) and derive for y\\n        y =cs -x\\n        */\\n        \\n\\t\\t//if ts is odd then there is not solution, from (1)\\n        if(ts%2)return ans;\\n        \\n        int x= ts/2-cs;\\n        int y = cs-x;\\n        \\n\\t\\t//x and y can not be zero in this context\\n        if(x<0 || y<0)return ans;\\n        \\n        ans.push_back(x);\\n        ans.push_back(y);\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2784394,
                "title": "python-linear-equation",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T, C = tomatoSlices, cheeseSlices\\n        if T < 2*C or (T - 2*C)%2 != 0: return []\\n        if 4*C < T or (4*C - T)%2 != 0: return []\\n        return [(T - 2*C)//2, (4*C - T)//2]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        T, C = tomatoSlices, cheeseSlices\\n        if T < 2*C or (T - 2*C)%2 != 0: return []\\n        if 4*C < T or (4*C - T)%2 != 0: return []\\n        return [(T - 2*C)//2, (4*C - T)//2]",
                "codeTag": "Java"
            },
            {
                "id": 2752266,
                "title": "go-linear-equation",
                "content": "Let us define number of jumbo burgers as X and number of small burgers as Y We have to find an x and y in this equation:\\n1. 4X + 2Y = tomato\\n2. X + Y = cheese\\n\\n```\\nfunc numOfBurgers(tomatoSlices int, cheeseSlices int) []int {\\n    reminder := (4*cheeseSlices - tomatoSlices) % 2\\n    if reminder != 0 {\\n        return nil\\n    }\\n    \\n    small := (4*cheeseSlices - tomatoSlices) / 2\\n    jumbo := cheeseSlices - small\\n    \\n    if small < 0 || jumbo < 0 {\\n        return nil\\n    }\\n    return []int{jumbo, small}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numOfBurgers(tomatoSlices int, cheeseSlices int) []int {\\n    reminder := (4*cheeseSlices - tomatoSlices) % 2\\n    if reminder != 0 {\\n        return nil\\n    }\\n    \\n    small := (4*cheeseSlices - tomatoSlices) / 2\\n    jumbo := cheeseSlices - small\\n    \\n    if small < 0 || jumbo < 0 {\\n        return nil\\n    }\\n    return []int{jumbo, small}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2705724,
                "title": "java-solution",
                "content": "# I had a python solution initially but it was leading to TLE so I had to write it in java. Here it is.\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(tomatoSlices==0 && cheeseSlices==0)\\n        {\\n            \\n            list.add(0);\\n            list.add(0);\\n        }\\n        else\\n        {\\n            for(int x=0;x<cheeseSlices;x++)\\n            {\\n                if(4*x + 2*(cheeseSlices-x)==tomatoSlices)\\n                {\\n                    list.add(x);\\n                    list.add(cheeseSlices-x);\\n                    return list;\\n                }\\n            }\\n            \\n            return list;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        if(tomatoSlices==0 && cheeseSlices==0)\\n        {\\n            \\n            list.add(0);\\n            list.add(0);\\n        }\\n        else\\n        {\\n            for(int x=0;x<cheeseSlices;x++)\\n            {\\n                if(4*x + 2*(cheeseSlices-x)==tomatoSlices)\\n                {\\n                    list.add(x);\\n                    list.add(cheeseSlices-x);\\n                    return list;\\n                }\\n            }\\n            \\n            return list;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699238,
                "title": "easy-to-understand-java-solution-beats-100-of-the-submissions",
                "content": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (tomatoSlices%2!=0){\\n            return ans;\\n        }else if(tomatoSlices == 0 && cheeseSlices == 0){\\n            ans.add(0);\\n            ans.add(0);\\n            return ans;\\n        }\\n        double x = 0, y = 0;\\n        x = tomatoSlices/2 - cheeseSlices;\\n        y = 2*cheeseSlices-tomatoSlices/2;\\n        if ((int)x == x && (int)y == y && x>=0 && y>=0){\\n            ans.add((int) x);\\n            ans.add((int) y);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if (tomatoSlices%2!=0){\\n            return ans;\\n        }else if(tomatoSlices == 0 && cheeseSlices == 0){\\n            ans.add(0);\\n            ans.add(0);\\n            return ans;\\n        }\\n        double x = 0, y = 0;\\n        x = tomatoSlices/2 - cheeseSlices;\\n        y = 2*cheeseSlices-tomatoSlices/2;\\n        if ((int)x == x && (int)y == y && x>=0 && y>=0){\\n            ans.add((int) x);\\n            ans.add((int) y);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641779,
                "title": "easy-c-code-to-understand",
                "content": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if((t-2*c)<0 or (t-2*c)%2!=0 or 4*c-t<0 or (4*c-t)%2!=0){\\n            return ans;\\n        }\\n        ans.push_back((t-2*c)/2);\\n        ans.push_back((4*c-t)/2);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n        vector<int>ans;\\n        if((t-2*c)<0 or (t-2*c)%2!=0 or 4*c-t<0 or (4*c-t)%2!=0){\\n            return ans;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2585752,
                "title": "python-simple-math-solution",
                "content": "```\\nIt is easy to have the following equations:\\n4*x+2*y=to\\nx+y=ch\\n\\nSolving the previous equations lead x, y = (to-2*ch)//2, (4*ch-to)//2\\nWe also need to see whether the solution re-create the original inputs of to and ch\\n```\\n\\n```\\ndef numOfBurgers(self, to: int, ch: int) -> List[int]:\\n\\tx, y = (to-2*ch)//2, (4*ch-to)//2\\n\\treturn [x, y] if x>=0 and y>=0 and 4*x+2*y==to and x+y==ch else []\\n```",
                "solutionTags": [],
                "code": "```\\nIt is easy to have the following equations:\\n4*x+2*y=to\\nx+y=ch\\n\\nSolving the previous equations lead x, y = (to-2*ch)//2, (4*ch-to)//2\\nWe also need to see whether the solution re-create the original inputs of to and ch\\n```\n```\\ndef numOfBurgers(self, to: int, ch: int) -> List[int]:\\n\\tx, y = (to-2*ch)//2, (4*ch-to)//2\\n\\treturn [x, y] if x>=0 and y>=0 and 4*x+2*y==to and x+y==ch else []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2576261,
                "title": "simple-maths-equation-in-python",
                "content": "b= big\\n\\ns= small\\n4b+2s= tomatoslices\\nb+s= cheeseslices\\n\\n```\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        b= (tomatoSlices - 2* cheeseSlices)/2\\n        s= (4*cheeseSlices - tomatoSlices)/2\\n\\n        if b== int(b) and s== int(s) and (b>=0 and s>=0):\\n            return [int(b),int(s)]\\n        elif tomatoSlices==0 and cheeseSlices==0:\\n            return [0,0]\\n        else:\\n            return []\\n```",
                "solutionTags": [],
                "code": "```\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        b= (tomatoSlices - 2* cheeseSlices)/2\\n        s= (4*cheeseSlices - tomatoSlices)/2\\n\\n        if b== int(b) and s== int(s) and (b>=0 and s>=0):\\n            return [int(b),int(s)]\\n        elif tomatoSlices==0 and cheeseSlices==0:\\n            return [0,0]\\n        else:\\n            return []\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2575749,
                "title": "python-easy-log-n-solution",
                "content": "\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if(tomatoSlices % 2 !=0):\\n            return []\\n        if(tomatoSlices < cheeseSlices * 2):\\n            return []\\n        if(tomatoSlices > cheeseSlices * 4):\\n            return []\\n        \\n        \\n        diff = int(cheeseSlices / 2)\\n        jumbo = diff\\n        small = cheeseSlices - jumbo\\n        total = 4 * jumbo + 2 * small\\n        \\n        while( total != tomatoSlices ):\\n            diff = int(diff / 2) or 1\\n            \\n            if(total > tomatoSlices):\\n                jumbo = jumbo - diff\\n                small = cheeseSlices - jumbo \\n                \\n            else:\\n                jumbo = jumbo + diff\\n                small = cheeseSlices - jumbo \\n        \\n            total = 4 * jumbo + 2 * small\\n            \\n        return [jumbo, small]",
                "solutionTags": [],
                "code": "\\tdef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if(tomatoSlices % 2 !=0):\\n            return []\\n        if(tomatoSlices < cheeseSlices * 2):\\n            return []\\n        if(tomatoSlices > cheeseSlices * 4):\\n            return []\\n        \\n        \\n        diff = int(cheeseSlices / 2)\\n        jumbo = diff\\n        small = cheeseSlices - jumbo\\n        total = 4 * jumbo + 2 * small\\n        \\n        while( total != tomatoSlices ):\\n            diff = int(diff / 2) or 1\\n            \\n            if(total > tomatoSlices):\\n                jumbo = jumbo - diff\\n                small = cheeseSlices - jumbo \\n                \\n            else:\\n                jumbo = jumbo + diff\\n                small = cheeseSlices - jumbo \\n        \\n            total = 4 * jumbo + 2 * small\\n            \\n        return [jumbo, small]",
                "codeTag": "Python3"
            },
            {
                "id": 2571150,
                "title": "c-o-1-solution-no-need-to-loop-math-equations-math",
                "content": "# Explanation\\n* **4x + 2y = Tomatos**\\n* **x+y = Cheese**\\n* X is No. Larger burger\\n* Y is No. smaller Burger\\nby solving these two equation together to evaluate each X and Y \\nwe get **y = cheese - x** And **x = (Tomatos - 2 * Cheese) /2**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) {\\n        vector<int>res;\\n        if (T % 2 == 0 && T >= C){\\n            int x = (T - 2*C)/2;\\n            int y = C - x;\\n            if (x < 0 || y < 0)return res; // count can\\'t be negatives\\n            res.push_back(x);\\n            res.push_back(y);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int T, int C) {\\n        vector<int>res;\\n        if (T % 2 == 0 && T >= C){\\n            int x = (T - 2*C)/2;\\n            int y = C - x;\\n            if (x < 0 || y < 0)return res; // count can\\'t be negatives\\n            res.push_back(x);\\n            res.push_back(y);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570891,
                "title": "easy-c-solution",
                "content": "We will consider the small Burger =sm and Jumbo Burger=la;\\nThen we will apply some simple math to get the answer.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int to, int ch) {\\n        int x=4*ch-to;\\n        if(x%2!=0) return {};\\n        else{\\n            int sm=x/2;\\n            int la=ch-sm;\\n            if(sm>=0 and la>=0){\\n            return {la,sm};\\n            }\\n            else\\n            {\\n                return {};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int to, int ch) {\\n        int x=4*ch-to;\\n        if(x%2!=0) return {};\\n        else{\\n            int sm=x/2;\\n            int la=ch-sm;\\n            if(sm>=0 and la>=0){\\n            return {la,sm};\\n            }\\n            else\\n            {\\n                return {};\\n            }\\n        }\\n        return {};\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564607,
                "title": "python-o-1-one-statement",
                "content": "```\\nclass Solution:\\n    from typing import List\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        return [] if (tomatoSlices - 2 * cheeseSlices) < 0 or (cheeseSlices * 4 - tomatoSlices) < 0 or tomatoSlices % 2 else [tomatoSlices //2 - cheeseSlices, cheeseSlices * 2 -tomatoSlices // 2]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    from typing import List\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        return [] if (tomatoSlices - 2 * cheeseSlices) < 0 or (cheeseSlices * 4 - tomatoSlices) < 0 or tomatoSlices % 2 else [tomatoSlices //2 - cheeseSlices, cheeseSlices * 2 -tomatoSlices // 2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561957,
                "title": "c-simplest-solution-math",
                "content": "\\n\\t vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        // invalid case \\n        if(tomatoSlices &1 ){\\n            return {};\\n        }\\n        \\n        int y = (tomatoSlices/2) - cheeseSlices;\\n        int x = cheeseSlices -  y;\\n        \\n        // check not valid ans \\n        if(x <0 || y <0){\\n            return {};\\n        }\\n        \\n        return {y,x};\\n                                                                                             \\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "\\n\\t vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        // invalid case \\n        if(tomatoSlices &1 ){\\n            return {};\\n        }\\n        \\n        int y = (tomatoSlices/2) - cheeseSlices;\\n        int x = cheeseSlices -  y;\\n        \\n        // check not valid ans \\n        if(x <0 || y <0){\\n            return {};\\n        }\\n        \\n        return {y,x};\\n                                                                                             \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2540689,
                "title": "java-100-fast",
                "content": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if(cheeseSlices*2 == tomatoSlices)\\n        {\\n            l.add(0);\\n            l.add(cheeseSlices);\\n        }\\n        else if(cheeseSlices*4 == tomatoSlices)\\n        {\\n            l.add(cheeseSlices);\\n            l.add(0);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 == 2)\\n        {\\n            l.add(1);\\n            l.add(cheeseSlices-1);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 > 2 && (tomatoSlices - cheeseSlices*2)%2==0)\\n        {\\n            int diff = 0;\\n            int a = (tomatoSlices - cheeseSlices*2)/4;\\n            if(((tomatoSlices - cheeseSlices*2)%4)==2)\\n            {\\n                diff = 1;\\n            }\\n            if(a*2+diff > cheeseSlices)\\n            {\\n                return l;\\n            }\\n            l.add(a*2+diff);\\n            l.add(cheeseSlices-(a*2+diff));\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> l = new ArrayList<>();\\n        if(cheeseSlices*2 == tomatoSlices)\\n        {\\n            l.add(0);\\n            l.add(cheeseSlices);\\n        }\\n        else if(cheeseSlices*4 == tomatoSlices)\\n        {\\n            l.add(cheeseSlices);\\n            l.add(0);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 == 2)\\n        {\\n            l.add(1);\\n            l.add(cheeseSlices-1);\\n        }\\n        else if(tomatoSlices - cheeseSlices*2 > 2 && (tomatoSlices - cheeseSlices*2)%2==0)\\n        {\\n            int diff = 0;\\n            int a = (tomatoSlices - cheeseSlices*2)/4;\\n            if(((tomatoSlices - cheeseSlices*2)%4)==2)\\n            {\\n                diff = 1;\\n            }\\n            if(a*2+diff > cheeseSlices)\\n            {\\n                return l;\\n            }\\n            l.add(a*2+diff);\\n            l.add(cheeseSlices-(a*2+diff));\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529833,
                "title": "solve-a-linear-system-only-c-python",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> v;\\n        int t = (tomatoSlices-2*cheeseSlices);\\n        int c = (4*cheeseSlices-tomatoSlices);\\n        if(t>=0 && c>=0){\\n            if(t%2==0 && c%2==0){\\n                v.push_back(t/2);\\n                v.push_back(c/2);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        v = []\\n        t = (tomatoSlices-2*cheeseSlices)\\n        c = (4*cheeseSlices-tomatoSlices)\\n        if(t>=0 and c>=0):\\n            if(t%2==0 and c%2==0):\\n                v.append(t//2)\\n                v.append(c//2)\\n        return v\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> v;\\n        int t = (tomatoSlices-2*cheeseSlices);\\n        int c = (4*cheeseSlices-tomatoSlices);\\n        if(t>=0 && c>=0){\\n            if(t%2==0 && c%2==0){\\n                v.push_back(t/2);\\n                v.push_back(c/2);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        v = []\\n        t = (tomatoSlices-2*cheeseSlices)\\n        c = (4*cheeseSlices-tomatoSlices)\\n        if(t>=0 and c>=0):\\n            if(t%2==0 and c%2==0):\\n                v.append(t//2)\\n                v.append(c//2)\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498928,
                "title": "cpp-tc-o-1-sc-o-1",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\t\\t\\t//below are the possible  conditions  to make burgers\\n\\t\\t\\t//tomatoSlices must be even \\n\\t\\t\\t//tomatoSlices/2 >= cheeseSlices && tomatoSlices/4<=cheeseSlices\\n\\n\\t\\t\\t//base case\\n\\t\\t\\tif((tomatoSlices&1) || (tomatoSlices/2 <cheeseSlices) || (tomatoSlices/4>cheeseSlices)){\\n\\t\\t\\t\\treturn {};\\n\\t\\t\\t}\\n\\n\\t\\t\\tint jumboBurgers=0,smallBurgers=0;\\n\\n\\t\\t\\t//total burgers can be made is equal to total cheeseSlices available\\n\\t\\t\\tsmallBurgers=(tomatoSlices/2);  \\n\\t\\t\\tjumboBurgers=smallBurgers-cheeseSlices;\\n\\t\\t\\tsmallBurgers=cheeseSlices-jumboBurgers;\\n\\n\\t\\t\\treturn {jumboBurgers,smallBurgers};\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n\\t\\t\\t//below are the possible  conditions  to make burgers\\n\\t\\t\\t//tomatoSlices must be even \\n\\t\\t\\t//tomatoSlices/2 >= cheeseSlices && tomatoSlices/4<=cheeseSlices\\n\\n\\t\\t\\t//base case\\n\\t\\t\\tif((tomatoSlices&1) || (tomatoSlices/2 <cheeseSlices) || (tomatoSlices/4>cheeseSlices)){\\n\\t\\t\\t\\treturn {}",
                "codeTag": "Java"
            },
            {
                "id": 2489068,
                "title": "c-0ms-simple-logic",
                "content": "**Please do upvote if you liked my efforts :)**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) \\n    {\\n        int a, b;\\n        \\n        if(t%2 != 0 or t<2*c) return {};\\n        \\n        a = t/2-c, b = 2*c-t/2;\\n        if(a<0 or b<0 or 4*a + 2*b != t or a+b != c) return {};\\n        \\n        return {a, b};\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) \\n    {\\n        int a, b;\\n        \\n        if(t%2 != 0 or t<2*c) return {};\\n        \\n        a = t/2-c, b = 2*c-t/2;\\n        if(a<0 or b<0 or 4*a + 2*b != t or a+b != c) return {};\\n        \\n        return {a, b};\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460355,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "Runtime: 99 ms, faster than 82.35% of JavaScript online submissions for Number of Burgers with No Waste of Ingredients.\\nMemory Usage: 43.4 MB, less than 94.12% of JavaScript online submissions for Number of Burgers with No Waste of Ingredients.\\n```\\nvar numOfBurgers = function (tomatoSlices, cheeseSlices) {\\n  if (!(cheeseSlices * 2 <= tomatoSlices)) {\\n    return [];\\n  }\\n  if (tomatoSlices % 2 !== 0) {\\n    return [];\\n  }\\n  let halfTomatoSlices = tomatoSlices / 2;\\n  let jumbo = halfTomatoSlices - cheeseSlices;\\n  if (jumbo > cheeseSlices) {\\n    return [];\\n  }\\n  return [jumbo, cheeseSlices - jumbo];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfBurgers = function (tomatoSlices, cheeseSlices) {\\n  if (!(cheeseSlices * 2 <= tomatoSlices)) {\\n    return [];\\n  }\\n  if (tomatoSlices % 2 !== 0) {\\n    return [];\\n  }\\n  let halfTomatoSlices = tomatoSlices / 2;\\n  let jumbo = halfTomatoSlices - cheeseSlices;\\n  if (jumbo > cheeseSlices) {\\n    return [];\\n  }\\n  return [jumbo, cheeseSlices - jumbo];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2416647,
                "title": "math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n          if(ts&1) return {};\\n        \\n          int lb=(ts/4)+((ts%4)?1:0);\\n          int ub=(ts/2);\\n        \\n          if(cs<lb or cs>ub) return {};\\n          \\n          int fm=(ts/4); \\n        \\n          int ftke=0;\\n        \\n          while(ftke <= fm)\\n          {\\n              int bachelo=(ts - (ftke*4));\\n              int takenbytwo=(bachelo/2);\\n              \\n              if((ftke+takenbytwo) == cs){\\n                  return {ftke,takenbytwo};\\n              }\\n              \\n              ftke++; \\n          }\\n          \\n         return {};\\n          \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int ts, int cs) {\\n          if(ts&1) return {};\\n        \\n          int lb=(ts/4)+((ts%4)?1:0);\\n          int ub=(ts/2);\\n        \\n          if(cs<lb or cs>ub) return {};\\n          \\n          int fm=(ts/4); \\n        \\n          int ftke=0;\\n        \\n          while(ftke <= fm)\\n          {\\n              int bachelo=(ts - (ftke*4));\\n              int takenbytwo=(bachelo/2);\\n              \\n              if((ftke+takenbytwo) == cs){\\n                  return {ftke,takenbytwo};\\n              }\\n              \\n              ftke++; \\n          }\\n          \\n         return {};\\n          \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416053,
                "title": "c-0ms-100-faster-math",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n\\n        if (tomatoSlices == 0 and cheeseSlices == 0)\\n            return {0, 0};\\n        if (tomatoSlices % 2 != 0)\\n            return {};\\n\\n        if (tomatoSlices <= cheeseSlices)\\n            return {};\\n        if ((tomatoSlices - (2 * cheeseSlices)) % 2 != 0)\\n            return {};\\n\\n        int x = (tomatoSlices - (2 * cheeseSlices)) / 2;\\n        if (x < 0)\\n            return {};\\n\\n        int y = cheeseSlices - x;\\n        if (y < 0)\\n            return {};\\n\\n        return {x, y};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices)\\n    {\\n\\n        if (tomatoSlices == 0 and cheeseSlices == 0)\\n            return {0, 0};\\n        if (tomatoSlices % 2 != 0)\\n            return {};\\n\\n        if (tomatoSlices <= cheeseSlices)\\n            return {};\\n        if ((tomatoSlices - (2 * cheeseSlices)) % 2 != 0)\\n            return {};\\n\\n        int x = (tomatoSlices - (2 * cheeseSlices)) / 2;\\n        if (x < 0)\\n            return {};\\n\\n        int y = cheeseSlices - x;\\n        if (y < 0)\\n            return {};\\n\\n        return {x, y};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414438,
                "title": "python-maths-formula",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \\n        Jumbo = (tomatoSlices - 2*cheeseSlices) / 2\\n        \\n        Small = cheeseSlices - Jumbo\\n        \\n        if int(Jumbo) == Jumbo >= 0 and int(Small) == Small >= 0:\\n            return [int(Jumbo), int(Small)]\\n        \\n        return []\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        \\n        Jumbo = (tomatoSlices - 2*cheeseSlices) / 2\\n        \\n        Small = cheeseSlices - Jumbo\\n        \\n        if int(Jumbo) == Jumbo >= 0 and int(Small) == Small >= 0:\\n            return [int(Jumbo), int(Small)]\\n        \\n        return []\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2405898,
                "title": "easy-math-c",
                "content": "```\\n vector<int> numOfBurgers(int t, int c) {\\n        //4-1,2-1\\n        vector<int> v;\\n        t-=c*2;\\n        if(t%2!=0 || t<0)\\n            return v;\\n        int temp=t/2;\\n        v.push_back(temp);\\n        if((c-temp)<0)\\n            return {};\\n        v.push_back((c-temp));\\n        return v;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\n vector<int> numOfBurgers(int t, int c) {\\n        //4-1,2-1\\n        vector<int> v;\\n        t-=c*2;\\n        if(t%2!=0 || t<0)\\n            return v;\\n        int temp=t/2;\\n        v.push_back(temp);\\n        if((c-temp)<0)\\n            return {};\\n        v.push_back((c-temp));\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2368872,
                "title": "binary-search-c-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Observation\\n        // Total Number of Burgers is Equal to Number of cheeseSlices\\n        // Try to make 1 --> cheeseSlices Amount of Jumbo Burgers and \\n        // remaining will be Small Burger\\n        vector <int> ans;\\n        if(tomatoSlices == 0 and cheeseSlices == 0) {\\n            ans.push_back(0), ans.push_back(0);\\n            return ans;\\n        }\\n        // Do Binary Search to Get Ideal Division.\\n        int low = 0, high = cheeseSlices;\\n        while(low < high) {\\n            int mid = (low + high) / 2;\\n            int jumbo = mid, small = cheeseSlices - mid;\\n            // Jumbo needs 4 tomatoes per burger\\n            // Small needs 2 tomatoes per burger\\n            int needJumboTom = jumbo * 4;\\n            int needSmallTom = small * 2;\\n            // Should Add Upto tomatoSlices\\n            if(needJumboTom + needSmallTom == tomatoSlices) {\\n                ans.push_back(jumbo), ans.push_back(small);\\n                break;\\n            } else if(needJumboTom + needSmallTom < tomatoSlices) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nHope You Like It :)",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // Observation\\n        // Total Number of Burgers is Equal to Number of cheeseSlices\\n        // Try to make 1 --> cheeseSlices Amount of Jumbo Burgers and \\n        // remaining will be Small Burger\\n        vector <int> ans;\\n        if(tomatoSlices == 0 and cheeseSlices == 0) {\\n            ans.push_back(0), ans.push_back(0);\\n            return ans;\\n        }\\n        // Do Binary Search to Get Ideal Division.\\n        int low = 0, high = cheeseSlices;\\n        while(low < high) {\\n            int mid = (low + high) / 2;\\n            int jumbo = mid, small = cheeseSlices - mid;\\n            // Jumbo needs 4 tomatoes per burger\\n            // Small needs 2 tomatoes per burger\\n            int needJumboTom = jumbo * 4;\\n            int needSmallTom = small * 2;\\n            // Should Add Upto tomatoSlices\\n            if(needJumboTom + needSmallTom == tomatoSlices) {\\n                ans.push_back(jumbo), ans.push_back(small);\\n                break;\\n            } else if(needJumboTom + needSmallTom < tomatoSlices) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2365094,
                "title": "o-1-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int x=cheeseSlices-((4*cheeseSlices-tomatoSlices)/2);\\n        int y=(4*cheeseSlices-tomatoSlices)/2;\\n        if((4*cheeseSlices-tomatoSlices)%2==0 && x>=0 && y>=0)\\n        {\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        vector<int> ans;\\n        int x=cheeseSlices-((4*cheeseSlices-tomatoSlices)/2);\\n        int y=(4*cheeseSlices-tomatoSlices)/2;\\n        if((4*cheeseSlices-tomatoSlices)%2==0 && x>=0 && y>=0)\\n        {\\n            ans.push_back(x);\\n            ans.push_back(y);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355809,
                "title": "intuitive-just-math-nothing-relevant-to-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // 4 * x + 2 * y == tomato\\n        // 1 * x + 1 * y == cheese\\n        // => 2 * x == tomato - 2 * cheese\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if (jumbo % 2 or jumbo < 0 or cheeseSlices - jumbo / 2 < 0) return {};\\n        \\n        return {jumbo / 2, cheeseSlices - jumbo / 2};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        // 4 * x + 2 * y == tomato\\n        // 1 * x + 1 * y == cheese\\n        // => 2 * x == tomato - 2 * cheese\\n        \\n        int jumbo = tomatoSlices - 2 * cheeseSlices;\\n        if (jumbo % 2 or jumbo < 0 or cheeseSlices - jumbo / 2 < 0) return {};\\n        \\n        return {jumbo / 2, cheeseSlices - jumbo / 2};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349343,
                "title": "c-simple-maths-solution-explained",
                "content": "Let the number of **jumbo burgers** be **m** and the number of **small burgers** be **n**.\\n\\nAccording to the problem, \\n--> for every jumbo burger, 4 tomatoSlices and 1 cheeseSlice are used\\n--> for every small burger, 1 tomatoSlice and 1 cheeseSlice is used.\\n\\nSimply create two linear equations for the above cases and solve :).\\nIf either **m** or **n** comes out to be negative means that we cannot create burgers with no waste of ingredients, therefore return {}.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // if tomatoSlices are odd, tomato ingredient will be wasted for sure since both type of burgers use even number of tomato slices\\n            return {};\\n        \\n        int m, n;\\n        \\n        //4m + 2n = tomatoSlices;\\n        //m + n = cheeseSlices;\\n        \\n        m = (tomatoSlices-2*cheeseSlices)/2;\\n        n = (4*cheeseSlices-tomatoSlices)/2;\\n        \\n        if(m < 0 || n < 0)\\n            return {};\\n        \\n        vector<int> ans;\\n        ans.push_back(m);\\n        ans.push_back(n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices%2 != 0) // if tomatoSlices are odd, tomato ingredient will be wasted for sure since both type of burgers use even number of tomato slices\\n            return {};\\n        \\n        int m, n;\\n        \\n        //4m + 2n = tomatoSlices;\\n        //m + n = cheeseSlices;\\n        \\n        m = (tomatoSlices-2*cheeseSlices)/2;\\n        n = (4*cheeseSlices-tomatoSlices)/2;\\n        \\n        if(m < 0 || n < 0)\\n            return {};\\n        \\n        vector<int> ans;\\n        ans.push_back(m);\\n        ans.push_back(n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337371,
                "title": "java-easy-to-understand",
                "content": "\\'\\'\\'\\nclass Solution {\\n\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        if(tomatoSlices%2!=0)\\n            return l;\\n        \\n        int x=tomatoSlices/2-cheeseSlices;\\n        \\n        if(x<0 || cheeseSlices-x<0)\\n            return l;\\n        \\n        l.add(x);\\n        l.add(cheeseSlices-x);\\n        \\n        return l;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        \\n        List<Integer> l=new ArrayList<>();\\n        \\n        if(tomatoSlices%2!=0)\\n            return l;\\n        \\n        int x=tomatoSlices/2-cheeseSlices;\\n        \\n        if(x<0 || cheeseSlices-x<0)\\n            return l;\\n        \\n        l.add(x);\\n        l.add(cheeseSlices-x);\\n        \\n        return l;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2326286,
                "title": "python-easy-understanding-beats-100",
                "content": "```\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        \\n        if t==c==0:\\n            return [0,0]\\n        four=(t-2*c)//2  # no of jumbo burgers by solving 4x+2y=t and x+y=c\\n        two=c-four #number of small burgers\\n        if c>=t or (t-2*c)%2==1 or four<0 or two<0: #if cheese is less than tomatoes or if number of jumbo burgers is a decimal or number of burgers are negtive we return empty list\\n            return []\\n        \\n        return [four,two]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def numOfBurgers(self, t, c):\\n        \\n        if t==c==0:\\n            return [0,0]\\n        four=(t-2*c)//2  # no of jumbo burgers by solving 4x+2y=t and x+y=c\\n        two=c-four #number of small burgers\\n        if c>=t or (t-2*c)%2==1 or four<0 or two<0: #if cheese is less than tomatoes or if number of jumbo burgers is a decimal or number of burgers are negtive we return empty list\\n            return []\\n        \\n        return [four,two]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314394,
                "title": "java-simple-mathematical-solution-2-approaches-1ms-3ms",
                "content": "**Inefficient solution | O(n)**\\n```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if((tomatoSlices&1)==1)\\n            return new ArrayList<Integer>();\\n        if(cheeseSlices > tomatoSlices/2)\\n            return new ArrayList<Integer>();\\n        int jBurgers = 0;\\n        while(tomatoSlices>2*cheeseSlices && tomatoSlices>0 && cheeseSlices>0){\\n            tomatoSlices -= 4;\\n            cheeseSlices--;\\n            jBurgers++;\\n        }\\n        if(tomatoSlices==2*cheeseSlices)\\n            return Arrays.asList(jBurgers, cheeseSlices);\\n        return new ArrayList<Integer>();\\n    }\\n```\\n\\n**Efficient solution (1ms-3ms) | O(1)**\\n```\\n   public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if((tomatoSlices&1)==1)\\n            return ans;\\n        if(cheeseSlices > tomatoSlices/2 || tomatoSlices > 4*cheeseSlices)\\n            return ans;\\n        int jumbo = (tomatoSlices-cheeseSlices*2)/2;\\n        ans.add(jumbo);\\n        ans.add(cheeseSlices-jumbo);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if((tomatoSlices&1)==1)\\n            return new ArrayList<Integer>();\\n        if(cheeseSlices > tomatoSlices/2)\\n            return new ArrayList<Integer>();\\n        int jBurgers = 0;\\n        while(tomatoSlices>2*cheeseSlices && tomatoSlices>0 && cheeseSlices>0){\\n            tomatoSlices -= 4;\\n            cheeseSlices--;\\n            jBurgers++;\\n        }\\n        if(tomatoSlices==2*cheeseSlices)\\n            return Arrays.asList(jBurgers, cheeseSlices);\\n        return new ArrayList<Integer>();\\n    }\\n```\n```\\n   public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer> ans = new ArrayList<>();\\n        if((tomatoSlices&1)==1)\\n            return ans;\\n        if(cheeseSlices > tomatoSlices/2 || tomatoSlices > 4*cheeseSlices)\\n            return ans;\\n        int jumbo = (tomatoSlices-cheeseSlices*2)/2;\\n        ans.add(jumbo);\\n        ans.add(cheeseSlices-jumbo);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297276,
                "title": "two-equations-in-two-unknowns-python",
                "content": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        ns = (4*cheeseSlices - tomatoSlices)/2\\n        nj = cheeseSlices- ns                \\n        \\n        if nj < 0 or ns < 0 or (4*int(nj)+ 2*int(ns)) != tomatoSlices or (int(nj) + int(ns)) != cheeseSlices :\\n            return []\\n        else:\\n            return[int(nj), int(ns)]",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        ns = (4*cheeseSlices - tomatoSlices)/2\\n        nj = cheeseSlices- ns                \\n        \\n        if nj < 0 or ns < 0 or (4*int(nj)+ 2*int(ns)) != tomatoSlices or (int(nj) + int(ns)) != cheeseSlices :\\n            return []\\n        else:\\n            return[int(nj), int(ns)]",
                "codeTag": "Python3"
            },
            {
                "id": 2263824,
                "title": "python-pure-math-explained",
                "content": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\"\"\"\\n\\t\\tj: jumbo , s: small,  so we can get :\\n\\t\\t4j + 2s = t\\n\\t\\tj + s = c\\n\\t\\t==>\\n\\t\\t2j = t-2c  => j = (t-2c)/2\\n\\t\\t2s = 4c-t  => s = 2c-t/2\\n\\t\\t\\n\\t\\tSo , now the objective is to get non-negative answer for j and s\\n\\t\"\"\"\\n\\tt, c = tomatoSlices, cheeseSlices\\n\\tj = (t-2*c)/2 \\n\\tif int(j) != j or j < 0:\\n\\t\\treturn []\\n\\ts = 2*c - t/2\\n\\n\\tif int(s) != s or s < 0:\\n\\t\\treturn []\\n\\treturn [int(j), int(s)]\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\"\"\"\\n\\t\\tj: jumbo , s: small,  so we can get :\\n\\t\\t4j + 2s = t\\n\\t\\tj + s = c\\n\\t\\t==>\\n\\t\\t2j = t-2c  => j = (t-2c)/2\\n\\t\\t2s = 4c-t  => s = 2c-t/2\\n\\t\\t\\n\\t\\tSo , now the objective is to get non-negative answer for j and s\\n\\t\"\"\"\\n\\tt, c = tomatoSlices, cheeseSlices\\n\\tj = (t-2*c)/2 \\n\\tif int(j) != j or j < 0:\\n\\t\\treturn []\\n\\ts = 2*c - t/2\\n\\n\\tif int(s) != s or s < 0:\\n\\t\\treturn []\\n\\treturn [int(j), int(s)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2208887,
                "title": "equations-in-my-programming-seriously-upd",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\\tif (tomatoSlices % 2 == 1): #UPD that improve speed almost twice\\n\\t\\t\\treturn []\\n        \"\"\"\\n        a system of two equations:\\n            4x+2y = tomatoSlices\\n            x+y = cheeseSlices\\n        \"\"\"\\n        x = tomatoSlices/2 - cheeseSlices\\n        y =  (cheeseSlices-x)\\n        if (0<=x==int(x))*(0<=y==int(y)):\\n            return [int(x),int(y)]\\n        return []",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n\\t\\tif (tomatoSlices % 2 == 1): #UPD that improve speed almost twice\\n\\t\\t\\treturn []\\n        \"\"\"\\n        a system of two equations:\\n            4x+2y = tomatoSlices\\n            x+y = cheeseSlices\\n        \"\"\"\\n        x = tomatoSlices/2 - cheeseSlices\\n        y =  (cheeseSlices-x)\\n        if (0<=x==int(x))*(0<=y==int(y)):\\n            return [int(x),int(y)]\\n        return []",
                "codeTag": "Java"
            },
            {
                "id": 2172522,
                "title": "c-solution-based-on-math",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n\\n        int delta_a = (t - 2 * c);\\n        int delta_b = (-t + 4 * c);\\n        if (delta_a % 2 == 1 || delta_b % 2 == 1){\\n            return {};\\n        }\\n        int j = delta_a / 2;\\n        int s = delta_b / 2;\\n        if (j < 0 || s < 0){\\n            return {};\\n        }\\n        return {j, s}; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int t, int c) {\\n\\n        int delta_a = (t - 2 * c);\\n        int delta_b = (-t + 4 * c);\\n        if (delta_a % 2 == 1 || delta_b % 2 == 1){\\n            return {};\\n        }\\n        int j = delta_a / 2;\\n        int s = delta_b / 2;\\n        if (j < 0 || s < 0){\\n            return {};\\n        }\\n        return {j, s}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166808,
                "title": "linear-equation-problem-using-python3",
                "content": "4x + 2y = tomatoSlices = t\\nx + y = cheese slices = c\\nwhere 4x+y => Jumbo Burger\\nand 2x+y => Small Burger\\n, after solving the equations we get,\\n\\nx = (t - 2*c)/2\\ny = (4*c-t)/2\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = (tomatoSlices - 2*cheeseSlices)/2\\n        y = (4*cheeseSlices - tomatoSlices)/2\\n        if x<0 or y<0 or int(x)!=x or int(y)!=y:\\n            return []\\n        else:\\n            return [int(x),int(y)]\\n``\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "4x + 2y = tomatoSlices = t\\nx + y = cheese slices = c\\nwhere 4x+y => Jumbo Burger\\nand 2x+y => Small Burger\\n, after solving the equations we get,\\n\\nx = (t - 2*c)/2\\ny = (4*c-t)/2\\n\\n```\\ndef numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        x = (tomatoSlices - 2*cheeseSlices)/2\\n        y = (4*cheeseSlices - tomatoSlices)/2\\n        if x<0 or y<0 or int(x)!=x or int(y)!=y:\\n            return []\\n        else:\\n            return [int(x),int(y)]\\n``\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2125510,
                "title": "c-simple-mathematics",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato%2) return {};\\n        int j=tomato/2-cheese;\\n        int s=cheese-j;\\n        if(s<0 or j<0){\\n            return {};\\n        }\\n        return {j,s};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> numOfBurgers(int tomato, int cheese) {\\n        if(tomato%2) return {};\\n        int j=tomato/2-cheese;\\n        int s=cheese-j;\\n        if(s<0 or j<0){\\n            return {};\\n        }\\n        return {j,s};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120256,
                "title": "python-3-simple-o-1-math-solution",
                "content": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices % 2:\\n            return []\\n        jumbo = tomatoSlices // 2 - cheeseSlices\\n        if jumbo < 0 or cheeseSlices < jumbo:\\n            return []\\n        return [jumbo, cheeseSlices - jumbo]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\\n        if tomatoSlices % 2:\\n            return []\\n        jumbo = tomatoSlices // 2 - cheeseSlices\\n        if jumbo < 0 or cheeseSlices < jumbo:\\n            return []\\n        return [jumbo, cheeseSlices - jumbo]",
                "codeTag": "Java"
            },
            {
                "id": 2101555,
                "title": "simple-javascript-solution",
                "content": "```\\nfunction numOfBurgers(a, b, s = 0) {\\n    while (a > 0 && b > 0 && a !== 2 * b) a -= 4, --b, ++s\\n    return a === 2 * b ? [s, b] : []\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction numOfBurgers(a, b, s = 0) {\\n    while (a > 0 && b > 0 && a !== 2 * b) a -= 4, --b, ++s\\n    return a === 2 * b ? [s, b] : []\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2089539,
                "title": "easy-java-solution-beginner-friendly",
                "content": "**Please Upvote if You Liked The Solution.**\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>list=new ArrayList<>();\\n        int ts=tomatoSlices;\\n        int cs=cheeseSlices;\\n        if (ts<cs*2 || ts>cs*4 || ts%2!=0 || (ts==0 && cs>0) || (cs==0 && ts>0))\\n        {\\n            return list;\\n        }\\n        int cnt=0;\\n        while(ts>0 && cs>0 && ts!=cs*2)\\n        {\\n            ts-=4;\\n            cnt++;\\n            cs--;\\n        }\\n        list.add(cnt);\\n        list.add(cs);\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        List<Integer>list=new ArrayList<>();\\n        int ts=tomatoSlices;\\n        int cs=cheeseSlices;\\n        if (ts<cs*2 || ts>cs*4 || ts%2!=0 || (ts==0 && cs>0) || (cs==0 && ts>0))\\n        {\\n            return list;\\n        }\\n        int cnt=0;\\n        while(ts>0 && cs>0 && ts!=cs*2)\\n        {\\n            ts-=4;\\n            cnt++;\\n            cs--;\\n        }\\n        list.add(cnt);\\n        list.add(cs);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080150,
                "title": "python-simple-algebra",
                "content": "We first simply tomatoSlices as t, cheeseSlices as c.\\nLet\\'s assume there are x jumbo and y small. We will have the following euqations:\\n* 4x + 2y = t\\n* 2x + y = c\\n\\nSolving the above equations, we need to make sure that both x and y will be non-negative integers. \\n```\\ndef numOfBurgers(self, t: int, c: int) -> List[int]:\\n\\tif (t - 2 * c) % 2 or (t - 2 * c) < 0: return []\\n\\tif c < (t - 2 * c) // 2: return []\\n\\treturn [ (t - 2 * c) // 2, c - (t - 2 * c) // 2 ]\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef numOfBurgers(self, t: int, c: int) -> List[int]:\\n\\tif (t - 2 * c) % 2 or (t - 2 * c) < 0: return []\\n\\tif c < (t - 2 * c) // 2: return []\\n\\treturn [ (t - 2 * c) // 2, c - (t - 2 * c) // 2 ]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2073954,
                "title": "java-linear-algebra-based-solution",
                "content": "This is similar to solving a linear algebra question. The result of S and J can\\'t be negative and can\\'t be a fraction.\\n\\nLet J be the number of Jumbo Burgers, S be the number of Small Burgers.\\n\\n4J + 2S = tomatoSlices\\nJ+S = cheeseSlices\\n     \\nJ = cheeseSlices - S;\\n4J + 2S = tomatoSlices\\n4 * (cheeseSlices - S) + 2S = tomatoSlices;\\n4 * cheeseSlices - 4S + 2S = tomatoSlices;\\n4 * cheeseSlices - 2S = tomatoSlices;\\ntomatoSlices - 4 * cheeseSlices = - 2S;\\n0-(tomatoSlices - 4 * cheeseSlices) = 2S;\\nAnd we can substitute S back into the J + S = Cheese to find J.\\n\\nIf either is negative or not an integer, then we return an empty list.\\n```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 1) return new ArrayList();\\n        \\n        \\n        // Both can\\'t be negative!\\n        int twiceNumS = -tomatoSlices + 4 * cheeseSlices;\\n        if(twiceNumS >= 0 && twiceNumS % 2 == 0){\\n            int numS = twiceNumS / 2;\\n            int numJ = cheeseSlices - numS;\\n            if(numJ >= 0){\\n                ArrayList<Integer> ans = new ArrayList();\\n                ans.add(numJ);\\n                ans.add(numS);\\n                return ans;\\n            }\\n        }\\n        return new ArrayList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\\n        if(tomatoSlices % 2 == 1) return new ArrayList();\\n        \\n        \\n        // Both can\\'t be negative!\\n        int twiceNumS = -tomatoSlices + 4 * cheeseSlices;\\n        if(twiceNumS >= 0 && twiceNumS % 2 == 0){\\n            int numS = twiceNumS / 2;\\n            int numJ = cheeseSlices - numS;\\n            if(numJ >= 0){\\n                ArrayList<Integer> ans = new ArrayList();\\n                ans.add(numJ);\\n                ans.add(numS);\\n                return ans;\\n            }\\n        }\\n        return new ArrayList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1968114,
                "content": [
                    {
                        "username": "prometheus101112",
                        "content": "Simple 2 equations and 2 variables problem. Any other ways of solving it ? Do tell"
                    }
                ]
            }
        ]
    },
    {
        "title": "Checking Existence of Edge Length Limited Paths",
        "question_content": "<p>An undirected graph of <code>n</code> nodes is defined by <code>edgeList</code>, where <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with distance <code>dis<sub>i</sub></code>. Note that there may be <strong>multiple</strong> edges between two nodes.</p>\n\n<p>Given an array <code>queries</code>, where <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code>, your task is to determine for each <code>queries[j]</code> whether there is a path between <code>p<sub>j</sub></code> and <code>q<sub>j</sub></code><sub> </sub>such that each edge on the path has a distance <strong>strictly less than</strong> <code>limit<sub>j</sub></code> .</p>\n\n<p>Return <em>a <strong>boolean array</strong> </em><code>answer</code><em>, where </em><code>answer.length == queries.length</code> <em>and the </em><code>j<sup>th</sup></code> <em>value of </em><code>answer</code> <em>is </em><code>true</code><em> if there is a path for </em><code>queries[j]</code><em> is </em><code>true</code><em>, and </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/08/h.png\" style=\"width: 267px; height: 262px;\" />\n<pre>\n<strong>Input:</strong> n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\n<strong>Output:</strong> [false,true]\n<strong>Explanation:</strong> The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.\nFor the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.\nFor the second query, there is a path (0 -&gt; 1 -&gt; 2) of two edges with distances less than 5, thus we return true for this query.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/12/08/q.png\" style=\"width: 390px; height: 358px;\" />\n<pre>\n<strong>Input:</strong> n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\n<strong>Output:</strong> [true,false]\n<strong>Explanation:</strong> The above figure shows the given graph.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= edgeList.length, queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edgeList[i].length == 3</code></li>\n\t<li><code>queries[j].length == 3</code></li>\n\t<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> &lt;= n - 1</code></li>\n\t<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>\n\t<li><code>p<sub>j</sub> != q<sub>j</sub></code></li>\n\t<li><code>1 &lt;= dis<sub>i</sub>, limit<sub>j</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li>There may be <strong>multiple</strong> edges between two nodes.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 978450,
                "title": "c-dsu-two-pointers",
                "content": "**Observation**\\n\\nThe key here is to notice that the queries are offline which means that we can reorganize them however we want.\\n\\nNow to answer the question, whether there is a path between any two nodes where the maximum edge length or weight is less than `limit`, we can join all the edges whose weight is less than `limit` and if we are still not able to reach one node from the other it essentially means that there is no path between them where edge weight is less than `limit`.\\n\\nWhich is the best data structure that can help us join edges as we want and answer whether in that structure, node `a` and node `b` are connected ? \\nThat\\'s right! **DSU**.\\n\\nLet\\'s try and use these facts to solve the question.\\n\\n**Solution**\\n\\nFirst we need to sort the input `queries` and `edgeList` by edge length or `weight`.\\n\\nWe can now simply use a two pointer approach to `Union` all the nodes whose edges have `weight` less than `query[i]`.\\n\\nTo know if there is a path between them all we need is to know whether their parents (in DSU) are same.\\n\\n```c++\\n// Standard Disjoint-set data structure implementation.\\nstatic class DSU {\\n    vector<int> Parent, Rank;\\n    public:\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries)\\n    {\\n        DSU dsu(n);\\n\\t\\t\\n\\t\\t//Add query indices to help with organizing/ordering results.\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n\\t\\t\\n\\t\\t//Sort inputs\\n        sort(queries.begin(), queries.end(), [](auto &l, auto &r) { return l[2] < r[2]; });\\n        sort(edgeList.begin(), edgeList.end(), [](auto &l, auto &r) { return l.back() < r.back(); });\\n\\t\\t\\n        int i=0;\\n        vector<bool> result(queries.size());\\n        for (vector<int> &q:queries) \\n        {\\n\\t\\t\\t// Two pointer approach. Join the edges till their weight is less than the current query.\\n            while (i<edgeList.size()&&edgeList[i][2]<q[2]) \\n                dsu.Union(edgeList[i][0],edgeList[i++][1]);\\n\\t\\t\\t\\n\\t\\t\\t//If parents are same we know that their is a path.\\n            result[q.back()]=dsu.Find(q[0]) == dsu.Find(q[1]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nTime: `O(ElogE + QlogQ)`. Where `E` is the number of edges in `edgeList` and `Q` is the number of `queries`. This comes from sorting both inputs.\\nSpace: `O(n)`. Where `n` is the number of nodes.",
                "solutionTags": [],
                "code": "```c++\\n// Standard Disjoint-set data structure implementation.\\nstatic class DSU {\\n    vector<int> Parent, Rank;\\n    public:\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries)\\n    {\\n        DSU dsu(n);\\n\\t\\t\\n\\t\\t//Add query indices to help with organizing/ordering results.\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n\\t\\t\\n\\t\\t//Sort inputs\\n        sort(queries.begin(), queries.end(), [](auto &l, auto &r) { return l[2] < r[2]; });\\n        sort(edgeList.begin(), edgeList.end(), [](auto &l, auto &r) { return l.back() < r.back(); });\\n\\t\\t\\n        int i=0;\\n        vector<bool> result(queries.size());\\n        for (vector<int> &q:queries) \\n        {\\n\\t\\t\\t// Two pointer approach. Join the edges till their weight is less than the current query.\\n            while (i<edgeList.size()&&edgeList[i][2]<q[2]) \\n                dsu.Union(edgeList[i][0],edgeList[i++][1]);\\n\\t\\t\\t\\n\\t\\t\\t//If parents are same we know that their is a path.\\n            result[q.back()]=dsu.Find(q[0]) == dsu.Find(q[1]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978576,
                "title": "python3-union-find",
                "content": "**Algo**\\nSort queries based on weight and sort edges based on weight as well. Scan through queries from lowest to highest weight and connect the edges whose weight strictly fall below this limit. Check if the queried nodes `p` and `q` are connected in Union-Find structure. If so, put `True` in the relevant position; otherwise put `False`. \\n\\n**Implementation**\\n```\\nclass UnionFind:\\n    def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int) -> bool:\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: \\n            prt, qrt = qrt, prt \\n        self.parent[prt] = qrt \\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\\n        edgeList = sorted((w, u, v) for u, v, w in edgeList)\\n        \\n        uf = UnionFind(n)\\n        \\n        ans = [None] * len(queries)\\n        ii = 0\\n        for w, p, q, i in queries: \\n            while ii < len(edgeList) and edgeList[ii][0] < w: \\n                _, u, v = edgeList[ii]\\n                uf.union(u, v)\\n                ii += 1\\n            ans[i] = uf.find(p) == uf.find(q)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN) + O(MlogM)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int) -> bool:\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: \\n            prt, qrt = qrt, prt \\n        self.parent[prt] = qrt \\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\\n        edgeList = sorted((w, u, v) for u, v, w in edgeList)\\n        \\n        uf = UnionFind(n)\\n        \\n        ans = [None] * len(queries)\\n        ii = 0\\n        for w, p, q, i in queries: \\n            while ii < len(edgeList) and edgeList[ii][0] < w: \\n                _, u, v = edgeList[ii]\\n                uf.union(u, v)\\n                ii += 1\\n            ans[i] = uf.find(p) == uf.find(q)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464929,
                "title": "image-explanation-easiest-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Checking Existence of Edge Length Limited Paths` by `Aryan Mittal`\\n![Google4.png](https://assets.leetcode.com/users/images/5e4850eb-7f31-417f-b101-c685af27e333_1682735486.275424.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/7fdc3925-b40c-47f8-b329-8a35eb024040_1682734690.1872091.png)\\n![image.png](https://assets.leetcode.com/users/images/9523d5ad-c938-487e-8fd5-fdef71f04780_1682734707.1898415.png)\\n![image.png](https://assets.leetcode.com/users/images/2488c447-de39-4354-a249-24bf9be4ca37_1682734714.6824613.png)\\n![image.png](https://assets.leetcode.com/users/images/2c00fdfd-e762-40ac-a2b0-b7ae02d0337d_1682734726.421154.png)\\n![image.png](https://assets.leetcode.com/users/images/5aea696d-4164-4cfd-9589-306bd36a76a2_1682734735.6077356.png)\\n![image.png](https://assets.leetcode.com/users/images/27921ff2-c244-4a7b-828e-f2b66e486ba0_1682734744.5216231.png)\\n![image.png](https://assets.leetcode.com/users/images/2d7aedab-b35d-40cf-aa3c-687764bc7848_1682734753.2953846.png)\\n![image.png](https://assets.leetcode.com/users/images/a1c8bec1-1782-4740-89f2-068c3ec8889c_1682734762.1884577.png)\\n![image.png](https://assets.leetcode.com/users/images/26576915-565f-44c9-b751-ef0b71e792b3_1682734770.2168715.png)\\n![image.png](https://assets.leetcode.com/users/images/b3fdfdb5-3a36-4c31-81db-2b22ffbeb8f1_1682734778.0451572.png)\\n![image.png](https://assets.leetcode.com/users/images/f7df8bf9-5bd4-4002-915b-6949850892f0_1682734785.5234723.png)\\n![image.png](https://assets.leetcode.com/users/images/8b06b897-cc67-4d69-bcb8-5014b39a38a6_1682734794.4986067.png)\\n![image.png](https://assets.leetcode.com/users/images/5bcdbb08-4d23-475c-a3f3-3233fe5211d8_1682734821.2350752.png)\\n![image.png](https://assets.leetcode.com/users/images/78f76182-2a5c-46a5-8b81-3b261bb51c03_1682734830.8271737.png)\\n\\n\\n# Code\\n`Mark the DSU Code as the template [I always use this ONLY]`\\n```C++ []\\nclass DSU {\\n    public:\\n    vector<int> Parent, Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n        \\n        sort(queries.begin(), queries.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        sort(edgeList.begin(), edgeList.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        \\n        int i=0;\\n        vector<bool> res(queries.size(), false);\\n        for(auto q: queries){\\n            while(i<edgeList.size() && edgeList[i][2]<q[2]){\\n                dsu.Union(edgeList[i][0] , edgeList[i][1]);\\n                i++;\\n            }\\n            \\n            if(dsu.Find(q[0]) == dsu.Find(q[1]))\\n                res[q[3]] = true;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass DSU {\\n    private int[] parent;\\n    private int[] rank;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x]);\\n    }\\n\\n    public boolean union(int x, int y) {\\n        int xset = find(x), yset = find(y);\\n        if (xset != yset) {\\n            if (rank[xset] < rank[yset]) {\\n                parent[xset] = yset;\\n            } else {\\n                parent[yset] = xset;\\n            }\\n            if (rank[xset] == rank[yset]) {\\n                rank[xset]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        DSU dsu = new DSU(n);\\n        for (int i = 0; i < queries.length; i++) {\\n            queries[i] = new int[] { queries[i][0], queries[i][1], queries[i][2], i };\\n        }\\n\\n        Arrays.sort(queries, (a, b) -> Integer.compare(a[2], b[2]));\\n        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        int i = 0;\\n        boolean[] res = new boolean[queries.length];\\n        for (int[] q : queries) {\\n            while (i < edgeList.length && edgeList[i][2] < q[2]) {\\n                dsu.union(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n\\n            if (dsu.find(q[0]) == dsu.find(q[1])) {\\n                res[q[3]] = true;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n```Python []\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xset, yset = self.find(x), self.find(y)\\n        if xset != yset:\\n            if self.rank[xset] < self.rank[yset]:\\n                self.parent[xset] = yset\\n            else:\\n                self.parent[yset] = xset\\n            if self.rank[xset] == self.rank[yset]:\\n                self.rank[xset] += 1\\n            return True\\n        return False\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        dsu = DSU(n)\\n        for i, q in enumerate(queries):\\n            queries[i].append(i)\\n\\n        queries.sort(key=lambda q: q[2])\\n        edgeList.sort(key=lambda e: e[2])\\n\\n        i = 0\\n        res = [False] * len(queries)\\n        for q in queries:\\n            while i < len(edgeList) and edgeList[i][2] < q[2]:\\n                dsu.union(edgeList[i][0], edgeList[i][1])\\n                i += 1\\n\\n            if dsu.find(q[0]) == dsu.find(q[1]):\\n                res[q[3]] = True\\n\\n        return res\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```C++ []\\nclass DSU {\\n    public:\\n    vector<int> Parent, Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n        \\n        sort(queries.begin(), queries.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        sort(edgeList.begin(), edgeList.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        \\n        int i=0;\\n        vector<bool> res(queries.size(), false);\\n        for(auto q: queries){\\n            while(i<edgeList.size() && edgeList[i][2]<q[2]){\\n                dsu.Union(edgeList[i][0] , edgeList[i][1]);\\n                i++;\\n            }\\n            \\n            if(dsu.Find(q[0]) == dsu.Find(q[1]))\\n                res[q[3]] = true;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass DSU {\\n    private int[] parent;\\n    private int[] rank;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        rank = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] == x) {\\n            return x;\\n        }\\n        return parent[x] = find(parent[x]);\\n    }\\n\\n    public boolean union(int x, int y) {\\n        int xset = find(x), yset = find(y);\\n        if (xset != yset) {\\n            if (rank[xset] < rank[yset]) {\\n                parent[xset] = yset;\\n            } else {\\n                parent[yset] = xset;\\n            }\\n            if (rank[xset] == rank[yset]) {\\n                rank[xset]++;\\n            }\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        DSU dsu = new DSU(n);\\n        for (int i = 0; i < queries.length; i++) {\\n            queries[i] = new int[] { queries[i][0], queries[i][1], queries[i][2], i };\\n        }\\n\\n        Arrays.sort(queries, (a, b) -> Integer.compare(a[2], b[2]));\\n        Arrays.sort(edgeList, (a, b) -> Integer.compare(a[2], b[2]));\\n\\n        int i = 0;\\n        boolean[] res = new boolean[queries.length];\\n        for (int[] q : queries) {\\n            while (i < edgeList.length && edgeList[i][2] < q[2]) {\\n                dsu.union(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n\\n            if (dsu.find(q[0]) == dsu.find(q[1])) {\\n                res[q[3]] = true;\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```Python []\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        xset, yset = self.find(x), self.find(y)\\n        if xset != yset:\\n            if self.rank[xset] < self.rank[yset]:\\n                self.parent[xset] = yset\\n            else:\\n                self.parent[yset] = xset\\n            if self.rank[xset] == self.rank[yset]:\\n                self.rank[xset] += 1\\n            return True\\n        return False\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        dsu = DSU(n)\\n        for i, q in enumerate(queries):\\n            queries[i].append(i)\\n\\n        queries.sort(key=lambda q: q[2])\\n        edgeList.sort(key=lambda e: e[2])\\n\\n        i = 0\\n        res = [False] * len(queries)\\n        for q in queries:\\n            while i < len(edgeList) and edgeList[i][2] < q[2]:\\n                dsu.union(edgeList[i][0], edgeList[i][1])\\n                i += 1\\n\\n            if dsu.find(q[0]) == dsu.find(q[1]):\\n                res[q[3]] = True\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978453,
                "title": "c-union-find",
                "content": "## Solution 1. Union Find\\n\\nSort the edges from small distance to large distance.\\n\\nTraverse the queries from small limit to large limit. Given a limit, we union the nodes that can be connected. \\n\\nIn this way, we just need to traverse the edges that are smaller than the limit. Since we are visiting the queries with increasing limit, we just need to visit the edges once from small distance to large distance.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-220/problems/checking-existence-of-edge-length-limited-paths/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE + QlogQ)\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        id[x] = y;\\n    }\\n    bool connected(int i, int j) { return find(i) == find(j); }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& E, vector<vector<int>>& Q) {\\n        vector<bool> ans(Q.size());\\n        for (int i = 0; i < Q.size(); ++i) Q[i].push_back(i);\\n        sort(begin(Q), end(Q), [&](auto &a, auto &b) { return a[2] < b[2]; });\\n        sort(begin(E), end(E), [&](auto &a, auto &b) { return a[2] < b[2]; });\\n        UnionFind uf(n);\\n        int i = 0;\\n        for (auto &q : Q) { // traverse the queries from small limit to large limit\\n            int u = q[0], v = q[1], limit = q[2], qid = q[3];\\n            for (; i < E.size() && E[i][2] < limit; ++i) uf.connect(E[i][0], E[i][1]); // visit the edges that are smaller than the limit\\n            ans[qid] = uf.connected(u, v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-220/problems/checking-existence-of-edge-length-limited-paths/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE + QlogQ)\\n// Space: O(N)\\nclass UnionFind {\\n    vector<int> id;\\npublic:\\n    UnionFind(int n) : id(n) {\\n        iota(begin(id), end(id), 0);\\n    }\\n    void connect(int a, int b) {\\n        int x = find(a), y = find(b);\\n        if (x == y) return;\\n        id[x] = y;\\n    }\\n    bool connected(int i, int j) { return find(i) == find(j); }\\n    int find(int a) {\\n        return id[a] == a ? a : (id[a] = find(id[a]));\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& E, vector<vector<int>>& Q) {\\n        vector<bool> ans(Q.size());\\n        for (int i = 0; i < Q.size(); ++i) Q[i].push_back(i);\\n        sort(begin(Q), end(Q), [&](auto &a, auto &b) { return a[2] < b[2]; });\\n        sort(begin(E), end(E), [&](auto &a, auto &b) { return a[2] < b[2]; });\\n        UnionFind uf(n);\\n        int i = 0;\\n        for (auto &q : Q) { // traverse the queries from small limit to large limit\\n            int u = q[0], v = q[1], limit = q[2], qid = q[3];\\n            for (; i < E.size() && E[i][2] < limit; ++i) uf.connect(E[i][0], E[i][1]); // visit the edges that are smaller than the limit\\n            ans[qid] = uf.connected(u, v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465024,
                "title": "day-394-custom-union-find-100-0ms-python-java-c-explained-approach",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n![image.png](https://assets.leetcode.com/users/images/a2267944-10b8-41f2-b624-81a67ccea163_1680148646.205976.png)\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### \\u2022\\tproblem is to determine if there is a path between two nodes in an undirected graph such that each edge on the path has a distance strictly less than a given limit.\\n##### \\u2022\\tThe input consists of the number of nodes, the edge list, and the queries.\\n##### \\u2022\\tThe edge list is an array of arrays, where each sub-array represents an edge between two nodes and the distance between them.\\n##### \\u2022\\tThe queries are an array of arrays, where each sub-array represents a query with two nodes and a limit.\\n##### \\u2022\\tThe using the union-find algorithm to determine if there is a path between two nodes.\\n##### \\u2022\\tThe union-find algorithm is used to group nodes into connected components.\\n##### \\u2022\\tFirst sorts the edges in the edge list by their distance in ascending order.\\n##### \\u2022 Then iterates over the sorted edges and performs a union operation on the nodes connected by the edge.\\n##### \\u2022\\tThe union operation updates the parent and rank arrays to group the nodes into connected components.\\n##### \\u2022\\tThen iterates over the queries and checks if the two nodes are connected and if the distance between them is less than the given limit.\\n##### \\u2022\\tThe isConnectedAndWithinLimit method uses the find method to determine if the two nodes are connected and if the distance between them is less than the given limit.\\n##### \\u2022\\tThe find method uses the parent and weight arrays to find the root of the connected component and checks if the weight of the edge is less than the given limit.\\n##### \\u2022\\tThe union method updates the parent, rank, and weight arrays to group the nodes into connected components and store the weight of the edge.\\n##### \\u2022\\tfinally returns a boolean array where each element represents if there is a path between the two nodes in the corresponding query with edges less than the given limit.\\n\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] weight;\\n    public boolean[] distanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        // Initialize parent, rank, and weight arrays\\n        parent = new int[length];\\n        rank = new int[length];\\n        weight = new int[length];\\n        for (int i = 0; i < length ; i++) parent[i] = i;\\n\\n        // Sort edges in the adjacency list by distance\\n        Arrays.sort(adjList, Comparator.comparingInt(a -> a[2]));\\n        // Group nodes into connected components using union-find algorithm\\n        for (int[] edge : adjList) unionByRank(edge[0], edge[1], edge[2]);\\n\\n        // Initialize answer array\\n        boolean[] answer = new boolean[queries.length];\\n        // Check if there is a path between two nodes with distance less than the given limit for each query\\n        for (int i = 0 ; i < queries.length; i++)\\n            answer[i] = isConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n\\n    // Check if there is a path between two nodes with distance less than the given limit\\n    public boolean isConnectedAndWithinLimit(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    // Find the root of the connected component for a node with distance less than the given limit\\n    private int find (int x, int limit) {\\n        while (x != parent[x]) {\\n            // If the weight of the edge is greater than or equal to the given limit, break out of the loop\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    // Union two nodes into the same connected component with the given limit as the weight of the edge\\n    private void unionByRank (int x, int y, int limit) {\\n        // Find the root of the connected component for each node\\n        int x_ref = find (x, Integer.MAX_VALUE);\\n        int y_ref = find (y, Integer.MAX_VALUE);\\n        if (x_ref != y_ref) {\\n            // If the rank of the root of x is less than the rank of the root of y, make y the parent of x\\n            if (rank[x_ref] < rank[y_ref]) {\\n                parent[x_ref] = y_ref;\\n                weight [x_ref] = limit;;\\n            } else {\\n                // Otherwise, make x the parent of y\\n                parent[y_ref] = x_ref;\\n                weight[y_ref] = limit;\\n                // If the ranks of the roots are equal, increment the rank of the root of x\\n                if (rank[x_ref] == rank[y_ref]) {\\n                    rank[x_ref]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def distanceLimitedPathsExist(self, length: int, adjList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parent = [i for i in range(length)]\\n        rank = [0 for i in range(length)]\\n        weight = [0 for i in range(length)]\\n\\n        adjList.sort(key=lambda x: x[2])\\n        for edge in adjList:\\n            self.unionByRank(edge[0], edge[1], edge[2], parent, rank, weight)\\n\\n        answer = []\\n        for query in queries:\\n            answer.append(self.isConnectedAndWithinLimit(query[0], query[1], query[2], parent, weight))\\n\\n        return answer\\n\\n    def isConnectedAndWithinLimit(self, p: int, q: int, limit: int, parent: List[int], weight: List[int]) -> bool:\\n        return self.find(p, limit, parent, weight) == self.find(q, limit, parent, weight)\\n\\n    def find(self, x: int, limit: int, parent: List[int], weight: List[int]) -> int:\\n        while x != parent[x]:\\n            if weight[x] >= limit:\\n                break\\n            x = parent[x]\\n        return x\\n\\n    def unionByRank(self, x: int, y: int, limit: int, parent: List[int], rank: List[int], weight: List[int]) -> None:\\n        x_ref = self.find(x, float(\\'inf\\'), parent, weight)\\n        y_ref = self.find(y, float(\\'inf\\'), parent, weight)\\n        if x_ref != y_ref:\\n            if rank[x_ref] < rank[y_ref]:\\n                parent[x_ref] = y_ref\\n                weight[x_ref] = limit\\n            else:\\n                parent[y_ref] = x_ref\\n                weight[y_ref] = limit\\n                if rank[x_ref] == rank[y_ref]:\\n                    rank[x_ref] += 1\\n```\\n\\n```c++ []\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int length, vector<vector<int>>& adjList, vector<vector<int>>& queries) {\\n        vector<int> parent(length);\\n        vector<int> rank(length);\\n        vector<int> weight(length);\\n        for (int i = 0; i < length ; i++) parent[i] = i;\\n\\n        sort(adjList.begin(), adjList.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        for (vector<int>& edge : adjList) unionByRank(edge[0], edge[1], edge[2], parent, rank, weight);\\n\\n        vector<bool> answer;\\n        for (vector<int>& query : queries)\\n            answer.push_back(isConnectedAndWithinLimit(query[0], query[1], query[2], parent, weight));\\n\\n        return answer;\\n    }\\n\\n    bool isConnectedAndWithinLimit(int p, int q, int limit, vector<int>& parent, vector<int>& weight) {\\n        return find(p, limit, parent, weight) == find(q, limit, parent, weight);\\n    }\\n\\n    int find(int x, int limit, vector<int>& parent, vector<int>& weight) {\\n        while (x != parent[x]) {\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    void unionByRank(int x, int y, int limit, vector<int>& parent, vector<int>& rank, vector<int>& weight) {\\n        int x_ref = find(x, INT_MAX, parent, weight);\\n        int y_ref = find(y, INT_MAX, parent, weight);\\n        if (x_ref != y_ref) {\\n            if (rank[x_ref] < rank[y_ref]) {\\n                parent[x_ref] = y_ref;\\n                weight[x_ref] = limit;\\n            } else {\\n                parent[y_ref] = x_ref;\\n                weight[y_ref] = limit;\\n                if (rank[x_ref] == rank[y_ref]) {\\n                    rank[x_ref]++;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n```csharp []\\npublic class Solution {\\n public bool[] DistanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        int[] parent = Enumerable.Range(0, length).ToArray();\\n        int[] rank = new int[length];\\n        int[] weight = new int[length];\\n\\n        Array.Sort(adjList, (a, b) => a[2].CompareTo(b[2]));\\n        foreach (int[] edge in adjList) {\\n            Union(edge[0], edge[1], edge[2], parent, rank, weight);\\n        }\\n\\n        bool[] answer = new bool[queries.Length];\\n        for (int i = 0; i < queries.Length; i++) {\\n            answer[i] = IsConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2], parent, weight);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private bool IsConnectedAndWithinLimit(int p, int q, int limit, int[] parent, int[] weight) {\\n        return Find(p, limit, parent, weight) == Find(q, limit, parent, weight);\\n    }\\n\\n    private int Find(int x, int limit, int[] parent, int[] weight) {\\n        while (x != parent[x]) {\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    private void Union(int x, int y, int limit, int[] parent, int[] rank, int[] weight) {\\n        int xRef = Find(x, int.MaxValue, parent, weight);\\n        int yRef = Find(y, int.MaxValue, parent, weight);\\n        if (xRef == yRef) {\\n            return;\\n        }\\n        if (rank[xRef] < rank[yRef]) {\\n            parent[xRef] = yRef;\\n            weight[xRef] = limit;\\n        } else {\\n            parent[yRef] = xRef;\\n            weight[yRef] = limit;\\n            if (rank[xRef] == rank[yRef]) {\\n                rank[xRef]++;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n# 2nd  union by size \\n\\n```java []\\nclass Solution {\\n    private int[] parent;\\n    private int[] size;\\n    private int[] weight;\\n    public boolean[] distanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        // Initialize parent, size, and weight arrays\\n        parent = new int[length];\\n        size = new int[length];\\n        weight = new int[length];\\n        for (int i = 0; i < length ; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n\\n        // Sort edges in the adjacency list by distance\\n        Arrays.sort(adjList, Comparator.comparingInt(a -> a[2]));\\n        // Group nodes into connected components using union-find algorithm\\n        for (int[] edge : adjList) unionBySize(edge[0], edge[1], edge[2]);\\n\\n        // Initialize answer array\\n        boolean[] answer = new boolean[queries.length];\\n        // Check if there is a path between two nodes with distance less than the given limit for each query\\n        for (int i = 0 ; i < queries.length; i++)\\n            answer[i] = isConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n\\n    // Check if there is a path between two nodes with distance less than the given limit\\n    public boolean isConnectedAndWithinLimit(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    // Find the root of the connected component for a node with distance less than the given limit\\n    private int find (int x, int limit) {\\n        while (x != parent[x]) {\\n            // If the weight of the edge is greater than or equal to the given limit, break out of the loop\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    // Union two nodes into the same connected component with the given limit as the weight of the edge\\n    private void unionBySize (int x, int y, int limit) {\\n        // Find the root of the connected component for each node\\n        int x_ref = find (x, Integer.MAX_VALUE);\\n        int y_ref = find (y, Integer.MAX_VALUE);\\n        if (x_ref != y_ref) {\\n        // If the size of the root of x is less than the size of the root of y, make y the parent of x\\n        if (size[x_ref] < size[y_ref]) {\\n            parent[x_ref] = y_ref;\\n            weight [x_ref] = limit;\\n            size[y_ref] += size[x_ref];\\n        } else {\\n            // Otherwise, make x the parent of y\\n            parent[y_ref] = x_ref;\\n            weight[y_ref] = limit;\\n            size[x_ref] += size[y_ref];\\n          }\\n        }\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity:\\nSorting the adjacency list takes O(E log E) time, where E is the number of edges in the graph.\\nThe union-find algorithm takes O(E \\u03B1(V)) time, where \\u03B1 is the inverse Ackermann function and V is the number of vertices in the graph. In practice, \\u03B1(V) is a very small value, so we can consider the time complexity to be O(E).\\nChecking if there is a path between two nodes with distance less than the given limit takes O(log V) time, where V is the number of vertices in the graph.\\nWe perform this check for each query, so the total time complexity for all queries is O(Q log V), where Q is the number of queries.\\nTherefore, the overall time complexity of the algorithm is O(E log E + Q log V).\\n- Space Complexity:\\nWe use three arrays of size V to store the parent, rank, and weight of each node in the graph, so the space complexity is O(V).\\nWe also use a boolean array of size Q to store the answer for each query, so the space complexity is O(Q).\\nTherefore, the overall space complexity of the algorithm is O(V + Q).\\n\\n\\n# dry run \\nFor the first: Input: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nOutput: [false,true]\\n\\n\\nWe have 3 nodes and the following edges: (0,1) with weight 2, (1,2) with weight 4, (2,0) with weight 8, and (1,0) with weight 16.\\nWe have 2 queries: (0,1) with limit 2 and (0,2) with limit 5.\\nWe initialize the parent, rank, and weight arrays to [0, 1, 2] and [0, 0, 0].\\nWe sort the edges in the adjacency list by distance: (0,1) with weight 2, (1,2) with weight 4, (2,0) with weight 8, and (1,0) with weight 16.\\nWe group the nodes into connected components using the union-find algorithm. First, we union nodes 0 and 1 with weight 2, then we union nodes 1 and 2 with weight 4, and finally we union nodes 2 and 0 with weight 8. The resulting parent array is [0, 0, 0].\\nFor the first query (0,1) with limit 2, we check if there is a path between nodes 0 and 1 with distance less than 2. We find the root of node 0 with limit 2, which is 0, and the root of node 1 with limit 2, which is 0. Since the roots are the same, we return true.\\nFor the second query (0,2) with limit 5, we check if there is a path between nodes 0 and 2 with distance less than 5. We find the root of node 0 with limit 5, which is 0, and the root of node 2 with limit 5, which is 0. Since the roots are the same, we return true.\\nTherefore, the output is [false, true].\\n\\nFor the second input:\\nInput: n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]\\nOutput: [true,false]\\n\\nWe have 5 nodes and the following edges: (0,1) with weight 10, (1,2) with weight 5, (2,3) with weight 9, and (3,4) with weight 13.\\nWe have 2 queries: (0,4) with limit 14 and (1,4) with limit 13.\\nWe initialize the parent, rank, and weight arrays to [0, 1, 2, 3, 4] and [0, 0, 0, 0, 0].\\nWe sort the edges in the adjacency list by distance: (1,2) with weight 5, (0,1) with weight 10, (2,3) with weight 9, and (3,4) with weight 13.\\nWe group the nodes into connected components using the union-find algorithm. First, we union nodes 1 and 2 with weight 5, then we union nodes 0 and 1 with weight 10, then we union nodes 2 and 3 with weight 9, and finally we union nodes 3 and 4 with weight 13. The resulting parent array is [0, 0, 0, 2, 3].\\nFor the first query (0,4) with limit 14, we check if there is a path between nodes 0 and 4 with distance less than 14. We find the root of node 0 with limit 14, which is 0, and the root of node 4 with limit 14, which is 3. Since the roots are not the same, we return false.\\nFor the second query (1,4) with limit 13, we check if there is a path between nodes 1 and 4 with distance less than 13. We find the root of node 1 with limit 13, which is 0, and the root of node 4 with limit 13, which is 3. Since the roots are the same, we return true.\\nTherefore, the output is [true, false].\\n\\n\\n# FAQ \\n\\n# Why we want to merge the smaller tree into the larger tree?\\n\\nIn the Union-Find algorithm, the rank array is used to keep of the depth of each node in the tree. When performing the union operation, we want to merge the smaller tree into the larger tree to keep the depth of the tree as small as possible. This helps to improve the performance of the  find operation, which is used to determine the root of the tree.\\n\\nIf we always merge the smaller tree into the larger tree, we can ensure that the depth of the tree does not increase significantly. This is because the depth of the tree is proportional to the logarithm of the number of nodes in the tree. By keeping the depth of the tree small, we can ensure that the find operation runs in O(log n) time, where n is the number of nodes in the tree.\\n\\nThe rank array is used to keep track of the depth of each node in the tree. When we merge two trees, we compare the  rank of the root nodes of the two trees. If the rank of the root node of the first tree is less than the rank of the root node of the second tree, we make the root node of the first tree a child of the root node of the second tree. Otherwise, we make the root node of the second tree a child of the root node of the first tree. If the rank of the root nodes is the same, we arbitrarily choose one of the root nodes to be the parent and increment its rank by one.\\n\\nBy always merging the smaller tree into the larger tree, we can ensure that the depth of the tree does not increase significantly, which helps to improve the performance of the find operation.\\n\\n# How Path Compression will work in the Union-Find.\\n\\nPath is a technique used in the Union-Find algorithm to improve the performance the find operation The find operation is used to determine the root of the tree that a node belongs to. In the basic implementation of the Union-Find algorithm, the find operation traverses the tree from the node to the root to determine the root of the tree. This can take O(log n) time in the worst case, where n is the number of nodes in the tree.\\n\\nPath compression is a technique that can be used to reduce the depth of the tree during the find operation. When we perform the find operation on a node, we traverse the tree from the node to the root to determine the root of the tree. During this traversal, we can update the parent of each node along the path to the root to be the root itself. This can be done recursively or iteratively.\\n\\nBy updating the parent of each node along the path to the root to be the root itself, we can reduce the depth of the tree. This can help to improve the performance of the find operation, as subsequent find operations on the same node or its descendants will take less time.\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nhttps://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solutions/3465024/day-394-union-find-100-0ms-python-java-c-explained-approach/\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C#"
                ],
                "code": "```java []\\nclass Solution {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] weight;\\n    public boolean[] distanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        // Initialize parent, rank, and weight arrays\\n        parent = new int[length];\\n        rank = new int[length];\\n        weight = new int[length];\\n        for (int i = 0; i < length ; i++) parent[i] = i;\\n\\n        // Sort edges in the adjacency list by distance\\n        Arrays.sort(adjList, Comparator.comparingInt(a -> a[2]));\\n        // Group nodes into connected components using union-find algorithm\\n        for (int[] edge : adjList) unionByRank(edge[0], edge[1], edge[2]);\\n\\n        // Initialize answer array\\n        boolean[] answer = new boolean[queries.length];\\n        // Check if there is a path between two nodes with distance less than the given limit for each query\\n        for (int i = 0 ; i < queries.length; i++)\\n            answer[i] = isConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n\\n    // Check if there is a path between two nodes with distance less than the given limit\\n    public boolean isConnectedAndWithinLimit(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    // Find the root of the connected component for a node with distance less than the given limit\\n    private int find (int x, int limit) {\\n        while (x != parent[x]) {\\n            // If the weight of the edge is greater than or equal to the given limit, break out of the loop\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    // Union two nodes into the same connected component with the given limit as the weight of the edge\\n    private void unionByRank (int x, int y, int limit) {\\n        // Find the root of the connected component for each node\\n        int x_ref = find (x, Integer.MAX_VALUE);\\n        int y_ref = find (y, Integer.MAX_VALUE);\\n        if (x_ref != y_ref) {\\n            // If the rank of the root of x is less than the rank of the root of y, make y the parent of x\\n            if (rank[x_ref] < rank[y_ref]) {\\n                parent[x_ref] = y_ref;\\n                weight [x_ref] = limit;;\\n            } else {\\n                // Otherwise, make x the parent of y\\n                parent[y_ref] = x_ref;\\n                weight[y_ref] = limit;\\n                // If the ranks of the roots are equal, increment the rank of the root of x\\n                if (rank[x_ref] == rank[y_ref]) {\\n                    rank[x_ref]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def distanceLimitedPathsExist(self, length: int, adjList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parent = [i for i in range(length)]\\n        rank = [0 for i in range(length)]\\n        weight = [0 for i in range(length)]\\n\\n        adjList.sort(key=lambda x: x[2])\\n        for edge in adjList:\\n            self.unionByRank(edge[0], edge[1], edge[2], parent, rank, weight)\\n\\n        answer = []\\n        for query in queries:\\n            answer.append(self.isConnectedAndWithinLimit(query[0], query[1], query[2], parent, weight))\\n\\n        return answer\\n\\n    def isConnectedAndWithinLimit(self, p: int, q: int, limit: int, parent: List[int], weight: List[int]) -> bool:\\n        return self.find(p, limit, parent, weight) == self.find(q, limit, parent, weight)\\n\\n    def find(self, x: int, limit: int, parent: List[int], weight: List[int]) -> int:\\n        while x != parent[x]:\\n            if weight[x] >= limit:\\n                break\\n            x = parent[x]\\n        return x\\n\\n    def unionByRank(self, x: int, y: int, limit: int, parent: List[int], rank: List[int], weight: List[int]) -> None:\\n        x_ref = self.find(x, float(\\'inf\\'), parent, weight)\\n        y_ref = self.find(y, float(\\'inf\\'), parent, weight)\\n        if x_ref != y_ref:\\n            if rank[x_ref] < rank[y_ref]:\\n                parent[x_ref] = y_ref\\n                weight[x_ref] = limit\\n            else:\\n                parent[y_ref] = x_ref\\n                weight[y_ref] = limit\\n                if rank[x_ref] == rank[y_ref]:\\n                    rank[x_ref] += 1\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int length, vector<vector<int>>& adjList, vector<vector<int>>& queries) {\\n        vector<int> parent(length);\\n        vector<int> rank(length);\\n        vector<int> weight(length);\\n        for (int i = 0; i < length ; i++) parent[i] = i;\\n\\n        sort(adjList.begin(), adjList.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[2] < b[2];\\n        });\\n        for (vector<int>& edge : adjList) unionByRank(edge[0], edge[1], edge[2], parent, rank, weight);\\n\\n        vector<bool> answer;\\n        for (vector<int>& query : queries)\\n            answer.push_back(isConnectedAndWithinLimit(query[0], query[1], query[2], parent, weight));\\n\\n        return answer;\\n    }\\n\\n    bool isConnectedAndWithinLimit(int p, int q, int limit, vector<int>& parent, vector<int>& weight) {\\n        return find(p, limit, parent, weight) == find(q, limit, parent, weight);\\n    }\\n\\n    int find(int x, int limit, vector<int>& parent, vector<int>& weight) {\\n        while (x != parent[x]) {\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    void unionByRank(int x, int y, int limit, vector<int>& parent, vector<int>& rank, vector<int>& weight) {\\n        int x_ref = find(x, INT_MAX, parent, weight);\\n        int y_ref = find(y, INT_MAX, parent, weight);\\n        if (x_ref != y_ref) {\\n            if (rank[x_ref] < rank[y_ref]) {\\n                parent[x_ref] = y_ref;\\n                weight[x_ref] = limit;\\n            } else {\\n                parent[y_ref] = x_ref;\\n                weight[y_ref] = limit;\\n                if (rank[x_ref] == rank[y_ref]) {\\n                    rank[x_ref]++;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```csharp []\\npublic class Solution {\\n public bool[] DistanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        int[] parent = Enumerable.Range(0, length).ToArray();\\n        int[] rank = new int[length];\\n        int[] weight = new int[length];\\n\\n        Array.Sort(adjList, (a, b) => a[2].CompareTo(b[2]));\\n        foreach (int[] edge in adjList) {\\n            Union(edge[0], edge[1], edge[2], parent, rank, weight);\\n        }\\n\\n        bool[] answer = new bool[queries.Length];\\n        for (int i = 0; i < queries.Length; i++) {\\n            answer[i] = IsConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2], parent, weight);\\n        }\\n\\n        return answer;\\n    }\\n\\n    private bool IsConnectedAndWithinLimit(int p, int q, int limit, int[] parent, int[] weight) {\\n        return Find(p, limit, parent, weight) == Find(q, limit, parent, weight);\\n    }\\n\\n    private int Find(int x, int limit, int[] parent, int[] weight) {\\n        while (x != parent[x]) {\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    private void Union(int x, int y, int limit, int[] parent, int[] rank, int[] weight) {\\n        int xRef = Find(x, int.MaxValue, parent, weight);\\n        int yRef = Find(y, int.MaxValue, parent, weight);\\n        if (xRef == yRef) {\\n            return;\\n        }\\n        if (rank[xRef] < rank[yRef]) {\\n            parent[xRef] = yRef;\\n            weight[xRef] = limit;\\n        } else {\\n            parent[yRef] = xRef;\\n            weight[yRef] = limit;\\n            if (rank[xRef] == rank[yRef]) {\\n                rank[xRef]++;\\n            }\\n        }\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    private int[] parent;\\n    private int[] size;\\n    private int[] weight;\\n    public boolean[] distanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        // Initialize parent, size, and weight arrays\\n        parent = new int[length];\\n        size = new int[length];\\n        weight = new int[length];\\n        for (int i = 0; i < length ; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n\\n        // Sort edges in the adjacency list by distance\\n        Arrays.sort(adjList, Comparator.comparingInt(a -> a[2]));\\n        // Group nodes into connected components using union-find algorithm\\n        for (int[] edge : adjList) unionBySize(edge[0], edge[1], edge[2]);\\n\\n        // Initialize answer array\\n        boolean[] answer = new boolean[queries.length];\\n        // Check if there is a path between two nodes with distance less than the given limit for each query\\n        for (int i = 0 ; i < queries.length; i++)\\n            answer[i] = isConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n\\n    // Check if there is a path between two nodes with distance less than the given limit\\n    public boolean isConnectedAndWithinLimit(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    // Find the root of the connected component for a node with distance less than the given limit\\n    private int find (int x, int limit) {\\n        while (x != parent[x]) {\\n            // If the weight of the edge is greater than or equal to the given limit, break out of the loop\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    // Union two nodes into the same connected component with the given limit as the weight of the edge\\n    private void unionBySize (int x, int y, int limit) {\\n        // Find the root of the connected component for each node\\n        int x_ref = find (x, Integer.MAX_VALUE);\\n        int y_ref = find (y, Integer.MAX_VALUE);\\n        if (x_ref != y_ref) {\\n        // If the size of the root of x is less than the size of the root of y, make y the parent of x\\n        if (size[x_ref] < size[y_ref]) {\\n            parent[x_ref] = y_ref;\\n            weight [x_ref] = limit;\\n            size[y_ref] += size[x_ref];\\n        } else {\\n            // Otherwise, make x the parent of y\\n            parent[y_ref] = x_ref;\\n            weight[y_ref] = limit;\\n            size[x_ref] += size[y_ref];\\n          }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978702,
                "title": "c-union-find-and-multimap",
                "content": "Did not see it... tried modified Floyd Warshall - too slow - and then BFS - faster but still too slow.\\n\\nThe key observation is that we can process queries in any order - e.g. from smallest to largest distance. When processing a query, we can use all edges with smaller distances. When processing the next query, we can add more edges, and so on.\\n\\nDisjoined set structure allows tracking connected sub-sets and joining them efficiently. \\n\\n```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& qs) {\\n    multimap<int, array<int, 3>> mm;\\n    for (auto i = 0; i < qs.size(); ++i)\\n        mm.insert({qs[i][2], {qs[i][0], qs[i][1], i}});\\n    sort(begin(edges), end(edges), [](vector<int> &a, vector<int> &b) { return a[2] < b[2]; });\\n    vector<int> ds(n, -1);\\n    vector<bool> res(qs.size());\\n    int ei = 0;\\n    for (auto &q : mm) {\\n        while (ei < edges.size() && edges[ei][2] < q.first) {\\n            int i = find(ds, edges[ei][0]), j = find(ds, edges[ei][1]);\\n            if (i != j) {\\n                if (ds[i] > ds[j])\\n                    swap(i, j);\\n                ds[i] += ds[j];\\n                ds[j] = i;\\n            }\\n            ++ei;\\n        }\\n        res[q.second[2]] = find(ds, q.second[0]) == find(ds, q.second[1]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint find(vector<int> &ds, int i) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& qs) {\\n    multimap<int, array<int, 3>> mm;\\n    for (auto i = 0; i < qs.size(); ++i)\\n        mm.insert({qs[i][2], {qs[i][0], qs[i][1], i}});\\n    sort(begin(edges), end(edges), [](vector<int> &a, vector<int> &b) { return a[2] < b[2]; });\\n    vector<int> ds(n, -1);\\n    vector<bool> res(qs.size());\\n    int ei = 0;\\n    for (auto &q : mm) {\\n        while (ei < edges.size() && edges[ei][2] < q.first) {\\n            int i = find(ds, edges[ei][0]), j = find(ds, edges[ei][1]);\\n            if (i != j) {\\n                if (ds[i] > ds[j])\\n                    swap(i, j);\\n                ds[i] += ds[j];\\n                ds[j] = i;\\n            }\\n            ++ei;\\n        }\\n        res[q.second[2]] = find(ds, q.second[0]) == find(ds, q.second[1]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978655,
                "title": "clean-java",
                "content": "after sort edge, query by weight, we constract UnionFind from small to large\\nwe use extra query[3] to save original index(position)\\n```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int M = edgeList.length, N = queries.length;\\n        DSU dsu = new DSU(n);\\n        for (int i = 0; i < queries.length; i++) \\n            queries[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i}; \\n        Arrays.sort(queries, (a, b) -> a[2] - b[2]);\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        boolean[] res = new boolean[N];\\n        for (int i = 0, j = 0; i < N; i++) {\\n            int[] query = queries[i];\\n            while (j < M && edgeList[j][2] < queries[i][2])\\n                dsu.union(edgeList[j][0], edgeList[j++][1]);\\n            res[queries[i][3]] = dsu.find(queries[i][0]) == dsu.find(queries[i][1]);\\n        }\\n        return res;\\n    }\\n}\\n\\nclass DSU {\\n    int[] parent;\\n    public DSU(int N) {\\n        this.parent = new int[N];\\n        for (int i = 0; i < N; i++) parent[i] = i;\\n    }\\n    public int find(int x) {\\n        if (parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    public void union(int x, int y) {\\n        parent[find(x)] = parent[find(y)];\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int M = edgeList.length, N = queries.length;\\n        DSU dsu = new DSU(n);\\n        for (int i = 0; i < queries.length; i++) \\n            queries[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i}; \\n        Arrays.sort(queries, (a, b) -> a[2] - b[2]);\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        boolean[] res = new boolean[N];\\n        for (int i = 0, j = 0; i < N; i++) {\\n            int[] query = queries[i];\\n            while (j < M && edgeList[j][2] < queries[i][2])\\n                dsu.union(edgeList[j][0], edgeList[j++][1]);\\n            res[queries[i][3]] = dsu.find(queries[i][0]) == dsu.find(queries[i][1]);\\n        }\\n        return res;\\n    }\\n}\\n\\nclass DSU {\\n    int[] parent;\\n    public DSU(int N) {\\n        this.parent = new int[N];\\n        for (int i = 0; i < N; i++) parent[i] = i;\\n    }\\n    public int find(int x) {\\n        if (parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    public void union(int x, int y) {\\n        parent[find(x)] = parent[find(y)];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192227,
                "title": "java-clean-union-find-solution-with-detailed-comments",
                "content": "This great question utilize the power of **Union-Find** which enables \"constant\" time query. The tricks are actually pretty straightforward: \\n\\n1. sort both queries by increasing weight\\n2. sort edges by increasing weight\\n3. for each query, union all edges whose weight is less than this query\\n4. check if two nodes in query belongs to the same group\\n\\nThis idea is pretty important (yet not unique). We may utilize similar tricks in these problems:\\n* [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/discuss/1192238/xieyun95)\\n* [1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value/)\\n\\n\\n\\n```\\nclass Solution {\\n    private int[] parents;\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        this.parents = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        \\n        int m = queries.length;\\n        \\n        // storing {u, v, weight, original idx} by increasing weight\\n        int[][] sortedQueries = new int[m][4];\\n        for (int i = 0; i < m; i++) {\\n            sortedQueries[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i};\\n        }\\n        Arrays.sort(sortedQueries, (a,b) -> a[2] - b[2]);\\n        \\n        \\n        // sort edgeList by increasing weight \\n        Arrays.sort(edgeList, (a,b) -> a[2] - b[2]);\\n        int idx = 0;\\n        \\n        boolean[] res = new boolean[m];\\n        \\n        for (int i = 0; i < m; i++) {\\n            int[] q = sortedQueries[i];\\n            int w = q[2];\\n            \\n            // union all edges with weight less than current query\\n            while (idx < edgeList.length && edgeList[idx][2] < w) {\\n                int[] e = edgeList[idx++];\\n                int u = e[0], v = e[1];\\n                union(u, v);\\n            }\\n            \\n            int uQuery = q[0], vQuery = q[1], id = q[3];\\n            res[id] = (find(uQuery) == find(vQuery));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void union(int u, int v) {\\n        int uParent = find(u);\\n        int vParent = find(v);\\n        parents[uParent] = vParent;\\n    }\\n    \\n    private int find(int u) {\\n        while (u != parents[u]) {\\n            parents[u] = parents[parents[u]];\\n            u = parents[u];\\n        }\\n        return u;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    private int[] parents;\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        this.parents = new int[n];\\n        for (int i = 0; i < n; i++) parents[i] = i;\\n        \\n        int m = queries.length;\\n        \\n        // storing {u, v, weight, original idx} by increasing weight\\n        int[][] sortedQueries = new int[m][4];\\n        for (int i = 0; i < m; i++) {\\n            sortedQueries[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i};\\n        }\\n        Arrays.sort(sortedQueries, (a,b) -> a[2] - b[2]);\\n        \\n        \\n        // sort edgeList by increasing weight \\n        Arrays.sort(edgeList, (a,b) -> a[2] - b[2]);\\n        int idx = 0;\\n        \\n        boolean[] res = new boolean[m];\\n        \\n        for (int i = 0; i < m; i++) {\\n            int[] q = sortedQueries[i];\\n            int w = q[2];\\n            \\n            // union all edges with weight less than current query\\n            while (idx < edgeList.length && edgeList[idx][2] < w) {\\n                int[] e = edgeList[idx++];\\n                int u = e[0], v = e[1];\\n                union(u, v);\\n            }\\n            \\n            int uQuery = q[0], vQuery = q[1], id = q[3];\\n            res[id] = (find(uQuery) == find(vQuery));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void union(int u, int v) {\\n        int uParent = find(u);\\n        int vParent = find(v);\\n        parents[uParent] = vParent;\\n    }\\n    \\n    private int find(int u) {\\n        while (u != parents[u]) {\\n            parents[u] = parents[parents[u]];\\n            u = parents[u];\\n        }\\n        return u;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981266,
                "title": "6-lines-with-unicode-find",
                "content": "Accepted in 5064 ms. As long as LeetCode lets me, I\\'m gonna use Unicode-Find every single time :-P\\n```\\ndef distanceLimitedPathsExist(self, n, E, Q):\\n    s = \\'\\'.join(map(chr, range(n)))\\n    *map(list.append, Q, count()),\\n    for u, v, d, *j in sorted(Q + E, key=itemgetter(2)):\\n        if j: Q[j[0]] = s[u] == s[v]\\n        else: s = s.replace(s[u], s[v])\\n    return Q\\n```\\n(This is Python3, I just didn\\'t like the look of the long cluttered original function signature.)\\n\\nNo need to merge the sorted edges and queries on our own, we can just put the queries first and rely on Timsort\\'s stability. I annotate the queries with their index, both to distinguish them from the edges and to know where to write their results.\\n\\nLOL, my results are *off the charts*. Literally. On opposite ends! My *time* of 5064 ms is off the time distribution chart\\'s *right* end of about 3800 ms, and my *memory usage* of 53.1 MB is off the memory distribution\\'s *left* end of 60.0 MB. Well, a string is a very compact data structure.\\n![image](https://assets.leetcode.com/users/images/2c1ca99d-8aa7-4210-a9b4-b5fd2774ba84_1608616494.9549015.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef distanceLimitedPathsExist(self, n, E, Q):\\n    s = \\'\\'.join(map(chr, range(n)))\\n    *map(list.append, Q, count()),\\n    for u, v, d, *j in sorted(Q + E, key=itemgetter(2)):\\n        if j: Q[j[0]] = s[u] == s[v]\\n        else: s = s.replace(s[u], s[v])\\n    return Q\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3464857,
                "title": "easy-solution-of-java-c-beginner-friendly-with-comments",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    // union find\\n    // sort both edgeList and queries in increasing order of dist and limit, respectively\\n    // two loops:\\n    // outer loop: for each query, if limit increases, than check to see if there is more edges that\\n    // can be added\\n    // inner loop: if dis is less than the new limit, add the edge\\n\\n    // Runtime is bound by sorting: O(ElogE + NlogN + N + E);\\n    int[] up;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        up = new int[n];\\n        Arrays.fill(up, -1);\\n        \\n        boolean[] res = new boolean[queries.length];\\n        Arrays.sort(edgeList, new arrComparator());\\n        \\n        \\n        int[][] temp = new int[queries.length][4];\\n        for (int i = 0; i < temp.length; i++) {\\n            temp[i][0] = queries[i][0];\\n            temp[i][1] = queries[i][1];\\n            temp[i][2] = queries[i][2];\\n            temp[i][3] = i;\\n        }\\n        queries = temp;\\n        Arrays.sort(queries, new arrComparator());\\n        \\n        int limit = 0;\\n        int j = 0;\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] q = queries[i];\\n            if (q[2] > limit) {\\n                limit = q[2];\\n                while (j < edgeList.length && edgeList[j][2] < limit) {\\n                    int x = edgeList[j][0];\\n                    int y = edgeList[j][1];\\n                    if (find(x) != find(y)) union(find(x), find(y));\\n                    j++;\\n                }\\n            }\\n            res[q[3]] = find(q[0]) == find(q[1]);\\n        }\\n        return res;\\n    }\\n    \\n    private int find(int x) {\\n        int r = x;\\n        while (up[r] >= 0) {\\n            r = up[r];\\n        }\\n        \\n        if (r == x) return r;\\n        \\n        int p = up[x];\\n        while (p >= 0) {\\n            up[x] = r;\\n            x = p;\\n            p = up[x];\\n        }\\n        return r;\\n    }\\n    \\n    private void union(int x, int y) {\\n        if (up[x] > up[y]) {\\n            up[y] += up[x];\\n            up[x] = y;\\n        } else {\\n            up[x] += up[y];\\n            up[y] = x;\\n        }\\n    }\\n    \\n    class arrComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return a[2] - b[2];\\n        } \\n    }\\n}\\n```\\nC++\\n```\\nclass DSUnode{\\n    public:\\n    int parent,rank;\\n    DSUnode(int parent,int rank){\\n        this->parent=parent;\\n        this->rank=rank;\\n    }\\n};\\nclass DSU{\\n    private:\\n    vector<DSUnode>parents;\\n    void _merge(int parent,int child){\\n        this->parents[child].parent=parent;\\n        this->parents[parent].rank+=this->parents[child].rank;\\n    }\\n    int _find(int x){\\n        while(this->parents[x].parent!=x){\\n            x=this->parents[x].parent;\\n        }\\n        return x;\\n    }\\n    public:\\n    DSU(int n){\\n        for(int i=0;i<n;i++){\\n            DSUnode element(i,1);\\n            this->parents.push_back(element);\\n        }\\n    }\\n    void findUnion(int x,int y){\\n        int parx=this->_find(x);\\n        int pary=this->_find(y);\\n        if(parx!=pary){\\n            if(this->parents[parx].rank>=this->parents[pary].rank){\\n                this->_merge(parx,pary);\\n            } else {\\n                this->_merge(pary,parx);\\n            }\\n        }\\n    }\\n    bool isConnected(int start,int end){\\n        return this->_find(start)==this->_find(end);\\n    }\\n};\\nclass Solution {\\nprivate:\\n    int determineEnd(vector<int>&weights,int limit){\\n        int end=lower_bound(weights.begin(),weights.end(),limit)-weights.begin();\\n        return end==weights.size()?end:end-1;\\n    }\\n    bool solve(DSU &dsu,int qs,int qe,int &start,int end,vector<vector<int>>&edges){\\n        if(dsu.isConnected(qs,qe)){\\n            return true;\\n        } else {\\n            while(start<=end){\\n                int s=edges[start][0];\\n                int e=edges[start][1];\\n                dsu.findUnion(s,e);\\n                if(dsu.isConnected(qs,qe)){\\n                    return true;\\n                }\\n                start++;\\n            }\\n            return false;\\n        }\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),[](vector<int>&e1,vector<int>&e2){\\n            return e1[2]<e2[2];\\n        });\\n        sort(queries.begin(),queries.end(),[](vector<int>&q1,vector<int>&q2){\\n            return q1[2]<q2[2];\\n        });\\n        vector<int>weights;\\n        for(vector<int>edge:edges){\\n            weights.push_back(edge[2]);\\n        }\\n        vector<bool>ans(queries.size(),true);\\n        int start=0;\\n        for(vector<int>query:queries){\\n            int qs=query[0];\\n            int qe=query[1];\\n            int limit=query[2];\\n            int index=query[3];\\n            int end=determineEnd(weights,limit);\\n            ans[index]=solve(dsu,qs,qe,start,end,edges);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    // union find\\n    // sort both edgeList and queries in increasing order of dist and limit, respectively\\n    // two loops:\\n    // outer loop: for each query, if limit increases, than check to see if there is more edges that\\n    // can be added\\n    // inner loop: if dis is less than the new limit, add the edge\\n\\n    // Runtime is bound by sorting: O(ElogE + NlogN + N + E);\\n    int[] up;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        up = new int[n];\\n        Arrays.fill(up, -1);\\n        \\n        boolean[] res = new boolean[queries.length];\\n        Arrays.sort(edgeList, new arrComparator());\\n        \\n        \\n        int[][] temp = new int[queries.length][4];\\n        for (int i = 0; i < temp.length; i++) {\\n            temp[i][0] = queries[i][0];\\n            temp[i][1] = queries[i][1];\\n            temp[i][2] = queries[i][2];\\n            temp[i][3] = i;\\n        }\\n        queries = temp;\\n        Arrays.sort(queries, new arrComparator());\\n        \\n        int limit = 0;\\n        int j = 0;\\n        for (int i = 0; i < queries.length; i++) {\\n            int[] q = queries[i];\\n            if (q[2] > limit) {\\n                limit = q[2];\\n                while (j < edgeList.length && edgeList[j][2] < limit) {\\n                    int x = edgeList[j][0];\\n                    int y = edgeList[j][1];\\n                    if (find(x) != find(y)) union(find(x), find(y));\\n                    j++;\\n                }\\n            }\\n            res[q[3]] = find(q[0]) == find(q[1]);\\n        }\\n        return res;\\n    }\\n    \\n    private int find(int x) {\\n        int r = x;\\n        while (up[r] >= 0) {\\n            r = up[r];\\n        }\\n        \\n        if (r == x) return r;\\n        \\n        int p = up[x];\\n        while (p >= 0) {\\n            up[x] = r;\\n            x = p;\\n            p = up[x];\\n        }\\n        return r;\\n    }\\n    \\n    private void union(int x, int y) {\\n        if (up[x] > up[y]) {\\n            up[y] += up[x];\\n            up[x] = y;\\n        } else {\\n            up[x] += up[y];\\n            up[y] = x;\\n        }\\n    }\\n    \\n    class arrComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return a[2] - b[2];\\n        } \\n    }\\n}\\n```\n```\\nclass DSUnode{\\n    public:\\n    int parent,rank;\\n    DSUnode(int parent,int rank){\\n        this->parent=parent;\\n        this->rank=rank;\\n    }\\n};\\nclass DSU{\\n    private:\\n    vector<DSUnode>parents;\\n    void _merge(int parent,int child){\\n        this->parents[child].parent=parent;\\n        this->parents[parent].rank+=this->parents[child].rank;\\n    }\\n    int _find(int x){\\n        while(this->parents[x].parent!=x){\\n            x=this->parents[x].parent;\\n        }\\n        return x;\\n    }\\n    public:\\n    DSU(int n){\\n        for(int i=0;i<n;i++){\\n            DSUnode element(i,1);\\n            this->parents.push_back(element);\\n        }\\n    }\\n    void findUnion(int x,int y){\\n        int parx=this->_find(x);\\n        int pary=this->_find(y);\\n        if(parx!=pary){\\n            if(this->parents[parx].rank>=this->parents[pary].rank){\\n                this->_merge(parx,pary);\\n            } else {\\n                this->_merge(pary,parx);\\n            }\\n        }\\n    }\\n    bool isConnected(int start,int end){\\n        return this->_find(start)==this->_find(end);\\n    }\\n};\\nclass Solution {\\nprivate:\\n    int determineEnd(vector<int>&weights,int limit){\\n        int end=lower_bound(weights.begin(),weights.end(),limit)-weights.begin();\\n        return end==weights.size()?end:end-1;\\n    }\\n    bool solve(DSU &dsu,int qs,int qe,int &start,int end,vector<vector<int>>&edges){\\n        if(dsu.isConnected(qs,qe)){\\n            return true;\\n        } else {\\n            while(start<=end){\\n                int s=edges[start][0];\\n                int e=edges[start][1];\\n                dsu.findUnion(s,e);\\n                if(dsu.isConnected(qs,qe)){\\n                    return true;\\n                }\\n                start++;\\n            }\\n            return false;\\n        }\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(edges.begin(),edges.end(),[](vector<int>&e1,vector<int>&e2){\\n            return e1[2]<e2[2];\\n        });\\n        sort(queries.begin(),queries.end(),[](vector<int>&q1,vector<int>&q2){\\n            return q1[2]<q2[2];\\n        });\\n        vector<int>weights;\\n        for(vector<int>edge:edges){\\n            weights.push_back(edge[2]);\\n        }\\n        vector<bool>ans(queries.size(),true);\\n        int start=0;\\n        for(vector<int>query:queries){\\n            int qs=query[0];\\n            int qe=query[1];\\n            int limit=query[2];\\n            int index=query[3];\\n            int end=determineEnd(weights,limit);\\n            ans[index]=solve(dsu,qs,qe,start,end,edges);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234460,
                "title": "c-disjoin-set-union",
                "content": "This question is so far one of the best problem of DSU. \\n\\n**How to identify DSU?** \\nWell, in questions where we are asked to reach one node from another, or where we need to attach nodes or form components of similiar types, we go with DSU. In DSU questions, most of the time, we are not given any extra conditions on the path, like shortest, longest, etc. We just need to find if we could reach from one node to another. \\n\\n**What to do after identifying?**\\nThe only two functions in DSU are `join(Node1, Node2)`, to join two nodes, and `find(Node)` to find the godfather of the component to which `Node` belongs.\\nNow we can use `Rank` to optimize the join function and `path-compression` to optimize the find function. I\\'ve use path-compression only. \\n\\n**How to approach this question?**\\nIn this question, we are given queries and edges. Now, in questions where we have to use DSU, we dont actually need to form the graph, we just have to join two nodes whose parents are not same. \\nIn this problem, if we sort the queries and edges array based limits, then we would be able to use the precomputed answer. \\n**How?** After sorting both of the arrays based on limits, for each query, we can loop in the edges vector and for each pair of node whose dist < limit, we can join them together. Joining them signifies that for the given limit, there exists a path between those two nodes which has all the edges < curr_limit.\\n\\n\\n```\\nvector <int> parent(100005,-1);\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        for(int i = 0; i<=n; i++) parent[i] = i;\\n        \\n\\t\\t// Sorting the edges array based on dist of each pair of node. \\n        sort(edges.begin(),edges.end(),[](vector<int>&a, vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n\\n\\t\\t// We will need the indices of query elements coz after sorting, the order will change. \\n\\t\\t// So we push the index in the same element vector of query.\\n        for(int i = 0; i<queries.size(); i++) queries[i].push_back(i);\\n\\t\\t\\t\\n\\t\\t// Sorting queries based on limits. \\n        sort(queries.begin(),queries.end(),[](vector<int>&a,vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n        \\n        vector <bool> ans(queries.size(),false);\\n        int idx = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            // Here we loop on edges vector and join the two nodes having dist < curr_limit.\\n\\t\\t\\twhile(idx<edges.size() and edges[idx][2]<queries[i][2]){\\n                join(edges[idx][0],edges[idx][1]);\\n                idx++;\\n            }\\n\\t\\t\\t// If the two nodes of current query has same godfather, we set this queries ans as true\\n            if(find(parent[queries[i][0]]) == find(parent[queries[i][1]])) ans[queries[i][3]] = true;\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void join(int a, int b){\\n        a = find(a);\\n        b = find(b);\\n        \\n        if(a!=b) parent[b] = a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nvector <int> parent(100005,-1);\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        for(int i = 0; i<=n; i++) parent[i] = i;\\n        \\n\\t\\t// Sorting the edges array based on dist of each pair of node. \\n        sort(edges.begin(),edges.end(),[](vector<int>&a, vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n\\n\\t\\t// We will need the indices of query elements coz after sorting, the order will change. \\n\\t\\t// So we push the index in the same element vector of query.\\n        for(int i = 0; i<queries.size(); i++) queries[i].push_back(i);\\n\\t\\t\\t\\n\\t\\t// Sorting queries based on limits. \\n        sort(queries.begin(),queries.end(),[](vector<int>&a,vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n        \\n        vector <bool> ans(queries.size(),false);\\n        int idx = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            // Here we loop on edges vector and join the two nodes having dist < curr_limit.\\n\\t\\t\\twhile(idx<edges.size() and edges[idx][2]<queries[i][2]){\\n                join(edges[idx][0],edges[idx][1]);\\n                idx++;\\n            }\\n\\t\\t\\t// If the two nodes of current query has same godfather, we set this queries ans as true\\n            if(find(parent[queries[i][0]]) == find(parent[queries[i][1]])) ans[queries[i][3]] = true;\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void join(int a, int b){\\n        a = find(a);\\n        b = find(b);\\n        \\n        if(a!=b) parent[b] = a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978449,
                "title": "c-solution-with-disjoint-set-two-pointers-o-nlogn",
                "content": "```\\nclass disjoint_set {\\npublic:\\n\\tvector<int> R;\\n\\tdisjoint_set(int n) : R(n) { iota(R.begin(), R.end(), 0); }\\n\\tint find(int i) { return R[i] == i ? i : R[i] = find(R[i]); }\\n\\tbool join(int i, int j) { i = find(i); j = find(j); if (i == j) return false; R[i] = j; return true; }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& el, vector<vector<int>>& qs) {\\n        disjoint_set ds(n);\\n        sort(el.begin(), el.end(), [](auto &a, auto &b){return a[2] < b[2];});\\n\\n        vector<int> idx(qs.size()); // index sorting instead of data sorting\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](int a, int b){return qs[a][2] < qs[b][2];});\\n\\n        int x = 0;\\n        vector<bool> ans(qs.size());\\n        for (auto &i : idx) {\\n            for (; x < el.size() && el[x][2] < qs[i][2]; x++)\\n                ds.join(el[x][0], el[x][1]);\\n            ans[i] = ds.find(qs[i][0]) == ds.find(qs[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass disjoint_set {\\npublic:\\n\\tvector<int> R;\\n\\tdisjoint_set(int n) : R(n) { iota(R.begin(), R.end(), 0); }\\n\\tint find(int i) { return R[i] == i ? i : R[i] = find(R[i]); }\\n\\tbool join(int i, int j) { i = find(i); j = find(j); if (i == j) return false; R[i] = j; return true; }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& el, vector<vector<int>>& qs) {\\n        disjoint_set ds(n);\\n        sort(el.begin(), el.end(), [](auto &a, auto &b){return a[2] < b[2];});\\n\\n        vector<int> idx(qs.size()); // index sorting instead of data sorting\\n        iota(idx.begin(), idx.end(), 0);\\n        sort(idx.begin(), idx.end(), [&](int a, int b){return qs[a][2] < qs[b][2];});\\n\\n        int x = 0;\\n        vector<bool> ans(qs.size());\\n        for (auto &i : idx) {\\n            for (; x < el.size() && el[x][2] < qs[i][2]; x++)\\n                ds.join(el[x][0], el[x][1]);\\n            ans[i] = ds.find(qs[i][0]) == ds.find(qs[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465314,
                "title": "java-dfs-approach-just-for-understanding",
                "content": "```\\n// Approach 1: Depth First Search - TLE\\n\\n// Time complexity: O(n\\xB2)\\n// Space complexity: O(n\\xB2)\\t\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        Map<Integer, List<Pair<Integer, Integer>>> adj = new HashMap<>();\\n        \\n        for (int[] edge : edgeList) {\\n            adj.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(new Pair(edge[1], edge[2]));\\n            adj.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(new Pair(edge[0], edge[2]));\\n        }\\n        \\n        boolean[] answer = new boolean[queries.length];\\n        int i = 0;\\n        \\n        for (int[] query : queries) {\\n            boolean[] visited = new boolean[n];\\n            answer[i++] = dfs(adj, query[0], query[1], query[2], visited); \\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private boolean dfs(Map<Integer, List<Pair<Integer, Integer>>> adj, int curr, int dest, int limit, boolean[] visited) {\\n        if (curr == dest)\\n            return true;\\n        \\n        visited[curr] = true;\\n        \\n        if (!adj.containsKey(curr))\\n            return false;\\n        \\n        for (Pair<Integer, Integer> next : adj.get(curr)) {\\n            if (!visited[next.getKey()] && next.getValue() < limit) {\\n                if (dfs(adj, next.getKey(), dest, limit, visited))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n**Note:-** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Approach 1: Depth First Search - TLE\\n\\n// Time complexity: O(n\\xB2)\\n// Space complexity: O(n\\xB2)\\t\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        Map<Integer, List<Pair<Integer, Integer>>> adj = new HashMap<>();\\n        \\n        for (int[] edge : edgeList) {\\n            adj.computeIfAbsent(edge[0], k -> new ArrayList<>()).add(new Pair(edge[1], edge[2]));\\n            adj.computeIfAbsent(edge[1], k -> new ArrayList<>()).add(new Pair(edge[0], edge[2]));\\n        }\\n        \\n        boolean[] answer = new boolean[queries.length];\\n        int i = 0;\\n        \\n        for (int[] query : queries) {\\n            boolean[] visited = new boolean[n];\\n            answer[i++] = dfs(adj, query[0], query[1], query[2], visited); \\n        }\\n        \\n        return answer;\\n    }\\n    \\n    private boolean dfs(Map<Integer, List<Pair<Integer, Integer>>> adj, int curr, int dest, int limit, boolean[] visited) {\\n        if (curr == dest)\\n            return true;\\n        \\n        visited[curr] = true;\\n        \\n        if (!adj.containsKey(curr))\\n            return false;\\n        \\n        for (Pair<Integer, Integer> next : adj.get(curr)) {\\n            if (!visited[next.getKey()] && next.getValue() < limit) {\\n                if (dfs(adj, next.getKey(), dest, limit, visited))\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978509,
                "title": "java-sort-and-then-union-find-disjoint-set",
                "content": "The idea is to sort the queries/edges by distance, then build up a disjoint set with edges allowed for the current query and so on.\\n\\nRuntime is O(q log(q)) + O(e log(e))\\n\\n```\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    // DISJOINT SET\\n\\n    Map<int[], Integer> original = new IdentityHashMap<>();\\n    for (int i = 0; i < queries.length; i++) {\\n      original.put(queries[i], i);\\n    }\\n    \\n    \\n    // start with smaller queries then union allowed edges and so on\\n    parent = IntStream.rangeClosed(0, n).toArray();\\n\\n    Map<Integer, Boolean> result = new HashMap<>();\\n    Arrays.sort(queries, Comparator.comparingInt(a -> a[2]));\\n    Arrays.sort(edgeList, Comparator.comparingInt(a -> a[2]));\\n    int qI = 0;\\n    int eI = 0;\\n    for (; qI < queries.length; qI++){\\n      int[] query = queries[qI];\\n      while (eI < edgeList.length && edgeList[eI][2] < query[2]){\\n        union(edgeList[eI][0], edgeList[eI][1]);\\n        eI++;\\n      }\\n      result.put(qI, find(query[0]) == find(query[1]));\\n    }\\n\\n\\n    boolean[] r= new boolean[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n      r[original.get(queries[i])] = result.get(i);\\n    }\\n    return r;\\n\\n  }\\n  \\n  private int[] parent;\\n\\n  private void union(int a, int b) {\\n    parent[find(a)] = find(b);\\n  }\\n\\n  private int find(int a) {\\n    if (a != parent[a]) {\\n      parent[a] = find(parent[a]);\\n    }\\n    return parent[a];\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    // DISJOINT SET\\n\\n    Map<int[], Integer> original = new IdentityHashMap<>();\\n    for (int i = 0; i < queries.length; i++) {\\n      original.put(queries[i], i);\\n    }\\n    \\n    \\n    // start with smaller queries then union allowed edges and so on\\n    parent = IntStream.rangeClosed(0, n).toArray();\\n\\n    Map<Integer, Boolean> result = new HashMap<>();\\n    Arrays.sort(queries, Comparator.comparingInt(a -> a[2]));\\n    Arrays.sort(edgeList, Comparator.comparingInt(a -> a[2]));\\n    int qI = 0;\\n    int eI = 0;\\n    for (; qI < queries.length; qI++){\\n      int[] query = queries[qI];\\n      while (eI < edgeList.length && edgeList[eI][2] < query[2]){\\n        union(edgeList[eI][0], edgeList[eI][1]);\\n        eI++;\\n      }\\n      result.put(qI, find(query[0]) == find(query[1]));\\n    }\\n\\n\\n    boolean[] r= new boolean[queries.length];\\n    for (int i = 0; i < queries.length; i++) {\\n      r[original.get(queries[i])] = result.get(i);\\n    }\\n    return r;\\n\\n  }\\n  \\n  private int[] parent;\\n\\n  private void union(int a, int b) {\\n    parent[find(a)] = find(b);\\n  }\\n\\n  private int find(int a) {\\n    if (a != parent[a]) {\\n      parent[a] = find(parent[a]);\\n    }\\n    return parent[a];\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978504,
                "title": "python-union-find",
                "content": "Intuition:\\n\\n- Since one of the constraints is `1 <= edgeList.length, queries.length <= 10^5` so `O(N^2)` solution won\\'t pass, we need to be better than that\\n- Disjoint Set Union is a great way to find if paths exist (if two nodes are connected)\\n- To brute-force, for every query we can generate a DSU using edges smaller than the limit\\n- To avoid repeated computation, if we can rearrange the queries from smaller limit to greater limit, we can build the DSU from the smaller distances to greater ones, and generate the desired answers iteratively.\\n\\n```python\\nclass DSU:\\n    def __init__(self, N):\\n        self.root = list(range(N))\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        self.root[x] = self.root[y] = min(x, y)\\n    def connected(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        return x == y\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, N: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        Q = len(queries)\\n        E = len(edgeList)\\n        edgeList.sort(key=lambda x: x[2])\\n        dsu = DSU(N)\\n        \\n        ans = [None] * Q\\n        j = 0\\n        \\n        for l, a, b, i in sorted(((l, a, b, i) for i, (a, b, l) in enumerate(queries))):\\n            while j < E and edgeList[j][2] < l:\\n                x, y, _ = edgeList[j]\\n                dsu.union(x, y)\\n                j += 1\\n            \\n            ans[i] = dsu.connected(a, b)\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass DSU:\\n    def __init__(self, N):\\n        self.root = list(range(N))\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        self.root[x] = self.root[y] = min(x, y)\\n    def connected(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        return x == y\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, N: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        Q = len(queries)\\n        E = len(edgeList)\\n        edgeList.sort(key=lambda x: x[2])\\n        dsu = DSU(N)\\n        \\n        ans = [None] * Q\\n        j = 0\\n        \\n        for l, a, b, i in sorted(((l, a, b, i) for i, (a, b, l) in enumerate(queries))):\\n            while j < E and edgeList[j][2] < l:\\n                x, y, _ = edgeList[j]\\n                dsu.union(x, y)\\n                j += 1\\n            \\n            ans[i] = dsu.connected(a, b)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464945,
                "title": "c-disjoint-set-union",
                "content": "# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int>size;\\n    vector<int>parent;\\n    DisjointSet(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n    }\\n    \\n    int findUpar(int node){\\n        if(node==parent[node])return node;\\n\\n       return parent[node]=findUpar(parent[node]);\\n    }\\n\\n    void UnionBySize(int u,int v){\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        if(ulp_u==ulp_v)return ;\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n       \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a,vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DisjointSet ds(n);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        sort(queries.begin(),queries.end(),cmp);\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        int j=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(j<edgeList.size()&&edgeList[j][2]<queries[i][2]){\\n                ds.UnionBySize(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            if(ds.findUpar(queries[i][0])==ds.findUpar(queries[i][1])){\\n                ans[queries[i][3]]=true;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<int>size;\\n    vector<int>parent;\\n    DisjointSet(int n){\\n        size.resize(n,1);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++)parent[i]=i;\\n    }\\n    \\n    int findUpar(int node){\\n        if(node==parent[node])return node;\\n\\n       return parent[node]=findUpar(parent[node]);\\n    }\\n\\n    void UnionBySize(int u,int v){\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        if(ulp_u==ulp_v)return ;\\n        if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n       \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a,vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DisjointSet ds(n);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        sort(queries.begin(),queries.end(),cmp);\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        int j=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(j<edgeList.size()&&edgeList[j][2]<queries[i][2]){\\n                ds.UnionBySize(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            if(ds.findUpar(queries[i][0])==ds.findUpar(queries[i][1])){\\n                ans[queries[i][3]]=true;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983847,
                "title": "javascript-union-find-solution-w-explanation-100-100",
                "content": "_(**Update**: Small update to the code, streamlining the union/find process, using typed arrays for smaller overhead, and reusing_ **`queries`** _as the answer array.)_\\n\\nFor this solution, we\\'re going to implement a Union-Find approach. The Union-Find approach involves keeping track of groups of linked objects and uses three main components: a parent array (**par**) in which to keep track of the parent of each of our elements, a **find** function used to find the parent of an element, and a **union** function used to merge two groups together under one parent.\\n\\nSo first, we build our intial **par** array, making each element its own parent by mapping each element\\'s index to its value, such that **par[i] = i**.\\n\\nFor the **find** function, we want to return the ultimate parent, not simply the immediate parent, so we make it a recursive function that calls itself until it finds a parent which is its own parent. We can use this function to compress future processing time by rewriting the parent of each element along the chain to subsequently point to this ultimate parent.\\n\\nFor the **union** function, we simply **find** the parents of the two elements and make one a child to the other. (*You can use a weighting system in order to try to keep the subgroups balanced, but in this case it\\'s not really necessary; the compression in the **find** function accomplishes much the same time-saving, making a weighting system more of a hindrance than a help.*)\\n\\nWe then need to sort the edge list (**e**) so that we can process the union of only those edges below the relative limit threshold of each of the queries (**q**).\\n\\nWe also should sort **q** so that we only have to process the edges once each instead of having to reset **par** between each query. But because our answer array (**ans**) needs to be in the same order as the original **q**, we should instead create an order key array (**ord**) of mapped out indexes and then sort it based on the limit values in **q**. This way we can keep our **q** in its original order but access its elements in sorted order.\\n\\nSo now we just iterate through our ordered queries and just before checking each query we process any edge unions up to the query\\'s limit. We can use optional chaining when checking the next query\\'s limit in order to account for reaching the end of **e**.\\n\\nThen we simply **find** the parent of each query\\'s two nodes, and if they match, update the appropriate index in **ans** before finally rerturning **ans**.\\n\\n\\n```\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const par = Uint32Array.from({length: n}, (_,i) => i),\\n          find = x => x === par[x] ? x : par[x] = find(par[x]),\\n          union = (x,y) => par[find(y)] = find(x)\\n    let ord = Uint32Array.from({length: queries.length}, (_,i) => i), j = 0\\n    edgeList.sort((a,b) => a[2] - b[2])\\n    ord.sort((a,b) => queries[a][2] - queries[b][2])\\n    for (let i of ord) {\\n        let [a,b,wt] = queries[i]\\n        while (edgeList[j]?.[2] < wt)\\n            union(edgeList[j][0], edgeList[j++][1])\\n        queries[i] = find(a) === find(b)\\n    }\\n    return queries\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const par = Uint32Array.from({length: n}, (_,i) => i),\\n          find = x => x === par[x] ? x : par[x] = find(par[x]),\\n          union = (x,y) => par[find(y)] = find(x)\\n    let ord = Uint32Array.from({length: queries.length}, (_,i) => i), j = 0\\n    edgeList.sort((a,b) => a[2] - b[2])\\n    ord.sort((a,b) => queries[a][2] - queries[b][2])\\n    for (let i of ord) {\\n        let [a,b,wt] = queries[i]\\n        while (edgeList[j]?.[2] < wt)\\n            union(edgeList[j][0], edgeList[j++][1])\\n        queries[i] = find(a) === find(b)\\n    }\\n    return queries\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 978641,
                "title": "java-union-find-solution",
                "content": "The trick is to sort the queries as well so that we could reuse the `roots` array.\\n```\\nclass Solution {\\n    \\n    int curr = 0;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edges, int[][] queries) {\\n        Arrays.sort(edges, (a, b) -> (a[2] - b[2]));\\n\\t\\t// Add another column to the queries so that we know the index after sorting.\\n        int[][] qs = new int[queries.length][4];\\n        for(int i = 0; i < queries.length; i++) {\\n            qs[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i};\\n        }\\n        Arrays.sort(qs, (a, b) -> (a[2] - b[2]));\\n        boolean[] res = new boolean[queries.length];\\n        int[] roots = new int[n];\\n        for(int i = 0; i < n; i++) roots[i] = i;\\n        for(int i = 0; i < queries.length; i++) {\\n            int[] q = qs[i];\\n            res[q[3]] = helper(edges, q[0], q[1], q[2], roots);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean helper(int[][] edges, int start, int end, int limit, int[] roots) {\\n        for(int i = curr; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            if(e[2] >= limit) {\\n\\t\\t\\t\\t// \\'curr\\' is to mark until which step have we finished the union-find.\\n                curr = i;\\n                break;\\n            }\\n            int root1 = find(roots, e[0]);\\n            int root2 = find(roots, e[1]);\\n            if(root1 != root2) {\\n                roots[root1] = root2;\\n            }\\n        }\\n        return find(roots, start) == find(roots, end);\\n    }\\n    \\n    private int find(int[] roots, int i) {\\n        int j = i;\\n        while(roots[i] != i) {\\n            i = roots[i];\\n        }\\n        roots[j] = i;\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int curr = 0;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edges, int[][] queries) {\\n        Arrays.sort(edges, (a, b) -> (a[2] - b[2]));\\n\\t\\t// Add another column to the queries so that we know the index after sorting.\\n        int[][] qs = new int[queries.length][4];\\n        for(int i = 0; i < queries.length; i++) {\\n            qs[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i};\\n        }\\n        Arrays.sort(qs, (a, b) -> (a[2] - b[2]));\\n        boolean[] res = new boolean[queries.length];\\n        int[] roots = new int[n];\\n        for(int i = 0; i < n; i++) roots[i] = i;\\n        for(int i = 0; i < queries.length; i++) {\\n            int[] q = qs[i];\\n            res[q[3]] = helper(edges, q[0], q[1], q[2], roots);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean helper(int[][] edges, int start, int end, int limit, int[] roots) {\\n        for(int i = curr; i < edges.length; i++) {\\n            int[] e = edges[i];\\n            if(e[2] >= limit) {\\n\\t\\t\\t\\t// \\'curr\\' is to mark until which step have we finished the union-find.\\n                curr = i;\\n                break;\\n            }\\n            int root1 = find(roots, e[0]);\\n            int root2 = find(roots, e[1]);\\n            if(root1 != root2) {\\n                roots[root1] = root2;\\n            }\\n        }\\n        return find(roots, start) == find(roots, end);\\n    }\\n    \\n    private int find(int[] roots, int i) {\\n        int j = i;\\n        while(roots[i] != i) {\\n            i = roots[i];\\n        }\\n        roots[j] = i;\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464876,
                "title": "c-disjointset-unionfind-dsu-bonus-disjointset-implementation",
                "content": "# Approach\\n- Sort the inputs (`queries` and `edgeList`) by edge length (weight)\\n- Use a two pointer approach to union all the nodes whose edges have length  (weight) less than $$query[i]$$\\n- If there is a path between them than their parents (in DSU) are the same\\n\\n# Bonus\\n`DisjointSet` implementation which is reusable for other problems.\\n\\n# Complexity\\n- Time complexity: $$O(M \\\\times log(M) + N \\\\times log(N))$$ , where $$M$$ is the number of edges in `edgeList` and $$N$$ - the number of queries\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public class DisjointSet\\n    {\\n        private readonly int[] _parent;\\n        private readonly int[] _rank;\\n\\n        public DisjointSet(int n)\\n        {\\n            _parent = new int[n];\\n            _rank = new int[n];\\n            for (var i = 0; i < n; i++)\\n            {\\n                _parent[i] = i;\\n            }\\n        }\\n\\n        public int Find(int x)\\n        {\\n            // If `x` is the parent of itself then `x` is the representative of this set\\n            // Else we recursively call Find on its parent\\n            var xSet = _parent[x] == x ? x : Find(_parent[x]);\\n\\n            // We cache the result by moving i\\u2019s node directly under the representative of this set\\n            _parent[x] = xSet;\\n\\n            return xSet;\\n        }\\n\\n        public bool Union(int x, int y)\\n        {\\n            var xSet = Find(x);\\n            var ySet = Find(y);\\n\\n            if (xSet == ySet)\\n            {\\n                // Elements are in same set, no need to unite anything.\\n                return false;\\n            }\\n\\n            if (_rank[xSet] < _rank[ySet])\\n            {\\n                // If x\\u2019s rank is less than y\\u2019s rank then move x under y\\n                _parent[xSet] = ySet;\\n            }\\n            else if (_rank[xSet] > _rank[ySet])\\n            {\\n                // If y\\u2019s rank is less than x\\u2019s rank then move y under x\\n                _parent[xSet] = ySet;\\n            }\\n            else\\n            {\\n                // If their ranks are the same\\n                // Then move x under y (doesn\\'t matter which one goes where)\\n                _parent[xSet] = ySet;\\n\\n                // And increment the result tree\\'s rank\\n                _rank[xSet]++;\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries)\\n    {\\n       var dsu = new DisjointSet(n);\\n\\n        // Add query indices to help with ordering results\\n        for (var i = 0; i < queries.Length; i++)\\n        {\\n            queries[i] = new[] {queries[i][0], queries[i][1], queries[i][2], i};\\n        }\\n\\n        Array.Sort(queries, (a, b) => a[2] - b[2]);\\n        Array.Sort(edgeList, (a, b) => a[2] - b[2]);\\n\\n        var result = new bool[queries.Length];\\n        var j = 0;\\n\\n        foreach (var query in queries)\\n        {\\n            // Two pointer => join the edges till their weight is less than the current query\\n            for (; j < edgeList.Length && edgeList[j][2] < query[2]; ++j)\\n            {\\n                dsu.Union(edgeList[j][0], edgeList[j][1]);\\n            }\\n\\n            // If parents are the same than their is a path\\n            result[query[3]] = dsu.Find(query[0]) == dsu.Find(query[1]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public class DisjointSet\\n    {\\n        private readonly int[] _parent;\\n        private readonly int[] _rank;\\n\\n        public DisjointSet(int n)\\n        {\\n            _parent = new int[n];\\n            _rank = new int[n];\\n            for (var i = 0; i < n; i++)\\n            {\\n                _parent[i] = i;\\n            }\\n        }\\n\\n        public int Find(int x)\\n        {\\n            // If `x` is the parent of itself then `x` is the representative of this set\\n            // Else we recursively call Find on its parent\\n            var xSet = _parent[x] == x ? x : Find(_parent[x]);\\n\\n            // We cache the result by moving i\\u2019s node directly under the representative of this set\\n            _parent[x] = xSet;\\n\\n            return xSet;\\n        }\\n\\n        public bool Union(int x, int y)\\n        {\\n            var xSet = Find(x);\\n            var ySet = Find(y);\\n\\n            if (xSet == ySet)\\n            {\\n                // Elements are in same set, no need to unite anything.\\n                return false;\\n            }\\n\\n            if (_rank[xSet] < _rank[ySet])\\n            {\\n                // If x\\u2019s rank is less than y\\u2019s rank then move x under y\\n                _parent[xSet] = ySet;\\n            }\\n            else if (_rank[xSet] > _rank[ySet])\\n            {\\n                // If y\\u2019s rank is less than x\\u2019s rank then move y under x\\n                _parent[xSet] = ySet;\\n            }\\n            else\\n            {\\n                // If their ranks are the same\\n                // Then move x under y (doesn\\'t matter which one goes where)\\n                _parent[xSet] = ySet;\\n\\n                // And increment the result tree\\'s rank\\n                _rank[xSet]++;\\n            }\\n\\n            return true;\\n        }\\n    }\\n\\n    public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries)\\n    {\\n       var dsu = new DisjointSet(n);\\n\\n        // Add query indices to help with ordering results\\n        for (var i = 0; i < queries.Length; i++)\\n        {\\n            queries[i] = new[] {queries[i][0], queries[i][1], queries[i][2], i};\\n        }\\n\\n        Array.Sort(queries, (a, b) => a[2] - b[2]);\\n        Array.Sort(edgeList, (a, b) => a[2] - b[2]);\\n\\n        var result = new bool[queries.Length];\\n        var j = 0;\\n\\n        foreach (var query in queries)\\n        {\\n            // Two pointer => join the edges till their weight is less than the current query\\n            for (; j < edgeList.Length && edgeList[j][2] < query[2]; ++j)\\n            {\\n                dsu.Union(edgeList[j][0], edgeList[j][1]);\\n            }\\n\\n            // If parents are the same than their is a path\\n            result[query[3]] = dsu.Find(query[0]) == dsu.Find(query[1]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466084,
                "title": "c-solution-using-union-find-with-approach-and-comments-faster-than-95",
                "content": "# Intuition\\n### **Sort both the array weight wise and traverse until queries is smaller then edgeList**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Make a parent array and initialize it with themselves.\\n2. Make a answer array and initislize it with false.\\n3. Swap the first and third part of edgeList to sort it w.r.t weight.\\n4. Sort edgeList.\\n5. Make an array to store the weights of the queries vector and their index.\\n6. Traverse in the edgeList until its weight is greater than queries weight.\\n7. Make their parents same in the loop which has been traversed.\\n8. Outside the loop check if they have same parents means they can be traversed so make them true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dsu(vector<int>& parent,int x)\\n    {\\n        //Base case\\n        if(parent[x] == x)\\n            return x;\\n        //Else check its parent\\n        else\\n            return parent[x] = dsu(parent,parent[x]);\\n        \\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) \\n    {\\n        //A parent vector to store the parent of the elements\\n        vector<int> parent(n,-1);\\n\\n        //Answer vector to store the answer\\n        vector<bool> ans(queries.size(),false);\\n\\n        //Make every element its own parent\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        //Swap the weight index with the first index so that we can sort it by weight\\n        for(int i=0;i<edgeList.size();i++)\\n            swap(edgeList[i][0],edgeList[i][2]);\\n\\n        //Sort by Weight\\n        sort(edgeList.begin(),edgeList.end());\\n\\n        //Store the queries weight and its index\\n        vector<pair<int,int>> arr;\\n\\n        for(int i=0;i<queries.size();i++)\\n            arr.push_back({queries[i][2],i});\\n        \\n        //Sort the queries w.r.t weight\\n        sort(arr.begin(),arr.end());\\n\\n\\n        int j = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            //Traverse until query weight is greater than the edge weight\\n            while(j < edgeList.size() && edgeList[j][0] < arr[i].first)\\n            {    \\n                //Take the vertices of the edgelist\\n                int u = edgeList[j][1],v = edgeList[j][2];\\n                //Check their parents\\n                int pu = dsu(parent,u),pv = dsu(parent,v);\\n                //If not equal make them equal\\n                if(pu != pv)\\n                    parent[pu] = pv;\\n                \\n                j++;\\n            }\\n            //Take the vertices of the query \\n            int x = queries[arr[i].second][0],y = queries[arr[i].second][1];\\n            //Check their parents\\n            int px = dsu(parent,x),py = dsu(parent,y);\\n            //If parents are equal then return true\\n            if(px == py)\\n                ans[arr[i].second] = true;\\n            \\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n# Please Upvote if helps!!!!!",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dsu(vector<int>& parent,int x)\\n    {\\n        //Base case\\n        if(parent[x] == x)\\n            return x;\\n        //Else check its parent\\n        else\\n            return parent[x] = dsu(parent,parent[x]);\\n        \\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) \\n    {\\n        //A parent vector to store the parent of the elements\\n        vector<int> parent(n,-1);\\n\\n        //Answer vector to store the answer\\n        vector<bool> ans(queries.size(),false);\\n\\n        //Make every element its own parent\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        //Swap the weight index with the first index so that we can sort it by weight\\n        for(int i=0;i<edgeList.size();i++)\\n            swap(edgeList[i][0],edgeList[i][2]);\\n\\n        //Sort by Weight\\n        sort(edgeList.begin(),edgeList.end());\\n\\n        //Store the queries weight and its index\\n        vector<pair<int,int>> arr;\\n\\n        for(int i=0;i<queries.size();i++)\\n            arr.push_back({queries[i][2],i});\\n        \\n        //Sort the queries w.r.t weight\\n        sort(arr.begin(),arr.end());\\n\\n\\n        int j = 0;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            //Traverse until query weight is greater than the edge weight\\n            while(j < edgeList.size() && edgeList[j][0] < arr[i].first)\\n            {    \\n                //Take the vertices of the edgelist\\n                int u = edgeList[j][1],v = edgeList[j][2];\\n                //Check their parents\\n                int pu = dsu(parent,u),pv = dsu(parent,v);\\n                //If not equal make them equal\\n                if(pu != pv)\\n                    parent[pu] = pv;\\n                \\n                j++;\\n            }\\n            //Take the vertices of the query \\n            int x = queries[arr[i].second][0],y = queries[arr[i].second][1];\\n            //Check their parents\\n            int px = dsu(parent,x),py = dsu(parent,y);\\n            //If parents are equal then return true\\n            if(px == py)\\n                ans[arr[i].second] = true;\\n            \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464847,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        dict1, n = defaultdict(int), len(queries)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        edgeList.sort(key = lambda x: x[2])\\n\\n        i, res = 0, [False]*n\\n\\n        for limit, x, y, idx in sorted((q[2],q[0],q[1],i) for i,q in enumerate(queries)):\\n            while i < len(edgeList) and edgeList[i][2] < limit:\\n                union(edgeList[i][0],edgeList[i][1])\\n                i += 1\\n            res[idx] = find(x) == find(y)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        dict1, n = defaultdict(int), len(queries)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        edgeList.sort(key = lambda x: x[2])\\n\\n        i, res = 0, [False]*n\\n\\n        for limit, x, y, idx in sorted((q[2],q[0],q[1],i) for i,q in enumerate(queries)):\\n            while i < len(edgeList) and edgeList[i][2] < limit:\\n                union(edgeList[i][0],edgeList[i][1])\\n                i += 1\\n            res[idx] = find(x) == find(y)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054026,
                "title": "c-dsu-union-find-easy",
                "content": "We Rearrange the Queries and EdgeLists so as to kind of precompute for future queries by DSU\\n\\n# Complexity\\n- Time complexity:\\n- O(N+Q)\\n\\n- Space complexity:\\n- O(N+Q)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent,size;\\n    void make(int var)\\n    {\\n        parent[var]=var;\\n        size[var]=1;\\n        return;\\n    }\\n    int findparent(int var)\\n    {\\n        if(parent[var]==var)\\n        {\\n            return var;\\n        }\\n        parent[var]=findparent(parent[var]);\\n        return parent[var];\\n    }\\n    void Union(int var1,int var2)\\n    {\\n        var1=findparent(var1);\\n        var2=findparent(var2);\\n        if(var1==var2)\\n        {\\n            return;\\n        }\\n        if(size[var1]>size[var2])\\n        {\\n            parent[var2]=var1;\\n            size[var1]+=size[var2];\\n        }\\n        else\\n        {\\n            parent[var1]=var2;\\n            size[var2]+=size[var1];\\n        }\\n        return;\\n    }\\n    static bool comparator(vector<int>&a,vector<int>&b)\\n    {\\n        return (a[2]<=b[2]);\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n,vector<vector<int>>&edgeList,vector<vector<int>>&queries) \\n    {\\n        parent.assign(n,0);\\n        size.assign(n,0);\\n        int i=0,j=0;\\n        for(i=0;i<n;i++)\\n        {\\n            make(i);\\n        }\\n        for(i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        sort(edgeList.begin(),edgeList.end(),comparator);\\n        sort(queries.begin(),queries.end(),comparator);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            while(j<edgeList.size() && edgeList[j][2]<queries[i][2])\\n            {\\n                Union(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            parent[queries[i][0]]=findparent(queries[i][0]);\\n            parent[queries[i][1]]=findparent(queries[i][1]);\\n            ans[queries[i][3]]=(parent[queries[i][0]]==parent[queries[i][1]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent,size;\\n    void make(int var)\\n    {\\n        parent[var]=var;\\n        size[var]=1;\\n        return;\\n    }\\n    int findparent(int var)\\n    {\\n        if(parent[var]==var)\\n        {\\n            return var;\\n        }\\n        parent[var]=findparent(parent[var]);\\n        return parent[var];\\n    }\\n    void Union(int var1,int var2)\\n    {\\n        var1=findparent(var1);\\n        var2=findparent(var2);\\n        if(var1==var2)\\n        {\\n            return;\\n        }\\n        if(size[var1]>size[var2])\\n        {\\n            parent[var2]=var1;\\n            size[var1]+=size[var2];\\n        }\\n        else\\n        {\\n            parent[var1]=var2;\\n            size[var2]+=size[var1];\\n        }\\n        return;\\n    }\\n    static bool comparator(vector<int>&a,vector<int>&b)\\n    {\\n        return (a[2]<=b[2]);\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n,vector<vector<int>>&edgeList,vector<vector<int>>&queries) \\n    {\\n        parent.assign(n,0);\\n        size.assign(n,0);\\n        int i=0,j=0;\\n        for(i=0;i<n;i++)\\n        {\\n            make(i);\\n        }\\n        for(i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        sort(edgeList.begin(),edgeList.end(),comparator);\\n        sort(queries.begin(),queries.end(),comparator);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            while(j<edgeList.size() && edgeList[j][2]<queries[i][2])\\n            {\\n                Union(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            parent[queries[i][0]]=findparent(queries[i][0]);\\n            parent[queries[i][1]]=findparent(queries[i][1]);\\n            ans[queries[i][3]]=(parent[queries[i][0]]==parent[queries[i][1]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978520,
                "title": "python-c-sort-union-find",
                "content": "**Idea**\\n* Add edges to the graph from smallest to largest.\\n* Answer queries from smallest to largest.\\n* Use a [Union-Find Data Structure](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) to check connectivity.\\n\\n\\n**Python**\\n```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        q = list(sorted((limit, p, q, i) for i, (p, q, limit) in enumerate(queries)))\\n        e = deque(sorted((d, u, v) for (u, v, d) in edgeList))\\n        \\n        uf = list(range(n))\\n        \\n        def find(x):\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        def join(u, v):\\n            uf[find(u)] = find(v)\\n        \\n        def is_connected(u, v):\\n            return find(u) == find(v)\\n        \\n        ans = list(False for _ in range(len(q)))\\n        \\n        for limit, p, q, i in q:\\n            while e and e[0][0] < limit:\\n                _, u, v = e.popleft()\\n                join(u, v)\\n            ans[i] = is_connected(p, q)\\n        \\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int uf[112345];\\n    \\n    int find(int x) {\\n        return uf[x] != x ? (uf[x] = find(uf[x])) : x;\\n    }\\n    \\n    void join(int x, int y) {\\n        uf[find(x)] = find(y);\\n    }\\n    \\n    bool is_connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(\\n            int n, \\n            vector<vector<int>>& edges, \\n            vector<vector<int>>& queries) {\\n        iota(uf, uf + n, 0);\\n        \\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        \\n        auto by_weight = [](auto &a, auto &b) {\\n            return a[2] < b[2];\\n        };\\n        \\n        sort(queries.begin(), queries.end(), by_weight);\\n        sort(edges.begin(), edges.end(), by_weight);\\n        \\n        vector<bool> ans(queries.size());\\n        int j = 0;\\n        for (auto &q : queries) {\\n            for (; j < edges.size() && edges[j][2] < q[2]; j++) {\\n                join(edges[j][0], edges[j][1]);\\n            }\\n            ans[q[3]] = is_connected(q[0], q[1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        q = list(sorted((limit, p, q, i) for i, (p, q, limit) in enumerate(queries)))\\n        e = deque(sorted((d, u, v) for (u, v, d) in edgeList))\\n        \\n        uf = list(range(n))\\n        \\n        def find(x):\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        def join(u, v):\\n            uf[find(u)] = find(v)\\n        \\n        def is_connected(u, v):\\n            return find(u) == find(v)\\n        \\n        ans = list(False for _ in range(len(q)))\\n        \\n        for limit, p, q, i in q:\\n            while e and e[0][0] < limit:\\n                _, u, v = e.popleft()\\n                join(u, v)\\n            ans[i] = is_connected(p, q)\\n        \\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int uf[112345];\\n    \\n    int find(int x) {\\n        return uf[x] != x ? (uf[x] = find(uf[x])) : x;\\n    }\\n    \\n    void join(int x, int y) {\\n        uf[find(x)] = find(y);\\n    }\\n    \\n    bool is_connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(\\n            int n, \\n            vector<vector<int>>& edges, \\n            vector<vector<int>>& queries) {\\n        iota(uf, uf + n, 0);\\n        \\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        \\n        auto by_weight = [](auto &a, auto &b) {\\n            return a[2] < b[2];\\n        };\\n        \\n        sort(queries.begin(), queries.end(), by_weight);\\n        sort(edges.begin(), edges.end(), by_weight);\\n        \\n        vector<bool> ans(queries.size());\\n        int j = 0;\\n        for (auto &q : queries) {\\n            for (; j < edges.size() && edges[j][2] < q[2]; j++) {\\n                join(edges[j][0], edges[j][1]);\\n            }\\n            ans[q[3]] = is_connected(q[0], q[1]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978454,
                "title": "c-solution-with-union-find-sort",
                "content": "```\\n public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n\\n        public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries)\\n        {\\n            bool[] res = new bool[queries.Length];\\n            (int idx, int[] q)[] qData = new (int idx, int[] q)[queries.Length];\\n\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                qData[i] = (i, queries[i]);\\n            }\\n\\n            //sort edges by length\\n            Array.Sort(edgeList, (e1, e2) => e1[2].CompareTo(e2[2]));\\n            //sort queries by limit\\n            Array.Sort(qData, (q1, q2) => q1.q[2].CompareTo(q2.q[2]));\\n            Unions dsu = new Unions(n);\\n\\n            int edIdx = 0;\\n\\n            for (int i = 0; i < qData.Length; i++)\\n            {\\n                //add edges accodring to current limit\\n                while (edIdx < edgeList.Length && edgeList[edIdx][2] < qData[i].q[2])\\n                {\\n                    dsu.Union(edgeList[edIdx][0], edgeList[edIdx][1]);\\n                    edIdx++;\\n                }\\n\\n                res[qData[i].idx] = (dsu.Find(qData[i].q[0]) == dsu.Find(qData[i].q[1]));\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n public class Solution\\n    {\\n        private class Unions\\n        {\\n            private readonly int[] _parents;\\n            private readonly int[] _ranks;\\n\\n            public Unions(int n)\\n            {\\n                _parents = new int[n];\\n                _ranks = new int[n];\\n                for (int i = 0; i < n; i++)\\n                {\\n                    _parents[i] = i;\\n                }\\n            }\\n\\n            public int Find(int x)\\n            {\\n                if (x != _parents[x])\\n                {\\n                    x = Find(_parents[x]);\\n                }\\n                return _parents[x];\\n            }\\n\\n            public bool Union(int x, int y)\\n            {\\n                int px = Find(x);\\n                int py = Find(y);\\n                if (px == py)\\n                {\\n                    return false;\\n                }\\n                if (_ranks[px] > _ranks[py])\\n                {\\n                    _parents[py] = px;\\n                    _ranks[px]++;\\n                }\\n                else\\n                {\\n                    _parents[px] = py;\\n                    _ranks[py]++;\\n                }\\n                return true;\\n            }\\n        }\\n\\n\\n        public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries)\\n        {\\n            bool[] res = new bool[queries.Length];\\n            (int idx, int[] q)[] qData = new (int idx, int[] q)[queries.Length];\\n\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                qData[i] = (i, queries[i]);\\n            }\\n\\n            //sort edges by length\\n            Array.Sort(edgeList, (e1, e2) => e1[2].CompareTo(e2[2]));\\n            //sort queries by limit\\n            Array.Sort(qData, (q1, q2) => q1.q[2].CompareTo(q2.q[2]));\\n            Unions dsu = new Unions(n);\\n\\n            int edIdx = 0;\\n\\n            for (int i = 0; i < qData.Length; i++)\\n            {\\n                //add edges accodring to current limit\\n                while (edIdx < edgeList.Length && edgeList[edIdx][2] < qData[i].q[2])\\n                {\\n                    dsu.Union(edgeList[edIdx][0], edgeList[edIdx][1]);\\n                    edIdx++;\\n                }\\n\\n                res[qData[i].idx] = (dsu.Find(qData[i].q[0]) == dsu.Find(qData[i].q[1]));\\n            }\\n\\n            return res;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481123,
                "title": "dsu-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn queries we have to find if there is a path from u to v such that maximum edgewt is less that limit.This can be done through dsu . \\nBut again we can\\'t make graph for each queries , so we will reuse the graph made earlier through dsu. for this we will sort the queries on the basis of limit. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\nclass DisjointSet\\n{\\npublic:\\n    vector<int> size, parent;\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n    int findUPar(int node)\\n    {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v)\\n    {\\n        int ulp_u = findUPar(u), ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v)\\n            return;\\n        if (size[ulp_u] >= size[ulp_v])\\n        {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n        else if (size[ulp_u] < size[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n    }\\n};\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<vector<int>> edges;\\n        DisjointSet ds(n);\\n        for(auto it:edgeList)\\n        {\\n            int u=it[0],v=it[1],wt=it[2];\\n            edges.push_back({wt,u,v});\\n        }\\n        sort(edges.begin(),edges.end());\\n        vector<vector<int>> q;\\n        int i=0;\\n        for(auto it:queries)\\n        {\\n            int u=it[0],v=it[1],wt=it[2];\\n            q.push_back({wt,u,v,i++});\\n        }\\n      \\n       \\n        sort(q.begin(),q.end());\\n         i=0;\\n        vector<bool> ans(q.size());\\n        for(auto it:q)\\n        {\\n            int wt=it[0],u=it[1],v=it[2],ind =it[3];\\n           // cout<<wt<<\" \\\\n\";\\n            while(i<edges.size())\\n            {\\n                int dst=edges[i][0],x=edges[i][1],y=edges[i][2];\\n                if(dst>=wt)\\n                break;\\n               // cout<<wt<<\" \"<<dst<<endl;\\n                ds.unionBySize(x,y);\\n                i++;\\n            }\\n            if(ds.findUPar(u)==ds.findUPar(v))\\n            ans[ind]=1;\\n            else\\n            ans[ind]=0;\\n\\n        }\\n           return ans;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\nclass DisjointSet\\n{\\npublic:\\n    vector<int> size, parent;\\n    DisjointSet(int n)\\n    {\\n        size.resize(n + 1, 1);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++)\\n        {\\n            parent[i] = i;\\n        }\\n    }\\n    int findUPar(int node)\\n    {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionBySize(int u, int v)\\n    {\\n        int ulp_u = findUPar(u), ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v)\\n            return;\\n        if (size[ulp_u] >= size[ulp_v])\\n        {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n        else if (size[ulp_u] < size[ulp_v])\\n        {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n    }\\n};\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<vector<int>> edges;\\n        DisjointSet ds(n);\\n        for(auto it:edgeList)\\n        {\\n            int u=it[0],v=it[1],wt=it[2];\\n            edges.push_back({wt,u,v});\\n        }\\n        sort(edges.begin(),edges.end());\\n        vector<vector<int>> q;\\n        int i=0;\\n        for(auto it:queries)\\n        {\\n            int u=it[0],v=it[1],wt=it[2];\\n            q.push_back({wt,u,v,i++});\\n        }\\n      \\n       \\n        sort(q.begin(),q.end());\\n         i=0;\\n        vector<bool> ans(q.size());\\n        for(auto it:q)\\n        {\\n            int wt=it[0],u=it[1],v=it[2],ind =it[3];\\n           // cout<<wt<<\" \\\\n\";\\n            while(i<edges.size())\\n            {\\n                int dst=edges[i][0],x=edges[i][1],y=edges[i][2];\\n                if(dst>=wt)\\n                break;\\n               // cout<<wt<<\" \"<<dst<<endl;\\n                ds.unionBySize(x,y);\\n                i++;\\n            }\\n            if(ds.findUPar(u)==ds.findUPar(v))\\n            ans[ind]=1;\\n            else\\n            ans[ind]=0;\\n\\n        }\\n           return ans;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3465574,
                "title": "c-simpledsu-w-detailed-explanation-commented-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\n1) We can apply BFS or DFS to find answer from moving one node\\nto anothoer node. Obviously, traversing it queries number of time may \\nlead to TLE.\\n2) Instead of that we can apply DSU (Disjoint set Union) and why DSU ?\\n3) In question we have to tell for each query that whether we are \\nable to reach from one node to anthor node in less than limit value\\nwhen we are given edges with distance values.\\n4) So, for every queries[limit] value, we will try to find path in\\nedges array that less than this limit value, how many nodes are \\nwe able to travel.\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\n5) Finally we will see that if in less than this limit we are able \\nto make a group of nodes we can travel. \\n6) If in this group both queries node also present than we answer \\nwill be true for this index elsewise false.\\n7) Now, why first: We will sort the edges array \\nas will as the queries array.\\n8) See, we will creating groups of nodes with the help of DSU that\\nless than this limit value we are able to reach this number of nodes.\\nIf we will sort the queries array on the basis of limit value then for\\nith query limit we already know that less than this limit value,\\nwe already group nodes, so by moving in increasing order we don\\'t\\nneed to create group again. There is much probaility that for covering\\ncurrent ith value limit, maybe two of the nodes ask in queries already\\ncovered with much less value and if it that, we already cover them \\nin a group. \\n9) Sorting edges array on the basis of weight help us in \\nmoving linear increasing order as per by the queries limit values.\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nTime Complexity: O(n + q + szlogsz + qlogq + (sz + q) + n),\\nsz: size of edges, q: size of queries\\n\\nwhere 1) n: no of nodes (intially making each node as parent of itslef)\\n      2) q: holding up the exact/original indices for each query\\n      3) szlogsz: sorting the edges array\\n      4) qlogq: sorting the queries array \\n      5) (sz + q): worst case for each query limit value \\n        there is only one edge array\\n      6) n: recursive find function used to find parent\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nSpace Complexity: O(n + n + q) \\n       1) defining parent array of size n\\n       2) anthor n (recursive stack space used to find parent)\\n       3) anthor q, to store answer\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n// find function which is used to find parent of a node\\n    int find(int node, vector<int>& parent)\\n    {\\n        // if node is parent of itself return here\\n        if(node == parent[node])\\n            return node;\\n        \\n        // else go on in finding actual parent\\n        return parent[node] = find(parent[node], parent);\\n    }\\n    \\n    // union funtion to merge parents of two nodes\\n    void Union(int node0, int node1, vector<int>& parent)\\n    {\\n        int par0 = find(node0, parent); // find parent of node zero\\n        int par1 = find(node1, parent); // find parent of node one\\n        \\n        // if values of parents of node zero and one are equal \\n        // then we will return true from here\\n        if(par0 == par1)\\n            return;\\n        \\n        // make parent of one anothoer (parent[par1] = par0, also valid)\\n        parent[par0] = par1;\\n    }\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int q = queries.size(); // defining size of queries array\\n        int sz = edges.size(); // defining size of edges array \\n\\n        // Intiliaze parent array, which will take care of parent of every node\\n        vector<int> parent(n, 0); \\n\\n        // intially make parent of everyone itself\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n\\n        // sort edges on the basis of distance weight\\n        sort(edges.begin(), edges.end(), [&](vector<int>& edge1, vector<int>& edge2){\\n            return edge1[2] < edge2[2];\\n        });\\n\\n        // keep track of original indices\\n        for(int i = 0; i < q; i++) queries[i].push_back(i);\\n        \\n        // sort queries on the basis of weight\\n        sort(queries.begin(), queries.end(), [&](vector<int>& query1,vector<int>& query2) {\\n            \\n            return query1[2] < query2[2];\\n        });\\n\\n        // declare answer array of size q, intially everything false\\n        vector<bool> ans(q, false);\\n        int edgeMoment = 0; // pointer to move in edges array\\n\\n        // now, for each query we will calculate answer\\n        for(int eachQuery = 0; eachQuery < q; eachQuery++) {\\n            int currQueryWeight = queries[eachQuery][2]; // currentWeight in queries\\n            \\n            // move in edges till edge distane weight less than currQueryWeight \\n            // and map parents\\n            while(edgeMoment < sz && edges[edgeMoment][2] < currQueryWeight)\\n            Union(edges[edgeMoment][0], edges[edgeMoment][1], parent), edgeMoment++;\\n\\n            // if for this currQueryWeight, queries nodes found in same group,\\n            // put answer true\\n            if(find(queries[eachQuery][0], parent) == \\n            find(queries[eachQuery][1], parent))  {\\n\\n                ans[queries[eachQuery][3]] = true;\\n            }\\n        }\\n        \\n        // finally, return ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n1) We can apply BFS or DFS to find answer from moving one node\\nto anothoer node. Obviously, traversing it queries number of time may \\nlead to TLE.\\n2) Instead of that we can apply DSU (Disjoint set Union) and why DSU ?\\n3) In question we have to tell for each query that whether we are \\nable to reach from one node to anthor node in less than limit value\\nwhen we are given edges with distance values.\\n4) So, for every queries[limit] value, we will try to find path in\\nedges array that less than this limit value, how many nodes are \\nwe able to travel.\\n```\n```\\n5) Finally we will see that if in less than this limit we are able \\nto make a group of nodes we can travel. \\n6) If in this group both queries node also present than we answer \\nwill be true for this index elsewise false.\\n7) Now, why first: We will sort the edges array \\nas will as the queries array.\\n8) See, we will creating groups of nodes with the help of DSU that\\nless than this limit value we are able to reach this number of nodes.\\nIf we will sort the queries array on the basis of limit value then for\\nith query limit we already know that less than this limit value,\\nwe already group nodes, so by moving in increasing order we don\\'t\\nneed to create group again. There is much probaility that for covering\\ncurrent ith value limit, maybe two of the nodes ask in queries already\\ncovered with much less value and if it that, we already cover them \\nin a group. \\n9) Sorting edges array on the basis of weight help us in \\nmoving linear increasing order as per by the queries limit values.\\n```\n```\\nTime Complexity: O(n + q + szlogsz + qlogq + (sz + q) + n),\\nsz: size of edges, q: size of queries\\n\\nwhere 1) n: no of nodes (intially making each node as parent of itslef)\\n      2) q: holding up the exact/original indices for each query\\n      3) szlogsz: sorting the edges array\\n      4) qlogq: sorting the queries array \\n      5) (sz + q): worst case for each query limit value \\n        there is only one edge array\\n      6) n: recursive find function used to find parent\\n```\n```\\nSpace Complexity: O(n + n + q) \\n       1) defining parent array of size n\\n       2) anthor n (recursive stack space used to find parent)\\n       3) anthor q, to store answer\\n```\n```\\nclass Solution {\\npublic:\\n// find function which is used to find parent of a node\\n    int find(int node, vector<int>& parent)\\n    {\\n        // if node is parent of itself return here\\n        if(node == parent[node])\\n            return node;\\n        \\n        // else go on in finding actual parent\\n        return parent[node] = find(parent[node], parent);\\n    }\\n    \\n    // union funtion to merge parents of two nodes\\n    void Union(int node0, int node1, vector<int>& parent)\\n    {\\n        int par0 = find(node0, parent); // find parent of node zero\\n        int par1 = find(node1, parent); // find parent of node one\\n        \\n        // if values of parents of node zero and one are equal \\n        // then we will return true from here\\n        if(par0 == par1)\\n            return;\\n        \\n        // make parent of one anothoer (parent[par1] = par0, also valid)\\n        parent[par0] = par1;\\n    }\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int q = queries.size(); // defining size of queries array\\n        int sz = edges.size(); // defining size of edges array \\n\\n        // Intiliaze parent array, which will take care of parent of every node\\n        vector<int> parent(n, 0); \\n\\n        // intially make parent of everyone itself\\n        for(int i = 0; i < n; i++) parent[i] = i;\\n\\n        // sort edges on the basis of distance weight\\n        sort(edges.begin(), edges.end(), [&](vector<int>& edge1, vector<int>& edge2){\\n            return edge1[2] < edge2[2];\\n        });\\n\\n        // keep track of original indices\\n        for(int i = 0; i < q; i++) queries[i].push_back(i);\\n        \\n        // sort queries on the basis of weight\\n        sort(queries.begin(), queries.end(), [&](vector<int>& query1,vector<int>& query2) {\\n            \\n            return query1[2] < query2[2];\\n        });\\n\\n        // declare answer array of size q, intially everything false\\n        vector<bool> ans(q, false);\\n        int edgeMoment = 0; // pointer to move in edges array\\n\\n        // now, for each query we will calculate answer\\n        for(int eachQuery = 0; eachQuery < q; eachQuery++) {\\n            int currQueryWeight = queries[eachQuery][2]; // currentWeight in queries\\n            \\n            // move in edges till edge distane weight less than currQueryWeight \\n            // and map parents\\n            while(edgeMoment < sz && edges[edgeMoment][2] < currQueryWeight)\\n            Union(edges[edgeMoment][0], edges[edgeMoment][1], parent), edgeMoment++;\\n\\n            // if for this currQueryWeight, queries nodes found in same group,\\n            // put answer true\\n            if(find(queries[eachQuery][0], parent) == \\n            find(queries[eachQuery][1], parent))  {\\n\\n                ans[queries[eachQuery][3]] = true;\\n            }\\n        }\\n        \\n        // finally, return ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465108,
                "title": "javascript-with-explanation-100-100-union-find",
                "content": "# Code\\n```\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const uf = new UnionFind(n), ans = [];\\n\\n    // Create a list of index of queries in incresing order of limit in each query\\n    const order = Array(queries.length).fill().map((_, i) => i);\\n    order.sort((a,b) => queries[a][2] - queries[b][2]);\\n\\n    // Sort edgeList in incresing order of distances\\n    edgeList.sort((a,b) => a[2] - b[2]);\\n\\n    let index=0;\\n    for(const i of order) {\\n        const [p, q, limit] = queries[i];\\n\\n        // For each query, add all edges having distance less than limit\\n        while(edgeList[index]?.[2] < limit){\\n            uf.union(edgeList[index][0], edgeList[index][1]);\\n            index++;\\n        }\\n\\n        // If all edges dis is less than limit then below condition return true\\n        ans[i] = uf.find(p) === uf.find(q);\\n    }\\n    return ans;\\n};\\n\\n\\n\\n\\n//////////////// Union Find Data Structure ////////////////\\nclass UnionFind {\\n    constructor(n) {\\n        this.parent = Array(n).fill().map((_,i) => i);\\n    }\\n\\n    find(i) {\\n        if(this.parent[i] !== i) this.parent[i] = this.find(this.parent[i]);\\n        return this.parent[i];\\n    }\\n    \\n    union(i, j) {\\n        this.parent[this.find(j)] = this.find(i);\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const uf = new UnionFind(n), ans = [];\\n\\n    // Create a list of index of queries in incresing order of limit in each query\\n    const order = Array(queries.length).fill().map((_, i) => i);\\n    order.sort((a,b) => queries[a][2] - queries[b][2]);\\n\\n    // Sort edgeList in incresing order of distances\\n    edgeList.sort((a,b) => a[2] - b[2]);\\n\\n    let index=0;\\n    for(const i of order) {\\n        const [p, q, limit] = queries[i];\\n\\n        // For each query, add all edges having distance less than limit\\n        while(edgeList[index]?.[2] < limit){\\n            uf.union(edgeList[index][0], edgeList[index][1]);\\n            index++;\\n        }\\n\\n        // If all edges dis is less than limit then below condition return true\\n        ans[i] = uf.find(p) === uf.find(q);\\n    }\\n    return ans;\\n};\\n\\n\\n\\n\\n//////////////// Union Find Data Structure ////////////////\\nclass UnionFind {\\n    constructor(n) {\\n        this.parent = Array(n).fill().map((_,i) => i);\\n    }\\n\\n    find(i) {\\n        if(this.parent[i] !== i) this.parent[i] = this.find(this.parent[i]);\\n        return this.parent[i];\\n    }\\n    \\n    union(i, j) {\\n        this.parent[this.find(j)] = this.find(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464947,
                "title": "rust-unionfind",
                "content": "```\\nimpl Solution {\\n    pub fn distance_limited_paths_exist(n: i32, mut edge_list: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut idx: Vec<_> = (0..queries.len()).collect();\\n        idx.sort_by_key(|&i| queries[i][2]);\\n        edge_list.sort_by_key(|v| v[2]);\\n\\n        let mut uf: Vec<usize> = (0..n as usize).collect();\\n        fn uf_find(i: usize, uf: &mut [usize]) -> usize {\\n            if (uf[i] != i) {\\n                uf[i] = uf_find(uf[i], uf);\\n            }\\n            uf[i]\\n        }\\n        fn uf_union(i: usize, j: usize, uf: &mut [usize]) {\\n            let i = uf_find(i, uf);\\n            let j = uf_find(j, uf);\\n            uf[i] = j;\\n        }\\n\\n        let mut ret = vec![false; queries.len()];\\n        let mut j = 0;\\n        for i in idx {\\n            while j < edge_list.len() && edge_list[j][2] < queries[i][2] {\\n                uf_union(edge_list[j][0] as usize, edge_list[j][1] as usize, &mut uf);\\n                j += 1;\\n            }\\n            ret[i] = uf_find(queries[i][0] as usize, &mut uf) == uf_find(queries[i][1] as usize, &mut uf);\\n        }\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distance_limited_paths_exist(n: i32, mut edge_list: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let mut idx: Vec<_> = (0..queries.len()).collect();\\n        idx.sort_by_key(|&i| queries[i][2]);\\n        edge_list.sort_by_key(|v| v[2]);\\n\\n        let mut uf: Vec<usize> = (0..n as usize).collect();\\n        fn uf_find(i: usize, uf: &mut [usize]) -> usize {\\n            if (uf[i] != i) {\\n                uf[i] = uf_find(uf[i], uf);\\n            }\\n            uf[i]\\n        }\\n        fn uf_union(i: usize, j: usize, uf: &mut [usize]) {\\n            let i = uf_find(i, uf);\\n            let j = uf_find(j, uf);\\n            uf[i] = j;\\n        }\\n\\n        let mut ret = vec![false; queries.len()];\\n        let mut j = 0;\\n        for i in idx {\\n            while j < edge_list.len() && edge_list[j][2] < queries[i][2] {\\n                uf_union(edge_list[j][0] as usize, edge_list[j][1] as usize, &mut uf);\\n                j += 1;\\n            }\\n            ret[i] = uf_find(queries[i][0] as usize, &mut uf) == uf_find(queries[i][1] as usize, &mut uf);\\n        }\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1595297,
                "title": "c-solution-using-dsu",
                "content": "```\\nclass union_find\\n{\\n    private:\\n    vector<int>parent;\\n    vector<int>rank;\\n    public:\\n    union_find(int n)\\n    {\\n        parent=vector<int>(n,0);\\n        rank=vector<int>(n,1);\\n        iota(parent.begin(),parent.end(),0);\\n    }\\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x]=find(parent[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        if(rank[x]>rank[y])\\n        {\\n            parent[y]=x;\\n            rank[x]+=rank[y];\\n        }\\n        else\\n        {\\n             parent[x]=y;\\n             rank[y]+=rank[x];\\n        }\\n    }\\n    bool is_connected(int x,int y)\\n    {\\n        return find(x)==find(y);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>&nums, vector<vector<int>>& q) \\n    {    \\n        union_find dsu(n);\\n        sort(nums.begin(),nums.end(),[&](auto &a,auto &b)\\n             {return a[2]<b[2];});\\n        for(int i=0;i<q.size();i++)\\n        {\\n            q[i].push_back(i);\\n        }\\n        sort(q.begin(),q.end(),[&](auto &a,auto &b)\\n             {return a[2]<b[2];});\\n        int i=0;\\n        int X=nums.size();\\n        vector<bool>ans(q.size());\\n        for(auto it:q)\\n        {\\n            while(i<X&&nums[i][2]<it[2])\\n            {\\n                int p1=dsu.find(nums[i][0]);\\n                int p2=dsu.find(nums[i][1]);\\n                if(p1!=p2)\\n                {\\n                   dsu.merge(p1,p2);\\n                }\\n                i++;\\n            }\\n            ans[it[3]]=dsu.is_connected(it[0],it[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass union_find\\n{\\n    private:\\n    vector<int>parent;\\n    vector<int>rank;\\n    public:\\n    union_find(int n)\\n    {\\n        parent=vector<int>(n,0);\\n        rank=vector<int>(n,1);\\n        iota(parent.begin(),parent.end(),0);\\n    }\\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x]=find(parent[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        if(rank[x]>rank[y])\\n        {\\n            parent[y]=x;\\n            rank[x]+=rank[y];\\n        }\\n        else\\n        {\\n             parent[x]=y;\\n             rank[y]+=rank[x];\\n        }\\n    }\\n    bool is_connected(int x,int y)\\n    {\\n        return find(x)==find(y);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>&nums, vector<vector<int>>& q) \\n    {    \\n        union_find dsu(n);\\n        sort(nums.begin(),nums.end(),[&](auto &a,auto &b)\\n             {return a[2]<b[2];});\\n        for(int i=0;i<q.size();i++)\\n        {\\n            q[i].push_back(i);\\n        }\\n        sort(q.begin(),q.end(),[&](auto &a,auto &b)\\n             {return a[2]<b[2];});\\n        int i=0;\\n        int X=nums.size();\\n        vector<bool>ans(q.size());\\n        for(auto it:q)\\n        {\\n            while(i<X&&nums[i][2]<it[2])\\n            {\\n                int p1=dsu.find(nums[i][0]);\\n                int p2=dsu.find(nums[i][1]);\\n                if(p1!=p2)\\n                {\\n                   dsu.merge(p1,p2);\\n                }\\n                i++;\\n            }\\n            ans[it[3]]=dsu.is_connected(it[0],it[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232101,
                "title": "c-union-find",
                "content": "Sort all edges as well as queries in increasing order. To answer a query i.e. (qv1,qv2,weight) we connect all those edges whose weights are strictly less than \\'weight\\'. After connecting those edges we check if the query nodes are connected or not which will be true only if edge weights smaller than \\'weight\\' were involved else it would be false as it requires extra edges having edge weights greater than \\'weight\\'.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent,rank;\\n    \\n    void initialize(int n){\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    \\n    int findPar(int v){\\n        if(v==parent[v]) return v;\\n        return parent[v]=findPar(parent[v]);\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int s=edgeList.size();\\n        int m=queries.size();\\n        parent.resize(n);\\n        rank.resize(n);\\n        initialize(n);\\n        \\n        vector<vector<int>>edges,q;\\n        for(int i=0;i<s;i++){\\n            vector<int>t;\\n            t.push_back(edgeList[i][2]); t.push_back(i);\\n            edges.push_back(t);\\n        }\\n        for(int i=0;i<m;i++){\\n            vector<int>t;\\n            t.push_back(queries[i][2]); t.push_back(i);\\n            q.push_back(t);\\n        }\\n        \\n        sort(edges.begin(),edges.end());\\n        sort(q.begin(),q.end());\\n        \\n        vector<bool>ans(m);\\n        int start=0;\\n        \\n        for(int i=0;i<m;i++){\\n            int weight=q[i][0];\\n            int qv1=queries[q[i][1]][0];\\n            int qv2=queries[q[i][1]][1];\\n            for(int j=start;j<s;j++){\\n                if(edges[j][0]<weight){\\n                    int v1=edgeList[edges[j][1]][0];\\n                    int v2=edgeList[edges[j][1]][1];\\n                    int u=findPar(v1);\\n                    int v=findPar(v2);\\n                    if(u!=v){\\n                        //union\\n                        if(rank[u]<rank[v])\\n                            parent[u]=v;\\n                        else if(rank[v]<rank[u])\\n                            parent[v]=u;\\n                        else\\n                            parent[v]=u,rank[u]++;\\n                    }\\n                    start++;\\n                    \\n                }\\n                else\\n                    break;\\n                \\n            }\\n            if(findPar(qv1)==findPar(qv2))\\n                ans[q[i][1]]=true;\\n            else\\n                ans[q[i][1]]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent,rank;\\n    \\n    void initialize(int n){\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n    }\\n    \\n    int findPar(int v){\\n        if(v==parent[v]) return v;\\n        return parent[v]=findPar(parent[v]);\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int s=edgeList.size();\\n        int m=queries.size();\\n        parent.resize(n);\\n        rank.resize(n);\\n        initialize(n);\\n        \\n        vector<vector<int>>edges,q;\\n        for(int i=0;i<s;i++){\\n            vector<int>t;\\n            t.push_back(edgeList[i][2]); t.push_back(i);\\n            edges.push_back(t);\\n        }\\n        for(int i=0;i<m;i++){\\n            vector<int>t;\\n            t.push_back(queries[i][2]); t.push_back(i);\\n            q.push_back(t);\\n        }\\n        \\n        sort(edges.begin(),edges.end());\\n        sort(q.begin(),q.end());\\n        \\n        vector<bool>ans(m);\\n        int start=0;\\n        \\n        for(int i=0;i<m;i++){\\n            int weight=q[i][0];\\n            int qv1=queries[q[i][1]][0];\\n            int qv2=queries[q[i][1]][1];\\n            for(int j=start;j<s;j++){\\n                if(edges[j][0]<weight){\\n                    int v1=edgeList[edges[j][1]][0];\\n                    int v2=edgeList[edges[j][1]][1];\\n                    int u=findPar(v1);\\n                    int v=findPar(v2);\\n                    if(u!=v){\\n                        //union\\n                        if(rank[u]<rank[v])\\n                            parent[u]=v;\\n                        else if(rank[v]<rank[u])\\n                            parent[v]=u;\\n                        else\\n                            parent[v]=u,rank[u]++;\\n                    }\\n                    start++;\\n                    \\n                }\\n                else\\n                    break;\\n                \\n            }\\n            if(findPar(qv1)==findPar(qv2))\\n                ans[q[i][1]]=true;\\n            else\\n                ans[q[i][1]]=false;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466250,
                "title": "sorting-union-find-c",
                "content": "```\\nclass Solution {\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    int find_prnt(int node, vector<int> &prnt) {\\n        if(node == prnt[node]) return node;\\n        return prnt[node] = find_prnt(prnt[node], prnt);\\n    }\\n    void unionn(int u, int v, vector<int> &prnt, vector<int> &rank) {\\n        int ulp_u = find_prnt(u, prnt), ulp_v = find_prnt(v, prnt);\\n\\n        if(rank[ulp_u] > rank[ulp_v]) prnt[ulp_v] = ulp_u; \\n        else if(rank[ulp_u] < rank[ulp_v]) prnt[ulp_u] = ulp_v;\\n        else {\\n            prnt[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int m = queries.size(), p = 0;\\n        for(int i=0; i<m; i++) queries[i].push_back(i);\\n\\n        sort(edgeList.begin(), edgeList.end(), cmp);\\n        sort(queries.begin(), queries.end(), cmp);\\n\\n        vector<bool> ans(m);\\n        vector<int> prnt(n), rank(n);\\n        for(int i=0; i<n; i++) prnt[i] = i;\\n\\n        for(auto q : queries) {\\n            while(p < edgeList.size() && edgeList[p][2] < q[2]) {\\n                unionn(edgeList[p][0], edgeList[p][1], prnt, rank), p++;\\n            }\\n            ans[q[3]] = find_prnt(q[0], prnt) == find_prnt(q[1], prnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    int find_prnt(int node, vector<int> &prnt) {\\n        if(node == prnt[node]) return node;\\n        return prnt[node] = find_prnt(prnt[node], prnt);\\n    }\\n    void unionn(int u, int v, vector<int> &prnt, vector<int> &rank) {\\n        int ulp_u = find_prnt(u, prnt), ulp_v = find_prnt(v, prnt);\\n\\n        if(rank[ulp_u] > rank[ulp_v]) prnt[ulp_v] = ulp_u; \\n        else if(rank[ulp_u] < rank[ulp_v]) prnt[ulp_u] = ulp_v;\\n        else {\\n            prnt[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int m = queries.size(), p = 0;\\n        for(int i=0; i<m; i++) queries[i].push_back(i);\\n\\n        sort(edgeList.begin(), edgeList.end(), cmp);\\n        sort(queries.begin(), queries.end(), cmp);\\n\\n        vector<bool> ans(m);\\n        vector<int> prnt(n), rank(n);\\n        for(int i=0; i<n; i++) prnt[i] = i;\\n\\n        for(auto q : queries) {\\n            while(p < edgeList.size() && edgeList[p][2] < q[2]) {\\n                unionn(edgeList[p][0], edgeList[p][1], prnt, rank), p++;\\n            }\\n            ans[q[3]] = find_prnt(q[0], prnt) == find_prnt(q[1], prnt);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465602,
                "title": "sorting-dsu",
                "content": "# Complexity\\n- Time complexity:O(ElogE + QlogQ + Q + E) = O(NlogN)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int>Parent;\\n    vector<int>Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for(int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x? x : Find(Parent[x]);\\n    }\\n\\n    void Union(int a, int b) {\\n        a = Find(a);\\n        b = Find(b);\\n        if(Rank[a] == Rank[b]) Rank[a]++;\\n        if(Rank[a] > Rank[b]){\\n            Parent[b] = a;\\n        }\\n        else {\\n            Parent[a] = b;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& q) {\\n        int nq = q.size();\\n        for(int i = 0; i < nq; i++) {\\n            q[i].push_back(i);\\n        }\\n        sort(begin(q), end(q), [&](auto const& a, auto const& b) {\\n          return a[2] < b[2];\\n        });\\n        sort(begin(edgeList), end(edgeList), [&](auto const& a, auto const& b) {\\n          return a[2] < b[2];\\n        });\\n        vector<bool>ans(nq, 0);\\n        int i = 0;\\n        DSU dsu(n);\\n        for(int j = 0; j < nq; j++) {\\n          while(i < edgeList.size() && edgeList[i][2] < q[j][2]) {\\n            dsu.Union(edgeList[i][0], edgeList[i][1]);\\n            i++;\\n          }\\n          if(dsu.Find(q[j][0]) == dsu.Find(q[j][1])) ans[q[j][3]] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int>Parent;\\n    vector<int>Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for(int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x? x : Find(Parent[x]);\\n    }\\n\\n    void Union(int a, int b) {\\n        a = Find(a);\\n        b = Find(b);\\n        if(Rank[a] == Rank[b]) Rank[a]++;\\n        if(Rank[a] > Rank[b]){\\n            Parent[b] = a;\\n        }\\n        else {\\n            Parent[a] = b;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& q) {\\n        int nq = q.size();\\n        for(int i = 0; i < nq; i++) {\\n            q[i].push_back(i);\\n        }\\n        sort(begin(q), end(q), [&](auto const& a, auto const& b) {\\n          return a[2] < b[2];\\n        });\\n        sort(begin(edgeList), end(edgeList), [&](auto const& a, auto const& b) {\\n          return a[2] < b[2];\\n        });\\n        vector<bool>ans(nq, 0);\\n        int i = 0;\\n        DSU dsu(n);\\n        for(int j = 0; j < nq; j++) {\\n          while(i < edgeList.size() && edgeList[i][2] < q[j][2]) {\\n            dsu.Union(edgeList[i][0], edgeList[i][1]);\\n            i++;\\n          }\\n          if(dsu.Find(q[j][0]) == dsu.Find(q[j][1])) ans[q[j][3]] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465601,
                "title": "deep-and-step-by-step-approach-and-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading the problem, the first approach that came to my mind was to try to find an answer for each query using **Dijkstra**\\'s algorithm. However, after analyzing the constraints, I realized that it would lead to a TLE (Time Limit Exceeded). As this approach takes O(Q*Nlog(E)) time.\\n\\nSince the problem requires us to check if a path exists between two nodes, I thought it could be solved using the **Disjoint Set Union (DSU)** data structure, as it helps to find the parent in nearly constant time.\\n\\n\\n---\\n\\n\\n\\n# Approach\\n1. Create a DisjointSet class to represent the graph, which will store the parent node for each node in the graph. Initially, each node is its own parent.\\n2. Add a findParent method to the DisjointSet class, which finds the parent of a given node. If the parent of a node is itself, return the node, otherwise recursively call findParent on the parent of the node.\\n3. Add a unionByRank method to the DisjointSet class, which takes two nodes and unions them together. The method finds the parent of each node, and if they are not the same, it merges the two sets by attaching the one with the smaller rank to the one with the larger rank.\\n4. Add an isParentEqual method to the DisjointSet class, which checks if the parent of two nodes is the same. This method uses findParent to get the parent of each node and then checks if they are equal.\\n5. Sort the edges by distance in non-decreasing order.\\n6. Sort the queries by limit in non-decreasing order.\\n7. For each query, loop through the edges until the distance is greater than the limit of the current query. For each edge, call the unionByRank method to merge the nodes together.\\n8. After all edges less than the current query\\'s limit have been processed, check if the parent of the source and destination nodes in the query are the same using the isParentEqual method. If they are, set the answer for the query to true, otherwise set it to false.\\n9. Return the array of answers.\\n\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity**:\\n\\n1. Sorting the edges takes O(ElogE) time.\\n2. Sorting the queries takes O(QlogQ) time.\\n3. For each query, we iterate through the edges up to limit distance. Therefore, for all queries, we iterate through all the edges at most once. So, iterating through all the edges takes O(E) time.\\n4. Union-find operations take nearly O(1) time.\\n5. Therefore, the total time complexity of the solution is O(ElogE + QlogQ + (O+E)).\\n\\n- **Space complexity**:\\n\\n1. We use a disjoint-set data structure to keep track of the connected components of the graph. The space required for this data structure is O(N).\\n2.If we neglect space required to store answer, the total space complexity of the solution is O(N).\\n\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass DisjointSet {\\nprivate:\\n    vector<int> parent, rank;\\n\\npublic:\\n    DisjointSet(int n) {\\n        parent.resize(n+1, 0);\\n        rank.resize(n+1, 0);\\n\\n        for(int i=0; i<n+1; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int node) {\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int upU = findParent(u);\\n        int upV = findParent(v);\\n\\n        if(upU == upV)\\n            return;\\n        \\n        if(rank[upU] < rank[upV]) {\\n            parent[upU] = upV;\\n        }\\n        else {\\n            parent[upV] = upU;\\n            rank[upU]++;\\n        }\\n    }\\n\\n    bool isParentEqual(int u, int v) {\\n        return (findParent(u) == findParent(v));\\n    }\\n};\\n\\nclass Solution {\\n    bool static compare(const vector<int> &a, const vector<int> &b) {\\n        return (a[2] < b[2]);\\n    }\\n\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int nodes, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int n = queries.size();\\n\\n        vector<bool> ans(n, false);\\n        \\n        for(int i=0; i<n; i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(edges.begin(), edges.end(), compare);\\n        sort(queries.begin(), queries.end(), compare);\\n\\n        DisjointSet ds(nodes);\\n        int i=0;\\n\\n        for(auto &query : queries) {\\n            int u = query[0];\\n            int v = query[1];\\n            int limit = query[2];\\n            int qId = query[3];\\n\\n            for(; (i < edges.size()) && (edges[i][2] < limit); i++) {\\n                ds.unionByRank(edges[i][0], edges[i][1]);\\n            }\\n            ans[qId] = ds.isParentEqual(u, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n---\\n\\n**Happy Coding...**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass DisjointSet {\\nprivate:\\n    vector<int> parent, rank;\\n\\npublic:\\n    DisjointSet(int n) {\\n        parent.resize(n+1, 0);\\n        rank.resize(n+1, 0);\\n\\n        for(int i=0; i<n+1; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int node) {\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int upU = findParent(u);\\n        int upV = findParent(v);\\n\\n        if(upU == upV)\\n            return;\\n        \\n        if(rank[upU] < rank[upV]) {\\n            parent[upU] = upV;\\n        }\\n        else {\\n            parent[upV] = upU;\\n            rank[upU]++;\\n        }\\n    }\\n\\n    bool isParentEqual(int u, int v) {\\n        return (findParent(u) == findParent(v));\\n    }\\n};\\n\\nclass Solution {\\n    bool static compare(const vector<int> &a, const vector<int> &b) {\\n        return (a[2] < b[2]);\\n    }\\n\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int nodes, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int n = queries.size();\\n\\n        vector<bool> ans(n, false);\\n        \\n        for(int i=0; i<n; i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(edges.begin(), edges.end(), compare);\\n        sort(queries.begin(), queries.end(), compare);\\n\\n        DisjointSet ds(nodes);\\n        int i=0;\\n\\n        for(auto &query : queries) {\\n            int u = query[0];\\n            int v = query[1];\\n            int limit = query[2];\\n            int qId = query[3];\\n\\n            for(; (i < edges.size()) && (edges[i][2] < limit); i++) {\\n                ds.unionByRank(edges[i][0], edges[i][1]);\\n            }\\n            ans[qId] = ds.isParentEqual(u, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464937,
                "title": "python3-beats-87-42-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        parent = [i for i in range(n+1)]\\n    \\n        rank = [0 for i in range(n+1)]\\n\\n        def find(parent, x):\\n\\n            if parent[x] == x:\\n                return x\\n            parent[x] = find(parent, parent[x])\\n            return parent[x]\\n\\n        def union(parent, a, b):\\n\\n            a = find(parent, a)\\n            b = find(parent, b)\\n\\n            if a == b:\\n                return \\n\\n            if rank[a] < rank[b]:\\n                parent[a] = b\\n            elif rank[a] > rank[b]:\\n                parent[b] = a\\n            else:\\n                parent[b] = a\\n                rank[a] += 1\\n                \\n        edgeList.sort(key = lambda x: x[2])\\n        res = [0] * len(queries)\\n        queries = [[i, ch] for i, ch in enumerate(queries)]\\n        queries.sort(key = lambda x: x[1][2])\\n        \\n        ind = 0\\n        for i, (a, b, w) in queries:\\n            \\n            while ind < len(edgeList) and edgeList[ind][2] < w:\\n                union(parent, edgeList[ind][0], edgeList[ind][1])\\n                ind += 1\\n                \\n            res[i] = find(parent, a) == find(parent, b)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        parent = [i for i in range(n+1)]\\n    \\n        rank = [0 for i in range(n+1)]\\n\\n        def find(parent, x):\\n\\n            if parent[x] == x:\\n                return x\\n            parent[x] = find(parent, parent[x])\\n            return parent[x]\\n\\n        def union(parent, a, b):\\n\\n            a = find(parent, a)\\n            b = find(parent, b)\\n\\n            if a == b:\\n                return \\n\\n            if rank[a] < rank[b]:\\n                parent[a] = b\\n            elif rank[a] > rank[b]:\\n                parent[b] = a\\n            else:\\n                parent[b] = a\\n                rank[a] += 1\\n                \\n        edgeList.sort(key = lambda x: x[2])\\n        res = [0] * len(queries)\\n        queries = [[i, ch] for i, ch in enumerate(queries)]\\n        queries.sort(key = lambda x: x[1][2])\\n        \\n        ind = 0\\n        for i, (a, b, w) in queries:\\n            \\n            while ind < len(edgeList) and edgeList[ind][2] < w:\\n                union(parent, edgeList[ind][0], edgeList[ind][1])\\n                ind += 1\\n                \\n            res[i] = find(parent, a) == find(parent, b)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464812,
                "title": "swift-solution-runtime-beats-75-2186-ms-memory-beats-100-29-6-mb",
                "content": "# Approach\\nAs the backbone a variation of `Floyd Warshall\\'s` algorithm is used, which is an all-pairs shortest path algorithm, to compute the shortest distance between all pairs of nodes in the graph considering only edges with distances less than the limit. A Union-Find data structure with path compression and union by rank was used for cases with large n.\\n\\n## Time Complexity\\nThe time complexity of this solution is `O(E * log(E) + Q * log(Q))`, where E is the number of edges and Q is the number of queries. This complexity should work efficiently for large values of n.\\n\\n## Space Complexity\\nThe space complexity is `O(n + E + Q)`, where n is the number of nodes, E is the number of edges, and Q is the number of queries. The space is used to store the `UnionFind` data structure, the sorted edges, the sorted queries, and the result array.\\n\\n# Solution\\n```swift\\nclass Solution {\\n    func distanceLimitedPathsExist(_ n: Int, _ edgeList: [[Int]], _ queries: [[Int]]) -> [Bool] {\\n        var edges = edgeList.sorted { $0[2] < $1[2] }\\n        var queriesWithIndex = queries.enumerated().sorted { $0.1[2] < $1.1[2] }\\n        var result = Array(repeating: false, count: queries.count)\\n        let uf = UnionFind(n)\\n        var edgeIndex = 0\\n\\n        for (queryIndex, query) in queriesWithIndex {\\n            let p = query[0]\\n            let q = query[1]\\n            let limit = query[2]\\n        \\n            while edgeIndex < edges.count && edges[edgeIndex][2] < limit {\\n                let edge = edges[edgeIndex]\\n                uf.union(edge[0], edge[1])\\n                edgeIndex += 1\\n            }\\n        \\n            result[queryIndex] = uf.find(p) == uf.find(q)\\n        }\\n    \\n        return result\\n    }\\n\\n    final class UnionFind {\\n        var parent: [Int]\\n        var rank: [Int]\\n    \\n        init(_ size: Int) {\\n            parent = Array(0..<size)\\n            rank = Array(repeating: 0, count: size)\\n        }\\n    \\n        func find(_ x: Int) -> Int {\\n            if parent[x] != x {\\n                parent[x] = find(parent[x])\\n            }\\n            return parent[x]\\n        }\\n    \\n        func union(_ x: Int, _ y: Int) {\\n            let rootX = find(x)\\n            let rootY = find(y)\\n        \\n            if rootX != rootY {\\n                if rank[rootX] > rank[rootY] {\\n                    parent[rootY] = rootX\\n                } else if rank[rootX] < rank[rootY] {\\n                    parent[rootX] = rootY\\n                } else {\\n                    parent[rootY] = rootX\\n                    rank[rootX] += 1\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func distanceLimitedPathsExist(_ n: Int, _ edgeList: [[Int]], _ queries: [[Int]]) -> [Bool] {\\n        var edges = edgeList.sorted { $0[2] < $1[2] }\\n        var queriesWithIndex = queries.enumerated().sorted { $0.1[2] < $1.1[2] }\\n        var result = Array(repeating: false, count: queries.count)\\n        let uf = UnionFind(n)\\n        var edgeIndex = 0\\n\\n        for (queryIndex, query) in queriesWithIndex {\\n            let p = query[0]\\n            let q = query[1]\\n            let limit = query[2]\\n        \\n            while edgeIndex < edges.count && edges[edgeIndex][2] < limit {\\n                let edge = edges[edgeIndex]\\n                uf.union(edge[0], edge[1])\\n                edgeIndex += 1\\n            }\\n        \\n            result[queryIndex] = uf.find(p) == uf.find(q)\\n        }\\n    \\n        return result\\n    }\\n\\n    final class UnionFind {\\n        var parent: [Int]\\n        var rank: [Int]\\n    \\n        init(_ size: Int) {\\n            parent = Array(0..<size)\\n            rank = Array(repeating: 0, count: size)\\n        }\\n    \\n        func find(_ x: Int) -> Int {\\n            if parent[x] != x {\\n                parent[x] = find(parent[x])\\n            }\\n            return parent[x]\\n        }\\n    \\n        func union(_ x: Int, _ y: Int) {\\n            let rootX = find(x)\\n            let rootY = find(y)\\n        \\n            if rootX != rootY {\\n                if rank[rootX] > rank[rootY] {\\n                    parent[rootY] = rootX\\n                } else if rank[rootX] < rank[rootY] {\\n                    parent[rootX] = rootY\\n                } else {\\n                    parent[rootY] = rootX\\n                    rank[rootX] += 1\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464793,
                "title": "daily-leetcoding-challenge-april-day-29",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Disjoint-Set Union\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2723170,
                "title": "minimum-spanning-tree-disjoint-set-union",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // darna mt bhai\\n    \\n    \\n   /* create a mst by given graph using krushkal\\'s algorithm once mst is formed then we use binary lifting concept for finding lowest common ansestor is used for answering the query\\n \\n along with storing the parent array we also maintain a maxweight array \\n where maxweight[i][j] tell that what is the maximum weight in path between \\n node i and node (i+2^j) \\n \\n this can be calculated using dfs and once these vales are calculated then\\n using lowest common anscestor method we can answer the query\\n \\n for better understanding look at my submission\\n \\n */\\n    // custom comparator used for sorting the edges array \\n    // helpful in kruskal\\'s algorithm\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    \\n    // x=30 used for binary lifting\\n    int x=30;\\n    \\n    // different vectors used \\n    vector<vector<int>>parent,maxweight;\\n    vector<int>par,Size,vis,depth;\\n    vector<vector<pair<int,int>>>g;\\n    \\n// union find to create mst\\n    void make(int i){\\n        par[i]=i;\\n        Size[i]=1;\\n    }\\n    int find(int a){\\n        if(par[a]==a)return a;\\n        return par[a]=find(par[a]);\\n    }\\n    void Union(int a,int b){\\n        a=find(a),b=find(b);\\n        if(a!=b){\\n            if(Size[a]<Size[b])swap(a,b);\\n            par[b]=a;\\n            Size[a]+=Size[b];\\n            return;\\n        }\\n    }\\n    \\n    //creating mst using kruskal\\'s algorithm\\n    \\n    void create_mst(vector<vector<int>>&edge,int n){\\n        sort(edge.begin(),edge.end(),comp);\\n        par.clear(),Size.clear();\\n        par.resize(n),Size.resize(n);\\n        for(int i=0;i<n;++i)make(i);\\n        g.clear(),g.resize(n);\\n        for(auto e:edge){\\n            int a=e[0],b=e[1],w=e[2];\\n            if(find(a)!=find(b)){\\n                Union(a,b);\\n                g[a].push_back({b,w});\\n                g[b].push_back({a,w});\\n            }\\n        }\\n        return;\\n    }\\n    \\n    //run dfs for calculating (initial values of parent and maxweight)\\n   \\n    void dfs(int i){\\n        vis[i]=true;\\n        for(auto ch:g[i]){\\n            int v=ch.first,w=ch.second;\\n            if(!vis[v]){\\n                parent[v][0]=i;\\n                depth[v]=depth[i]+1;\\n                maxweight[v][0]=w;\\n                dfs(v);\\n            }\\n        }\\n        \\n    }\\n    \\n    // this function calculating all parent and maxweight values\\n    void cal(int n){\\n     parent.clear(),maxweight.clear(),depth.clear(),depth.resize(n,0);\\nparent.resize(n,vector<int>(x+1,-1)),maxweight.resize(n,vector<int>(x+1,INT_MIN));\\n        vis.clear();\\n        vis.resize(n,false);\\n        for(int i=0;i<n;++i){\\n            if(!vis[i]){\\n                depth[i]=0;\\n                dfs(i);\\n            }\\n        }\\n        \\n        //calculating rest of parent and maxweight values\\n        \\n        for(int j=1;j<=x;++j){\\n            for(int i=0;i<n;++i){\\n              if(parent[i][j-1]!=-1){\\n    parent[i][j]=parent[parent[i][j-1]][j-1];\\n    maxweight[i][j]=max(maxweight[i][j-1],maxweight[parent[i][j-1]][j-1]);\\n              }\\n            }\\n        }\\n    }\\n    \\n    // modified method for finding k_Th ancestor\\n    \\n    pair<int,int> k_th_ancestor(int a,int k){\\n        int weight=INT_MIN;\\n        for(int i=x;i>=0;--i){\\n            if(k&(1<<i)){\\n                k-=(1<<i);\\n                weight=max(weight,maxweight[a][i]);\\n                 a=parent[a][i];\\n                if(a==-1)return {-1,INT_MIN};\\n            }\\n        }\\n        return {a,weight};\\n    }\\n    \\n    //function for finding lca\\n    int lca(int a,int b){\\n        if(depth[a]>depth[b])swap(a,b);\\n        int d=depth[b]-depth[a];\\n        auto pr=k_th_ancestor(b,d);\\n        b=pr.first;\\n        int weight=pr.second;\\n        if(a==b)return weight;\\n        for(int i=x;i>=0;--i){\\n            if(parent[a][i]!=parent[b][i]){\\n                weight=max(weight,max(maxweight[a][i],maxweight[b][i]));\\n                a=parent[a][i];\\n                b=parent[b][i];\\n            }\\n        }\\n        weight=max(weight,max(maxweight[a][0],maxweight[b][0]));\\n        return weight;\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        create_mst(edgeList,n);\\n        cal(n);\\n        vector<bool>ans(queries.size());\\n        for(int i=0;i<queries.size();++i){\\n            int a=queries[i][0],b=queries[i][1],limit=queries[i][2];\\n            if(find(a)!=find(b)){\\n                ans[i]=false;\\n                continue;\\n            }\\n            ans[i]=(lca(a,b)<limit);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // darna mt bhai\\n    \\n    \\n   /* create a mst by given graph using krushkal\\'s algorithm once mst is formed then we use binary lifting concept for finding lowest common ansestor is used for answering the query\\n \\n along with storing the parent array we also maintain a maxweight array \\n where maxweight[i][j] tell that what is the maximum weight in path between \\n node i and node (i+2^j) \\n \\n this can be calculated using dfs and once these vales are calculated then\\n using lowest common anscestor method we can answer the query\\n \\n for better understanding look at my submission\\n \\n */\\n    // custom comparator used for sorting the edges array \\n    // helpful in kruskal\\'s algorithm\\n    static bool comp(vector<int>&a,vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    \\n    // x=30 used for binary lifting\\n    int x=30;\\n    \\n    // different vectors used \\n    vector<vector<int>>parent,maxweight;\\n    vector<int>par,Size,vis,depth;\\n    vector<vector<pair<int,int>>>g;\\n    \\n// union find to create mst\\n    void make(int i){\\n        par[i]=i;\\n        Size[i]=1;\\n    }\\n    int find(int a){\\n        if(par[a]==a)return a;\\n        return par[a]=find(par[a]);\\n    }\\n    void Union(int a,int b){\\n        a=find(a),b=find(b);\\n        if(a!=b){\\n            if(Size[a]<Size[b])swap(a,b);\\n            par[b]=a;\\n            Size[a]+=Size[b];\\n            return;\\n        }\\n    }\\n    \\n    //creating mst using kruskal\\'s algorithm\\n    \\n    void create_mst(vector<vector<int>>&edge,int n){\\n        sort(edge.begin(),edge.end(),comp);\\n        par.clear(),Size.clear();\\n        par.resize(n),Size.resize(n);\\n        for(int i=0;i<n;++i)make(i);\\n        g.clear(),g.resize(n);\\n        for(auto e:edge){\\n            int a=e[0],b=e[1],w=e[2];\\n            if(find(a)!=find(b)){\\n                Union(a,b);\\n                g[a].push_back({b,w});\\n                g[b].push_back({a,w});\\n            }\\n        }\\n        return;\\n    }\\n    \\n    //run dfs for calculating (initial values of parent and maxweight)\\n   \\n    void dfs(int i){\\n        vis[i]=true;\\n        for(auto ch:g[i]){\\n            int v=ch.first,w=ch.second;\\n            if(!vis[v]){\\n                parent[v][0]=i;\\n                depth[v]=depth[i]+1;\\n                maxweight[v][0]=w;\\n                dfs(v);\\n            }\\n        }\\n        \\n    }\\n    \\n    // this function calculating all parent and maxweight values\\n    void cal(int n){\\n     parent.clear(),maxweight.clear(),depth.clear(),depth.resize(n,0);\\nparent.resize(n,vector<int>(x+1,-1)),maxweight.resize(n,vector<int>(x+1,INT_MIN));\\n        vis.clear();\\n        vis.resize(n,false);\\n        for(int i=0;i<n;++i){\\n            if(!vis[i]){\\n                depth[i]=0;\\n                dfs(i);\\n            }\\n        }\\n        \\n        //calculating rest of parent and maxweight values\\n        \\n        for(int j=1;j<=x;++j){\\n            for(int i=0;i<n;++i){\\n              if(parent[i][j-1]!=-1){\\n    parent[i][j]=parent[parent[i][j-1]][j-1];\\n    maxweight[i][j]=max(maxweight[i][j-1],maxweight[parent[i][j-1]][j-1]);\\n              }\\n            }\\n        }\\n    }\\n    \\n    // modified method for finding k_Th ancestor\\n    \\n    pair<int,int> k_th_ancestor(int a,int k){\\n        int weight=INT_MIN;\\n        for(int i=x;i>=0;--i){\\n            if(k&(1<<i)){\\n                k-=(1<<i);\\n                weight=max(weight,maxweight[a][i]);\\n                 a=parent[a][i];\\n                if(a==-1)return {-1,INT_MIN};\\n            }\\n        }\\n        return {a,weight};\\n    }\\n    \\n    //function for finding lca\\n    int lca(int a,int b){\\n        if(depth[a]>depth[b])swap(a,b);\\n        int d=depth[b]-depth[a];\\n        auto pr=k_th_ancestor(b,d);\\n        b=pr.first;\\n        int weight=pr.second;\\n        if(a==b)return weight;\\n        for(int i=x;i>=0;--i){\\n            if(parent[a][i]!=parent[b][i]){\\n                weight=max(weight,max(maxweight[a][i],maxweight[b][i]));\\n                a=parent[a][i];\\n                b=parent[b][i];\\n            }\\n        }\\n        weight=max(weight,max(maxweight[a][0],maxweight[b][0]));\\n        return weight;\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        create_mst(edgeList,n);\\n        cal(n);\\n        vector<bool>ans(queries.size());\\n        for(int i=0;i<queries.size();++i){\\n            int a=queries[i][0],b=queries[i][1],limit=queries[i][2];\\n            if(find(a)!=find(b)){\\n                ans[i]=false;\\n                continue;\\n            }\\n            ans[i]=(lca(a,b)<limit);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456528,
                "title": "python-union-find-sorting",
                "content": "```\\n# Idea: \\n# For a query [p, q, limit]\\n# we can connect all edges with a weight less than limit -> union nodes u_i, v_i if dis_i < limit\\n# after previous step, simply check if p and q is connected  ---> get answer for this query\\n\\n# Optimization: \\n# we can sort the query in ASC by limit, so for query with larger limits, no need to connect small weight edges\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        # Dynamic union-find with path compression and union by rank\\n        class UnionFind:\\n\\t\\t    pass\\n        \\n        edgeList.sort(key=lambda x:x[2])        # sort all edges by weight(\"distance\")\\n        for i in range(len(queries)):\\n            queries[i].append(i)                # add original query index into query cuz we will sort it later\\n                                                # we still need original index to store answers\\n            \\n        queries.sort(key=lambda x:x[2])         # sort the query in ASC by limit\\n        uf = UnionFind()\\n        start = 0                               # record start index of unvisited edge in edgeList\\n        ans = [False] * len(queries)\\n        \\n        for u, v, limit, index in queries:\\n            \\n            for i in range(start, len(edgeList)):\\n                a, b, weight = edgeList[i]\\n                if weight < limit:\\n                    uf.union(a, b)\\n                else:                           # find an edge with weiight >= limit, stop here\\n                    start = i                   # record current index, so we can resume more efficiently \\n                    break\\n            \\n            if u in uf.parents and v in uf.parents and uf.find(u) == uf.find(v):\\n                ans[index] = True\\n                \\n        return ans \\n```\\n\\nImplementation of UnionFind class in more details: \\nWe don\\'t always need path compression and union-by-rank, but it doesn\\'t hurt if we implement that.\\n\\n```\\n# Dynamic union-find with path compression and union by rank\\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.ranks = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.ranks[x] = 0\\n                \\n            def find(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                self.insert(x)\\n                self.insert(y)\\n                x, y = self.find(x), self.find(y)\\n                if x == y:\\n                    return \\n                if self.ranks[x] > self.ranks[y]:\\n                    self.parents[y] = x\\n                else:\\n                    self.parents[x] = y\\n                    if self.ranks[x] == self.ranks[y]:\\n                        self.ranks[y] += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\n# Idea: \\n# For a query [p, q, limit]\\n# we can connect all edges with a weight less than limit -> union nodes u_i, v_i if dis_i < limit\\n# after previous step, simply check if p and q is connected  ---> get answer for this query\\n\\n# Optimization: \\n# we can sort the query in ASC by limit, so for query with larger limits, no need to connect small weight edges\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        # Dynamic union-find with path compression and union by rank\\n        class UnionFind:\\n\\t\\t    pass\\n        \\n        edgeList.sort(key=lambda x:x[2])        # sort all edges by weight(\"distance\")\\n        for i in range(len(queries)):\\n            queries[i].append(i)                # add original query index into query cuz we will sort it later\\n                                                # we still need original index to store answers\\n            \\n        queries.sort(key=lambda x:x[2])         # sort the query in ASC by limit\\n        uf = UnionFind()\\n        start = 0                               # record start index of unvisited edge in edgeList\\n        ans = [False] * len(queries)\\n        \\n        for u, v, limit, index in queries:\\n            \\n            for i in range(start, len(edgeList)):\\n                a, b, weight = edgeList[i]\\n                if weight < limit:\\n                    uf.union(a, b)\\n                else:                           # find an edge with weiight >= limit, stop here\\n                    start = i                   # record current index, so we can resume more efficiently \\n                    break\\n            \\n            if u in uf.parents and v in uf.parents and uf.find(u) == uf.find(v):\\n                ans[index] = True\\n                \\n        return ans \\n```\n```\\n# Dynamic union-find with path compression and union by rank\\n        class UnionFind:\\n            def __init__(self):\\n                self.parents = {}\\n                self.ranks = {}\\n                \\n            def insert(self, x):\\n                if x not in self.parents:\\n                    self.parents[x] = x\\n                    self.ranks[x] = 0\\n                \\n            def find(self, x):\\n                if self.parents[x] != x:\\n                    self.parents[x] = self.find(self.parents[x])\\n                return self.parents[x]\\n            \\n            def union(self, x, y):\\n                self.insert(x)\\n                self.insert(y)\\n                x, y = self.find(x), self.find(y)\\n                if x == y:\\n                    return \\n                if self.ranks[x] > self.ranks[y]:\\n                    self.parents[y] = x\\n                else:\\n                    self.parents[x] = y\\n                    if self.ranks[x] == self.ranks[y]:\\n                        self.ranks[y] += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2411244,
                "title": "dsu-c",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    \\n    vector<int> parent;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x]==x)return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void Union(int x,int y)\\n    {\\n        int lx = find(x);\\n        int ly = find(y);\\n        parent[lx] = ly;\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& q) {\\n        int m = q.size();\\n        for(int i = 0;i<m;i++)\\n        {\\n            q[i].push_back(i);\\n        }\\n        \\n        parent.resize(n,0);\\n        for(int i = 0;i<n;i++)\\n            parent[i] = i;\\n        sort(edges.begin(),edges.end(),cmp);\\n        sort(q.begin(),q.end(),cmp);\\n        \\n        int i = 0;\\n        vector<bool> ans(m,0);\\n        \\n        for(auto it:q)\\n        {\\n            while(i<edges.size() and edges[i][2]<it[2])\\n            {\\n                Union(edges[i][0],edges[i][1]);\\n                i++;\\n            }\\n            ans[it[3]] = (find(it[0])==find(it[1]));\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    \\n    vector<int> parent;\\n    \\n    int find(int x)\\n    {\\n        if(parent[x]==x)return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void Union(int x,int y)\\n    {\\n        int lx = find(x);\\n        int ly = find(y);\\n        parent[lx] = ly;\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& q) {\\n        int m = q.size();\\n        for(int i = 0;i<m;i++)\\n        {\\n            q[i].push_back(i);\\n        }\\n        \\n        parent.resize(n,0);\\n        for(int i = 0;i<n;i++)\\n            parent[i] = i;\\n        sort(edges.begin(),edges.end(),cmp);\\n        sort(q.begin(),q.end(),cmp);\\n        \\n        int i = 0;\\n        vector<bool> ans(m,0);\\n        \\n        for(auto it:q)\\n        {\\n            while(i<edges.size() and edges[i][2]<it[2])\\n            {\\n                Union(edges[i][0],edges[i][1]);\\n                i++;\\n            }\\n            ans[it[3]] = (find(it[0])==find(it[1]));\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330524,
                "title": "c-union-find-two-pointer",
                "content": "```\\n// custom comparator to sort based on weight\\nbool comp(vector<int> &a,vector<int> &b){\\n    if(a[2] == b[2]){\\n        return a[1]<b[1];\\n    }\\n    return a[2]<b[2];\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    // Union Find data structure\\n    \\n    int parent[100005];\\n    int sz[100005];\\n    \\n    void makeset(int v){\\n        parent[v] = v;\\n        sz[v] = 1;\\n    }\\n    int find(int v){\\n        if(parent[v] == v) return v;\\n        return parent[v] = find(parent[v]);\\n    }\\n    void Union(int x,int y){\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return;\\n        if(sz[x]>sz[y]) swap(x,y);\\n        parent[y] = x;\\n        sz[y]+=sz[x];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n        for(int i=0;i<n;i++) {\\n            makeset(i);\\n        }\\n        int m = queries.size();\\n        for(int i=0;i<queries.size();i++) {\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(queries.begin(),queries.end(),comp);\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        vector<bool> ans(queries.size(),false);\\n        int i=0;\\n        int j=0;\\n        // two pointer\\n        // building graph based on weights allowed by queries\\n        while(j<m){\\n            int wt = queries[j][2];\\n            \\n            while(i<edgeList.size() && edgeList[i][2]<wt){\\n                int a = edgeList[i][0];\\n                int b = edgeList[i][1];\\n                Union(a,b);\\n                i++;\\n            }\\n            if(find(queries[j][0]) == find(queries[j][1])){\\n                ans[queries[j][3]] = 1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\n// custom comparator to sort based on weight\\nbool comp(vector<int> &a,vector<int> &b){\\n    if(a[2] == b[2]){\\n        return a[1]<b[1];\\n    }\\n    return a[2]<b[2];\\n}\\n\\nclass Solution {\\npublic:\\n    \\n    // Union Find data structure\\n    \\n    int parent[100005];\\n    int sz[100005];\\n    \\n    void makeset(int v){\\n        parent[v] = v;\\n        sz[v] = 1;\\n    }\\n    int find(int v){\\n        if(parent[v] == v) return v;\\n        return parent[v] = find(parent[v]);\\n    }\\n    void Union(int x,int y){\\n        x = find(x);\\n        y = find(y);\\n        if(x == y) return;\\n        if(sz[x]>sz[y]) swap(x,y);\\n        parent[y] = x;\\n        sz[y]+=sz[x];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n        for(int i=0;i<n;i++) {\\n            makeset(i);\\n        }\\n        int m = queries.size();\\n        for(int i=0;i<queries.size();i++) {\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(queries.begin(),queries.end(),comp);\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        vector<bool> ans(queries.size(),false);\\n        int i=0;\\n        int j=0;\\n        // two pointer\\n        // building graph based on weights allowed by queries\\n        while(j<m){\\n            int wt = queries[j][2];\\n            \\n            while(i<edgeList.size() && edgeList[i][2]<wt){\\n                int a = edgeList[i][0];\\n                int b = edgeList[i][1];\\n                Union(a,b);\\n                i++;\\n            }\\n            if(find(queries[j][0]) == find(queries[j][1])){\\n                ans[queries[j][3]] = 1;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245317,
                "title": "beginner-level-intuition-development-for-any-offline-query-questions",
                "content": "In mostly every post in discuss everyone told the solution for this question.\\nBut no one exactly has told the offline query concept. So i have tried to tell and highlight my approach of seeing and identifying offline query type questions.\\n\\nHope it helps. Plz upvote if u like!\\n\\n**Intuition for Solving OFFLINE QUERIES QUESTION**\\n1. There will be first of all some `queries will be given`.\\n2. Then we should first consider of `solving a single query in the best optimized way`.\\n3. Then after applying the optimised approach found for a single querie in step2 , we will `apply it in every query and time complexity would be somewhat close to O(q.size() * N) because for every query we will be traversing whole array.`.\\n4. Now we should think about applying **offline query** and we need to observe below written type of a scenario for offline query.\\n\\n  ```\\n```\\n  ```\\nIn most of the case there would be some limit value would be given for every query.\\nThen we will see that:\\n\\t       For eg : <=7 will be also candidate for <=10 which will also be candidate for <=20 and so on.\\nIf we observe above type of  scenario in any query type question. Then we simply need to apply the offline query algorithm.\\n```\\n```\\n```\\n\\n>> **OUR MAIN FOCUS SHOULD ONLY BE ON `How to solve a single query in most efficient way` and secondly, `identifying whether it is a offline query type question or not by observing above scenarios`, because after identifying the algorithm for any offline type qery is approx same as below**\\n\\n\\n# Generic Algorithm for any OFFLINE QUERY TYPE QUESTION: \\n\\n           //put indexes in the query\\n\\t\\t   for(int i=0;i<q.size();i++) q[i].push_back(i);\\n\\t\\t   //sort the queries and input\\n           sort(begin(a),end(a));\\n           sort(begin(q),end(q),[](auto &x,auto &y){ return x[1] < y[1]; });\\n        \\n           int i=0;\\n           vector<int> ans(q.size());\\n        \\n           for(auto j:q){\\n                 int c= j[0], p=j[1], idx= j[2];\\n                for(;i<size(a) and a[i]<=p;i++) //call function for putting candidates of a single query\\'\\n\\t\\t\\t\\t//put answer of current query in its corresponding index number in the result array...\\n                if(i==0) ans[idx]=-1;\\n                else ans[idx]= //function for getting answer of single query \\n           } \\n        return ans;\\n\\n\\n\\n**Solution for this problem based on offline query concept** => C++\\n   \\n    class Solution {\\n    public:\\n\\n    class DSU{\\n        vector<int> par,rank;\\n        public:\\n        \\n        DSU(int n){\\n            par.resize(n);\\n            rank.resize(n,1);\\n            iota(begin(par),end(par),0);\\n        }\\n        \\n        int find(int u){\\n            if(par[u]==u) return u;\\n            else return par[u]= find(par[u]);\\n        }\\n        \\n        void union_p(int u,int v){\\n            u= find(u);\\n            v= find(v);\\n            \\n            if(rank[u]<rank[v]) par[u]=v;\\n            else if(rank[u]>rank[v]) par[v]=u;\\n            else{\\n                par[v]=u;\\n                rank[u]++;\\n            }\\n        }\\n    };\\n    \\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>&a, vector<vector<int>>& q) {\\n        \\n       DSU d(n);\\n       //Algofor offline queries\\n       for(int i=0;i<q.size();i++) q[i].push_back(i);\\n       //sort the queries and input\\n       sort(begin(a),end(a),[](auto &x,auto &y){ return x[2] < y[2]; });\\n       sort(begin(q),end(q),[](auto &x,auto &y){ return x[2] < y[2]; });\\n    \\n       int i=0;\\n       vector<bool> ans(q.size());\\n    \\n       for(auto j:q){\\n            int u= j[0], v=j[1], p=j[2], idx= j[3];\\n            for(;i<size(a) and a[i][2]<p;i++) d.union_p(a[i][0],a[i][1]);\\n            ans[idx]= (d.find(u)==d.find(v));\\n       } \\n       \\n       return ans;\\n        \\n    }\\n    };",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n```\n```\\nIn most of the case there would be some limit value would be given for every query.\\nThen we will see that:\\n\\t       For eg : <=7 will be also candidate for <=10 which will also be candidate for <=20 and so on.\\nIf we observe above type of  scenario in any query type question. Then we simply need to apply the offline query algorithm.\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2009290,
                "title": "python-union-find-simple-and-easy",
                "content": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        def find(v):\\n            if parent[v] != v:\\n                parent[v] = find(parent[v])\\n            return parent[v]\\n        def union(v, w):\\n            parent[find(v)] = find(w)\\n        edgeList.sort(key = lambda e: e[2])\\n        queries = sorted(((v,w,limit,i) for i, (v, w, limit) in enumerate(queries)), key = lambda e:e[2])\\n        parent = [i for i in range(n)]\\n        j = 0\\n        res = [0]*len(queries)\\n        for v,w,limit,i in queries:\\n            while j < len(edgeList) and edgeList[j][2] < limit:\\n                p, q, _ = edgeList[j]\\n                union(p,q)\\n                j += 1\\n            res[i] = find(v) == find(w)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        def find(v):\\n            if parent[v] != v:\\n                parent[v] = find(parent[v])\\n            return parent[v]\\n        def union(v, w):\\n            parent[find(v)] = find(w)\\n        edgeList.sort(key = lambda e: e[2])\\n        queries = sorted(((v,w,limit,i) for i, (v, w, limit) in enumerate(queries)), key = lambda e:e[2])\\n        parent = [i for i in range(n)]\\n        j = 0\\n        res = [0]*len(queries)\\n        for v,w,limit,i in queries:\\n            while j < len(edgeList) and edgeList[j][2] < limit:\\n                p, q, _ = edgeList[j]\\n                union(p,q)\\n                j += 1\\n            res[i] = find(v) == find(w)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1942762,
                "title": "java-simple-clear-and-concise-solution-with-templated-dsu",
                "content": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        Map<int[], Integer> position = new HashMap<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            position.put(queries[i], i);\\n        }\\n        \\n        Arrays.sort(queries, (a, b) -> a[2] - b[2]);\\n        \\n        DSU dsu = new DSU(n);\\n        boolean[] ans = new boolean[queries.length];\\n        int j = 0;\\n        \\n        for (int[] q : queries) {\\n            int limit = q[2];\\n            \\n            while(j < edgeList.length && edgeList[j][2] < limit) {\\n                dsu.union(edgeList[j][0], edgeList[j][1]);\\n                j++;\\n            }\\n            \\n            ans[position.get(q)] = dsu.isConnected(q[0], q[1]);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n```\\n\\n<br><br><br><br>\\n\\t\\n\\tHere\\'s the standard DSU template used, I have solved most of the DSU problems using the below template :)\\n\\t\\n<br><br><br><br><br>\\n\\n\\n```\\n    \\n    class DSU {\\n        int[] root;\\n        int[] rank;\\n        \\n        public DSU (int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            if (root[x] == x) return x;\\n            return root[x] = find(root[x]);\\n        }\\n        \\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            if (rootX == rootY) return;\\n            \\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                rank[rootX] += rank[rootY];\\n                \\n            } else {\\n                root[rootX] = rootY;\\n                rank[rootY] += rank[rootX];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y) {\\n            return find(x) == find(y);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        Map<int[], Integer> position = new HashMap<>();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            position.put(queries[i], i);\\n        }\\n        \\n        Arrays.sort(queries, (a, b) -> a[2] - b[2]);\\n        \\n        DSU dsu = new DSU(n);\\n        boolean[] ans = new boolean[queries.length];\\n        int j = 0;\\n        \\n        for (int[] q : queries) {\\n            int limit = q[2];\\n            \\n            while(j < edgeList.length && edgeList[j][2] < limit) {\\n                dsu.union(edgeList[j][0], edgeList[j][1]);\\n                j++;\\n            }\\n            \\n            ans[position.get(q)] = dsu.isConnected(q[0], q[1]);\\n        }\\n        \\n        return ans;\\n    }\\n\\t\\n```\n```\\n    \\n    class DSU {\\n        int[] root;\\n        int[] rank;\\n        \\n        public DSU (int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            \\n            for (int i = 0; i < n; i++) {\\n                root[i] = i;\\n                rank[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x) {\\n            if (root[x] == x) return x;\\n            return root[x] = find(root[x]);\\n        }\\n        \\n        public void union(int x, int y) {\\n            int rootX = find(x);\\n            int rootY = find(y);\\n            \\n            if (rootX == rootY) return;\\n            \\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                rank[rootX] += rank[rootY];\\n                \\n            } else {\\n                root[rootX] = rootY;\\n                rank[rootY] += rank[rootX];\\n            }\\n        }\\n        \\n        public boolean isConnected(int x, int y) {\\n            return find(x) == find(y);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395808,
                "title": "java-passes-all-test-cases-union-find",
                "content": "```\\nclass Solution {\\n        public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n            int[] parent = new int[n];\\n\\n            for (int i = 0; i < n; ++i) {\\n                parent[i] = i;\\n            }\\n\\n            // Sort the edges in the provided graph based on distance.\\n            Arrays.sort(edgeList, Comparator.comparing(a -> Integer.valueOf(a[2])));\\n\\n            // Sort queries in increasing order of distance.\\n            List<int[]> q = new ArrayList<>();\\n            for (int i = 0; i < queries.length; ++i) {\\n                int[] entry = new int[4];\\n                entry[0] = queries[i][0]; // Start index\\n                entry[1] = queries[i][1]; // End Index\\n                entry[2] = queries[i][2]; // Threshold\\n                entry[3] = i; //\\n\\n                q.add(entry);\\n            }\\n\\n            q.sort(Comparator.comparing(a -> a[2]));\\n\\n            int index = 0;\\n            boolean[] result = new boolean[q.size()];\\n            for (var entry : q) {\\n                int threshold = entry[2];\\n                //\\n                while (index < edgeList.length && edgeList[index][2] < threshold) {\\n                    union(parent, edgeList[index][0], edgeList[index][1]);\\n                    ++index;\\n                }\\n\\n                result[entry[3]] = find(parent, entry[0]) == find(parent, entry[1]);\\n            }\\n\\n            return result;\\n        }\\n\\n        // O(Log(N))\\n        int find(int[] parent, int ind) {\\n            if (parent[ind] != ind) {\\n                return find(parent, parent[ind]);\\n            }\\n\\n            return ind;\\n        }\\n\\n        // O(Log(N))\\n        void union(int[] parent, int x, int y) {\\n            int p1 = find(parent, x);\\n            int p2 = find(parent, y);\\n            parent[p1] = p2;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n            int[] parent = new int[n];\\n\\n            for (int i = 0; i < n; ++i) {\\n                parent[i] = i;\\n            }\\n\\n            // Sort the edges in the provided graph based on distance.\\n            Arrays.sort(edgeList, Comparator.comparing(a -> Integer.valueOf(a[2])));\\n\\n            // Sort queries in increasing order of distance.\\n            List<int[]> q = new ArrayList<>();\\n            for (int i = 0; i < queries.length; ++i) {\\n                int[] entry = new int[4];\\n                entry[0] = queries[i][0]; // Start index\\n                entry[1] = queries[i][1]; // End Index\\n                entry[2] = queries[i][2]; // Threshold\\n                entry[3] = i; //\\n\\n                q.add(entry);\\n            }\\n\\n            q.sort(Comparator.comparing(a -> a[2]));\\n\\n            int index = 0;\\n            boolean[] result = new boolean[q.size()];\\n            for (var entry : q) {\\n                int threshold = entry[2];\\n                //\\n                while (index < edgeList.length && edgeList[index][2] < threshold) {\\n                    union(parent, edgeList[index][0], edgeList[index][1]);\\n                    ++index;\\n                }\\n\\n                result[entry[3]] = find(parent, entry[0]) == find(parent, entry[1]);\\n            }\\n\\n            return result;\\n        }\\n\\n        // O(Log(N))\\n        int find(int[] parent, int ind) {\\n            if (parent[ind] != ind) {\\n                return find(parent, parent[ind]);\\n            }\\n\\n            return ind;\\n        }\\n\\n        // O(Log(N))\\n        void union(int[] parent, int x, int y) {\\n            int p1 = find(parent, x);\\n            int p2 = find(parent, y);\\n            parent[p1] = p2;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050269,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    private static class DisJointSet{\\n        int val;\\n        DisJointSet par;\\n        public DisJointSet(int value){\\n            this.val = value;\\n            this.par = this;\\n        }\\n    }\\n\\n    private void union(DisJointSet set1, DisJointSet set2){ set1.par = set2; }\\n\\n    private DisJointSet find(DisJointSet set){\\n        if(set.par == set) return set;\\n        return set.par = find(set.par);\\n    }\\n\\n    private HashMap<Integer, DisJointSet> hashMap = new HashMap<>();\\n    private HashMap<DisJointSet, Set<Integer>> nodeMap = new HashMap();\\n    private int nodes;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        nodes = n;\\n        for (int i = 0; i < nodes; i++)\\n            hashMap.put(i, new DisJointSet(i));\\n        //sort edges by weight - this is trivial thing to begin Kruskal\\n        Arrays.sort(edgeList, Comparator.comparingInt(arr -> arr[2]));\\n        \\n        //mark index along with query - not a better way as it use space ---use hashmap or something\\n        int[][] queriesWithIdx = new int[queries.length][];\\n        for (int idx = 0; idx < queries.length; idx++) {\\n            int[] query = queries[idx];\\n            int[] nquery = new int[]{query[0], query[1], query[2],idx};\\n            queriesWithIdx[idx] = nquery;\\n        }\\n        \\n        //sort queries by cost so that we will use edges only till that cost threshold to build MST\\n        Arrays.sort(queriesWithIdx, Comparator.comparingInt(arr -> arr[2]));\\n        boolean[] res = new boolean[queries.length];\\n        int prev = 0;\\n        for (int[] query : queriesWithIdx){\\n            int costThreshold = query[2];\\n            for (int i = prev; i < edgeList.length; i++){\\n                if(edgeList[i][2] >= costThreshold){\\n                    //record the prev index , so that next run of kruskal should start from edge from that index\\n                    prev = i;\\n                    break;\\n                }\\n                int u = edgeList[i][0];\\n                int v = edgeList[i][1];\\n                union(find(hashMap.get(u)), find(hashMap.get(v)));\\n            }\\n            //after doing a kruskal on limites set of edges bound by constraint , check if the u and v are in same set or not\\n            if(find(hashMap.get(query[0])) == find(hashMap.get(query[1]))){\\n                res[query[3]] = true;\\n            }else\\n                res[query[3]] = false;\\n        }\\n\\n        \\n        return  res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static class DisJointSet{\\n        int val;\\n        DisJointSet par;\\n        public DisJointSet(int value){\\n            this.val = value;\\n            this.par = this;\\n        }\\n    }\\n\\n    private void union(DisJointSet set1, DisJointSet set2){ set1.par = set2; }\\n\\n    private DisJointSet find(DisJointSet set){\\n        if(set.par == set) return set;\\n        return set.par = find(set.par);\\n    }\\n\\n    private HashMap<Integer, DisJointSet> hashMap = new HashMap<>();\\n    private HashMap<DisJointSet, Set<Integer>> nodeMap = new HashMap();\\n    private int nodes;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        nodes = n;\\n        for (int i = 0; i < nodes; i++)\\n            hashMap.put(i, new DisJointSet(i));\\n        //sort edges by weight - this is trivial thing to begin Kruskal\\n        Arrays.sort(edgeList, Comparator.comparingInt(arr -> arr[2]));\\n        \\n        //mark index along with query - not a better way as it use space ---use hashmap or something\\n        int[][] queriesWithIdx = new int[queries.length][];\\n        for (int idx = 0; idx < queries.length; idx++) {\\n            int[] query = queries[idx];\\n            int[] nquery = new int[]{query[0], query[1], query[2],idx};\\n            queriesWithIdx[idx] = nquery;\\n        }\\n        \\n        //sort queries by cost so that we will use edges only till that cost threshold to build MST\\n        Arrays.sort(queriesWithIdx, Comparator.comparingInt(arr -> arr[2]));\\n        boolean[] res = new boolean[queries.length];\\n        int prev = 0;\\n        for (int[] query : queriesWithIdx){\\n            int costThreshold = query[2];\\n            for (int i = prev; i < edgeList.length; i++){\\n                if(edgeList[i][2] >= costThreshold){\\n                    //record the prev index , so that next run of kruskal should start from edge from that index\\n                    prev = i;\\n                    break;\\n                }\\n                int u = edgeList[i][0];\\n                int v = edgeList[i][1];\\n                union(find(hashMap.get(u)), find(hashMap.get(v)));\\n            }\\n            //after doing a kruskal on limites set of edges bound by constraint , check if the u and v are in same set or not\\n            if(find(hashMap.get(query[0])) == find(hashMap.get(query[1]))){\\n                res[query[3]] = true;\\n            }else\\n                res[query[3]] = false;\\n        }\\n\\n        \\n        return  res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978679,
                "title": "javascript-union-find",
                "content": "Sort the query and edgeLists by limit. Start from the strictest limit.\\n\\n```\\nvar distanceLimitedPathsExist = function (n, edgeList, queries) {\\n  queries = queries.map((n, i) => [...n, i]).sort((a, b) => a[2] - b[2]);\\n  edgeList.sort((a, b) => a[2] - b[2]);\\n  \\n  const res = Array(queries.length);\\n  const ds = new DS(n);\\n  \\n  let j = 0;\\n  for (let [p, q, limit, i] of queries) {\\n    while (j < edgeList.length && edgeList[j][2] < limit) {\\n      const [u, v, dis] = edgeList[j];\\n      ds.union(u, v);\\n      j++;\\n    }\\n    res[i] = ds.find(p) === ds.find(q);\\n  }\\n  \\n  return res;\\n};\\n\\nclass DS {\\n  constructor(n) {\\n    this.id = [...Array(n).keys()];\\n    this.rank = Array(n).fill(0);\\n  }\\n  \\n  find(i) {\\n    if (i !== this.id[i]) this.id[i] = this.find(this.id[i]);\\n    return this.id[i];\\n  }\\n  \\n  union(i, j) {\\n    const [I, J] = [this.find(i), this.find(j)];\\n    if (I === J) return false;\\n    const [rankI, rankJ] = [this.rank[I], this.rank[J]];\\n    if (rankI < rankJ) this.id[I] = J;\\n    else if (rankI > rankJ) this.id[J] = I;\\n    else {\\n      this.id[I] = J;\\n      this.rank[J]++;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar distanceLimitedPathsExist = function (n, edgeList, queries) {\\n  queries = queries.map((n, i) => [...n, i]).sort((a, b) => a[2] - b[2]);\\n  edgeList.sort((a, b) => a[2] - b[2]);\\n  \\n  const res = Array(queries.length);\\n  const ds = new DS(n);\\n  \\n  let j = 0;\\n  for (let [p, q, limit, i] of queries) {\\n    while (j < edgeList.length && edgeList[j][2] < limit) {\\n      const [u, v, dis] = edgeList[j];\\n      ds.union(u, v);\\n      j++;\\n    }\\n    res[i] = ds.find(p) === ds.find(q);\\n  }\\n  \\n  return res;\\n};\\n\\nclass DS {\\n  constructor(n) {\\n    this.id = [...Array(n).keys()];\\n    this.rank = Array(n).fill(0);\\n  }\\n  \\n  find(i) {\\n    if (i !== this.id[i]) this.id[i] = this.find(this.id[i]);\\n    return this.id[i];\\n  }\\n  \\n  union(i, j) {\\n    const [I, J] = [this.find(i), this.find(j)];\\n    if (I === J) return false;\\n    const [rankI, rankJ] = [this.rank[I], this.rank[J]];\\n    if (rankI < rankJ) this.id[I] = J;\\n    else if (rankI > rankJ) this.id[J] = I;\\n    else {\\n      this.id[I] = J;\\n      this.rank[J]++;\\n    }\\n    return true;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978669,
                "title": "python-union-find",
                "content": "The key idea is to populate the union-find data structure as we answer queries ordered by the allowed edge cost, from smallest to biggest. Any connection under that cost is allowed to go into our structure.\\n```\\nclass UnionFind:\\n\\n    def __init__(self, size):\\n        self.size = size\\n        self.parents = list(range(size))\\n        self.sizes = [0] * size\\n    \\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx == rooty: return\\n        small, big = (rootx, rooty) if self.sizes[rootx] < self.sizes[rooty] else (rooty, rootx)\\n        self.parents[small] = big\\n    \\n    def find(self, x):\\n        if self.parents[x] != x:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        uf = UnionFind(n)\\n        \\n        edgeList.sort(key=lambda x: x[2])\\n        answers = [None] * len(queries)\\n        queries = [(l, s, d, i) for i, (s, d, l) in enumerate(queries)]\\n        queries.sort(key=lambda x:x[0])\\n        \\n        eidx = 0\\n        for limit, src, dest, q_idx in queries:\\n            while eidx < len(edgeList) and edgeList[eidx][2] < limit:\\n                uf.union(edgeList[eidx][0], edgeList[eidx][1])\\n                eidx += 1\\n            \\n            answers[q_idx] = uf.find(src) == uf.find(dest)\\n        \\n        return answers\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n\\n    def __init__(self, size):\\n        self.size = size\\n        self.parents = list(range(size))\\n        self.sizes = [0] * size\\n    \\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx == rooty: return\\n        small, big = (rootx, rooty) if self.sizes[rootx] < self.sizes[rooty] else (rooty, rootx)\\n        self.parents[small] = big\\n    \\n    def find(self, x):\\n        if self.parents[x] != x:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        uf = UnionFind(n)\\n        \\n        edgeList.sort(key=lambda x: x[2])\\n        answers = [None] * len(queries)\\n        queries = [(l, s, d, i) for i, (s, d, l) in enumerate(queries)]\\n        queries.sort(key=lambda x:x[0])\\n        \\n        eidx = 0\\n        for limit, src, dest, q_idx in queries:\\n            while eidx < len(edgeList) and edgeList[eidx][2] < limit:\\n                uf.union(edgeList[eidx][0], edgeList[eidx][1])\\n                eidx += 1\\n            \\n            answers[q_idx] = uf.find(src) == uf.find(dest)\\n        \\n        return answers\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978468,
                "title": "python-union-find",
                "content": "Sort `E`.\\nSort `Q` but only get indices.\\nGradually add edges in sorted `E` based on sorted `Q`.\\nCheck if the given query nodes are connected.\\nEssentially union-find.\\n\\n```python\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, E, Q):\\n        #this part is union-find\\n        def find(i):\\n            if i != root[i]:\\n                root[i] = find(root[i])\\n            return root[i]\\n\\n        def uni(x, y):\\n            x, y = find(x), find(y)\\n            if x == y: return 0\\n            root[x] = y\\n            return 1\\n        \\n        root = list(range(n))\\n        \\n        #this will be the answer\\n        ans = [False]*len(Q)\\n        \\n        #sort edges based on cost\\n        i = 0\\n        E.sort(key=lambda x: x[2])\\n        \\n        #don\\'t sort Q, but get the sorted list of queries in ix_all\\n        q = [x[2] for x in Q]\\n        ix_all = sorted(range(len(q)), key=q.__getitem__)\\n        for ix in ix_all: #loop over sorted indices of Q\\n            #add all edges that satisfy cost requirement\\n            while i<len(E) and E[i][2]<Q[ix][2]:\\n                x, y = E[i][0], E[i][1]\\n                i += 1\\n                uni(x,y)\\n            \\n            #check if the query nodes are connected\\n            if find(Q[ix][0]) == find(Q[ix][1]):\\n                ans[ix] = True\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, E, Q):\\n        #this part is union-find\\n        def find(i):\\n            if i != root[i]:\\n                root[i] = find(root[i])\\n            return root[i]\\n\\n        def uni(x, y):\\n            x, y = find(x), find(y)\\n            if x == y: return 0\\n            root[x] = y\\n            return 1\\n        \\n        root = list(range(n))\\n        \\n        #this will be the answer\\n        ans = [False]*len(Q)\\n        \\n        #sort edges based on cost\\n        i = 0\\n        E.sort(key=lambda x: x[2])\\n        \\n        #don\\'t sort Q, but get the sorted list of queries in ix_all\\n        q = [x[2] for x in Q]\\n        ix_all = sorted(range(len(q)), key=q.__getitem__)\\n        for ix in ix_all: #loop over sorted indices of Q\\n            #add all edges that satisfy cost requirement\\n            while i<len(E) and E[i][2]<Q[ix][2]:\\n                x, y = E[i][0], E[i][1]\\n                i += 1\\n                uni(x,y)\\n            \\n            #check if the query nodes are connected\\n            if find(Q[ix][0]) == find(Q[ix][1]):\\n                ans[ix] = True\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007149,
                "title": "concise-and-clean",
                "content": "\\n```\\nclass Solution {\\n    int p[];\\n    int find(int a) { return p[a]==a? a: (p[a]=find(p[a])); }\\n    void union(int a, int b) { p[find(b)]=p[find(a)]; }\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        p=new int[n]; for(int i=0;i<n;p[i]=i++);\\n        Arrays.sort(edgeList, (a,b)->a[2]-b[2]);\\n        for(int i=0;i<queries.length; queries[i]=new int[]{queries[i][0], queries[i][1], queries[i][2], i}, ++i); \\n        Arrays.sort(queries, (a,b)->a[2]-b[2]);\\n\\n        boolean[] res=new boolean[queries.length];\\n        int i=0;\\n        for(int[] q: queries) {\\n            while(i<edgeList.length && edgeList[i][2] < q[2]) union(edgeList[i][0], edgeList[i++][1]);\\n            res[q[3]]=find(q[0])==find(q[1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int p[];\\n    int find(int a) { return p[a]==a? a: (p[a]=find(p[a])); }\\n    void union(int a, int b) { p[find(b)]=p[find(a)]; }\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        p=new int[n]; for(int i=0;i<n;p[i]=i++);\\n        Arrays.sort(edgeList, (a,b)->a[2]-b[2]);\\n        for(int i=0;i<queries.length; queries[i]=new int[]{queries[i][0], queries[i][1], queries[i][2], i}, ++i); \\n        Arrays.sort(queries, (a,b)->a[2]-b[2]);\\n\\n        boolean[] res=new boolean[queries.length];\\n        int i=0;\\n        for(int[] q: queries) {\\n            while(i<edgeList.length && edgeList[i][2] < q[2]) union(edgeList[i][0], edgeList[i++][1]);\\n            res[q[3]]=find(q[0])==find(q[1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484652,
                "title": "easy",
                "content": "\\n# Code\\n```\\nclass DisjointSet {\\nprivate:\\n    vector<int> parent, rank;\\n\\npublic:\\n    DisjointSet(int n) {\\n        parent.resize(n+1, 0);\\n        rank.resize(n+1, 0);\\n\\n        for(int i=0; i<n+1; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int node) {\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int upU = findParent(u);\\n        int upV = findParent(v);\\n\\n        if(upU == upV)\\n            return;\\n        \\n        if(rank[upU] < rank[upV]) {\\n            parent[upU] = upV;\\n        }\\n        else {\\n            parent[upV] = upU;\\n            rank[upU]++;\\n        }\\n    }\\n\\n    bool isParentEqual(int u, int v) {\\n        return (findParent(u) == findParent(v));\\n    }\\n};\\n\\nclass Solution {\\n    bool static compare(const vector<int> &a, const vector<int> &b) {\\n        return (a[2] < b[2]);\\n    }\\n\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int nodes, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int n = queries.size();\\n\\n        vector<bool> ans(n, false);\\n        \\n        for(int i=0; i<n; i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(edges.begin(), edges.end(), compare);\\n        sort(queries.begin(), queries.end(), compare);\\n\\n        DisjointSet ds(nodes);\\n        int i=0;\\n\\n        for(auto &query : queries) {\\n            int u = query[0];\\n            int v = query[1];\\n            int limit = query[2];\\n            int qId = query[3];\\n\\n            for(; (i < edges.size()) && (edges[i][2] < limit); i++) {\\n                ds.unionByRank(edges[i][0], edges[i][1]);\\n            }\\n            ans[qId] = ds.isParentEqual(u, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\nprivate:\\n    vector<int> parent, rank;\\n\\npublic:\\n    DisjointSet(int n) {\\n        parent.resize(n+1, 0);\\n        rank.resize(n+1, 0);\\n\\n        for(int i=0; i<n+1; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findParent(int node) {\\n        if(node == parent[node])\\n            return node;\\n        \\n        return parent[node] = findParent(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int upU = findParent(u);\\n        int upV = findParent(v);\\n\\n        if(upU == upV)\\n            return;\\n        \\n        if(rank[upU] < rank[upV]) {\\n            parent[upU] = upV;\\n        }\\n        else {\\n            parent[upV] = upU;\\n            rank[upU]++;\\n        }\\n    }\\n\\n    bool isParentEqual(int u, int v) {\\n        return (findParent(u) == findParent(v));\\n    }\\n};\\n\\nclass Solution {\\n    bool static compare(const vector<int> &a, const vector<int> &b) {\\n        return (a[2] < b[2]);\\n    }\\n\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int nodes, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int n = queries.size();\\n\\n        vector<bool> ans(n, false);\\n        \\n        for(int i=0; i<n; i++) {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(edges.begin(), edges.end(), compare);\\n        sort(queries.begin(), queries.end(), compare);\\n\\n        DisjointSet ds(nodes);\\n        int i=0;\\n\\n        for(auto &query : queries) {\\n            int u = query[0];\\n            int v = query[1];\\n            int limit = query[2];\\n            int qId = query[3];\\n\\n            for(; (i < edges.size()) && (edges[i][2] < limit); i++) {\\n                ds.unionByRank(edges[i][0], edges[i][1]);\\n            }\\n            ans[qId] = ds.isParentEqual(u, v);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470387,
                "title": "rub-go-disjoint-set-union-leetcode-s-solution-translation",
                "content": "## Leetcode: 1697. Checking Existence of Edge Length Limited Paths.\\n\\n**Ruby/Go: Disjoint-Set Union. Leetcode\\'s soltuoin translation.**\\n\\nRuby and Go transltion of the Leetcode\\'s [solution](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solution/).\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1697. Checking Existence of Edge Length Limited Paths.\\n# https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 726 ms, faster than 100.00% of Ruby online submissions for Checking\\n# Existence of Edge Length Limited Paths.\\n# Memory Usage: 247.5 MB, less than 100.00% of Ruby online submissions for\\n# Checking Existence of Edge Length Limited Paths.\\n# 2023.04.29 Daily Challenge.\\n# @param {Integer} n\\n# @param {Integer[][]} edge_list\\n# @param {Integer[][]} queries\\n# @return {Boolean[]}\\nclass Uf\\n  def initialize(size)\\n    @g = Array.new(size).map.with_index{|x,i| i} \\n    @r = []\\n  end\\n  def find(n)\\n    if @g[n] != n\\n      @g[n] = find(@g[n])\\n    end\\n    @g[n]\\n  end\\n  def join(n1,n2)\\n    g1 = find(n1)\\n    g2 = find(n2)\\n    return if g1 == g2\\n    @r[g1] ||= 0\\n    @r[g2] ||= 0\\n    if @r[g1] > @r[g2]\\n      @g[g2] = g1\\n    elsif @r[g1] < @r[g2]\\n      @g[g1] = g2\\n    else\\n      @g[g1] = g2\\n      @r[g2] ||= 0\\n      @r[g2] += 1\\n    end\\n  end\\n  def con(n1,n2)\\n    g1 = find(n1)\\n    g2 = find(n2)\\n    g1 == g2\\n  end\\nend\\ndef distance_limited_paths_exist(n, edge_list, queries)\\n  # Based on:\\n  # https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solution/\\n  uf = Uf.new(n)\\n  qc = queries.size\\n  ans = Array.new(qc,false)\\n\\n  # Store original inicies with all queries.\\n  qwi = [] # Queries with index.\\n  qc.times do |i|\\n    qwi[i] = queries[i]\\n    qwi[i].push(i)\\n  end\\n\\n  # Sort all edges in increasing order of their edge weights.\\n  edge_list.sort!{|a,b| a[2] - b[2]}\\n  # Sort all queries in increasing order of the limit of edge allowed.\\n  qwi.sort!{|a,b| a[2] - b[2]}\\n\\n  # ei - edges index.\\n  ei = 0\\n\\n  # qoi - Query original index.\\n  # l - limit.\\n  # Iterate on each query one by one.\\n  qwi.each do |pe,q,l,qoi|\\n    # We can attach edges with satisfy the limit given by the query.\\n    while ei < edge_list.size && edge_list[ei][2] < l\\n      n1 = edge_list[ei][0]\\n      n2 = edge_list[ei][1]\\n      uf.join(n1,n2)\\n      ei += 1\\n    end\\n\\n    # If both nodes belong to the same component, it means we can reach them.\\n    ans[qoi] = uf.con(pe,q)\\n  end\\n\\n  return ans\\nend\\n```\\n\\nGo code:\\n```Go\\n// Leetcode: 1697. Checking Existence of Edge Length Limited Paths.\\n// https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/\\n// = = = = = = = = = = = = = =\\n// Accepted.\\n// Thanks God, Jesus Christ!\\n// = = = = = = = = = = = = = =\\n// Runtime: 336 ms, faster than 66.67% of Go online submissions for Checking\\n// Existence of Edge Length Limited Paths.\\n// Memory Usage: 17.6 MB, less than 33.33% of Go online submissions for Checking\\n// Existence of Edge Length Limited Paths.\\n// 2023.04.30 Updated.\\npackage main\\n\\n// import \"sort\"\\n// Line 5: Char 8: sort redeclared in this block (solution.go)\\n// Line -2: Char 2: other declaration of sort (solution.go)\\n// Line 5: Char 8: imported and not used: \"sort\" (solution.go)\\n\\ntype unfn struct {\\n\\tg []int\\n\\tr []int\\n}\\n\\nfunc (t *unfn) find(n int) int {\\n\\tif n != t.g[n] {\\n\\t\\tt.g[n] = t.find(t.g[n])\\n\\t}\\n\\treturn t.g[n]\\n}\\n\\nfunc (t *unfn) join(n1, n2 int) {\\n\\tg1, g2 := t.find(n1), t.find(n2)\\n\\tif g1 == g2 {\\n\\t\\treturn\\n\\t}\\n\\tif t.r[g1] > t.r[g2] {\\n\\t\\tt.g[g2] = g1\\n\\t} else if t.r[g1] < t.r[g2] {\\n\\t\\tt.g[g1] = g2\\n\\t} else {\\n\\t\\tt.g[g1] = g2\\n\\t\\tt.r[g2] += 1\\n\\t}\\n}\\n\\nfunc (t *unfn) con(n1, n2 int) bool {\\n\\tg1, g2 := t.find(n1), t.find(n2)\\n\\treturn g1 == g2\\n}\\n\\nfunc newUn(n int) *unfn {\\n\\tx := unfn{}\\n\\tx.g = make([]int, n)\\n\\tx.r = make([]int, n)\\n\\tfor i := 0; i < n; i += 1 {\\n\\t\\tx.g[i] = i\\n\\t}\\n\\treturn &x\\n}\\n\\nfunc distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n\\n\\t// Based on the Leetcode\\'s solution.\\n\\n\\tuf := newUn(n)\\n\\tqc := len(queries)\\n\\tans := make([]bool, qc)\\n\\n\\t// Store original incides with all quieres.\\n\\tqwi := make([][]int, qc)\\n\\tfor i, _ := range qwi {\\n\\t\\tqwi[i] = make([]int, len(queries[i])+1)\\n\\t\\tfor j, v1 := range queries[i] {\\n\\t\\t\\tqwi[i][j] = v1\\n\\t\\t}\\n\\t\\tqwi[i][len(queries[i])] = i\\n\\t}\\n\\t// Sort all edges in increasing order of their edge weights.\\n\\tsort.Slice(edgeList, func(i, j int) bool {\\n\\t\\ta, b := edgeList[i], edgeList[j]\\n\\t\\treturn a[2] < b[2]\\n\\t})\\n\\t// Sort all queries in increasing orderof the limit of edge allowed.\\n\\tsort.Slice(qwi, func(i, j int) bool {\\n\\t\\ta, b := qwi[i], qwi[j]\\n\\t\\treturn a[2] < b[2]\\n\\t})\\n\\t// ei - edges index.\\n\\tei := 0\\n\\te := edgeList\\n\\tel := len(edgeList)\\n\\n\\t// qoi - Query original index.\\n\\t// l - limit.\\n\\t// Iterate on each query one by one.\\n\\tfor _, v := range qwi {\\n\\t\\tpe, q, l, qoi := v[0], v[1], v[2], v[3]\\n\\t\\tfor ei < el && e[ei][2] < l {\\n\\t\\t\\tn1 := e[ei][0]\\n\\t\\t\\tn2 := e[ei][1]\\n\\t\\t\\tuf.join(n1, n2)\\n\\t\\t\\tei += 1\\n\\t\\t}\\n\\t\\t// If both nodes belong to the same component, it means we can reach\\n\\t\\t// them.\\n\\t\\tans[qoi] = uf.con(pe, q)\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Go"
                ],
                "code": "```Ruby\\n# Leetcode: 1697. Checking Existence of Edge Length Limited Paths.\\n# https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/\\n# = = = = = = = = = = = = = =\\n# Accepted.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# Runtime: 726 ms, faster than 100.00% of Ruby online submissions for Checking\\n# Existence of Edge Length Limited Paths.\\n# Memory Usage: 247.5 MB, less than 100.00% of Ruby online submissions for\\n# Checking Existence of Edge Length Limited Paths.\\n# 2023.04.29 Daily Challenge.\\n# @param {Integer} n\\n# @param {Integer[][]} edge_list\\n# @param {Integer[][]} queries\\n# @return {Boolean[]}\\nclass Uf\\n  def initialize(size)\\n    @g = Array.new(size).map.with_index{|x,i| i} \\n    @r = []\\n  end\\n  def find(n)\\n    if @g[n] != n\\n      @g[n] = find(@g[n])\\n    end\\n    @g[n]\\n  end\\n  def join(n1,n2)\\n    g1 = find(n1)\\n    g2 = find(n2)\\n    return if g1 == g2\\n    @r[g1] ||= 0\\n    @r[g2] ||= 0\\n    if @r[g1] > @r[g2]\\n      @g[g2] = g1\\n    elsif @r[g1] < @r[g2]\\n      @g[g1] = g2\\n    else\\n      @g[g1] = g2\\n      @r[g2] ||= 0\\n      @r[g2] += 1\\n    end\\n  end\\n  def con(n1,n2)\\n    g1 = find(n1)\\n    g2 = find(n2)\\n    g1 == g2\\n  end\\nend\\ndef distance_limited_paths_exist(n, edge_list, queries)\\n  # Based on:\\n  # https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solution/\\n  uf = Uf.new(n)\\n  qc = queries.size\\n  ans = Array.new(qc,false)\\n\\n  # Store original inicies with all queries.\\n  qwi = [] # Queries with index.\\n  qc.times do |i|\\n    qwi[i] = queries[i]\\n    qwi[i].push(i)\\n  end\\n\\n  # Sort all edges in increasing order of their edge weights.\\n  edge_list.sort!{|a,b| a[2] - b[2]}\\n  # Sort all queries in increasing order of the limit of edge allowed.\\n  qwi.sort!{|a,b| a[2] - b[2]}\\n\\n  # ei - edges index.\\n  ei = 0\\n\\n  # qoi - Query original index.\\n  # l - limit.\\n  # Iterate on each query one by one.\\n  qwi.each do |pe,q,l,qoi|\\n    # We can attach edges with satisfy the limit given by the query.\\n    while ei < edge_list.size && edge_list[ei][2] < l\\n      n1 = edge_list[ei][0]\\n      n2 = edge_list[ei][1]\\n      uf.join(n1,n2)\\n      ei += 1\\n    end\\n\\n    # If both nodes belong to the same component, it means we can reach them.\\n    ans[qoi] = uf.con(pe,q)\\n  end\\n\\n  return ans\\nend\\n```\n```Go\\n// Leetcode: 1697. Checking Existence of Edge Length Limited Paths.\\n// https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/\\n// = = = = = = = = = = = = = =\\n// Accepted.\\n// Thanks God, Jesus Christ!\\n// = = = = = = = = = = = = = =\\n// Runtime: 336 ms, faster than 66.67% of Go online submissions for Checking\\n// Existence of Edge Length Limited Paths.\\n// Memory Usage: 17.6 MB, less than 33.33% of Go online submissions for Checking\\n// Existence of Edge Length Limited Paths.\\n// 2023.04.30 Updated.\\npackage main\\n\\n// import \"sort\"\\n// Line 5: Char 8: sort redeclared in this block (solution.go)\\n// Line -2: Char 2: other declaration of sort (solution.go)\\n// Line 5: Char 8: imported and not used: \"sort\" (solution.go)\\n\\ntype unfn struct {\\n\\tg []int\\n\\tr []int\\n}\\n\\nfunc (t *unfn) find(n int) int {\\n\\tif n != t.g[n] {\\n\\t\\tt.g[n] = t.find(t.g[n])\\n\\t}\\n\\treturn t.g[n]\\n}\\n\\nfunc (t *unfn) join(n1, n2 int) {\\n\\tg1, g2 := t.find(n1), t.find(n2)\\n\\tif g1 == g2 {\\n\\t\\treturn\\n\\t}\\n\\tif t.r[g1] > t.r[g2] {\\n\\t\\tt.g[g2] = g1\\n\\t} else if t.r[g1] < t.r[g2] {\\n\\t\\tt.g[g1] = g2\\n\\t} else {\\n\\t\\tt.g[g1] = g2\\n\\t\\tt.r[g2] += 1\\n\\t}\\n}\\n\\nfunc (t *unfn) con(n1, n2 int) bool {\\n\\tg1, g2 := t.find(n1), t.find(n2)\\n\\treturn g1 == g2\\n}\\n\\nfunc newUn(n int) *unfn {\\n\\tx := unfn{}\\n\\tx.g = make([]int, n)\\n\\tx.r = make([]int, n)\\n\\tfor i := 0; i < n; i += 1 {\\n\\t\\tx.g[i] = i\\n\\t}\\n\\treturn &x\\n}\\n\\nfunc distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n\\n\\t// Based on the Leetcode\\'s solution.\\n\\n\\tuf := newUn(n)\\n\\tqc := len(queries)\\n\\tans := make([]bool, qc)\\n\\n\\t// Store original incides with all quieres.\\n\\tqwi := make([][]int, qc)\\n\\tfor i, _ := range qwi {\\n\\t\\tqwi[i] = make([]int, len(queries[i])+1)\\n\\t\\tfor j, v1 := range queries[i] {\\n\\t\\t\\tqwi[i][j] = v1\\n\\t\\t}\\n\\t\\tqwi[i][len(queries[i])] = i\\n\\t}\\n\\t// Sort all edges in increasing order of their edge weights.\\n\\tsort.Slice(edgeList, func(i, j int) bool {\\n\\t\\ta, b := edgeList[i], edgeList[j]\\n\\t\\treturn a[2] < b[2]\\n\\t})\\n\\t// Sort all queries in increasing orderof the limit of edge allowed.\\n\\tsort.Slice(qwi, func(i, j int) bool {\\n\\t\\ta, b := qwi[i], qwi[j]\\n\\t\\treturn a[2] < b[2]\\n\\t})\\n\\t// ei - edges index.\\n\\tei := 0\\n\\te := edgeList\\n\\tel := len(edgeList)\\n\\n\\t// qoi - Query original index.\\n\\t// l - limit.\\n\\t// Iterate on each query one by one.\\n\\tfor _, v := range qwi {\\n\\t\\tpe, q, l, qoi := v[0], v[1], v[2], v[3]\\n\\t\\tfor ei < el && e[ei][2] < l {\\n\\t\\t\\tn1 := e[ei][0]\\n\\t\\t\\tn2 := e[ei][1]\\n\\t\\t\\tuf.join(n1, n2)\\n\\t\\t\\tei += 1\\n\\t\\t}\\n\\t\\t// If both nodes belong to the same component, it means we can reach\\n\\t\\t// them.\\n\\t\\tans[qoi] = uf.con(pe, q)\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467757,
                "title": "java-32ms-100-2-sorts-and-union-find-fastest-beginner-friendly",
                "content": "**--- Algorithm ---**\\nThe code below has been optimized for speed, which sacrifices some simplicity.  The code uses the following algorithm:\\n\\n1. Sort the edges in ascending distance order.\\n2. Sort the queries in ascending distance order.\\n3. Initialize a union-find for the nodes of the graph.\\n4. Initialize boolean array to be returned, to all false.\\n5. Initialize iterator for the sorted edges.\\n6. Loop through the queries in sorted order.\\n7. Add all edges with a distance shorter than the current queries limit distance, using iterator for the sorted edges, and using union-find to add those edges to the graph.\\n8. If the two nodes of the query have the same union-find parent, then there must be a valid path between the query\\'s two nodes, so set current query\\'s entry in the boolean array to true.\\n9. Loop back to step #6, until all queries have been processed.\\n10. Return boolean array.\\n\\n**--- Union Find ---**\\nIn this leetcode problem, the union-find is used to determine if any two nodes of the graph are connected by some path through the graph.  As the queries are processed in ascending order sorted by their limit distance, we only partially build the graph, using only those edges that have a distance less than the current query\\'s limit distance.  Therefore, all edges that have been added to the graph, will always be valid edges for the current query.  Determining if any path exists between the query\\'s two nodes is done with a union-find.\\n\\nThe \"**union-find**\" is two operations.  The \"**find**\" operation to find any node\\'s \"**root**\" node in the graph.  And the \"**union**\" operation to join any two nodes, which in this case is to add an edge between two nodes.  The purpose of the union-find is to collect nodes into groups, where each group has a path or paths connecting all members of the group.  a union-find group is identified by its root node.  Another union-find group with a different root node, will NOT have any graph connections between the two groups.  Union-find groups are connected within the group, but disconnected (or disjoint) from other groups.\\n\\nA union-find group\\'s **root node has no special significance** in this leetcode problem.  The root node has simply been arbitrarily chosen to be the union-find group\\'s identifier.  The root node of a group may change when the union operation merges two groups into a single group.\\n\\nTo implement the union-find data structure, we create an array `parents[]`.  The `parents` array is indexed by a node\\'s node number.  The `parents` array contains each node\\'s parent node number.  A \"**root**\" node in the `parents` array is simply any node that is its own parent, or `parents[i]==i` for root nodes.  For non-root nodes, which node is the parent node, has no special significance other than to find the path to that node\\'s root node.  The any node\\'s parent node number may be modified by the union-find operations, so which node is currently the parent of another has little significance.\\n\\nTo create the `parents` array, we initialize each node to be its own parent, making each node a root node.  Initially, no edges have been processed, so there are no connections between any nodes, and therefore each node is isolated in its own union-find group, with itself being the root node of its own group.  The nodes will become connected later when performing union operations.  To initialize the `parents` array, use the code:\\n```\\n        int[] parents = new int[n];\\n        for (int i = n - 1; i >= 0; i--)\\n            parents[i] = i;\\n```\\nTo perform the union-find\\'s find operation, call the `findRoot()` method.  This method calls itself recursively to find the root of the union-find group.  All nodes in the same union-find group have the same root node, and have edges that create paths between any two nodes in the same union-find group.  The `findParent()` method will also update the nodes it recurses through, so next time they have a shorter path to the root node. The `parents[]` array contains the parent node number for every node.  A node is the root of a union-find group if `parents[i]==i`.\\n```\\n    private int findRoot(int[] parents, int node) {\\n        if (parents[node] == node)  return node;\\n        return parents[node] = findRoot(parents, parents[node]);\\n    }\\n```\\nWe use the union-find\\'s union operation to add an edge to the graph, using that edge\\'s two nodes.  The union operation is very simple.  First we find the root node numbers for the edge\\'s two nodes.  If both nodes have the same root node, then some path between the two nodes already exists so nothing to do, because they are already in the same union-find group.  If both nodes have different root nodes, then there was previously no path between the two nodes.  But now this edge will directly connect the two nodes, so we need to merge the two union-find groups by setting the root node of one union-find group, to point to the root node of the other group, thereby demoting one of the root nodes a non-root node.  For the root node that was demoted to a non-root node, any chain of parentage that led to that root node, will now continue that chain to the other root node, which is now the root node of the two groups that have been combined into a single group.  When doing the union operation to merge two groups, it is arbitrary as to which root is demoted to non-root, and which root node becomes the root node for the new combined group.  The union operation is performed with the following code:\\n```\\n                    int rootU = findRoot(parents, edge[0]);\\n                    int rootV = findRoot(parents, edge[1]);\\n                    if (rootU != rootV)  parents[rootV] = rootU;\\n```\\nThis is a very simple implementation of union-find, but this simple implementation is enough for many leetcode problems.  The union-find is also called \"disjoint-set data structure\", \"merge-find set\", or \"union-find data structure\".  In this leetcode problem, the actual graph is NOT stored as edges are added to the graph.  Only the union-find groupings of the graph\\'s nodes is needed.\\n\\n**--- Sorting ---**\\nSorting the edges and the queries does NOT modify the `edgeList` and `queries` arrays.  Two sorted arrays are created.  One sorted array for edges, and one sorted array for queries.\\n\\nTo sort, an array of `long` is created the same length of the array to be sorted.  The distance and original index is written into each `long`.  Then the array of `long` is sorted using `Arrays.sort()`, resulting in edges or queries in increasing distance order.  Each `long` in the sorted array contains the original index back to the `edgeList` or `queries` arrays.  An array of `long` is used for sorting because: 1) sorting an array of primitive types is faster than sorting more complex objects and this code has been optimized for speed, and 2) a `long` is needed to contain the values to be sorted.\\n\\nEach `long` value in the array to be sorted, is loaded with the distance value and the original index into the `edgeList` or `queries` arrays.  The distance is placed in the more significant digits of the `long` to be able to sort by distance, and the original index is placed in the lowest digits of the `long`.  Then the array is sorted using `Arrays.sort()`.  \\n\\nThe first code example below has the sorted `long` values storing distance and index inside the `long` in binary bit positions, using SHIFT-LEFT to load the `long` values, and using AND to read the index value from the `long` value.  These `long` values are stored as:\\n```\\n | Bit 63                                                   Bit 0 |\\n+V-------------+------------------------------+-------------------V+\\n|   (unused)   |     Bits 20..49 : distance   | Bits 0..19 : index |\\n+--------------+------------------------------+--------------------+\\n\\t\\tAssigning value to long:  long = distance << 20 + index\\n\\t\\tReading index from long:  index = long & 0xFFFFF\\n\\t\\t\\n```\\nThe second code example below has the sorted `long` values storing distance and index inside the `long` in decimal digit positions, using MULTIPLY to load the `long` values, and MODULO to read the index from the `long` value.  Storing the sorted values using binary operators, had runtimes as much as 12% faster as using decimal digit storage.  These `long` values are stored as:\\n```\\nDecimal digits in 64-bit long:  00_00d_ddd_ddd_ddd_xxx_xxx\\n\\t\\t\\t\\t\\tx = Digits containing index value.\\n\\t\\t\\t\\t\\td = Digits containing distance value.\\n\\t\\t\\t\\t\\t0 = Unused decimal digits.\\n\\t\\tAssigning value to long:  long = distance * 1_000_000 + index\\n\\t\\tReading index from long:  index = long % 1_000_000\\n```\\n**--- Miscelaneous ---**\\nThis code runs as fast as 32ms using binary stored data in the sorted `long` values, and 33ms using decimal stored data in the sorted `long` values, in August 2023.\\n\\nIf useful, please upvote.\\n\\n**--- Commented code with binary shift and mask for building and retrieving sorted values (faster) ---**\\n\\n```\\nclass Solution {\\n    // These MASK and SHIFT values are used to build sort \\n    // arrays for the edges and for the queries.  The arrays \\n    // to be sorted contain the higher binary digits, and \\n    // the index into the edges or the queries into the \\n    // lower binary digits.  After sorting, only the index \\n    // in the lower part of the long value is used.\\n    static final long MASK = 0xFFFFFL;\\n    static final int SHIFT = 20;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, \\n                                               int[][] queries) {\\n        int eCount = edgeList.length;\\n        int qCount = queries.length;\\n\\n        // Sort the edges by distance.\\n        long[] eSort = new long[eCount];\\n        for (int i = eCount - 1; i >= 0; i--)\\n            eSort[i] = ((long)edgeList[i][2] << SHIFT) + i;\\n        Arrays.sort(eSort);\\n        \\n        // Sort the queries by limit distance.\\n        long[] qSort = new long[qCount];\\n        for (int i = qCount - 1; i >= 0; i--)\\n            qSort[i] = ((long)queries[i][2] << SHIFT) + i;\\n        Arrays.sort(qSort);\\n        \\n        // Build the parents array for the union find.\\n        int[] parents = new int[n];\\n        for (int i = n - 1; i >= 0; i--)\\n            parents[i] = i;\\n        \\n        boolean[] result = new boolean[qCount];\\n        int eSortIdx = 0;\\n        int[] e = edgeList[(int)(eSort[0] & MASK)];\\n        int eDist = e[2];\\n        // Loop through all of the queries, in increasing limit distance \\n        // order.\\n        for (int qSortIdx = 0; qSortIdx < qCount; qSortIdx++) {\\n            int qIdx = (int)(qSort[qSortIdx] & MASK);\\n            int[] q = queries[qIdx];\\n            int qDist = q[2];\\n            // Process all of the unprocessed edges that are within the \\n            // current query\\'s limit distance.  Because queries are processed \\n            // in low to high distance order, and edges are processed in low \\n            // to high distance order, we just process edged (i.e. connect \\n            // via union-find) until we hit an edge with larger or same \\n            // distance as the current query\\'s limit distance.\\n            if (eSortIdx < eCount) {\\n                while (qDist > eDist) {\\n                    int rootU = findRoot(parents, e[0]);\\n                    int rootV = findRoot(parents, e[1]);\\n                    if (rootU != rootV)\\n                        parents[rootV] = rootU;\\n                    eSortIdx++;\\n                    if (eSortIdx >= eCount)  break;\\n                    e = edgeList[(int)(eSort[eSortIdx] & MASK)];\\n                    eDist = e[2];\\n                }\\n            }\\n            // Use union-find roots to decide if the two query nodes \\n            // are connected by some path.\\n            if (findRoot(parents, q[0]) == findRoot(parents, q[1])) \\n                result[qIdx] = true;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    private int findRoot(int[] parents, int node) {\\n        if (parents[node] == node)  return node;\\n        return parents[node] = findRoot(parents, parents[node]);\\n    }\\n}\\n```\\n**--- Clean Java code with decimal multiply and modulo for building and retrieving sorted values (slower) ---**\\n```\\nclass Solution {\\n    static final long MOD = 1_000_000L;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, \\n                                               int[][] queries) {\\n        int eCount = edgeList.length;\\n        int qCount = queries.length;\\n\\n        long[] eSort = new long[eCount];\\n        for (int i = eCount - 1; i >= 0; i--)\\n            eSort[i] = (long)edgeList[i][2] * MOD + i;\\n        Arrays.sort(eSort);\\n        \\n        long[] qSort = new long[qCount];\\n        for (int i = qCount - 1; i >= 0; i--)\\n            qSort[i] = (long)queries[i][2] * MOD + i;\\n        Arrays.sort(qSort);\\n        \\n        int[] parents = new int[n];\\n        for (int i = n - 1; i >= 0; i--)\\n            parents[i] = i;\\n        \\n        boolean[] result = new boolean[qCount];\\n        int eSortIdx = 0;\\n        int[] e = edgeList[(int)(eSort[0] % MOD)];\\n        int eDist = e[2];\\n        for (int qSortIdx = 0; qSortIdx < qCount; qSortIdx++) {\\n            int qIdx = (int)(qSort[qSortIdx] % MOD);\\n            int[] q = queries[qIdx];\\n            int qDist = q[2];\\n            if (eSortIdx < eCount) {\\n                while (qDist > eDist) {\\n                    int rootU = findRoot(parents, e[0]);\\n                    int rootV = findRoot(parents, e[1]);\\n                    if (rootU != rootV)\\n                        parents[rootV] = rootU;\\n                    eSortIdx++;\\n                    if (eSortIdx >= eCount)  break;\\n                    e = edgeList[(int)(eSort[eSortIdx] % MOD)];\\n                    eDist = e[2];\\n                }\\n            }\\n            if (findRoot(parents, q[0]) == findRoot(parents, q[1])) \\n                result[qIdx] = true;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    private int findRoot(int[] parents, int node) {\\n        if (parents[node] == node)  return node;\\n        return parents[node] = findRoot(parents, parents[node]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\n        int[] parents = new int[n];\\n        for (int i = n - 1; i >= 0; i--)\\n            parents[i] = i;\\n```\n```\\n    private int findRoot(int[] parents, int node) {\\n        if (parents[node] == node)  return node;\\n        return parents[node] = findRoot(parents, parents[node]);\\n    }\\n```\n```\\n                    int rootU = findRoot(parents, edge[0]);\\n                    int rootV = findRoot(parents, edge[1]);\\n                    if (rootU != rootV)  parents[rootV] = rootU;\\n```\n```\\n | Bit 63                                                   Bit 0 |\\n+V-------------+------------------------------+-------------------V+\\n|   (unused)   |     Bits 20..49 : distance   | Bits 0..19 : index |\\n+--------------+------------------------------+--------------------+\\n\\t\\tAssigning value to long:  long = distance << 20 + index\\n\\t\\tReading index from long:  index = long & 0xFFFFF\\n\\t\\t\\n```\n```\\nDecimal digits in 64-bit long:  00_00d_ddd_ddd_ddd_xxx_xxx\\n\\t\\t\\t\\t\\tx = Digits containing index value.\\n\\t\\t\\t\\t\\td = Digits containing distance value.\\n\\t\\t\\t\\t\\t0 = Unused decimal digits.\\n\\t\\tAssigning value to long:  long = distance * 1_000_000 + index\\n\\t\\tReading index from long:  index = long % 1_000_000\\n```\n```\\nclass Solution {\\n    // These MASK and SHIFT values are used to build sort \\n    // arrays for the edges and for the queries.  The arrays \\n    // to be sorted contain the higher binary digits, and \\n    // the index into the edges or the queries into the \\n    // lower binary digits.  After sorting, only the index \\n    // in the lower part of the long value is used.\\n    static final long MASK = 0xFFFFFL;\\n    static final int SHIFT = 20;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, \\n                                               int[][] queries) {\\n        int eCount = edgeList.length;\\n        int qCount = queries.length;\\n\\n        // Sort the edges by distance.\\n        long[] eSort = new long[eCount];\\n        for (int i = eCount - 1; i >= 0; i--)\\n            eSort[i] = ((long)edgeList[i][2] << SHIFT) + i;\\n        Arrays.sort(eSort);\\n        \\n        // Sort the queries by limit distance.\\n        long[] qSort = new long[qCount];\\n        for (int i = qCount - 1; i >= 0; i--)\\n            qSort[i] = ((long)queries[i][2] << SHIFT) + i;\\n        Arrays.sort(qSort);\\n        \\n        // Build the parents array for the union find.\\n        int[] parents = new int[n];\\n        for (int i = n - 1; i >= 0; i--)\\n            parents[i] = i;\\n        \\n        boolean[] result = new boolean[qCount];\\n        int eSortIdx = 0;\\n        int[] e = edgeList[(int)(eSort[0] & MASK)];\\n        int eDist = e[2];\\n        // Loop through all of the queries, in increasing limit distance \\n        // order.\\n        for (int qSortIdx = 0; qSortIdx < qCount; qSortIdx++) {\\n            int qIdx = (int)(qSort[qSortIdx] & MASK);\\n            int[] q = queries[qIdx];\\n            int qDist = q[2];\\n            // Process all of the unprocessed edges that are within the \\n            // current query\\'s limit distance.  Because queries are processed \\n            // in low to high distance order, and edges are processed in low \\n            // to high distance order, we just process edged (i.e. connect \\n            // via union-find) until we hit an edge with larger or same \\n            // distance as the current query\\'s limit distance.\\n            if (eSortIdx < eCount) {\\n                while (qDist > eDist) {\\n                    int rootU = findRoot(parents, e[0]);\\n                    int rootV = findRoot(parents, e[1]);\\n                    if (rootU != rootV)\\n                        parents[rootV] = rootU;\\n                    eSortIdx++;\\n                    if (eSortIdx >= eCount)  break;\\n                    e = edgeList[(int)(eSort[eSortIdx] & MASK)];\\n                    eDist = e[2];\\n                }\\n            }\\n            // Use union-find roots to decide if the two query nodes \\n            // are connected by some path.\\n            if (findRoot(parents, q[0]) == findRoot(parents, q[1])) \\n                result[qIdx] = true;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    private int findRoot(int[] parents, int node) {\\n        if (parents[node] == node)  return node;\\n        return parents[node] = findRoot(parents, parents[node]);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static final long MOD = 1_000_000L;\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, \\n                                               int[][] queries) {\\n        int eCount = edgeList.length;\\n        int qCount = queries.length;\\n\\n        long[] eSort = new long[eCount];\\n        for (int i = eCount - 1; i >= 0; i--)\\n            eSort[i] = (long)edgeList[i][2] * MOD + i;\\n        Arrays.sort(eSort);\\n        \\n        long[] qSort = new long[qCount];\\n        for (int i = qCount - 1; i >= 0; i--)\\n            qSort[i] = (long)queries[i][2] * MOD + i;\\n        Arrays.sort(qSort);\\n        \\n        int[] parents = new int[n];\\n        for (int i = n - 1; i >= 0; i--)\\n            parents[i] = i;\\n        \\n        boolean[] result = new boolean[qCount];\\n        int eSortIdx = 0;\\n        int[] e = edgeList[(int)(eSort[0] % MOD)];\\n        int eDist = e[2];\\n        for (int qSortIdx = 0; qSortIdx < qCount; qSortIdx++) {\\n            int qIdx = (int)(qSort[qSortIdx] % MOD);\\n            int[] q = queries[qIdx];\\n            int qDist = q[2];\\n            if (eSortIdx < eCount) {\\n                while (qDist > eDist) {\\n                    int rootU = findRoot(parents, e[0]);\\n                    int rootV = findRoot(parents, e[1]);\\n                    if (rootU != rootV)\\n                        parents[rootV] = rootU;\\n                    eSortIdx++;\\n                    if (eSortIdx >= eCount)  break;\\n                    e = edgeList[(int)(eSort[eSortIdx] % MOD)];\\n                    eDist = e[2];\\n                }\\n            }\\n            if (findRoot(parents, q[0]) == findRoot(parents, q[1])) \\n                result[qIdx] = true;\\n        }\\n        return result;\\n    }\\n    \\n    \\n    private int findRoot(int[] parents, int node) {\\n        if (parents[node] == node)  return node;\\n        return parents[node] = findRoot(parents, parents[node]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467709,
                "title": "simple-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn+qlogq)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n(n+q)\\n# Code\\n```\\nclass UnionFind {\\n  public UnionFind(int n) {\\n    id = new int[n];\\n    rank = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void unionByRank(int u, int v) {\\n    final int i = find(u);\\n    final int j = find(v);\\n    if (i == j)\\n      return;\\n    if (rank[i] < rank[j]) {\\n      id[i] = id[j];\\n    } else if (rank[i] > rank[j]) {\\n      id[j] = id[i];\\n    } else {\\n      id[i] = id[j];\\n      ++rank[j];\\n    }\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n  private int[] rank;\\n}\\n\\nclass Solution {\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    boolean[] ans = new boolean[queries.length];\\n    int[][] qs = new int[queries.length][4];\\n    UnionFind uf = new UnionFind(n);\\n\\n    for (int i = 0; i < queries.length; ++i) {\\n      qs[i][0] = queries[i][0];\\n      qs[i][1] = queries[i][1];\\n      qs[i][2] = queries[i][2];\\n      qs[i][3] = i;\\n    }\\n\\n    Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n    Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n\\n    int i = 0; // i := edgeList\\'s index\\n    for (int[] q : qs) {\\n      // Union edges whose distances < limit (q[2])\\n      while (i < edgeList.length && edgeList[i][2] < q[2])\\n        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);\\n      if (uf.find(q[0]) == uf.find(q[1]))\\n        ans[q[3]] = true;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UnionFind {\\n  public UnionFind(int n) {\\n    id = new int[n];\\n    rank = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void unionByRank(int u, int v) {\\n    final int i = find(u);\\n    final int j = find(v);\\n    if (i == j)\\n      return;\\n    if (rank[i] < rank[j]) {\\n      id[i] = id[j];\\n    } else if (rank[i] > rank[j]) {\\n      id[j] = id[i];\\n    } else {\\n      id[i] = id[j];\\n      ++rank[j];\\n    }\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n  private int[] rank;\\n}\\n\\nclass Solution {\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    boolean[] ans = new boolean[queries.length];\\n    int[][] qs = new int[queries.length][4];\\n    UnionFind uf = new UnionFind(n);\\n\\n    for (int i = 0; i < queries.length; ++i) {\\n      qs[i][0] = queries[i][0];\\n      qs[i][1] = queries[i][1];\\n      qs[i][2] = queries[i][2];\\n      qs[i][3] = i;\\n    }\\n\\n    Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n    Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n\\n    int i = 0; // i := edgeList\\'s index\\n    for (int[] q : qs) {\\n      // Union edges whose distances < limit (q[2])\\n      while (i < edgeList.length && edgeList[i][2] < q[2])\\n        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);\\n      if (uf.find(q[0]) == uf.find(q[1]))\\n        ans[q[3]] = true;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467234,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int>& parent)\\n    {\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = find(parent[node], parent);\\n    }\\n    void Union(int node0, int node1, vector<int>& parent)\\n    {\\n        int par0 = find(node0, parent); \\n        int par1 = find(node1, parent);\\n        if(par0 == par1)\\n            return;\\n        parent[par0] = par1;\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        int sz = edges.size(); \\n        vector<int> parent(n, 0); \\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        sort(edges.begin(), edges.end(), [&](vector<int>& edge1, vector<int>& edge2){\\n            return edge1[2] < edge2[2];\\n        });\\n        for(int i = 0; i < q; i++) queries[i].push_back(i);\\n        sort(queries.begin(), queries.end(), [&](vector<int>& query1,vector<int>& query2) \\n        {\\n            return query1[2] < query2[2];\\n        });\\n        vector<bool> ans(q, false);\\n        int edgeMoment = 0; \\n        for(int eachQuery = 0; eachQuery < q; eachQuery++) \\n        {\\n            int currQueryWeight = queries[eachQuery][2]; \\n            while(edgeMoment < sz && edges[edgeMoment][2] < currQueryWeight)\\n            Union(edges[edgeMoment][0], edges[edgeMoment][1], parent), edgeMoment++;\\n            if(find(queries[eachQuery][0], parent) == \\n            find(queries[eachQuery][1], parent))  {\\n\\n                ans[queries[eachQuery][3]] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int node, vector<int>& parent)\\n    {\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = find(parent[node], parent);\\n    }\\n    void Union(int node0, int node1, vector<int>& parent)\\n    {\\n        int par0 = find(node0, parent); \\n        int par1 = find(node1, parent);\\n        if(par0 == par1)\\n            return;\\n        parent[par0] = par1;\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        int q = queries.size();\\n        int sz = edges.size(); \\n        vector<int> parent(n, 0); \\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        sort(edges.begin(), edges.end(), [&](vector<int>& edge1, vector<int>& edge2){\\n            return edge1[2] < edge2[2];\\n        });\\n        for(int i = 0; i < q; i++) queries[i].push_back(i);\\n        sort(queries.begin(), queries.end(), [&](vector<int>& query1,vector<int>& query2) \\n        {\\n            return query1[2] < query2[2];\\n        });\\n        vector<bool> ans(q, false);\\n        int edgeMoment = 0; \\n        for(int eachQuery = 0; eachQuery < q; eachQuery++) \\n        {\\n            int currQueryWeight = queries[eachQuery][2]; \\n            while(edgeMoment < sz && edges[edgeMoment][2] < currQueryWeight)\\n            Union(edges[edgeMoment][0], edges[edgeMoment][1], parent), edgeMoment++;\\n            if(find(queries[eachQuery][0], parent) == \\n            find(queries[eachQuery][1], parent))  {\\n\\n                ans[queries[eachQuery][3]] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466983,
                "title": "union-find-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int) -> bool:\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: \\n            prt, qrt = qrt, prt \\n        self.parent[prt] = qrt \\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\\n        edgeList = sorted((w, u, v) for u, v, w in edgeList)\\n        \\n        uf = UnionFind(n)\\n        \\n        ans = [None] * len(queries)\\n        ii = 0\\n        for w, p, q, i in queries: \\n            while ii < len(edgeList) and edgeList[ii][0] < w: \\n                _, u, v = edgeList[ii]\\n                uf.union(u, v)\\n                ii += 1\\n            ans[i] = uf.find(p) == uf.find(q)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int) -> bool:\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: \\n            prt, qrt = qrt, prt \\n        self.parent[prt] = qrt \\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\\n        edgeList = sorted((w, u, v) for u, v, w in edgeList)\\n        \\n        uf = UnionFind(n)\\n        \\n        ans = [None] * len(queries)\\n        ii = 0\\n        for w, p, q, i in queries: \\n            while ii < len(edgeList) and edgeList[ii][0] < w: \\n                _, u, v = edgeList[ii]\\n                uf.union(u, v)\\n                ii += 1\\n            ans[i] = uf.find(p) == uf.find(q)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466449,
                "title": "easy-to-understand-optimized-simple-approach",
                "content": "\\n\\n# Code\\n```\\nclass DSU {\\n    public:\\n    vector<int> Parent, Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n        \\n        sort(queries.begin(), queries.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        sort(edgeList.begin(), edgeList.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        \\n        int i=0;\\n        vector<bool> res(queries.size(), false);\\n        for(auto q: queries){\\n            while(i<edgeList.size() && edgeList[i][2]<q[2]){\\n                dsu.Union(edgeList[i][0] , edgeList[i][1]);\\n                i++;\\n            }\\n            \\n            if(dsu.Find(q[0]) == dsu.Find(q[1]))\\n                res[q[3]] = true;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU {\\n    public:\\n    vector<int> Parent, Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++)\\n            queries[i].push_back(i);\\n        \\n        sort(queries.begin(), queries.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        sort(edgeList.begin(), edgeList.end(), [&](auto const &a, auto const &b){\\n            return a[2] < b[2];\\n        });\\n        \\n        int i=0;\\n        vector<bool> res(queries.size(), false);\\n        for(auto q: queries){\\n            while(i<edgeList.size() && edgeList[i][2]<q[2]){\\n                dsu.Union(edgeList[i][0] , edgeList[i][1]);\\n                i++;\\n            }\\n            \\n            if(dsu.Find(q[0]) == dsu.Find(q[1]))\\n                res[q[3]] = true;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466424,
                "title": "holy-moly-give-it-a-try-for-this-solution",
                "content": "# Hint 1\\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than limitlimitlimit, just check with the minimum weight. We can always traverse a\\u2194ba \\\\leftrightarrow ba\\u2194b via minimum weighted edge if minWeight<limitmin.\\n\\n# Hint 2\\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse 1\\u22122\\u22123\\u22124 with limit=10, then we can also traverse from any source to destination pair in [1,2,3,4]with limit\\u226510.\\n\\n# Hint 3\\nSo, for a specific queries[i], assume there is a copy of the given graph but it has only those edges which has weight<limit. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the limitlimitlimit?\\n\\n# Hint 4\\nWhen we were able to traverse 1\\u22122\\u22123\\u22124 with limit=10, suppose there was one edge 1\\u21945 with weight=11, and we were not able to use it to reach 555. But if limitlimitlimit is increased to 12, then we can use it to go 1\\u22125 and subsequently any source to destination pair in [1,2,3,4,5].\\n\\n# Hint 5\\nWhen limit is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has weight where oldLimit\\u2264weight<newLimit. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have queries and edgeList sorted with weight or limit. But, before sorting queries, don\\'t forget to store their original indices for final result array.\\n\\n# Hint 6\\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [This](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide/) if you want to learn DSU). For an increased limit, take union of those disjoint sets for those new edges.\\n\\n# Intuition & Approach\\n\\u2022 problem is to determine if there is a path between two nodes in an undirected graph such that each edge on the path has a distance strictly less than a given limit.\\n\\n\\u2022 The input consists of the number of nodes, the edge list, and the queries.\\n\\n\\u2022 The edge list is an array of arrays, where each sub-array represents an edge between two nodes and the distance between them.\\n\\n\\u2022 The queries are an array of arrays, where each sub-array represents a query with two nodes and a limit.\\n\\n\\u2022 The using the union-find algorithm to determine if there is a path between two nodes.\\n\\n\\u2022 The union-find algorithm is used to group nodes into connected components.\\n\\n\\u2022 First sorts the edges in the edge list by their distance in ascending order.\\n\\n\\u2022 Then iterates over the sorted edges and performs a union operation on the nodes connected by the edge.\\n\\n\\u2022 The union operation updates the parent and rank arrays to group the nodes into connected components.\\n\\n\\u2022 Then iterates over the queries and checks if the two nodes are connected and if the distance between them is less than the given limit.\\n\\n\\u2022 The isConnectedAndWithinLimit method uses the find method to determine if the two nodes are connected and if the distance between them is less than the given limit.\\n\\n\\u2022 The find method uses the parent and weight arrays to find the root of the connected component and checks if the weight of the edge is less than the given limit.\\n\\n\\u2022 The union method updates the parent, rank, and weight arrays to group the nodes into connected components and store the weight of the edge.\\n\\n\\u2022 finally returns a boolean array where each element represents if there is a path between the two nodes in the corresponding query with edges less than the given limit.$ -->\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        \\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n        \\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        E = len(edgeList)\\n        Q = len(queries)\\n        uf = UnionFind(n)\\n        ans = [False] * Q\\n        for i in range(Q):\\n            queries[i].append(i)\\n        queries.sort(key=lambda x: x[2])\\n        edgeList.sort(key=lambda x: x[2])\\n        j = 0\\n        for i in range(Q):\\n            while j < E and edgeList[j][2] < queries[i][2]:\\n                uf.union(edgeList[j][0], edgeList[j][1])\\n                j += 1\\n            ans[queries[i][3]] = (uf.find(queries[i][0]) == uf.find(queries[i][1]))\\n        return ans\\n\\n\\n\"\"\"\\n# TLE and wrong ans\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parents = defaultdict(lambda: None)\\n        sizes = defaultdict(int)\\n        \\n        def find(a):\\n            if a not in parents:\\n                parents[a] = a\\n                sizes[a] = 1\\n                return a\\n\\n            root = a\\n            while parents[root] != root:\\n                root = parents[root]\\n            while parents[a] != a:\\n                nxt = parents[a]\\n                parents[a] = root\\n                a = nxt\\n            return root\\n        \\n        def union(a,b):\\n            roota = find(a)\\n            rootb = find(b)\\n            if roota == rootb:\\n                return\\n            if sizes[roota] > sizes[rootb]:\\n                sizes[roota] += sizes[rootb]\\n                sizes[rootb] = 0\\n                parents[rootb] = roota\\n            else:\\n                sizes[rootb] += sizes[roota]\\n                sizes[roota] = 0\\n                parents[roota] = rootb\\n\\n        Q, E = len(queries), len(edgeList)\\n\\n        #print(edgeList)      \\n        edgeList.sort(key=lambda x: x[2])\\n        #print(edgeList)\\n        queries = sorted(((u,v,l,idx) for idx,(u,v,l) in enumerate(queries)), key=lambda x: x[2])\\n        #print(queries)\\n\\n        res = [False] * Q\\n        e_idx = 0\\n        for p, q, l, i in queries:\\n            while e_idx < E and edgeList[e_idx][2] < l:\\n                u, v, _ = edgeList[e_idx]\\n                union(u, v)\\n                res[i] = find(p) == find(q)\\n                e_idx += 1\\n        return res\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        \\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n        \\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        E = len(edgeList)\\n        Q = len(queries)\\n        uf = UnionFind(n)\\n        ans = [False] * Q\\n        for i in range(Q):\\n            queries[i].append(i)\\n        queries.sort(key=lambda x: x[2])\\n        edgeList.sort(key=lambda x: x[2])\\n        j = 0\\n        for i in range(Q):\\n            while j < E and edgeList[j][2] < queries[i][2]:\\n                uf.union(edgeList[j][0], edgeList[j][1])\\n                j += 1\\n            ans[queries[i][3]] = (uf.find(queries[i][0]) == uf.find(queries[i][1]))\\n        return ans\\n\\n\\n\"\"\"\\n# TLE and wrong ans\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parents = defaultdict(lambda: None)\\n        sizes = defaultdict(int)\\n        \\n        def find(a):\\n            if a not in parents:\\n                parents[a] = a\\n                sizes[a] = 1\\n                return a\\n\\n            root = a\\n            while parents[root] != root:\\n                root = parents[root]\\n            while parents[a] != a:\\n                nxt = parents[a]\\n                parents[a] = root\\n                a = nxt\\n            return root\\n        \\n        def union(a,b):\\n            roota = find(a)\\n            rootb = find(b)\\n            if roota == rootb:\\n                return\\n            if sizes[roota] > sizes[rootb]:\\n                sizes[roota] += sizes[rootb]\\n                sizes[rootb] = 0\\n                parents[rootb] = roota\\n            else:\\n                sizes[rootb] += sizes[roota]\\n                sizes[roota] = 0\\n                parents[roota] = rootb\\n\\n        Q, E = len(queries), len(edgeList)\\n\\n        #print(edgeList)      \\n        edgeList.sort(key=lambda x: x[2])\\n        #print(edgeList)\\n        queries = sorted(((u,v,l,idx) for idx,(u,v,l) in enumerate(queries)), key=lambda x: x[2])\\n        #print(queries)\\n\\n        res = [False] * Q\\n        e_idx = 0\\n        for p, q, l, i in queries:\\n            while e_idx < E and edgeList[e_idx][2] < l:\\n                u, v, _ = edgeList[e_idx]\\n                union(u, v)\\n                res[i] = find(p) == find(q)\\n                e_idx += 1\\n        return res\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466113,
                "title": "java-solution-union-find-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort edge list by limit, to have min edge with min limit with a higher rank\\n- Build Union Find components with limits\\n- Query UF to find connected componets based on limit\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        var uf = new UF(n);\\n        Arrays.sort(edgeList, Comparator.comparingInt(a -> a[2]));\\n\\n        for (var e : edgeList)\\n            uf.union(e[0], e[1], e[2]);\\n        \\n        var answer = new boolean[queries.length];\\n        for (var i = 0; i < queries.length; ++i)\\n            answer[i] = uf.connected(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n}\\n\\nclass UF {\\n\\n    private final int[] id, rank, limits;\\n\\n    UF(int N) {\\n        this.id = new int[N];\\n        this.rank = new int[N];\\n        this.limits = new int[N];\\n\\n        for (var i = 0; i < N; ++i)\\n            id[i] = i;\\n    }\\n\\n    void union(int p, int q, int limit) {\\n        var pId = find(p);\\n        var qId = find(q);\\n\\n        if (pId == qId)\\n            return;\\n\\n        if (rank[pId] < rank[qId]) {\\n            id[pId] = qId;\\n            limits[pId] = limit;\\n        } else if (rank[pId] > rank[qId]) {\\n            id[qId] = pId;\\n            limits[qId] = limit;\\n        } else {\\n            id[qId] = pId;\\n            limits[qId] = limit;\\n            rank[pId]++;\\n        }\\n    }\\n\\n    boolean connected(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    private int find(int p) {\\n        while (p != id[p])\\n            p = id[p];\\n        \\n        return p;\\n    }\\n\\n    private int find(int p, int limit) {\\n        while (p != id[p] && limits[p] < limit)\\n            p = id[p];\\n        \\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        var uf = new UF(n);\\n        Arrays.sort(edgeList, Comparator.comparingInt(a -> a[2]));\\n\\n        for (var e : edgeList)\\n            uf.union(e[0], e[1], e[2]);\\n        \\n        var answer = new boolean[queries.length];\\n        for (var i = 0; i < queries.length; ++i)\\n            answer[i] = uf.connected(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n}\\n\\nclass UF {\\n\\n    private final int[] id, rank, limits;\\n\\n    UF(int N) {\\n        this.id = new int[N];\\n        this.rank = new int[N];\\n        this.limits = new int[N];\\n\\n        for (var i = 0; i < N; ++i)\\n            id[i] = i;\\n    }\\n\\n    void union(int p, int q, int limit) {\\n        var pId = find(p);\\n        var qId = find(q);\\n\\n        if (pId == qId)\\n            return;\\n\\n        if (rank[pId] < rank[qId]) {\\n            id[pId] = qId;\\n            limits[pId] = limit;\\n        } else if (rank[pId] > rank[qId]) {\\n            id[qId] = pId;\\n            limits[qId] = limit;\\n        } else {\\n            id[qId] = pId;\\n            limits[qId] = limit;\\n            rank[pId]++;\\n        }\\n    }\\n\\n    boolean connected(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    private int find(int p) {\\n        while (p != id[p])\\n            p = id[p];\\n        \\n        return p;\\n    }\\n\\n    private int find(int p, int limit) {\\n        while (p != id[p] && limits[p] < limit)\\n            p = id[p];\\n        \\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465675,
                "title": "c-solution-union-find-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int edgesCount = edgeList.Length, queriesCount = queries.Length;\\n        DSU dsu = new DSU(n);\\n\\n        for (int i = 0; i < queriesCount; i++) \\n            queries[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i}; \\n\\n        Array.Sort(queries, (a, b) => a[2] - b[2]);\\n        Array.Sort(edgeList, (a, b) => a[2] - b[2]);\\n        bool[] res = new bool[queriesCount];\\n\\n        for (int i = 0, j = 0; i < queriesCount; i++) {\\n            var query = queries[i];\\n\\n            while (j < edgesCount && edgeList[j][2] < queries[i][2])\\n                dsu.union(edgeList[j][0], edgeList[j++][1]);\\n\\n            res[queries[i][3]] = dsu.find(queries[i][0]) == dsu.find(queries[i][1]);\\n        }\\n\\n        return res;\\n    }\\n\\n    class DSU {\\n        public int[] parent;\\n\\n        public DSU(int n) {\\n            parent = new int[n];\\n\\n            for (int i = 0; i < n; i++) parent[i] = i;\\n        }\\n\\n        public int find(int x) {\\n            if (parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void union(int x, int y) {\\n            parent[find(x)] = parent[find(y)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int edgesCount = edgeList.Length, queriesCount = queries.Length;\\n        DSU dsu = new DSU(n);\\n\\n        for (int i = 0; i < queriesCount; i++) \\n            queries[i] = new int[]{queries[i][0], queries[i][1], queries[i][2], i}; \\n\\n        Array.Sort(queries, (a, b) => a[2] - b[2]);\\n        Array.Sort(edgeList, (a, b) => a[2] - b[2]);\\n        bool[] res = new bool[queriesCount];\\n\\n        for (int i = 0, j = 0; i < queriesCount; i++) {\\n            var query = queries[i];\\n\\n            while (j < edgesCount && edgeList[j][2] < queries[i][2])\\n                dsu.union(edgeList[j][0], edgeList[j++][1]);\\n\\n            res[queries[i][3]] = dsu.find(queries[i][0]) == dsu.find(queries[i][1]);\\n        }\\n\\n        return res;\\n    }\\n\\n    class DSU {\\n        public int[] parent;\\n\\n        public DSU(int n) {\\n            parent = new int[n];\\n\\n            for (int i = 0; i < n; i++) parent[i] = i;\\n        }\\n\\n        public int find(int x) {\\n            if (parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void union(int x, int y) {\\n            parent[find(x)] = parent[find(y)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465652,
                "title": "java-union-find-disjoint-set",
                "content": "```\\nclass Solution {\\n    \\n    int[] parent;\\n    int[] rank;\\n    \\n    Solution(){\\n        int n = 100004;\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i = 0;i<n;i++)\\n            parent[i] = i;\\n    }\\n    \\n    public void union(int u, int v){\\n        int pu = findParent(u), pv = findParent(v);\\n        int ru = rank[pu] , rv = rank[pv];\\n        \\n        if(pu == pv)\\n            return;\\n        if(ru < rv){\\n            parent[pu] = pv;\\n        }else if(rv < ru)\\n            parent[pv] = pu;\\n        else{\\n            parent[pu] = pv;\\n            rank[pv]++;\\n        }\\n        return;\\n    }\\n    \\n    public int findParent(int u){\\n        if( u != parent[u])\\n            parent[u] = findParent(parent[u]);\\n        return parent[u] ;\\n    }\\n    \\n    public boolean connected(int u, int v){\\n        return findParent(u) == findParent(v);\\n    }\\n    \\n    public void sort(int[][] query){\\n         Arrays.sort(query, new Comparator<int[] >(){\\n            @Override\\n            public int compare(int[] first, int[] second){\\n                return first[2] - second[2]; \\n            }\\n        });\\n    }\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int no_of_query = queries.length;\\n        int[][] query = new int[no_of_query][4];\\n        int i = 0, j = 0;\\n        for( i =0 ;i < no_of_query ; i++){\\n            query[i][0] = queries[i][0];\\n            query[i][1] = queries[i][1];\\n            query[i][2] = queries[i][2];\\n            query[i][3] = i;\\n        }\\n\\n        sort(query);\\n        sort(edgeList);\\n       \\n        int currentEdge = 0;\\n        int edges = edgeList.length;\\n        boolean[] ans = new boolean[no_of_query];\\n        for(i = 0;i < no_of_query ; i++){\\n            int u = query[i][0], v = query[i][1], limit = query[i][2], ind = query[i][3];\\n            while( currentEdge < edges && edgeList[currentEdge][2] < limit){\\n                int p = edgeList[currentEdge][0], q = edgeList[currentEdge][1] ;\\n                union(p,q);\\n                currentEdge++;\\n            }\\n            ans[ind] = findParent(u) == findParent(v);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[] parent;\\n    int[] rank;\\n    \\n    Solution(){\\n        int n = 100004;\\n        parent = new int[n];\\n        rank = new int[n];\\n        for(int i = 0;i<n;i++)\\n            parent[i] = i;\\n    }\\n    \\n    public void union(int u, int v){\\n        int pu = findParent(u), pv = findParent(v);\\n        int ru = rank[pu] , rv = rank[pv];\\n        \\n        if(pu == pv)\\n            return;\\n        if(ru < rv){\\n            parent[pu] = pv;\\n        }else if(rv < ru)\\n            parent[pv] = pu;\\n        else{\\n            parent[pu] = pv;\\n            rank[pv]++;\\n        }\\n        return;\\n    }\\n    \\n    public int findParent(int u){\\n        if( u != parent[u])\\n            parent[u] = findParent(parent[u]);\\n        return parent[u] ;\\n    }\\n    \\n    public boolean connected(int u, int v){\\n        return findParent(u) == findParent(v);\\n    }\\n    \\n    public void sort(int[][] query){\\n         Arrays.sort(query, new Comparator<int[] >(){\\n            @Override\\n            public int compare(int[] first, int[] second){\\n                return first[2] - second[2]; \\n            }\\n        });\\n    }\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int no_of_query = queries.length;\\n        int[][] query = new int[no_of_query][4];\\n        int i = 0, j = 0;\\n        for( i =0 ;i < no_of_query ; i++){\\n            query[i][0] = queries[i][0];\\n            query[i][1] = queries[i][1];\\n            query[i][2] = queries[i][2];\\n            query[i][3] = i;\\n        }\\n\\n        sort(query);\\n        sort(edgeList);\\n       \\n        int currentEdge = 0;\\n        int edges = edgeList.length;\\n        boolean[] ans = new boolean[no_of_query];\\n        for(i = 0;i < no_of_query ; i++){\\n            int u = query[i][0], v = query[i][1], limit = query[i][2], ind = query[i][3];\\n            while( currentEdge < edges && edgeList[currentEdge][2] < limit){\\n                int p = edgeList[currentEdge][0], q = edgeList[currentEdge][1] ;\\n                union(p,q);\\n                currentEdge++;\\n            }\\n            ans[ind] = findParent(u) == findParent(v);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465390,
                "title": "clean-and-simple-code",
                "content": "# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int nn = edgeList.length;\\n        int len = queries.length;\\n        boolean res[] = new boolean[len];\\n        int arr[][] = new int[len][4];\\n        for(int i = 0;i<len;i++){\\n            arr[i][0] = queries[i][0];\\n            arr[i][1] = queries[i][1];\\n            arr[i][2] = queries[i][2];\\n            arr[i][3] = i;\\n        }\\n        Arrays.sort(arr,(a,b) -> a[2] - b[2]);\\n        Arrays.sort(edgeList,(a,b) -> a[2] - b[2]);\\n        DSU obj = new DSU(n);\\n        int j = 0;\\n        for(int i = 0;i<len;i++){\\n            int a = arr[i][0];\\n            int b = arr[i][1];\\n            int dis = arr[i][2];\\n            int idx = arr[i][3];\\n            while(j<nn && edgeList[j][2] < dis){\\n                obj.union(edgeList[j][0], edgeList[j++][1]);\\n            }\\n            res[idx] = obj.findPar(a) == obj.findPar(b);\\n        }\\n        return res;\\n    }\\n}\\nclass DSU{\\n    int par[];\\n    int rank[];\\n    DSU(int n){\\n        par = new int[n];\\n        rank = new int[n];\\n        for(int i = 0;i<n;i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findPar(int n){\\n        if(n == par[n]) return n;\\n        return par[n] = findPar(par[n]);\\n    }\\n    void union(int u, int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if(rank[u] < rank[v]){\\n            par[u] = v;\\n        }else if(rank[v] < rank[u]){\\n            par[v] = u;\\n        }else{\\n            par[v] = u;\\n            rank[u]++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int nn = edgeList.length;\\n        int len = queries.length;\\n        boolean res[] = new boolean[len];\\n        int arr[][] = new int[len][4];\\n        for(int i = 0;i<len;i++){\\n            arr[i][0] = queries[i][0];\\n            arr[i][1] = queries[i][1];\\n            arr[i][2] = queries[i][2];\\n            arr[i][3] = i;\\n        }\\n        Arrays.sort(arr,(a,b) -> a[2] - b[2]);\\n        Arrays.sort(edgeList,(a,b) -> a[2] - b[2]);\\n        DSU obj = new DSU(n);\\n        int j = 0;\\n        for(int i = 0;i<len;i++){\\n            int a = arr[i][0];\\n            int b = arr[i][1];\\n            int dis = arr[i][2];\\n            int idx = arr[i][3];\\n            while(j<nn && edgeList[j][2] < dis){\\n                obj.union(edgeList[j][0], edgeList[j++][1]);\\n            }\\n            res[idx] = obj.findPar(a) == obj.findPar(b);\\n        }\\n        return res;\\n    }\\n}\\nclass DSU{\\n    int par[];\\n    int rank[];\\n    DSU(int n){\\n        par = new int[n];\\n        rank = new int[n];\\n        for(int i = 0;i<n;i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findPar(int n){\\n        if(n == par[n]) return n;\\n        return par[n] = findPar(par[n]);\\n    }\\n    void union(int u, int v){\\n        u = findPar(u);\\n        v = findPar(v);\\n        if(rank[u] < rank[v]){\\n            par[u] = v;\\n        }else if(rank[v] < rank[u]){\\n            par[v] = u;\\n        }else{\\n            par[v] = u;\\n            rank[u]++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465067,
                "title": "distance-limited-paths-exist-using-disjoint-set-union-in-c-easy-to-understand",
                "content": "# Intuition\\nTo solve the problem, we can use Kruskal\\'s algorithm to find the minimum spanning tree of the given graph, and then use this tree to answer the queries.\\n\\nWe first sort the edges of the graph in non-decreasing order of their weights. We then pick the edges one by one, and add them to the tree if they do not create a cycle. To check if an edge creates a cycle, we can use a disjoint set data structure. We then process the queries one by one, and check if the two nodes of each query are connected in the minimum spanning tree and the distance between them is less than the given limit.\\n\\nIf the two nodes of a query are connected in the minimum spanning tree and the distance between them is less than the given limit, then we mark the answer for this query as true, otherwise we mark it as false. Finally, we return the array of answers for all the queries.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the edgeList in non-descending order of their weights.\\n2. For each query in queries, sort the edgeList up to the limit of the query.\\n3. Use a modified version of Dijkstra\\'s algorithm to find a path between the two nodes of each query.\\n4. In the modified Dijkstra\\'s algorithm, stop exploring the neighboring nodes once the weight of the edge between the current node and a neighboring node exceeds the limit of the query.\\n5. If a path is found between the two nodes of a query, mark the query as true in the answer array. Otherwise, mark it as false.\\n6. Return the answer array.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- The TimeComplexity O((m+n) log m), where m is the number of edges in edgeList and n is the number of queries in queries. This is because the edges are sorted using quicksort, which has an average-case time complexity of O(m log m), and the queries are also sorted, which takes O(n log n) time. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- The space complexity of the code is O(m+n), where m is the number of edges in edgeList and n is the number of queries in queries. \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n...............................................................................................................\\nPLEASE UPVOTE IF YOU FIND THAT IT HELPED YOU ...............................................................................................................\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<int>size;\\n    vector<int>head;\\n    DisjointSet(int n){\\n        size.resize(n,1);\\n        head.resize(n);\\n        for(int i=0;i<n;i++)head[i]=i;\\n    }\\n    \\n    int findUpar(int node){\\n        if(node==head[node])return node;\\n\\n       return head[node]=findUpar(head[node]);\\n    }\\n\\n    void UnionBySize(int u,int v){\\n        int jms=findUpar(u);\\n        int rms=findUpar(v);\\n        if(jms==rms)return ;\\n        if(size[jms]<size[rms]){\\n            head[jms]=rms;\\n            size[rms]+=size[jms];\\n        }\\n        else{\\n            head[rms]=jms;\\n            size[jms]+=size[rms];\\n        }\\n       \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a,vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DisjointSet ds(n);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        sort(queries.begin(),queries.end(),cmp);\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        int j=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(j<edgeList.size()&&edgeList[j][2]<queries[i][2]){\\n                ds.UnionBySize(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            if(ds.findUpar(queries[i][0])==ds.findUpar(queries[i][1])){\\n                ans[queries[i][3]]=true;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<int>size;\\n    vector<int>head;\\n    DisjointSet(int n){\\n        size.resize(n,1);\\n        head.resize(n);\\n        for(int i=0;i<n;i++)head[i]=i;\\n    }\\n    \\n    int findUpar(int node){\\n        if(node==head[node])return node;\\n\\n       return head[node]=findUpar(head[node]);\\n    }\\n\\n    void UnionBySize(int u,int v){\\n        int jms=findUpar(u);\\n        int rms=findUpar(v);\\n        if(jms==rms)return ;\\n        if(size[jms]<size[rms]){\\n            head[jms]=rms;\\n            size[rms]+=size[jms];\\n        }\\n        else{\\n            head[rms]=jms;\\n            size[jms]+=size[rms];\\n        }\\n       \\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>&a,vector<int>&b){\\n        return a[2]<b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DisjointSet ds(n);\\n        \\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        vector<bool>ans(queries.size(),false);\\n        sort(queries.begin(),queries.end(),cmp);\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        int j=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(j<edgeList.size()&&edgeList[j][2]<queries[i][2]){\\n                ds.UnionBySize(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            if(ds.findUpar(queries[i][0])==ds.findUpar(queries[i][1])){\\n                ans[queries[i][3]]=true;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464966,
                "title": "union-find-python-js-solution",
                "content": "Hello **Tenno Leetcoders**, \\nFor this problem, we have an undirected graph of `n` nodes defined by `edgeList`, where `edgeList[i] = [ui, vi, disi]`. denotes an edge between nodes `ui` and `v`i with distance `disi`.\\n\\nWe are given an `array queries`, where `queries[j] = [pj, qj, limitj]`, we want to determine for each `queries[i]`, whether there is a path between `pj` and `qj` such that each edge on the path has a distance strictly less than `limitj`.\\n\\n\\nWe want to return a `boolean array answer`, where `answer.length == queries.length` and the `jth value` of answer is `true` if there is a `path` for `queries[j]` is `true`, and `false` otherwise.\\n\\n## Explanation\\n\\nThis problem want us to determine for each query in `queries` array, we want to know if there exists a path between node `pj` and `qj` in an undirected graph defined by `edgeList` such that each edge on the path has a distance stricly less than `limitj`\\n\\nSince, we want to determine if there is a path between two nodes such that each edges within the path has a distance strictly less than the given limit denoted as `limitj`\\n\\nWe can use `Union-find` to help us determine wether there is a path between two nodes that satisfy the given limit condition \\n\\nA basic usage of `Union-find` will be first, initializing each node as its own seperate component. \\n\\nAs we proceed each edge, we check whether the connection between two nodes are in the same component. \\n\\nWe can then determine the same two nodes belonging to the same component have the same root node.\\n\\nFor this problem though, we can use the same basic usage of`Union-find` with some modifications. We should first merge componenets by considering the weight of each edges. \\n\\nAs we merge two componenets, we want to choose the smallest edge weight between the parent and child.\\n\\nTo keep track of each parent node, we want to use an array and another array to keep track of distances betwen each node and its parent and set the  starting distance as `0s`.\\n\\nWe will iterate our given `edgeList`. For each edge, we will find the parent nodes using `union-find`, comparing the distances between each node and its parent with their weight. If their weight is less than the distance, we can update the parent and the starting distances with the new parents distance.\\n\\nWe will need to check if there is a path between two nodes. by finding the root of the parent and child nodes using `union-find` again. We can then calculate the distance between each node and its root.\\n\\nIf their distance is less than the given limit denoted as `limitj` then we return `true` else `false`\\n\\n\\n### Code\\n\\n**Python**\\n```\\nclass UnionFind:\\n    \\n    def __init__(self,n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [0] * n\\n        \\n    def find(self, node):\\n        if self.parent[node] != node:\\n            self.parent[node] = self.find(self.parent[node])\\n        \\n        return self.parent[node]\\n    \\n    \\n\\n    def union(self, node1, node2):\\n        root1 = self.find(node1)\\n        root2 = self.find(node2)\\n        \\n        if root1 == root2: return \\n        \\n        if self.size[root1] > self.size[root2]: self.parent[root2] = root1\\n        elif self.size[root1] < self.size[root2]: self.parent[root1] = root2\\n        else: \\n            self.parent[root1] = root2\\n            self.size[root2] += 1\\n                \\n    def connected(self, node1, node2):\\n        return self.find(node1) == self.find(node2)\\n    \\nclass Solution:               \\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        uf = UnionFind(n)\\n        \\n        edgeList.sort(key=lambda x: x[2])\\n        \\n        queries_sorted = [(limit, i, p, q) for i, (p,q, limit) in enumerate(queries)]\\n        \\n        queries_sorted.sort()\\n        \\n        result = [False] * len(queries)\\n        \\n        edges_index = 0\\n        \\n        for limit, query_index, p, q in queries_sorted:\\n            while edges_index < len(edgeList) and edgeList[edges_index][2] < limit:\\n                uf.union(edgeList[edges_index][0], edgeList[edges_index][1])\\n                edges_index += 1\\n                \\n            if uf.connected(p,q):\\n                result[query_index] = True\\n                \\n        return result\\n```\\n\\n**JavaScript**\\n\\n```\\nclass UnionFind{\\n    \\n    constructor(n){\\n        this.parent = Array(n).fill().map((_, i) => i)\\n        this.size = Array(n).fill(0)\\n    }\\n    \\n    find(node){\\n        if(this.parent[node] !== node){\\n            this.parent[node] = this.find(this.parent[node])\\n        }\\n        return this.parent[node]\\n    }    \\n    \\n    union(node1, node2){\\n        let root1 = this.find(node1)\\n        let root2 = this.find(node2)\\n        \\n        if (root1 === root2) return\\n        \\n        if(this.size[root1] > this.size[root2]) {\\n            this.parent[root2] = root1\\n        }\\n        else if(this.size[root1] < this.size[root2]){\\n            this.parent[root1] = root2\\n        }\\n        else{\\n            this.parent[root1] = root2\\n            this.size[root2] += 1\\n        }\\n    }\\n    \\n    connected(node1, node2){\\n        return this.find(node1) === this.find(node2)\\n    }\\n    \\n}\\n\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    \\n    let uf = new  UnionFind(n)\\n    \\n    edgeList.sort((a,b) => a[2] - b[2])\\n    \\n    let queries_sorted = queries.map((q,i) => [q[2], i, q[0], q[1]])\\n    queries_sorted.sort((a,b ) => a[0] - b[0])\\n    \\n    let result = Array(queries_sorted.length).fill(false)\\n\\n    \\n    let edges_index = 0\\n    \\n    \\n    for(let [limit, query_index, p, q] of queries_sorted){\\n       \\n        while(edges_index < edgeList.length && edgeList[edges_index][2] < limit){\\n            \\n            uf.union(edgeList[edges_index][0], edgeList[edges_index][1])\\n            edges_index += 1\\n        }\\n        \\n        if(uf.connected(p,q)){\\n            result[query_index] = true\\n        }\\n   \\n    }\\n       \\n  return result\\n};\\n```\\n\\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    \\n    def __init__(self,n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [0] * n\\n        \\n    def find(self, node):\\n        if self.parent[node] != node:\\n            self.parent[node] = self.find(self.parent[node])\\n        \\n        return self.parent[node]\\n    \\n    \\n\\n    def union(self, node1, node2):\\n        root1 = self.find(node1)\\n        root2 = self.find(node2)\\n        \\n        if root1 == root2: return \\n        \\n        if self.size[root1] > self.size[root2]: self.parent[root2] = root1\\n        elif self.size[root1] < self.size[root2]: self.parent[root1] = root2\\n        else: \\n            self.parent[root1] = root2\\n            self.size[root2] += 1\\n                \\n    def connected(self, node1, node2):\\n        return self.find(node1) == self.find(node2)\\n    \\nclass Solution:               \\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        uf = UnionFind(n)\\n        \\n        edgeList.sort(key=lambda x: x[2])\\n        \\n        queries_sorted = [(limit, i, p, q) for i, (p,q, limit) in enumerate(queries)]\\n        \\n        queries_sorted.sort()\\n        \\n        result = [False] * len(queries)\\n        \\n        edges_index = 0\\n        \\n        for limit, query_index, p, q in queries_sorted:\\n            while edges_index < len(edgeList) and edgeList[edges_index][2] < limit:\\n                uf.union(edgeList[edges_index][0], edgeList[edges_index][1])\\n                edges_index += 1\\n                \\n            if uf.connected(p,q):\\n                result[query_index] = True\\n                \\n        return result\\n```\n```\\nclass UnionFind{\\n    \\n    constructor(n){\\n        this.parent = Array(n).fill().map((_, i) => i)\\n        this.size = Array(n).fill(0)\\n    }\\n    \\n    find(node){\\n        if(this.parent[node] !== node){\\n            this.parent[node] = this.find(this.parent[node])\\n        }\\n        return this.parent[node]\\n    }    \\n    \\n    union(node1, node2){\\n        let root1 = this.find(node1)\\n        let root2 = this.find(node2)\\n        \\n        if (root1 === root2) return\\n        \\n        if(this.size[root1] > this.size[root2]) {\\n            this.parent[root2] = root1\\n        }\\n        else if(this.size[root1] < this.size[root2]){\\n            this.parent[root1] = root2\\n        }\\n        else{\\n            this.parent[root1] = root2\\n            this.size[root2] += 1\\n        }\\n    }\\n    \\n    connected(node1, node2){\\n        return this.find(node1) === this.find(node2)\\n    }\\n    \\n}\\n\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    \\n    let uf = new  UnionFind(n)\\n    \\n    edgeList.sort((a,b) => a[2] - b[2])\\n    \\n    let queries_sorted = queries.map((q,i) => [q[2], i, q[0], q[1]])\\n    queries_sorted.sort((a,b ) => a[0] - b[0])\\n    \\n    let result = Array(queries_sorted.length).fill(false)\\n\\n    \\n    let edges_index = 0\\n    \\n    \\n    for(let [limit, query_index, p, q] of queries_sorted){\\n       \\n        while(edges_index < edgeList.length && edgeList[edges_index][2] < limit){\\n            \\n            uf.union(edgeList[edges_index][0], edgeList[edges_index][1])\\n            edges_index += 1\\n        }\\n        \\n        if(uf.connected(p,q)){\\n            result[query_index] = true\\n        }\\n   \\n    }\\n       \\n  return result\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464923,
                "title": "python-build-graph-from-smallest-dist-to-bigger",
                "content": "1. Sort *queries* by `l`imit\\n2. Sort *edges* by `d`ist\\n3. Iterate over `queries` as `l`:\\n3.1. Connect all nodes that have edges with `d` < `l`. \\n3.2. Check the query\\'s `p` and `q` belong to the same `component`.\\n4. Repeat for all queries\\n\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parents = defaultdict(lambda: None)\\n        sizes = defaultdict(int)\\n        \\n        def find(a):\\n            if a not in parents:\\n                parents[a] = a\\n                sizes[a] = 1\\n                return a\\n\\n            root = a\\n            while parents[root] != root:\\n                root = parents[root]\\n\\n            while parents[a] != a:\\n                nxt = parents[a]\\n                parents[a] = root\\n                a = nxt\\n            \\n            return root\\n        \\n        def union(a,b):\\n            roota = find(a)\\n            rootb = find(b)\\n            \\n            if roota == rootb:\\n                return\\n            \\n            if sizes[roota] > sizes[rootb]:\\n                sizes[roota] += sizes[rootb]\\n                sizes[rootb] = 0\\n                parents[rootb] = roota\\n            else:\\n                sizes[rootb] += sizes[roota]\\n                sizes[roota] = 0\\n                parents[roota] = rootb\\n        \\n        Q, E = len(queries), len(edgeList)\\n                \\n        edgeList.sort(key=lambda x: x[2])\\n        queries = sorted(((u,v,l,i) for i,(u,v,l) in enumerate(queries)), key=lambda x: x[2])\\n        \\n        res = [False] * Q\\n        e_idx = 0\\n        for p, q, l, i in queries:\\n            while e_idx < E and edgeList[e_idx][2] < l:\\n                u, v, _ = edgeList[e_idx]\\n                union(u, v)\\n                e_idx += 1\\n            res[i] = find(p) == find(q)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parents = defaultdict(lambda: None)\\n        sizes = defaultdict(int)\\n        \\n        def find(a):\\n            if a not in parents:\\n                parents[a] = a\\n                sizes[a] = 1\\n                return a\\n\\n            root = a\\n            while parents[root] != root:\\n                root = parents[root]\\n\\n            while parents[a] != a:\\n                nxt = parents[a]\\n                parents[a] = root\\n                a = nxt\\n            \\n            return root\\n        \\n        def union(a,b):\\n            roota = find(a)\\n            rootb = find(b)\\n            \\n            if roota == rootb:\\n                return\\n            \\n            if sizes[roota] > sizes[rootb]:\\n                sizes[roota] += sizes[rootb]\\n                sizes[rootb] = 0\\n                parents[rootb] = roota\\n            else:\\n                sizes[rootb] += sizes[roota]\\n                sizes[roota] = 0\\n                parents[roota] = rootb\\n        \\n        Q, E = len(queries), len(edgeList)\\n                \\n        edgeList.sort(key=lambda x: x[2])\\n        queries = sorted(((u,v,l,i) for i,(u,v,l) in enumerate(queries)), key=lambda x: x[2])\\n        \\n        res = [False] * Q\\n        e_idx = 0\\n        for p, q, l, i in queries:\\n            while e_idx < E and edgeList[e_idx][2] < l:\\n                u, v, _ = edgeList[e_idx]\\n                union(u, v)\\n                e_idx += 1\\n            res[i] = find(p) == find(q)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464921,
                "title": "dijkstra-s-algorithm-c-easy-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        for(int i = 0; i<=n; i++) parent[i] = i;\\n        \\n\\t\\t// Sorting the edges array based on dist of each pair of node. \\n        sort(edges.begin(),edges.end(),[](vector<int>&a, vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n\\n\\t\\t// We will need the indices of query elements coz after sorting, the order will change. \\n\\t\\t// So we push the index in the same element vector of query.\\n        for(int i = 0; i<queries.size(); i++) queries[i].push_back(i);\\n\\t\\t\\t\\n\\t\\t// Sorting queries based on limits. \\n        sort(queries.begin(),queries.end(),[](vector<int>&a,vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n        \\n        vector <bool> ans(queries.size(),false);\\n        int idx = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            // Here we loop on edges vector and join the two nodes having dist < curr_limit.\\n\\t\\t\\twhile(idx<edges.size() and edges[idx][2]<queries[i][2]){\\n                join(edges[idx][0],edges[idx][1]);\\n                idx++;\\n            }\\n\\t\\t\\t// If the two nodes of current query has same godfather, we set this queries ans as true\\n            if(find(parent[queries[i][0]]) == find(parent[queries[i][1]])) ans[queries[i][3]] = true;\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void join(int a, int b){\\n        a = find(a);\\n        b = find(b);\\n        \\n        if(a!=b) parent[b] = a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sort",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        for(int i = 0; i<=n; i++) parent[i] = i;\\n        \\n\\t\\t// Sorting the edges array based on dist of each pair of node. \\n        sort(edges.begin(),edges.end(),[](vector<int>&a, vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n\\n\\t\\t// We will need the indices of query elements coz after sorting, the order will change. \\n\\t\\t// So we push the index in the same element vector of query.\\n        for(int i = 0; i<queries.size(); i++) queries[i].push_back(i);\\n\\t\\t\\t\\n\\t\\t// Sorting queries based on limits. \\n        sort(queries.begin(),queries.end(),[](vector<int>&a,vector<int>&b){\\n            if(a[2]<b[2]) return true;\\n            return false;\\n        });\\n        \\n        vector <bool> ans(queries.size(),false);\\n        int idx = 0;\\n        for(int i = 0; i<queries.size(); i++){\\n            // Here we loop on edges vector and join the two nodes having dist < curr_limit.\\n\\t\\t\\twhile(idx<edges.size() and edges[idx][2]<queries[i][2]){\\n                join(edges[idx][0],edges[idx][1]);\\n                idx++;\\n            }\\n\\t\\t\\t// If the two nodes of current query has same godfather, we set this queries ans as true\\n            if(find(parent[queries[i][0]]) == find(parent[queries[i][1]])) ans[queries[i][3]] = true;\\n        }\\n        return ans;\\n    }\\nprotected:\\n    int find(int x){\\n        if(parent[x]==x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void join(int a, int b){\\n        a = find(a);\\n        b = find(b);\\n        \\n        if(a!=b) parent[b] = a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464907,
                "title": "c-union-find-with-explanation",
                "content": "\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* root;\\nint** qcopy;\\n\\nint find(int x) {\\n    if(x==root[x])\\n        return x;\\n    else\\n        return root[x] = find(root[x]);\\n}\\n\\nint cmp(void const* a, void const* b) {\\n    return (*(int**)a)[2] - (*(int**)b)[2];\\n}\\n\\nint cmp2(void const* a, void const* b) {\\n    return qcopy[*(int*)a][2] - qcopy[*(int*)b][2];\\n}\\n\\nbool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize = queriesSize;\\n    int i;\\n    //init union set\\n    root = (int*)malloc(sizeof(int)*n);\\n    for (i = 0; i < n; i++)\\n        root[i] = i;\\n    //init answer array\\n    bool* ans = (bool*)malloc(sizeof(bool) * queriesSize);\\n\\n    int idx[queriesSize];//index of queries\\n    for (i = 0; i < queriesSize; ++i)\\n        idx[i] = i;\\n\\n    qcopy = queries;\\n    qsort(idx, queriesSize, sizeof(int), cmp2);//sort the index base on the queries limit length\\n    qsort(edgeList, edgeListSize, sizeof(int*), cmp); //sort by edge distance\\n    \\n    int j=0;\\n    for (i = 0; i < queriesSize; ++i) {\\n        int curr = idx[i];//current queries index in sorted queries\\n        int len = queries[curr][2];//limit length\\n        \\n        //update union set when distance less than limit \\n        while(j < edgeListSize && edgeList[j][2] < len){\\n            int a = find(edgeList[j][0]);\\n            int b = find(edgeList[j][1]);\\n            root[b] = a;\\n            j++;\\n        }\\n\\n        //check if nodes has same root\\n        if (find(queries[curr][0]) == find(queries[curr][1]))\\n            ans[curr] = 1;\\n        else \\n            ans[curr] = 0;\\n    }\\n\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* root;\\nint** qcopy;\\n\\nint find(int x) {\\n    if(x==root[x])\\n        return x;\\n    else\\n        return root[x] = find(root[x]);\\n}\\n\\nint cmp(void const* a, void const* b) {\\n    return (*(int**)a)[2] - (*(int**)b)[2];\\n}\\n\\nint cmp2(void const* a, void const* b) {\\n    return qcopy[*(int*)a][2] - qcopy[*(int*)b][2];\\n}\\n\\nbool* distanceLimitedPathsExist(int n, int** edgeList, int edgeListSize, int* edgeListColSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){\\n    *returnSize = queriesSize;\\n    int i;\\n    //init union set\\n    root = (int*)malloc(sizeof(int)*n);\\n    for (i = 0; i < n; i++)\\n        root[i] = i;\\n    //init answer array\\n    bool* ans = (bool*)malloc(sizeof(bool) * queriesSize);\\n\\n    int idx[queriesSize];//index of queries\\n    for (i = 0; i < queriesSize; ++i)\\n        idx[i] = i;\\n\\n    qcopy = queries;\\n    qsort(idx, queriesSize, sizeof(int), cmp2);//sort the index base on the queries limit length\\n    qsort(edgeList, edgeListSize, sizeof(int*), cmp); //sort by edge distance\\n    \\n    int j=0;\\n    for (i = 0; i < queriesSize; ++i) {\\n        int curr = idx[i];//current queries index in sorted queries\\n        int len = queries[curr][2];//limit length\\n        \\n        //update union set when distance less than limit \\n        while(j < edgeListSize && edgeList[j][2] < len){\\n            int a = find(edgeList[j][0]);\\n            int b = find(edgeList[j][1]);\\n            root[b] = a;\\n            j++;\\n        }\\n\\n        //check if nodes has same root\\n        if (find(queries[curr][0]) == find(queries[curr][1]))\\n            ans[curr] = 1;\\n        else \\n            ans[curr] = 0;\\n    }\\n\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464897,
                "title": "js-union-find",
                "content": "# Approach\\nAfter sorting query and edge arrays, we iterate through queries and connect all edges that have a distance below the limit of the current query. Then we check whether the two nodes of the query are connected.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + eloge + qlogq + (e + q))$$ - n to initialize parent and rank arrays, eloge and qlogq to sort edgeList and queriesWithIndex, e + q for union find on every edge and query\\n\\n- Space complexity:\\n$$O(n + q)$$ - n for parent and rank arrays, q for queriesWithIndex\\n\\n# Code\\n```\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const par = [];\\n    for (let i = 0; i < n; i++) par.push(i);\\n    const rank = new Array(n).fill(1);\\n\\n    function find(n) {\\n        if (n === par[n]) return n;\\n        return par[n] = find(par[n]);\\n    }\\n\\n    function union(n1, n2) {\\n        let p1 = find(n1), p2 = find(n2);\\n        if (p1 === p2) return false;\\n        if (rank[p1] > rank[p2]) {\\n            par[p2] = p1;\\n            rank[p1] += rank[p2];\\n        } else {\\n            par[p1] = p2;\\n            rank[p2] += rank[p1];\\n        }\\n        return true;\\n    }\\n\\n    // add index to queries so we know where it goes in result array after sorting\\n    const queriesWithIndex = [];\\n    for (let i = 0; i < queries.length; i++) {\\n        queriesWithIndex[i] = [...queries[i], i];\\n    }\\n\\n    // sort new queries array and edgeList by distance\\n    queriesWithIndex.sort((a, b) => a[2] - b[2]);\\n    edgeList.sort((a, b) => a[2] - b[2]);\\n\\n    const res = new Array(queries.length);\\n\\n    let edgesIndex = 0;\\n    // iterate through queries, connecting all edges that are below the limit\\n    for (let [p, q, limit, i] of queriesWithIndex) {\\n        while (edgesIndex < edgeList.length && edgeList[edgesIndex][2] < limit) {\\n            union(edgeList[edgesIndex][0], edgeList[edgesIndex][1]);\\n            edgesIndex++;\\n        }\\n        // check if the two query edges are connected\\n        res[i] = (find(p) === find(q));\\n    }\\n    return res;\\n}\\n// TC: O(n + eloge + qlogq + (e + q)) n to initialize parent and rank arrays, eloge and qlogq to sort edgeList and queriesWithIndex, e + q for union find\\n// SC: O(n + q) n for parent and rank arrays, q for queriesWithIndex\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    const par = [];\\n    for (let i = 0; i < n; i++) par.push(i);\\n    const rank = new Array(n).fill(1);\\n\\n    function find(n) {\\n        if (n === par[n]) return n;\\n        return par[n] = find(par[n]);\\n    }\\n\\n    function union(n1, n2) {\\n        let p1 = find(n1), p2 = find(n2);\\n        if (p1 === p2) return false;\\n        if (rank[p1] > rank[p2]) {\\n            par[p2] = p1;\\n            rank[p1] += rank[p2];\\n        } else {\\n            par[p1] = p2;\\n            rank[p2] += rank[p1];\\n        }\\n        return true;\\n    }\\n\\n    // add index to queries so we know where it goes in result array after sorting\\n    const queriesWithIndex = [];\\n    for (let i = 0; i < queries.length; i++) {\\n        queriesWithIndex[i] = [...queries[i], i];\\n    }\\n\\n    // sort new queries array and edgeList by distance\\n    queriesWithIndex.sort((a, b) => a[2] - b[2]);\\n    edgeList.sort((a, b) => a[2] - b[2]);\\n\\n    const res = new Array(queries.length);\\n\\n    let edgesIndex = 0;\\n    // iterate through queries, connecting all edges that are below the limit\\n    for (let [p, q, limit, i] of queriesWithIndex) {\\n        while (edgesIndex < edgeList.length && edgeList[edgesIndex][2] < limit) {\\n            union(edgeList[edgesIndex][0], edgeList[edgesIndex][1]);\\n            edgesIndex++;\\n        }\\n        // check if the two query edges are connected\\n        res[i] = (find(p) === find(q));\\n    }\\n    return res;\\n}\\n// TC: O(n + eloge + qlogq + (e + q)) n to initialize parent and rank arrays, eloge and qlogq to sort edgeList and queriesWithIndex, e + q for union find\\n// SC: O(n + q) n for parent and rank arrays, q for queriesWithIndex\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464890,
                "title": "java-union-find-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting the Queries + Computing UNION-FIND of the Edgelist via Sorted Approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int[][] modifiedQueries = new int[queries.length][4];\\n        for(int i=0;i<queries.length;i++) {\\n            modifiedQueries[i][0] = queries[i][0];\\n            modifiedQueries[i][1] = queries[i][1];\\n            modifiedQueries[i][2] = queries[i][2];\\n            modifiedQueries[i][3] = i;\\n        }\\n        Arrays.sort(modifiedQueries,(a, b) -> a[2] - b[2]);\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        int i = 0, j = 0;\\n        boolean[] answer = new boolean[modifiedQueries.length];\\n        DisjointSet disjointSet = new DisjointSet(n);\\n\\n        while(i<modifiedQueries.length) {\\n            while(j < edgeList.length && edgeList[j][2] < modifiedQueries[i][2]) {\\n                disjointSet.union(edgeList[j][0], edgeList[j][1]);\\n                j++;\\n            }\\n            answer[modifiedQueries[i][3]] = disjointSet.findParent(modifiedQueries[i][0]) == disjointSet.findParent(modifiedQueries[i][1]);\\n            i++;\\n        }\\n        return answer;\\n    }\\n}\\n\\nclass DisjointSet {\\n\\n    private int[] parent;\\n    private int[] rank;\\n\\n    public DisjointSet(int n) {\\n        this.parent = new int[n];\\n        this.rank = new int[n];\\n        for(int i=1;i<n;i++) {\\n            this.parent[i] = i;\\n        }\\n    }\\n\\n    public int findParent(int node) {\\n        if(this.parent[node]!=node) this.parent[node] = findParent(this.parent[node]);\\n        return this.parent[node];\\n    }\\n\\n    public void union(int u, int v) {\\n        int uPar = findParent(u);\\n        int vPar = findParent(v);\\n\\n        if(uPar == vPar) return;\\n        if(this.rank[uPar] < this.rank[vPar]) this.parent[uPar] = vPar;\\n        else if(this.rank[vPar] < this.rank[uPar]) this.parent[vPar] = uPar;\\n        else {\\n            this.parent[uPar] = vPar;\\n            this.rank[vPar]++;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int[][] modifiedQueries = new int[queries.length][4];\\n        for(int i=0;i<queries.length;i++) {\\n            modifiedQueries[i][0] = queries[i][0];\\n            modifiedQueries[i][1] = queries[i][1];\\n            modifiedQueries[i][2] = queries[i][2];\\n            modifiedQueries[i][3] = i;\\n        }\\n        Arrays.sort(modifiedQueries,(a, b) -> a[2] - b[2]);\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        int i = 0, j = 0;\\n        boolean[] answer = new boolean[modifiedQueries.length];\\n        DisjointSet disjointSet = new DisjointSet(n);\\n\\n        while(i<modifiedQueries.length) {\\n            while(j < edgeList.length && edgeList[j][2] < modifiedQueries[i][2]) {\\n                disjointSet.union(edgeList[j][0], edgeList[j][1]);\\n                j++;\\n            }\\n            answer[modifiedQueries[i][3]] = disjointSet.findParent(modifiedQueries[i][0]) == disjointSet.findParent(modifiedQueries[i][1]);\\n            i++;\\n        }\\n        return answer;\\n    }\\n}\\n\\nclass DisjointSet {\\n\\n    private int[] parent;\\n    private int[] rank;\\n\\n    public DisjointSet(int n) {\\n        this.parent = new int[n];\\n        this.rank = new int[n];\\n        for(int i=1;i<n;i++) {\\n            this.parent[i] = i;\\n        }\\n    }\\n\\n    public int findParent(int node) {\\n        if(this.parent[node]!=node) this.parent[node] = findParent(this.parent[node]);\\n        return this.parent[node];\\n    }\\n\\n    public void union(int u, int v) {\\n        int uPar = findParent(u);\\n        int vPar = findParent(v);\\n\\n        if(uPar == vPar) return;\\n        if(this.rank[uPar] < this.rank[vPar]) this.parent[uPar] = vPar;\\n        else if(this.rank[vPar] < this.rank[uPar]) this.parent[vPar] = uPar;\\n        else {\\n            this.parent[uPar] = vPar;\\n            this.rank[vPar]++;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464871,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edgeList\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    let index = new Array(n).fill().map((_,i) => i);\\n    let keys = new Array(queries.length).fill().map((_,i) => i)\\n    let result = new Array(queries.length), j = 0\\n\\n    const find = (x) => x !== index[x] ? index[x] = find(index[x]) : index[x]\\n    const union = (x,y) => index[find(x)] = find(y)\\n    edgeList.sort((a,b) => a[2] - b[2])\\n    keys.sort((a,b) => queries[a][2] - queries[b][2])\\n\\n    for (let i of keys) {\\n        let [a,b,c] = queries[i]\\n        while (edgeList[j]?.[2] < c) union(edgeList[j][0], edgeList[j++][1])\\n        result[i] = find(a) === find(b)\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edgeList\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    let index = new Array(n).fill().map((_,i) => i);\\n    let keys = new Array(queries.length).fill().map((_,i) => i)\\n    let result = new Array(queries.length), j = 0\\n\\n    const find = (x) => x !== index[x] ? index[x] = find(index[x]) : index[x]\\n    const union = (x,y) => index[find(x)] = find(y)\\n    edgeList.sort((a,b) => a[2] - b[2])\\n    keys.sort((a,b) => queries[a][2] - queries[b][2])\\n\\n    for (let i of keys) {\\n        let [a,b,c] = queries[i]\\n        while (edgeList[j]?.[2] < c) union(edgeList[j][0], edgeList[j++][1])\\n        result[i] = find(a) === find(b)\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3464861,
                "title": "python3-solution",
                "content": "\\n```\\nclass UnionFind:\\n    def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int) -> bool:\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: \\n            prt, qrt = qrt, prt \\n        self.parent[prt] = qrt \\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\\n        edgeList = sorted((w, u, v) for u, v, w in edgeList)\\n        \\n        uf = UnionFind(n)\\n        \\n        ans = [None] * len(queries)\\n        ii = 0\\n        for w, p, q, i in queries: \\n            while ii < len(edgeList) and edgeList[ii][0] < w: \\n                _, u, v = edgeList[ii]\\n                uf.union(u, v)\\n                ii += 1\\n            ans[i] = uf.find(p) == uf.find(q)\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, N: int):\\n        self.parent = list(range(N))\\n        self.rank = [1] * N\\n\\n    def find(self, p: int) -> int:\\n        if p != self.parent[p]:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n\\n    def union(self, p: int, q: int) -> bool:\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: \\n            prt, qrt = qrt, prt \\n        self.parent[prt] = qrt \\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = sorted((w, p, q, i) for i, (p, q, w) in enumerate(queries))\\n        edgeList = sorted((w, u, v) for u, v, w in edgeList)\\n        \\n        uf = UnionFind(n)\\n        \\n        ans = [None] * len(queries)\\n        ii = 0\\n        for w, p, q, i in queries: \\n            while ii < len(edgeList) and edgeList[ii][0] < w: \\n                _, u, v = edgeList[ii]\\n                uf.union(u, v)\\n                ii += 1\\n            ans[i] = uf.find(p) == uf.find(q)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464818,
                "title": "python-disjoint-set-union",
                "content": "```python []\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        x_root, y_root = self.find(x), self.find(y)\\n        if x_root == y_root:\\n            return\\n        if self.rank[x_root] < self.rank[y_root]:\\n            x_root, y_root = y_root, x_root\\n        self.parent[y_root] = x_root\\n        if self.rank[x_root] == self.rank[y_root]:\\n            self.rank[x_root] += 1\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = [[i] + q for i, q in enumerate(queries)]\\n        queries.sort(key=lambda x: x[3])\\n        edges.sort(key=lambda x: x[2])\\n        dsu = DSU(n)\\n        res = [0] * len(queries)\\n        j = 0\\n        for i, u, v, lim in queries:\\n            while j < len(edges) and edges[j][2] < lim:\\n                p, q = edges[j][:2]\\n                dsu.union(p, q)\\n                j += 1\\n            res[i] = dsu.find(u) == dsu.find(v)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```python []\\nclass DSU:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, x, y):\\n        x_root, y_root = self.find(x), self.find(y)\\n        if x_root == y_root:\\n            return\\n        if self.rank[x_root] < self.rank[y_root]:\\n            x_root, y_root = y_root, x_root\\n        self.parent[y_root] = x_root\\n        if self.rank[x_root] == self.rank[y_root]:\\n            self.rank[x_root] += 1\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        queries = [[i] + q for i, q in enumerate(queries)]\\n        queries.sort(key=lambda x: x[3])\\n        edges.sort(key=lambda x: x[2])\\n        dsu = DSU(n)\\n        res = [0] * len(queries)\\n        j = 0\\n        for i, u, v, lim in queries:\\n            while j < len(edges) and edges[j][2] < lim:\\n                p, q = edges[j][:2]\\n                dsu.union(p, q)\\n                j += 1\\n            res[i] = dsu.find(u) == dsu.find(v)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2863636,
                "title": "online-solution-in-o-m-logm-n-q-logn",
                "content": "We compute the minimum spanning trees (there can be multiple ones, we are not guaranteed that the graph is connected) using Kruskal\\'s Algorithm.  ``O(M*logM)`` from sorting.\\nWe then build Binary Lifting data structure on the trees. ``O(N*logN)``.\\nFor each query we get LCA of the 2 nodes ``x`` and ``y`` using Binary Lifting data structure and we also get max edge cost on the path from ``x`` to LCA and from ``y`` to LCA. If the maximum edge cost on the path is less than the limit, the answer to query is true. ``O(logN)`` per query, ``O(Q*logN)`` total.\\nAdding up the complexities ``O(M*logM+(Q+N)*logN)``.",
                "solutionTags": [],
                "code": "We compute the minimum spanning trees (there can be multiple ones, we are not guaranteed that the graph is connected) using Kruskal\\'s Algorithm.  ``O(M*logM)`` from sorting.\\nWe then build Binary Lifting data structure on the trees. ``O(N*logN)``.\\nFor each query we get LCA of the 2 nodes ``x`` and ``y`` using Binary Lifting data structure and we also get max edge cost on the path from ``x`` to LCA and from ``y`` to LCA. If the maximum edge cost on the path is less than the limit, the answer to query is true. ``O(logN)`` per query, ``O(Q*logN)`` total.\\nAdding up the complexities ``O(M*logM+(Q+N)*logN)``.",
                "codeTag": "Unknown"
            },
            {
                "id": 2252346,
                "title": "python-unionfind-with-comments",
                "content": "Sort both edges and queries by distance. For each query connect only nodes closer than the query threshold. All further queries would reuse previous connected graph with possibly adding some own edges.\\n\\ntime: O(N log(N) + M log(M)) space: O(N)\\n\\n```\\n# standard UnionFind implementation\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.roots = [i for i in range(n)]\\n        self.ranks = [1] * n\\n        #self.sizes = [1] * n\\n        #self.count = n\\n\\n    def find(self, x):\\n        root = self.roots[x]\\n        if root != self.roots[root]:\\n            self.roots[x] = self.find(root)                \\n        return self.roots[x]\\n\\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx != rooty:\\n            if self.ranks[rootx] > self.ranks[rooty]:\\n                self.roots[rooty] = rootx\\n                #self.sizes[rootx] += self.sizes[rooty]\\n            elif self.ranks[rootx] < self.ranks[rooty]:\\n                self.roots[rootx] = rooty\\n                #self.sizes[rooty] += self.sizes[rootx]\\n            else:\\n                self.roots[rooty] = rootx\\n                #self.sizes[rootx] += self.sizes[rooty]\\n                self.ranks[rootx] += 1\\n            #self.count -= 1\\n\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    #def getCount(self):\\n    #    return self.count\\n    \\n    #def getCompSize(self, x):\\n    #    return self.sizes[x]\\n    \\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        m = len(queries)\\n        # sort edges by distance\\n        edgeList.sort(key=lambda x: x[2])\\n        # sort queries added their indexes by distance\\n        idx_queries = sorted(zip(queries, range(m)), key=lambda x: x[0][2])\\n        \\n        res = [False] * m\\n        edge_idx = 0\\n        \\n        uf = UnionFind(n + 1)\\n        # review all queries in acsending order\\n        for (u, v, t), idx in idx_queries:\\n            # add only edges which are less than the current query threshold\\n            # only those edges may be reachable for this query\\n\\t\\t\\t# they will also automatically be reachable for all further queries\\n            while edge_idx < len(edgeList) and edgeList[edge_idx][2] < t:\\n                # connect nodes\\n                uf.union(edgeList[edge_idx][0], edgeList[edge_idx][1])\\n                edge_idx += 1\\n            # see if the query nodes connected\\n            res[idx] = uf.connected(u, v)\\n            \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# standard UnionFind implementation\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.roots = [i for i in range(n)]\\n        self.ranks = [1] * n\\n        #self.sizes = [1] * n\\n        #self.count = n\\n\\n    def find(self, x):\\n        root = self.roots[x]\\n        if root != self.roots[root]:\\n            self.roots[x] = self.find(root)                \\n        return self.roots[x]\\n\\n    def union(self, x, y):\\n        rootx = self.find(x)\\n        rooty = self.find(y)\\n        if rootx != rooty:\\n            if self.ranks[rootx] > self.ranks[rooty]:\\n                self.roots[rooty] = rootx\\n                #self.sizes[rootx] += self.sizes[rooty]\\n            elif self.ranks[rootx] < self.ranks[rooty]:\\n                self.roots[rootx] = rooty\\n                #self.sizes[rooty] += self.sizes[rootx]\\n            else:\\n                self.roots[rooty] = rootx\\n                #self.sizes[rootx] += self.sizes[rooty]\\n                self.ranks[rootx] += 1\\n            #self.count -= 1\\n\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    #def getCount(self):\\n    #    return self.count\\n    \\n    #def getCompSize(self, x):\\n    #    return self.sizes[x]\\n    \\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        m = len(queries)\\n        # sort edges by distance\\n        edgeList.sort(key=lambda x: x[2])\\n        # sort queries added their indexes by distance\\n        idx_queries = sorted(zip(queries, range(m)), key=lambda x: x[0][2])\\n        \\n        res = [False] * m\\n        edge_idx = 0\\n        \\n        uf = UnionFind(n + 1)\\n        # review all queries in acsending order\\n        for (u, v, t), idx in idx_queries:\\n            # add only edges which are less than the current query threshold\\n            # only those edges may be reachable for this query\\n\\t\\t\\t# they will also automatically be reachable for all further queries\\n            while edge_idx < len(edgeList) and edgeList[edge_idx][2] < t:\\n                # connect nodes\\n                uf.union(edgeList[edge_idx][0], edgeList[edge_idx][1])\\n                edge_idx += 1\\n            # see if the query nodes connected\\n            res[idx] = uf.connected(u, v)\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142667,
                "title": "c-disjoint-set-union-data-structure",
                "content": "* Sort queries based on limits .\\n\\n* Sort edgeList based on weights.\\n\\n* Find lower_bound of limit in edgeList . This indicates that upto `idx` index all the weighs in edgesList will be **strictly smaller** than `limit`.\\n\\n* For all the connections in edgeList make components/sets using DSU. (DSU is the best data strcuture for this purpose).\\n\\n* If Two elements come under a common set , then this shows that every edge in their path is strictly smalller than `limit`.\\n\\n\\n\\n\\n```\\nclass DSU{\\nprivate:\\n    int n ; \\n    vector<int> parent, rank ;\\n    \\npublic:\\n    DSU(int n){\\n        this->n = n ;\\n        parent.resize(n);\\n        iota(begin(parent),end(parent),0);\\n        rank.resize(n,1) ;\\n    }\\n    \\n    int find_parent(int node){\\n        if(node == parent[node]) return node ;\\n        return parent[node] = find_parent(parent[node]) ;\\n    }\\n    void Union(int u , int v){\\n        int U = find_parent(u) , V = find_parent(v) ;\\n        if(U == V) return ;\\n        if(rank[U] < rank[V]) swap(U,V) ;\\n        rank[U] += rank[V] ;\\n        parent[V] = U ;\\n    }\\n    \\n};\\n\\nstruct cmp{\\n    bool operator()(const vector<int> &v1 , const vector<int> &v2){\\n        return v1[2] < v2[2] ;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n) ;\\n        vector<bool> ans(queries.size(),false) ;\\n        for(int i = 0 ; i < queries.size() ; ++i ) queries[i].push_back(i) ;\\n        \\n        sort(begin(queries),end(queries),[&](const vector<int> &v1 ,const vector<int> &v2)->bool{\\n           return v1[2] < v2[2] ; \\n        });\\n        sort(begin(edgeList),end(edgeList),[&](const vector<int> &v1 , const vector<int> &v2)->bool{\\n           return v1[2] < v2[2] ; \\n        });\\n        \\n        // for(auto &x : edgeList) cout << x[2] << \" \" ; cout << endl ;\\n        // for(auto &x : queries) cout << x[2] << \" \" ; cout << endl ;\\n        \\n        int prev = 0 ;\\n        for(auto &x : queries){\\n            int p = x[0] , q = x[1] , limit = x[2] , i = x[3] ;\\n\\t\\t\\t// to make sure comparision is done based on 2nd index in edgeList form a custom comparator cmp\\n            int idx = lower_bound(begin(edgeList) + prev , end(edgeList),vector<int>{INT_MIN,INT_MIN,limit},cmp()) - begin(edgeList) - 1 ;\\n            \\n            for(int j = prev ; j <= idx ; ++j ){\\n                //cout << j << endl ;\\n                int u = edgeList[j][0] , v = edgeList[j][1] , dis = edgeList[j][2] ;\\n                dsu.Union(u,v) ;\\n            }\\n            prev = idx + 1 ;\\n\\t\\t\\t//Check if p and q fall under the same set or not ?\\n            if(dsu.find_parent(p) == dsu.find_parent(q)) ans[i] = true ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass DSU{\\nprivate:\\n    int n ; \\n    vector<int> parent, rank ;\\n    \\npublic:\\n    DSU(int n){\\n        this->n = n ;\\n        parent.resize(n);\\n        iota(begin(parent),end(parent),0);\\n        rank.resize(n,1) ;\\n    }\\n    \\n    int find_parent(int node){\\n        if(node == parent[node]) return node ;\\n        return parent[node] = find_parent(parent[node]) ;\\n    }\\n    void Union(int u , int v){\\n        int U = find_parent(u) , V = find_parent(v) ;\\n        if(U == V) return ;\\n        if(rank[U] < rank[V]) swap(U,V) ;\\n        rank[U] += rank[V] ;\\n        parent[V] = U ;\\n    }\\n    \\n};\\n\\nstruct cmp{\\n    bool operator()(const vector<int> &v1 , const vector<int> &v2){\\n        return v1[2] < v2[2] ;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n) ;\\n        vector<bool> ans(queries.size(),false) ;\\n        for(int i = 0 ; i < queries.size() ; ++i ) queries[i].push_back(i) ;\\n        \\n        sort(begin(queries),end(queries),[&](const vector<int> &v1 ,const vector<int> &v2)->bool{\\n           return v1[2] < v2[2] ; \\n        });\\n        sort(begin(edgeList),end(edgeList),[&](const vector<int> &v1 , const vector<int> &v2)->bool{\\n           return v1[2] < v2[2] ; \\n        });\\n        \\n        // for(auto &x : edgeList) cout << x[2] << \" \" ; cout << endl ;\\n        // for(auto &x : queries) cout << x[2] << \" \" ; cout << endl ;\\n        \\n        int prev = 0 ;\\n        for(auto &x : queries){\\n            int p = x[0] , q = x[1] , limit = x[2] , i = x[3] ;\\n\\t\\t\\t// to make sure comparision is done based on 2nd index in edgeList form a custom comparator cmp\\n            int idx = lower_bound(begin(edgeList) + prev , end(edgeList),vector<int>{INT_MIN,INT_MIN,limit},cmp()) - begin(edgeList) - 1 ;\\n            \\n            for(int j = prev ; j <= idx ; ++j ){\\n                //cout << j << endl ;\\n                int u = edgeList[j][0] , v = edgeList[j][1] , dis = edgeList[j][2] ;\\n                dsu.Union(u,v) ;\\n            }\\n            prev = idx + 1 ;\\n\\t\\t\\t//Check if p and q fall under the same set or not ?\\n            if(dsu.find_parent(p) == dsu.find_parent(q)) ans[i] = true ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2137561,
                "title": "java-solution",
                "content": "**First solution is a BFS solution which gives TLE: **\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        boolean[] output = new boolean[queries.length];\\n        \\n        Graph g = new Graph(n);\\n        \\n        for (int i=0; i<edgeList.length; i++) {\\n            g.addEdge(edgeList[i][0], edgeList[i][1], edgeList[i][2]);\\n        }\\n        \\n        for (int i=0; i<queries.length; i++) {\\n            int source = queries[i][0];\\n            int dest = queries[i][1];\\n            int limit = queries[i][2];\\n            boolean[] visited = new boolean[n];\\n            \\n            PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\\n            \\n            visited[source] = true;\\n            for (int j=0; j<g.arr.get(source).size(); j++) {\\n                int v = g.arr.get(source).get(j).v;\\n                int w = g.arr.get(source).get(j).weight;\\n                \\n                if (w < limit) {\\n                    pq.add(new int[]{v, w});\\n                }\\n                \\n            }\\n            \\n            pq.add(new int[]{source, 0});\\n            \\n            while (!pq.isEmpty()) {\\n                int[] current = pq.remove();\\n                \\n                int u = current[0];\\n                int dist = current[1];\\n                \\n                if (u == dest) {\\n                    output[i] = true;\\n                    break;\\n                }\\n                visited[u] = true;\\n                \\n                \\n               // System.out.println(u);\\n                for (int j=0; j<g.arr.get(u).size(); j++) {\\n                    int v = g.arr.get(u).get(j).v;\\n                    int w = g.arr.get(u).get(j).weight;\\n                \\n                    \\n                    \\n                    if (!visited[v] && w < limit) {\\n                       // System.out.println(v + \" \" + w);\\n                        pq.add(new int[]{v, w});\\n                    }\\n                } \\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\nclass Node {\\n    int v;\\n    int weight;\\n    \\n    public Node (int v, int weight) {\\n        this.v = v;\\n        this.weight = weight;\\n    } \\n}\\n\\nclass Graph{\\n    int V;\\n    List<List<Node>> arr;\\n    \\n    public Graph(int v) {\\n        V = v;\\n        \\n        arr = new ArrayList<>();\\n        \\n        for (int i=0; i<v; i++) {\\n            arr.add(new ArrayList<>());\\n        }\\n    }\\n    \\n    public void addEdge(int u, int v, int w) {\\n        arr.get(u).add(new Node(v, w));\\n        arr.get(v).add(new Node(u, w));\\n    }\\n}\\n\\n**Next solution uses Union Find and DSU algorthm which is clean and accepted - **\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        UnionFind uf = new UnionFind(n);\\n        \\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n        \\n        int[][] sortedQueries = new int[queries.length][4];\\n        \\n        for (int i=0; i<queries.length; i++) {\\n            sortedQueries[i][0] = queries[i][0];\\n            sortedQueries[i][1] = queries[i][1];\\n            sortedQueries[i][2] = queries[i][2];\\n            sortedQueries[i][3] = i;\\n        }\\n        \\n        Arrays.sort(sortedQueries, (a, b) -> a[2] - b[2]);\\n        \\n        int start = 0;\\n        boolean[] output = new boolean[queries.length];\\n        \\n        for (int i=0; i<sortedQueries.length; i++) {\\n            int[] query = sortedQueries[i];\\n            \\n            int w = query[2];\\n            \\n            while (start < edgeList.length && edgeList[start][2] < w) {\\n                uf.union(edgeList[start][0], edgeList[start][1]);\\n                start++;\\n            }\\n            \\n            if (uf.find(query[0]) == uf.find(query[1])) {\\n                output[query[3]] = true;\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parent;\\n    \\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        \\n        for (int i=0; i<n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    public int find(int x) {\\n        while (x != parent[x]) {\\n            x = parent[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    public void union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n        \\n        parent[xParent] = yParent;\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Breadth-First Search",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        boolean[] output = new boolean[queries.length];\\n        \\n        Graph g = new Graph(n);\\n        \\n        for (int i=0; i<edgeList.length; i++) {\\n            g.addEdge(edgeList[i][0], edgeList[i][1], edgeList[i][2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2081006,
                "title": "java-union-find-o-vlog-v-elog-e-faster-than-96-7",
                "content": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int queryLen = queries.length;\\n        int[][] queryWithIds = new int[queryLen][4];\\n        \\n        for (int i = 0; i < queryLen; i++) {\\n            queryWithIds[i] = new int[] {\\n              i, queries[i][0], queries[i][1], queries[i][2] \\n            };\\n        }\\n        // sort quries by limit\\n        Arrays.parallelSort(queryWithIds, (r1, r2) -> Integer.compare(r1[3], r2[3]));\\n        // sort edges by dis\\n        Arrays.parallelSort(edgeList, (r1, r2) -> Integer.compare(r1[2], r2[2]));\\n        int edgeTop = 0;\\n        boolean[] result = new boolean[queryLen];\\n        // initialize UnionFind object\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < queryLen; i++) {\\n            int limit = queryWithIds[i][3];\\n            while (edgeTop < edgeList.length && edgeList[edgeTop][2] < limit) {\\n                uf.union(edgeList[edgeTop][0], edgeList[edgeTop][1]);\\n                edgeTop++;\\n            }\\n            result[queryWithIds[i][0]] = uf.find(queryWithIds[i][1]) == uf.find(queryWithIds[i][2]);\\n        }\\n        return result;\\n    }\\n    private static class UnionFind {\\n        private int[] root;\\n        private int[] rank;\\n        public UnionFind(int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            Arrays.fill(this.root, -1);\\n        }\\n        public int find(int target) {\\n            if (root[target] == -1) return target;\\n            return root[target] = find(root[target]);\\n        }\\n        public void union(int t1, int t2) {\\n            int r1 = find(t1);\\n            int r2 = find(t2);\\n            if (r1 != r2) {\\n                if (rank[r1] > rank[r2]) {\\n                    root[r2] = r1;\\n                } else if (rank[r2] > rank[r1]) {\\n                    root[r1] = r2;\\n                } else {\\n                    root[r2] = r1;\\n                    rank[r1]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int queryLen = queries.length;\\n        int[][] queryWithIds = new int[queryLen][4];\\n        \\n        for (int i = 0; i < queryLen; i++) {\\n            queryWithIds[i] = new int[] {\\n              i, queries[i][0], queries[i][1], queries[i][2] \\n            };\\n        }\\n        // sort quries by limit\\n        Arrays.parallelSort(queryWithIds, (r1, r2) -> Integer.compare(r1[3], r2[3]));\\n        // sort edges by dis\\n        Arrays.parallelSort(edgeList, (r1, r2) -> Integer.compare(r1[2], r2[2]));\\n        int edgeTop = 0;\\n        boolean[] result = new boolean[queryLen];\\n        // initialize UnionFind object\\n        UnionFind uf = new UnionFind(n);\\n        for (int i = 0; i < queryLen; i++) {\\n            int limit = queryWithIds[i][3];\\n            while (edgeTop < edgeList.length && edgeList[edgeTop][2] < limit) {\\n                uf.union(edgeList[edgeTop][0], edgeList[edgeTop][1]);\\n                edgeTop++;\\n            }\\n            result[queryWithIds[i][0]] = uf.find(queryWithIds[i][1]) == uf.find(queryWithIds[i][2]);\\n        }\\n        return result;\\n    }\\n    private static class UnionFind {\\n        private int[] root;\\n        private int[] rank;\\n        public UnionFind(int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            Arrays.fill(this.root, -1);\\n        }\\n        public int find(int target) {\\n            if (root[target] == -1) return target;\\n            return root[target] = find(root[target]);\\n        }\\n        public void union(int t1, int t2) {\\n            int r1 = find(t1);\\n            int r2 = find(t2);\\n            if (r1 != r2) {\\n                if (rank[r1] > rank[r2]) {\\n                    root[r2] = r1;\\n                } else if (rank[r2] > rank[r1]) {\\n                    root[r1] = r2;\\n                } else {\\n                    root[r2] = r1;\\n                    rank[r1]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598251,
                "title": "golang-union-find-solution-by-golang",
                "content": "1. Sort queries by limit\\n2. Sort edges by distance\\n3. For each query, Connect all the edges whose distances are less than limit by union find\\n4. If queries[0] and queries[1] meet the requirement, they should be in same group.\\n```\\nfunc DistanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n\\tvar q_len int = len(queries)\\n\\tvar record []int = make([]int,q_len)\\n\\tfor i := 0;i < q_len;i++{\\n\\t\\trecord[i] = i\\n\\t}\\n\\ttype funcType func (groups []int,node int)int\\n\\tvar get_parent funcType\\n\\tget_parent = func (groups []int,node int)int{\\n\\t\\tif groups[node] != node{\\n\\t\\t\\tgroups[node] = get_parent(groups,groups[node])\\n\\t\\t}\\n\\t\\treturn groups[node]\\n\\t}\\n\\tsort.Slice(record, func(i, j int) bool {\\n\\t\\treturn queries[record[i]][2] < queries[record[j]][2]\\n\\t})\\n\\tsort.Slice(edgeList, func(i, j int) bool {\\n\\t\\treturn edgeList[i][2] < edgeList[j][2]\\n\\t})\\n\\tvar groups []int = make([]int,n)\\n\\tfor i := 0;i < n;i++{\\n\\t\\tgroups[i] = i\\n\\t}\\n\\tvar res []bool = make([]bool,q_len)\\n\\tvar edge_idx int = 0\\n\\tvar edge_len int = len(edgeList)\\n\\tfor i := 0;i < q_len;i++{\\n\\t\\tfor edge_idx < edge_len && edgeList[edge_idx][2] < queries[record[i]][2]{\\n\\t\\t\\tnode1 := edgeList[edge_idx][0]\\n\\t\\t\\tnode2 := edgeList[edge_idx][1]\\n\\t\\t\\tgroup1 := get_parent(groups,node1)\\n\\t\\t\\tgroup2 := get_parent(groups,node2)\\n\\t\\t\\tif group1 != group2{\\n\\t\\t\\t\\tif group1 < group2{\\n\\t\\t\\t\\t\\tgroups[group2] = group1\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tgroups[group1] = group2\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tedge_idx++\\n\\t\\t}\\n\\t\\tn1 := queries[record[i]][0]\\n\\t\\tn2 := queries[record[i]][1]\\n\\t\\tif get_parent(groups,n1) == get_parent(groups,n2){\\n\\t\\t\\tres[record[i]] = true\\n\\t\\t}else{\\n\\t\\t\\tres[record[i]] = false\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc DistanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n\\tvar q_len int = len(queries)\\n\\tvar record []int = make([]int,q_len)\\n\\tfor i := 0;i < q_len;i++{\\n\\t\\trecord[i] = i\\n\\t}\\n\\ttype funcType func (groups []int,node int)int\\n\\tvar get_parent funcType\\n\\tget_parent = func (groups []int,node int)int{\\n\\t\\tif groups[node] != node{\\n\\t\\t\\tgroups[node] = get_parent(groups,groups[node])\\n\\t\\t}\\n\\t\\treturn groups[node]\\n\\t}\\n\\tsort.Slice(record, func(i, j int) bool {\\n\\t\\treturn queries[record[i]][2] < queries[record[j]][2]\\n\\t})\\n\\tsort.Slice(edgeList, func(i, j int) bool {\\n\\t\\treturn edgeList[i][2] < edgeList[j][2]\\n\\t})\\n\\tvar groups []int = make([]int,n)\\n\\tfor i := 0;i < n;i++{\\n\\t\\tgroups[i] = i\\n\\t}\\n\\tvar res []bool = make([]bool,q_len)\\n\\tvar edge_idx int = 0\\n\\tvar edge_len int = len(edgeList)\\n\\tfor i := 0;i < q_len;i++{\\n\\t\\tfor edge_idx < edge_len && edgeList[edge_idx][2] < queries[record[i]][2]{\\n\\t\\t\\tnode1 := edgeList[edge_idx][0]\\n\\t\\t\\tnode2 := edgeList[edge_idx][1]\\n\\t\\t\\tgroup1 := get_parent(groups,node1)\\n\\t\\t\\tgroup2 := get_parent(groups,node2)\\n\\t\\t\\tif group1 != group2{\\n\\t\\t\\t\\tif group1 < group2{\\n\\t\\t\\t\\t\\tgroups[group2] = group1\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tgroups[group1] = group2\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tedge_idx++\\n\\t\\t}\\n\\t\\tn1 := queries[record[i]][0]\\n\\t\\tn2 := queries[record[i]][1]\\n\\t\\tif get_parent(groups,n1) == get_parent(groups,n2){\\n\\t\\t\\tres[record[i]] = true\\n\\t\\t}else{\\n\\t\\t\\tres[record[i]] = false\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1454862,
                "title": "c-dsu-solution-explained",
                "content": "```\\nbool cmp(vector<int>& a, vector<int>& b){\\n    return a[2]<b[2];\\n}\\nclass Solution {\\npublic:\\n    int par[100002];\\n    \\n    int find(int a){\\n        if(par[a]==a) return a;\\n        return par[a]=find(par[a]);\\n    }\\n    \\n    void uni(int a, int b){\\n        a=find(a);\\n        b=find(b);\\n        if(a==b) return;\\n        if(a<b) swap(a,b);\\n        par[b]=a;\\n    }\\n\\t\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edge, vector<vector<int>>& queries) {\\n        int i=0,j=0;\\n        int q=queries.size();\\n        \\n        vector<vector<int> > qu;\\n\\t\\t\\n        for(i=0;i<queries.size();i++){\\n            qu.push_back({queries[i][0],queries[i][1],queries[i][2],i}); //storing the index of query to keep mark of after sorting\\n        }\\n\\t\\t\\n        sort(edge.begin(), edge.end(), cmp); //sort edge according to distance\\n        sort(qu.begin(), qu.end(),cmp); //sort queries according to limit\\n        \\n        for(i=0;i<n+1;i++){\\n            par[i]=i;\\n        }\\n        i=0;\\n        vector<bool> ans(q);\\n\\t\\t\\n        while(i<q){\\n            while(j<edge.size() && edge[j][2]<qu[i][2]){ //checking if edge dist is less than current limit, then union \\n                uni(edge[j][0], edge[j][1]);\\n                j++;\\n            }\\n            if(find(qu[i][0]) == find(qu[i][1])) ans[qu[i][3]]=true;\\n            else ans[qu[i][3]]=false;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nbool cmp(vector<int>& a, vector<int>& b){\\n    return a[2]<b[2];\\n}\\nclass Solution {\\npublic:\\n    int par[100002];\\n    \\n    int find(int a){\\n        if(par[a]==a) return a;\\n        return par[a]=find(par[a]);\\n    }\\n    \\n    void uni(int a, int b){\\n        a=find(a);\\n        b=find(b);\\n        if(a==b) return;\\n        if(a<b) swap(a,b);\\n        par[b]=a;\\n    }\\n\\t\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edge, vector<vector<int>>& queries) {\\n        int i=0,j=0;\\n        int q=queries.size();\\n        \\n        vector<vector<int> > qu;\\n\\t\\t\\n        for(i=0;i<queries.size();i++){\\n            qu.push_back({queries[i][0],queries[i][1],queries[i][2],i}); //storing the index of query to keep mark of after sorting\\n        }\\n\\t\\t\\n        sort(edge.begin(), edge.end(), cmp); //sort edge according to distance\\n        sort(qu.begin(), qu.end(),cmp); //sort queries according to limit\\n        \\n        for(i=0;i<n+1;i++){\\n            par[i]=i;\\n        }\\n        i=0;\\n        vector<bool> ans(q);\\n\\t\\t\\n        while(i<q){\\n            while(j<edge.size() && edge[j][2]<qu[i][2]){ //checking if edge dist is less than current limit, then union \\n                uni(edge[j][0], edge[j][1]);\\n                j++;\\n            }\\n            if(find(qu[i][0]) == find(qu[i][1])) ans[qu[i][3]]=true;\\n            else ans[qu[i][3]]=false;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396567,
                "title": "dp-binarylifting",
                "content": "```\\nvector<set<int>>g;\\nmap<vector<int>,int>cost;\\nvector<int>h,vis;\\nmap<int,int>par;\\nint ances[100005][18],dp[100005][18];\\nvoid dfs(int u,int p){\\n    vis[u]=1;\\n    ances[u][0]=p;\\n    vector<int>tmp={p,u};\\n    dp[u][0]=cost[tmp];\\n    for(int i=1;i<18;i++){\\n        dp[u][i]=max(dp[ances[u][i-1]][i-1],dp[u][i-1]);\\n        ances[u][i]=ances[ances[u][i-1]][i-1];\\n    }\\n    h[u]=h[p]+1;\\n    for(int child:g[u]){\\n        if(vis[child])continue;\\n        dfs(child,u);\\n    }\\n}\\nint climb(int u,int ht,int &res){\\n    int bit=17;\\n    while(ht>0 and bit>=0){\\n        if((ht&(1<<bit))>0){\\n            ht-=(1<<bit);\\n            res=max(dp[u][bit],res);\\n            u=ances[u][bit];\\n        }\\n        bit--;\\n    }\\n    return u;\\n}\\nint find(int u){\\n    if(!par.count(u) or par[u]==u)return par[u]=u;\\n    return par[u]=find(par[u]);\\n}\\nint lca(int u,int v,int& res){\\n    int res1=0;\\n    if(h[u]<h[v])swap(u,v);\\n    u=climb(u,h[u]-h[v],res1);\\n    res=max(res1,res);\\n    res1=0;\\n    if(u==v)return u;\\n    int bit=17;\\n    while(ances[u][0]!=ances[v][0] and bit>=0){\\n        if(ances[u][bit]==ances[v][bit]){\\n            bit--;\\n            continue;\\n        }\\n        res=max(dp[u][bit],res);\\n        res=max(dp[v][bit],res);\\n        u=ances[u][bit];\\n        v=ances[v][bit];\\n        bit--;\\n    }\\n    res=max(res,dp[u][0]);\\n    res=max(res,dp[v][0]);\\n    return ances[u][0];\\n}\\n\\nclass Solution {\\npublic:\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& e, vector<vector<int>>& q) {\\n    memset(dp,0,sizeof(dp));\\n    memset(ances,0,sizeof(ances));\\n    h=vector<int>(n,0);\\n    g=vector<set<int>>(n);\\n    vis=vector<int>(n,0);\\n    cost.clear();\\n    par.clear();\\n    vector<vector<int>>el(0);\\n    for(auto v:e){\\n        el.push_back({v[2],v[0],v[1]});\\n    }\\n    sort(el.begin(),el.end());\\n    for(auto v:el){\\n        \\n        int p1=find(v[1]);\\n        int p2=find(v[2]);\\n        if(p1==p2)continue;\\n        par[p1]=p2;\\n        vector<int>tmp={v[1],v[2]};\\n        vector<int>tmp1={v[2],v[1]};\\n        cost[tmp1]=v[0];\\n        cost[tmp]=v[0];\\n        g[v[1]].insert(v[2]);\\n        g[v[2]].insert(v[1]);\\n    }\\n    for(int i=0;i<n;i++){\\n        if(vis[i])continue;\\n        cost[{i,i}]=0;\\n        dfs(i,i);\\n    }\\n    vector<bool>res(0);\\n    for(auto v:q){\\n        int ans=0;\\n        lca(v[0],v[1],ans);\\n        \\n        if(ans<v[2] and find(v[0])==find(v[1]))res.push_back(1);\\n        else res.push_back(0);\\n    }\\n    return res;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvector<set<int>>g;\\nmap<vector<int>,int>cost;\\nvector<int>h,vis;\\nmap<int,int>par;\\nint ances[100005][18],dp[100005][18];\\nvoid dfs(int u,int p){\\n    vis[u]=1;\\n    ances[u][0]=p;\\n    vector<int>tmp={p,u};\\n    dp[u][0]=cost[tmp];\\n    for(int i=1;i<18;i++){\\n        dp[u][i]=max(dp[ances[u][i-1]][i-1],dp[u][i-1]);\\n        ances[u][i]=ances[ances[u][i-1]][i-1];\\n    }\\n    h[u]=h[p]+1;\\n    for(int child:g[u]){\\n        if(vis[child])continue;\\n        dfs(child,u);\\n    }\\n}\\nint climb(int u,int ht,int &res){\\n    int bit=17;\\n    while(ht>0 and bit>=0){\\n        if((ht&(1<<bit))>0){\\n            ht-=(1<<bit);\\n            res=max(dp[u][bit],res);\\n            u=ances[u][bit];\\n        }\\n        bit--;\\n    }\\n    return u;\\n}\\nint find(int u){\\n    if(!par.count(u) or par[u]==u)return par[u]=u;\\n    return par[u]=find(par[u]);\\n}\\nint lca(int u,int v,int& res){\\n    int res1=0;\\n    if(h[u]<h[v])swap(u,v);\\n    u=climb(u,h[u]-h[v],res1);\\n    res=max(res1,res);\\n    res1=0;\\n    if(u==v)return u;\\n    int bit=17;\\n    while(ances[u][0]!=ances[v][0] and bit>=0){\\n        if(ances[u][bit]==ances[v][bit]){\\n            bit--;\\n            continue;\\n        }\\n        res=max(dp[u][bit],res);\\n        res=max(dp[v][bit],res);\\n        u=ances[u][bit];\\n        v=ances[v][bit];\\n        bit--;\\n    }\\n    res=max(res,dp[u][0]);\\n    res=max(res,dp[v][0]);\\n    return ances[u][0];\\n}\\n\\nclass Solution {\\npublic:\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& e, vector<vector<int>>& q) {\\n    memset(dp,0,sizeof(dp));\\n    memset(ances,0,sizeof(ances));\\n    h=vector<int>(n,0);\\n    g=vector<set<int>>(n);\\n    vis=vector<int>(n,0);\\n    cost.clear();\\n    par.clear();\\n    vector<vector<int>>el(0);\\n    for(auto v:e){\\n        el.push_back({v[2],v[0],v[1]});\\n    }\\n    sort(el.begin(),el.end());\\n    for(auto v:el){\\n        \\n        int p1=find(v[1]);\\n        int p2=find(v[2]);\\n        if(p1==p2)continue;\\n        par[p1]=p2;\\n        vector<int>tmp={v[1],v[2]};\\n        vector<int>tmp1={v[2],v[1]};\\n        cost[tmp1]=v[0];\\n        cost[tmp]=v[0];\\n        g[v[1]].insert(v[2]);\\n        g[v[2]].insert(v[1]);\\n    }\\n    for(int i=0;i<n;i++){\\n        if(vis[i])continue;\\n        cost[{i,i}]=0;\\n        dfs(i,i);\\n    }\\n    vector<bool>res(0);\\n    for(auto v:q){\\n        int ans=0;\\n        lca(v[0],v[1],ans);\\n        \\n        if(ans<v[2] and find(v[0])==find(v[1]))res.push_back(1);\\n        else res.push_back(0);\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391174,
                "title": "c-o-n-log-n-union-find",
                "content": "```\\n\\tvoid merge(int a, int b, vector<int>& sets){\\n        int x=find(a,sets),y=find(b,sets);\\n        if(x!=y){\\n            sets[x]=y;\\n        }\\n    }\\n    int find(int a, vector<int>& sets){\\n        return sets[a]==a?a:sets[a]=find(sets[a],sets);\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        sort(edgeList.begin(), edgeList.end(), [](vector<int> a, vector<int> b){\\n            return a[2]<b[2];\\n        });\\n        int m=queries.size();\\n        int idx[m];\\n        for(int i=0;i<m;i++){\\n            idx[i]=i;\\n        }\\n        sort(idx,idx+m,[&queries](int a, int b){\\n            return queries[a][2]<queries[b][2];\\n        });\\n        vector<int> sets(n);\\n        for(int i=0;i<n;i++){\\n            sets[i]=i;\\n        }\\n        vector<bool> ans(m);\\n        int i=0;\\n        for(int j=0;j<m;j++){\\n            while(i<edgeList.size() && edgeList[i][2]<queries[idx[j]][2]){\\n                merge(edgeList[i][0],edgeList[i][1],sets);\\n                i++;\\n            }\\n            ans[idx[j]]=find(queries[idx[j]][0],sets)==find(queries[idx[j]][1],sets);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tvoid merge(int a, int b, vector<int>& sets){\\n        int x=find(a,sets),y=find(b,sets);\\n        if(x!=y){\\n            sets[x]=y;\\n        }\\n    }\\n    int find(int a, vector<int>& sets){\\n        return sets[a]==a?a:sets[a]=find(sets[a],sets);\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        sort(edgeList.begin(), edgeList.end(), [](vector<int> a, vector<int> b){\\n            return a[2]<b[2];\\n        });\\n        int m=queries.size();\\n        int idx[m];\\n        for(int i=0;i<m;i++){\\n            idx[i]=i;\\n        }\\n        sort(idx,idx+m,[&queries](int a, int b){\\n            return queries[a][2]<queries[b][2];\\n        });\\n        vector<int> sets(n);\\n        for(int i=0;i<n;i++){\\n            sets[i]=i;\\n        }\\n        vector<bool> ans(m);\\n        int i=0;\\n        for(int j=0;j<m;j++){\\n            while(i<edgeList.size() && edgeList[i][2]<queries[idx[j]][2]){\\n                merge(edgeList[i][0],edgeList[i][1],sets);\\n                i++;\\n            }\\n            ans[idx[j]]=find(queries[idx[j]][0],sets)==find(queries[idx[j]][1],sets);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1128870,
                "title": "java-union-find-97-69-faster",
                "content": "```\\n\\tint[] parent;\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int qSize= queries.length, eSize= edgeList.length;\\n        parent= new int[n];\\n        for(int i=0; i<n; i++) parent[i]= i;\\n        Arrays.sort(edgeList,(a,b)->a[2]-b[2]);\\n        int[][] sortedQ= new int[qSize][];\\n        boolean[] res= new boolean[qSize];\\n        for(int i=0; i<qSize; i++){\\n            sortedQ[i]= new int[]{queries[i][0],queries[i][1],queries[i][2],i};\\n        }\\n        Arrays.sort(sortedQ,(a,b)->a[2]-b[2]);\\n        int index= 0;\\n        for(int[] query: sortedQ){\\n            while(index<eSize && edgeList[index][2]<query[2]) union(edgeList[index][0],edgeList[index++][1]);\\n            res[query[3]]= find(query[0])==find(query[1]);\\n        }\\n        return res;\\n    }\\n    public void union(int v1, int v2){\\n        int group1= find(v1), group2= find(v2);\\n        parent[group1]= group2;\\n    }\\n    public int find(int v){\\n        while(v!=parent[v]){\\n            parent[v]= parent[parent[parent[v]]];\\n            v= parent[v];\\n        }\\n        return v;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tint[] parent;\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        int qSize= queries.length, eSize= edgeList.length;\\n        parent= new int[n];\\n        for(int i=0; i<n; i++) parent[i]= i;\\n        Arrays.sort(edgeList,(a,b)->a[2]-b[2]);\\n        int[][] sortedQ= new int[qSize][];\\n        boolean[] res= new boolean[qSize];\\n        for(int i=0; i<qSize; i++){\\n            sortedQ[i]= new int[]{queries[i][0],queries[i][1],queries[i][2],i};\\n        }\\n        Arrays.sort(sortedQ,(a,b)->a[2]-b[2]);\\n        int index= 0;\\n        for(int[] query: sortedQ){\\n            while(index<eSize && edgeList[index][2]<query[2]) union(edgeList[index][0],edgeList[index++][1]);\\n            res[query[3]]= find(query[0])==find(query[1]);\\n        }\\n        return res;\\n    }\\n    public void union(int v1, int v2){\\n        int group1= find(v1), group2= find(v2);\\n        parent[group1]= group2;\\n    }\\n    public int find(int v){\\n        while(v!=parent[v]){\\n            parent[v]= parent[parent[parent[v]]];\\n            v= parent[v];\\n        }\\n        return v;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1044238,
                "title": "ruby-union-find",
                "content": "Sort edges and queries by weight remembering initial queries order.\\n\\nIterate queries in weight ascending order. Combain vertices with edges having weight < query weight.\\n\\nFor each query check if vertices are combined (belong to the same group).\\n  \\n```ruby\\ndef distance_limited_paths_exist(n, edge_list, queries)\\n  # Union-find\\n  par = *0...n # parent vertices for combined groups\\n  find = ->(x) { par[x] == x ? x : (par[x] = find[par[x]]) }\\n  merge = ->(x, y, _w) { par[find[x]] = find[y] }\\n\\n  ret = Array.new(queries.size, false)\\n\\n  edges = edge_list.sort_by(&:last) # sort by weight\\n  qs = queries.map.with_index { |(u, v, w), i| [w, u, v, i] }.sort\\n  \\n  for w, u, v, i in qs\\n    merge[*edges.shift] while edges.any? && edges.first.last < w\\n    ret[i] = find[u] == find[v]\\n  end\\n  ret\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Union Find"
                ],
                "code": "```ruby\\ndef distance_limited_paths_exist(n, edge_list, queries)\\n  # Union-find\\n  par = *0...n # parent vertices for combined groups\\n  find = ->(x) { par[x] == x ? x : (par[x] = find[par[x]]) }\\n  merge = ->(x, y, _w) { par[find[x]] = find[y] }\\n\\n  ret = Array.new(queries.size, false)\\n\\n  edges = edge_list.sort_by(&:last) # sort by weight\\n  qs = queries.map.with_index { |(u, v, w), i| [w, u, v, i] }.sort\\n  \\n  for w, u, v, i in qs\\n    merge[*edges.shift] while edges.any? && edges.first.last < w\\n    ret[i] = find[u] == find[v]\\n  end\\n  ret\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1035435,
                "title": "java-union-find-solution-o-nlogn-o-n",
                "content": "```\\nclass Solution {\\n    private int[] f;\\n   \\n    private void init(int n) {\\n        f = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            f[i] = i;\\n        }\\n    }\\n    \\n    private int find(int x) {\\n        if (f[x] == x) {\\n            return x;\\n        }\\n        \\n        return f[x] = find(f[x]);\\n    }\\n    \\n    private void union(int x, int y) {\\n        int p = find(x);\\n        int q = find(y);\\n        \\n        if (p != q) {\\n            f[p] = q;\\n        }\\n    }\\n    \\n    class Query implements Comparable<Query> {\\n        int[] qry;\\n        int index;\\n        \\n        public Query(int[] qry, int index) {\\n            this.qry = qry;\\n            this.index = index;\\n        }\\n        \\n        public int compareTo(Query q) {\\n            return this.qry[2] - q.qry[2];\\n        }\\n    }\\n    \\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        if (edgeList == null || edgeList.length == 0 || queries == null || queries.length == 0) {\\n            return new boolean[0];\\n        }\\n        \\n        Arrays.sort(edgeList, (e1, e2) -> e1[2] - e2[2]);\\n        \\n        List<Query> list = new ArrayList();\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            list.add(new Query(queries[i], i));\\n        }\\n        \\n        Collections.sort(list);\\n        \\n        init(n);\\n        \\n        boolean[] res = new boolean[queries.length];\\n        \\n        int prevLimit = 0;\\n        int curLimit = 0;\\n        int prevIndex = 0;\\n        \\n        for (int i = 0; i < list.size(); i++) {\\n            Query q = list.get(i);\\n            \\n            curLimit = q.qry[2];\\n            \\n            // add new edges to union\\n            prevIndex = addEdges(prevIndex, prevLimit, curLimit, edgeList);\\n            \\n            // if two nodes has a valid path, put true\\n            if (find(q.qry[0]) == find(q.qry[1])) {\\n                res[q.index] = true;\\n            }\\n            \\n            prevLimit = curLimit;\\n        }\\n        \\n        \\n        return res;\\n    }\\n    \\n    // add new edges to uf\\n    private int addEdges(int prevIndex, int prevLimit, int curLimit, int[][] edges) {\\n        int i = prevIndex;\\n        \\n        for (i = prevIndex; i < edges.length; i++) {\\n            if (edges[i][2] >= prevLimit && edges[i][2] < curLimit) {\\n                union(edges[i][0], edges[i][1]);\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        \\n        return i;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int[] f;\\n   \\n    private void init(int n) {\\n        f = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            f[i] = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 999735,
                "title": "c-solution-using-union-find-method",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int find(int n,int parent[])\\n    {\\n        if(parent[n]==-1)\\n            return n;\\n        return parent[n]=find(parent[n],parent);\\n    }\\n    \\n    bool compare(vector<int> &a,vector<int>&b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n      multimap<int,array<int,3>> mmp;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            mmp.insert({queries[i][2],{queries[i][0],queries[i][1],i}});\\n        }\\n        // sort(edgeList.begin(),edgeList.end(),compare);\\n        sort(begin(edgeList), end(edgeList), [](vector<int> &a, vector<int> &b) { return a[2] < b[2]; });\\n        int parent[n];\\n        memset(parent,-1,sizeof(parent));\\n        vector<bool> ans(queries.size());\\n        \\n        int index_edge=0;\\n        \\n        for(auto &querie:mmp)\\n        {\\n            while(index_edge<edgeList.size() and querie.first>edgeList[index_edge][2])\\n            {\\n                int parent1=find(edgeList[index_edge][0],parent);\\n                int parent2=find(edgeList[index_edge][1],parent);\\n                // parent[edgeList[index_edge][0]]=parent1;\\n                // parent[edgeList[index_edge][1]]=parent2;\\n                // cout<<parent1<<\" \"<<parent2<<endl;\\n                if(parent1!=parent2)\\n                {\\n                    parent[parent1]=parent2; \\n                }\\n                index_edge++;\\n                // cout<<index_edge<<\" \"<<querie.first<<\" \"<<edgeList[index_edge][2]<<\" \"<<edgeList.size()<<endl;\\n            }\\n            if(find(querie.second[0],parent)==find(querie.second[1],parent))\\n                ans[querie.second[2]]=true;\\n            else\\n                ans[querie.second[2]]=false;\\n            \\n        }\\n        for(int i=0;i<edgeList.size();i++)\\n            cout<<edgeList[i][2]<<\" \";\\n        // for(int i=0;i<n;i++)\\n        //     cout<<parent[i]<<\" \";\\n        return ans;\\n           \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int find(int n,int parent[])\\n    {\\n        if(parent[n]==-1)\\n            return n;\\n        return parent[n]=find(parent[n],parent);\\n    }\\n    \\n    bool compare(vector<int> &a,vector<int>&b)\\n    {\\n        return a[2]<b[2];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n      multimap<int,array<int,3>> mmp;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            mmp.insert({queries[i][2],{queries[i][0],queries[i][1],i}});\\n        }\\n        // sort(edgeList.begin(),edgeList.end(),compare);\\n        sort(begin(edgeList), end(edgeList), [](vector<int> &a, vector<int> &b) { return a[2] < b[2]; });\\n        int parent[n];\\n        memset(parent,-1,sizeof(parent));\\n        vector<bool> ans(queries.size());\\n        \\n        int index_edge=0;\\n        \\n        for(auto &querie:mmp)\\n        {\\n            while(index_edge<edgeList.size() and querie.first>edgeList[index_edge][2])\\n            {\\n                int parent1=find(edgeList[index_edge][0],parent);\\n                int parent2=find(edgeList[index_edge][1],parent);\\n                // parent[edgeList[index_edge][0]]=parent1;\\n                // parent[edgeList[index_edge][1]]=parent2;\\n                // cout<<parent1<<\" \"<<parent2<<endl;\\n                if(parent1!=parent2)\\n                {\\n                    parent[parent1]=parent2; \\n                }\\n                index_edge++;\\n                // cout<<index_edge<<\" \"<<querie.first<<\" \"<<edgeList[index_edge][2]<<\" \"<<edgeList.size()<<endl;\\n            }\\n            if(find(querie.second[0],parent)==find(querie.second[1],parent))\\n                ans[querie.second[2]]=true;\\n            else\\n                ans[querie.second[2]]=false;\\n            \\n        }\\n        for(int i=0;i<edgeList.size();i++)\\n            cout<<edgeList[i][2]<<\" \";\\n        // for(int i=0;i<n;i++)\\n        //     cout<<parent[i]<<\" \";\\n        return ans;\\n           \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 986236,
                "title": "very-simple-solution-with-explanations",
                "content": "Using DSU, we can add edges from small weight to large weight, and query from small limit to large limit. \\n\\nTime complexity:` O(E log E) + O(Q log Q)`\\nSpace complexity: `O(n)`\\n\\n```\\n    class DSU {\\n        vector<int> parent, rank;\\n        public:\\n        DSU(int n) {\\n            parent.resize(n);\\n            for (int x = 0; x < n; x++) {\\n                parent[x] = x;\\n            }\\n            rank.resize(n);\\n        }\\n        int find(int x) {\\n            int p = parent[x];\\n            if (p == x) return x;\\n            return parent[x] = find(p);\\n        }\\n        void unions(int x, int y) {\\n            x = find(x); y = find(y);\\n            if (x == y) return;\\n            \\n            if (rank[x] == rank[y]) rank[x]++;\\n            else if (rank[x] < rank[y]) swap(x, y);\\n            parent[y] = x;\\n        }\\n    };\\n    \\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        auto cmp = [&](vector<int> &a, vector<int> &b) {\\n          return a[2] < b[2];  \\n        };\\n        sort(edgeList.begin(), edgeList.end(), cmp); // sort by weight\\n        \\n        for (int i = 0; i < queries.size(); i++) queries[i].push_back(i); // record index\\n        sort(queries.begin(), queries.end(), cmp);  // sort by limit\\n        \\n        DSU dsu(n);\\n        vector<bool> res(queries.size());\\n        int i = 0;\\n        for (auto &q : queries) {\\n            while(i < edgeList.size() && edgeList[i][2] < q[2]) { // only take edges with smaller weight than limit\\n                dsu.unions(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n            res[q[3]] = dsu.find(q[0]) == dsu.find(q[1]);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Using DSU, we can add edges from small weight to large weight, and query from small limit to large limit. \\n\\nTime complexity:` O(E log E) + O(Q log Q)`\\nSpace complexity: `O(n)`\\n\\n```\\n    class DSU {\\n        vector<int> parent, rank;\\n        public:\\n        DSU(int n) {\\n            parent.resize(n);\\n            for (int x = 0; x < n; x++) {\\n                parent[x] = x;\\n            }\\n            rank.resize(n);\\n        }\\n        int find(int x) {\\n            int p = parent[x];\\n            if (p == x) return x;\\n            return parent[x] = find(p);\\n        }\\n        void unions(int x, int y) {\\n            x = find(x); y = find(y);\\n            if (x == y) return;\\n            \\n            if (rank[x] == rank[y]) rank[x]++;\\n            else if (rank[x] < rank[y]) swap(x, y);\\n            parent[y] = x;\\n        }\\n    };\\n    \\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        auto cmp = [&](vector<int> &a, vector<int> &b) {\\n          return a[2] < b[2];  \\n        };\\n        sort(edgeList.begin(), edgeList.end(), cmp); // sort by weight\\n        \\n        for (int i = 0; i < queries.size(); i++) queries[i].push_back(i); // record index\\n        sort(queries.begin(), queries.end(), cmp);  // sort by limit\\n        \\n        DSU dsu(n);\\n        vector<bool> res(queries.size());\\n        int i = 0;\\n        for (auto &q : queries) {\\n            while(i < edgeList.size() && edgeList[i][2] < q[2]) { // only take edges with smaller weight than limit\\n                dsu.unions(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n            res[q[3]] = dsu.find(q[0]) == dsu.find(q[1]);\\n        }\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 983767,
                "title": "javascript-union-find-with-disjoint-set-rank-optimization",
                "content": "Haven\\'t touched UF for a while, use this as a point to write a general implementation for disjoint sets. \\n\\nMost folks do is use an array of integer for parents. Instead used map and don\\'t initiazlize the size of DS in the beginning, so the class is a little more inclusive. For this problem we are giving the nodes as integer, but if I am going to present this problem with alphabetic letters, the array solution would have to create a map and reverse map for coding/decoding.\\n\\nHere is the code:\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edgeList\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nclass DisjointSet {\\n  constructor (){\\n    this.parents = {};\\n    this.ranks = {};\\n  }\\n  \\n  union (x, y) {\\n    let xr = this.find(x), yr = this.find(y);\\n    if(this.ranks[xr] < this.ranks[yr]){\\n      this.parents[xr] = yr;\\n    }else{\\n      this.parents[yr] = xr;\\n      if(this.ranks[xr] == this.ranks[yr]) this.ranks[yr] += 1\\n    }\\n  }\\n  \\n  find(x) {\\n    if(!(x in this.ranks)){\\n      this.parents[x] = x;\\n      this.ranks[x] = 0;\\n    }\\n    if(this.parents[x] != x){\\n      this.parents[x] = this.find(this.parents[x])\\n    }\\n    return this.parents[x];\\n  }\\n  \\n  isConnected(x, y){\\n    return this.find(x) == this.find(y)\\n  }\\n}\\n// disjoint set with both sorted\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n  edgeList.sort((a, b) => a[2] - b[2])\\n  queries = queries.map((v, ind) => [...v, ind]).sort((a, b) => a[2] - b[2])\\n  \\n  let ds = new DisjointSet(), res = Array(queries.length).fill(false), i = 0, j = 0;\\n  while(i < queries.length){\\n    while(j < edgeList.length && queries[i][2] > edgeList[j][2]){\\n      ds.union(edgeList[j][0], edgeList[j][1])\\n      j++;\\n    }\\n    res[queries[i][3]] = ds.isConnected(queries[i][0], queries[i][1])\\n    i++;\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edgeList\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nclass DisjointSet {\\n  constructor (){\\n    this.parents = {};\\n    this.ranks = {};\\n  }\\n  \\n  union (x, y) {\\n    let xr = this.find(x), yr = this.find(y);\\n    if(this.ranks[xr] < this.ranks[yr]){\\n      this.parents[xr] = yr;\\n    }else{\\n      this.parents[yr] = xr;\\n      if(this.ranks[xr] == this.ranks[yr]) this.ranks[yr] += 1\\n    }\\n  }\\n  \\n  find(x) {\\n    if(!(x in this.ranks)){\\n      this.parents[x] = x;\\n      this.ranks[x] = 0;\\n    }\\n    if(this.parents[x] != x){\\n      this.parents[x] = this.find(this.parents[x])\\n    }\\n    return this.parents[x];\\n  }\\n  \\n  isConnected(x, y){\\n    return this.find(x) == this.find(y)\\n  }\\n}\\n// disjoint set with both sorted\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n  edgeList.sort((a, b) => a[2] - b[2])\\n  queries = queries.map((v, ind) => [...v, ind]).sort((a, b) => a[2] - b[2])\\n  \\n  let ds = new DisjointSet(), res = Array(queries.length).fill(false), i = 0, j = 0;\\n  while(i < queries.length){\\n    while(j < edgeList.length && queries[i][2] > edgeList[j][2]){\\n      ds.union(edgeList[j][0], edgeList[j][1])\\n      j++;\\n    }\\n    res[queries[i][3]] = ds.isConnected(queries[i][0], queries[i][1])\\n    i++;\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981834,
                "title": "wrong-answer-naive-dfs-bfs-test-case-2-works-on-sample-case",
                "content": "Any idea why this causes wrong answer?\\n\\n```python\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        adj = [[] for _ in range(n)]\\n        for edge in edgeList:\\n            a, b, cost = edge\\n            adj[a].append([b, cost])\\n        \\n        res =  []\\n        \\n        \\n        def dfs(src, dst, limit, visited):\\n            visited[src] = True\\n            for [neighbor, cost] in adj[src]:\\n                if cost < limit:\\n                    if neighbor == dst:\\n                        return True\\n                    if not visited[neighbor]:\\n                        if dfs(neighbor, dst, limit, visited):\\n                            return True\\n            \\n            return False\\n        for query in queries:\\n            src, dst, limit = query\\n\\t\\t\\t# dfs on two ways\\n            visited = [False for _ in range(n)]\\n            one = dfs(src, dst, limit, visited)\\n            visited = [False for _ in range(n)]\\n            two = dfs(dst, src, limit, visited)\\n            res.append(one or two)\\n        \\n        return res\\n```\\n\\nNote, that based on the difference between the actual and expected answer, it seems that if the above dfs method returns True for a particular query, it is correct. However if it returns False for a particular query it may not be correct (Some false negatives). So perhaps, this naive DFS failed to find some possible path? Any ideas? Also the exact same bug will occur on exact same test case (test case 2) on exact same query, if I use BFS, instead of DFS.\\n\\n\\nFor reference, this is the test case\\n```\\n13\\n[[9,1,53],[3,2,66],[12,5,99],[9,7,26],[1,4,78],[11,1,62],[3,10,50],[12,1,71],[12,6,63],[1,10,63],[9,10,88],[9,11,59],[1,4,37],[4,2,63],[0,2,26],[6,12,98],[9,11,99],[4,5,40],[2,8,25],[4,2,35],[8,10,9],[11,9,25],[10,11,11],[7,6,89],[2,4,99],[10,4,63]]\\n[[9,7,65],[9,6,1],[4,5,34],[10,8,43],[3,7,76],[4,2,15],[7,6,52],[2,0,50],[7,6,62],[1,0,81],[4,5,35],[0,11,86],[12,5,50],[11,2,2],[9,5,6],[12,0,95],[10,6,9],[9,4,73],[6,10,48],[12,0,91],[9,10,58],[9,8,73],[2,3,44],[7,11,83],[5,3,14],[6,2,33]]\\n```\\n\\nOutput:\\n```\\n[true,false,false,true,true,false,false,true,false,true,false,true,false,false,false,**false**,false,true,false,**false**,true,true,false,true,false,false]\\n```\\nExpected:\\n```\\n[true,false,false,true,true,false,false,true,false,true,false,true,false,false,false,**true**,false,true,false,**true**,true,true,false,true,false,false]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        adj = [[] for _ in range(n)]\\n        for edge in edgeList:\\n            a, b, cost = edge\\n            adj[a].append([b, cost])\\n        \\n        res =  []\\n        \\n        \\n        def dfs(src, dst, limit, visited):\\n            visited[src] = True\\n            for [neighbor, cost] in adj[src]:\\n                if cost < limit:\\n                    if neighbor == dst:\\n                        return True\\n                    if not visited[neighbor]:\\n                        if dfs(neighbor, dst, limit, visited):\\n                            return True\\n            \\n            return False\\n        for query in queries:\\n            src, dst, limit = query\\n\\t\\t\\t# dfs on two ways\\n            visited = [False for _ in range(n)]\\n            one = dfs(src, dst, limit, visited)\\n            visited = [False for _ in range(n)]\\n            two = dfs(dst, src, limit, visited)\\n            res.append(one or two)\\n        \\n        return res\\n```\n```\\n13\\n[[9,1,53],[3,2,66],[12,5,99],[9,7,26],[1,4,78],[11,1,62],[3,10,50],[12,1,71],[12,6,63],[1,10,63],[9,10,88],[9,11,59],[1,4,37],[4,2,63],[0,2,26],[6,12,98],[9,11,99],[4,5,40],[2,8,25],[4,2,35],[8,10,9],[11,9,25],[10,11,11],[7,6,89],[2,4,99],[10,4,63]]\\n[[9,7,65],[9,6,1],[4,5,34],[10,8,43],[3,7,76],[4,2,15],[7,6,52],[2,0,50],[7,6,62],[1,0,81],[4,5,35],[0,11,86],[12,5,50],[11,2,2],[9,5,6],[12,0,95],[10,6,9],[9,4,73],[6,10,48],[12,0,91],[9,10,58],[9,8,73],[2,3,44],[7,11,83],[5,3,14],[6,2,33]]\\n```\n```\\n[true,false,false,true,true,false,false,true,false,true,false,true,false,false,false,**false**,false,true,false,**false**,true,true,false,true,false,false]\\n```\n```\\n[true,false,false,true,true,false,false,true,false,true,false,true,false,false,false,**true**,false,true,false,**true**,true,true,false,true,false,false]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 980585,
                "title": "c-union-find",
                "content": "n = 5\\nedgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]]\\nqueries = [[0,4,14],[1,4,13]]\\nret = [0, 0]\\n\\n1. Append index in each query\\nqueries = [[0,4,14,0],[1,4,13,1]]\\n\\n2. Sort the edges and queries from small to large by distances\\nedgeList = [[1,2,5],[2,3,9],[0,1,10],[3,4,13]]\\nqueries = [[1,4,13,1],[0,4,14,0]]\\n\\n3. Traverse the queries, add edges less than limit in each query.\\nfor query = [1,4,13,1]  add edges = [[1,2,5],[2,3,9],[0,1,10]]  then \\n0 -- 1 -- 2 -- 3          |            4\\ncheck if 1 is connected with 4 false, ret[1] = false \\nfor query = [0,4,14,0]  add edges = [[3,4,13]] then \\n0 -- 1 -- 2 -- 3  -- 4\\ncheck if 0 is connected with 4 true, ret[0] = true\\nBTW: for result ret[index], index = query[3] because I have appended index to queries at step 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>& ds, int x)\\n    {\\n        return ds[x] == x ? x : ds[x] = find(ds, ds[x]);\\n    }\\n    \\n    int merge(vector<int>& ds, int x, int y)\\n    {\\n        int fx = find(ds, x);\\n        int fy = find(ds, y);\\n        \\n        if(fx != fy)\\n        {\\n            ds[fx] = fy;\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    static bool comp(const vector<int>& a, const vector<int>& b)\\n    {\\n        return a[2] < b[2];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,           vector<vector<int>>& queries) \\n    {\\n        if(n <= 0)\\n        {\\n            return {};\\n        }\\n        \\n        vector<int> ds(n, 0);\\n        int len1 = edgeList.size();\\n        int len2 = queries.size();\\n        vector<bool> ret(len2, false);\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            ds[i] = i;\\n        }\\n        \\n        for(int i=0; i<len2; ++i)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(edgeList.begin(), edgeList.end(), comp);\\n        sort(queries.begin(), queries.end(), comp);\\n        \\n        for(int i=0, j=0; i<len2; ++i)\\n        {\\n            while(j < len1 && edgeList[j][2] < queries[i][2])\\n            {\\n                merge(ds, edgeList[j][0], edgeList[j][1]);\\n                ++j;\\n            }\\n            \\n            if(find(ds, queries[i][0]) == find(ds, queries[i][1]))\\n            {\\n                ret[queries[i][3]] = 1;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<int>& ds, int x)\\n    {\\n        return ds[x] == x ? x : ds[x] = find(ds, ds[x]);\\n    }\\n    \\n    int merge(vector<int>& ds, int x, int y)\\n    {\\n        int fx = find(ds, x);\\n        int fy = find(ds, y);\\n        \\n        if(fx != fy)\\n        {\\n            ds[fx] = fy;\\n            return 1;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    static bool comp(const vector<int>& a, const vector<int>& b)\\n    {\\n        return a[2] < b[2];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList,           vector<vector<int>>& queries) \\n    {\\n        if(n <= 0)\\n        {\\n            return {};\\n        }\\n        \\n        vector<int> ds(n, 0);\\n        int len1 = edgeList.size();\\n        int len2 = queries.size();\\n        vector<bool> ret(len2, false);\\n        \\n        for(int i=0; i<n; ++i)\\n        {\\n            ds[i] = i;\\n        }\\n        \\n        for(int i=0; i<len2; ++i)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        \\n        sort(edgeList.begin(), edgeList.end(), comp);\\n        sort(queries.begin(), queries.end(), comp);\\n        \\n        for(int i=0, j=0; i<len2; ++i)\\n        {\\n            while(j < len1 && edgeList[j][2] < queries[i][2])\\n            {\\n                merge(ds, edgeList[j][0], edgeList[j][1]);\\n                ++j;\\n            }\\n            \\n            if(find(ds, queries[i][0]) == find(ds, queries[i][1]))\\n            {\\n                ret[queries[i][3]] = 1;\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978987,
                "title": "java-union-find-with-explanation",
                "content": "Took me a while to understand @Wilmol\\'s solution. I wanted to annotate the code so hopefully other\\'s can find it useful.\\nFirst, understand what the union find (aka disjoint set) data structure is. https://www.youtube.com/watch?v=ID00PMy0-vE\\n\\nAlright. Now that you know what it is, we can use a DSU and check if the query\\'s start and end are in the same component.\\nIntuition: \\n1) Sort the edges by weight.\\n2) For each query, construct our DSU with edges less than the query\\'s weight.\\n3) The query\\'s start and end will be connected if they are in the same DSU component. We can check by looking at their roots.\\n4) For optimization reasons, sort the queries by weight so that we don\\'t have to rebuild the DSU from all edges for each query. This allows us to construct the DSU starting with the edge that violated the last query\\'s weight.\\n\\n```\\nclass Solution {\\n    \\n    // This is used to evaluate only the edges that haven\\'t yet been evaluated for the limit in the queries\\n    // We sort the queries by limit ascending so that we can start from where the limit was exceeded in the\\n    // previous query.\\n    int curr = 0;\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edges, int[][] queries) {\\n        // Sort edges  by ascending weight, this will let us stop checking the edges after it\\n        // violates the limit in the query.\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        \\n        // We want to sort the queries by weight, so to retain the info of its ith index, we\\n        // create a new array that contains its index.\\n        int[][] qs = new int[queries.length][4];\\n        for (int i = 0; i < queries.length; i++) {\\n            qs[i][0] = queries[i][0];\\n            qs[i][1] = queries[i][1];\\n            qs[i][2] = queries[i][2];\\n            qs[i][3] = i;\\n        }\\n        Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n        \\n        int[] roots = new int[n];\\n        for (int i = 0; i < n; i++) roots[i] = i; // Initialize the DSU\\n        \\n        // For each query, go through the edges and see if the two nodes are in the same component\\n        boolean[] res = new boolean[queries.length];\\n        for (int[] q : qs) { // n2 log n\\n            res[q[3]] = helper(edges, q[0], q[1], q[2], roots);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean helper(int[][] edges, int start, int end, int limit, int[] roots) { // n log n\\n        // Start at curr, which is the last edge that violated the previous query\\'s limit\\n        for (int i = curr; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            if (edge[2] >= limit) {\\n                // This edge is out of limit\\n                this.curr = i;\\n                break;\\n            }\\n            int edgeStartRoot = getRoot(roots, edge[0]);\\n            int edgeEndRoot = getRoot(roots, edge[1]);\\n            if (edgeStartRoot != edgeEndRoot) {\\n                // They don\\'t have the same root, but clearly they\\'re connected since they\\'re an\\n                // edge. For this example, just update edgeEndRoot\\'s root to be edgeStartRoot.\\n                roots[edgeEndRoot] = edgeStartRoot;\\n                // Note: we could\\'ve updated edgeStartRoot\\'s root to be edgeEndRoot and it would\\n                // still work\\n                // roots[edgeStartRoot] = edgeEndRoot;\\n            }\\n        }\\n        // Since we only look at edges that are less than the limit, if the start and end\\n        // share the same root, it\\'s in the same component, implying that there\\'s a path\\n        // between them.\\n        return getRoot(roots, start) == getRoot(roots, end); // log n\\n    }\\n    \\n    private int getRoot(int[] roots, int node) {\\n        int temp = node;\\n        // Find the node that points to itself.\\n        while (roots[node] != node) {\\n            node = roots[node];\\n        }\\n        // Set the node\\'s label as the node that points to itself.\\n        roots[temp] = node;\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // This is used to evaluate only the edges that haven\\'t yet been evaluated for the limit in the queries\\n    // We sort the queries by limit ascending so that we can start from where the limit was exceeded in the\\n    // previous query.\\n    int curr = 0;\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edges, int[][] queries) {\\n        // Sort edges  by ascending weight, this will let us stop checking the edges after it\\n        // violates the limit in the query.\\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\\n        \\n        // We want to sort the queries by weight, so to retain the info of its ith index, we\\n        // create a new array that contains its index.\\n        int[][] qs = new int[queries.length][4];\\n        for (int i = 0; i < queries.length; i++) {\\n            qs[i][0] = queries[i][0];\\n            qs[i][1] = queries[i][1];\\n            qs[i][2] = queries[i][2];\\n            qs[i][3] = i;\\n        }\\n        Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n        \\n        int[] roots = new int[n];\\n        for (int i = 0; i < n; i++) roots[i] = i; // Initialize the DSU\\n        \\n        // For each query, go through the edges and see if the two nodes are in the same component\\n        boolean[] res = new boolean[queries.length];\\n        for (int[] q : qs) { // n2 log n\\n            res[q[3]] = helper(edges, q[0], q[1], q[2], roots);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean helper(int[][] edges, int start, int end, int limit, int[] roots) { // n log n\\n        // Start at curr, which is the last edge that violated the previous query\\'s limit\\n        for (int i = curr; i < edges.length; i++) {\\n            int[] edge = edges[i];\\n            if (edge[2] >= limit) {\\n                // This edge is out of limit\\n                this.curr = i;\\n                break;\\n            }\\n            int edgeStartRoot = getRoot(roots, edge[0]);\\n            int edgeEndRoot = getRoot(roots, edge[1]);\\n            if (edgeStartRoot != edgeEndRoot) {\\n                // They don\\'t have the same root, but clearly they\\'re connected since they\\'re an\\n                // edge. For this example, just update edgeEndRoot\\'s root to be edgeStartRoot.\\n                roots[edgeEndRoot] = edgeStartRoot;\\n                // Note: we could\\'ve updated edgeStartRoot\\'s root to be edgeEndRoot and it would\\n                // still work\\n                // roots[edgeStartRoot] = edgeEndRoot;\\n            }\\n        }\\n        // Since we only look at edges that are less than the limit, if the start and end\\n        // share the same root, it\\'s in the same component, implying that there\\'s a path\\n        // between them.\\n        return getRoot(roots, start) == getRoot(roots, end); // log n\\n    }\\n    \\n    private int getRoot(int[] roots, int node) {\\n        int temp = node;\\n        // Find the node that points to itself.\\n        while (roots[node] != node) {\\n            node = roots[node];\\n        }\\n        // Set the node\\'s label as the node that points to itself.\\n        roots[temp] = node;\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978567,
                "title": "simple-python-union-find",
                "content": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, A: List[List[int]], B: List[List[int]]) -> List[bool]:\\n        par = {}\\n        A.sort(key = lambda x: x[2])\\n        \\n        for i, query in enumerate(B):\\n            query.append(i)\\n        B.sort(key = lambda x: x[2])\\n        \\n        def find(a):\\n            par.setdefault(a, a)\\n            if par[a] != a:\\n                par[a] = find(par[a])\\n            return par[a]\\n        \\n        def union(a, b):\\n            par.setdefault(a, a)\\n            par.setdefault(b, b)\\n            par[find(a)] = par[find(b)]\\n        \\n        ans = [False]*len(B)\\n        i = 0\\n        for a, b, lim, idx in B:\\n            while i < len(A) and A[i][2] < lim:\\n                union(A[i][0], A[i][1])\\n                i += 1\\n            \\n            if find(a) == find(b):\\n                ans[idx] = True\\n        return ans\\n ```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, A: List[List[int]], B: List[List[int]]) -> List[bool]:\\n        par = {}\\n        A.sort(key = lambda x: x[2])\\n        \\n        for i, query in enumerate(B):\\n            query.append(i)\\n        B.sort(key = lambda x: x[2])\\n        \\n        def find(a):\\n            par.setdefault(a, a)\\n            if par[a] != a:\\n                par[a] = find(par[a])\\n            return par[a]\\n        \\n        def union(a, b):\\n            par.setdefault(a, a)\\n            par.setdefault(b, b)\\n            par[find(a)] = par[find(b)]\\n        \\n        ans = [False]*len(B)\\n        i = 0\\n        for a, b, lim, idx in B:\\n            while i < len(A) and A[i][2] < lim:\\n                union(A[i][0], A[i][1])\\n                i += 1\\n            \\n            if find(a) == find(b):\\n                ans[idx] = True\\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 978540,
                "title": "python-union-find",
                "content": "**Approach:**\\n\\nFirst sort the edges **and** the queries\\nso that the edge cost is ascending.\\n\\nSecond add the edges into a Union Find \\ndata structure one at a time up to the\\nmaximum cost of the current query.\\n\\nIf the start and end node become connected\\nthen query ```i``` is True.\\n\\nIf the cost to add the next edge is greater\\nthan or equal to the max cost for the current query\\nthen the query is false - move on to the next query.\\n\\n<br>\\n\\n```python\\nclass Union_Find(object):\\n    def __init__(self):\\n        self.group_id = 0\\n        self.groups = {}\\n        self.node_id = {}\\n    \\n    def union(self, a, b):\\n        A, B = a in self.node_id, b in self.node_id\\n        if A and B and self.node_id[a] != self.node_id[b]:\\n            self.merge(a, b)\\n        elif A or B:\\n            self.add(a, b)\\n        else:\\n            self.create(a, b)\\n    \\n    def merge(self, a, b):\\n        obs, targ = sorted((self.node_id[a], self.node_id[b]), key = lambda id: len(self.groups[id]))\\n        for node in self.groups[obs]:\\n            self.node_id[node] = targ\\n        self.groups[targ] |= self.groups[obs]\\n        del self.groups[obs]\\n        \\n    def add(self, a, b):\\n        a, b = (a, b) if a in self.node_id else (b, a)\\n        targ = self.node_id[a]\\n        self.node_id[b] = targ\\n        self.groups[targ] |= set([b])\\n    \\n    def create(self, a, b):\\n        self.groups[self.group_id] = set([a,b])\\n        self.node_id[a] = self.node_id[b] = self.group_id\\n        self.group_id += 1\\n        \\n    def is_connected(self, a, b):\\n        return a in self.node_id and b in self.node_id and self.node_id[a] == self.node_id[b]\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        res = [False] * len(queries)\\n        queries = [(i, q) for i,q in enumerate(queries)]\\n        queries.sort(key = lambda q: q[1][2])\\n        edges.sort(key = lambda e: e[2])\\n        \\n        uf = Union_Find()\\n        e = 0\\n        for i, (start, end, cost) in queries:\\n            # start and end are already connected - Query i is True\\n            if uf.is_connected(start, end):\\n                res[i] = True\\n                continue\\n            while e < len(edges):\\n                a, b, c = edges[e]\\n                if c >= cost:\\n                    # The cost to add an edge is too large - Query i is False\\n                    res[i] = False\\n                    break\\n                else:\\n                    # The cost to add an edge not too large - but start and end are not connected yet - keep adding edges\\n                    uf.union(a, b)\\n                    if uf.is_connected(start, end):\\n                        res[i] = True\\n                        break\\n                    e += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```i```\n```python\\nclass Union_Find(object):\\n    def __init__(self):\\n        self.group_id = 0\\n        self.groups = {}\\n        self.node_id = {}\\n    \\n    def union(self, a, b):\\n        A, B = a in self.node_id, b in self.node_id\\n        if A and B and self.node_id[a] != self.node_id[b]:\\n            self.merge(a, b)\\n        elif A or B:\\n            self.add(a, b)\\n        else:\\n            self.create(a, b)\\n    \\n    def merge(self, a, b):\\n        obs, targ = sorted((self.node_id[a], self.node_id[b]), key = lambda id: len(self.groups[id]))\\n        for node in self.groups[obs]:\\n            self.node_id[node] = targ\\n        self.groups[targ] |= self.groups[obs]\\n        del self.groups[obs]\\n        \\n    def add(self, a, b):\\n        a, b = (a, b) if a in self.node_id else (b, a)\\n        targ = self.node_id[a]\\n        self.node_id[b] = targ\\n        self.groups[targ] |= set([b])\\n    \\n    def create(self, a, b):\\n        self.groups[self.group_id] = set([a,b])\\n        self.node_id[a] = self.node_id[b] = self.group_id\\n        self.group_id += 1\\n        \\n    def is_connected(self, a, b):\\n        return a in self.node_id and b in self.node_id and self.node_id[a] == self.node_id[b]\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        \\n        res = [False] * len(queries)\\n        queries = [(i, q) for i,q in enumerate(queries)]\\n        queries.sort(key = lambda q: q[1][2])\\n        edges.sort(key = lambda e: e[2])\\n        \\n        uf = Union_Find()\\n        e = 0\\n        for i, (start, end, cost) in queries:\\n            # start and end are already connected - Query i is True\\n            if uf.is_connected(start, end):\\n                res[i] = True\\n                continue\\n            while e < len(edges):\\n                a, b, c = edges[e]\\n                if c >= cost:\\n                    # The cost to add an edge is too large - Query i is False\\n                    res[i] = False\\n                    break\\n                else:\\n                    # The cost to add an edge not too large - but start and end are not connected yet - keep adding edges\\n                    uf.union(a, b)\\n                    if uf.is_connected(start, end):\\n                        res[i] = True\\n                        break\\n                    e += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098035,
                "title": "typescript-union-find-time-o-elog-e-qlog-q-space-o-n-q",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(Elog(E) + Qlog(Q))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWhere **E** is the # of edges and **Q** is the # of queries\\n\\n- Space complexity*: O(N + Q)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhere **Q** is the # of queries.\\n\\n\\\\* Please note the space used for sorting by [Array.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) is not included, as it \"depends on the implementation\". From what I\\'ve gathered, it\\'s likely between O(log(N)) and O(N).\\n\\n# Code\\n```Typescript\\nfunction distanceLimitedPathsExist(n: number, edgeList: number[][], queries: number[][]): boolean[] {\\n    const E = edgeList.length;\\n    const Q = queries.length;\\n\\n    // Sort edges by distance ASC\\n    edgeList.sort((a, b) => a[2] - b[2]);\\n\\n    // Sort queries by limit ASC\\n    const sortedQueries: number[] = [];\\n    for (let i = 0; i < Q; sortedQueries.push(i++)){}\\n    sortedQueries.sort((a, b) => queries[a][2] - queries[b][2]);\\n\\n    // Initialize output\\n    const exists = new Array(Q).fill(false);\\n\\n    // For each query:\\n    let e = 0;\\n    const dsu = new DSU(n);\\n    for (let q = 0; q < Q; ++q) {\\n        const i = sortedQueries[q];\\n        const [a, b, limit] = queries[i];\\n        // Process edges below query limit\\n        for (; e < E && edgeList[e][2] < limit; ++e) {\\n            dsu.merge(edgeList[e][0], edgeList[e][1]);\\n        }\\n        // Check if path exists with only edges below limit\\n        exists[i] = dsu.find(a) === dsu.find(b);\\n    }\\n\\n    return exists;\\n}\\n\\nclass DSU {\\n    roots: number[];\\n    ranks: number[];\\n\\n    constructor(N: number) {\\n        const roots: number[] = [];\\n        for (let i = 0; i < N; roots.push(i++)){}\\n        this.roots = roots;\\n        this.ranks = new Array(N).fill(1);\\n    }\\n\\n    find(a: number): number {\\n        const roots = this.roots;\\n        let b = a;\\n        while (a !== roots[a]) {\\n            a = roots[a];\\n        }\\n        while (b !== a) {\\n            const c = roots[b];\\n            roots[b] = a;\\n            b = c;\\n        }\\n        return a;\\n    }\\n\\n    merge(a: number, b: number): void {\\n        a = this.find(a);\\n        b = this.find(b);\\n        if (a === b) {\\n            return;\\n        }\\n        if (this.ranks[a] < this.ranks[b]) {\\n            const c = a;\\n            a = b;\\n            b = c;\\n        }\\n        this.roots[b] = a;\\n        this.ranks[a] += this.ranks[b];\\n    }\\n}\\n\\n/**\\n * Your DistanceLimitedPathsExist object will be instantiated and called as such:\\n * var obj = new DistanceLimitedPathsExist(n, edgeList)\\n * var param_1 = obj.query(p,q,limit)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Union Find"
                ],
                "code": "```Typescript\\nfunction distanceLimitedPathsExist(n: number, edgeList: number[][], queries: number[][]): boolean[] {\\n    const E = edgeList.length;\\n    const Q = queries.length;\\n\\n    // Sort edges by distance ASC\\n    edgeList.sort((a, b) => a[2] - b[2]);\\n\\n    // Sort queries by limit ASC\\n    const sortedQueries: number[] = [];\\n    for (let i = 0; i < Q; sortedQueries.push(i++)){}\\n    sortedQueries.sort((a, b) => queries[a][2] - queries[b][2]);\\n\\n    // Initialize output\\n    const exists = new Array(Q).fill(false);\\n\\n    // For each query:\\n    let e = 0;\\n    const dsu = new DSU(n);\\n    for (let q = 0; q < Q; ++q) {\\n        const i = sortedQueries[q];\\n        const [a, b, limit] = queries[i];\\n        // Process edges below query limit\\n        for (; e < E && edgeList[e][2] < limit; ++e) {\\n            dsu.merge(edgeList[e][0], edgeList[e][1]);\\n        }\\n        // Check if path exists with only edges below limit\\n        exists[i] = dsu.find(a) === dsu.find(b);\\n    }\\n\\n    return exists;\\n}\\n\\nclass DSU {\\n    roots: number[];\\n    ranks: number[];\\n\\n    constructor(N: number) {\\n        const roots: number[] = [];\\n        for (let i = 0; i < N; roots.push(i++)){}\\n        this.roots = roots;\\n        this.ranks = new Array(N).fill(1);\\n    }\\n\\n    find(a: number): number {\\n        const roots = this.roots;\\n        let b = a;\\n        while (a !== roots[a]) {\\n            a = roots[a];\\n        }\\n        while (b !== a) {\\n            const c = roots[b];\\n            roots[b] = a;\\n            b = c;\\n        }\\n        return a;\\n    }\\n\\n    merge(a: number, b: number): void {\\n        a = this.find(a);\\n        b = this.find(b);\\n        if (a === b) {\\n            return;\\n        }\\n        if (this.ranks[a] < this.ranks[b]) {\\n            const c = a;\\n            a = b;\\n            b = c;\\n        }\\n        this.roots[b] = a;\\n        this.ranks[a] += this.ranks[b];\\n    }\\n}\\n\\n/**\\n * Your DistanceLimitedPathsExist object will be instantiated and called as such:\\n * var obj = new DistanceLimitedPathsExist(n, edgeList)\\n * var param_1 = obj.query(p,q,limit)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086436,
                "title": "menggunakan-pendekatan-union-find-disjoint-set-union",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            root_x = find(x)\\n            root_y = find(y)\\n            if root_x != root_y:\\n                if rank[root_x] < rank[root_y]:\\n                    parent[root_x] = root_y\\n                elif rank[root_x] > rank[root_y]:\\n                    parent[root_y] = root_x\\n                else:\\n                    parent[root_x] = root_y\\n                    rank[root_y] += 1\\n        \\n        edgeList.sort(key=lambda x: x[2])  # Urutkan edgeList berdasarkan jarak\\n        \\n        queries = [(p, q, limit, i) for i, (p, q, limit) in enumerate(queries)]\\n        queries.sort(key=lambda x: x[2])  # Urutkan queries berdasarkan batas jarak\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        result = [False] * len(queries)\\n        edge_index = 0\\n        \\n        for p, q, limit, i in queries:\\n            while edge_index < len(edgeList) and edgeList[edge_index][2] < limit:\\n                u, v, dis = edgeList[edge_index]\\n                union(u, v)\\n                edge_index += 1\\n            \\n            if find(p) == find(q):\\n                result[i] = True\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(x, y):\\n            root_x = find(x)\\n            root_y = find(y)\\n            if root_x != root_y:\\n                if rank[root_x] < rank[root_y]:\\n                    parent[root_x] = root_y\\n                elif rank[root_x] > rank[root_y]:\\n                    parent[root_y] = root_x\\n                else:\\n                    parent[root_x] = root_y\\n                    rank[root_y] += 1\\n        \\n        edgeList.sort(key=lambda x: x[2])  # Urutkan edgeList berdasarkan jarak\\n        \\n        queries = [(p, q, limit, i) for i, (p, q, limit) in enumerate(queries)]\\n        queries.sort(key=lambda x: x[2])  # Urutkan queries berdasarkan batas jarak\\n        \\n        parent = list(range(n))\\n        rank = [0] * n\\n        result = [False] * len(queries)\\n        edge_index = 0\\n        \\n        for p, q, limit, i in queries:\\n            while edge_index < len(edgeList) and edgeList[edge_index][2] < limit:\\n                u, v, dis = edgeList[edge_index]\\n                union(u, v)\\n                edge_index += 1\\n            \\n            if find(p) == find(q):\\n                result[i] = True\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050731,
                "title": "c-brute-force-dfs-dsu-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n    public:\\n    vector<int> parent;\\n    vector<int> rank;\\n    //constructor\\n    DSU(int n){\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n    //finding parent of node\\n    int findParent(int u){\\n        if(parent[u]==u){\\n            return u;\\n        }\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    //doing union of graph using rank\\n    void Union(int u,int v){\\n        int u_parent=findParent(u);\\n        int v_parent=findParent(v);\\n        if(u_parent==v_parent){\\n            return;\\n        }\\n        if(rank[u_parent]<rank[v_parent]){\\n            parent[u_parent]=v_parent;\\n        }\\n        else if(rank[v_parent]<rank[u_parent]){\\n            parent[v_parent]=u_parent;\\n        }\\n        else{\\n            parent[v_parent]=u_parent;\\n            rank[u_parent]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int> a,vector<int> b){\\n    return a[2]<b[2];\\n}\\n        vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edge, vector<vector<int>>& queries) {\\n        //sort edges and queries in incresisng based on weight nd limit\\n        sort(edge.begin(),edge.end(),cmp);\\n        //storing the index of query\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(),queries.end(),cmp);\\n\\n        int q=queries.size();\\n        vector<bool> ans(q,false);\\n        DSU adj(n);\\n\\n        //for each given query make include those edges only that statisfy the given property\\n        int i=0,j=0;\\n\\n        while(i<queries.size()){\\n            int u=queries[i][0];\\n            int v=queries[i][1];\\n            int limit=queries[i][2];\\n            int idx=queries[i][3];\\n\\n            while(j<edge.size() && edge[j][2]<limit){\\n                adj.Union(edge[j][0],edge[j][1]);\\n                j++;\\n            }\\n            if(adj.findParent(u)==adj.findParent(v)){\\n                ans[idx]=true;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n//***************** USING DFS TLE ************************\\n\\n// bool dfs(int s,int d,int limit,vector<int> &vis,vector<pair<int,int>> adj[]){\\n//     if(s==d){\\n//         return true;\\n//     }\\n//     vis[s]=1;\\n//     bool ans=false;\\n//     for(auto it: adj[s]){\\n//         int node=it.first;\\n//         int wt=it.second;\\n//         if(!vis[node] && wt<limit){/+\\n//             bool val=dfs(node,d,limit,vis,adj);\\n//             ans=ans||val;\\n//         }\\n//     }\\n//     return ans;\\n// }\\n\\n    // vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edge, vector<vector<int>>& queries) {\\n    //     vector<pair<int,int>> adj[n];\\n    //     for(auto it: edge){\\n    //         adj[it[0]].push_back({it[1],it[2]});\\n    //         adj[it[1]].push_back({it[0],it[2]});\\n    //     }\\n    //     vector<bool> ans;\\n    //     for(auto it: queries){\\n    //         vector<int> vis(n,0);\\n    //         bool val=dfs(it[0],it[1],it[2],vis,adj);\\n    //         ans.push_back(val);\\n    //     }\\n    //     return ans;\\n    // }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\n    public:\\n    vector<int> parent;\\n    vector<int> rank;\\n    //constructor\\n    DSU(int n){\\n        parent.resize(n);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n    }\\n    //finding parent of node\\n    int findParent(int u){\\n        if(parent[u]==u){\\n            return u;\\n        }\\n        return parent[u]=findParent(parent[u]);\\n    }\\n    //doing union of graph using rank\\n    void Union(int u,int v){\\n        int u_parent=findParent(u);\\n        int v_parent=findParent(v);\\n        if(u_parent==v_parent){\\n            return;\\n        }\\n        if(rank[u_parent]<rank[v_parent]){\\n            parent[u_parent]=v_parent;\\n        }\\n        else if(rank[v_parent]<rank[u_parent]){\\n            parent[v_parent]=u_parent;\\n        }\\n        else{\\n            parent[v_parent]=u_parent;\\n            rank[u_parent]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int> a,vector<int> b){\\n    return a[2]<b[2];\\n}\\n        vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edge, vector<vector<int>>& queries) {\\n        //sort edges and queries in incresisng based on weight nd limit\\n        sort(edge.begin(),edge.end(),cmp);\\n        //storing the index of query\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(),queries.end(),cmp);\\n\\n        int q=queries.size();\\n        vector<bool> ans(q,false);\\n        DSU adj(n);\\n\\n        //for each given query make include those edges only that statisfy the given property\\n        int i=0,j=0;\\n\\n        while(i<queries.size()){\\n            int u=queries[i][0];\\n            int v=queries[i][1];\\n            int limit=queries[i][2];\\n            int idx=queries[i][3];\\n\\n            while(j<edge.size() && edge[j][2]<limit){\\n                adj.Union(edge[j][0],edge[j][1]);\\n                j++;\\n            }\\n            if(adj.findParent(u)==adj.findParent(v)){\\n                ans[idx]=true;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n//***************** USING DFS TLE ************************\\n\\n// bool dfs(int s,int d,int limit,vector<int> &vis,vector<pair<int,int>> adj[]){\\n//     if(s==d){\\n//         return true;\\n//     }\\n//     vis[s]=1;\\n//     bool ans=false;\\n//     for(auto it: adj[s]){\\n//         int node=it.first;\\n//         int wt=it.second;\\n//         if(!vis[node] && wt<limit){/+\\n//             bool val=dfs(node,d,limit,vis,adj);\\n//             ans=ans||val;\\n//         }\\n//     }\\n//     return ans;\\n// }\\n\\n    // vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edge, vector<vector<int>>& queries) {\\n    //     vector<pair<int,int>> adj[n];\\n    //     for(auto it: edge){\\n    //         adj[it[0]].push_back({it[1],it[2]});\\n    //         adj[it[1]].push_back({it[0],it[2]});\\n    //     }\\n    //     vector<bool> ans;\\n    //     for(auto it: queries){\\n    //         vector<int> vis(n,0);\\n    //         bool val=dfs(it[0],it[1],it[2],vis,adj);\\n    //         ans.push_back(val);\\n    //     }\\n    //     return ans;\\n    // }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024570,
                "title": "c-with-explantion",
                "content": "# Intuition\\n1. sort edgeList by edgeList[2]\\n2. sort queries by queries[2]\\n3. now union (edgeList[j][0],  edgeList[j][1]) for every distance less than queries[i][2]\\n4. check if (queries[i], queries[0]) are in the same root\\n\\n# Code\\n```\\n\\nbool Compare(vector<int>&a, vector<int>&b)\\n{\\n    if(a[2] < b[2]) return true;\\n    else return false;\\n}\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n            }\\n        }\\n        return true;\\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n    UnionFind *uf = new UnionFind(n);\\n    sort(edgeList.begin(), edgeList.end(), Compare);\\n    for(int i=0; i<queries.size(); i++)\\n    {\\n        queries[i].push_back(i);\\n    }\\n    sort(queries.begin(), queries.end(), Compare);\\n    vector<bool> vRet(queries.size());\\n    int iIdx = 0;\\n    for(int i=0; i<queries.size(); i++)\\n    {\\n        int iDistLimit = queries[i][2];\\n        for(int j=iIdx; j<edgeList.size(); j++)\\n        {\\n            if(edgeList[j][2] < iDistLimit)\\n            {\\n                uf->Union(edgeList[j][0], edgeList[j][1]);\\n            }\\n            else\\n            {\\n                iIdx = j;\\n                break;\\n            }\\n        }\\n        if(uf->find(queries[i][0]) == uf->find(queries[i][1])) vRet[queries[i][3]] = true;\\n        else vRet[queries[i][3]]  = false;\\n    }\\n\\n        \\n    \\n    return vRet;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nbool Compare(vector<int>&a, vector<int>&b)\\n{\\n    if(a[2] < b[2]) return true;\\n    else return false;\\n}\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n            }\\n        }\\n        return true;\\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n    UnionFind *uf = new UnionFind(n);\\n    sort(edgeList.begin(), edgeList.end(), Compare);\\n    for(int i=0; i<queries.size(); i++)\\n    {\\n        queries[i].push_back(i);\\n    }\\n    sort(queries.begin(), queries.end(), Compare);\\n    vector<bool> vRet(queries.size());\\n    int iIdx = 0;\\n    for(int i=0; i<queries.size(); i++)\\n    {\\n        int iDistLimit = queries[i][2];\\n        for(int j=iIdx; j<edgeList.size(); j++)\\n        {\\n            if(edgeList[j][2] < iDistLimit)\\n            {\\n                uf->Union(edgeList[j][0], edgeList[j][1]);\\n            }\\n            else\\n            {\\n                iIdx = j;\\n                break;\\n            }\\n        }\\n        if(uf->find(queries[i][0]) == uf->find(queries[i][1])) vRet[queries[i][3]] = true;\\n        else vRet[queries[i][3]]  = false;\\n    }\\n\\n        \\n    \\n    return vRet;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4006674,
                "title": "kishan-s-coding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        dict1, n = defaultdict(int), len(queries)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        edgeList.sort(key = lambda x: x[2])\\n\\n        i, res = 0, [False]*n\\n\\n        for limit, x, y, idx in sorted((q[2],q[0],q[1],i) for i,q in enumerate(queries)):\\n            while i < len(edgeList) and edgeList[i][2] < limit:\\n                union(edgeList[i][0],edgeList[i][1])\\n                i += 1\\n            res[idx] = find(x) == find(y)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        dict1, n = defaultdict(int), len(queries)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        edgeList.sort(key = lambda x: x[2])\\n\\n        i, res = 0, [False]*n\\n\\n        for limit, x, y, idx in sorted((q[2],q[0],q[1],i) for i,q in enumerate(queries)):\\n            while i < len(edgeList) and edgeList[i][2] < limit:\\n                union(edgeList[i][0],edgeList[i][1])\\n                i += 1\\n            res[idx] = find(x) == find(y)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993177,
                "title": "python-union-find-solution",
                "content": "```\\nfrom operator import itemgetter\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: list[list[int]], queries: list[list[int]]) -> list[bool]:\\n        edges.sort(key=itemgetter(2))\\n\\n        m = len(edges)\\n\\n        output = [False] * len(queries)\\n\\n        uf = UF(n)\\n        e_idx = 0\\n\\n        for i, (u, v, limit) in sorted(enumerate(queries), key=lambda q: q[1][2]):\\n            while e_idx < m and (edge := edges[e_idx])[2] < limit:\\n                uf.union(edge[0], edge[1])\\n                e_idx += 1\\n\\n            output[i] = uf.find(u) == uf.find(v)\\n\\n        return output\\n\\n```\\n\\nDefinition of **UF**,\\n\\n```\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\n\\n\\n@dataclass(frozen=True)\\nclass UF:\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n    node_count: int\\n\\n    def find(self, u: int) -> int:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self.find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: int, v: int) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u != root_v:\\n            self._merge_roots(root_u, root_v)\\n\\n        return root_u != root_v\\n\\n    def _merge_roots(self, u: int, v: int):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is the ith element and value\\n                 is its corresponding parent\\n        \"\"\"\\n        return list(range(self.node_count))\\n\\n    @cached_property\\n    def _rank(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is ith node element and value\\n        is its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return [1] * self.node_count\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nfrom operator import itemgetter\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: list[list[int]], queries: list[list[int]]) -> list[bool]:\\n        edges.sort(key=itemgetter(2))\\n\\n        m = len(edges)\\n\\n        output = [False] * len(queries)\\n\\n        uf = UF(n)\\n        e_idx = 0\\n\\n        for i, (u, v, limit) in sorted(enumerate(queries), key=lambda q: q[1][2]):\\n            while e_idx < m and (edge := edges[e_idx])[2] < limit:\\n                uf.union(edge[0], edge[1])\\n                e_idx += 1\\n\\n            output[i] = uf.find(u) == uf.find(v)\\n\\n        return output\\n\\n```\n```\\nfrom dataclasses import dataclass\\nfrom functools import cached_property\\n\\n\\n@dataclass(frozen=True)\\nclass UF:\\n    \"\"\"\\n    Implementing union find algorithm\\n    \"\"\"\\n    node_count: int\\n\\n    def find(self, u: int) -> int:\\n        \"\"\"\\n        :return: representative node of cluster containing node \"u\"\\n        \"\"\"\\n        parent = self._parent\\n\\n        if u != (pu := parent[u]):\\n            parent[u] = self.find(pu)  # path compression\\n\\n        return parent[u]\\n\\n    def union(self, u: int, v: int) -> bool:\\n        \"\"\"\\n        merging clusters containing node \"u\" and node \"v\"\\n        :param u:\\n        :param v:\\n        :return: True if union/merge is needed else False\\n        \"\"\"\\n        root_u, root_v = self.find(u), self.find(v)\\n\\n        if root_u != root_v:\\n            self._merge_roots(root_u, root_v)\\n\\n        return root_u != root_v\\n\\n    def _merge_roots(self, u: int, v: int):\\n        \"\"\"\\n        \"u\" and \"v\" are root nodes of two different clusters and the two\\n        clusters are to be merged. In this function, we determine which\\n        node should be made parent using rank and update parent accordingly.\\n\\n        Node with higher rank is made parent and in case of tie, \"v\" (\"u\" can\\n        also be chosen) node is chosen as parent and its rank is incremented\\n        by 1\\n\\n        :param u:\\n        :param v:\\n        \"\"\"\\n        rank = self._rank\\n\\n        if rank[u] > rank[v]:\\n            self._parent[v] = u\\n        else:\\n            self._parent[u] = v\\n\\n            if rank[u] == rank[v]:\\n                self._rank[v] += 1\\n\\n    @cached_property\\n    def _parent(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is the ith element and value\\n                 is its corresponding parent\\n        \"\"\"\\n        return list(range(self.node_count))\\n\\n    @cached_property\\n    def _rank(self) -> list[int]:\\n        \"\"\"\\n        :return: list in which ith index is ith node element and value\\n        is its rank. Rank is used while merging clusters\\n        \"\"\"\\n        return [1] * self.node_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989505,
                "title": "c-offline-queries-dsu",
                "content": "\\n# Code\\n```\\nclass DSU {\\n    vector<int> parent, size;\\n    public:\\n    DSU(int n) {\\n        parent.resize(n, 0);\\n        size.resize(n, 1);\\n        for(int i = 0; i < n; ++i) parent[i] = i;\\n    }\\n\\n    int find(int n) {\\n        if(parent[n] == n) return n;\\n        return parent[n] = find(parent[n]);\\n    }\\n\\n    bool unite(int a, int b) {\\n        int u = find(a), v = find(b);\\n        if(u == v) return false;\\n        if(size[u] < size[v]) swap(u, v);\\n        size[u] += size[v];\\n        parent[v] = u;\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i = 0; i < queries.size(); ++i) queries[i].push_back(i);\\n        sort(edgeList.begin(), edgeList.end(), [](vector<int> &a, vector<int> &b) {\\n            return a[2] < b[2];\\n        });\\n        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b) {\\n            return a[2] < b[2];\\n        });\\n        vector<bool> res(queries.size());\\n        int i = 0;\\n        for(auto &que : queries) {\\n            while(i < edgeList.size() && edgeList[i][2] < que[2]) {\\n                dsu.unite(edgeList[i][0], edgeList[i][1]);\\n                ++i;\\n            }\\n            if(dsu.find(que[0]) == dsu.find(que[1])) {\\n                res[que[3]] = edgeList[i - 1][2] < que[2];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU {\\n    vector<int> parent, size;\\n    public:\\n    DSU(int n) {\\n        parent.resize(n, 0);\\n        size.resize(n, 1);\\n        for(int i = 0; i < n; ++i) parent[i] = i;\\n    }\\n\\n    int find(int n) {\\n        if(parent[n] == n) return n;\\n        return parent[n] = find(parent[n]);\\n    }\\n\\n    bool unite(int a, int b) {\\n        int u = find(a), v = find(b);\\n        if(u == v) return false;\\n        if(size[u] < size[v]) swap(u, v);\\n        size[u] += size[v];\\n        parent[v] = u;\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i = 0; i < queries.size(); ++i) queries[i].push_back(i);\\n        sort(edgeList.begin(), edgeList.end(), [](vector<int> &a, vector<int> &b) {\\n            return a[2] < b[2];\\n        });\\n        sort(queries.begin(), queries.end(), [](vector<int> &a, vector<int> &b) {\\n            return a[2] < b[2];\\n        });\\n        vector<bool> res(queries.size());\\n        int i = 0;\\n        for(auto &que : queries) {\\n            while(i < edgeList.size() && edgeList[i][2] < que[2]) {\\n                dsu.unite(edgeList[i][0], edgeList[i][1]);\\n                ++i;\\n            }\\n            if(dsu.find(que[0]) == dsu.find(que[1])) {\\n                res[que[3]] = edgeList[i - 1][2] < que[2];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988071,
                "title": "dsu-class-clean-implementation",
                "content": "# Intuition\\nFirst of all understand that we need to take the edges with the value less than the limit and not the final distance from source and destination. Had we needed to find that we could have applied Djisktra algo. But here we need to select edges such that their weight is less than the limit\\n\\n# Approach\\nThe only point now left in this DSU approach is to understand the need to sort. Basically we need to compute our answer for various different queries. Let\\'s say we had a query where for the first query the limit is 10 and for the next one the limit is 5, now all the edges computed for limit 5 will again be computed for the limit 10 and vica versa. Hence to avoid this, we will first consider the lower limits and gradually consider the higher ones. Sorting the edges provide us with the flexibility to include the edges appropriately based on our limit value\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + e + q + eloge + qlogq)$$\\n\\n- Space complexity:\\n$$O(n + q)$$\\n\\n# Code\\n```\\nclass DSU {\\npublic:\\n    vector<int> parent, size;\\n    DSU(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        for(int i = 0; i <= n; i++) parent[i] = i;\\n    }\\n    int find(int x) {\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void unionSize(int u, int v) {\\n        int uP = find(u), vP = find(v);\\n        if(uP == vP) return;\\n        if(size[uP] > size[vP]) {\\n            parent[vP] = uP;\\n            size[uP] += size[vP];\\n        } else {\\n            parent[uP] = vP;\\n            size[vP] += size[uP];\\n        }\\n    }\\n};\\nclass Solution {\\n    bool static compare(const vector<int>& a, const vector<int>& b) {\\n        return a[2] < b[2];\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int querySize = queries.size();\\n        DSU ds(n);\\n        vector<bool> ans(querySize);\\n        vector<vector<int>> newQ;\\n        int index = 0;\\n        for(auto& it : queries) {\\n            newQ.push_back({it[0], it[1], it[2], index});\\n            index++;\\n        }\\n\\n        sort(edgeList.begin(), edgeList.end(), compare);\\n        sort(newQ.begin(), newQ.end(), compare);\\n        int edgeIndex = 0;\\n\\n        for(auto& it : newQ) {\\n            int start = it[0], end = it[1], limit = it[2], i = it[3];\\n\\n            while(edgeIndex < edgeList.size() and edgeList[edgeIndex][2] < limit) {\\n                ds.unionSize(edgeList[edgeIndex][0], edgeList[edgeIndex][1]);\\n                edgeIndex++;\\n            }\\n\\n            ans[i] = ds.find(start) == ds.find(end);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> parent, size;\\n    DSU(int n) {\\n        parent.resize(n + 1);\\n        size.resize(n + 1, 1);\\n        for(int i = 0; i <= n; i++) parent[i] = i;\\n    }\\n    int find(int x) {\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    void unionSize(int u, int v) {\\n        int uP = find(u), vP = find(v);\\n        if(uP == vP) return;\\n        if(size[uP] > size[vP]) {\\n            parent[vP] = uP;\\n            size[uP] += size[vP];\\n        } else {\\n            parent[uP] = vP;\\n            size[vP] += size[uP];\\n        }\\n    }\\n};\\nclass Solution {\\n    bool static compare(const vector<int>& a, const vector<int>& b) {\\n        return a[2] < b[2];\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int querySize = queries.size();\\n        DSU ds(n);\\n        vector<bool> ans(querySize);\\n        vector<vector<int>> newQ;\\n        int index = 0;\\n        for(auto& it : queries) {\\n            newQ.push_back({it[0], it[1], it[2], index});\\n            index++;\\n        }\\n\\n        sort(edgeList.begin(), edgeList.end(), compare);\\n        sort(newQ.begin(), newQ.end(), compare);\\n        int edgeIndex = 0;\\n\\n        for(auto& it : newQ) {\\n            int start = it[0], end = it[1], limit = it[2], i = it[3];\\n\\n            while(edgeIndex < edgeList.size() and edgeList[edgeIndex][2] < limit) {\\n                ds.unionSize(edgeList[edgeIndex][0], edgeList[edgeIndex][1]);\\n                edgeIndex++;\\n            }\\n\\n            ans[i] = ds.find(start) == ds.find(end);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981072,
                "title": "sorting-and-disjoint-set-union-solution-c",
                "content": "\\n# Approach\\n- Sort the edgelist and queries arrays based on their distance and limit value\\n- We also need to store the relative order as we want to return the answer of our queries array in that order\\n- Now we will build the graph until the edge dist < limit\\n- Check if the queries vertices belong to the same componenet\\n  - If yes answer would be true for that query \\n  - Else answer would be false\\n\\nHere we will use Disjoint Set Union to build the graph as it would be easy to check whether two vertices belong to the same component or not.\\n- If they belong to the same component then we can have a path where distance of each edge path is strictly less than the limit of our query.\\n\\n\\n# Code\\n```\\nclass DSU{\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int size;\\n    DSU(int n){\\n        this->size = n;\\n        parent.resize(n);\\n        rank.resize(n,1);\\n        for(int i=0;i<n;i++)   parent[i] = i;\\n    }\\n    int getParent(int node){\\n        if(node==parent[node])  return node;\\n        return parent[node] = getParent(parent[node]);\\n    }\\n    bool Union(int u,int v){\\n        int parentu = getParent(u);\\n        int parentv = getParent(v);\\n        if(parentu==parentv)    return false;\\n        \\n        if(rank[parentu]<rank[parentv])\\n            parent[parentu] = parentv ;\\n        else if(rank[parentv]<rank[parentu])\\n            parent[parentv] = parentu ;\\n        else{\\n            parent[parentu] = parentv ;\\n            rank[parentv]++;\\n        }\\n        return true;\\n    }   \\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<bool> result(queries.size(),false);\\n\\n        vector<vector<int>> q;\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        // sorting the queries based on their limit value after storing their relative order(index)\\n        sort(queries.begin(),queries.end(),[](const vector<int> &a,const vector<int>& b){   \\n            return a[2]<=b[2];\\n        });\\n\\n        // sorting the edges based on their distances\\n        sort(edgeList.begin(),edgeList.end(),[](const vector<int> &a,const vector<int> &b){\\n            return a[2]<b[2];\\n        });\\n\\n        DSU d(n);\\n\\n        int i = 0;\\n        for(auto &query:queries){\\n            int u = query[0];\\n            int v = query[1];\\n            int limit = query[2];\\n            int index = query[3];       \\n\\n            bool ans = false;\\n            while(i<edgeList.size() && edgeList[i][2]<limit){       //building the graph until dis<limit is true\\n                int nodea = edgeList[i][0];\\n                int nodeb = edgeList[i][1];\\n                d.Union(nodea,nodeb);\\n                i++;\\n            }\\n            ans = d.getParent(u) == d.getParent(v) ;            // if both belongs to the same component means we can have path from u to v with each edge distance strictly less than limit\\n            result[index] = ans;\\n        }\\n\\n        return result;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int size;\\n    DSU(int n){\\n        this->size = n;\\n        parent.resize(n);\\n        rank.resize(n,1);\\n        for(int i=0;i<n;i++)   parent[i] = i;\\n    }\\n    int getParent(int node){\\n        if(node==parent[node])  return node;\\n        return parent[node] = getParent(parent[node]);\\n    }\\n    bool Union(int u,int v){\\n        int parentu = getParent(u);\\n        int parentv = getParent(v);\\n        if(parentu==parentv)    return false;\\n        \\n        if(rank[parentu]<rank[parentv])\\n            parent[parentu] = parentv ;\\n        else if(rank[parentv]<rank[parentu])\\n            parent[parentv] = parentu ;\\n        else{\\n            parent[parentu] = parentv ;\\n            rank[parentv]++;\\n        }\\n        return true;\\n    }   \\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<bool> result(queries.size(),false);\\n\\n        vector<vector<int>> q;\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        // sorting the queries based on their limit value after storing their relative order(index)\\n        sort(queries.begin(),queries.end(),[](const vector<int> &a,const vector<int>& b){   \\n            return a[2]<=b[2];\\n        });\\n\\n        // sorting the edges based on their distances\\n        sort(edgeList.begin(),edgeList.end(),[](const vector<int> &a,const vector<int> &b){\\n            return a[2]<b[2];\\n        });\\n\\n        DSU d(n);\\n\\n        int i = 0;\\n        for(auto &query:queries){\\n            int u = query[0];\\n            int v = query[1];\\n            int limit = query[2];\\n            int index = query[3];       \\n\\n            bool ans = false;\\n            while(i<edgeList.size() && edgeList[i][2]<limit){       //building the graph until dis<limit is true\\n                int nodea = edgeList[i][0];\\n                int nodeb = edgeList[i][1];\\n                d.Union(nodea,nodeb);\\n                i++;\\n            }\\n            ans = d.getParent(u) == d.getParent(v) ;            // if both belongs to the same component means we can have path from u to v with each edge distance strictly less than limit\\n            result[index] = ans;\\n        }\\n\\n        return result;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927185,
                "title": "build-graph-in-sorted-order",
                "content": "\\n```\\nclass DSU{\\npublic:\\n    vector<int> rank,parent;\\n    DSU(int n){\\n        rank.resize(n+1);\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            rank[i]=1;\\n            parent[i]=i;\\n        }\\n    }\\n    int findpar(int node){\\n        if(parent[node]==node) return node;\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void Union(int u,int v){\\n        int pu=findpar(u),pv=findpar(v);\\n        if(pu==pv) return;\\n        if(rank[pu]<=rank[pv]){\\n            rank[pv]+=rank[pu];\\n            parent[pv]=pu;\\n        }else{\\n            rank[pu]+=rank[pv];\\n            parent[pu]=pv;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &v1,vector<int> &v2){\\n        return v1[2]<=v2[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<vector<int>> query;\\n        for(int i=0;i<queries.size();i++){\\n            query.push_back({queries[i][2],queries[i][0],queries[i][1],i});\\n        }\\n        sort(query.begin(),query.end());\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        vector<bool> ans(queries.size(),false);\\n        int ind=0;\\n        int m=edgeList.size();\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++){\\n            while(ind<m){\\n                if(edgeList[ind][2]<query[i][0]){\\n                    int u=edgeList[ind][0],v=edgeList[ind][1];\\n                    dsu.Union(u,v);\\n                    ind++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            int x=query[i][1],y=query[i][2];\\n            if(dsu.findpar(x)==dsu.findpar(y)){\\n                ans[query[i][3]]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n    vector<int> rank,parent;\\n    DSU(int n){\\n        rank.resize(n+1);\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            rank[i]=1;\\n            parent[i]=i;\\n        }\\n    }\\n    int findpar(int node){\\n        if(parent[node]==node) return node;\\n        return parent[node]=findpar(parent[node]);\\n    }\\n    void Union(int u,int v){\\n        int pu=findpar(u),pv=findpar(v);\\n        if(pu==pv) return;\\n        if(rank[pu]<=rank[pv]){\\n            rank[pv]+=rank[pu];\\n            parent[pv]=pu;\\n        }else{\\n            rank[pu]+=rank[pv];\\n            parent[pu]=pv;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &v1,vector<int> &v2){\\n        return v1[2]<=v2[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<vector<int>> query;\\n        for(int i=0;i<queries.size();i++){\\n            query.push_back({queries[i][2],queries[i][0],queries[i][1],i});\\n        }\\n        sort(query.begin(),query.end());\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        vector<bool> ans(queries.size(),false);\\n        int ind=0;\\n        int m=edgeList.size();\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++){\\n            while(ind<m){\\n                if(edgeList[ind][2]<query[i][0]){\\n                    int u=edgeList[ind][0],v=edgeList[ind][1];\\n                    dsu.Union(u,v);\\n                    ind++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            int x=query[i][1],y=query[i][2];\\n            if(dsu.findpar(x)==dsu.findpar(y)){\\n                ans[query[i][3]]=true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909799,
                "title": "dsu-sorting-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    static bool cmp(vector<int>& a,vector<int>& b) \\n    {\\n        return (a[2]<b[2]);\\n    }\\n\\n    int find(int x,vector<int>& par) \\n    {\\n        if(x==par[x])\\n        return x;\\n        int y=find(par[x],par);\\n        return par[x]=y;\\n    }\\n\\n    void merge(int x,int y,vector<int>& par,vector<int>& rank)\\n    {\\n        int lx=find(x,par),ly=find(y,par);\\n        if(lx!=ly)\\n        {\\n            if(rank[lx]>rank[ly])\\n            par[ly]=lx;\\n            else if(rank[ly]>rank[lx])\\n            par[lx]=ly;\\n            else\\n            {\\n                par[ly]=lx;\\n                rank[lx]++;\\n            }\\n        }\\n    }\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) \\n    { \\n        int q=queries.size();\\n        int e=edgeList.size();\\n        for(int i=0;i<q;i++)\\n        queries[i].push_back(i);\\n\\n        sort(edgeList.begin(),edgeList.end(),cmp); \\n        sort(queries.begin(),queries.end(),cmp);\\n        //Sort edgeList and queries according to weights\\n\\n\\n        vector<int> par(n),rank(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n            rank[i]=0;\\n        }\\n\\n        vector<bool> out(q);\\n\\n        int j=0;\\n        for(auto i:queries)\\n        {\\n            while(j<e&&edgeList[j][2]<i[2])\\n            {\\n                merge(edgeList[j][0],edgeList[j][1],par,rank);\\n                j++;\\n            }\\n            //Take all the edges with weight less than the query weight and merge them\\n            if(find(i[0],par)==find(i[1],par))\\n                out[i[3]]=1;\\n            else\\n                out[i[3]]=0;\\n            //Now if the two query nodes are merged, then a path with required constraints is possible\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    static bool cmp(vector<int>& a,vector<int>& b) \\n    {\\n        return (a[2]<b[2]);\\n    }\\n\\n    int find(int x,vector<int>& par) \\n    {\\n        if(x==par[x])\\n        return x;\\n        int y=find(par[x],par);\\n        return par[x]=y;\\n    }\\n\\n    void merge(int x,int y,vector<int>& par,vector<int>& rank)\\n    {\\n        int lx=find(x,par),ly=find(y,par);\\n        if(lx!=ly)\\n        {\\n            if(rank[lx]>rank[ly])\\n            par[ly]=lx;\\n            else if(rank[ly]>rank[lx])\\n            par[lx]=ly;\\n            else\\n            {\\n                par[ly]=lx;\\n                rank[lx]++;\\n            }\\n        }\\n    }\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) \\n    { \\n        int q=queries.size();\\n        int e=edgeList.size();\\n        for(int i=0;i<q;i++)\\n        queries[i].push_back(i);\\n\\n        sort(edgeList.begin(),edgeList.end(),cmp); \\n        sort(queries.begin(),queries.end(),cmp);\\n        //Sort edgeList and queries according to weights\\n\\n\\n        vector<int> par(n),rank(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n            rank[i]=0;\\n        }\\n\\n        vector<bool> out(q);\\n\\n        int j=0;\\n        for(auto i:queries)\\n        {\\n            while(j<e&&edgeList[j][2]<i[2])\\n            {\\n                merge(edgeList[j][0],edgeList[j][1],par,rank);\\n                j++;\\n            }\\n            //Take all the edges with weight less than the query weight and merge them\\n            if(find(i[0],par)==find(i[1],par))\\n                out[i[3]]=1;\\n            else\\n                out[i[3]]=0;\\n            //Now if the two query nodes are merged, then a path with required constraints is possible\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882014,
                "title": "easy-striver-s-union-find-c",
                "content": "# Intuition\\none of the best question of the disjoint set union concept main thing here was when to handle which query for which sorting was used we will handle the queries weight wise \\n\\n# Approach\\nmake a disjointset class and a cmp to sort the values based on the weight sort both queries and the edgelist now coming to the logic we will go on until we get weight less than a particular query as soon we get weight greater then or equal to the query weight we fill the ans for that query now until here all the weights less than query will be under one component and hence we can fill the answer for them if they belong to same component it means they can reach there with weight less then query weight other wise they cant reach\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) for sorting O(nlogn+m) for query \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& ed, vector<vector<int>>& q) {\\n        int n1=q.size(); \\n        DisjointSet ds(n);\\n        // for storing ans\\n        for(int i=0; i<n1; i++){\\n            q[i].push_back(i);\\n        }\\n\\n        sort(ed.begin(),ed.end(),cmp);\\n        sort(q.begin(),q.end(),cmp);\\n\\n        vector<bool> ans(n1);\\n        int i=0;\\n        for(auto &it:q){\\n            while(i<ed.size() && ed[i][2]<it[2]){\\n             ds.unionByRank(ed[i][0],ed[i][1]);\\n             i++;\\n            }\\n            if(ds.findUPar(it[0])==ds.findUPar(it[1])){\\n            ans[it[3]]=true;\\n            }\\n            else{\\n                ans[it[3]]=false;\\n            }\\n        }\\n     return ans;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a,vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& ed, vector<vector<int>>& q) {\\n        int n1=q.size(); \\n        DisjointSet ds(n);\\n        // for storing ans\\n        for(int i=0; i<n1; i++){\\n            q[i].push_back(i);\\n        }\\n\\n        sort(ed.begin(),ed.end(),cmp);\\n        sort(q.begin(),q.end(),cmp);\\n\\n        vector<bool> ans(n1);\\n        int i=0;\\n        for(auto &it:q){\\n            while(i<ed.size() && ed[i][2]<it[2]){\\n             ds.unionByRank(ed[i][0],ed[i][1]);\\n             i++;\\n            }\\n            if(ds.findUPar(it[0])==ds.findUPar(it[1])){\\n            ans[it[3]]=true;\\n            }\\n            else{\\n                ans[it[3]]=false;\\n            }\\n        }\\n     return ans;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868789,
                "title": "c-union-find-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DSU{\\n    vector<int> parent , rank;\\n    public:\\n    DSU(int n)\\n    {\\n        rank.resize(n , 0);\\n        parent.resize(n);\\n        for(int i = 0 ; i < n ; i++)parent[i] = i;\\n    }\\n    int findPar(int node)\\n    {\\n        if(node == parent[node])return node;\\n        else return parent[node] = findPar(parent[node]);\\n    }\\n    void UnionBy(int u , int v)\\n    {\\n        int pu = findPar(u);\\n        int pv = findPar(v);\\n\\n        if(pu == pv)return ;\\n        \\n        if(rank[pu] > rank[pv]){\\n            parent[pv] = pu;\\n        }\\n        else if(rank[pv] > rank[pu]){\\n            parent[pu] = pv;\\n        }\\n        else{\\n            rank[pu]++;\\n            parent[pu] = pv;\\n        }\\n    }\\n};\\nstruct myCmp{\\n    bool operator()(vector<int>&a , vector<int>&b){\\n        if(a[2] < b[2]) return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& arr, vector<vector<int>>& q) {\\n          int num = q.size();\\n          vector<bool> result(num);\\n          DSU ds(n);\\n          for(int i = 0 ; i < num ; i++)q[i].push_back(i);\\n\\n          sort(q.begin() , q.end() , [](vector<int>&l , vector<int>&r){return l[2] < r[2];});\\n          sort(arr.begin() , arr.end() , [](vector<int>&l , vector<int>&r){return l[2] < r[2];});\\n\\n          int index = 0;\\n          for(vector<int>&temp : q){\\n              int u = temp[0];\\n              int v = temp[1];\\n              int limit = temp[2];\\n              int i = temp[3];\\n\\n              while(index < arr.size() && arr[index][2] < limit){\\n                       ds.UnionBy(arr[index][0] , arr[index][1]);    \\n                       index++;  \\n              }\\n              result[i] = ds.findPar(u) == ds.findPar(v);\\n          }\\n          return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\n    vector<int> parent , rank;\\n    public:\\n    DSU(int n)\\n    {\\n        rank.resize(n , 0);\\n        parent.resize(n);\\n        for(int i = 0 ; i < n ; i++)parent[i] = i;\\n    }\\n    int findPar(int node)\\n    {\\n        if(node == parent[node])return node;\\n        else return parent[node] = findPar(parent[node]);\\n    }\\n    void UnionBy(int u , int v)\\n    {\\n        int pu = findPar(u);\\n        int pv = findPar(v);\\n\\n        if(pu == pv)return ;\\n        \\n        if(rank[pu] > rank[pv]){\\n            parent[pv] = pu;\\n        }\\n        else if(rank[pv] > rank[pu]){\\n            parent[pu] = pv;\\n        }\\n        else{\\n            rank[pu]++;\\n            parent[pu] = pv;\\n        }\\n    }\\n};\\nstruct myCmp{\\n    bool operator()(vector<int>&a , vector<int>&b){\\n        if(a[2] < b[2]) return true;\\n        return false;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& arr, vector<vector<int>>& q) {\\n          int num = q.size();\\n          vector<bool> result(num);\\n          DSU ds(n);\\n          for(int i = 0 ; i < num ; i++)q[i].push_back(i);\\n\\n          sort(q.begin() , q.end() , [](vector<int>&l , vector<int>&r){return l[2] < r[2];});\\n          sort(arr.begin() , arr.end() , [](vector<int>&l , vector<int>&r){return l[2] < r[2];});\\n\\n          int index = 0;\\n          for(vector<int>&temp : q){\\n              int u = temp[0];\\n              int v = temp[1];\\n              int limit = temp[2];\\n              int i = temp[3];\\n\\n              while(index < arr.size() && arr[index][2] < limit){\\n                       ds.UnionBy(arr[index][0] , arr[index][1]);    \\n                       index++;  \\n              }\\n              result[i] = ds.findPar(u) == ds.findPar(v);\\n          }\\n          return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852176,
                "title": "dsu-c",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust build the trees according to the queries.\\nSort the queries array based on the limit of each queries and then build the graph using those edges which have distance between then less than that of the limit of the queries. A DSU can be used to build the graph. It is very similar to building a MST. Note that you should sort the edgeList array in increasing sequence of their distances. \\n\\n\\n# Code\\n```\\nclass DSU{\\npublic:\\n    int N;\\n    vector<int> par,rank;\\n    int Find(int u){\\n        if(par[u]==-1){\\n            return u;\\n        }\\n        return par[u]=Find(par[u]);\\n    }\\n    void Union(int u, int v){\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n\\n        if(s1!=s2){\\n            if(rank[s1]>=rank[s2]){\\n                rank[s1]+=rank[s2];\\n                par[s2]=s1;\\n            }else{\\n                rank[s2]+=rank[s1];\\n                par[s1]=s2;\\n            }\\n        }\\n    }\\n    DSU(int n){\\n        N = n;\\n        par = vector<int>(n+5,-1);\\n        rank = vector<int>(n+5,1);\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU* T = new DSU(n);\\n        vector<bool> ans(queries.size(),false);\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(edgeList.begin(),edgeList.end(),[](const auto &a, const auto &b){\\n            return (a[2]<b[2]);\\n        });\\n        sort(queries.begin(),queries.end(),[](const auto &a, const auto &b){\\n            return (a[2]<b[2]);\\n        });\\n        int i = 0;\\n        int j = 0;\\n\\n\\n        while(j<queries.size()){\\n            int u = queries[j][0];\\n            int v = queries[j][1];\\n            int lim = queries[j][2];\\n            int idx = queries[j][3];\\n        \\n            //construct a graph for (u,v) such that the distance between \\n            while(i<edgeList.size() and edgeList[i][2]<lim){\\n                //now keep adding these edges\\n                int x = edgeList[i][0];\\n                int y = edgeList[i][1];\\n                T->Union(x,y);\\n                i++;\\n            }\\n            if(T->Find(u)==T->Find(v)){\\n                ans[idx]=true;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n    int N;\\n    vector<int> par,rank;\\n    int Find(int u){\\n        if(par[u]==-1){\\n            return u;\\n        }\\n        return par[u]=Find(par[u]);\\n    }\\n    void Union(int u, int v){\\n        int s1 = Find(u);\\n        int s2 = Find(v);\\n\\n        if(s1!=s2){\\n            if(rank[s1]>=rank[s2]){\\n                rank[s1]+=rank[s2];\\n                par[s2]=s1;\\n            }else{\\n                rank[s2]+=rank[s1];\\n                par[s1]=s2;\\n            }\\n        }\\n    }\\n    DSU(int n){\\n        N = n;\\n        par = vector<int>(n+5,-1);\\n        rank = vector<int>(n+5,1);\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU* T = new DSU(n);\\n        vector<bool> ans(queries.size(),false);\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(edgeList.begin(),edgeList.end(),[](const auto &a, const auto &b){\\n            return (a[2]<b[2]);\\n        });\\n        sort(queries.begin(),queries.end(),[](const auto &a, const auto &b){\\n            return (a[2]<b[2]);\\n        });\\n        int i = 0;\\n        int j = 0;\\n\\n\\n        while(j<queries.size()){\\n            int u = queries[j][0];\\n            int v = queries[j][1];\\n            int lim = queries[j][2];\\n            int idx = queries[j][3];\\n        \\n            //construct a graph for (u,v) such that the distance between \\n            while(i<edgeList.size() and edgeList[i][2]<lim){\\n                //now keep adding these edges\\n                int x = edgeList[i][0];\\n                int y = edgeList[i][1];\\n                T->Union(x,y);\\n                i++;\\n            }\\n            if(T->Find(u)==T->Find(v)){\\n                ans[idx]=true;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846761,
                "title": "easy-python-solution-using-union-find-and-sorting-o-nlog-n-and-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parent=[i for i in range(n)]\\n        rank=[0]*n\\n        queries=list(enumerate(queries))\\n        edgeList.sort(key=lambda x:[x[2],x[0],x[1]])\\n        queries.sort(key=lambda x:[x[1][2],x[1][0],x[1][1]])\\n        i=0\\n        ans=[False for _ in range(len(queries))]\\n        for index,val in queries:\\n            a,b,c=val\\n            while(i<len(edgeList) and edgeList[i][2]<c):\\n                self.union(parent,edgeList[i][0],edgeList[i][1],rank)\\n                i+=1\\n            ans[index]=(self.find(parent,a)==self.find(parent,b))\\n        return ans\\n            \\n    def union(self,parent,node1,node2,rank):\\n        par1=self.find(parent,node1)\\n        par2=self.find(parent,node2)\\n        if(par1!=par2):\\n            if(rank[par1]>rank[par2]):\\n                parent[par2]=par1\\n            elif(rank[par1]<rank[par2]):\\n                parent[par1]=par2\\n            else:\\n                rank[par1]+=1\\n                parent[par2]=par1\\n    \\n    def find(self,parent,node):\\n        if(parent[node]==node):return node\\n        parent[node]=self.find(parent,parent[node])\\n        return parent[node]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        parent=[i for i in range(n)]\\n        rank=[0]*n\\n        queries=list(enumerate(queries))\\n        edgeList.sort(key=lambda x:[x[2],x[0],x[1]])\\n        queries.sort(key=lambda x:[x[1][2],x[1][0],x[1][1]])\\n        i=0\\n        ans=[False for _ in range(len(queries))]\\n        for index,val in queries:\\n            a,b,c=val\\n            while(i<len(edgeList) and edgeList[i][2]<c):\\n                self.union(parent,edgeList[i][0],edgeList[i][1],rank)\\n                i+=1\\n            ans[index]=(self.find(parent,a)==self.find(parent,b))\\n        return ans\\n            \\n    def union(self,parent,node1,node2,rank):\\n        par1=self.find(parent,node1)\\n        par2=self.find(parent,node2)\\n        if(par1!=par2):\\n            if(rank[par1]>rank[par2]):\\n                parent[par2]=par1\\n            elif(rank[par1]<rank[par2]):\\n                parent[par1]=par2\\n            else:\\n                rank[par1]+=1\\n                parent[par2]=par1\\n    \\n    def find(self,parent,node):\\n        if(parent[node]==node):return node\\n        parent[node]=self.find(parent,parent[node])\\n        return parent[node]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831009,
                "title": "rust-disjoint-set",
                "content": "# Approach\\n\\nSort `queries` by weight limit. Then for each weight limit increase, link nodes in the graph that are now connected.\\n\\n# Code\\n```\\n#[derive(Debug)]\\npub struct DisjointSet {\\n    parents: Vec<Option<usize>>,\\n    count: usize,\\n}\\n\\nimpl DisjointSet {\\n    pub fn new(n: usize) -> Self {\\n        let parents = vec![None; n];\\n\\n        Self { parents, count: 0 }\\n    }\\n\\n    pub fn init(&mut self, e: usize) {\\n        if e >= self.parents.len() {\\n            return;\\n        }\\n        if self.parents[e].is_some() {\\n            return;\\n        } // already initialized\\n\\n        self.parents[e] = Some(e);\\n        self.count += 1; // new representative\\n    }\\n\\n    pub fn find(&mut self, e: usize) -> Option<usize> {\\n        if e >= self.parents.len() {\\n            return None;\\n        }\\n\\n        let parent = self.parents[e]?; // uninitialized\\n        if parent == e {\\n            return Some(e);\\n        } // self-representative\\n\\n        let ret = self.find(parent)?;\\n        self.parents[e] = Some(ret); // path compression\\n\\n        Some(ret)\\n    }\\n\\n    pub fn link(&mut self, e0: usize, e1: usize) {\\n        if let Some(p0) = self.find(e0) {\\n            if let Some(p1) = self.find(e1) {\\n                if p0 == p1 {\\n                    return;\\n                } // already linked\\n\\n                // p1 is no longer a representative\\n                self.parents[p1] = Some(p0);\\n                self.count -= 1;\\n            }\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.count\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(vec: Vec<Vec<i32>>) -> Vec<([usize; 2], u32)> {\\n        vec.into_iter()\\n            .filter(|v| v.len() > 2)\\n            .map(|v| {\\n                ([v[0] as usize, v[1] as usize], v[2] as u32)\\n            })\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn distance_limited_paths_exist(\\n        n: i32,\\n        edge_vec: Vec<Vec<i32>>,\\n        queries: Vec<Vec<i32>>\\n    ) -> Vec<bool> {\\n        let n = n as usize;\\n\\n        let mut edge_vec = Self::preproc(edge_vec);\\n        edge_vec.sort_unstable_by_key(|&(v, d)| (d, v));\\n        // println!(\"edge: {:?}\", edge_vec);\\n\\n        let queries = Self::preproc(queries);\\n        let n_queries = queries.len();\\n        let mut queries = queries.into_iter()\\n            .enumerate()\\n            .collect::<Vec<_>>();\\n        queries.sort_unstable_by_key(|&(i, (v, d))| ((d, v), i));\\n        // println!(\"queries: {:?}\", queries);\\n\\n        let mut set = DisjointSet::new(n);\\n        for i in 0..n { set.init(i); }\\n\\n        let mut ret = vec![false; n_queries];\\n\\n        let mut ptr_prev = usize::MIN;\\n        for (i, ([v0, v1], weight)) in queries {\\n            let ptr_1 = edge_vec.partition_point(|&(_, d)| d < weight);\\n            for ptr in ptr_prev..ptr_1 {\\n                let ([v0, v1], _) = edge_vec[ptr];\\n                set.link(v0, v1);\\n            }\\n            ptr_prev = ptr_1;\\n\\n            if set.find(v0).unwrap() == set.find(v1).unwrap() {\\n                ret[i] = true;\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Search",
                    "Union Find"
                ],
                "code": "```\\n#[derive(Debug)]\\npub struct DisjointSet {\\n    parents: Vec<Option<usize>>,\\n    count: usize,\\n}\\n\\nimpl DisjointSet {\\n    pub fn new(n: usize) -> Self {\\n        let parents = vec![None; n];\\n\\n        Self { parents, count: 0 }\\n    }\\n\\n    pub fn init(&mut self, e: usize) {\\n        if e >= self.parents.len() {\\n            return;\\n        }\\n        if self.parents[e].is_some() {\\n            return;\\n        } // already initialized\\n\\n        self.parents[e] = Some(e);\\n        self.count += 1; // new representative\\n    }\\n\\n    pub fn find(&mut self, e: usize) -> Option<usize> {\\n        if e >= self.parents.len() {\\n            return None;\\n        }\\n\\n        let parent = self.parents[e]?; // uninitialized\\n        if parent == e {\\n            return Some(e);\\n        } // self-representative\\n\\n        let ret = self.find(parent)?;\\n        self.parents[e] = Some(ret); // path compression\\n\\n        Some(ret)\\n    }\\n\\n    pub fn link(&mut self, e0: usize, e1: usize) {\\n        if let Some(p0) = self.find(e0) {\\n            if let Some(p1) = self.find(e1) {\\n                if p0 == p1 {\\n                    return;\\n                } // already linked\\n\\n                // p1 is no longer a representative\\n                self.parents[p1] = Some(p0);\\n                self.count -= 1;\\n            }\\n        }\\n    }\\n\\n    pub fn len(&self) -> usize {\\n        self.count\\n    }\\n}\\n\\nimpl Solution {\\n    fn preproc(vec: Vec<Vec<i32>>) -> Vec<([usize; 2], u32)> {\\n        vec.into_iter()\\n            .filter(|v| v.len() > 2)\\n            .map(|v| {\\n                ([v[0] as usize, v[1] as usize], v[2] as u32)\\n            })\\n            .collect::<Vec<_>>()\\n    }\\n\\n    pub fn distance_limited_paths_exist(\\n        n: i32,\\n        edge_vec: Vec<Vec<i32>>,\\n        queries: Vec<Vec<i32>>\\n    ) -> Vec<bool> {\\n        let n = n as usize;\\n\\n        let mut edge_vec = Self::preproc(edge_vec);\\n        edge_vec.sort_unstable_by_key(|&(v, d)| (d, v));\\n        // println!(\"edge: {:?}\", edge_vec);\\n\\n        let queries = Self::preproc(queries);\\n        let n_queries = queries.len();\\n        let mut queries = queries.into_iter()\\n            .enumerate()\\n            .collect::<Vec<_>>();\\n        queries.sort_unstable_by_key(|&(i, (v, d))| ((d, v), i));\\n        // println!(\"queries: {:?}\", queries);\\n\\n        let mut set = DisjointSet::new(n);\\n        for i in 0..n { set.init(i); }\\n\\n        let mut ret = vec![false; n_queries];\\n\\n        let mut ptr_prev = usize::MIN;\\n        for (i, ([v0, v1], weight)) in queries {\\n            let ptr_1 = edge_vec.partition_point(|&(_, d)| d < weight);\\n            for ptr in ptr_prev..ptr_1 {\\n                let ([v0, v1], _) = edge_vec[ptr];\\n                set.link(v0, v1);\\n            }\\n            ptr_prev = ptr_1;\\n\\n            if set.find(v0).unwrap() == set.find(v1).unwrap() {\\n                ret[i] = true;\\n            }\\n        }\\n\\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3826603,
                "title": "help-test-case-23-one-false-is-flipped-cannot-get-the-bug-in-my-code",
                "content": "```\\n class Solution {\\npublic:\\n    \\n    \\n    static bool sortit(vector<int> a , vector<int> b){\\n        return a[2] <= b[2];\\n    }\\n    \\n    \\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    \\n    int getparent(int node){\\n        if(parent[node] == node) \\n            return node;\\n        \\n        return parent[node] = getparent(parent[node]);\\n    }\\n    \\n    \\n    void Union(int node1 , int node2){\\n        \\n        int p1 = getparent(node1);\\n        int p2 = getparent(node2);\\n        \\n        int r1 = rank[p1];\\n        int r2 = rank[p2];\\n        \\n        if(r1 >= r2){\\n            parent[p2] = p1;\\n            if(r1 == r2) rank[p1]++;\\n         }else{\\n            parent[p1] = p2;\\n        }\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n        \\n        parent.resize(n,-1);\\n        rank.resize(n,0);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n        }\\n        \\n        int sze = edgeList.size();\\n        int szq = queries.size();\\n        \\n        sort(edgeList.begin(),edgeList.end(),sortit);\\n        \\n//         cout<<\" sorted edgeList \"<<endl;\\n//         for(int i=0;i<sze;i++){\\n//             cout<<edgeList[i][0]<<\" \"<<edgeList[i][1]<<\" \"<<edgeList[i][2]<<endl;\\n//         }\\n        \\n        unordered_map<string,int>  posQ;\\n        \\n        for(int i=0;i<szq;i++){\\n            string key = to_string(queries[i][0]) +\"|\"+to_string(queries[i][1]) +\"|\"+to_string(queries[i][2]);\\n            \\n            \\n            posQ[key] = i;\\n        }\\n        \\n        \\n        sort(queries.begin(),queries.end(),sortit);\\n\\n        cout<<\" sorted qUERIES \"<<endl;\\n        for(int i=0;i<szq;i++){\\n            cout<<queries[i][0]<<\" \"<<queries[i][1]<<\" \"<<queries[i][2]<<endl;\\n        }\\n        \\n        vector<bool> ans(szq, false) ;\\n        \\n        \\n        int currQ = 0;\\n        // int currlimit = queries[currQ][2];\\n        \\n        int i = 0;\\n        \\n        while(currQ < szq){\\n            \\n            // cout<<i<<\" sze:\"<<sze<<\" currQ\"<<currQ<<\" szq:\"<<szq<<endl;\\n            \\n            while(i<sze && edgeList[i][2] < queries[currQ][2]){\\n                Union(edgeList[i][0] , edgeList[i][1]);\\n                i++;\\n            //    cout<<\"loop \"<<i<<\" \";\\n            }\\n            \\n            // cout<<\"here\"<<endl;\\n                int p1 = getparent(queries[currQ][0]);\\n                int p2 = getparent(queries[currQ][1]);\\n                \\n                string key = to_string(queries[currQ][0]) +\"|\"+to_string(queries[currQ][1]) +\"|\"+to_string(queries[currQ][2]);\\n                \\n                int idx = posQ[key];\\n            \\n                if(p1 == p2) ans[idx] = true;\\n                \\n                currQ++;\\n                cout<<\"currQ \"<<currQ<<endl;\\n            }\\n        \\n            // cout<<\"here\"<<endl;\\n            return ans;\\n\\n        }\\n        \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    \\n    \\n    static bool sortit(vector<int> a , vector<int> b){\\n        return a[2] <= b[2];\\n    }\\n    \\n    \\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    \\n    int getparent(int node){\\n        if(parent[node] == node) \\n            return node;\\n        \\n        return parent[node] = getparent(parent[node]);\\n    }\\n    \\n    \\n    void Union(int node1 , int node2){\\n        \\n        int p1 = getparent(node1);\\n        int p2 = getparent(node2);\\n        \\n        int r1 = rank[p1];\\n        int r2 = rank[p2];\\n        \\n        if(r1 >= r2){\\n            parent[p2] = p1;\\n            if(r1 == r2) rank[p1]++;\\n         }else{\\n            parent[p1] = p2;\\n        }\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n        \\n        parent.resize(n,-1);\\n        rank.resize(n,0);\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            parent[i] = i;\\n        }\\n        \\n        int sze = edgeList.size();\\n        int szq = queries.size();\\n        \\n        sort(edgeList.begin(),edgeList.end(),sortit);\\n        \\n//         cout<<\" sorted edgeList \"<<endl;\\n//         for(int i=0;i<sze;i++){\\n//             cout<<edgeList[i][0]<<\" \"<<edgeList[i][1]<<\" \"<<edgeList[i][2]<<endl;\\n//         }\\n        \\n        unordered_map<string,int>  posQ;\\n        \\n        for(int i=0;i<szq;i++){\\n            string key = to_string(queries[i][0]) +\"|\"+to_string(queries[i][1]) +\"|\"+to_string(queries[i][2]);\\n            \\n            \\n            posQ[key] = i;\\n        }\\n        \\n        \\n        sort(queries.begin(),queries.end(),sortit);\\n\\n        cout<<\" sorted qUERIES \"<<endl;\\n        for(int i=0;i<szq;i++){\\n            cout<<queries[i][0]<<\" \"<<queries[i][1]<<\" \"<<queries[i][2]<<endl;\\n        }\\n        \\n        vector<bool> ans(szq, false) ;\\n        \\n        \\n        int currQ = 0;\\n        // int currlimit = queries[currQ][2];\\n        \\n        int i = 0;\\n        \\n        while(currQ < szq){\\n            \\n            // cout<<i<<\" sze:\"<<sze<<\" currQ\"<<currQ<<\" szq:\"<<szq<<endl;\\n            \\n            while(i<sze && edgeList[i][2] < queries[currQ][2]){\\n                Union(edgeList[i][0] , edgeList[i][1]);\\n                i++;\\n            //    cout<<\"loop \"<<i<<\" \";\\n            }\\n            \\n            // cout<<\"here\"<<endl;\\n                int p1 = getparent(queries[currQ][0]);\\n                int p2 = getparent(queries[currQ][1]);\\n                \\n                string key = to_string(queries[currQ][0]) +\"|\"+to_string(queries[currQ][1]) +\"|\"+to_string(queries[currQ][2]);\\n                \\n                int idx = posQ[key];\\n            \\n                if(p1 == p2) ans[idx] = true;\\n                \\n                currQ++;\\n                cout<<\"currQ \"<<currQ<<endl;\\n            }\\n        \\n            // cout<<\"here\"<<endl;\\n            return ans;\\n\\n        }\\n        \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3739642,
                "title": "pls-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] weight;\\n    public boolean[] distanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        // Initialize parent, rank, and weight arrays\\n        parent = new int[length];\\n        rank = new int[length];\\n        weight = new int[length];\\n        for (int i = 0; i < length ; i++) parent[i] = i;\\n\\n        // Sort edges in the adjacency list by distance\\n        Arrays.sort(adjList, Comparator.comparingInt(a -> a[2]));\\n        // Group nodes into connected components using union-find algorithm\\n        for (int[] edge : adjList) unionByRank(edge[0], edge[1], edge[2]);\\n\\n        // Initialize answer array\\n        boolean[] answer = new boolean[queries.length];\\n        // Check if there is a path between two nodes with distance less than the given limit for each query\\n        for (int i = 0 ; i < queries.length; i++)\\n            answer[i] = isConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n\\n    // Check if there is a path between two nodes with distance less than the given limit\\n    public boolean isConnectedAndWithinLimit(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    // Find the root of the connected component for a node with distance less than the given limit\\n    private int find (int x, int limit) {\\n        while (x != parent[x]) {\\n            // If the weight of the edge is greater than or equal to the given limit, break out of the loop\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    // Union two nodes into the same connected component with the given limit as the weight of the edge\\n    private void unionByRank (int x, int y, int limit) {\\n        // Find the root of the connected component for each node\\n        int x_ref = find (x, Integer.MAX_VALUE);\\n        int y_ref = find (y, Integer.MAX_VALUE);\\n        if (x_ref != y_ref) {\\n            // If the rank of the root of x is less than the rank of the root of y, make y the parent of x\\n            if (rank[x_ref] < rank[y_ref]) {\\n                parent[x_ref] = y_ref;\\n                weight [x_ref] = limit;;\\n            } else {\\n                // Otherwise, make x the parent of y\\n                parent[y_ref] = x_ref;\\n                weight[y_ref] = limit;\\n                // If the ranks of the roots are equal, increment the rank of the root of x\\n                if (rank[x_ref] == rank[y_ref]) {\\n                    rank[x_ref]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int[] parent;\\n    private int[] rank;\\n    private int[] weight;\\n    public boolean[] distanceLimitedPathsExist(int length, int[][] adjList, int[][] queries) {\\n        // Initialize parent, rank, and weight arrays\\n        parent = new int[length];\\n        rank = new int[length];\\n        weight = new int[length];\\n        for (int i = 0; i < length ; i++) parent[i] = i;\\n\\n        // Sort edges in the adjacency list by distance\\n        Arrays.sort(adjList, Comparator.comparingInt(a -> a[2]));\\n        // Group nodes into connected components using union-find algorithm\\n        for (int[] edge : adjList) unionByRank(edge[0], edge[1], edge[2]);\\n\\n        // Initialize answer array\\n        boolean[] answer = new boolean[queries.length];\\n        // Check if there is a path between two nodes with distance less than the given limit for each query\\n        for (int i = 0 ; i < queries.length; i++)\\n            answer[i] = isConnectedAndWithinLimit(queries[i][0], queries[i][1], queries[i][2]);\\n\\n        return answer;\\n    }\\n\\n    // Check if there is a path between two nodes with distance less than the given limit\\n    public boolean isConnectedAndWithinLimit(int p, int q, int limit) {\\n        return find(p, limit) == find(q, limit);\\n    }\\n\\n    // Find the root of the connected component for a node with distance less than the given limit\\n    private int find (int x, int limit) {\\n        while (x != parent[x]) {\\n            // If the weight of the edge is greater than or equal to the given limit, break out of the loop\\n            if (weight[x] >= limit) {\\n                break;\\n            }\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n\\n    // Union two nodes into the same connected component with the given limit as the weight of the edge\\n    private void unionByRank (int x, int y, int limit) {\\n        // Find the root of the connected component for each node\\n        int x_ref = find (x, Integer.MAX_VALUE);\\n        int y_ref = find (y, Integer.MAX_VALUE);\\n        if (x_ref != y_ref) {\\n            // If the rank of the root of x is less than the rank of the root of y, make y the parent of x\\n            if (rank[x_ref] < rank[y_ref]) {\\n                parent[x_ref] = y_ref;\\n                weight [x_ref] = limit;;\\n            } else {\\n                // Otherwise, make x the parent of y\\n                parent[y_ref] = x_ref;\\n                weight[y_ref] = limit;\\n                // If the ranks of the roots are equal, increment the rank of the root of x\\n                if (rank[x_ref] == rank[y_ref]) {\\n                    rank[x_ref]++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589539,
                "title": "easy-java-solution-dsa",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\n  public UnionFind(int n) {\\n    id = new int[n];\\n    rank = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void unionByRank(int u, int v) {\\n    final int i = find(u);\\n    final int j = find(v);\\n    if (i == j)\\n      return;\\n    if (rank[i] < rank[j]) {\\n      id[i] = id[j];\\n    } else if (rank[i] > rank[j]) {\\n      id[j] = id[i];\\n    } else {\\n      id[i] = id[j];\\n      ++rank[j];\\n    }\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n  private int[] rank;\\n}\\n\\nclass Solution {\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    boolean[] ans = new boolean[queries.length];\\n    int[][] qs = new int[queries.length][4];\\n    UnionFind uf = new UnionFind(n);\\n\\n    for (int i = 0; i < queries.length; ++i) {\\n      qs[i][0] = queries[i][0];\\n      qs[i][1] = queries[i][1];\\n      qs[i][2] = queries[i][2];\\n      qs[i][3] = i;\\n    }\\n\\n    Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n    Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n\\n    int i = 0; \\n    for (int[] q : qs) {\\n      while (i < edgeList.length && edgeList[i][2] < q[2])\\n        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);\\n      if (uf.find(q[0]) == uf.find(q[1]))\\n        ans[q[3]] = true;\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UnionFind {\\n  public UnionFind(int n) {\\n    id = new int[n];\\n    rank = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void unionByRank(int u, int v) {\\n    final int i = find(u);\\n    final int j = find(v);\\n    if (i == j)\\n      return;\\n    if (rank[i] < rank[j]) {\\n      id[i] = id[j];\\n    } else if (rank[i] > rank[j]) {\\n      id[j] = id[i];\\n    } else {\\n      id[i] = id[j];\\n      ++rank[j];\\n    }\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n  private int[] rank;\\n}\\n\\nclass Solution {\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    boolean[] ans = new boolean[queries.length];\\n    int[][] qs = new int[queries.length][4];\\n    UnionFind uf = new UnionFind(n);\\n\\n    for (int i = 0; i < queries.length; ++i) {\\n      qs[i][0] = queries[i][0];\\n      qs[i][1] = queries[i][1];\\n      qs[i][2] = queries[i][2];\\n      qs[i][3] = i;\\n    }\\n\\n    Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n    Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n\\n    int i = 0; \\n    for (int[] q : qs) {\\n      while (i < edgeList.length && edgeList[i][2] < q[2])\\n        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);\\n      if (uf.find(q[0]) == uf.find(q[1]))\\n        ans[q[3]] = true;\\n    }\\n\\n    return ans;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565912,
                "title": "dsu-striver-version",
                "content": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\n\\n\\nclass Solution {\\nprivate:\\n    bool static comp(vector<int> &a, vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n    bool static compQ(vector<int> &a, vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n    \\n    \\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& q) {\\n        sort(edgeList.begin(),edgeList.end(),comp);   //sorting according to dist\\n        DisjointSet ds(n);\\n        vector<bool> res(q.size());\\n        for(int i=0;i<q.size();i++){\\n            q[i].push_back(i);  // pushing the index in each q so we don\\'t loose track of its position\\n        }\\n        sort(q.begin(),q.end(),compQ); //sorting according to dist\\n        // for(auto it: edgeList) cout<<it[0]<<\" \";\\n        \\n        int k=0;\\n        for(int i=0;i<q.size();i++){//for each q, traverse the edgelist and insert those edges into the DSU whose dist is\\n\\t\\t//strictly less than the q_dist\\n            while(k<edgeList.size() && edgeList[k][2]<q[i][2]){\\n                if(ds.findUPar(edgeList[k][0])==ds.findUPar(edgeList[k][1])){  // they are connected\\n                }\\n                else{ // they are not connected\\n                    ds.unionByRank(edgeList[k][0],edgeList[k][1]);  \\n                    \\n                }\\n                k++;\\n            }\\n\\t\\t\\t//after we are done connecting all the edges within our limit, we check if both the nodes from the q are from the same parent. If yes, insert true into the res or else insert false into the res vector.\\n            if(ds.findUPar(q[i][0])==ds.findUPar(q[i][1])){\\n                res[q[i][3]]=true;\\n            }\\n            else res[q[i][3]]=false;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\nPeace :-)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size; \\npublic: \\n    DisjointSet(int n) {\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\n\\n\\nclass Solution {\\nprivate:\\n    bool static comp(vector<int> &a, vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n    bool static compQ(vector<int> &a, vector<int> &b){\\n        return a[2]<b[2];\\n    }\\n    \\n    \\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& q) {\\n        sort(edgeList.begin(),edgeList.end(),comp);   //sorting according to dist\\n        DisjointSet ds(n);\\n        vector<bool> res(q.size());\\n        for(int i=0;i<q.size();i++){\\n            q[i].push_back(i);  // pushing the index in each q so we don\\'t loose track of its position\\n        }\\n        sort(q.begin(),q.end(),compQ); //sorting according to dist\\n        // for(auto it: edgeList) cout<<it[0]<<\" \";\\n        \\n        int k=0;\\n        for(int i=0;i<q.size();i++){//for each q, traverse the edgelist and insert those edges into the DSU whose dist is\\n\\t\\t//strictly less than the q_dist\\n            while(k<edgeList.size() && edgeList[k][2]<q[i][2]){\\n                if(ds.findUPar(edgeList[k][0])==ds.findUPar(edgeList[k][1])){  // they are connected\\n                }\\n                else{ // they are not connected\\n                    ds.unionByRank(edgeList[k][0],edgeList[k][1]);  \\n                    \\n                }\\n                k++;\\n            }\\n\\t\\t\\t//after we are done connecting all the edges within our limit, we check if both the nodes from the q are from the same parent. If yes, insert true into the res or else insert false into the res vector.\\n            if(ds.findUPar(q[i][0])==ds.findUPar(q[i][1])){\\n                res[q[i][3]]=true;\\n            }\\n            else res[q[i][3]]=false;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3516592,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        dict1, n = defaultdict(int), len(queries)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        edgeList.sort(key = lambda x: x[2])\\n\\n        i, res = 0, [False]*n\\n\\n        for limit, x, y, idx in sorted((q[2],q[0],q[1],i) for i,q in enumerate(queries)):\\n            while i < len(edgeList) and edgeList[i][2] < limit:\\n                union(edgeList[i][0],edgeList[i][1])\\n                i += 1\\n            res[idx] = find(x) == find(y)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n, edgeList, queries):\\n        dict1, n = defaultdict(int), len(queries)\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n\\n        edgeList.sort(key = lambda x: x[2])\\n\\n        i, res = 0, [False]*n\\n\\n        for limit, x, y, idx in sorted((q[2],q[0],q[1],i) for i,q in enumerate(queries)):\\n            while i < len(edgeList) and edgeList[i][2] < limit:\\n                union(edgeList[i][0],edgeList[i][1])\\n                i += 1\\n            res[idx] = find(x) == find(y)\\n            \\n        return res\\n            \\n            \\n            \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510295,
                "title": "java-union-find",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    class DSU {\\n        int[] roots;\\n        int[] sizes;\\n        DSU(int size) {\\n            roots = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                roots[i] = i;\\n            }\\n            sizes = new int[size];\\n        }\\n        public int find(int a) {\\n            if (roots[a] == a) {\\n                return a;\\n            }\\n            roots[a] = find(roots[a]);\\n            return roots[a];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            if (sizes[rootA] > sizes[rootB]) {\\n                roots[rootB] = rootA;\\n                sizes[rootA] += sizes[rootB];\\n            } else {\\n                roots[rootA] = rootB;\\n                sizes[rootB] += sizes[rootA];\\n            }\\n        }\\n    }\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        boolean[] res = new boolean[queries.length];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2)->Integer.compare(v1[2], v2[2]));\\n        for (int i = 0; i < queries.length; i++) {\\n            pq.add(new int[]{queries[i][0], queries[i][1], queries[i][2], i});\\n        }\\n\\n        Arrays.sort(edgeList, (int[] v1, int[] v2)->Integer.compare(v1[2], v2[2]));\\n\\n        DSU dsu = new DSU(n);\\n\\n        int i = 0;\\n        while ( ! pq.isEmpty()) {\\n            int[] q = pq.poll();\\n            while (i < edgeList.length && edgeList[i][2] < q[2]) {\\n                dsu.union(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n            res[q[3]] = (dsu.find(q[0]) == dsu.find(q[1]));\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    class DSU {\\n        int[] roots;\\n        int[] sizes;\\n        DSU(int size) {\\n            roots = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                roots[i] = i;\\n            }\\n            sizes = new int[size];\\n        }\\n        public int find(int a) {\\n            if (roots[a] == a) {\\n                return a;\\n            }\\n            roots[a] = find(roots[a]);\\n            return roots[a];\\n        }\\n\\n        public void union(int a, int b) {\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA == rootB) {\\n                return;\\n            }\\n            if (sizes[rootA] > sizes[rootB]) {\\n                roots[rootB] = rootA;\\n                sizes[rootA] += sizes[rootB];\\n            } else {\\n                roots[rootA] = rootB;\\n                sizes[rootB] += sizes[rootA];\\n            }\\n        }\\n    }\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        boolean[] res = new boolean[queries.length];\\n\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((int[] v1, int[] v2)->Integer.compare(v1[2], v2[2]));\\n        for (int i = 0; i < queries.length; i++) {\\n            pq.add(new int[]{queries[i][0], queries[i][1], queries[i][2], i});\\n        }\\n\\n        Arrays.sort(edgeList, (int[] v1, int[] v2)->Integer.compare(v1[2], v2[2]));\\n\\n        DSU dsu = new DSU(n);\\n\\n        int i = 0;\\n        while ( ! pq.isEmpty()) {\\n            int[] q = pq.poll();\\n            while (i < edgeList.length && edgeList[i][2] < q[2]) {\\n                dsu.union(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n            res[q[3]] = (dsu.find(q[0]) == dsu.find(q[1]));\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499608,
                "title": "java-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int parent[];\\n    int rank[];\\n\\n    private int find(int n){\\n        if(parent[n]==n)return n;\\n        return parent[n]=find(parent[n]);\\n    }\\nprivate void union (int a,int b){\\n    int pa=find(a);\\n    int pb=find(b);\\n    if(pa==pb)return ;\\n    if(rank[pa]<rank[pb]){parent[pb]=pa;}\\n    else if(rank[pa]>rank[pb]){parent[pa]=pb;}\\n    else{\\n    parent[pb]=pa;\\n    rank[pa]++;\\n    }\\n}\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        parent=new int[n];\\n        rank=new int[n];\\n        for(int i=0;i<n;i++)parent[i]=i;\\n        int q[][]=new int[queries.length][4];\\n        for(int i=0;i<q.length;i++){\\n                q[i][0]=queries[i][0];\\n                q[i][1]=queries[i][1];\\n                q[i][2]=queries[i][2];\\n                q[i][3]=i;\\n        }\\n        boolean ans[]=new boolean[queries.length];\\nArrays.sort(q,(a,b)->Integer.compare(a[2],b[2]));\\nArrays.sort(edgeList,(a,b)->Integer.compare(a[2],b[2]));\\nint i=0;\\nfor(int[] a:q){\\nwhile(i<edgeList.length&& edgeList[i][2]<a[2]){\\n    union(edgeList[i][0],edgeList[i][1]);\\n    i++;\\n}\\nans[a[3]]=find(a[0])==find(a[1]);\\n\\n}\\nreturn ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int parent[];\\n    int rank[];\\n\\n    private int find(int n){\\n        if(parent[n]==n)return n;\\n        return parent[n]=find(parent[n]);\\n    }\\nprivate void union (int a,int b){\\n    int pa=find(a);\\n    int pb=find(b);\\n    if(pa==pb)return ;\\n    if(rank[pa]<rank[pb]){parent[pb]=pa;}\\n    else if(rank[pa]>rank[pb]){parent[pa]=pb;}\\n    else{\\n    parent[pb]=pa;\\n    rank[pa]++;\\n    }\\n}\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        parent=new int[n];\\n        rank=new int[n];\\n        for(int i=0;i<n;i++)parent[i]=i;\\n        int q[][]=new int[queries.length][4];\\n        for(int i=0;i<q.length;i++){\\n                q[i][0]=queries[i][0];\\n                q[i][1]=queries[i][1];\\n                q[i][2]=queries[i][2];\\n                q[i][3]=i;\\n        }\\n        boolean ans[]=new boolean[queries.length];\\nArrays.sort(q,(a,b)->Integer.compare(a[2],b[2]));\\nArrays.sort(edgeList,(a,b)->Integer.compare(a[2],b[2]));\\nint i=0;\\nfor(int[] a:q){\\nwhile(i<edgeList.length&& edgeList[i][2]<a[2]){\\n    union(edgeList[i][0],edgeList[i][1]);\\n    i++;\\n}\\nans[a[3]]=find(a[0])==find(a[1]);\\n\\n}\\nreturn ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493818,
                "title": "simple-using-dsu-default-template-sorting-with-explanation",
                "content": "```\\nclass DSU {\\npublic:\\n    vector<int> Parent, Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nbool cmp(const vector<int>&a,const vector<int>&b){\\n    return (a[2] < b[2]);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i); // preserving the original index\\n        }\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        sort(queries.begin(),queries.end(),cmp);\\n        vector<bool>ans(queries.size(),false);\\n        int i=0,j=0; // i represents the queries and j represents the edges;\\n        while(i<queries.size()){\\n            int p= queries[i][0], q= queries[i][1], limit = queries[i][2];\\n            while(j<edgeList.size() and edgeList[j][2]<limit){\\n                // we will build the graph;\\n                dsu.Union(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            \\n            ans[queries[i][3]]=(dsu.Find(p)==dsu.Find(q));\\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nTime Complexity -> e*log(e) {For sorting edgeList} + q*log(q) {for sorting queryList}  + O(q+e) {As the Union and find operation takes constant time....}\\nSpace Complexity -> O(n)",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\npublic:\\n    vector<int> Parent, Rank;\\n    DSU(int n) {\\n        Parent.resize(n);\\n        Rank.resize(n, 0);\\n        for (int i = 0; i < n; i++) Parent[i] = i;\\n    }\\n    int Find(int x) {\\n        return Parent[x] = Parent[x] == x ? x : Find(Parent[x]);\\n    }\\n    bool Union(int x, int y) {\\n        int xset = Find(x), yset = Find(y);\\n        if (xset != yset) {\\n            Rank[xset] < Rank[yset] ? Parent[xset] = yset : Parent[yset] = xset;\\n            Rank[xset] += Rank[xset] == Rank[yset];\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\nbool cmp(const vector<int>&a,const vector<int>&b){\\n    return (a[2] < b[2]);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU dsu(n);\\n        for(int i=0;i<queries.size();i++){\\n            queries[i].push_back(i); // preserving the original index\\n        }\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        sort(queries.begin(),queries.end(),cmp);\\n        vector<bool>ans(queries.size(),false);\\n        int i=0,j=0; // i represents the queries and j represents the edges;\\n        while(i<queries.size()){\\n            int p= queries[i][0], q= queries[i][1], limit = queries[i][2];\\n            while(j<edgeList.size() and edgeList[j][2]<limit){\\n                // we will build the graph;\\n                dsu.Union(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            \\n            ans[queries[i][3]]=(dsu.Find(p)==dsu.Find(q));\\n            i++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485114,
                "title": "c-easy-solution-disjoint-set-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool com(vector<int>& a,vector<int>& b){\\n        return a[2]<b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DisjointSet ds(n);\\n        int size=queries.size();\\n        vector<bool> Vec(size);\\n        map<pair<int,pair<int,int>>,vector<int>> mp;\\n        for(int i=0;i<queries.size();i++){\\n            mp[{queries[i][0],{queries[i][1],queries[i][2]}}].push_back(i);\\n            \\n        }\\n        sort(edgeList.begin(),edgeList.end(),com);\\n        sort(queries.begin(),queries.end(),com);\\n        int j=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(j<edgeList.size() && edgeList[j][2]<queries[i][2]){\\n                ds.unionByRank(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            int u=ds.findUPar(queries[i][0]);\\n            int v=ds.findUPar(queries[i][1]);\\n            pair<int,pair<int,int>> id={queries[i][0],{queries[i][1],queries[i][2]}};\\n            if(u==v){\\n                for(auto it:mp[id]){\\n                    Vec[it]=true;\\n                }\\n            }\\n        }\\n        return Vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    static bool com(vector<int>& a,vector<int>& b){\\n        return a[2]<b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DisjointSet ds(n);\\n        int size=queries.size();\\n        vector<bool> Vec(size);\\n        map<pair<int,pair<int,int>>,vector<int>> mp;\\n        for(int i=0;i<queries.size();i++){\\n            mp[{queries[i][0],{queries[i][1],queries[i][2]}}].push_back(i);\\n            \\n        }\\n        sort(edgeList.begin(),edgeList.end(),com);\\n        sort(queries.begin(),queries.end(),com);\\n        int j=0;\\n        for(int i=0;i<queries.size();i++){\\n            while(j<edgeList.size() && edgeList[j][2]<queries[i][2]){\\n                ds.unionByRank(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n            int u=ds.findUPar(queries[i][0]);\\n            int v=ds.findUPar(queries[i][1]);\\n            pair<int,pair<int,int>> id={queries[i][0],{queries[i][1],queries[i][2]}};\\n            if(u==v){\\n                for(auto it:mp[id]){\\n                    Vec[it]=true;\\n                }\\n            }\\n        }\\n        return Vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478512,
                "title": "dsu-very-easy-with-detail-explanation",
                "content": "\\nObservation\\n\\nThe key here is to notice that the queries are offline which means that we can reorganize them however we want.\\n\\nNow to answer the question, whether there is a path between any two nodes where the maximum edge length or weight is less than limit, we can join all the edges whose weight is less than limit and if we are still not able to reach one node from the other it essentially means that there is no path between them where edge weight is less than limit.\\n\\nWhich is the best data structure that can help us join edges as we want and answer whether in that structure, node a and node b are connected ?\\nThat\\'s right! DSU.\\n\\nLet\\'s try and use these facts to solve the question.\\n\\nSolution\\n\\nFirst we need to sort the input queries and edgeList by edge length or weight.\\n\\nWe can now simply use a two pointer approach to Union all the nodes whose edges have weight less than query[i].\\n\\nTo know if there is a path between them all we need is to know whether their parents (in DSU) are same.\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int>parent;\\n     int find(int node)\\n     {\\n      if(parent[node]==node)return node;\\n      return parent[node]=find(parent[node]);\\n     }\\n    void Union(int x  ,int y)\\n    {\\n         int px=find(x), py=find (y);\\n         if(px!=py) parent[px]=py;\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgelist, vector<vector<int>>& queries) {\\n        // Parent array\\n        parent.resize(n);\\n        for(int i=0 ; i< n ;i++)\\n        parent[i]=i;\\n        // Res code \\n        vector<bool>result(queries.size(),false);\\n        // Push index \\n        for(int i=0 ;i<queries.size();i++)\\n        queries[i].push_back(i);\\n\\n        // Logic to sort according to weight \\n        auto lamda=[&](vector<int>&v1,vector<int>&v2)\\n        {\\n            return v1[2]<v2[2];\\n        };\\n        sort(begin(edgelist),end(edgelist),lamda);\\n        sort(begin(queries),end(queries),lamda);\\n      \\n        // Dsu \\n        int j=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            vector<int>query=queries[i];\\n            int u=query[0];\\n            int v=query[1]; \\n            int w=query[2];\\n            int idx=query[3];\\n            while(j<edgelist.size() and edgelist[j][2]<w)\\n            {\\n                Union(edgelist[j][0] ,edgelist[j][1]);\\n                j++;\\n            }\\n          \\n          if(find(u)==find(v))\\n          result[idx]=true;\\n        }\\n        return result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int>parent;\\n     int find(int node)\\n     {\\n      if(parent[node]==node)return node;\\n      return parent[node]=find(parent[node]);\\n     }\\n    void Union(int x  ,int y)\\n    {\\n         int px=find(x), py=find (y);\\n         if(px!=py) parent[px]=py;\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgelist, vector<vector<int>>& queries) {\\n        // Parent array\\n        parent.resize(n);\\n        for(int i=0 ; i< n ;i++)\\n        parent[i]=i;\\n        // Res code \\n        vector<bool>result(queries.size(),false);\\n        // Push index \\n        for(int i=0 ;i<queries.size();i++)\\n        queries[i].push_back(i);\\n\\n        // Logic to sort according to weight \\n        auto lamda=[&](vector<int>&v1,vector<int>&v2)\\n        {\\n            return v1[2]<v2[2];\\n        };\\n        sort(begin(edgelist),end(edgelist),lamda);\\n        sort(begin(queries),end(queries),lamda);\\n      \\n        // Dsu \\n        int j=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            vector<int>query=queries[i];\\n            int u=query[0];\\n            int v=query[1]; \\n            int w=query[2];\\n            int idx=query[3];\\n            while(j<edgelist.size() and edgelist[j][2]<w)\\n            {\\n                Union(edgelist[j][0] ,edgelist[j][1]);\\n                j++;\\n            }\\n          \\n          if(find(u)==find(v))\\n          result[idx]=true;\\n        }\\n        return result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476477,
                "title": "c-sorting-dsu-o-n1-log-n1-n2-log-n2-o-n-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n1 log n1 + n2 log n2),\\nn1 = edgeList.size(), n2 = queries.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + n2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Dsu {\\npublic:\\n\\n    Dsu(int n) {\\n        root = rank = vector<int> (n, 0);\\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n        }\\n    }\\n\\n    int find(int i) {\\n        return root[i] == i ? i : root[i] = find(root[i]);\\n    }\\n\\n    void un(int i, int j) {\\n        int ri = find(i);\\n        int rj = find(j);\\n        if (ri == rj) return;\\n        if (rank[ri] > rank[rj]) root[rj] = ri;\\n        else if (rank[ri] < rank[rj]) root[ri] = rj;\\n        else {\\n            rank[ri]++;\\n            root[rj] = ri;\\n        }\\n    }\\n\\nprivate:\\n    vector<int> root, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        auto comp = [](const auto& a, const auto& b) { return a[2] < b[2]; };\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(edgeList.begin(), edgeList.end(), comp);\\n        sort(queries.begin(), queries.end(), comp);\\n        int i = 0;\\n        vector<bool> ans (queries.size());\\n        Dsu dsu (n);\\n        for (auto q:queries) {\\n            while (i < edgeList.size() && edgeList[i][2] < q[2]) {\\n                dsu.un(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n            ans[q[3]] = dsu.find(q[0]) == dsu.find(q[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass Dsu {\\npublic:\\n\\n    Dsu(int n) {\\n        root = rank = vector<int> (n, 0);\\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n        }\\n    }\\n\\n    int find(int i) {\\n        return root[i] == i ? i : root[i] = find(root[i]);\\n    }\\n\\n    void un(int i, int j) {\\n        int ri = find(i);\\n        int rj = find(j);\\n        if (ri == rj) return;\\n        if (rank[ri] > rank[rj]) root[rj] = ri;\\n        else if (rank[ri] < rank[rj]) root[ri] = rj;\\n        else {\\n            rank[ri]++;\\n            root[rj] = ri;\\n        }\\n    }\\n\\nprivate:\\n    vector<int> root, rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        auto comp = [](const auto& a, const auto& b) { return a[2] < b[2]; };\\n        for (int i = 0; i < queries.size(); i++) {\\n            queries[i].push_back(i);\\n        }\\n        sort(edgeList.begin(), edgeList.end(), comp);\\n        sort(queries.begin(), queries.end(), comp);\\n        int i = 0;\\n        vector<bool> ans (queries.size());\\n        Dsu dsu (n);\\n        for (auto q:queries) {\\n            while (i < edgeList.size() && edgeList[i][2] < q[2]) {\\n                dsu.un(edgeList[i][0], edgeList[i][1]);\\n                i++;\\n            }\\n            ans[q[3]] = dsu.find(q[0]) == dsu.find(q[1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3474263,
                "title": "dsu-sorting-most-easiest-solution-in-c",
                "content": "```\\nclass DSU{\\n    private:vector<int>parent,size;\\n    public:\\n    DSU(int node)\\n    {\\n        for(int i=0;i<=node;i++)\\n        {\\n            parent.push_back(i);\\n            size.push_back(1);\\n        }\\n    }\\n    \\n    int findparent(int node)\\n    {\\n        if(node==parent[node])\\n            return node;\\n        return parent[node]=findparent(parent[node]);\\n    }\\n    void unionbysize(int u,int v)\\n    {\\n        int pu=findparent(u);\\n        int pv=findparent(v);\\n        if(pv==pu)\\n            return ;\\n        if(size[pu]>size[pv])\\n        {\\n            parent[pv]=pu;\\n            size[pu]+=size[pv];\\n        }\\n        else\\n        {\\n            parent[pu]=pv;\\n            size[pv]+=size[pu];\\n        }\\n    }\\n    int get_size(int u)\\n    {\\n        \\n        return size[findparent(u)];\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n   static bool compa(vector<int>&a,vector<int>&b)\\n   {\\n       return a[2]<b[2];\\n   }\\n   static bool comp(vector<int>&a,vector<int>&b)\\n   {\\n       return a[2]<b[2];\\n   }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU obj(n+1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(),queries.end(),compa);\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        vector<bool>ans(queries.size(),0);\\n        int i=0;\\n        for(auto itr:queries)\\n        {\\n            int u=itr[0];\\n            int v=itr[1];\\n            int lim=itr[2];\\n            int index=itr[3];\\n            while(i<edgeList.size() and edgeList[i][2]<lim)\\n            {\\n                obj.unionbysize(edgeList[i][0],edgeList[i][1]);\\n                i++;\\n            }\\n            if(obj.findparent(u)==obj.findparent(v))\\n            {\\n                ans[index]=1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass DSU{\\n    private:vector<int>parent,size;\\n    public:\\n    DSU(int node)\\n    {\\n        for(int i=0;i<=node;i++)\\n        {\\n            parent.push_back(i);\\n            size.push_back(1);\\n        }\\n    }\\n    \\n    int findparent(int node)\\n    {\\n        if(node==parent[node])\\n            return node;\\n        return parent[node]=findparent(parent[node]);\\n    }\\n    void unionbysize(int u,int v)\\n    {\\n        int pu=findparent(u);\\n        int pv=findparent(v);\\n        if(pv==pu)\\n            return ;\\n        if(size[pu]>size[pv])\\n        {\\n            parent[pv]=pu;\\n            size[pu]+=size[pv];\\n        }\\n        else\\n        {\\n            parent[pu]=pv;\\n            size[pv]+=size[pu];\\n        }\\n    }\\n    int get_size(int u)\\n    {\\n        \\n        return size[findparent(u)];\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n   static bool compa(vector<int>&a,vector<int>&b)\\n   {\\n       return a[2]<b[2];\\n   }\\n   static bool comp(vector<int>&a,vector<int>&b)\\n   {\\n       return a[2]<b[2];\\n   }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        DSU obj(n+1);\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(),queries.end(),compa);\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        vector<bool>ans(queries.size(),0);\\n        int i=0;\\n        for(auto itr:queries)\\n        {\\n            int u=itr[0];\\n            int v=itr[1];\\n            int lim=itr[2];\\n            int index=itr[3];\\n            while(i<edgeList.size() and edgeList[i][2]<lim)\\n            {\\n                obj.unionbysize(edgeList[i][0],edgeList[i][1]);\\n                i++;\\n            }\\n            if(obj.findparent(u)==obj.findparent(v))\\n            {\\n                ans[index]=1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471505,
                "title": "golang-unionfind",
                "content": "# Code\\n```\\ntype UnionFind struct {\\n    rank []int\\n    group []int\\n}\\n\\nfunc New(n int) *UnionFind {\\n    uf := &UnionFind{}\\n    uf.rank = make([]int, n)\\n    uf.group = make([]int, n)\\n    for i := 0; i < n; i++ {\\n        uf.rank[i] = 1\\n        uf.group[i] = i\\n    }\\n    return uf\\n}\\n\\nfunc (uf *UnionFind) find(node int) int {\\n    if uf.group[node] == node {\\n        return node\\n    }\\n    uf.group[node] = uf.find(uf.group[node])\\n    return uf.group[node]\\n}\\n\\nfunc (uf *UnionFind) join(node1, node2 int) int {\\n    node1, node2 = uf.find(node1), uf.find(node2)\\n    if node1 == node2 {\\n        return 0\\n    }\\n    if uf.rank[node1] > uf.rank[node2] {\\n        uf.group[node2] = node1\\n        uf.rank[node1] += uf.rank[node2]\\n    } else {\\n        uf.group[node1] = node2\\n        uf.rank[node2] += uf.rank[node1]\\n    }\\n    return 1\\n}\\n\\nfunc (uf *UnionFind) areConnected(node1, node2 int) bool {\\n    return uf.find(node1) == uf.find(node2)\\n}\\n\\nfunc distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n    uf := New(n)\\n    queriesCount := len(queries)\\n    answer := make([]bool, queriesCount)\\n    for i := range queries {\\n        queries[i] = append(queries[i], i)\\n    }\\n    sort.Slice(queries, func(i, j int) bool {\\n        return queries[i][2] < queries[j][2] \\n    })\\n    edgesIndex := 0\\n    sort.Slice(edgeList, func(i, j int) bool {\\n        return edgeList[i][2] < edgeList[j][2]\\n    })\\n    for _, query := range queries {\\n        p, q, limit, queryOriginalIndex := query[0], query[1], query[2], query[3]\\n        for edgesIndex < len(edgeList) && edgeList[edgesIndex][2] < limit {\\n            uf.join(edgeList[edgesIndex][0], edgeList[edgesIndex][1])\\n            edgesIndex++\\n        }\\n        if uf.areConnected(p, q) {\\n            answer[queryOriginalIndex] = true\\n        }\\n    }\\n    return answer\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype UnionFind struct {\\n    rank []int\\n    group []int\\n}\\n\\nfunc New(n int) *UnionFind {\\n    uf := &UnionFind{}\\n    uf.rank = make([]int, n)\\n    uf.group = make([]int, n)\\n    for i := 0; i < n; i++ {\\n        uf.rank[i] = 1\\n        uf.group[i] = i\\n    }\\n    return uf\\n}\\n\\nfunc (uf *UnionFind) find(node int) int {\\n    if uf.group[node] == node {\\n        return node\\n    }\\n    uf.group[node] = uf.find(uf.group[node])\\n    return uf.group[node]\\n}\\n\\nfunc (uf *UnionFind) join(node1, node2 int) int {\\n    node1, node2 = uf.find(node1), uf.find(node2)\\n    if node1 == node2 {\\n        return 0\\n    }\\n    if uf.rank[node1] > uf.rank[node2] {\\n        uf.group[node2] = node1\\n        uf.rank[node1] += uf.rank[node2]\\n    } else {\\n        uf.group[node1] = node2\\n        uf.rank[node2] += uf.rank[node1]\\n    }\\n    return 1\\n}\\n\\nfunc (uf *UnionFind) areConnected(node1, node2 int) bool {\\n    return uf.find(node1) == uf.find(node2)\\n}\\n\\nfunc distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n    uf := New(n)\\n    queriesCount := len(queries)\\n    answer := make([]bool, queriesCount)\\n    for i := range queries {\\n        queries[i] = append(queries[i], i)\\n    }\\n    sort.Slice(queries, func(i, j int) bool {\\n        return queries[i][2] < queries[j][2] \\n    })\\n    edgesIndex := 0\\n    sort.Slice(edgeList, func(i, j int) bool {\\n        return edgeList[i][2] < edgeList[j][2]\\n    })\\n    for _, query := range queries {\\n        p, q, limit, queryOriginalIndex := query[0], query[1], query[2], query[3]\\n        for edgesIndex < len(edgeList) && edgeList[edgesIndex][2] < limit {\\n            uf.join(edgeList[edgesIndex][0], edgeList[edgesIndex][1])\\n            edgesIndex++\\n        }\\n        if uf.areConnected(p, q) {\\n            answer[queryOriginalIndex] = true\\n        }\\n    }\\n    return answer\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3470536,
                "title": "why-my-solution-got-tle-i-used-both-path-compression-and-union-by-rank",
                "content": "# Code\\n```\\nclass DSU{\\npublic:\\n    vector<int> rank, p;\\n    DSU(int n){\\n        rank.resize(n, 0);\\n        p.resize(n, 0);\\n        for(int i = 0;i < n;i++){\\n            p[i] = i;\\n        }\\n    }\\n    int Find(int x){\\n        if(p[x] != x){\\n            p[x] = Find(p[x]);\\n        }\\n        return p[x];\\n    }\\n    bool Union(int x, int y){\\n        int rootX = Find (x);\\n        int rootY = Find (y);\\n        if (rootX == rootY)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            if (rank[rootX] > rank[rootY])\\n            {\\n                p[rootY] = rootX;\\n            }\\n            else if (rank[rootY] > rank[rootX])\\n            {\\n                p[rootX] = rootY;\\n            }\\n            else\\n            {\\n                p[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& E, vector<vector<int>>& Q) {\\n        auto comp = [](auto a, auto b){\\n            return a[2] < b[2];\\n        };\\n        for(int i = 0;i < Q.size();i++){\\n            Q[i].push_back(i);\\n        }\\n        sort(E.begin(), E.end(), comp);\\n        sort(Q.begin(), Q.end(), comp);\\n        int idx = 0;\\n        vector<bool> res(Q.size(), 0);\\n        DSU ds(n);\\n        for(auto q : Q){\\n            int limit = q[2], a = q[0], b = q[1];\\n            while(idx < E.size() && E[idx][2] < limit){\\n                ds.Union(E[idx][0], E[idx][1]);\\n                idx++;\\n            }\\n            if((ds.Find(a) == ds.Find(b)))\\n                res[q[3]] = 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DSU{\\npublic:\\n    vector<int> rank, p;\\n    DSU(int n){\\n        rank.resize(n, 0);\\n        p.resize(n, 0);\\n        for(int i = 0;i < n;i++){\\n            p[i] = i;\\n        }\\n    }\\n    int Find(int x){\\n        if(p[x] != x){\\n            p[x] = Find(p[x]);\\n        }\\n        return p[x];\\n    }\\n    bool Union(int x, int y){\\n        int rootX = Find (x);\\n        int rootY = Find (y);\\n        if (rootX == rootY)\\n        {\\n            return false;\\n        }\\n        else\\n        {\\n            if (rank[rootX] > rank[rootY])\\n            {\\n                p[rootY] = rootX;\\n            }\\n            else if (rank[rootY] > rank[rootX])\\n            {\\n                p[rootX] = rootY;\\n            }\\n            else\\n            {\\n                p[rootX] = rootY;\\n                rank[rootY]++;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& E, vector<vector<int>>& Q) {\\n        auto comp = [](auto a, auto b){\\n            return a[2] < b[2];\\n        };\\n        for(int i = 0;i < Q.size();i++){\\n            Q[i].push_back(i);\\n        }\\n        sort(E.begin(), E.end(), comp);\\n        sort(Q.begin(), Q.end(), comp);\\n        int idx = 0;\\n        vector<bool> res(Q.size(), 0);\\n        DSU ds(n);\\n        for(auto q : Q){\\n            int limit = q[2], a = q[0], b = q[1];\\n            while(idx < E.size() && E[idx][2] < limit){\\n                ds.Union(E[idx][0], E[idx][1]);\\n                idx++;\\n            }\\n            if((ds.Find(a) == ds.Find(b)))\\n                res[q[3]] = 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470316,
                "title": "easy-c-disjoint-set-union-graphs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M) where, M = queries.size()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n  \\n  public:\\n\\n    vector<int> rank, parent;\\n    \\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n    \\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        \\n        if (ulp_u == ulp_v) return;\\n        \\n        if (rank[ulp_u] < rank[ulp_v]) \\n        parent[ulp_u] = ulp_v;\\n                \\n        else if (rank[ulp_v] < rank[ulp_u])\\n        parent[ulp_v] = ulp_u;\\n                \\n        else {\\n        \\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n            \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\nstatic bool cmp(vector<int> &a, vector<int> &b){\\n    \\n      return a[2]<b[2];\\n\\n}\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n      DisjointSet ds(n);\\n      \\n      vector<bool> ans(queries.size(), false);\\n\\n     for(int i=0;i<queries.size();i++)\\n      queries[i].push_back(i);\\n\\n      sort(queries.begin(), queries.end(), cmp);\\n\\n      sort(edgeList.begin(), edgeList.end(), cmp);\\n\\n      int i=0;\\n\\n      for(auto j : queries){\\ncout<<j[3]<<endl;\\n        while(i<edgeList.size() and edgeList[i][2] < j[2]){\\n\\n          ds.unionByRank(edgeList[i][0], edgeList[i][1]);\\n          i++;\\n\\n        }\\n\\n        if( ds.findUPar(j[0]) == ds.findUPar(j[1]) )\\n        ans[j[3]] = true;\\n\\n      }\\n\\n       return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet {\\n  \\n  public:\\n\\n    vector<int> rank, parent;\\n    \\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n    \\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        \\n        if (ulp_u == ulp_v) return;\\n        \\n        if (rank[ulp_u] < rank[ulp_v]) \\n        parent[ulp_u] = ulp_v;\\n                \\n        else if (rank[ulp_v] < rank[ulp_u])\\n        parent[ulp_v] = ulp_u;\\n                \\n        else {\\n        \\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n            \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\nstatic bool cmp(vector<int> &a, vector<int> &b){\\n    \\n      return a[2]<b[2];\\n\\n}\\n\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n      DisjointSet ds(n);\\n      \\n      vector<bool> ans(queries.size(), false);\\n\\n     for(int i=0;i<queries.size();i++)\\n      queries[i].push_back(i);\\n\\n      sort(queries.begin(), queries.end(), cmp);\\n\\n      sort(edgeList.begin(), edgeList.end(), cmp);\\n\\n      int i=0;\\n\\n      for(auto j : queries){\\ncout<<j[3]<<endl;\\n        while(i<edgeList.size() and edgeList[i][2] < j[2]){\\n\\n          ds.unionByRank(edgeList[i][0], edgeList[i][1]);\\n          i++;\\n\\n        }\\n\\n        if( ds.findUPar(j[0]) == ds.findUPar(j[1]) )\\n        ans[j[3]] = true;\\n\\n      }\\n\\n       return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3470169,
                "title": "sort-edges-queries-merge-groups-and-check-if-same-group",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNo Clue\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort Edges & Queries  ,merge groups and check if same group\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(n,m))\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int max_group = 0;\\n        int m = queries.size();\\n        int e_size = edgeList.size();\\n        for(int i=0; i<m; i++)\\n        {   // adding index\\n            queries[i].push_back(i);\\n        }\\n        vector<bool> ans(m,false);\\n        vector<vector<int>> groups;\\n        vector<int> my_group(n,-1);\\n        auto cmp = [](vector<int> &a,vector<int> &b)->bool {return(a[2]<b[2]);};\\n        sort(queries.begin(),queries.end(),cmp);\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        int next_edge  = 0;\\n        int last_limit = -1;\\n        for(int next_query = 0; next_query<m; next_query++)\\n        {\\n            int a = queries[next_query][0];\\n            int b = queries[next_query][1];\\n            if(last_limit == queries[next_query][2])\\n            {\\n                if (my_group[a] != -1 && my_group[a] == my_group[b])\\n                    ans[queries[next_query][3]] = true;\\n                else \\n                    ans[queries[next_query][3]] = false; continue;\\n            }\\n            last_limit = queries[next_query][2];\\n            for(; ((next_edge < e_size) && (edgeList[next_edge][2]<queries[next_query][2])); next_edge++)\\n            {\\n                int ae = edgeList[next_edge][0];\\n                int be = edgeList[next_edge][1];\\n                if (my_group[ae] == -1)\\n                {\\n                    if (my_group[be] == -1)\\n                    {\\n                        groups.push_back({ae,be});\\n                        my_group[be] = max_group++;\\n                    }\\n                    else\\n                    {\\n                        groups[my_group[be]].push_back(ae);\\n                    }\\n                    my_group[ae] = my_group[be];\\n                }\\n                else if (my_group[be] == -1)\\n                {\\n                    groups[my_group[ae]].push_back(be);\\n                    my_group[be] = my_group[ae];\\n                }\\n                else if  (my_group[be] != my_group[ae])\\n                {  // merge groups\\n                    if (groups[my_group[be]].size() > groups[my_group[ae]].size()) swap(ae,be);\\n                    int tmp = my_group[be];\\n                    for(auto i : groups[tmp])\\n                    {\\n                         groups[my_group[ae]].push_back(i);\\n                        my_group[i] = my_group[ae];\\n                    }\\n                    groups[tmp].clear();\\n                }\\n\\n            }\\n            if (my_group[a] != -1 && my_group[a] == my_group[b])\\n                ans[queries[next_query][3]] = true;\\n        }\\n        return  ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int max_group = 0;\\n        int m = queries.size();\\n        int e_size = edgeList.size();\\n        for(int i=0; i<m; i++)\\n        {   // adding index\\n            queries[i].push_back(i);\\n        }\\n        vector<bool> ans(m,false);\\n        vector<vector<int>> groups;\\n        vector<int> my_group(n,-1);\\n        auto cmp = [](vector<int> &a,vector<int> &b)->bool {return(a[2]<b[2]);};\\n        sort(queries.begin(),queries.end(),cmp);\\n        sort(edgeList.begin(),edgeList.end(),cmp);\\n        int next_edge  = 0;\\n        int last_limit = -1;\\n        for(int next_query = 0; next_query<m; next_query++)\\n        {\\n            int a = queries[next_query][0];\\n            int b = queries[next_query][1];\\n            if(last_limit == queries[next_query][2])\\n            {\\n                if (my_group[a] != -1 && my_group[a] == my_group[b])\\n                    ans[queries[next_query][3]] = true;\\n                else \\n                    ans[queries[next_query][3]] = false; continue;\\n            }\\n            last_limit = queries[next_query][2];\\n            for(; ((next_edge < e_size) && (edgeList[next_edge][2]<queries[next_query][2])); next_edge++)\\n            {\\n                int ae = edgeList[next_edge][0];\\n                int be = edgeList[next_edge][1];\\n                if (my_group[ae] == -1)\\n                {\\n                    if (my_group[be] == -1)\\n                    {\\n                        groups.push_back({ae,be});\\n                        my_group[be] = max_group++;\\n                    }\\n                    else\\n                    {\\n                        groups[my_group[be]].push_back(ae);\\n                    }\\n                    my_group[ae] = my_group[be];\\n                }\\n                else if (my_group[be] == -1)\\n                {\\n                    groups[my_group[ae]].push_back(be);\\n                    my_group[be] = my_group[ae];\\n                }\\n                else if  (my_group[be] != my_group[ae])\\n                {  // merge groups\\n                    if (groups[my_group[be]].size() > groups[my_group[ae]].size()) swap(ae,be);\\n                    int tmp = my_group[be];\\n                    for(auto i : groups[tmp])\\n                    {\\n                         groups[my_group[ae]].push_back(i);\\n                        my_group[i] = my_group[ae];\\n                    }\\n                    groups[tmp].clear();\\n                }\\n\\n            }\\n            if (my_group[a] != -1 && my_group[a] == my_group[b])\\n                ans[queries[next_query][3]] = true;\\n        }\\n        return  ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470019,
                "title": "well-explained-intutive-full-logic-explained",
                "content": "# Intuition\\nThe question is fairly easy one if Time complexity is ignored. We just need to traverse the queries array and see if there is a path possible and each edge is less than the given value in queries.\\nBut the trick lies to solve it within the given constraints and for that we can make use of **Sorting and DSU**.\\n\\n\\n# Approach\\n- First thought that comes is, for each query we will take all the nodes disconnected and then using DSU we will connect it if the edge between any two nodes < queries[i][2], and at last see if there is a path from queries[i][0] till queries[i][1].\\n- Here the problem would be that after each query we would need to clear our DSU result and start from scratch.\\n- SO in order to overcome this we need to **sort**. We will sort the queries vector by the **limit** given. Since we are sorting the queries vector and we need to return the result by the index, we will add index to the queries vector then sort it so that the order is preserved.\\n- We will also sort the edgeList according to the dis.\\n- So Basically for each query, we will traverse it and we will connect all the nodes using DSU such that queries[i][2] >  edgeList[j]2]. If any node is connected for queries[i][x] then it will be connected for queries[i][y], given that y>x. That is why we are sorting both edgeList and queries according to the dis and limit value respectively.\\n- Thus with help of sorting we are not doing any repetitive traversal. \\\\\\n- At last we are checking if the nodes are connected, if yes for that query we are storing True else False.\\n\\n# Complexity\\n- **Time complexity**:\\nWe are sorting both edgeList and queries vector. So TC O(nlogn)\\n\\n- **Space complexity**:\\nWe are using O(n) to store parent and rank vector for DSU.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n\\n    int findParent(int i)\\n    {\\n        if(parent[i]==i)\\n                return i;\\n        return findParent(parent[i]);\\n    }\\n\\n    void unionx(int x,int y)\\n    {\\n        int x_parent=findParent(x);\\n        int y_parent=findParent(y);\\t\\t\\n        \\n        if(x_parent==y_parent) return;\\n        if(rank[x_parent]>rank[y_parent])\\n                parent[y_parent]=x_parent;\\n        else if(rank[y_parent]>rank[x_parent])\\n                parent[x_parent]=y_parent;\\n        else{\\n            parent[x_parent]=y_parent;\\n            rank[y_parent]++;\\n        }\\n\\n    }\\n    static bool comp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[2]<v2[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        parent.resize(n);\\n        rank.resize(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        sort(queries.begin(),queries.end(),comp);\\n\\n        vector<bool>result(queries.size(),false);\\n\\n        int j=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int u=queries[i][0];\\n            int v=queries[i][1];\\n            int d=queries[i][2];\\n            int idx=queries[i][3];\\n\\n            while(j<edgeList.size() and edgeList[j][2]<d)\\n            {\\n                unionx(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n\\n            if(findParent(u)==findParent(v))\\n                result[idx]=true;\\n            else\\n                result[idx]=false;\\n        }\\n        return result;\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n\\n    int findParent(int i)\\n    {\\n        if(parent[i]==i)\\n                return i;\\n        return findParent(parent[i]);\\n    }\\n\\n    void unionx(int x,int y)\\n    {\\n        int x_parent=findParent(x);\\n        int y_parent=findParent(y);\\t\\t\\n        \\n        if(x_parent==y_parent) return;\\n        if(rank[x_parent]>rank[y_parent])\\n                parent[y_parent]=x_parent;\\n        else if(rank[y_parent]>rank[x_parent])\\n                parent[x_parent]=y_parent;\\n        else{\\n            parent[x_parent]=y_parent;\\n            rank[y_parent]++;\\n        }\\n\\n    }\\n    static bool comp(vector<int>&v1,vector<int>&v2)\\n    {\\n        return v1[2]<v2[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        parent.resize(n);\\n        rank.resize(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            queries[i].push_back(i);\\n        }\\n\\n        sort(edgeList.begin(),edgeList.end(),comp);\\n        sort(queries.begin(),queries.end(),comp);\\n\\n        vector<bool>result(queries.size(),false);\\n\\n        int j=0;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int u=queries[i][0];\\n            int v=queries[i][1];\\n            int d=queries[i][2];\\n            int idx=queries[i][3];\\n\\n            while(j<edgeList.size() and edgeList[j][2]<d)\\n            {\\n                unionx(edgeList[j][0],edgeList[j][1]);\\n                j++;\\n            }\\n\\n            if(findParent(u)==findParent(v))\\n                result[idx]=true;\\n            else\\n                result[idx]=false;\\n        }\\n        return result;\\n\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469699,
                "title": "c-sorting-disjoint-set-96-time-545ms-100-space-108-5mb",
                "content": "Typical clustering problem and we might wish to play smart about it, since a brute force approach will clearly fail with numbers at hand.\\n\\nWe will \"lazily\" populate our clustering data structure, a Disjoint Set (AKA \"Union Find\"), so tht it will have only all the edges below the current query.\\n\\nWe can avoid re-populating the clusters from scratch all the time, if we proceed in increasing order, as explained in a bit.\\n\\nBut first, let\\'s declare a few support variables:\\n* `eLen` and `qLen` will store the length of `edges` and `queries` respectively;\\n* `ePos` will be a pointer we will use to add edges lazily to our disjoint set;\\n* `lmt` and `resPos` are support variables we will use later with the queries;\\n* `uf` is our `UF` instance, initialised for the full range of `n`;\\n* `res` is our accumulator variable, preset to be of `qLen` cells to avoid reallocations.\\n\\nNext we will sort both `edges` and `queries` by increasing distance, but not before having added the original position `i` to each query, not to lose that information.\\n\\nOur class `UF` will have a constructor taking its expected size `n`, that will be stored in the variable `count` and used to fill the first `n` cells of `parent` so that each cell has a value equal to its index.\\n\\nWe will then create a standard `find` method that will `return` either:\\n* `node`, when its values matches `parent[node]` (ie: it is the head of a cluster);\\n* the recursive call to `find(parent[node])` otherwise, storing it in `parent[node]` itself.\\n\\nFinally the `merge` method will take two nodes `n1` and `n2` and:\\n* convert them to the value of their respective parents;\\n* `return` if they are the same (ie: already part of the same cluster);\\n* make sure that `n1 < n2`, swapping the two values otherwise;\\n* set the `parent` of `n2` to be `n1`;\\n* every time we merge, we have one less cluster, so we decrease `count` by `1`.\\n\\nTime for our main loop! For each query `q`, we will:\\n* store the original position of `q` (ie: `q[3]`) in `resPos`;\\n* if we are already in a situation that has every single node connected (ie: `uf.count == 1`), we will just:\\n    * set the matching cell `res[resPos]` to `true`;\\n    * `continue` with the loop;\\n* store the current distance limit (ie: `q[2]`) in `lmt`;\\n* loop `while` we still have edges to parse (ie: `ePos < eLen`) and their distance is within the limit (ie: `edges[ePos][2] < lmt`) and:\\n    * store the current edge `edges[ePos++]` in `currEdge` as a reference;\\n    * merge the nodes it connects in `uf`;\\n* set the matching cell `res[resPos]` to `true` if both queried nodes are in the same cluster (ie: `uf.find(q[0]) == uf.find(q[1])`), `false` otherwise.\\n\\nOnce done, we can `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$\\n\\n# Code\\n```cpp\\nstruct UF {\\n    int parent[100000], count;\\n    UF(int n) {\\n        // preparing count and parent\\n        count = n;\\n        iota(parent, parent + n, 0);\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int n1, int n2) {\\n        // turning n1 and n2 into their parents\\n        n1 = find(n1), n2 = find(n2);\\n        // nodes are already part of the same cluster\\n        if (n1 == n2) return;\\n        // making sure n1 < n2\\n        if (n1 > n2) swap(n1, n2);\\n        parent[n2] = n1, count--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>> &edges, vector<vector<int>> &queries) {\\n        // support variables\\n        int eLen = edges.size(), qLen = queries.size(), ePos = 0, lmt, resPos;\\n        UF uf(n);\\n        vector<bool> res(qLen);\\n        // preparing edges and queries\\n        sort(begin(edges), end(edges), [](auto &a, auto&b){return a[2] < b[2];});\\n        for (int i = 0; i < qLen; i++) queries[i].push_back(i);\\n        sort(begin(queries), end(queries), [](auto &a, auto&b){return a[2] < b[2];});\\n        // parsing queries\\n        for (auto &q: queries) {\\n            resPos = q[3];\\n            // all nodes are already connected\\n            if (uf.count == 1) {\\n                res[resPos] = true;\\n                continue;\\n            }\\n            // adding all edges that are still < lmt\\n            lmt = q[2];\\n            while (ePos < eLen && edges[ePos][2] < lmt) {\\n                auto &currEdge = edges[ePos++];\\n                uf.merge(currEdge[0], currEdge[1]);\\n            }\\n            // checking if both nodes are now in the same cluster\\n            res[resPos] = uf.find(q[0]) == uf.find(q[1]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAternative version with a boolean flag to stop the main loop when we have connected all the nodes already, after having initialised `res` to be all `true`s - it runs a bit faster:\\n\\n```cpp\\n// UF stays the same as above\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>> &edges, vector<vector<int>> &queries) {\\n        // support variables\\n        int eLen = edges.size(), qLen = queries.size(), ePos = 0, lmt, resPos;\\n        UF uf(n);\\n        vector<bool> res(qLen, true);\\n        bool allConnected = false;\\n        // preparing edges and queries\\n        sort(begin(edges), end(edges), [](auto &a, auto&b){return a[2] < b[2];});\\n        for (int i = 0; i < qLen; i++) queries[i].push_back(i);\\n        sort(begin(queries), end(queries), [](auto &a, auto&b){return a[2] < b[2];});\\n        // parsing queries\\n        for (auto &q: queries) {\\n            resPos = q[3];\\n            // adding all edges that are still < lmt\\n            lmt = q[2];\\n            while (ePos < eLen && edges[ePos][2] < lmt) {\\n                auto &currEdge = edges[ePos++];\\n                uf.merge(currEdge[0], currEdge[1]);\\n                if (uf.count == 1) {\\n                    allConnected = true;\\n                    break;\\n                }\\n            }\\n            // all nodes are already connected\\n            if (allConnected) break;\\n            // checking if both nodes are now in the same cluster\\n            res[resPos] = uf.find(q[0]) == uf.find(q[1]);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nSimilarly, I tried to implement ranking in `UF` and that too helped a bit:\\n\\n```cpp\\nstruct UF {\\n    int parent[100000], rank[100000], count;\\n    UF(int n) {\\n        // preparing count, rank and parent\\n        count = n;\\n        iota(parent, parent + n, 0);\\n        fill(rank, rank + n, 1);\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int n1, int n2) {\\n        // turning n1 and n2 into their parents\\n        n1 = find(n1), n2 = find(n2);\\n        // nodes are already part of the same cluster\\n        if (n1 == n2) return;\\n        // making sure n1 has the largest rank\\n        if (rank[n2] > rank[n1]) swap(n1, n2);\\n        parent[n2] = n1, rank[n1] += rank[n2], count--;\\n    }\\n};\\n\\n// main class stays the same\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```cpp\\nstruct UF {\\n    int parent[100000], count;\\n    UF(int n) {\\n        // preparing count and parent\\n        count = n;\\n        iota(parent, parent + n, 0);\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int n1, int n2) {\\n        // turning n1 and n2 into their parents\\n        n1 = find(n1), n2 = find(n2);\\n        // nodes are already part of the same cluster\\n        if (n1 == n2) return;\\n        // making sure n1 < n2\\n        if (n1 > n2) swap(n1, n2);\\n        parent[n2] = n1, count--;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>> &edges, vector<vector<int>> &queries) {\\n        // support variables\\n        int eLen = edges.size(), qLen = queries.size(), ePos = 0, lmt, resPos;\\n        UF uf(n);\\n        vector<bool> res(qLen);\\n        // preparing edges and queries\\n        sort(begin(edges), end(edges), [](auto &a, auto&b){return a[2] < b[2];});\\n        for (int i = 0; i < qLen; i++) queries[i].push_back(i);\\n        sort(begin(queries), end(queries), [](auto &a, auto&b){return a[2] < b[2];});\\n        // parsing queries\\n        for (auto &q: queries) {\\n            resPos = q[3];\\n            // all nodes are already connected\\n            if (uf.count == 1) {\\n                res[resPos] = true;\\n                continue;\\n            }\\n            // adding all edges that are still < lmt\\n            lmt = q[2];\\n            while (ePos < eLen && edges[ePos][2] < lmt) {\\n                auto &currEdge = edges[ePos++];\\n                uf.merge(currEdge[0], currEdge[1]);\\n            }\\n            // checking if both nodes are now in the same cluster\\n            res[resPos] = uf.find(q[0]) == uf.find(q[1]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\n// UF stays the same as above\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>> &edges, vector<vector<int>> &queries) {\\n        // support variables\\n        int eLen = edges.size(), qLen = queries.size(), ePos = 0, lmt, resPos;\\n        UF uf(n);\\n        vector<bool> res(qLen, true);\\n        bool allConnected = false;\\n        // preparing edges and queries\\n        sort(begin(edges), end(edges), [](auto &a, auto&b){return a[2] < b[2];});\\n        for (int i = 0; i < qLen; i++) queries[i].push_back(i);\\n        sort(begin(queries), end(queries), [](auto &a, auto&b){return a[2] < b[2];});\\n        // parsing queries\\n        for (auto &q: queries) {\\n            resPos = q[3];\\n            // adding all edges that are still < lmt\\n            lmt = q[2];\\n            while (ePos < eLen && edges[ePos][2] < lmt) {\\n                auto &currEdge = edges[ePos++];\\n                uf.merge(currEdge[0], currEdge[1]);\\n                if (uf.count == 1) {\\n                    allConnected = true;\\n                    break;\\n                }\\n            }\\n            // all nodes are already connected\\n            if (allConnected) break;\\n            // checking if both nodes are now in the same cluster\\n            res[resPos] = uf.find(q[0]) == uf.find(q[1]);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nstruct UF {\\n    int parent[100000], rank[100000], count;\\n    UF(int n) {\\n        // preparing count, rank and parent\\n        count = n;\\n        iota(parent, parent + n, 0);\\n        fill(rank, rank + n, 1);\\n    }\\n    int find(int node) {\\n        return node == parent[node] ? node : parent[node] = find(parent[node]);\\n    }\\n    void merge(int n1, int n2) {\\n        // turning n1 and n2 into their parents\\n        n1 = find(n1), n2 = find(n2);\\n        // nodes are already part of the same cluster\\n        if (n1 == n2) return;\\n        // making sure n1 has the largest rank\\n        if (rank[n2] > rank[n1]) swap(n1, n2);\\n        parent[n2] = n1, rank[n1] += rank[n2], count--;\\n    }\\n};\\n\\n// main class stays the same\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469466,
                "title": "c-efficient-solution-using-disjoint-set-union-faster-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n\\nclass DSU{\\n    public:\\n        vector<int> size;\\n        vector<int> parent;\\n\\n        DSU(int n){\\n            size.resize(n);\\n            parent.resize(n);\\n\\n            for(int i=0;i<n;i++){\\n                size[i] = 0;\\n                parent[i] = i;\\n            }\\n        }\\n\\n        int findParent(int node){\\n            if(parent[node] == node) return node;\\n            return parent[node] = findParent(parent[node]);\\n        }\\n\\n        void makeUnion(int node1,int node2){\\n            int u = findParent(node1),\\n            v = findParent(node2);\\n\\n            if(u == v) return;\\n            if(size[u] > size[v]){\\n                parent[v] = u;\\n                size[v] += size[u];\\n            }\\n            else{\\n                parent[u] = v;\\n                size[u] += size[v];\\n            }\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n\\n        sort(edgeList.begin(),edgeList.end(),[](vector<int>&v1,vector<int>&v2){\\n            return v1[2] < v2[2];\\n        });\\n        \\n        vector<vector<int>> newQueries;\\n        for(int i=0;i<queries.size();i++){\\n            newQueries.push_back({i,queries[i][0],queries[i][1],queries[i][2]});\\n        }\\n        sort(newQueries.begin(),newQueries.end(),[](vector<int>&v1,vector<int>&v2){\\n            return v1[3] < v2[3];\\n        });\\n        \\n        DSU* graph = new DSU(n);\\n        vector<bool> ans(queries.size(),false);\\n        int i=0;\\n        for(vector<int>&q : newQueries){\\n            int idx = q[0],u=q[1],v = q[2], limit = q[3];\\n            while(i < edgeList.size() && edgeList[i][2] < limit){\\n                graph->makeUnion(edgeList[i][0],edgeList[i][1]);\\n                i++;\\n            }\\n\\n            if(graph->findParent(u) == graph->findParent(v)) ans[idx] = true;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\n\\nclass DSU{\\n    public:\\n        vector<int> size;\\n        vector<int> parent;\\n\\n        DSU(int n){\\n            size.resize(n);\\n            parent.resize(n);\\n\\n            for(int i=0;i<n;i++){\\n                size[i] = 0;\\n                parent[i] = i;\\n            }\\n        }\\n\\n        int findParent(int node){\\n            if(parent[node] == node) return node;\\n            return parent[node] = findParent(parent[node]);\\n        }\\n\\n        void makeUnion(int node1,int node2){\\n            int u = findParent(node1),\\n            v = findParent(node2);\\n\\n            if(u == v) return;\\n            if(size[u] > size[v]){\\n                parent[v] = u;\\n                size[v] += size[u];\\n            }\\n            else{\\n                parent[u] = v;\\n                size[u] += size[v];\\n            }\\n        }\\n};\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n\\n        sort(edgeList.begin(),edgeList.end(),[](vector<int>&v1,vector<int>&v2){\\n            return v1[2] < v2[2];\\n        });\\n        \\n        vector<vector<int>> newQueries;\\n        for(int i=0;i<queries.size();i++){\\n            newQueries.push_back({i,queries[i][0],queries[i][1],queries[i][2]});\\n        }\\n        sort(newQueries.begin(),newQueries.end(),[](vector<int>&v1,vector<int>&v2){\\n            return v1[3] < v2[3];\\n        });\\n        \\n        DSU* graph = new DSU(n);\\n        vector<bool> ans(queries.size(),false);\\n        int i=0;\\n        for(vector<int>&q : newQueries){\\n            int idx = q[0],u=q[1],v = q[2], limit = q[3];\\n            while(i < edgeList.size() && edgeList[i][2] < limit){\\n                graph->makeUnion(edgeList[i][0],edgeList[i][1]);\\n                i++;\\n            }\\n\\n            if(graph->findParent(u) == graph->findParent(v)) ans[idx] = true;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469324,
                "title": "uniorfind-sortededgesaddsameset-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n     public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries)\\n        {\\n            UnionFind uf = new UnionFind(n);\\n\\n            // Summary\\n            // First of We Sort queries and as well as edges because\\n            // we first try as minimum val can be added in same set\\n            // ascending orderly we can union other set values.\\n            // as we sort queries so we have to track index for result, thats why we add a index in quires\\n\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                queries[i] = new[] { queries[i][0], queries[i][1], queries[i][2], i };\\n            }\\n\\n            Array.Sort(queries, (a,b)=> a[2] - b[2]);\\n            Array.Sort(edgeList, (a, b) => a[2] - b[2]);\\n            bool[] ans = new bool[queries.Length];\\n            \\n            for (int i = 0, j=0; i < queries.Length; i++)\\n            {\\n                while (j<edgeList.Length && edgeList[j][2] < queries[i][2])\\n                {\\n                    uf.Union(edgeList[j][0], edgeList[j++][1]);\\n                }\\n                ans[queries[i][3]] = uf.Find(queries[i][0]) == uf.Find(queries[i][1]);\\n            }\\n            return ans;\\n        }\\n      public class UnionFind\\n    {\\n         private int[] parent;\\n\\n        public UnionFind(int n)\\n        {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int Find(int x)\\n        {\\n            if (parent[x] != x) parent[x] = Find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void Union(int val1, int val2)\\n        {\\n            parent[Find(val1)] = parent[Find(val2)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n     public bool[] DistanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries)\\n        {\\n            UnionFind uf = new UnionFind(n);\\n\\n            // Summary\\n            // First of We Sort queries and as well as edges because\\n            // we first try as minimum val can be added in same set\\n            // ascending orderly we can union other set values.\\n            // as we sort queries so we have to track index for result, thats why we add a index in quires\\n\\n            for (int i = 0; i < queries.Length; i++)\\n            {\\n                queries[i] = new[] { queries[i][0], queries[i][1], queries[i][2], i };\\n            }\\n\\n            Array.Sort(queries, (a,b)=> a[2] - b[2]);\\n            Array.Sort(edgeList, (a, b) => a[2] - b[2]);\\n            bool[] ans = new bool[queries.Length];\\n            \\n            for (int i = 0, j=0; i < queries.Length; i++)\\n            {\\n                while (j<edgeList.Length && edgeList[j][2] < queries[i][2])\\n                {\\n                    uf.Union(edgeList[j][0], edgeList[j++][1]);\\n                }\\n                ans[queries[i][3]] = uf.Find(queries[i][0]) == uf.Find(queries[i][1]);\\n            }\\n            return ans;\\n        }\\n      public class UnionFind\\n    {\\n         private int[] parent;\\n\\n        public UnionFind(int n)\\n        {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int Find(int x)\\n        {\\n            if (parent[x] != x) parent[x] = Find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public void Union(int val1, int val2)\\n        {\\n            parent[Find(val1)] = parent[Find(val2)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468879,
                "title": "kotlin-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun distanceLimitedPathsExist(n: Int, edgeList: Array<IntArray>, queries: Array<IntArray>): BooleanArray {\\n        edgeList.sortBy { it[2] }\\n        val uf = UnionFind(n)\\n        val results = BooleanArray(queries.size)\\n        val queryIndices = queries.indices.sortedBy { queries[it][2] }\\n        \\n        var edgeIndex = 0\\n\\n        for (queryIndex in queryIndices) {\\n            val (p, q, limit) = queries[queryIndex]\\n\\n            while (edgeIndex < edgeList.size && edgeList[edgeIndex][2] < limit) {\\n                uf.union(edgeList[edgeIndex][0], edgeList[edgeIndex][1])\\n                edgeIndex++\\n            }\\n\\n            results[queryIndex] = uf.find(p) == uf.find(q)\\n        }\\n        \\n        return results\\n    }\\n}\\n\\nclass UnionFind(n: Int) {\\n    private val parent = IntArray(n) { it }\\n    private val rank = IntArray(n) { 0 }\\n\\n    fun find(x: Int): Int {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x])\\n        }\\n        return parent[x]\\n    }\\n\\n    fun union(x: Int, y: Int) {\\n        val rootX = find(x)\\n        val rootY = find(y)\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                parent[rootY] = rootX\\n            } else {\\n                parent[rootX] = rootY\\n                if (rank[rootX] == rank[rootY]) {\\n                    rank[rootY]++\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun distanceLimitedPathsExist(n: Int, edgeList: Array<IntArray>, queries: Array<IntArray>): BooleanArray {\\n        edgeList.sortBy { it[2] }\\n        val uf = UnionFind(n)\\n        val results = BooleanArray(queries.size)\\n        val queryIndices = queries.indices.sortedBy { queries[it][2] }\\n        \\n        var edgeIndex = 0\\n\\n        for (queryIndex in queryIndices) {\\n            val (p, q, limit) = queries[queryIndex]\\n\\n            while (edgeIndex < edgeList.size && edgeList[edgeIndex][2] < limit) {\\n                uf.union(edgeList[edgeIndex][0], edgeList[edgeIndex][1])\\n                edgeIndex++\\n            }\\n\\n            results[queryIndex] = uf.find(p) == uf.find(q)\\n        }\\n        \\n        return results\\n    }\\n}\\n\\nclass UnionFind(n: Int) {\\n    private val parent = IntArray(n) { it }\\n    private val rank = IntArray(n) { 0 }\\n\\n    fun find(x: Int): Int {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x])\\n        }\\n        return parent[x]\\n    }\\n\\n    fun union(x: Int, y: Int) {\\n        val rootX = find(x)\\n        val rootY = find(y)\\n\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                parent[rootY] = rootX\\n            } else {\\n                parent[rootX] = rootY\\n                if (rank[rootX] == rank[rootY]) {\\n                    rank[rootY]++\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468856,
                "title": "easy-fast-java-solution-checking-existence-of-edge-length-limited-paths",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] ques) {\\n        DSU dsu = new DSU(n);\\n        boolean ans[]=new boolean[ques.length];\\n        int q[][]=new int[ques.length][4];\\n        for(int i=0;i<ques.length;i++){\\n            q[i][0]=ques[i][0];\\n            q[i][1]=ques[i][1];\\n            q[i][2]=ques[i][2];\\n            q[i][3]=i;\\n        }\\n        sort(q);\\n        sort(edgeList);\\n        int j=0;\\n        for(int i=0;i<ques.length;i++){\\n            int d=q[i][2];\\n            for(;j<edgeList.length;j++){\\n                if(edgeList[j][2]<d){\\n                    int n1=edgeList[j][0];\\n                    int n2=edgeList[j][1];\\n                    dsu.join(n1,n2);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            boolean temp=dsu.isPair(q[i][0],q[i][1]);\\n            if(temp){\\n                ans[q[i][3]]=true;   \\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public void sort(int arr[][]){\\n        Arrays.sort(arr,new Comparator<int[]>(){\\n        public int compare(int a[], int b[]){\\n            return a[2]-b[2];\\n        }\\n        });\\n    }\\n\\n    class DSU{\\n        int arr[];\\n        int rank[];\\n\\n        public DSU(int n){\\n            arr=new int[n];\\n            rank=new int[n];\\n            for(int i=0;i<n;i++){\\n                arr[i]=i;\\n            }\\n        }\\n\\n        public void join(int n1, int n2){\\n            int p1=find(n1);\\n            int p2=find(n2);\\n            if(p1==p2){\\n                return;\\n            }\\n            if(rank[p1]>rank[p2]){\\n                arr[p2]=p1;\\n                return;\\n            }\\n            else if(rank[p1]<rank[p2]){\\n                arr[p1]=p2;\\n                return;\\n            }\\n            else{\\n                arr[p2]=p1;\\n                rank[p1]++;\\n                return;\\n            }\\n        }\\n\\n        public int find(int n1){\\n            if(n1==arr[n1]){\\n                return n1;\\n            }\\n            arr[n1]=find(arr[n1]);\\n            return arr[n1];\\n        }\\n\\n        public boolean isPair(int n1, int n2){\\n            return find(n1)==find(n2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] ques) {\\n        DSU dsu = new DSU(n);\\n        boolean ans[]=new boolean[ques.length];\\n        int q[][]=new int[ques.length][4];\\n        for(int i=0;i<ques.length;i++){\\n            q[i][0]=ques[i][0];\\n            q[i][1]=ques[i][1];\\n            q[i][2]=ques[i][2];\\n            q[i][3]=i;\\n        }\\n        sort(q);\\n        sort(edgeList);\\n        int j=0;\\n        for(int i=0;i<ques.length;i++){\\n            int d=q[i][2];\\n            for(;j<edgeList.length;j++){\\n                if(edgeList[j][2]<d){\\n                    int n1=edgeList[j][0];\\n                    int n2=edgeList[j][1];\\n                    dsu.join(n1,n2);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            boolean temp=dsu.isPair(q[i][0],q[i][1]);\\n            if(temp){\\n                ans[q[i][3]]=true;   \\n            }\\n        }\\n        return ans;\\n    }\\n\\n    public void sort(int arr[][]){\\n        Arrays.sort(arr,new Comparator<int[]>(){\\n        public int compare(int a[], int b[]){\\n            return a[2]-b[2];\\n        }\\n        });\\n    }\\n\\n    class DSU{\\n        int arr[];\\n        int rank[];\\n\\n        public DSU(int n){\\n            arr=new int[n];\\n            rank=new int[n];\\n            for(int i=0;i<n;i++){\\n                arr[i]=i;\\n            }\\n        }\\n\\n        public void join(int n1, int n2){\\n            int p1=find(n1);\\n            int p2=find(n2);\\n            if(p1==p2){\\n                return;\\n            }\\n            if(rank[p1]>rank[p2]){\\n                arr[p2]=p1;\\n                return;\\n            }\\n            else if(rank[p1]<rank[p2]){\\n                arr[p1]=p2;\\n                return;\\n            }\\n            else{\\n                arr[p2]=p1;\\n                rank[p1]++;\\n                return;\\n            }\\n        }\\n\\n        public int find(int n1){\\n            if(n1==arr[n1]){\\n                return n1;\\n            }\\n            arr[n1]=find(arr[n1]);\\n            return arr[n1];\\n        }\\n\\n        public boolean isPair(int n1, int n2){\\n            return find(n1)==find(n2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468014,
                "title": "javascript-union-find",
                "content": "\\n# Code\\n```\\nclass UnionFind {\\n  constructor(size) {\\n    this.group = [];\\n    this.rank = [];\\n    for (let i = 0; i < size; ++i) {\\n      this.group[i] = i;\\n    }\\n  }\\n\\n  find(node) {\\n    if (this.group[node] !== node) {\\n      this.group[node] = this.find(this.group[node]);\\n    }\\n    return this.group[node];\\n  }\\n\\n  join(node1, node2) {\\n    let group1 = this.find(node1);\\n    let group2 = this.find(node2);\\n\\n    // node1 and node2 already belong to same group.\\n    if (group1 === group2) {\\n      return;\\n    }\\n\\n    if (this.rank[group1] > this.rank[group2]) {\\n      this.group[group2] = group1;\\n    } else if (this.rank[group1] < this.rank[group2]) {\\n      this.group[group1] = group2;\\n    } else {\\n      this.group[group1] = group2;\\n      this.rank[group2] += 1;\\n    }\\n  }\\n\\n  areConnected(node1, node2) {\\n    let group1 = this.find(node1);\\n    let group2 = this.find(node2);\\n    return group1 === group2;\\n  }\\n}\\n\\nvar distanceLimitedPathsExist = function (n, edgeList, queries) {\\n  const uf = new UnionFind(n);\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    queries[i].push(i);\\n  }\\n\\n  const sorter = (a, b) => {\\n    return a[2] - b[2];\\n  }\\n\\n  edgeList.sort(sorter);\\n  queries.sort(sorter);\\n  const result = new Array(queries.length);\\n  let j = 0;\\n  for (let i = 0; i < queries.length; i++) {\\n    const [u, v, t, idx] = queries[i];\\n    while (j < edgeList.length && edgeList[j][2] < t) {\\n      uf.join(edgeList[j][0], edgeList[j][1]);\\n      j++;\\n    }\\n    if (uf.find(u) == uf.find(v)) {\\n      result[idx] = true;\\n    } else result[idx] = false;\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass UnionFind {\\n  constructor(size) {\\n    this.group = [];\\n    this.rank = [];\\n    for (let i = 0; i < size; ++i) {\\n      this.group[i] = i;\\n    }\\n  }\\n\\n  find(node) {\\n    if (this.group[node] !== node) {\\n      this.group[node] = this.find(this.group[node]);\\n    }\\n    return this.group[node];\\n  }\\n\\n  join(node1, node2) {\\n    let group1 = this.find(node1);\\n    let group2 = this.find(node2);\\n\\n    // node1 and node2 already belong to same group.\\n    if (group1 === group2) {\\n      return;\\n    }\\n\\n    if (this.rank[group1] > this.rank[group2]) {\\n      this.group[group2] = group1;\\n    } else if (this.rank[group1] < this.rank[group2]) {\\n      this.group[group1] = group2;\\n    } else {\\n      this.group[group1] = group2;\\n      this.rank[group2] += 1;\\n    }\\n  }\\n\\n  areConnected(node1, node2) {\\n    let group1 = this.find(node1);\\n    let group2 = this.find(node2);\\n    return group1 === group2;\\n  }\\n}\\n\\nvar distanceLimitedPathsExist = function (n, edgeList, queries) {\\n  const uf = new UnionFind(n);\\n\\n  for (let i = 0; i < queries.length; i++) {\\n    queries[i].push(i);\\n  }\\n\\n  const sorter = (a, b) => {\\n    return a[2] - b[2];\\n  }\\n\\n  edgeList.sort(sorter);\\n  queries.sort(sorter);\\n  const result = new Array(queries.length);\\n  let j = 0;\\n  for (let i = 0; i < queries.length; i++) {\\n    const [u, v, t, idx] = queries[i];\\n    while (j < edgeList.length && edgeList[j][2] < t) {\\n      uf.join(edgeList[j][0], edgeList[j][1]);\\n      j++;\\n    }\\n    if (uf.find(u) == uf.find(v)) {\\n      result[idx] = true;\\n    } else result[idx] = false;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468001,
                "title": "union-find-c-one-of-the-best-questions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjointset{\\n    vector<int> parent;\\n    vector<int> rank;\\n    public:\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i] = i;\\n        rank.resize(n+1);\\n        for(int i=0;i<=n;i++)rank[i] = 0;\\n    }\\n    int findUpar(int node){\\n        if(parent[node] == node)return node;\\n        return parent[node] = findUpar(parent[node]);\\n    }\\n    void make_union(int u,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;//connect smaller to larger \\n        }\\n        else if(rank[ulp_u] > rank[ulp_v]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else{\\n            parent[ulp_u] = ulp_v;\\n            rank[ulp_v]++;\\n        }\\n    }\\n    bool connected(int i,int j){return findUpar(i) == findUpar(j);}\\n};\\nclass Solution {\\n    static bool cmp(vector<int>&a,vector<int>&b){\\n        return a[2] < b[2];\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& q) {\\n    \\n        disjointset ds(n+1);\\n        for(int i=0;i<q.size();i++)q[i].push_back(i);\\n        sort(edges.begin(),edges.end(),cmp);\\n        sort(q.begin(),q.end(),cmp);\\n        int j = 0;\\n        vector<bool> ans(q.size(),false);\\n        for(int i=0;i<q.size();i++){\\n            int u = q[i][0];\\n            int v = q[i][1];\\n            int limit = q[i][2];\\n            int ind = q[i][3];\\n            for(;j<edges.size() && edges[j][2]<limit;j++){\\n                ds.make_union(edges[j][0],edges[j][1]);\\n            }\\n            ans[ind] = ds.connected(u,v);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjointset{\\n    vector<int> parent;\\n    vector<int> rank;\\n    public:\\n    disjointset(int n){\\n        parent.resize(n+1);\\n        for(int i=0;i<=n;i++)parent[i] = i;\\n        rank.resize(n+1);\\n        for(int i=0;i<=n;i++)rank[i] = 0;\\n    }\\n    int findUpar(int node){\\n        if(parent[node] == node)return node;\\n        return parent[node] = findUpar(parent[node]);\\n    }\\n    void make_union(int u,int v){\\n        int ulp_u = findUpar(u);\\n        int ulp_v = findUpar(v);\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;//connect smaller to larger \\n        }\\n        else if(rank[ulp_u] > rank[ulp_v]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else{\\n            parent[ulp_u] = ulp_v;\\n            rank[ulp_v]++;\\n        }\\n    }\\n    bool connected(int i,int j){return findUpar(i) == findUpar(j);}\\n};\\nclass Solution {\\n    static bool cmp(vector<int>&a,vector<int>&b){\\n        return a[2] < b[2];\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& q) {\\n    \\n        disjointset ds(n+1);\\n        for(int i=0;i<q.size();i++)q[i].push_back(i);\\n        sort(edges.begin(),edges.end(),cmp);\\n        sort(q.begin(),q.end(),cmp);\\n        int j = 0;\\n        vector<bool> ans(q.size(),false);\\n        for(int i=0;i<q.size();i++){\\n            int u = q[i][0];\\n            int v = q[i][1];\\n            int limit = q[i][2];\\n            int ind = q[i][3];\\n            for(;j<edges.size() && edges[j][2]<limit;j++){\\n                ds.make_union(edges[j][0],edges[j][1]);\\n            }\\n            ans[ind] = ds.connected(u,v);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467951,
                "title": "eleganto-union-find-python3-solution",
                "content": "```\\nclass Solution:\\n    \\n    def find(self, node: int, parent: List[int]) -> int:\\n        \\n        if node != parent[node]:\\n            parent[node] = self.find(parent[node], parent)\\n            \\n        return parent[node]\\n    \\n    \\n    def union(self, node1: int, node2: int, parent: List[int]) -> None:\\n        \\n        parent1 = self.find(node1, parent)\\n        parent2 = self.find(node2, parent)\\n        \\n        if parent1 < parent2:\\n            parent[parent2] = parent1\\n        else:\\n            parent[parent1] = parent2\\n    \\n    \\n    # O(len(edgeList)*log(len(edgeList)) + len(queries))*log(len(queries))) time,\\n    # O(len(queries) + O(n)) space,\\n    # Approach: union find, sorting\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        answer = [False for _ in range(len(queries))]\\n        parent = [i for i in range(n)]\\n        \\n        queries = [ (queries[i][0], queries[i][1], queries[i][2], i) for i in range(len(queries)) ]\\n        \\n        edgeList.sort(key=lambda x:x[2], reverse=True)\\n        queries.sort(key=lambda x:x[2], reverse=True)\\n        \\n\\n        while queries:\\n            p, q, curr_limit, index = queries.pop()\\n            \\n            while edgeList and edgeList[-1][2] < curr_limit:\\n                u, v, _ = edgeList.pop() \\n                self.union(u, v, parent)\\n            \\n            if self.find(p, parent) == self.find(q, parent):\\n                answer[index] = True\\n                \\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def find(self, node: int, parent: List[int]) -> int:\\n        \\n        if node != parent[node]:\\n            parent[node] = self.find(parent[node], parent)\\n            \\n        return parent[node]\\n    \\n    \\n    def union(self, node1: int, node2: int, parent: List[int]) -> None:\\n        \\n        parent1 = self.find(node1, parent)\\n        parent2 = self.find(node2, parent)\\n        \\n        if parent1 < parent2:\\n            parent[parent2] = parent1\\n        else:\\n            parent[parent1] = parent2\\n    \\n    \\n    # O(len(edgeList)*log(len(edgeList)) + len(queries))*log(len(queries))) time,\\n    # O(len(queries) + O(n)) space,\\n    # Approach: union find, sorting\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        answer = [False for _ in range(len(queries))]\\n        parent = [i for i in range(n)]\\n        \\n        queries = [ (queries[i][0], queries[i][1], queries[i][2], i) for i in range(len(queries)) ]\\n        \\n        edgeList.sort(key=lambda x:x[2], reverse=True)\\n        queries.sort(key=lambda x:x[2], reverse=True)\\n        \\n\\n        while queries:\\n            p, q, curr_limit, index = queries.pop()\\n            \\n            while edgeList and edgeList[-1][2] < curr_limit:\\n                u, v, _ = edgeList.pop() \\n                self.union(u, v, parent)\\n            \\n            if self.find(p, parent) == self.find(q, parent):\\n                answer[index] = True\\n                \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467940,
                "title": "javascript-union-find-sorting",
                "content": "I\\'m pretty happy I came up with this myself. Although it took a while.\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edgeList\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    let queriesMapIndex = new Map();\\n    for (let index = 0; index < queries.length; index += 1) {\\n        let [n1, n2, maxDist] = queries[index];\\n        if (queriesMapIndex.has(n1 + \\'-\\' + n2 + \\'-\\' + maxDist) === false) {\\n            queriesMapIndex.set(n1 + \\'-\\' + n2 + \\'-\\' + maxDist, []);\\n        }\\n        queriesMapIndex.get(n1 + \\'-\\' + n2 + \\'-\\' + maxDist).push(index);\\n    }\\n    \\n    queries.sort((a, b) => a[2] - b[2]);\\n    edgeList.sort((a, b) => a[2] - b[2]);\\n    \\n    let parent = [...Array(n).keys()];\\n    let rank = [...Array(n).fill(1)];\\n    \\n    let find = function(node) {\\n        while (node != parent[node]) {\\n            parent[node] = parent[parent[node]];\\n            node = parent[node];\\n        }\\n        return node;\\n    }\\n    \\n    let union = function(n1, n2) {\\n        let p1 = find(n1);\\n        let p2 = find(n2);\\n        \\n        if (rank[p1] > rank[p2]) {\\n            [p1, p2] = [p2, p1]; // p2 is always greater size\\n        }\\n        \\n        parent[p1] = p2;\\n        rank[p2] += 1;\\n    }\\n    \\n    let result = [...Array(queries.length)];\\n    let prevIndex = 0;\\n    for (let [n1, n2, maxDist] of queries) {\\n        for (let index = prevIndex; index < edgeList.length; index += 1) {\\n            let [node, neighbor, dist] = edgeList[index];\\n            if (dist >= maxDist) {\\n                prevIndex = index;\\n                break;\\n            }\\n            union(node, neighbor);\\n        }\\n        parent[n1] = find(n1);\\n        parent[n2] = find(n2);\\n        for (let index of queriesMapIndex.get(n1 + \\'-\\' + n2 + \\'-\\' + maxDist)) {\\n            result[index] = parent[n1] == parent[n2];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edgeList\\n * @param {number[][]} queries\\n * @return {boolean[]}\\n */\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    let queriesMapIndex = new Map();\\n    for (let index = 0; index < queries.length; index += 1) {\\n        let [n1, n2, maxDist] = queries[index];\\n        if (queriesMapIndex.has(n1 + \\'-\\' + n2 + \\'-\\' + maxDist) === false) {\\n            queriesMapIndex.set(n1 + \\'-\\' + n2 + \\'-\\' + maxDist, []);\\n        }\\n        queriesMapIndex.get(n1 + \\'-\\' + n2 + \\'-\\' + maxDist).push(index);\\n    }\\n    \\n    queries.sort((a, b) => a[2] - b[2]);\\n    edgeList.sort((a, b) => a[2] - b[2]);\\n    \\n    let parent = [...Array(n).keys()];\\n    let rank = [...Array(n).fill(1)];\\n    \\n    let find = function(node) {\\n        while (node != parent[node]) {\\n            parent[node] = parent[parent[node]];\\n            node = parent[node];\\n        }\\n        return node;\\n    }\\n    \\n    let union = function(n1, n2) {\\n        let p1 = find(n1);\\n        let p2 = find(n2);\\n        \\n        if (rank[p1] > rank[p2]) {\\n            [p1, p2] = [p2, p1]; // p2 is always greater size\\n        }\\n        \\n        parent[p1] = p2;\\n        rank[p2] += 1;\\n    }\\n    \\n    let result = [...Array(queries.length)];\\n    let prevIndex = 0;\\n    for (let [n1, n2, maxDist] of queries) {\\n        for (let index = prevIndex; index < edgeList.length; index += 1) {\\n            let [node, neighbor, dist] = edgeList[index];\\n            if (dist >= maxDist) {\\n                prevIndex = index;\\n                break;\\n            }\\n            union(node, neighbor);\\n        }\\n        parent[n1] = find(n1);\\n        parent[n2] = find(n2);\\n        for (let index of queriesMapIndex.get(n1 + \\'-\\' + n2 + \\'-\\' + maxDist)) {\\n            result[index] = parent[n1] == parent[n2];\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467917,
                "title": "javascript-union-find-implementation-beats-100-it-s-the-only-answer-in-js-lol",
                "content": "Here\\'s how we can do the union in javascript, too.\\n\\n# Code\\n```\\nlet UFind = function(n) {    \\n    this.parent = [];\\n    this.rank = [];\\n    \\n    for( var i=0; i<n; i++ ) {\\n        this.parent.push(i);\\n        this.rank.push(0);\\n    }\\n\\n    this.find = function(x) {\\n        if( this.parent[x] != x ) {\\n            this.parent[x] = this.find(this.parent[x]);\\n        }\\n        return this.parent[x];\\n    }\\n    \\n    this.union = function(x,y) {\\n        let px = this.find(x);\\n        let py = this.find(y);\\n\\n        if( px != py ) {\\n            if( this.rank[px] < this.rank[py] ) {\\n                this.parent[px] = py;\\n            } else if( this.rank[px] > this.rank[py] ) {\\n                this.parent[py] = px;\\n            } else {\\n                this.parent[py] = px;\\n                this.rank[px] ++;\\n            }\\n        }\\n    }\\n\\n    this.connected = function(x,y) {\\n        return ( this.find(x) == this.find(y) );\\n    }\\n};\\n\\n\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    var i, j, x, t;\\n    var querymap;\\n\\n    querymap=[];\\n    for( i=0; i<queries.length; i++ ) {\\n        querymap.push( [i, ...queries[i]] );\\n    }\\n    querymap.sort( (a,b) => (a[3]-b[3]) );\\n    edgeList.sort( (a,b) => (a[2]-b[2]) );\\n\\n    var Q, q, m, S, len, minlen;\\n    let results=new Array(querymap.length).fill(false), st;\\n    var lastdepth=0,di=0;\\n    var y,z, k, found;\\n\\n    let uf = new UFind(n);\\n    \\n    for( i=0; i<querymap.length; i++ ) {\\n        st = x = querymap[i][1];\\n        t = querymap[i][2];\\n        m = querymap[i][3];\\n\\n        for( ; di < edgeList.length; di++ ) {\\n            if( edgeList[di][2] >= m ) break;\\n\\n            uf.union( edgeList[di][0], edgeList[di][1] );\\n        }\\n\\n        //console.log(m + \":: \" + x + \",\" + t);\\n        //console.log(uf.parent, uf.rank);\\n\\n        results[ querymap[i][0] ] = uf.connected( x, t );\\n    }\\n    //console.log(edgeList);\\n\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet UFind = function(n) {    \\n    this.parent = [];\\n    this.rank = [];\\n    \\n    for( var i=0; i<n; i++ ) {\\n        this.parent.push(i);\\n        this.rank.push(0);\\n    }\\n\\n    this.find = function(x) {\\n        if( this.parent[x] != x ) {\\n            this.parent[x] = this.find(this.parent[x]);\\n        }\\n        return this.parent[x];\\n    }\\n    \\n    this.union = function(x,y) {\\n        let px = this.find(x);\\n        let py = this.find(y);\\n\\n        if( px != py ) {\\n            if( this.rank[px] < this.rank[py] ) {\\n                this.parent[px] = py;\\n            } else if( this.rank[px] > this.rank[py] ) {\\n                this.parent[py] = px;\\n            } else {\\n                this.parent[py] = px;\\n                this.rank[px] ++;\\n            }\\n        }\\n    }\\n\\n    this.connected = function(x,y) {\\n        return ( this.find(x) == this.find(y) );\\n    }\\n};\\n\\n\\nvar distanceLimitedPathsExist = function(n, edgeList, queries) {\\n    var i, j, x, t;\\n    var querymap;\\n\\n    querymap=[];\\n    for( i=0; i<queries.length; i++ ) {\\n        querymap.push( [i, ...queries[i]] );\\n    }\\n    querymap.sort( (a,b) => (a[3]-b[3]) );\\n    edgeList.sort( (a,b) => (a[2]-b[2]) );\\n\\n    var Q, q, m, S, len, minlen;\\n    let results=new Array(querymap.length).fill(false), st;\\n    var lastdepth=0,di=0;\\n    var y,z, k, found;\\n\\n    let uf = new UFind(n);\\n    \\n    for( i=0; i<querymap.length; i++ ) {\\n        st = x = querymap[i][1];\\n        t = querymap[i][2];\\n        m = querymap[i][3];\\n\\n        for( ; di < edgeList.length; di++ ) {\\n            if( edgeList[di][2] >= m ) break;\\n\\n            uf.union( edgeList[di][0], edgeList[di][1] );\\n        }\\n\\n        //console.log(m + \":: \" + x + \",\" + t);\\n        //console.log(uf.parent, uf.rank);\\n\\n        results[ querymap[i][0] ] = uf.connected( x, t );\\n    }\\n    //console.log(edgeList);\\n\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467887,
                "title": "union-find-dsu-implementation-w-explanation",
                "content": "# Solution\\n\\nTo record the relationship between nodes, we utilize a Union Find (DSU) in this problem. Our approach involves building the DSU from the edges with increasing distance. By doing this, we can halt at a specific point and assess whether the nodes are linked within a certain distance limit.\\n\\nWe utilize a standard DSU implementation with ranking to improve the performance. Additionally, we sort the edgeList in reverse order based on the distance. This makes it simpler to eliminate the edges with the least distance from the list. Furthermore, we sort the queries based on their limits, allowing us to handle the queries with increasing limits and expanding the DSU with viable edges.\\n\\nAfter preparing the DSU and sorting the data, we iterate through the queries, constructing the DSU, and then determine if two nodes in the query are connected at the current state of the DSU.\\n\\n# Complexity\\n`n`: the number of nodes\\n`e`: the number of edges\\n`q`: the number of queries\\n\\n- Time complexity: $$O(n+eloge+qlogq)$$\\n\\n- Space complexity: $$O(n+q)$$\\n\\n# Code\\n```\\nclass UF:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n        self.rank = [0]*n\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        if rx != ry:\\n            if self.rank[rx] > self.rank[ry]:\\n                self.root[ry] = rx\\n            elif self.rank[rx] < self.rank[ry]:\\n                self.root[rx] = ry\\n            else:\\n                self.root[ry] = rx\\n                self.rank[rx] += 1\\n    \\n    def is_connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        ans, uf = [False] * len(queries), UF(n)\\n        edgeList.sort(reverse=True, key=lambda x: x[2])\\n        query_limits = sorted([(limit, i) for i, (_, _, limit) in enumerate(queries)])\\n\\n        for limit, qi in query_limits:\\n            while edgeList and edgeList[-1][2] < limit:\\n                a, b, _ = edgeList.pop()\\n                uf.union(a, b)\\n            a, b, _ = queries[qi]\\n            ans[qi] = uf.is_connected(a, b)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n        self.rank = [0]*n\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        if rx != ry:\\n            if self.rank[rx] > self.rank[ry]:\\n                self.root[ry] = rx\\n            elif self.rank[rx] < self.rank[ry]:\\n                self.root[rx] = ry\\n            else:\\n                self.root[ry] = rx\\n                self.rank[rx] += 1\\n    \\n    def is_connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        ans, uf = [False] * len(queries), UF(n)\\n        edgeList.sort(reverse=True, key=lambda x: x[2])\\n        query_limits = sorted([(limit, i) for i, (_, _, limit) in enumerate(queries)])\\n\\n        for limit, qi in query_limits:\\n            while edgeList and edgeList[-1][2] < limit:\\n                a, b, _ = edgeList.pop()\\n                uf.union(a, b)\\n            a, b, _ = queries[qi]\\n            ans[qi] = uf.is_connected(a, b)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467851,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            if self.rank[px] < self.rank[py]:\\n                self.parent[px] = py\\n            elif self.rank[px] > self.rank[py]:\\n                self.parent[py] = px\\n            else:\\n                self.parent[py] = px\\n                self.rank[px] += 1\\n    \\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        edges = sorted(edges, key=lambda x: x[2])\\n        ans = [False] * len(queries)\\n        uf = UnionFind(n)\\n        i = 0\\n        sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][2])\\n        for q_idx, (u, v, limit) in sorted_queries:\\n            while i < len(edges) and edges[i][2] < limit:\\n                uf.union(edges[i][0], edges[i][1])\\n                i += 1\\n            ans[q_idx] = uf.connected(u, v)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [0] * n\\n    \\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            if self.rank[px] < self.rank[py]:\\n                self.parent[px] = py\\n            elif self.rank[px] > self.rank[py]:\\n                self.parent[py] = px\\n            else:\\n                self.parent[py] = px\\n                self.rank[px] += 1\\n    \\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edges: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        edges = sorted(edges, key=lambda x: x[2])\\n        ans = [False] * len(queries)\\n        uf = UnionFind(n)\\n        i = 0\\n        sorted_queries = sorted(enumerate(queries), key=lambda x: x[1][2])\\n        for q_idx, (u, v, limit) in sorted_queries:\\n            while i < len(edges) and edges[i][2] < limit:\\n                uf.union(edges[i][0], edges[i][1])\\n                i += 1\\n            ans[q_idx] = uf.connected(u, v)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467812,
                "title": "c-easy-and-clean-code-dsu-beats-no-hashmap",
                "content": "# Please Upvote if you liked my solution \\uD83E\\uDD17\\uD83E\\uDD17\\n\\n# Complexity\\n- Time complexity: $$O(ElogE + QlogQ)$$ As we are sorting `edgeList` array and `queries` array\\n`E` - size of `edgeList`\\n`Q` - size of `Queries`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N + Q)$$\\n`N` - no of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass DSU {\\n    vector<int> par, size;\\npublic:\\n    DSU(int n) {\\n        par.resize(n + 1, -1);\\n        size.resize(n + 1, 1);\\n    }\\n\\n    int findPar(int u) {\\n        return par[u] == -1 ? u : (par[u] = findPar(par[u]));\\n    }\\n\\n    bool unite(int u, int v) {\\n        u = findPar(u);\\n        v = findPar(v);\\n        if (u == v) return false;\\n        if (size[u] > size[v]) swap(u, v);\\n        par[u] = v;\\n        size[v] += size[u];\\n        return true;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& el, vector<vector<int>>& qs) {\\n        int len = qs.size();\\n        vector<bool> ans(len, 0);\\n        DSU dsu(n);\\n\\n        auto cmp = [&](vector<int>& a, vector<int>& b) {\\n            return a[2] <= b[2];\\n        };\\n\\n        auto isInSameGrp = [&](int u, int v) {\\n            return dsu.findPar(u) == dsu.findPar(v);\\n        };\\n\\n        for (int i = 0; i < len; i++) qs[i].push_back(i);\\n        sort(el.begin(), el.end(), cmp);\\n        sort(qs.begin(), qs.end(), cmp);\\n\\n        for (int i = 0, j = 0; i < len; i++) {\\n            while (j < el.size() && el[j][2] < qs[i][2]) dsu.unite(el[j][0], el[j][1]), j++;\\n            ans[qs[i][3]] = isInSameGrp(qs[i][0], qs[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n# Java Code\\n```\\nclass DSU {\\n    int par[], size[];\\n\\n    DSU(int n) {\\n        par = new int[n+1];\\n        size = new int[n+1];\\n        Arrays.fill(par, -1);\\n        Arrays.fill(size, 1);\\n    }\\n\\n    int findPar(int u) {\\n        return par[u] == -1 ? u : (par[u] = findPar(par[u]));\\n    }\\n\\n    boolean unite(int u, int v) {\\n        u = findPar(u);\\n        v = findPar(v);\\n        if (u == v) return false;\\n        if (size[u] > size[v]) u = u ^ v ^ (v = u); // swap u and v\\n        par[u] = v;\\n        size[v] += size[u];\\n        return true;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] el, int[][] qs) {\\n        int len = qs.length;\\n        boolean ans[] = new boolean[len];\\n        DSU dsu = new DSU(n);\\n\\n        Comparator<int[]> cmp = (a, b) -> a[2] - b[2];\\n        BiFunction<Integer, Integer, Boolean> isInSameGrp = (u, v) -> dsu.findPar(u) == dsu.findPar(v);\\n\\n        for (int i = 0; i < len; i++){\\n            int tmp[] = new int[4];\\n            tmp[0] = qs[i][0];\\n            tmp[1] = qs[i][1];\\n            tmp[2] = qs[i][2];\\n            tmp[3] = i;\\n            qs[i] = tmp;\\n        }\\n        Arrays.sort(el, cmp);\\n        Arrays.sort(qs, cmp);\\n\\n        for (int i = 0, j = 0; i < qs.length; i++) {\\n            while (j < el.length && el[j][2] < qs[i][2]){\\n                dsu.unite(el[j][0], el[j][1]); \\n                j++;\\n            }\\n            ans[qs[i][3]] = isInSameGrp.apply(qs[i][0], qs[i][1]);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n![upvote-img.jpg](https://assets.leetcode.com/users/images/2c0a0f1d-0a7d-47fc-90da-0ba7c06e8d5b_1682801648.4154732.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n\\nclass DSU {\\n    vector<int> par, size;\\npublic:\\n    DSU(int n) {\\n        par.resize(n + 1, -1);\\n        size.resize(n + 1, 1);\\n    }\\n\\n    int findPar(int u) {\\n        return par[u] == -1 ? u : (par[u] = findPar(par[u]));\\n    }\\n\\n    bool unite(int u, int v) {\\n        u = findPar(u);\\n        v = findPar(v);\\n        if (u == v) return false;\\n        if (size[u] > size[v]) swap(u, v);\\n        par[u] = v;\\n        size[v] += size[u];\\n        return true;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& el, vector<vector<int>>& qs) {\\n        int len = qs.size();\\n        vector<bool> ans(len, 0);\\n        DSU dsu(n);\\n\\n        auto cmp = [&](vector<int>& a, vector<int>& b) {\\n            return a[2] <= b[2];\\n        };\\n\\n        auto isInSameGrp = [&](int u, int v) {\\n            return dsu.findPar(u) == dsu.findPar(v);\\n        };\\n\\n        for (int i = 0; i < len; i++) qs[i].push_back(i);\\n        sort(el.begin(), el.end(), cmp);\\n        sort(qs.begin(), qs.end(), cmp);\\n\\n        for (int i = 0, j = 0; i < len; i++) {\\n            while (j < el.size() && el[j][2] < qs[i][2]) dsu.unite(el[j][0], el[j][1]), j++;\\n            ans[qs[i][3]] = isInSameGrp(qs[i][0], qs[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass DSU {\\n    int par[], size[];\\n\\n    DSU(int n) {\\n        par = new int[n+1];\\n        size = new int[n+1];\\n        Arrays.fill(par, -1);\\n        Arrays.fill(size, 1);\\n    }\\n\\n    int findPar(int u) {\\n        return par[u] == -1 ? u : (par[u] = findPar(par[u]));\\n    }\\n\\n    boolean unite(int u, int v) {\\n        u = findPar(u);\\n        v = findPar(v);\\n        if (u == v) return false;\\n        if (size[u] > size[v]) u = u ^ v ^ (v = u); // swap u and v\\n        par[u] = v;\\n        size[v] += size[u];\\n        return true;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] el, int[][] qs) {\\n        int len = qs.length;\\n        boolean ans[] = new boolean[len];\\n        DSU dsu = new DSU(n);\\n\\n        Comparator<int[]> cmp = (a, b) -> a[2] - b[2];\\n        BiFunction<Integer, Integer, Boolean> isInSameGrp = (u, v) -> dsu.findPar(u) == dsu.findPar(v);\\n\\n        for (int i = 0; i < len; i++){\\n            int tmp[] = new int[4];\\n            tmp[0] = qs[i][0];\\n            tmp[1] = qs[i][1];\\n            tmp[2] = qs[i][2];\\n            tmp[3] = i;\\n            qs[i] = tmp;\\n        }\\n        Arrays.sort(el, cmp);\\n        Arrays.sort(qs, cmp);\\n\\n        for (int i = 0, j = 0; i < qs.length; i++) {\\n            while (j < el.length && el[j][2] < qs[i][2]){\\n                dsu.unite(el[j][0], el[j][1]); \\n                j++;\\n            }\\n            ans[qs[i][3]] = isInSameGrp.apply(qs[i][0], qs[i][1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467805,
                "title": "golang-sorting-union-find",
                "content": "# Code\\n```\\nfunc findParent(parent []int, u int) int {\\n    if parent[u] == u {return u}\\n    parent[u] = findParent(parent, parent[u])\\n    return parent[u]\\n}\\n\\nfunc unionSet(parent []int, u, v int) {\\n    parU := findParent(parent, u)\\n    parV := findParent(parent, v)\\n    if parU == parV {return}\\n    if parU < parV {\\n        parent[parV] = parU\\n    } else {\\n        parent[parU] = parV \\n    }\\n}\\n\\nfunc iota(num []int) {\\n    for i := 0; i < len(num); i++ {\\n        num[i] = i\\n    }\\n}\\n\\nfunc distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n    index := make([]int, len(queries))\\n    sort.Slice(edgeList, func(i, j int) bool {\\n        return edgeList[i][2] < edgeList[j][2]\\n    })\\n    iota(index)\\n    sort.Slice(index, func(i, j int) bool {\\n        return queries[index[i]][2] < queries[index[j]][2]\\n    })\\n    parent := make([]int, n)\\n    iota(parent)\\n    var j int = 0\\n    ans := make([]bool, len(queries))\\n    for _, i := range index {\\n        for ; j < len(edgeList) && edgeList[j][2] < queries[i][2]; j++ {\\n            unionSet(parent, edgeList[j][0], edgeList[j][1])\\n        }\\n        ans[i] = findParent(parent, queries[i][0]) == findParent(parent, queries[i][1])\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nfunc findParent(parent []int, u int) int {\\n    if parent[u] == u {return u}\\n    parent[u] = findParent(parent, parent[u])\\n    return parent[u]\\n}\\n\\nfunc unionSet(parent []int, u, v int) {\\n    parU := findParent(parent, u)\\n    parV := findParent(parent, v)\\n    if parU == parV {return}\\n    if parU < parV {\\n        parent[parV] = parU\\n    } else {\\n        parent[parU] = parV \\n    }\\n}\\n\\nfunc iota(num []int) {\\n    for i := 0; i < len(num); i++ {\\n        num[i] = i\\n    }\\n}\\n\\nfunc distanceLimitedPathsExist(n int, edgeList [][]int, queries [][]int) []bool {\\n    index := make([]int, len(queries))\\n    sort.Slice(edgeList, func(i, j int) bool {\\n        return edgeList[i][2] < edgeList[j][2]\\n    })\\n    iota(index)\\n    sort.Slice(index, func(i, j int) bool {\\n        return queries[index[i]][2] < queries[index[j]][2]\\n    })\\n    parent := make([]int, n)\\n    iota(parent)\\n    var j int = 0\\n    ans := make([]bool, len(queries))\\n    for _, i := range index {\\n        for ; j < len(edgeList) && edgeList[j][2] < queries[i][2]; j++ {\\n            unionSet(parent, edgeList[j][0], edgeList[j][1])\\n        }\\n        ans[i] = findParent(parent, queries[i][0]) == findParent(parent, queries[i][1])\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467788,
                "title": "c-sorting-union-find",
                "content": "# Code\\n```\\nclass Solution {\\n    int findParent(vector<int> &parent, int u) {\\n        if(parent[u] == u) return u;\\n        return parent[u] = findParent(parent, parent[u]);\\n    }\\n    void unionSet(vector<int> &parent, int u, int v) {\\n        int parU = findParent(parent, u);\\n        int parV = findParent(parent, v);\\n        if(parU == parV) return;\\n        if(parU < parV) {\\n            parent[parV] = parU;\\n        }\\n        else {\\n            parent[parU] = parV; \\n        }\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<int> index(queries.size());\\n        sort(edgeList.begin(), edgeList.end(), [](auto &A, auto &B) {\\n            return A[2] < B[2];\\n        });\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int &A, int &B) {\\n            return queries[A][2] < queries[B][2];\\n        });\\n        vector<int> parent(n);\\n        iota(parent.begin(), parent.end(), 0);\\n        int j = 0;\\n        vector<bool> ans(queries.size());\\n        for(int i: index) {\\n            for(; j < edgeList.size() && edgeList[j][2] < queries[i][2]; j++) {\\n                unionSet(parent, edgeList[j][0], edgeList[j][1]);\\n            }\\n            ans[i] = findParent(parent, queries[i][0]) == findParent(parent, queries[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int findParent(vector<int> &parent, int u) {\\n        if(parent[u] == u) return u;\\n        return parent[u] = findParent(parent, parent[u]);\\n    }\\n    void unionSet(vector<int> &parent, int u, int v) {\\n        int parU = findParent(parent, u);\\n        int parV = findParent(parent, v);\\n        if(parU == parV) return;\\n        if(parU < parV) {\\n            parent[parV] = parU;\\n        }\\n        else {\\n            parent[parU] = parV; \\n        }\\n    }\\npublic:\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        vector<int> index(queries.size());\\n        sort(edgeList.begin(), edgeList.end(), [](auto &A, auto &B) {\\n            return A[2] < B[2];\\n        });\\n        iota(index.begin(), index.end(), 0);\\n        sort(index.begin(), index.end(), [&](int &A, int &B) {\\n            return queries[A][2] < queries[B][2];\\n        });\\n        vector<int> parent(n);\\n        iota(parent.begin(), parent.end(), 0);\\n        int j = 0;\\n        vector<bool> ans(queries.size());\\n        for(int i: index) {\\n            for(; j < edgeList.size() && edgeList[j][2] < queries[i][2]; j++) {\\n                unionSet(parent, edgeList[j][0], edgeList[j][1]);\\n            }\\n            ans[i] = findParent(parent, queries[i][0]) == findParent(parent, queries[i][1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467784,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    class UnionFind {\\n        private int[] group;\\n        private int[] rank;\\n        public UnionFind(int size) {\\n            rank = new int[size];\\n            group = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                group[i] = i;\\n            }\\n        }\\n\\n        public boolean areConnected(int n1, int n2) {\\n            int g1 = findGroup(n1);\\n            int g2 = findGroup(n2);\\n            return g1 == g2;\\n        }\\n\\n        public void join(int n1, int n2) {\\n            int g1 = findGroup(n1);\\n            int g2 = findGroup(n2);\\n            // if already in the same group\\n            if(g1 == g2) return;\\n\\n            if(rank[g1] > rank[g2]) group[g2] = g1;\\n            else if(rank[g2] > rank[g1]) group[g1] = g2;\\n            else {\\n                // choose one of the group and increase its rank\\n                group[g1] = g2;\\n                rank[g2]++;\\n            }\\n        }\\n\\n        private int findGroup(int n) {\\n            if(group[n] != n) {\\n                // if n has been assigned to a different group\\n                // update n to its new group\\n                group[n] = findGroup(group[n]);\\n            }\\n\\n            return group[n];\\n        }\\n    }\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        // backup query index\\n        int queryCount = queries.length;\\n        int[][] queriesWithIndex = new int[queryCount][4];\\n        for(int i = 0; i < queryCount; i++) {\\n            queriesWithIndex[i][0] = queries[i][0];\\n            queriesWithIndex[i][1] = queries[i][1];\\n            queriesWithIndex[i][2] = queries[i][2];\\n            queriesWithIndex[i][3] = i;\\n        }\\n        \\n        sort(edgeList);\\n        sort(queriesWithIndex);\\n\\n        boolean[] ans = new boolean[queryCount];\\n        int edgeIdx = 0;\\n        UnionFind uf = new UnionFind(n);\\n\\n        for(int[] query : queriesWithIndex) {\\n            int start = query[0], end = query[1], limit = query[2], originalIdx = query[3];\\n            while(edgeIdx < edgeList.length && edgeList[edgeIdx][2] < limit) {\\n                uf.join(edgeList[edgeIdx][0], edgeList[edgeIdx][1]);\\n                edgeIdx++;\\n            }\\n            ans[originalIdx] = uf.areConnected(start, end);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void sort(int[][] arr) {\\n        Arrays.sort(arr, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a1, int[] a2) {\\n                return a1[2] - a2[2];\\n            }\\n        });\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    class UnionFind {\\n        private int[] group;\\n        private int[] rank;\\n        public UnionFind(int size) {\\n            rank = new int[size];\\n            group = new int[size];\\n            for(int i = 0; i < size; i++) {\\n                group[i] = i;\\n            }\\n        }\\n\\n        public boolean areConnected(int n1, int n2) {\\n            int g1 = findGroup(n1);\\n            int g2 = findGroup(n2);\\n            return g1 == g2;\\n        }\\n\\n        public void join(int n1, int n2) {\\n            int g1 = findGroup(n1);\\n            int g2 = findGroup(n2);\\n            // if already in the same group\\n            if(g1 == g2) return;\\n\\n            if(rank[g1] > rank[g2]) group[g2] = g1;\\n            else if(rank[g2] > rank[g1]) group[g1] = g2;\\n            else {\\n                // choose one of the group and increase its rank\\n                group[g1] = g2;\\n                rank[g2]++;\\n            }\\n        }\\n\\n        private int findGroup(int n) {\\n            if(group[n] != n) {\\n                // if n has been assigned to a different group\\n                // update n to its new group\\n                group[n] = findGroup(group[n]);\\n            }\\n\\n            return group[n];\\n        }\\n    }\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        // backup query index\\n        int queryCount = queries.length;\\n        int[][] queriesWithIndex = new int[queryCount][4];\\n        for(int i = 0; i < queryCount; i++) {\\n            queriesWithIndex[i][0] = queries[i][0];\\n            queriesWithIndex[i][1] = queries[i][1];\\n            queriesWithIndex[i][2] = queries[i][2];\\n            queriesWithIndex[i][3] = i;\\n        }\\n        \\n        sort(edgeList);\\n        sort(queriesWithIndex);\\n\\n        boolean[] ans = new boolean[queryCount];\\n        int edgeIdx = 0;\\n        UnionFind uf = new UnionFind(n);\\n\\n        for(int[] query : queriesWithIndex) {\\n            int start = query[0], end = query[1], limit = query[2], originalIdx = query[3];\\n            while(edgeIdx < edgeList.length && edgeList[edgeIdx][2] < limit) {\\n                uf.join(edgeList[edgeIdx][0], edgeList[edgeIdx][1]);\\n                edgeIdx++;\\n            }\\n            ans[originalIdx] = uf.areConnected(start, end);\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void sort(int[][] arr) {\\n        Arrays.sort(arr, new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] a1, int[] a2) {\\n                return a1[2] - a2[2];\\n            }\\n        });\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467763,
                "title": "kotlin-union-find",
                "content": "# Approach\\nWe will use a (deconstructed, no separated class) Union-Find. Add index to each element in `queries`, and sort by distance. Also, sort `edgeList` by distance.\\n\\nWe then traverse queries from lowest weight to highest, and connect all edges that are strictly less than limit. Set `res[i]` where i is the current query we are looking at, to true if we can reach v from u. We know if we can reach if they have the same parent, we can check with `find()`.\\n\\n# Code\\n```\\nclass Solution {\\n    fun distanceLimitedPathsExist(n: Int, edgeList: Array<IntArray>, _queries: Array<IntArray>): BooleanArray {\\n        val parent = IntArray(n) {it}\\n\\n        fun find(x: Int): Int {\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        }\\n\\n        fun union(x: Int, y: Int) {\\n            val pX = find(x)\\n            val pY = find(y)\\n            if (pX != pY)\\n                parent[pY] = pX\\n        }\\n\\n        edgeList.sortBy {it[2]}\\n\\n        val queries = _queries.mapIndexed {\\n            i, q -> intArrayOf(q[0], q[1], q[2], i)\\n        }.toTypedArray()\\n        queries.sortBy {it[2]}\\n\\n        val res = BooleanArray(queries.size)\\n\\n        var i = 0\\n        for ((u, v, l, j) in queries) {\\n            while (i < edgeList.size && edgeList[i][2] < l) {\\n                union(edgeList[i][0], edgeList[i][1])\\n                i += 1\\n            }\\n\\n            res[j] = find(u) == find(v)\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    fun distanceLimitedPathsExist(n: Int, edgeList: Array<IntArray>, _queries: Array<IntArray>): BooleanArray {\\n        val parent = IntArray(n) {it}\\n\\n        fun find(x: Int): Int {\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        }\\n\\n        fun union(x: Int, y: Int) {\\n            val pX = find(x)\\n            val pY = find(y)\\n            if (pX != pY)\\n                parent[pY] = pX\\n        }\\n\\n        edgeList.sortBy {it[2]}\\n\\n        val queries = _queries.mapIndexed {\\n            i, q -> intArrayOf(q[0], q[1], q[2], i)\\n        }.toTypedArray()\\n        queries.sortBy {it[2]}\\n\\n        val res = BooleanArray(queries.size)\\n\\n        var i = 0\\n        for ((u, v, l, j) in queries) {\\n            while (i < edgeList.size && edgeList[i][2] < l) {\\n                union(edgeList[i][0], edgeList[i][1])\\n                i += 1\\n            }\\n\\n            res[j] = find(u) == find(v)\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467756,
                "title": "query-pre-processing-connectivity-check-via-union-find",
                "content": "# Intuition\\nFirst thought might be to use a graph traversal algorithm finding *max edge len* paths between nodes. However, the constraints of 10^5 nodes, edges, and queries makes this unfeasible. For these types of constraints **we need an O(n*log n) algorithm. Which means we can do sorting and union-find**.\\n\\nThe next insight is **when we process a query with the max len of K we only need to look at edges of len < K**. If there\\'s a path between two nodes using only such edges then this path has a max edge len < K.\\n\\n# Approach\\n\\n1. Order all edges by their length;\\n2. Order all queries by their max length. Make sure to record the original index of the query.\\n3. Create an empty union-find for `n` vertices.\\n4. Process queries in the order of increasing max len from step 2. For query (`from`, `to`, `maxLen`, `idx`):\\n    a. Use all edges with len < `maxLen` to connect their respective nodes in the union-find data structure.\\n    b. Use union-find to check if `from` and `to` belong to the same group. If they do, then there exists a path in the original graph with edges of length < `maxLen`.\\n    c. Use the result from step b. to record an answer to query `idx`.\\n\\n# Complexity\\n- Time complexity: O(n * log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static record Q(int from, int to, int len, int idx) {}\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]); // sort edges by the distance\\n        Q[] qs = new Q[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            qs[i] = new Q(queries[i][0], queries[i][1], queries[i][2], i);\\n        }\\n        // sort queries by the max len\\n        Arrays.sort(qs, (a, b) -> a.len - b.len);\\n\\n        boolean[] result = new boolean[queries.length];\\n        var uf = new UnionFind(n);\\n        int nextEdge = 0;\\n\\n        for (int i = 0; i < qs.length; i++) {\\n            var q = qs[i];\\n\\n            // add all edges with len < q.len to see which nodes are connectible\\n            // with a path with only edges of len < q.len\\n            while (nextEdge < edgeList.length && edgeList[nextEdge][2] < q.len) {\\n                uf.union(edgeList[nextEdge][0], edgeList[nextEdge][1], edgeList[nextEdge][2]);\\n                nextEdge++;\\n            }\\n\\n            int r1 = uf.findRepr(q.from);\\n            int r2 = uf.findRepr(q.to);\\n\\n            result[q.idx] = r1 == r2;\\n        }\\n\\n        return result;\\n    }\\n\\n    static class UnionFind {\\n        private final int size;\\n        private final int[] groupRepr;\\n        private final int[] groupSize;\\n\\n        public UnionFind(int size) {\\n            this.size = size;\\n            groupRepr = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                groupRepr[i] = i;\\n            }\\n            groupSize = new int[size];\\n            Arrays.fill(groupSize, 1);\\n        }\\n\\n        public int findRepr(int node) {\\n            while (groupRepr[node] != node) {\\n                node = groupRepr[node];\\n            }\\n            return node;\\n        }\\n\\n        public void union(int n1, int n2, int len) {\\n            int n1g = findRepr(n1);\\n            int n2g = findRepr(n2);\\n            if (n1g == n2g) {\\n                return;\\n            }\\n\\n            int smallerG = groupSize[n1g] < groupSize[n1g] ? n1g : n2g;\\n            int largerG = groupSize[n1g] < groupSize[n1g] ? n2g : n1g;\\n\\n            groupRepr[smallerG] = largerG;\\n            groupSize[largerG] += groupSize[smallerG];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static record Q(int from, int to, int len, int idx) {}\\n\\n    public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n        Arrays.sort(edgeList, (a, b) -> a[2] - b[2]); // sort edges by the distance\\n        Q[] qs = new Q[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            qs[i] = new Q(queries[i][0], queries[i][1], queries[i][2], i);\\n        }\\n        // sort queries by the max len\\n        Arrays.sort(qs, (a, b) -> a.len - b.len);\\n\\n        boolean[] result = new boolean[queries.length];\\n        var uf = new UnionFind(n);\\n        int nextEdge = 0;\\n\\n        for (int i = 0; i < qs.length; i++) {\\n            var q = qs[i];\\n\\n            // add all edges with len < q.len to see which nodes are connectible\\n            // with a path with only edges of len < q.len\\n            while (nextEdge < edgeList.length && edgeList[nextEdge][2] < q.len) {\\n                uf.union(edgeList[nextEdge][0], edgeList[nextEdge][1], edgeList[nextEdge][2]);\\n                nextEdge++;\\n            }\\n\\n            int r1 = uf.findRepr(q.from);\\n            int r2 = uf.findRepr(q.to);\\n\\n            result[q.idx] = r1 == r2;\\n        }\\n\\n        return result;\\n    }\\n\\n    static class UnionFind {\\n        private final int size;\\n        private final int[] groupRepr;\\n        private final int[] groupSize;\\n\\n        public UnionFind(int size) {\\n            this.size = size;\\n            groupRepr = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                groupRepr[i] = i;\\n            }\\n            groupSize = new int[size];\\n            Arrays.fill(groupSize, 1);\\n        }\\n\\n        public int findRepr(int node) {\\n            while (groupRepr[node] != node) {\\n                node = groupRepr[node];\\n            }\\n            return node;\\n        }\\n\\n        public void union(int n1, int n2, int len) {\\n            int n1g = findRepr(n1);\\n            int n2g = findRepr(n2);\\n            if (n1g == n2g) {\\n                return;\\n            }\\n\\n            int smallerG = groupSize[n1g] < groupSize[n1g] ? n1g : n2g;\\n            int largerG = groupSize[n1g] < groupSize[n1g] ? n2g : n1g;\\n\\n            groupRepr[smallerG] = largerG;\\n            groupSize[largerG] += groupSize[smallerG];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467731,
                "title": "dsu-clean-code-for-the-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    int find(int v,vector<int>&parent){\\n        if(v==parent[v]){\\n            return v;\\n        }\\n\\n        return parent[v]=find(parent[v],parent);\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n,vector<vector<int>>&edge,vector<vector<int>>& q) {\\n        \\n        vector<int>parent(n,-1);\\n\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n\\n\\n        vector<bool>res(q.size(),false);\\n\\n        for(int i=0;i<edge.size();i++){\\n            swap(edge[i][0],edge[i][2]);   // edge[i][2] this wt and edge[i][0] this is u\\n        }\\n\\n        sort(edge.begin(),edge.end());\\n\\n        vector<pair<int,int>>v;\\n\\n        \\n        for(int i=0;i<q.size();i++){\\n            v.push_back({q[i][2],i});\\n        }\\n\\n\\n        sort(v.begin(),v.end());\\n\\n\\n        int ptr=0;\\n\\n        for(int i=0;i<v.size();i++){\\n\\n            while(ptr<edge.size() and edge[ptr][0]<v[i].first){\\n\\n                int u=edge[ptr][1];\\n                int v=edge[ptr][2];\\n\\n                int parent_u=find(u,parent);\\n                int parent_v=find(v,parent);\\n\\n                if(parent_u!=parent_v){\\n                    parent[parent_u]=parent_v;\\n                }\\n\\n                ptr++;\\n\\n            }\\n\\n            int x=q[v[i].second][0];\\n            int y=q[v[i].second][1];\\n\\n            int px=find(x,parent);\\n            int py=find(y,parent);\\n\\n            if(px==py){\\n\\n                res[v[i].second]=true;\\n            }\\n        }\\n\\n\\n     return res;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    int find(int v,vector<int>&parent){\\n        if(v==parent[v]){\\n            return v;\\n        }\\n\\n        return parent[v]=find(parent[v],parent);\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n,vector<vector<int>>&edge,vector<vector<int>>& q) {\\n        \\n        vector<int>parent(n,-1);\\n\\n        for(int i=0;i<n;i++){\\n            parent[i]=i;\\n        }\\n\\n\\n        vector<bool>res(q.size(),false);\\n\\n        for(int i=0;i<edge.size();i++){\\n            swap(edge[i][0],edge[i][2]);   // edge[i][2] this wt and edge[i][0] this is u\\n        }\\n\\n        sort(edge.begin(),edge.end());\\n\\n        vector<pair<int,int>>v;\\n\\n        \\n        for(int i=0;i<q.size();i++){\\n            v.push_back({q[i][2],i});\\n        }\\n\\n\\n        sort(v.begin(),v.end());\\n\\n\\n        int ptr=0;\\n\\n        for(int i=0;i<v.size();i++){\\n\\n            while(ptr<edge.size() and edge[ptr][0]<v[i].first){\\n\\n                int u=edge[ptr][1];\\n                int v=edge[ptr][2];\\n\\n                int parent_u=find(u,parent);\\n                int parent_v=find(v,parent);\\n\\n                if(parent_u!=parent_v){\\n                    parent[parent_u]=parent_v;\\n                }\\n\\n                ptr++;\\n\\n            }\\n\\n            int x=q[v[i].second][0];\\n            int y=q[v[i].second][1];\\n\\n            int px=find(x,parent);\\n            int py=find(y,parent);\\n\\n            if(px==py){\\n\\n                res[v[i].second]=true;\\n            }\\n        }\\n\\n\\n     return res;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467718,
                "title": "rust-with-union-find",
                "content": "Had to read and think about the 6 hints for hours, before finally figuring it out... This is very hard.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn distance_limited_paths_exist(n: i32, mut edge_list: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let n = n as usize;\\n        let mut parent: Vec<usize> = (0..n).collect();\\n        let mut size = vec![0; n];\\n        let mut ans = vec![false; queries.len()];\\n\\n        let mut q_indices: Vec<usize> = (0..queries.len()).collect();\\n        q_indices.sort_unstable_by_key(|&i| queries[i][2]);\\n        edge_list.sort_unstable_by_key(|edge| edge[2]);\\n        edge_list.push(vec![0, 0, i32::MAX]);\\n        let mut i = 0;\\n        for edge in edge_list.iter() {\\n            while i < queries.len() {\\n                let q_i = q_indices[i];\\n                if queries[q_i][2] > edge[2] {\\n                    break;\\n                }\\n                let p_root = Self::find_set(queries[q_i][0] as usize, &mut parent);\\n                let q_root = Self::find_set(queries[q_i][1] as usize, &mut parent);\\n                if p_root == q_root && queries[q_i][2] > size[p_root] {\\n                    ans[q_i] = true;\\n                }\\n                i += 1;\\n            }\\n            \\n            if i == queries.len() {\\n                break;\\n            }\\n\\n            let mut u_root = Self::find_set(edge[0] as usize, &mut parent);\\n            let mut v_root = Self::find_set(edge[1] as usize, &mut parent);\\n            if u_root != v_root {\\n                if u_root > v_root {\\n                    std::mem::swap(&mut u_root, &mut v_root);\\n                }\\n                parent[v_root] = u_root;\\n                size[u_root] = edge[2];\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn find_set(i: usize, parent: &mut Vec<usize>) -> usize {\\n        if parent[i] != i {\\n            parent[i] = Self::find_set(parent[i], parent);\\n        }\\n        parent[i]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distance_limited_paths_exist(n: i32, mut edge_list: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let n = n as usize;\\n        let mut parent: Vec<usize> = (0..n).collect();\\n        let mut size = vec![0; n];\\n        let mut ans = vec![false; queries.len()];\\n\\n        let mut q_indices: Vec<usize> = (0..queries.len()).collect();\\n        q_indices.sort_unstable_by_key(|&i| queries[i][2]);\\n        edge_list.sort_unstable_by_key(|edge| edge[2]);\\n        edge_list.push(vec![0, 0, i32::MAX]);\\n        let mut i = 0;\\n        for edge in edge_list.iter() {\\n            while i < queries.len() {\\n                let q_i = q_indices[i];\\n                if queries[q_i][2] > edge[2] {\\n                    break;\\n                }\\n                let p_root = Self::find_set(queries[q_i][0] as usize, &mut parent);\\n                let q_root = Self::find_set(queries[q_i][1] as usize, &mut parent);\\n                if p_root == q_root && queries[q_i][2] > size[p_root] {\\n                    ans[q_i] = true;\\n                }\\n                i += 1;\\n            }\\n            \\n            if i == queries.len() {\\n                break;\\n            }\\n\\n            let mut u_root = Self::find_set(edge[0] as usize, &mut parent);\\n            let mut v_root = Self::find_set(edge[1] as usize, &mut parent);\\n            if u_root != v_root {\\n                if u_root > v_root {\\n                    std::mem::swap(&mut u_root, &mut v_root);\\n                }\\n                parent[v_root] = u_root;\\n                size[u_root] = edge[2];\\n            }\\n        }\\n        ans\\n    }\\n\\n    fn find_set(i: usize, parent: &mut Vec<usize>) -> usize {\\n        if parent[i] != i {\\n            parent[i] = Self::find_set(parent[i], parent);\\n        }\\n        parent[i]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467707,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        // union find\\n            // sort both edgeList and queries in increasing order of dist and limit, respectively\\n                // two loops:\\n                    // outer loop: for each query, if limit increases, than check to see if there is more edges that\\n                        // can be added\\n                            // inner loop: if dis is less than the new limit, add the edge\\n\\n                                // Runtime is bound by sorting: O(ElogE + NlogN + N + E);\\n                                    int[] up;\\n                                        \\n                                            public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n                                                    up = new int[n];\\n                                                            Arrays.fill(up, -1);\\n                                                                    \\n                                                                            boolean[] res = new boolean[queries.length];\\n                                                                                    Arrays.sort(edgeList, new arrComparator());\\n                                                                                            \\n                                                                                                    \\n                                                                                                            int[][] temp = new int[queries.length][4];\\n                                                                                                                    for (int i = 0; i < temp.length; i++) {\\n                                                                                                                                temp[i][0] = queries[i][0];\\n                                                                                                                                            temp[i][1] = queries[i][1];\\n                                                                                                                                                        temp[i][2] = queries[i][2];\\n                                                                                                                                                                    temp[i][3] = i;\\n                                                                                                                                                                            }\\n                                                                                                                                                                                    queries = temp;\\n                                                                                                                                                                                            Arrays.sort(queries, new arrComparator());\\n                                                                                                                                                                                                    \\n                                                                                                                                                                                                            int limit = 0;\\n                                                                                                                                                                                                                    int j = 0;\\n                                                                                                                                                                                                                            for (int i = 0; i < queries.length; i++) {\\n                                                                                                                                                                                                                                        int[] q = queries[i];\\n                                                                                                                                                                                                                                                    if (q[2] > limit) {\\n                                                                                                                                                                                                                                                                    limit = q[2];\\n                                                                                                                                                                                                                                                                                    while (j < edgeList.length && edgeList[j][2] < limit) {\\n                                                                                                                                                                                                                                                                                                        int x = edgeList[j][0];\\n                                                                                                                                                                                                                                                                                                                            int y = edgeList[j][1];\\n                                                                                                                                                                                                                                                                                                                                                if (find(x) != find(y)) union(find(x), find(y));\\n                                                                                                                                                                                                                                                                                                                                                                    j++;\\n                                                                                                                                                                                                                                                                                                                                                                                    }\\n                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                            res[q[3]] = find(q[0]) == find(q[1]);\\n                                                                                                                                                                                                                                                                                                                                                                                                                    }\\n                                                                                                                                                                                                                                                                                                                                                                                                                            return res;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                        private int find(int x) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                int r = x;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        while (up[r] >= 0) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                    r = up[r];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (r == x) return r;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            int p = up[x];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    while (p >= 0) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                up[x] = r;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            x = p;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        p = up[x];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        return r;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    private void union(int x, int y) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (up[x] > up[y]) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        up[y] += up[x];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    up[x] = y;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } else {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        up[x] += up[y];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    up[y] = x;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        class arrComparator implements Comparator<int[]> {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                public int compare(int[] a, int[] b) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            return a[2] - b[2];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    } \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }\\n                                                                                                                                                                                              \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        // union find\\n            // sort both edgeList and queries in increasing order of dist and limit, respectively\\n                // two loops:\\n                    // outer loop: for each query, if limit increases, than check to see if there is more edges that\\n                        // can be added\\n                            // inner loop: if dis is less than the new limit, add the edge\\n\\n                                // Runtime is bound by sorting: O(ElogE + NlogN + N + E);\\n                                    int[] up;\\n                                        \\n                                            public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n                                                    up = new int[n];\\n                                                            Arrays.fill(up, -1);\\n                                                                    \\n                                                                            boolean[] res = new boolean[queries.length];\\n                                                                                    Arrays.sort(edgeList, new arrComparator());\\n                                                                                            \\n                                                                                                    \\n                                                                                                            int[][] temp = new int[queries.length][4];\\n                                                                                                                    for (int i = 0; i < temp.length; i++) {\\n                                                                                                                                temp[i][0] = queries[i][0];\\n                                                                                                                                            temp[i][1] = queries[i][1];\\n                                                                                                                                                        temp[i][2] = queries[i][2];\\n                                                                                                                                                                    temp[i][3] = i;\\n                                                                                                                                                                            }\\n                                                                                                                                                                                    queries = temp;\\n                                                                                                                                                                                            Arrays.sort(queries, new arrComparator());\\n                                                                                                                                                                                                    \\n                                                                                                                                                                                                            int limit = 0;\\n                                                                                                                                                                                                                    int j = 0;\\n                                                                                                                                                                                                                            for (int i = 0; i < queries.length; i++) {\\n                                                                                                                                                                                                                                        int[] q = queries[i];\\n                                                                                                                                                                                                                                                    if (q[2] > limit) {\\n                                                                                                                                                                                                                                                                    limit = q[2];\\n                                                                                                                                                                                                                                                                                    while (j < edgeList.length && edgeList[j][2] < limit) {\\n                                                                                                                                                                                                                                                                                                        int x = edgeList[j][0];\\n                                                                                                                                                                                                                                                                                                                            int y = edgeList[j][1];\\n                                                                                                                                                                                                                                                                                                                                                if (find(x) != find(y)) union(find(x), find(y));\\n                                                                                                                                                                                                                                                                                                                                                                    j++;\\n                                                                                                                                                                                                                                                                                                                                                                                    }\\n                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                            res[q[3]] = find(q[0]) == find(q[1]);\\n                                                                                                                                                                                                                                                                                                                                                                                                                    }\\n                                                                                                                                                                                                                                                                                                                                                                                                                            return res;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                        private int find(int x) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                int r = x;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        while (up[r] >= 0) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                    r = up[r];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (r == x) return r;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            int p = up[x];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    while (p >= 0) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                up[x] = r;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            x = p;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        p = up[x];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        return r;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    private void union(int x, int y) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (up[x] > up[y]) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        up[y] += up[x];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    up[x] = y;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            } else {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        up[x] += up[y];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    up[y] = x;\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        class arrComparator implements Comparator<int[]> {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                public int compare(int[] a, int[] b) {\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            return a[2] - b[2];\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    } \\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }\\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }\\n                                                                                                                                                                                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467706,
                "title": "time-o-nlog-n-qlog-q-o-n-log-n-q-log-q-o-nlogn-qlogq",
                "content": "//Time: O(nlog\\u2061n+qlog\\u2061q)\\n//O(n\\\\log n + q\\\\log q)\\n//O(nlogn+qlogq)\\n//Space: (n+q)(n + q)(n+q)\\n\\n\\nclass UnionFind {\\n  public UnionFind(int n) {\\n    id = new int[n];\\n    rank = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n  public void unionByRank(int u, int v) {\\n    final int i = find(u);\\n    final int j = find(v);\\n    if (i == j)\\n      return;\\n    if (rank[i] < rank[j]) {\\n      id[i] = id[j];\\n    } else if (rank[i] > rank[j]) {\\n      id[j] = id[i];\\n    } else {\\n      id[i] = id[j];\\n      ++rank[j];\\n    }\\n  }\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n  private int[] id;\\n  private int[] rank;\\n}\\nclass Solution {\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    boolean[] ans = new boolean[queries.length];\\n    int[][] qs = new int[queries.length][4];\\n    UnionFind uf = new UnionFind(n);\\n    for (int i = 0; i < queries.length; ++i) {\\n      qs[i][0] = queries[i][0];\\n      qs[i][1] = queries[i][1];\\n      qs[i][2] = queries[i][2];\\n      qs[i][3] = i;\\n    }\\n    Arrays.sort(qs, (a, b) -> a[2] - b[2]);\\n    Arrays.sort(edgeList, (a, b) -> a[2] - b[2]);\\n    int i = 0; // i := edgeList\\'s index\\n    for (int[] q : qs) {\\n      // Union edges whose distances < limit (q[2])\\n      while (i < edgeList.length && edgeList[i][2] < q[2])\\n        uf.unionByRank(edgeList[i][0], edgeList[i++][1]);\\n      if (uf.find(q[0]) == uf.find(q[1]))\\n        ans[q[3]] = true;\\n    }\\n    return ans;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Union Find",
                    "Sorting"
                ],
                "code": "class Solution {\\n  public boolean[] distanceLimitedPathsExist(int n, int[][] edgeList, int[][] queries) {\\n    boolean[] ans = new boolean[queries.length];\\n    int[][] qs = new int[queries.length][4];\\n    UnionFind uf = new UnionFind(n);\\n    for (int i = 0; i < queries.length; ++i) {\\n      qs[i][0] = queries[i][0];\\n      qs[i][1] = queries[i][1];\\n      qs[i][2] = queries[i][2];\\n      qs[i][3] = i;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3467694,
                "title": "rust-unionfind",
                "content": "\\n# Code\\n```\\nimpl Solution {\\n    pub fn distance_limited_paths_exist(n: i32, mut edge_list: Vec<Vec<i32>>, mut queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let qlen = queries.len();\\n        let mut uf = UnionFind::new(n as usize);\\n        let mut answer = vec![false; qlen];\\n\\n        for i in 0..qlen {\\n            queries[i].push(i as i32);\\n        }\\n\\n        edge_list.sort_by(|a, b| a[2].cmp(&b[2]));\\n        queries.sort_by(|a, b| a[2].cmp(&b[2]));\\n\\n        let mut edge_index = 0;\\n        for i in 0..qlen {\\n            let (p, q, limit, original_index) = (queries[i][0], queries[i][1], queries[i][2], queries[i][3]);\\n\\n            while edge_index < edge_list.len() && edge_list[edge_index][2] < limit {\\n                let (node1, node2) = (edge_list[edge_index][0], edge_list[edge_index][1]);\\n                uf.set(node1 as usize, node2 as usize);\\n                edge_index += 1;\\n            }\\n\\n            answer[original_index as usize] = uf.connected(p as usize, q as usize);\\n        }\\n\\n        answer\\n    }\\n}\\n\\nstruct UnionFind {\\n    group: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n    fn new(len: usize) -> Self {\\n        Self {\\n            group: (0..len).collect()\\n        }\\n    }\\n\\n    fn find(&mut self, i: usize) -> usize {\\n        if self.group[i] != i {\\n            self.group[i] = self.find(self.group[i]);\\n        }\\n\\n        self.group[i]\\n    }\\n\\n    fn set(&mut self, i: usize, j: usize) {\\n        let g1 = self.find(i);\\n        let g2 = self.find(j);\\n        self.group[g1] = self.group[g2];\\n    }\\n\\n    fn connected(&mut self, i: usize, j: usize) -> bool {\\n        self.find(i) == self.find(j)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn distance_limited_paths_exist(n: i32, mut edge_list: Vec<Vec<i32>>, mut queries: Vec<Vec<i32>>) -> Vec<bool> {\\n        let qlen = queries.len();\\n        let mut uf = UnionFind::new(n as usize);\\n        let mut answer = vec![false; qlen];\\n\\n        for i in 0..qlen {\\n            queries[i].push(i as i32);\\n        }\\n\\n        edge_list.sort_by(|a, b| a[2].cmp(&b[2]));\\n        queries.sort_by(|a, b| a[2].cmp(&b[2]));\\n\\n        let mut edge_index = 0;\\n        for i in 0..qlen {\\n            let (p, q, limit, original_index) = (queries[i][0], queries[i][1], queries[i][2], queries[i][3]);\\n\\n            while edge_index < edge_list.len() && edge_list[edge_index][2] < limit {\\n                let (node1, node2) = (edge_list[edge_index][0], edge_list[edge_index][1]);\\n                uf.set(node1 as usize, node2 as usize);\\n                edge_index += 1;\\n            }\\n\\n            answer[original_index as usize] = uf.connected(p as usize, q as usize);\\n        }\\n\\n        answer\\n    }\\n}\\n\\nstruct UnionFind {\\n    group: Vec<usize>,\\n}\\n\\nimpl UnionFind {\\n    fn new(len: usize) -> Self {\\n        Self {\\n            group: (0..len).collect()\\n        }\\n    }\\n\\n    fn find(&mut self, i: usize) -> usize {\\n        if self.group[i] != i {\\n            self.group[i] = self.find(self.group[i]);\\n        }\\n\\n        self.group[i]\\n    }\\n\\n    fn set(&mut self, i: usize, j: usize) {\\n        let g1 = self.find(i);\\n        let g2 = self.find(j);\\n        self.group[g1] = self.group[g2];\\n    }\\n\\n    fn connected(&mut self, i: usize, j: usize) -> bool {\\n        self.find(i) == self.find(j)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3467656,
                "title": "proper-explaination-c-disjoint-set-union",
                "content": "Explaination:\\n```\\n\\t/*\\n    Advantage of using DisjointSet: It gives access to check if two nodes exists in graph or\\n                                    same component by checking its ultimate parent in O(1) time.\\n\\n\\n    WHY CAN\\'T WE USE DFS OR BFS HERE TO CHECK EDGE WEIGHT FOR EVERY NODE\\n        but are using DisjointSet Union...   \\n    \\n    As, it will give TLE for calling DFS/BFS for every Query.\\n    \\n    So, instead of checking for every node,\\n    \\n    \\n    \\n    \\n    \\n    Solution 1:  Simple DFS again and again  (TLE)\\n     \\n     time:   O(N+E) * O(N+E) = O(N^2)\\n    \\n    1.) Pick first query, call DFS and check every edge till destination if it has\\n        dist > limit.\\n    2.) Do same for all queries.\\n    \\n    \\n    \\n    OPTIMISED APPROACH:\\n    \\n    Intuition: Jo edges ka distance kamm hai unko hi pehle tackle kro aur increasing order\\n                me aise hi chlte chlo.\\n    \\n    1.) To maintain order in final answer, Add original index to the every query coz \\n        in next step we are going to sort.\\n    \\n    2.) First sort all queries in increasing order of Distance to evaluate \\n        nodes having smaller distance first.\\n        \\n    3.) Take first query, pick distance from it, (union all the nodes)/ (Connect all nodes)\\n        / (make graph for all nodes) having distance smaller than its limit \\n        After union, just check if(both nodes exists) answer for that query is true.\\n    \\n    This will save your time and u can check existence of two nodes in O(1) time.\\n*/\\n```\\n\\n\\n\\n.\\n.\\n.\\n.\\nCode:\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        \\n        // Step 1: Add original index to the every query, so that the order in final\\n        //         answer can be maintained.\\n        for(int i=0; i < queries.size(); i++)\\n            queries[i].push_back(i);\\n        \\n        // Step 2: sort queries in increasing order according to the distance.\\n        // sorting every row of matrix.\\n        sort(queries.begin(), queries.end(), cmp);\\n        \\n        // Step 3: Take a query, pick its limitDist, and start making graph by disjointSetUnion\\n        // till we are getting edges with (wt < limitDist).\\n        // The check for the existence of required edges.\\n        \\n        \\n        // to get edges having smaller distance first.\\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        int i = 0;\\n        DisjointSet ds(n);\\n        vector<bool> ans(queries.size(), false);\\n        \\n        for(auto q: queries) {\\n            int reqU = q[0];\\n            int reqV = q[1];\\n            int limit = q[2];\\n            int original_index = q[3];\\n            \\n            while(i < edges.size() && edges[i][2] < limit) {\\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n                \\n                ds.unionByRank(u, v);\\n                i++;\\n            }\\n            \\n            if(ds.findUPar(reqU) == ds.findUPar(reqV))\\n                ans[original_index] = true;\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n   \\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n       \\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n       \\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n       \\n        if (ulp_u == ulp_v)\\n            return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n       \\n        if (ulp_u == ulp_v)\\n            return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\n\\t/*\\n    Advantage of using DisjointSet: It gives access to check if two nodes exists in graph or\\n                                    same component by checking its ultimate parent in O(1) time.\\n\\n\\n    WHY CAN\\'T WE USE DFS OR BFS HERE TO CHECK EDGE WEIGHT FOR EVERY NODE\\n        but are using DisjointSet Union...   \\n    \\n    As, it will give TLE for calling DFS/BFS for every Query.\\n    \\n    So, instead of checking for every node,\\n    \\n    \\n    \\n    \\n    \\n    Solution 1:  Simple DFS again and again  (TLE)\\n     \\n     time:   O(N+E) * O(N+E) = O(N^2)\\n    \\n    1.) Pick first query, call DFS and check every edge till destination if it has\\n        dist > limit.\\n    2.) Do same for all queries.\\n    \\n    \\n    \\n    OPTIMISED APPROACH:\\n    \\n    Intuition: Jo edges ka distance kamm hai unko hi pehle tackle kro aur increasing order\\n                me aise hi chlte chlo.\\n    \\n    1.) To maintain order in final answer, Add original index to the every query coz \\n        in next step we are going to sort.\\n    \\n    2.) First sort all queries in increasing order of Distance to evaluate \\n        nodes having smaller distance first.\\n        \\n    3.) Take first query, pick distance from it, (union all the nodes)/ (Connect all nodes)\\n        / (make graph for all nodes) having distance smaller than its limit \\n        After union, just check if(both nodes exists) answer for that query is true.\\n    \\n    This will save your time and u can check existence of two nodes in O(1) time.\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &a, vector<int> &b) {\\n        return a[2] < b[2];\\n    }\\n    \\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edges, vector<vector<int>>& queries) {\\n        \\n        // Step 1: Add original index to the every query, so that the order in final\\n        //         answer can be maintained.\\n        for(int i=0; i < queries.size(); i++)\\n            queries[i].push_back(i);\\n        \\n        // Step 2: sort queries in increasing order according to the distance.\\n        // sorting every row of matrix.\\n        sort(queries.begin(), queries.end(), cmp);\\n        \\n        // Step 3: Take a query, pick its limitDist, and start making graph by disjointSetUnion\\n        // till we are getting edges with (wt < limitDist).\\n        // The check for the existence of required edges.\\n        \\n        \\n        // to get edges having smaller distance first.\\n        sort(edges.begin(), edges.end(), cmp);\\n        \\n        int i = 0;\\n        DisjointSet ds(n);\\n        vector<bool> ans(queries.size(), false);\\n        \\n        for(auto q: queries) {\\n            int reqU = q[0];\\n            int reqV = q[1];\\n            int limit = q[2];\\n            int original_index = q[3];\\n            \\n            while(i < edges.size() && edges[i][2] < limit) {\\n                int u = edges[i][0];\\n                int v = edges[i][1];\\n                \\n                ds.unionByRank(u, v);\\n                i++;\\n            }\\n            \\n            if(ds.findUPar(reqU) == ds.findUPar(reqV))\\n                ans[original_index] = true;\\n        }\\n        return ans;\\n    }\\n};\\n\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n   \\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n       \\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n       \\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n       \\n        if (ulp_u == ulp_v)\\n            return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n       \\n        if (ulp_u == ulp_v)\\n            return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467654,
                "title": "sorting-union-find-c",
                "content": "# Code\\n```\\nclass UnionFind {\\n    vector<int> parent, rank;\\n    public:\\n        UnionFind(int size){\\n            parent.resize(size);\\n            rank.resize(size, 0);\\n            for(int i=0; i<size; i++){\\n                parent[i] = i;\\n            }\\n        }\\n\\n        int find(int node){\\n            if (parent[node] != node){\\n                parent[node] = find(parent[node]);\\n            }\\n            return parent[node];\\n        }\\n\\n        void union_(int node1, int node2){\\n            int parent1 = find(node1);\\n            int parent2 = find(node2);\\n            if (parent1 == parent2){\\n                return;\\n            }else if (rank[parent1] < rank[parent2]){\\n                parent[parent1] = parent2; \\n            }else if (rank[parent2] < rank[parent1]){\\n                parent[parent2] = parent1;\\n            }else{\\n                parent[parent1] = parent2;\\n                rank[parent2]++;\\n            }\\n        }\\n\\n        bool areConnected(int node1, int node2){\\n            int parent1 = find(node1);\\n            int parent2 = find(node2);\\n            return (parent1 == parent2);\\n        }\\n};\\nclass Solution {\\npublic:\\n    bool static compare(vector<int>& a, vector<int>& b) {\\n        return a[2] < b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int qn = queries.size();\\n        UnionFind uf(n);\\n        for(int i=0; i<qn; i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), compare);\\n        sort(edgeList.begin(), edgeList.end(), compare);\\n        int edgeIdx = 0;\\n        vector<bool> ans(qn);\\n        for(int i=0; i<qn; i++){\\n            int node1 = queries[i][0];\\n            int node2 = queries[i][1];\\n            int limit = queries[i][2];\\n            int idx = queries[i][3];\\n            while(edgeIdx<edgeList.size() && edgeList[edgeIdx][2] < limit){\\n                uf.union_(edgeList[edgeIdx][0], edgeList[edgeIdx][1]);\\n                edgeIdx++;\\n            }\\n            ans[idx] = uf.areConnected(node1, node2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Sorting"
                ],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent, rank;\\n    public:\\n        UnionFind(int size){\\n            parent.resize(size);\\n            rank.resize(size, 0);\\n            for(int i=0; i<size; i++){\\n                parent[i] = i;\\n            }\\n        }\\n\\n        int find(int node){\\n            if (parent[node] != node){\\n                parent[node] = find(parent[node]);\\n            }\\n            return parent[node];\\n        }\\n\\n        void union_(int node1, int node2){\\n            int parent1 = find(node1);\\n            int parent2 = find(node2);\\n            if (parent1 == parent2){\\n                return;\\n            }else if (rank[parent1] < rank[parent2]){\\n                parent[parent1] = parent2; \\n            }else if (rank[parent2] < rank[parent1]){\\n                parent[parent2] = parent1;\\n            }else{\\n                parent[parent1] = parent2;\\n                rank[parent2]++;\\n            }\\n        }\\n\\n        bool areConnected(int node1, int node2){\\n            int parent1 = find(node1);\\n            int parent2 = find(node2);\\n            return (parent1 == parent2);\\n        }\\n};\\nclass Solution {\\npublic:\\n    bool static compare(vector<int>& a, vector<int>& b) {\\n        return a[2] < b[2];\\n    }\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        int qn = queries.size();\\n        UnionFind uf(n);\\n        for(int i=0; i<qn; i++){\\n            queries[i].push_back(i);\\n        }\\n        sort(queries.begin(), queries.end(), compare);\\n        sort(edgeList.begin(), edgeList.end(), compare);\\n        int edgeIdx = 0;\\n        vector<bool> ans(qn);\\n        for(int i=0; i<qn; i++){\\n            int node1 = queries[i][0];\\n            int node2 = queries[i][1];\\n            int limit = queries[i][2];\\n            int idx = queries[i][3];\\n            while(edgeIdx<edgeList.size() && edgeList[edgeIdx][2] < limit){\\n                uf.union_(edgeList[edgeIdx][0], edgeList[edgeIdx][1]);\\n                edgeIdx++;\\n            }\\n            ans[idx] = uf.areConnected(node1, node2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467650,
                "title": "sorting-and-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a particular query we only need to look on the edges that have length less than the limit. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf we arrange the `edgeList` and `queries` in increasing order, then for a query we only join the edges in the graph which have their length less than limit. After joining them, we now check for the query.\\n# Complexity\\n- Time complexity: $$O(Nlog(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        edgeList.sort(key = lambda x : x[2])\\n        queries = sorted([(i,q) for i,q in enumerate(queries)],key = lambda x : x[1][2])\\n        \\n        uf = union_find(n)\\n        k = 0\\n        ans = [0]*len(queries)\\n        for i,query in queries:\\n            limit = query[2]\\n            while k < len(edgeList) and edgeList[k][2] < limit:\\n                uf.union(edgeList[k][0],edgeList[k][1])\\n                k += 1\\n            ans[i] = uf.find(query[0]) == uf.find(query[1])\\n\\n        return ans\\n\\nclass union_find:\\n    def __init__(self,size):\\n        self.n = size\\n        self.parent = []\\n        self.rank = []\\n        for i in range(size):\\n            self.parent.append(i)\\n            self.rank.append(1)\\n    \\n    def find(self,x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self,a,b):\\n        x = self.find(a)\\n        y = self.find(b)\\n        if x == y:\\n            return\\n\\n        if self.rank[x] > self.rank[y]:\\n            self.parent[y] = x\\n        elif self.rank[x] < self.rank[y]:\\n            self.parent[x] = y\\n        else:\\n            self.parent[x] = y\\n            self.rank[y] += 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def distanceLimitedPathsExist(self, n: int, edgeList: List[List[int]], queries: List[List[int]]) -> List[bool]:\\n        edgeList.sort(key = lambda x : x[2])\\n        queries = sorted([(i,q) for i,q in enumerate(queries)],key = lambda x : x[1][2])\\n        \\n        uf = union_find(n)\\n        k = 0\\n        ans = [0]*len(queries)\\n        for i,query in queries:\\n            limit = query[2]\\n            while k < len(edgeList) and edgeList[k][2] < limit:\\n                uf.union(edgeList[k][0],edgeList[k][1])\\n                k += 1\\n            ans[i] = uf.find(query[0]) == uf.find(query[1])\\n\\n        return ans\\n\\nclass union_find:\\n    def __init__(self,size):\\n        self.n = size\\n        self.parent = []\\n        self.rank = []\\n        for i in range(size):\\n            self.parent.append(i)\\n            self.rank.append(1)\\n    \\n    def find(self,x):\\n        if self.parent[x] == x:\\n            return x\\n        self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self,a,b):\\n        x = self.find(a)\\n        y = self.find(b)\\n        if x == y:\\n            return\\n\\n        if self.rank[x] > self.rank[y]:\\n            self.parent[y] = x\\n        elif self.rank[x] < self.rank[y]:\\n            self.parent[x] = y\\n        else:\\n            self.parent[x] = y\\n            self.rank[y] += 1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1876513,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876497,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876472,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876464,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876459,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876502,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876741,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1567566,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876536,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1877154,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876513,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876497,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876472,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876464,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876459,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876502,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876741,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1567566,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876536,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1877154,
                "content": [
                    {
                        "username": "shivamaggarwal513",
                        "content": "# Hint 1\nForget about multiple edges between two nodes. They are just to confuse. If we want the weight to be less than $limit$, just check with the minimum weight. We can always traverse $a \\leftrightarrow b$ via minimum weighted edge if $minWeight < limit$.\n\n# Hint 2\nNormal traversal from source to destination for each query will be TLE. What is the redundant work? If we could traverse $1-2-3-4$ with $limit=10$, then we can also traverse from any source to destination pair in $[1,2,3,4]$ with $limit \\ge 10$.\n\n# Hint 3\nSo, for a specific $queries[i]$, assume there is a copy of the given graph but it has only those edges which has $weight < limit$. Then we can check if there is a path from source to destination, or in other words, whether source and destination belong to same component or not. What happens when we increase the $limit$?\n\n# Hint 4\nWhen we were able to traverse $1-2-3-4$ with $limit=10$, suppose there was one edge $1 \\leftrightarrow 5$ with $weight=11$, and we were not able to use it to reach $5$. But if $limit$ is increased to $12$, then we can use it to go $1-5$ and subsequently any source to destination pair in $[1,2,3,4,5]$.\n\n# Hint 5\nWhen $limit$ is increased, we can still use all the edges that were there in our copied graph. But we can use even more edges that has $weight$ where $oldLimit \\le weight < newLimit$. We can add these new edges that could not be used earlier, in our copied graph and check for a path again. To do this, we would like to have $queries$ and $edgeList$ sorted with $weight$ or $limit$. But, before sorting $queries$, don't forget to store their original indices for final result array.\n\n# Hint 6\nLooks like we are still doing traversal in copied graph to check for path on same nodes again and again. How can we quickly check if two nodes belong to the same component in the copied graph? We can make Disjoint Sets of components and check for their parents (See [this](https://leetcode.com/discuss/general-discussion/1072418/Disjoint-Set-Union-(DSU)Union-Find-A-Complete-Guide) if you want to learn DSU). For an increased $limit$, take union of those disjoint sets for those new edges.\n\nUpvote if helps!"
                    },
                    {
                        "username": "juleshwar",
                        "content": "Thanks for these verbose stage-wise hints! I only took the hints I needed and solved the question. I got the satisfaction of solving the question myself!"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@dwsyip](/dwsyip) I can\\'t do it at first glance. Try to think for what work we are doing again in brute force. If we can traverse the component $1-2-3-4$ with $limit=k$, then if next query asks for same component nodes and a $limit > k$, then why are we calculating again? If we have calculated that all edges in that component are already smaller than some smaller limit, then they will also be smaller than some bigger limit. So this way we can use the old calculated result but we need them sorted by $limit$ to do this.\\nNow if we sorted $queries$ by $limit$, then let\\'s say we calculated for $limit=k$, and want to calculate for $limit=k+x$. We need to add edges with $weight \\\\in [k,k+x)$. So, to find these edges, we will traverse on complete $edgeList$ array checking the condition on every edge. Or we could also sort it by $weight$ initially, and keep a global pointer out of the loop which can tell us that we have added edges till this index already, no need to traverse on them and check again for next query."
                    },
                    {
                        "username": "dwsyip",
                        "content": "[@Shivam Aggarwal](/shivamaggarwal513)\\nThanks! This is exactly what I need to learn to solve hard question. The sorting for queries and edges are great hint here. Just wondering how do you even thought of the optimization to sort both queries and edges at first glance?"
                    },
                    {
                        "username": "shivamaggarwal513",
                        "content": "[@jumadaru](/jumadaru) Yes, we have to add new edges to same cloned graph. You can send your code."
                    },
                    {
                        "username": "jumadaru",
                        "content": "[@jumadaru](/jumadaru) it is necesary to create a dict of limits for every query to use the same \"cloned\" graph without copy?"
                    },
                    {
                        "username": "jumadaru",
                        "content": "I did all you said and time is exceeded from the 14th case.\\n\\nEven I stop the loop if there weren\\'t new edges..."
                    },
                    {
                        "username": "Dal_Makhani",
                        "content": "At this point, all the people who solve daily leetcode problems should be awarded a Masochist Badge"
                    },
                    {
                        "username": "Maang-io",
                        "content": "So, till now, I had been avoiding Union Set, Union Find, but it seems now I have to learn this. I am going to spend more time on learning it. \nHit Upvote, if you want me to make a video explaining it via different problems at LeetCode and publish it on youtube"
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "LC trying so hard to end the streak."
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "Fr:)"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "So many hard questions these two weeks?"
                    },
                    {
                        "username": "ReTrisolaris",
                        "content": "[@ilya-chumakov](/ilya-chumakov) I\\'ve definitely seen much easier months. This month is definitely tough."
                    },
                    {
                        "username": "ilya-chumakov",
                        "content": "how many hard questions per month are usual?"
                    },
                    {
                        "username": "wangchenmeng09",
                        "content": "Three weeks, actually"
                    },
                    {
                        "username": "joseph261059",
                        "content": "Don't be afraid to sort. Once you know sorting and union-find, you can nail this question quickly"
                    },
                    {
                        "username": "Maverick767",
                        "content": "Yup, without this the question is kinda impossible. This was one of the few times I felt like the hints actually helped a lot "
                    },
                    {
                        "username": "Rapethor",
                        "content": "LET ME HAVE A GOOD WEEKEND FOR ONCE"
                    },
                    {
                        "username": "thomaslin000",
                        "content": "My thoughts for the problem were:\\n\\n1. Use a HashMap<Integer, HashSet<Integer>>  to represent nodes as key, and all nodes connected to it as the value.\\n2. Use a HashMap<String, List<Integer>> to represent connections from node A to node B, stylized as key \"A_B\" and list of distances of edges between those two nodes.\\n3. DFS from each start node in query to try and reach end node, and if you do , return true. \\n\\nLooking at the discussion, nobody even bothered with DFS, which leads me to believe it is not just faulty code, but also just fundamentally incorrent logic. Can somebody help me understand why this kind of question would not be DFS? Thanks."
                    },
                    {
                        "username": "Sarfraz-droid",
                        "content": "I was doing the same thing :/"
                    },
                    {
                        "username": "haimbender",
                        "content": "it\\'s cuz for each DFS you are only solving the problem for one query, with union find you can solve it for all the queries"
                    },
                    {
                        "username": "vnk01",
                        "content": "implement this in java is brutal \\uD83E\\uDD2E"
                    },
                    {
                        "username": "CoolBud",
                        "content": "This question was just epic. Had to look through solutions but nevertheless it was an amazing learning experience."
                    }
                ]
            },
            {
                "id": 1876699,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1876494,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1568491,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1877471,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1876665,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1876485,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1876466,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1574707,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 2039244,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 2010977,
                "content": [
                    {
                        "username": "aditya__r",
                        "content": "why the last testcase is empty? \\nI am getting TLE. Am I missing any edge case??"
                    },
                    {
                        "username": "uber6707",
                        "content": "Same"
                    },
                    {
                        "username": "shivkar2n",
                        "content": "Same here, why is the last testcase blank?"
                    },
                    {
                        "username": "blinov",
                        "content": "were you able to figure it out? I\\'m also getting 23/23 passed, but TLE"
                    },
                    {
                        "username": "harshsinghrajput",
                        "content": "Can someone explain me the second example? There is not 14 anywhere in the path so how it is valid and for q second query also"
                    },
                    {
                        "username": "tingyugenius",
                        "content": "the limitation means distance must less than this number so case 1 all path\\'s distances is ok, but in case 2  3 -> 4 distance equals 13, so it\\'s false"
                    },
                    {
                        "username": "xfourssea",
                        "content": "Example 1: \\nInput: n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]\\nFor the second query, [0,2,5],  there is a path (0 -> 1 -> 2) of two edges with distances 2+4=6 which is greater than 5, thus we return **False**.\\n\\nexmaple 2, the dp matrix[i][j]: i is starting index, j is ending index should be:\\n\\n[0, 10, 15, 24, 37], \\n[0, 0, 5, 14, 27], \\n[0, 0, 0, 9, 22], \\n[0, 0, 0, 0, 13], \\n[0, 0, 0, 0, 0]\\nFor  queries = [[0,4,14],[1,4,13]]\\n\\n0->1->2->3->4 total edge length should be 37.\\n1->2->3->4 total edge length should be 27\\nthuse should be False for both queries.\\n\\nDid I misunderstand anything?\\n\\n"
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I thought the same way, it would have been easy if it was the way I thought it was. But [@Charles Scales](/cscales) is right, we have to check each edge between two nodes that satisfies the condition in query."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Not totally length, just the max length"
                    },
                    {
                        "username": "cscales",
                        "content": "I thought the same thing as well. But I noticed after reading it carefully that it says EACH edge has to be less than the limit so it\\'s not a total length. "
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "this problem slaps harder than my mom"
                    },
                    {
                        "username": "zhhackk",
                        "content": "Have not solved it yet, but like it already. There should be a \\'very hard\\' category. "
                    },
                    {
                        "username": "Casardo",
                        "content": "leetcode aint getting  us have fun at weekends anymore hahaha... good luck for us"
                    },
                    {
                        "username": "JParks1982",
                        "content": "Getting really sick of seeing all these hard problems on consecutive days and on weekends. I may just cancel my membership..."
                    },
                    {
                        "username": "JParks1982",
                        "content": "[@daring-calf](/daring-calf) Why don\\'t you \"chill\"? Lol. Just making a remark, get over it."
                    },
                    {
                        "username": "daring-calf",
                        "content": "LOL chill, dude"
                    },
                    {
                        "username": "himv1998",
                        "content": "Or could you help me in learning how to use DSU \\nI am finding it difficult to understand"
                    },
                    {
                        "username": "Charles1791",
                        "content": "at first glance, hmmm, dijkstra algorithm would solve it\\nwhat? there are multiple queries? ok, then bellman-ford algorithm.\\n\\nwhen I tried nearly 45min to implement a bellman-ford algorithm, I got TLE...\\n\\nI was like: \"why would you do this to me?\""
                    },
                    {
                        "username": "rawatvishal",
                        "content": "this question is goated . so much of thinking!"
                    }
                ]
            },
            {
                "id": 1905789,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1878247,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1878246,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1877446,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1876796,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1876785,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1876782,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1876757,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1876736,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            },
            {
                "id": 1876685,
                "content": [
                    {
                        "username": "Tushar_Tushar",
                        "content": "anyone looking for brute force approach\\n\\nclass Solution {\\npublic:\\n\\nbool dfs(vector<pair<int,int>> adj[] , int start_node , int end_node , int lim , vector<bool> &visited){\\n\\n    if(start_node == end_node)return true;\\n\\n    visited[start_node] = true;\\n\\n    for(auto it : adj[start_node]){\\n        if(!visited[it.first] && it.second < lim){\\n            if(dfs(adj , it.first , end_node , lim , visited))return true;\\n        }\\n    }\\n    return false;\\n}\\n\\n\\n\\nvector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n    \\n    vector<pair<int,int>>adj[n+1];\\n\\n    for(int i=0 ; i<edgeList.size() ; i++){\\n        int u = edgeList[i][0];\\n        int v = edgeList[i][1];\\n        int dis = edgeList[i][2];\\n        adj[u].push_back({v , dis});\\n        adj[v].push_back({u , dis});\\n    }\\n\\n    vector<bool>ans;\\n\\n\\n    //O(Q*(V + E))\\n\\n    for(int i=0 ; i<queries.size() ; i++){\\n\\n        int p = queries[i][0];\\n        int q = queries[i][1];\\n        int lim = queries[i][2];\\n\\n        vector<bool>visited(n+1 , false);\\n        bool temp = dfs(adj , p , q , lim , visited);\\n\\n        ans.push_back(temp);\\n\\n    }\\n\\n    return ans;\\n\\n    \\n\\n    }\\n};\\n"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "after a day of procrastination i finally did it \\noffline queries +disjoint set +connected components"
                    },
                    {
                        "username": "escopablobar",
                        "content": "Annoys me big time the ratio between edges and queries are unknown. It makes a huge difference if one has infintely many edges and a small number of queries or the other way around, or similar amounts of both. I guess it\\'s never random, assuming this code has any actual use."
                    },
                    {
                        "username": "rapidcoder1609",
                        "content": "Hard questions on weekends should be banned"
                    },
                    {
                        "username": "adi29raj",
                        "content": "Yesterday everyone was like \"Ohh this should not be in hard category, medium at its best day\"...Guess what..leetcode strikes"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A weekend for dsu?"
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "For folks who where able to solve this, what specific attribute of the question screamed that you had to use the following technique\\n\\n1) sort the query and work with least weight as possible\\n2) we have to use union find concept here3\\n3) only work with edges that is less than given limit - so smart but did not see this.\\n\\nFor me, the part \\'reuse result from previous\\' query stood out since the query they gave us was an array. My mind went, there must be way to \\'use result from each query and store something, maybe store minimum distance to reach the destination ?\""
                    },
                    {
                        "username": "jimplank",
                        "content": "When I see a connectivity problem, my first two thoughts are always DFS and Disjoint Sets.  When I can frame it as incremental connectivity, then I go to Disjoint Sets first.  That was the case with this problem."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@solojavadev](/solodjavadev91) Regarding pt3, even I had issues finding this but what makes this more obvious is that the number of queries is huge, we can not afford to do union find again and again and see if the nodes are in a connected component. And then the LC hint talks about avoiding re-computation so it became more obvious that we need to consider only some edges, then use that result for bigger problem which has more edges added."
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "Stuck at the second example, how the F is 0 - > 4 less than 14 when it clearly show in the image 0 > 1 > 2 > 3 > 4, the weight between the node aggregate over 14! \\nI have yet to solve it ..."
                    },
                    {
                        "username": "DisquitingFridge",
                        "content": "Consider the question again carefully. You\\'re not asked to use the sum of edge weights between the nodes."
                    },
                    {
                        "username": "priyanshu8751",
                        "content": "Extreme hard !!!\n"
                    },
                    {
                        "username": "vivek_20",
                        "content": "class Solution {\\npublic:\\nvector<int>parent;\\nvector<int>sz;\\nstatic bool mycom(vector<int> a1, vector<int> a2){\\n\\n    return a1[2]<a2[2];\\n}\\n\\n\\nint  find_set(int a){\\n    if(parent[a]==a){\\n        return a;\\n    }\\n\\n    return find_set(parent[a]);\\n}\\n\\n\\nvoid make_set(int a,int b){\\n    a=find_set(a);\\n    b=find_set(b);\\n\\n    if(a!=b){\\n\\n        if(sz[a]<sz[b]){\\n            swap(a,b);\\n        }\\n\\n        parent[b]=a;\\n        sz[a]+=sz[b];\\n    }\\n}\\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\\n        \\n         parent= vector<int>(n,0);\\n\\n         sz=vector<int>(n,1);\\n          for(int i=0;i<n;i++){\\n              parent[i]=i;\\n\\n          }\\n\\n          for(int i=0;i<queries.size();i++){\\n              queries[i].push_back(i);\\n          }\\n\\n          vector<bool > ans(queries.size(),0);\\n\\n          sort(edgeList.begin(),edgeList.end(),mycom);\\n          sort(queries.begin(),queries.end(),mycom);\\n     \\n\\n     int i=0;\\n\\n     for(auto j: queries){\\n\\n         int comp=j[2];\\n\\n         while(i<edgeList.size() and edgeList[i][2]<comp){\\n             make_set(edgeList[i][0],edgeList[i][1]);\\n             i++;\\n         }\\n\\n         if(find_set(j[0])==find_set(j[1])){\\n             ans[j[3]]=true;\\n         }else{\\n              ans[j[3]]=false;\\n         }\\n     }\\n\\n\\n     return ans;\\n         \\n\\n\\n        \\n\\n\\n\\n    }\\n};\\n\\n\\nwhy is tle there "
                    }
                ]
            }
        ]
    }
]